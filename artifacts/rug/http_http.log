ChatCompletion(id='chatcmpl-BclZQFYkWWC9h9eE5WUibAtVmYch9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_into_iter_empty_header_map() {\n        let map: HeaderMap = HeaderMap::new();\n        let mut iter = map.into_iter();\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_single_entry() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        \n        let mut iter = map.into_iter();\n        assert_eq!(iter.next(), Some((Some(HOST), "example.com".parse().unwrap())));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_multiple_entries() {\n        let mut map = HeaderMap::new();\n        map.append(HOST, "example.com".parse().unwrap());\n        map.append(HOST, "example.org".parse().unwrap());\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut iter = map.into_iter();\n        assert_eq!(iter.next(), Some((Some(HOST), "example.com".parse().unwrap())));\n        assert_eq!(iter.next(), Some((None, "example.org".parse().unwrap())));\n        assert_eq!(iter.next(), Some((Some(CONTENT_LENGTH), "123".parse().unwrap())));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_multiple_values_per_key() {\n        let mut map = HeaderMap::new();\n        map.append(HOST, "example.com".parse().unwrap());\n        map.append(HOST, "example.org".parse().unwrap());\n        map.append(HOST, "example.net".parse().unwrap());\n\n        let mut iter = map.into_iter();\n        assert_eq!(iter.next(), Some((Some(HOST), "example.com".parse().unwrap())));\n        assert_eq!(iter.next(), Some((None, "example.org".parse().unwrap())));\n        assert_eq!(iter.next(), Some((None, "example.net".parse().unwrap())));\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579024, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=455, prompt_tokens=13063, total_tokens=13518, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZcc8JCpOf3TVMSgTKXUHK9oH6U', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, InvalidHeaderName, CONTENT_LENGTH};\n\n    #[test]\n    fn test_as_str_standard_header() {\n        let header = HeaderName::from_static("content-length");\n        assert_eq!(header.as_str(), "content-length");\n    }\n\n    #[test]\n    fn test_as_str_custom_header() {\n        let custom_header = HeaderName::from_lowercase(b"custom-header").unwrap();\n        assert_eq!(custom_header.as_str(), "custom-header");\n    }\n\n    #[test]\n    fn test_as_str_empty_header() {\n        let header_result = HeaderName::from_str("");\n        assert!(header_result.is_err());\n    }\n\n    #[test]\n    fn test_as_str_invalid_header() {\n        let header_result = HeaderName::from_str("Invalid Header");\n        assert!(header_result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579036, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=189, prompt_tokens=4224, total_tokens=4413, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZiN0x6IRbKBoiOZHxrAl9yoAVw', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, HeaderMap, CONTENT_LENGTH};\n    \n    #[test]\n    fn test_find_existing_header() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        let header_name = HeaderName::from_static("content-length");\n        \n        assert_eq!(header_name.find(&map), Some((0, 0))); // Adjust indices according to the internal structure\n    }\n    \n    #[test]\n    fn test_find_non_existing_header() {\n        let map = HeaderMap::new();\n        let header_name = HeaderName::from_static("non-existent-header");\n        \n        assert_eq!(header_name.find(&map), None);\n    }\n    \n    #[test]\n    fn test_find_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.append(CONTENT_LENGTH, "123".parse().unwrap());\n        map.append(CONTENT_LENGTH, "456".parse().unwrap());\n        let header_name = HeaderName::from_static("content-length");\n        \n        assert_eq!(header_name.find(&map), Some((0, 0))); // Adjust indices according to the internal structure\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579042, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=261, prompt_tokens=16361, total_tokens=16622, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZqrybRXulX8seCxIgF1YU1ue2h', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn test_try_entry() {\n        let mut map = HeaderMap::new();\n        let header_name = HeaderName::from_static("x-custom-header");\n        \n        // Attempt to insert a value for the header name\n        let entry_result = header_name.try_entry(&mut map);\n        \n        assert!(entry_result.is_ok());\n\n        // Check if the entry is vacant and insert a value\n        let entry = entry_result.unwrap();\n        assert!(matches!(entry, Entry::Vacant(_)));\n\n        // Insert value and check if it\'s stored\n        map.insert(header_name.clone(), "value".to_string());\n        assert_eq!(map.get(&header_name).unwrap(), "value");\n        \n        // Verify entry is now occupied\n        let occupied_entry_result = header_name.try_entry(&mut map);\n        assert!(occupied_entry_result.is_ok());\n        assert!(matches!(occupied_entry_result.unwrap(), Entry::Occupied(_)));\n    }\n\n    #[test]\n    fn test_try_entry_error() {\n        let mut map = HeaderMap::new();\n        let header_name = HeaderName::from_static("x-custom-header");\n        \n        // Fill the HeaderMap to reach max capacity\n        for i in 0..10 {\n            map.insert(HeaderName::from_static(&format!("header-{}", i)), i);\n        }\n\n        // Attempt to insert a new header when max capacity reached\n        let entry_result = header_name.try_entry(&mut map);\n        \n        // Since this is a test, we should expect an error\n        assert!(entry_result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579050, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=351, prompt_tokens=16361, total_tokens=16712, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZzQtCVxmeEwjJ1n2rXixgfnzYC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, CONTENT_TYPE};\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_try_append_new_key() {\n        let mut map = HeaderMap::new();\n        let result = HeaderName::from_static("X-Custom-Header").try_append(&mut map, "value1");\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n        assert_eq!(map.get("X-Custom-Header").unwrap(), &"value1");\n    }\n\n    #[test]\n    fn test_try_append_existing_key() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "100");\n        let result = CONTENT_LENGTH.try_append(&mut map, "200");\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n        assert_eq!(map.get_all(CONTENT_LENGTH).iter().count(), 2);\n    }\n\n    #[test]\n    fn test_try_append_with_capacity() {\n        let mut map = HeaderMap::with_capacity(10);\n        let result = CONTENT_TYPE.try_append(&mut map, "application/json");\n        assert!(result.is_ok());\n        assert!(!result.unwrap());\n        assert_eq!(map.get(CONTENT_TYPE).unwrap(), &"application/json");\n    }\n\n    #[test]\n    fn test_try_append_failure_due_to_capacity() {\n        let mut map = HeaderMap::with_capacity(1);\n        map.try_append(CONTENT_LENGTH, "100").unwrap();\n        let result = CONTENT_LENGTH.try_append(&mut map, "200");\n        assert!(result.is_ok());\n        assert!(result.unwrap());  // This indicates that 200 was appended successfully\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579059, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=366, prompt_tokens=16361, total_tokens=16727, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaCP1XJ7El9k9wCQjn4zBSZv1uv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, HEADER_NAME};\n    use http::HeaderMap;\n\n    #[test]\n    fn test_try_entry_success() {\n        let mut map = HeaderMap::new();\n        let header_name = HeaderName::from_static("x-custom-header");\n\n        map.insert(header_name.clone(), "value1");\n\n        let entry = header_name.try_entry(&mut map).unwrap();\n        assert_eq!(entry.insert("value2"), None);\n        assert_eq!(map.get(&header_name).unwrap(), "value2");\n    }\n\n    #[test]\n    fn test_try_entry_not_found() {\n        let mut map = HeaderMap::new();\n        let header_name = HeaderName::from_static("x-custom-header");\n\n        let result = header_name.try_entry(&mut map);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_entry_with_existing_header() {\n        let mut map = HeaderMap::new();\n        let header_name = HeaderName::from_static("x-custom-header");\n\n        map.insert(header_name.clone(), "value1");\n\n        let entry = header_name.try_entry(&mut map).unwrap();\n        assert_eq!(entry.insert("value2"), None);\n        assert_eq!(map.get(&header_name).unwrap(), "value2");\n    }\n\n    #[test]\n    fn test_try_entry_max_size_reached() {\n        let mut map = HeaderMap::with_capacity(1); // Set low capacity\n        let header_name = HeaderName::from_static("x-custom-header");\n\n        map.insert(header_name.clone(), "value1");\n\n        // Force the map to reach maximum capacity\n        assert!(map.try_insert(header_name.clone(), "value2").is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579072, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=371, prompt_tokens=16361, total_tokens=16732, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaNK0Cu9vqREea46oPjPVKv5Jfg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n\n    #[test]\n    fn test_try_insert() {\n        let mut map = HeaderMap::new();\n        let header_name = HeaderName::from_static("x-custom-header");\n\n        // Try inserting a value when the map is empty\n        let result = header_name.try_insert(&mut map, "value1".to_string()).unwrap();\n        assert!(result.is_none(), "Expected None when inserting a new key");\n\n        // Verify the value is now present in the map\n        assert_eq!(map.get(&header_name), Some(&"value1".to_string()));\n\n        // Try inserting a new value for the same key\n        let result = header_name.try_insert(&mut map, "value2".to_string()).unwrap();\n        assert_eq!(result, Some("value1".to_string()), "Expected to get the previous value");\n        \n        // Verify the value in the map is updated\n        assert_eq!(map.get(&header_name), Some(&"value2".to_string()));\n    }\n\n    #[test]\n    fn test_try_insert_exceed_capacity() {\n        let mut map = HeaderMap::with_capacity(1);\n        let header_name = HeaderName::from_static("x-custom-header");\n        \n        let _ = header_name.try_insert(&mut map, "value1".to_string()).unwrap();\n        \n        // Ensure the first insertion is successful\n        assert_eq!(map.get(&header_name), Some(&"value1".to_string()));\n\n        // Inserting a second value should exceed capacity\n        let result = header_name.try_insert(&mut map, "value2".to_string());\n        assert!(result.is_err(), "Expected an error when exceeding capacity");\n    }\n\n    #[test]\n    fn test_try_insert_with_different_types() {\n        let mut map = HeaderMap::new();\n        let header_name = HeaderName::from_static("x-custom-header");\n\n        // Try inserting a value with a different type\n        let result = header_name.try_insert(&mut map, 5u32).unwrap();\n        assert!(result.is_none(), "Expected None when inserting a new key");\n\n        assert_eq!(map.get(&header_name), Some(&5u32));\n\n        // Try inserting a new value for the same key\n        let result = header_name.try_insert(&mut map, 10u32).unwrap();\n        assert_eq!(result, Some(5u32), "Expected to get the previous value");\n\n        assert_eq!(map.get(&header_name), Some(&10u32));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579083, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=543, prompt_tokens=16361, total_tokens=16904, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclad7b9xurNHfJ4dYIvamTdylGIc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use header::name::HeaderName;\n    \n    #[test]\n    fn test_eq_same_header() {\n        let header1 = HeaderName::from_static("content-length");\n        let header2 = HeaderName::from_static("content-length");\n        assert!(header1.eq(&header2), "Headers should be equal");\n    }\n\n    #[test]\n    fn test_eq_different_headers() {\n        let header1 = HeaderName::from_static("content-length");\n        let header2 = HeaderName::from_static("content-type");\n        assert!(!header1.eq(&header2), "Headers should not be equal");\n    }\n\n    #[test]\n    fn test_eq_case_insensitive() {\n        let header1 = HeaderName::from_static("content-length");\n        let header2 = HeaderName::from_static("Content-Length");\n        assert!(header1.eq(&header2), "Headers should be equal (case insensitive)");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579099, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=207, prompt_tokens=4229, total_tokens=4436, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclalcMwjhLJSpcH6gYW23GEnzNWG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_header_value_eq_same_value() {\n        let val1 = HeaderValue::from_static("test");\n        let val2 = HeaderValue::from_static("test");\n        assert!(val1.eq(&val2));\n    }\n\n    #[test]\n    fn test_header_value_eq_different_value() {\n        let val1 = HeaderValue::from_static("test");\n        let val2 = HeaderValue::from_static("different");\n        assert!(!val1.eq(&val2));\n    }\n\n    #[test]\n    fn test_header_value_eq_with_string() {\n        let val = HeaderValue::from_static("test");\n        let str_value = String::from("test");\n        assert!(val.eq(&str_value));\n    }\n\n    #[test]\n    fn test_header_value_eq_with_bytes() {\n        let val = HeaderValue::from_static("test");\n        let byte_value: &[u8] = b"test";\n        assert!(val.eq(&byte_value));\n    }\n\n    #[test]\n    fn test_header_value_eq_with_str() {\n        let val = HeaderValue::from_static("test");\n        let str_value: &str = "test";\n        assert!(val.eq(&str_value));\n    }\n\n    #[test]\n    fn test_header_value_eq_different_type() {\n        let val = HeaderValue::from_static("test");\n        let different: &str = "not_test";\n        assert!(!val.eq(&different));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579107, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=327, prompt_tokens=4452, total_tokens=4779, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclauSGe4VB98ql2sEAFyctoJ7tGt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let val1 = HeaderValue::from_static("test");\n        let val2 = HeaderValue::from_static("test");\n        assert_eq!(val1.partial_cmp(&val2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let val1 = HeaderValue::from_static("apple");\n        let val2 = HeaderValue::from_static("banana");\n        assert_eq!(val1.partial_cmp(&val2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let val1 = HeaderValue::from_static("banana");\n        let val2 = HeaderValue::from_static("apple");\n        assert_eq!(val1.partial_cmp(&val2), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_not_equal() {\n        let val1 = HeaderValue::from_static("apple");\n        let val2 = HeaderValue::from_static("apple pie");\n        assert_eq!(val1.partial_cmp(&val2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_length() {\n        let val1 = HeaderValue::from_static("short");\n        let val2 = HeaderValue::from_static("longer string");\n        assert_eq!(val1.partial_cmp(&val2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_identical_bytes() {\n        let val1 = HeaderValue::from_bytes(b"identical").unwrap();\n        let val2 = HeaderValue::from_bytes(b"identical").unwrap();\n        assert_eq!(val1.partial_cmp(&val2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_bytes() {\n        let val1 = HeaderValue::from_bytes(b"different").unwrap();\n        let val2 = HeaderValue::from_bytes(b"byte").unwrap();\n        assert!(val1.partial_cmp(&val2).is_some());\n    }\n\n    #[test]\n    fn test_partial_cmp_with_empty() {\n        let val1 = HeaderValue::from_static("");\n        let val2 = HeaderValue::from_static("not empty");\n        assert_eq!(val1.partial_cmp(&val2), Some(cmp::Ordering::Less));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579116, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=526, prompt_tokens=4460, total_tokens=4986, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclb8SmtsUElOwOT8CuQfA5jpQiEs', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_method_eq() {\n        assert_eq!(Method::GET.eq(&Method::GET), true);\n        assert_eq!(Method::GET.eq(&Method::POST), false);\n        assert_eq!(Method::GET.eq(&Method::from_bytes(b"GET").unwrap()), true);\n        assert_eq!(Method::POST.eq(&Method::from_bytes(b"POST").unwrap()), true);\n        assert_eq!(Method::GET.eq(&Method::from_bytes(b"PUT").unwrap()), false);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579130, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=128, prompt_tokens=2363, total_tokens=2491, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbEzaRArqr5HQQDs7lLitSkJLhH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Ensure to bring in the necessary items\n    use http::header::{CONTENT_LENGTH, HOST}; // Import necessary headers\n    use http::HeaderMap; // Import HeaderMap to use in tests\n\n    #[test]\n    fn test_into_iter_empty() {\n        let headers = HeaderMap::new();\n        let mut iter = headers.into_iter();\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_single() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n        let mut iter = headers.into_iter();\n\n        assert_eq!(iter.next(), Some((Some(HOST), "example.com".parse().unwrap())));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_multiple() {\n        let mut headers = HeaderMap::new();\n        headers.append(HOST, "example.com".parse().unwrap());\n        headers.append(HOST, "example.org".parse().unwrap());\n        headers.append(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut iter = headers.into_iter();\n\n        assert_eq!(iter.next(), Some((Some(HOST), "example.com".parse().unwrap())));\n        assert_eq!(iter.next(), Some((None, "example.org".parse().unwrap())));\n        assert_eq!(iter.next(), Some((Some(CONTENT_LENGTH), "123".parse().unwrap())));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_with_multiple_values() {\n        let mut headers = HeaderMap::new();\n        headers.append(HOST, "example.com".parse().unwrap());\n        headers.append(HOST, "example.org".parse().unwrap());\n        headers.append(CONTENT_LENGTH, "100".parse().unwrap());\n        headers.append(CONTENT_LENGTH, "200".parse().unwrap());\n\n        let mut iter = headers.into_iter();\n\n        assert_eq!(iter.next(), Some((Some(HOST), "example.com".parse().unwrap())));\n        assert_eq!(iter.next(), Some((None, "example.org".parse().unwrap())));\n        assert_eq!(iter.next(), Some((Some(CONTENT_LENGTH), "100".parse().unwrap())));\n        assert_eq!(iter.next(), Some((None, "200".parse().unwrap())));\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579136, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=505, prompt_tokens=13186, total_tokens=13691, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbRiD5jnWDnokGU5GDEgu2Hn7eN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::map::as_header_name::Sealed;\n\n    #[test]\n    fn test_as_str() {\n        let string = String::from("header-name");\n        let result = string.as_str();\n        assert_eq!(result, "header-name");\n    }\n\n    #[test]\n    fn test_as_str_empty() {\n        let string = String::from("");\n        let result = string.as_str();\n        assert_eq!(result, "");\n    }\n\n    #[test]\n    fn test_as_str_whitespace() {\n        let string = String::from("   ");\n        let result = string.as_str();\n        assert_eq!(result, "   ");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579149, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=152, prompt_tokens=643, total_tokens=795, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbXiUqyU4A4JH7LPJ6Wqcjdy8iD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HOST, CONTENT_LENGTH};\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_find_existing_key() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n        \n        let key: String = "host".to_string();\n        let result = key.find(&headers);\n        assert_eq!(result, Some((0, 0))); // Assuming the first index for host\n    }\n\n    #[test]\n    fn test_find_non_existing_key() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n\n        let key: String = "content-length".to_string();\n        let result = key.find(&headers);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_find_multiple_entries() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n        headers.append(HOST, "another-example.com".parse().unwrap());\n\n        let key: String = "host".to_string();\n        let result = key.find(&headers);\n        assert_eq!(result, Some((0, 0))); // Expect to find the first occurrence\n    }\n\n    #[test]\n    fn test_find_empty_headers() {\n        let headers = HeaderMap::new();\n        let key: String = "host".to_string();\n        let result = key.find(&headers);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_find_with_different_case() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n\n        let key: String = "HOST".to_string();\n        let result = key.find(&headers);\n        assert_eq!(result, Some((0, 0))); // Should find despite case difference\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579155, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=414, prompt_tokens=13053, total_tokens=13467, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbgOYV85mQGnUlfzmbHQ89WBRhN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use http::header::{HeaderName, CONTENT_TYPE, CONTENT_LENGTH};\n\n    #[test]\n    fn test_try_entry_success() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_TYPE, "application/json".parse().unwrap());\n\n        let key = String::from("Content-Type");\n        let entry = key.try_entry(&mut map).unwrap();\n        assert_eq!(entry.key().as_str(), "content-type");\n    }\n\n    #[test]\n    fn test_try_entry_nonexistent_key() {\n        let mut map = HeaderMap::new();\n        let key = String::from("Nonexistent-Key");\n        \n        match key.try_entry(&mut map) {\n            Err(TryEntryError::InvalidHeaderName) => (),\n            _ => panic!("Expected InvalidHeaderName error."),\n        }\n    }\n\n    #[test]\n    fn test_try_entry_inserts_key() {\n        let mut map = HeaderMap::new();\n        let key = String::from("X-Custom-Header");\n        \n        let entry = key.try_entry(&mut map).unwrap();\n        entry.insert("value".parse().unwrap());\n\n        assert_eq!(map.get(&entry.key()).unwrap(), "value");\n    }\n\n    #[test]\n    fn test_try_entry_max_size_reached() {\n        let mut map = HeaderMap::with_capacity(1); // assuming capacity\n        map.insert(CONTENT_LENGTH, "10".parse().unwrap());\n\n        let key = String::from("Content-Length");\n        let _ = key.try_entry(&mut map).unwrap(); // should get the entry\n\n        let _ = map.try_insert(CONTENT_LENGTH, "20".parse().unwrap()).unwrap(); // should succeed\n\n        match key.try_entry(&mut map) {\n            Err(TryEntryError::MaxSizeReached(_)) => (),\n            _ => panic!("Expected MaxSizeReached error."),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579164, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=413, prompt_tokens=13059, total_tokens=13472, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbuP6z6pQlF9h5l2m5khTcH7buz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct TestStr<\'a>(&\'a str);\n\n    impl<\'a> header::map::as_header_name::Sealed for TestStr<\'a> {\n        fn as_str(&self) -> &str {\n            self.0\n        }\n    }\n\n    #[test]\n    fn test_as_str() {\n        let test_case = TestStr("test_header_name");\n        assert_eq!(test_case.as_str(), "test_header_name");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579178, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=108, prompt_tokens=155, total_tokens=263, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclbzo7GVgXz11hYTiSy4qwXfA35z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, HOST};\n    use http::HeaderMap;\n\n    #[test]\n    fn test_find_key_present() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let header_name = HeaderName::from_static("host");\n        let result = header_name.find(&map);\n\n        assert_eq!(result, Some((0, 0)));\n    }\n\n    #[test]\n    fn test_find_key_not_present() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let header_name = HeaderName::from_static("host");\n        let result = header_name.find(&map);\n\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_find_multiple_keys() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.insert(HOST, "example.org".parse().unwrap());\n\n        let header_name = HeaderName::from_static("host");\n        let result = header_name.find(&map);\n\n        assert_eq!(result, Some((0, 0)));\n    }\n\n    #[test]\n    fn test_find_empty_map() {\n        let map = HeaderMap::new();\n        let header_name = HeaderName::from_static("host");\n        let result = header_name.find(&map);\n\n        assert_eq!(result, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579183, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=339, prompt_tokens=12579, total_tokens=12918, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcAABVihCT2pXr0tMtmRxUUlZ2D', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName, CONTENT_LENGTH};\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_entry_insert() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        \n        let key: &str = "content-length";\n        let value: String = "123".to_string();\n        \n        let entry = key.try_entry(&mut map).unwrap();\n        entry.insert(value.clone());\n        \n        assert_eq!(map.get("content-length").unwrap(), &value);\n    }\n\n    #[test]\n    fn test_try_entry_overwrite() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        \n        let key: &str = "content-length";\n        let value1: String = "123".to_string();\n        let value2: String = "456".to_string();\n        \n        let entry = key.try_entry(&mut map).unwrap();\n        entry.insert(value1.clone());\n        \n        let entry = key.try_entry(&mut map).unwrap();\n        entry.insert(value2.clone());\n        \n        assert_eq!(map.get("content-length").unwrap(), &value2);\n    }\n\n    #[test]\n    fn test_try_entry_finds_key() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        \n        let key: &str = "content-length";\n        let value: String = "123".to_string();\n        \n        let entry = key.try_entry(&mut map).unwrap();\n        entry.insert(value.clone());\n        \n        assert!(map.contains_key("content-length"));\n    }\n\n    #[test]\n    fn test_try_entry_non_existent_key() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        \n        let key: &str = "non-existent-header";\n        \n        let result = key.try_entry(&mut map);\n        assert!(result.is_ok());\n        assert!(!map.contains_key("non-existent-header"));\n    }\n\n    #[test]\n    fn test_try_entry_max_size_reached() {\n        let mut map: HeaderMap<String> = HeaderMap::with_capacity(1);\n        \n        let key1: &str = "header1";\n        let key2: &str = "header2";\n        let value: String = "value".to_string();\n        \n        let entry1 = key1.try_entry(&mut map).unwrap();\n        entry1.insert(value.clone());\n\n        // Expecting \'TryEntryError::MaxSizeReached\' when trying to insert\n        let entry2 = key2.try_entry(&mut map);\n        assert!(entry2.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579194, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=552, prompt_tokens=12591, total_tokens=13143, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcZEplqoafBDOcvIWtwvqbezKjC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, HeaderValue};\n\n    #[test]\n    fn test_into_iter() {\n        let mut map = HeaderMap::new();\n        map.insert(HeaderName::from_static("host"), HeaderValue::from_static("example.com"));\n        map.append(HeaderName::from_static("host"), HeaderValue::from_static("example.org"));\n\n        let get_all = map.get_all("host");\n        let mut iter = get_all.into_iter();\n\n        assert_eq!(iter.next(), Some(&HeaderValue::from_static("example.com")));\n        assert_eq!(iter.next(), Some(&HeaderValue::from_static("example.org")));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let map: HeaderMap<HeaderValue> = HeaderMap::new();\n        let get_all = map.get_all("non-existent-header");\n        let mut iter = get_all.into_iter();\n\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_into_iter_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.insert(HeaderName::from_static("accept"), HeaderValue::from_static("text/html"));\n        map.append(HeaderName::from_static("accept"), HeaderValue::from_static("application/json"));\n        map.append(HeaderName::from_static("accept"), HeaderValue::from_static("text/plain"));\n\n        let get_all = map.get_all("accept");\n        let mut iter = get_all.into_iter();\n\n        assert_eq!(iter.next(), Some(&HeaderValue::from_static("text/html")));\n        assert_eq!(iter.next(), Some(&HeaderValue::from_static("application/json")));\n        assert_eq!(iter.next(), Some(&HeaderValue::from_static("text/plain")));\n        assert_eq!(iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579219, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=388, prompt_tokens=13667, total_tokens=14055, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcoqeQN3nhhVA07OrSEQ9e4YXVa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, CONTENT_LENGTH};\n\n    #[test]\n    fn test_into_iter() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        headers.insert(CONTENT_LENGTH, "456".parse().unwrap());\n        \n        let mut iter = headers.entry(CONTENT_LENGTH).unwrap().into_iter();\n        \n        assert_eq!(iter.next(), Some(&mut "123".parse().unwrap()));\n        assert_eq!(iter.next(), Some(&mut "456".parse().unwrap()));\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579234, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=143, prompt_tokens=15762, total_tokens=15905, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcvhosR5PG2h5c6VKYaZ3SCwJEC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName, CONTENT_LENGTH};\n\n    #[test]\n    fn test_into_iter() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        headers.insert(CONTENT_LENGTH, "456".parse().unwrap());\n\n        if let Entry::Occupied(entry) = headers.entry("content-length").unwrap() {\n            let values: Vec<_> = entry.into_iter().map(|v| v.clone()).collect();\n            assert_eq!(values, vec!["123", "456"]);\n        } else {\n            panic!("Expected occupied entry");\n        }\n    }\n\n    #[test]\n    fn test_into_iter_no_values() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        if let Entry::Occupied(entry) = headers.entry("content-length").unwrap() {\n            entry.remove(); // Remove all values\n            let values: Vec<_> = entry.into_iter().collect();\n            assert!(values.is_empty());\n        } else {\n            panic!("Expected occupied entry");\n        }\n    }\n\n    #[test]\n    fn test_into_iter_mut() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        headers.insert(CONTENT_LENGTH, "456".parse().unwrap());\n\n        if let Entry::Occupied(mut entry) = headers.entry("content-length").unwrap() {\n            let mut values: Vec<_> = entry.iter_mut().collect();\n            assert_eq!(values.len(), 2);\n\n            // Modify values\n            for v in &mut values {\n                v.push_str("!"); // Append "!" to each value\n            }\n\n            // Validate that the values in the headers have been updated\n            let updated_values: Vec<_> = entry.iter().map(|v| v.clone()).collect();\n            assert_eq!(updated_values, vec!["123!", "456!"]);\n        } else {\n            panic!("Expected occupied entry");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579241, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=442, prompt_tokens=15775, total_tokens=16217, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcld6E6arXwz6hheww7EijapYtNll', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n    \n    #[test]\n    fn test_try_append_new_key() {\n        let mut headers = HeaderMap::new();\n        let result = CONTENT_LENGTH.try_append(&mut headers, "100".parse().unwrap());\n        assert!(result.is_ok());\n        assert_eq!(headers.get(CONTENT_LENGTH).unwrap(), &"100");\n        assert_eq!(result.unwrap(), false);\n    }\n\n    #[test]\n    fn test_try_append_existing_key() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_LENGTH, "100".parse().unwrap());\n        let result = CONTENT_LENGTH.try_append(&mut headers, "200".parse().unwrap());\n        assert!(result.is_ok());\n        assert_eq!(headers.get_all(CONTENT_LENGTH).iter().count(), 2);\n        assert_eq!(result.unwrap(), true);\n    }\n\n    #[test]\n    fn test_try_append_capacity_limit() {\n        let mut headers = HeaderMap::with_capacity(2);\n        headers.insert(CONTENT_LENGTH, "100".parse().unwrap());\n        headers.insert(HOST, "example.com".parse().unwrap());\n        \n        // Exceeding capacity\n        let result = HOST.try_append(&mut headers, "another.com".parse().unwrap());\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n        \n        // Check if the new entry was appended\n        assert_eq!(headers.get_all(HOST).iter().count(), 2);\n    }\n\n    #[test]\n    fn test_try_append_invalid_header() {\n        let mut headers = HeaderMap::new();\n        let result: Result<bool, MaxSizeReached> = "&invalid_key".try_append(&mut headers, "value".parse().unwrap());\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579252, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=385, prompt_tokens=12585, total_tokens=12970, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldHFj2bWNzH41pmoAbzWqDXeqi0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n    \n    #[test]\n    fn test_try_entry() {\n        let mut headers = HeaderMap::new();\n        let key = CONTENT_LENGTH;\n\n        // Initially, the header map should not contain the key.\n        let result = key.try_entry(&mut headers);\n        assert!(result.is_err());\n\n        // Insert a value for the key and test the entry.\n        headers.insert(key, "123".parse().unwrap());\n\n        // Attempt to get the entry for the inserted key.\n        let entry_result = key.try_entry(&mut headers);\n        assert!(entry_result.is_ok());\n\n        let entry = entry_result.unwrap();\n        // Verify that the entry can be accessed and contains the expected value.\n        assert_eq!(entry.get(), "123");\n    }\n\n    #[test]\n    fn test_try_entry_with_multiple_inserts() {\n        let mut headers = HeaderMap::new();\n        let key = HeaderName::from_static("x-custom-header");\n\n        // Initially, the header map should not contain the key.\n        let result = key.try_entry(&mut headers);\n        assert!(result.is_err());\n\n        // Insert multiple values for the key.\n        headers.insert(key.clone(), "value1".parse().unwrap());\n        headers.append(key.clone(), "value2".parse().unwrap());\n\n        // Attempt to get the entry for the inserted key.\n        let entry_result = key.try_entry(&mut headers);\n        assert!(entry_result.is_ok());\n\n        let entry = entry_result.unwrap();\n        // Verify that the entry can be accessed and contains the expected first value.\n        assert_eq!(entry.get(), "value1");\n\n        // Also, test that we can append a new value and still access the entry.\n        entry.append("value3".parse().unwrap());\n        let values = headers.get_all(key);\n        let mut iter = values.iter();\n        assert_eq!(iter.next().unwrap(), &"value1");\n        assert_eq!(iter.next().unwrap(), &"value2");\n        assert_eq!(iter.next().unwrap(), &"value3");\n    }\n\n    #[test]\n    fn test_try_entry_max_size_reached() {\n        let mut headers = HeaderMap::with_capacity(MAX_SIZE);\n        let key = CONTENT_LENGTH;\n\n        // Initially, the header map should not contain the key, and we can insert a value\n        let result = key.try_entry(&mut headers);\n        assert!(result.is_err());\n\n        // Fill the header map to its maximum size\n        for i in 0..MAX_SIZE {\n            headers.insert(HeaderName::from_static(&format!("header-{}", i)), "value".parse().unwrap());\n        }\n\n        // Now, try to insert one more header\n        let result = headers.try_insert("new-header", "new-value".parse().unwrap());\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579263, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=602, prompt_tokens=12582, total_tokens=13184, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldXXCOq1oBb6kOw7p05pAwrtnI7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_insert_new_key() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        let result = CONTENT_LENGTH.try_insert(&mut map, "123".to_string());\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), None);\n        assert_eq!(map.get(CONTENT_LENGTH), Some(&"123".to_string()));\n    }\n\n    #[test]\n    fn test_try_insert_existing_key() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".to_string());\n        let result = CONTENT_LENGTH.try_insert(&mut map, "456".to_string());\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Some("123".to_string()));\n        assert_eq!(map.get(CONTENT_LENGTH), Some(&"456".to_string()));\n    }\n\n    #[test]\n    fn test_try_insert_overflow() {\n        let mut map: HeaderMap<String> = HeaderMap::with_capacity(1);\n        CONTENT_LENGTH.try_insert(&mut map, "123".to_string()).unwrap();\n        CONTENT_LENGTH.try_insert(&mut map, "456".to_string()).unwrap(); // Existing key\n        assert!(CONTENT_LENGTH.try_insert(&mut map, "789".to_string()).is_ok());\n        \n        // Simulate max size reached\n        for _ in 0..10 {\n            map.append(HOST, "too many".to_string());\n        }\n        let result = CONTENT_LENGTH.try_insert(&mut map, "0".to_string());\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579279, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=370, prompt_tokens=12591, total_tokens=12961, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcldg37s56kFYZNY4J6aaRuZD0cws', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::any::Any;\n\n    struct TestStruct;\n\n    impl extensions::AnyClone for TestStruct {}\n\n    #[test]\n    fn test_as_any() {\n        let test_instance = TestStruct;\n\n        let any_ref: &dyn Any = test_instance.as_any();\n\n        // Ensure the returned reference can be downcast\n        let downcast_ref = any_ref.downcast_ref::<TestStruct>();\n        assert!(downcast_ref.is_some());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579288, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=109, prompt_tokens=146, total_tokens=255, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldlXfC2uJwaATw0T4hg6qMMKmEt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::any::Any;\n\n    trait AnyClone {\n        fn as_any_mut(&mut self) -> &mut dyn Any;\n    }\n\n    impl<T: Any> AnyClone for T {\n        fn as_any_mut(&mut self) -> &mut dyn Any {\n            self\n        }\n    }\n\n    #[test]\n    fn test_as_any_mut() {\n        let mut value: i32 = 42;\n        let any_mut: &mut dyn Any = value.as_any_mut();\n        let retrieved_value = any_mut.downcast_mut::<i32>().unwrap();\n        *retrieved_value += 1;\n\n        assert_eq!(*retrieved_value, 43);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579293, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=156, prompt_tokens=151, total_tokens=307, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldqikCFGFrvu0UtnNv4IoEl7WUa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::any::Any;\n\n    trait AnyClone: Any {\n        fn clone_box(&self) -> Box<dyn AnyClone + Send + Sync>;\n    }\n\n    #[derive(Clone)]\n    struct TestStruct {\n        value: i32,\n    }\n\n    impl AnyClone for TestStruct {\n        fn clone_box(&self) -> Box<dyn AnyClone + Send + Sync> {\n            Box::new(self.clone())\n        }\n    }\n\n    #[test]\n    fn test_clone_box() {\n        let original = TestStruct { value: 42 };\n        let cloned = original.clone_box();\n\n        // Check that the cloned value is what we expect\n        if let Some(cloned_struct) = cloned.downcast_ref::<TestStruct>() {\n            assert_eq!(cloned_struct.value, 42);\n        } else {\n            panic!("Cloned box is not of type TestStruct");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579298, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=201, prompt_tokens=231, total_tokens=432, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldvXaROEShwhO1Z3OBhieTl9S4l', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::any::Any;\n\n    // Assume we have a struct that implements extensions::AnyClone\n    struct TestStruct;\n\n    impl extensions::AnyClone for TestStruct {\n        fn clone_box(&self) -> Box<dyn extensions::AnyClone + Send + Sync> {\n            Box::new(TestStruct)\n        }\n    }\n\n    #[test]\n    fn test_into_any() {\n        let instance: Box<dyn extensions::AnyClone + Send + Sync> = Box::new(TestStruct);\n        let any_box: Box<dyn Any> = instance.into_any();\n        assert!(any_box.is::<TestStruct>());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579303, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=146, prompt_tokens=224, total_tokens=370, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcle2eg9CZs8PrEH8dKUrny1yuEWk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_from_str() {\n        let input = "Hello, world!";\n        let byte_str = ByteStr::from(input);\n        let expected_bytes = Bytes::copy_from_slice(input.as_bytes());\n        assert_eq!(byte_str.bytes, expected_bytes);\n    }\n\n    #[test]\n    fn test_from_empty_str() {\n        let input = "";\n        let byte_str = ByteStr::from(input);\n        let expected_bytes = Bytes::copy_from_slice(input.as_bytes());\n        assert_eq!(byte_str.bytes, expected_bytes);\n    }\n\n    #[test]\n    fn test_from_utf8_str() {\n        let input = "Rust programming";\n        let byte_str = ByteStr::from(input);\n        assert_eq!(byte_str.deref(), input);\n    }\n\n    #[test]\n    fn test_from_static_str() {\n        let input: &\'static str = "Static string";\n        let byte_str = ByteStr::from_static(input);\n        assert_eq!(byte_str.deref(), input);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579310, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=229, prompt_tokens=1032, total_tokens=1261, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcle8Z5sxvFCyMTle6zDHYboXjBsy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_from_string() {\n        let s = String::from("Hello, ByteStr!");\n        let byte_str: ByteStr = ByteStr::from(s.clone());\n        \n        assert_eq!(byte_str.deref(), s.as_str());\n        assert_eq!(byte_str.bytes, Bytes::from(s));\n    }\n\n    #[test]\n    fn test_from_empty_string() {\n        let s = String::from("");\n        let byte_str: ByteStr = ByteStr::from(s.clone());\n        \n        assert_eq!(byte_str.deref(), s.as_str());\n        assert_eq!(byte_str.bytes, Bytes::from(s));\n    }\n\n    #[test]\n    fn test_from_string_with_unicode() {\n        let s = String::from("Hello, !");\n        let byte_str: ByteStr = ByteStr::from(s.clone());\n        \n        assert_eq!(byte_str.deref(), s.as_str());\n        assert_eq!(byte_str.bytes, Bytes::from(s));\n    }\n\n    #[test]\n    fn test_from_string_with_special_characters() {\n        let s = String::from("Hello, @#$%^&*()!");\n        let byte_str: ByteStr = ByteStr::from(s.clone());\n        \n        assert_eq!(byte_str.deref(), s.as_str());\n        assert_eq!(byte_str.bytes, Bytes::from(s));\n    }\n\n    #[test]\n    fn test_from_string_with_newline() {\n        let s = String::from("Hello, \\nWorld!");\n        let byte_str: ByteStr = ByteStr::from(s.clone());\n        \n        assert_eq!(byte_str.deref(), s.as_str());\n        assert_eq!(byte_str.bytes, Bytes::from(s));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579316, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=371, prompt_tokens=1511, total_tokens=1882, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcleImfpjWeoyE5zfza7r6N0cf2ye', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_deref_empty() {\n        let byte_str = ByteStr::new();\n        assert_eq!(&*byte_str, "");\n    }\n\n    #[test]\n    fn test_deref_static() {\n        let byte_str = ByteStr::from_static("Hello, world!");\n        assert_eq!(&*byte_str, "Hello, world!");\n    }\n\n    #[test]\n    fn test_deref_from_string() {\n        let byte_str: ByteStr = String::from("Hello, Rust!").into();\n        assert_eq!(&*byte_str, "Hello, Rust!");\n    }\n\n    #[test]\n    fn test_deref_from_str() {\n        let byte_str: ByteStr = "Hello, Universe!".into();\n        assert_eq!(&*byte_str, "Hello, Universe!");\n    }\n\n    #[test]\n    fn test_deref_invalid_utf8() {\n        let bytes = Bytes::from_static(&[0, 159, 146, 150]); // An invalid UTF-8 sequence\n        let result = std::panic::catch_unwind(|| {\n            unsafe { ByteStr::from_utf8_unchecked(bytes) }\n        });\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579326, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=272, prompt_tokens=1041, total_tokens=1313, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcleP4yeVh5CLK3wSj8mF334br88j', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::MaxSizeReached;\n\n    #[test]\n    fn test_from_max_size_reached() {\n        let max_size_reached = MaxSizeReached::new();\n        let err: Error = Error::from(max_size_reached);\n\n        assert!(err.is::<MaxSizeReached>());\n        assert_eq!(err.to_string(), "max size reached");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579333, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=94, prompt_tokens=2669, total_tokens=2763, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcleU1aOqlDF3PJbZFk76RaiaygHj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use header::name::InvalidHeaderName;\n\n    #[test]\n    fn test_from_invalid_header_name() {\n        let invalid_header_name = InvalidHeaderName::new();\n        let error: Error = From::from(invalid_header_name);\n        \n        assert!(error.is::<header::InvalidHeaderName>());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579338, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=80, prompt_tokens=2670, total_tokens=2750, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcleYZDuBw0EzMzySX9hNf3TBexzO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use header::value::InvalidHeaderValue;\n\n    #[test]\n    fn test_from_invalid_header_value() {\n        let invalid_header_value = InvalidHeaderValue { _priv: () };\n        let error: Error = Error::from(invalid_header_value);\n        \n        assert!(error.is::<header::InvalidHeaderValue>());\n        assert_eq!(format!("{}", error), "failed to parse header value");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579342, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=98, prompt_tokens=2670, total_tokens=2768, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclejmX5WokcnXq01dRwFLHboooz7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::method::InvalidMethod;\n\n    #[test]\n    fn test_from_invalid_method() {\n        let invalid_method = InvalidMethod::new();\n        let error: Error = Error::from(invalid_method);\n\n        assert!(error.is::<method::InvalidMethod>());\n        assert_eq!(error.to_string(), "invalid HTTP method");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579353, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=86, prompt_tokens=2666, total_tokens=2752, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclesWPNqnZ8aKmXCQc1OZoF0Zatl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::status::InvalidStatusCode;\n\n    #[test]\n    fn test_from_invalid_status_code() {\n        let invalid_status_code = InvalidStatusCode::new();\n        let error: Error = From::from(invalid_status_code);\n        assert!(error.is::<status::InvalidStatusCode>());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579362, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=79, prompt_tokens=2669, total_tokens=2748, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclexDdKBNq6fTu9nKE0DOMziPNv8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::Infallible;\n\n    #[test]\n    fn test_from_infallible() {\n        let err: Infallible = unreachable!(); // Infallible cannot actually be instantiated\n        let result: Error = Error::from(err);\n        // We can assert that the result is of type Error\n        assert!(result.is::<Infallible>() == false);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579367, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=98, prompt_tokens=2661, total_tokens=2759, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclf1Im1tQTI6wEE49ZGN66IaFt9H', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use uri::{ErrorKind, InvalidUri};\n\n    #[test]\n    fn test_from_invalid_uri() {\n        let invalid_uri_error = InvalidUri(ErrorKind::InvalidScheme);\n        let error: Error = Error::from(invalid_uri_error);\n        \n        if let ErrorKind::Uri(inner_error) = error.inner {\n            assert_eq!(inner_error.0, ErrorKind::InvalidScheme);\n        } else {\n            panic!("Expected ErrorKind::Uri");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579371, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=113, prompt_tokens=2666, total_tokens=2779, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclf5MNAPUshXYznksalvQvAEQ7lj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use uri::{ErrorKind, InvalidUriParts};\n\n    #[test]\n    fn test_from_invalid_uri_parts() {\n        let invalid_uri_parts = InvalidUriParts(InvalidUri(ErrorKind::InvalidScheme));\n        let error: Error = Error::from(invalid_uri_parts);\n        \n        match error.get_ref().downcast_ref::<InvalidUriParts>() {\n            Some(_) => assert!(true),\n            None => assert!(false, "Error conversion failed"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579375, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=112, prompt_tokens=2669, total_tokens=2781, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfBptDxb0T33RT0GwWhzHdxC1v8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header;\n    use crate::method;\n    use crate::status;\n    use crate::uri;\n    use crate::Error;\n\n    #[test]\n    fn test_source_with_max_size_reached() {\n        let err = header::map::MaxSizeReached::new();\n        let http_error = Error::from(err);\n        assert!(http_error.source().is_some());\n        assert!(http_error.source().unwrap().is::<header::map::MaxSizeReached>());\n    }\n\n    #[test]\n    fn test_source_with_invalid_header_name() {\n        let err = header::InvalidHeaderName::new();\n        let http_error = Error::from(err);\n        assert!(http_error.source().is_some());\n        assert!(http_error.source().unwrap().is::<header::InvalidHeaderName>());\n    }\n\n    #[test]\n    fn test_source_with_invalid_header_value() {\n        let err = header::InvalidHeaderValue {};\n        let http_error = Error::from(err);\n        assert!(http_error.source().is_some());\n        assert!(http_error.source().unwrap().is::<header::InvalidHeaderValue>());\n    }\n\n    #[test]\n    fn test_source_with_invalid_method() {\n        let err = method::InvalidMethod::new();\n        let http_error = Error::from(err);\n        assert!(http_error.source().is_some());\n        assert!(http_error.source().unwrap().is::<method::InvalidMethod>());\n    }\n\n    #[test]\n    fn test_source_with_invalid_status_code() {\n        let err = status::InvalidStatusCode::new();\n        let http_error = Error::from(err);\n        assert!(http_error.source().is_some());\n        assert!(http_error.source().unwrap().is::<status::InvalidStatusCode>());\n    }\n\n    #[test]\n    fn test_source_with_invalid_uri() {\n        let err = uri::InvalidUri::from(uri::ErrorKind::InvalidScheme);\n        let http_error = Error::from(err);\n        assert!(http_error.source().is_some());\n        assert!(http_error.source().unwrap().is::<uri::InvalidUri>());\n    }\n\n    #[test]\n    fn test_source_with_invalid_uri_parts() {\n        let err = uri::InvalidUriParts(uri::InvalidUri::from(uri::ErrorKind::SchemeTooLong));\n        let http_error = Error::from(err);\n        assert!(http_error.source().is_some());\n        assert!(http_error.source().unwrap().is::<uri::InvalidUriParts>());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579381, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=517, prompt_tokens=2660, total_tokens=3177, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfLaTb3grMcJ14zRAUkDfVT1f0Y', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::Hasher;\n\n    #[test]\n    fn test_finish() {\n        let mut hasher = IdHasher(0);\n        hasher.write_u64(10);\n        assert_eq!(hasher.finish(), 10);\n\n        hasher.write_u64(20);\n        assert_eq!(hasher.finish(), 20);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579391, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=87, prompt_tokens=286, total_tokens=373, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfPFMDkQUKlJXm7JHdrcQZHBoyE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::Hasher;\n\n    #[test]\n    #[should_panic(expected = "TypeId calls write_u64")]\n    fn test_idhasher_write() {\n        let mut hasher = IdHasher(0);\n        hasher.write(b"test data");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579395, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=74, prompt_tokens=290, total_tokens=364, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfT02by0qSrSlA1nqkVaHB8eKJS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::Hasher;\n\n    #[test]\n    fn test_write_u64() {\n        let mut hasher = IdHasher::default();\n        let id: u64 = 42;\n\n        hasher.write_u64(id);\n        assert_eq!(hasher.finish(), id);\n    }\n\n    #[test]\n    fn test_write_u64_changes_value() {\n        let mut hasher = IdHasher::default();\n        let id1: u64 = 10;\n        let id2: u64 = 20;\n\n        hasher.write_u64(id1);\n        assert_eq!(hasher.finish(), id1);\n\n        hasher.write_u64(id2);\n        assert_eq!(hasher.finish(), id2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579399, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=166, prompt_tokens=296, total_tokens=462, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfYcdQI2Dxm2Jw5x8gOZvX85wIS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{Bucket, Drain};\n    use crate::header::name::{HeaderName, StandardHeader};\n    use std::ptr;\n\n    #[test]\n    fn test_next() {\n        let key1 = HeaderName::from_static("header1");\n        let value1 = "value1";\n        let key2 = HeaderName::from_static("header2");\n        let value2 = "value2";\n\n        let buckets = vec![\n            Bucket {\n                hash: HashValue(1),\n                key: key1.clone(),\n                value: value1,\n                links: None,\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: key2.clone(),\n                value: value2,\n                links: None,\n            },\n        ];\n\n        let extra_values: Vec<ExtraValue<&str>> = Vec::new();\n        let mut drain = Drain {\n            idx: 0,\n            len: buckets.len(),\n            entries: (&buckets).as_mut_ptr(),\n            next: None,\n            extra_values: &extra_values,\n            lt: PhantomData,\n        };\n\n        let first_entry = drain.next();\n        assert_eq!(first_entry, Some((Some(key1), value1)));\n\n        let second_entry = drain.next();\n        assert_eq!(second_entry, Some((Some(key2), value2)));\n\n        let none_entry = drain.next();\n        assert_eq!(none_entry, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579404, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=310, prompt_tokens=5301, total_tokens=5611, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfjbVNSLgHElp1MeRU3QhTKPrPa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{Drain, Bucket};\n    use crate::header::name::HeaderName;\n    use std::ptr;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let buckets: [Bucket<i32>; 0] = [];\n        let extra_values: Vec<i32> = Vec::new();\n        let drain = Drain {\n            idx: 0,\n            len: 0,\n            entries: &buckets as *const _ as *mut _,\n            next: None,\n            extra_values: &extra_values as *const _ as *mut _,\n            lt: std::marker::PhantomData,\n        };\n        \n        assert_eq!(drain.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_with_entries() {\n        let buckets: [Bucket<i32>; 2] = [\n            Bucket {\n                hash: HashValue(0),\n                key: HeaderName::from_static("key1"),\n                value: 1,\n                links: None,\n            },\n            Bucket {\n                hash: HashValue(0),\n                key: HeaderName::from_static("key2"),\n                value: 2,\n                links: None,\n            },\n        ];\n        let extra_values: Vec<i32> = vec![3, 4];\n        let drain = Drain {\n            idx: 0,\n            len: 2,\n            entries: &buckets as *const _ as *mut _,\n            next: None,\n            extra_values: &extra_values as *const _ as *mut _,\n            lt: std::marker::PhantomData,\n        };\n        \n        assert_eq!(drain.size_hint(), (2, Some(4)));\n    }\n\n    #[test]\n    fn test_size_hint_partial() {\n        let buckets: [Bucket<i32>; 3] = [\n            Bucket {\n                hash: HashValue(0),\n                key: HeaderName::from_static("key1"),\n                value: 1,\n                links: None,\n            },\n            Bucket {\n                hash: HashValue(0),\n                key: HeaderName::from_static("key2"),\n                value: 2,\n                links: None,\n            },\n            Bucket {\n                hash: HashValue(0),\n                key: HeaderName::from_static("key3"),\n                value: 3,\n                links: None,\n            },\n        ];\n        let extra_values: Vec<i32> = vec![4, 5];\n        let drain = Drain {\n            idx: 1,\n            len: 3,\n            entries: &buckets as *const _ as *mut _,\n            next: None,\n            extra_values: &extra_values as *const _ as *mut _,\n            lt: std::marker::PhantomData,\n        };\n        \n        assert_eq!(drain.size_hint(), (2, Some(4)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579415, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=614, prompt_tokens=5207, total_tokens=5821, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfvN6K23PkKkFFdWZV2xH7shbdr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, HashValue, Bucket, Drain};\n\n    #[test]\n    fn test_drain_drop() {\n        let header_name = HeaderName::from_static("test-header");\n        let bucket = Bucket {\n            hash: HashValue(0),\n            key: header_name.clone(),\n            value: "test-value",\n            links: None,\n        };\n        let extra_values = Vec::new();\n        let entries: [Bucket<&str>; 1] = [bucket];\n\n        let mut drain = Drain {\n            idx: 0,\n            len: 1,\n            entries: &entries as *const _ as *mut _,\n            next: None,\n            extra_values: &extra_values as *const _ as *mut _,\n            lt: PhantomData,\n        };\n\n        // The drop method runs when going out of scope\n        drop(drain);\n        // No assertions here; we are testing the drop functionality without panic\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579427, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=214, prompt_tokens=5109, total_tokens=5323, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclg2XGL2jEwBanEXEEauPIzg6riY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName};\n\n    #[test]\n    fn test_getall_eq() {\n        let mut map1 = HeaderMap::new();\n        let mut map2 = HeaderMap::new();\n        \n        map1.insert(HeaderName::from_static("x-duplicate-header"), "value1".parse().unwrap());\n        map1.append(HeaderName::from_static("x-duplicate-header"), "value2".parse().unwrap());\n        \n        map2.insert(HeaderName::from_static("x-duplicate-header"), "value1".parse().unwrap());\n        map2.append(HeaderName::from_static("x-duplicate-header"), "value2".parse().unwrap());\n        \n        let getall1 = map1.get_all("x-duplicate-header");\n        let getall2 = map2.get_all("x-duplicate-header");\n        \n        assert!(getall1.eq(&getall2));\n    }\n\n    #[test]\n    fn test_getall_eq_different() {\n        let mut map1 = HeaderMap::new();\n        let mut map2 = HeaderMap::new();\n        \n        map1.insert(HeaderName::from_static("x-duplicate-header"), "value1".parse().unwrap());\n        map1.append(HeaderName::from_static("x-duplicate-header"), "value2".parse().unwrap());\n        \n        map2.insert(HeaderName::from_static("x-duplicate-header"), "value1".parse().unwrap());\n        map2.append(HeaderName::from_static("x-duplicate-header"), "value3".parse().unwrap());\n        \n        let getall1 = map1.get_all("x-duplicate-header");\n        let getall2 = map2.get_all("x-duplicate-header");\n        \n        assert!(!getall1.eq(&getall2));\n    }\n\n    #[test]\n    fn test_getall_empty() {\n        let map1 = HeaderMap::new();\n        let map2 = HeaderMap::new();\n        \n        let getall1 = map1.get_all("non-existing-header");\n        let getall2 = map2.get_all("non-existing-header");\n        \n        assert!(getall1.eq(&getall2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579434, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=461, prompt_tokens=13015, total_tokens=13476, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclgD4eU7f6RRKXNTzeaTu3NUl8QE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{HeaderMap, header::HOST};\n    \n    #[test]\n    fn test_into_iter_empty() {\n        let map: HeaderMap<String> = HeaderMap::new();\n        let values = map.get_all("host");\n        let mut iter = values.into_iter();\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_single_value() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".to_string());\n        let values = map.get_all("host");\n        let mut iter = values.into_iter();\n        assert_eq!(iter.next(), Some(&"example.com".to_string()));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".to_string());\n        map.append(HOST, "example.org".to_string());\n        \n        let values = map.get_all("host");\n        let mut iter = values.into_iter();\n        \n        assert_eq!(iter.next(), Some(&"example.com".to_string()));\n        assert_eq!(iter.next(), Some(&"example.org".to_string()));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_different_keys() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".to_string());\n        map.append(HOST, "example.org".to_string());\n        map.append("another-host", "example.net".to_string());\n        \n        let values = map.get_all("host");\n        let mut iter = values.into_iter();\n        \n        assert_eq!(iter.next(), Some(&"example.com".to_string()));\n        assert_eq!(iter.next(), Some(&"example.org".to_string()));\n        assert!(iter.next().is_none());\n        \n        let values = map.get_all("another-host");\n        let mut iter = values.into_iter();\n        \n        assert_eq!(iter.next(), Some(&"example.net".to_string()));\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579445, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=454, prompt_tokens=13664, total_tokens=14118, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclgOap58jxkynpxmo2tywL8Cdavk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn test_header_map_eq() {\n        let mut map1 = HeaderMap::new();\n        let mut map2 = HeaderMap::new();\n\n        map1.insert(HOST, "example.com".parse().unwrap());\n        map1.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        map2.insert(HOST, "example.com".parse().unwrap());\n        map2.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        \n        assert!(map1.eq(&map2));\n\n        map2.insert(CONTENT_LENGTH, "124".parse().unwrap());\n        assert!(!map1.eq(&map2));\n\n        map2.remove(CONTENT_LENGTH);\n        map2.insert(HOST, "example.com".parse().unwrap());\n        assert!(!map1.eq(&map2));\n\n        map1.insert(HOST, "example.com".parse().unwrap());\n        map2.clear();\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_header_map_eq_with_different_sizes() {\n        let mut map1 = HeaderMap::new();\n        let mut map2 = HeaderMap::new();\n\n        map1.insert(HOST, "example.com".parse().unwrap());\n        assert!(!map1.eq(&map2));\n\n        map2.insert(HOST, "example.com".parse().unwrap());\n        map2.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_header_map_eq_with_empty_maps() {\n        let map1 = HeaderMap::new();\n        let map2 = HeaderMap::new();\n        \n        assert!(map1.eq(&map2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579456, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=388, prompt_tokens=12583, total_tokens=12971, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclga9BVgE3vkVLAZ3eoxrqLo8Ela', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use std::convert::TryFrom;\n    use http::header::{HeaderMap, HeaderName};\n\n    #[test]\n    fn test_try_from_empty_map() {\n        let map: HashMap<HeaderName, String> = HashMap::new();\n        let result: Result<HeaderMap<String>, _> = HeaderMap::try_from(&map);\n        assert!(result.is_ok());\n        assert!(result.unwrap().is_empty());\n    }\n\n    #[test]\n    fn test_try_from_valid_map() {\n        let mut map = HashMap::new();\n        map.insert(HeaderName::from_static("content-type"), "application/json".to_string());\n        map.insert(HeaderName::from_static("accept"), "application/xml".to_string());\n        \n        let result: Result<HeaderMap<String>, _> = HeaderMap::try_from(&map);\n        assert!(result.is_ok());\n        let header_map = result.unwrap();\n        assert_eq!(header_map.get(HeaderName::from_static("content-type")).unwrap(), "application/json");\n        assert_eq!(header_map.get(HeaderName::from_static("accept")).unwrap(), "application/xml");\n    }\n\n    #[test]\n    fn test_try_from_invalid_key() {\n        let mut map = HashMap::new();\n        map.insert("invalid_key".to_string(), "value".to_string()); // Invalid key type\n        \n        let result: Result<HeaderMap<String>, _> = HeaderMap::try_from(&map);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_invalid_value() {\n        let mut map = HashMap::new();\n        map.insert(HeaderName::from_static("valid-key"), 123); // Invalid value type\n        \n        let result: Result<HeaderMap<i32>, _> = HeaderMap::try_from(&map);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579468, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=406, prompt_tokens=253, total_tokens=659, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclglJ7tHrZVyPz2ZXvbCjAxz5hjp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n\n    #[test]\n    fn test_header_map_default() {\n        let map: HeaderMap = HeaderMap::default();\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_header_map_with_capacity() {\n        let map: HeaderMap = HeaderMap::with_capacity(0);\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579479, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=133, prompt_tokens=12554, total_tokens=12687, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclgp8I7YPOB4iTiUYzkvZy8AaFNk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HOST, CONTENT_LENGTH, HeaderValue};\n\n    #[test]\n    fn test_extend_empty_map() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::new();\n        let items = vec![(HOST, "example.com".parse().unwrap())];\n        map.extend(items.iter().cloned());\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(HOST), Some(&HeaderValue::from_static("example.com")));\n    }\n\n    #[test]\n    fn test_extend_with_existing_keys() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        let items = vec![(HOST, "new.example.com".parse().unwrap())];\n        map.extend(items.iter().cloned());\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get_all(HOST).iter().count(), 2);\n    }\n\n    #[test]\n    fn test_extend_multiple_keys() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::new();\n        let items = vec![(HOST, "example.com".parse().unwrap()), (CONTENT_LENGTH, "123".parse().unwrap())];\n        map.extend(items.iter().cloned());\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(HOST), Some(&HeaderValue::from_static("example.com")));\n        assert_eq!(map.get(CONTENT_LENGTH), Some(&HeaderValue::from_static("123")));\n    }\n\n    #[test]\n    fn test_extend_with_no_items() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::new();\n        let items: Vec<(HeaderName, HeaderValue)> = Vec::new();\n        map.extend(items.iter().cloned());\n\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_extend_with_different_types() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::new();\n        let items = vec![(HOST, "example.com".parse().unwrap()), (CONTENT_LENGTH, "100".parse().unwrap())];\n        map.extend(items.iter().cloned());\n\n        assert_eq!(map.get(HOST), Some(&HeaderValue::from_static("example.com")));\n        assert_eq!(map.get(CONTENT_LENGTH), Some(&HeaderValue::from_static("100")));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579483, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=516, prompt_tokens=13185, total_tokens=13701, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclh2K8dZ0RObUTPSNcbkg5suDEgo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{ACCEPT, HOST, COOKIE, HeaderName, HeaderValue};\n\n    #[test]\n    fn test_extend_with_another_header_map() {\n        let mut map = HeaderMap::new();\n        map.insert(ACCEPT, HeaderValue::from_static("text/plain"));\n        map.insert(HOST, HeaderValue::from_static("hello.world"));\n\n        let mut extra = HeaderMap::new();\n        extra.insert(HOST, HeaderValue::from_static("foo.bar"));\n        extra.insert(COOKIE, HeaderValue::from_static("hello"));\n        extra.append(COOKIE, HeaderValue::from_static("world"));\n\n        map.extend(extra);\n\n        assert_eq!(map[HOST], HeaderValue::from_static("foo.bar"));\n        assert_eq!(map[ACCEPT], HeaderValue::from_static("text/plain"));\n        let v = map.get_all(HOST);\n        assert_eq!(1, v.iter().count());\n        let v = map.get_all(COOKIE);\n        assert_eq!(2, v.iter().count());\n    }\n\n    #[test]\n    #[should_panic(expected = "expected a header name, but got None")]\n    fn test_extend_with_none_key() {\n        let mut map = HeaderMap::new();\n        let extra = vec![(None, HeaderValue::from_static("value"))].into_iter();\n        map.extend(extra);\n    }\n\n    #[test]\n    fn test_extend_with_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.insert(ACCEPT, HeaderValue::from_static("text/plain"));\n\n        let extra = vec![\n            (Some(HOST), HeaderValue::from_static("foo.bar")),\n            (None, HeaderValue::from_static("value1")),\n            (None, HeaderValue::from_static("value2")),\n        ];\n\n        map.extend(extra);\n\n        // Check map content\n        assert_eq!(map[HOST], HeaderValue::from_static("foo.bar"));\n        let v = map.get_all(ACCEPT);\n        assert_eq!(1, v.iter().count());\n        let v = map.get_all(HOST);\n        assert_eq!(1, v.iter().count());\n        let v = map.get_all("foo.bar");\n        assert_eq!(0, v.iter().count());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579496, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=483, prompt_tokens=13569, total_tokens=14052, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclhFKwH3dtRKISgRXPqB2fc9apop', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, HeaderValue};\n\n    #[test]\n    fn test_from_iter_empty() {\n        let map: HeaderMap<HeaderValue> = HeaderMap::from_iter(vec![]);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_from_iter_single() {\n        let name = HeaderName::from_static("x-test-header");\n        let value = HeaderValue::from_static("test_value");\n        let map: HeaderMap<HeaderValue> = HeaderMap::from_iter(vec![(name.clone(), value.clone())]);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get_all(name).iter().next(), Some(&value));\n    }\n\n    #[test]\n    fn test_from_iter_multiple() {\n        let name1 = HeaderName::from_static("x-test-header-1");\n        let value1 = HeaderValue::from_static("test_value_1");\n        let name2 = HeaderName::from_static("x-test-header-2");\n        let value2 = HeaderValue::from_static("test_value_2");\n        let map: HeaderMap<HeaderValue> = HeaderMap::from_iter(vec![\n            (name1.clone(), value1.clone()),\n            (name1.clone(), value2.clone()),\n            (name2.clone(), value1.clone()),\n        ]);\n\n        assert_eq!(map.len(), 4);\n        let values1: Vec<_> = map.get_all(name1).iter().copied().collect();\n        assert_eq!(values1, vec![value1, value2]);\n        let values2: Vec<_> = map.get_all(name2).iter().copied().collect();\n        assert_eq!(values2, vec![value1]);\n    }\n\n    #[test]\n    fn test_from_iter_duplicates() {\n        let name = HeaderName::from_static("x-duplicate-header");\n        let value = HeaderValue::from_static("duplicate_value");\n\n        let map: HeaderMap<HeaderValue> = HeaderMap::from_iter(vec![\n            (name.clone(), value.clone()),\n            (name.clone(), value.clone()),\n        ]);\n\n        assert_eq!(map.len(), 2);\n        let values: Vec<_> = map.get_all(name).iter().copied().collect();\n        assert_eq!(values.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579509, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=493, prompt_tokens=13088, total_tokens=13581, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclhQh2cSGlek6Dc1Llzg3XmefzMu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, CONTENT_TYPE};\n\n    #[test]\n    fn test_into_iter_basic() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        map.insert(CONTENT_TYPE, "json".parse().unwrap());\n\n        let mut iter = map.into_iter();\n        assert_eq!(\n            iter.next(),\n            Some((Some(CONTENT_LENGTH), "123".parse().unwrap()))\n        );\n        assert_eq!(\n            iter.next(),\n            Some((Some(CONTENT_TYPE), "json".parse().unwrap()))\n        );\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.append(CONTENT_LENGTH, "123".parse().unwrap());\n        map.append(CONTENT_LENGTH, "456".parse().unwrap());\n        map.append(CONTENT_TYPE, "json".parse().unwrap());\n        map.append(CONTENT_TYPE, "html".parse().unwrap());\n        map.append(CONTENT_TYPE, "xml".parse().unwrap());\n\n        let mut iter = map.into_iter();\n        assert_eq!(\n            iter.next(),\n            Some((Some(CONTENT_LENGTH), "123".parse().unwrap()))\n        );\n        assert_eq!(iter.next(), Some((None, "456".parse().unwrap())));\n        assert_eq!(\n            iter.next(),\n            Some((Some(CONTENT_TYPE), "json".parse().unwrap()))\n        );\n        assert_eq!(iter.next(), Some((None, "html".parse().unwrap())));\n        assert_eq!(iter.next(), Some((None, "xml".parse().unwrap())));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let map: HeaderMap = HeaderMap::new();\n        let mut iter = map.into_iter();\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579520, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=420, prompt_tokens=13465, total_tokens=13885, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclhdPm30wRcYYUSVu5jnljHOsUw6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n    use http::HeaderMap;\n\n    #[test]\n    #[should_panic(expected = "no entry found for key \\"non-existent-header\\"")]\n    fn test_index_panic_on_non_existent_key() {\n        let headers = HeaderMap::new();\n        let _ = headers[CONTENT_LENGTH]; // should panic\n    }\n\n    #[test]\n    fn test_index_retrieve_existing_key() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n        assert_eq!(headers[HOST], "example.com");\n    }\n\n    #[test]\n    fn test_index_multiple_values() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n        headers.append(HOST, "example.org".parse().unwrap());\n        assert_eq!(headers[HOST], "example.com"); // should still return the first value\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579533, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=218, prompt_tokens=12602, total_tokens=12820, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclhlGYG1c1VTQvO1cVgkRsyu8Xdm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{HeaderMap, IntoIter, Bucket, ExtraValue}; // Adjust import paths as necessary\n\n    #[test]\n    fn test_next_empty_iterator() {\n        let empty_iter: IntoIter<i32> = IntoIter {\n            next: None,\n            entries: Vec::new().into_iter(), // Assuming Bucket<i32> is empty\n            extra_values: Vec::new(),\n        };\n        assert_eq!(empty_iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_entries() {\n        let mut map = HeaderMap::new();\n        map.insert("header1".into(), 1);\n        map.insert("header2".into(), 2);\n        \n        let mut iter = map.into_iter();\n\n        assert_eq!(iter.next(), Some((Some("header1".into()), 1)));\n        assert_eq!(iter.next(), Some((Some("header2".into()), 2)));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_extra_values() {\n        let mut map = HeaderMap::new();\n        map.insert("header1".into(), 1);\n        \n        // Simulate adding extra values, assuming you have the mechanism\n        // to do so in your HeaderMap\n        map.add_extra("extra1".into(), 10);\n        \n        let mut iter = map.into_iter();\n\n        assert_eq!(iter.next(), Some((Some("header1".into()), 1)));\n        assert_eq!(iter.next(), Some((None, 10))); // Assuming the extra value is returned next\n        assert_eq!(iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579541, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=355, prompt_tokens=735, total_tokens=1090, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclhtIfppiPv4K0t0jfPj4gGXgj7t', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::IntoIter;\n    \n    #[test]\n    fn test_size_hint() {\n        let mut header_map = HeaderMap::new();\n        // Populate header_map with test data\n        header_map.insert(HeaderName::from_static("Test-Header"), "TestValue1".into());\n        header_map.insert(HeaderName::from_static("Another-Header"), "TestValue2".into());\n\n        let iter: IntoIter<HeaderValue> = header_map.into_iter();\n        \n        // Test the size_hint function\n        let (lower, upper) = iter.size_hint();\n        \n        // Checking the size hint\n        assert_eq!(lower, 2); // Assuming 2 entries in the header_map\n        assert_eq!(upper, None); // Upper bound is not defined, should be None\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579549, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=186, prompt_tokens=686, total_tokens=872, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclhza56QYH4EKL80iq5GBImgsK5u', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::IntoIter;\n    use crate::header::{HeaderMap, HeaderName}; // Adjust the import paths accordingly\n\n    #[test]\n    fn test_into_iter_drop() {\n        // Create a HeaderMap and add some entries\n        let mut headers = HeaderMap::new();\n        headers.insert(HeaderName::from_static("header1"), "value1".into());\n        headers.insert(HeaderName::from_static("header2"), "value2".into());\n\n        // Create an IntoIter from the HeaderMap\n        let mut iter = headers.into_iter();\n\n        // Consume the iterator\n        while let Some(_) = iter.next() {}\n\n        // At this point, the iter should be fully consumed, and when it goes out of scope, it should drop cleanly.\n        // The drop() method should be called when `iter` goes out of scope here.\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579555, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=199, prompt_tokens=648, total_tokens=847, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcli7RdGEhiJf6IMRwfLe6qOrR3M4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{HeaderMap, header::{CONTENT_LENGTH, HOST}};\n\n    #[test]\n    fn test_next() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut iter = headers.iter();\n\n        assert_eq!(iter.next(), Some((&HOST, &"example.com")));\n        assert_eq!(iter.next(), Some((&CONTENT_LENGTH, &"123")));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_multiple_values() {\n        let mut headers = HeaderMap::new();\n        headers.append(HOST, "example.com".parse().unwrap());\n        headers.append(HOST, "example.org".parse().unwrap());\n        headers.append(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut iter = headers.iter();\n\n        assert_eq!(iter.next(), Some((&HOST, &"example.com")));\n        assert_eq!(iter.next(), Some((&HOST, &"example.org")));\n        assert_eq!(iter.next(), Some((&CONTENT_LENGTH, &"123")));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let headers = HeaderMap::new();\n        let mut iter = headers.iter();\n\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_after_clear() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n        headers.clear();\n\n        let mut iter = headers.iter();\n\n        assert_eq!(iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579563, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=361, prompt_tokens=13221, total_tokens=13582, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcliHlM9zkeFtlxQvxoRHpxedFhTA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName};\n    \n    #[test]\n    fn test_size_hint() {\n        let mut map = HeaderMap::new();\n        let header1: HeaderName = "header1".parse().unwrap();\n        let header2: HeaderName = "header2".parse().unwrap();\n        \n        map.insert(header1.clone(), "value1".parse().unwrap());\n        map.insert(header2.clone(), "value2".parse().unwrap());\n        \n        let iter = map.iter();\n        let (lower, upper) = iter.size_hint();\n        \n        assert_eq!(lower, 2);\n        assert!(upper.is_none());\n    }\n    \n    #[test]\n    fn test_size_hint_with_extra_values() {\n        let mut map = HeaderMap::new();\n        let header: HeaderName = "header".parse().unwrap();\n        \n        map.insert(header.clone(), "value1".parse().unwrap());\n        map.append(header.clone(), "value2".parse().unwrap());\n        \n        let iter = map.iter();\n        let (lower, upper) = iter.size_hint();\n        \n        assert_eq!(lower, 1); // There is one unique header\n        assert!(upper.is_none());\n    }\n    \n    #[test]\n    fn test_size_hint_empty() {\n        let map: HeaderMap = HeaderMap::new();\n        let iter = map.iter();\n        \n        let (lower, upper) = iter.size_hint();\n        \n        assert_eq!(lower, 0);\n        assert!(upper.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579573, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=330, prompt_tokens=13152, total_tokens=13482, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcliTcus3Wd9NeJuBiBknipWOn4PX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, HOST};\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_iter_mut_next() {\n        let mut header_map: HeaderMap<String> = HeaderMap::new();\n        header_map.insert(HOST, "example.com".to_string());\n        header_map.append(CONTENT_LENGTH, "123".to_string());\n        header_map.append(CONTENT_LENGTH, "456".to_string());\n\n        let mut iter = header_map.iter_mut();\n        \n        let (key, value) = iter.next().unwrap();\n        assert_eq!(key.as_str(), "host");\n        assert_eq!(value, &mut "example.com".to_string());\n\n        let (key, value) = iter.next().unwrap();\n        assert_eq!(key.as_str(), "content-length");\n        assert_eq!(value, &mut "123".to_string());\n\n        let (key, value) = iter.next().unwrap();\n        assert_eq!(key.as_str(), "content-length");\n        assert_eq!(value, &mut "456".to_string());\n\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_iter_mut_next_with_empty_map() {\n        let header_map: HeaderMap<String> = HeaderMap::new();\n        let mut iter = header_map.iter_mut();\n        \n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_iter_mut_next_with_multiple_values() {\n        let mut header_map: HeaderMap<String> = HeaderMap::new();\n        header_map.append(HOST, "example.com".to_string());\n        header_map.append(HOST, "example.org".to_string());\n        \n        let mut iter = header_map.iter_mut();\n        \n        let (key, value) = iter.next().unwrap();\n        assert_eq!(key.as_str(), "host");\n        assert_eq!(value, &mut "example.com".to_string());\n\n        let (key, value) = iter.next().unwrap();\n        assert_eq!(key.as_str(), "host");\n        assert_eq!(value, &mut "example.org".to_string());\n\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579585, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=462, prompt_tokens=13201, total_tokens=13663, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclifqAHnJfbScGN7q2EeVwJ7zhvD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n    use http::HeaderMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HeaderMap = HeaderMap::new();\n        let mut iter = map.iter_mut();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, None);\n    }\n\n    #[test]\n    fn test_size_hint_single_entry() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut iter = map.iter_mut();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, None);\n    }\n\n    #[test]\n    fn test_size_hint_multiple_entries() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        map.append(CONTENT_LENGTH, "456".parse().unwrap());\n\n        let mut iter = map.iter_mut();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, None);\n    }\n\n    #[test]\n    fn test_size_hint_with_extra_values() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        map.append(CONTENT_LENGTH, "456".parse().unwrap());\n        map.append(CONTENT_LENGTH, "789".parse().unwrap());\n\n        // Simulate having extra values\n        let _ = map.append(CONTENT_LENGTH, "extra".parse().unwrap());\n\n        let mut iter = map.iter_mut();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 4);\n        assert_eq!(upper, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579597, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=405, prompt_tokens=13277, total_tokens=13682, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclioxMeXUzCwdrpWvHbgpv88YtnJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{HeaderMap, Keys};\n    use crate::header::HeaderName;\n\n    #[test]\n    fn test_keys_count() {\n        let mut header_map = HeaderMap::new();\n        header_map.insert(HeaderName::from_static("Content-Type"), "application/json".parse().unwrap());\n        header_map.insert(HeaderName::from_static("Content-Length"), "123".parse().unwrap());\n        header_map.insert(HeaderName::from_static("Content-Type"), "text/plain".parse().unwrap()); // Duplicate key\n\n        let keys = Keys {\n            inner: header_map.buckets.iter(),\n        };\n\n        assert_eq!(keys.count(), 2); // Expecting 2 unique keys\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579606, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=163, prompt_tokens=458, total_tokens=621, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcliuxH3tXSLSldW8GNPTk1Zw179e', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::{HeaderMap, HeaderName};\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_last_with_multiple_keys() {\n        let mut map = HeaderMap::new();\n        map.insert(HeaderName::from_static("key1"), "value1".into());\n        map.insert(HeaderName::from_static("key2"), "value2".into());\n        map.insert(HeaderName::from_static("key3"), "value3".into());\n\n        let keys: Vec<_> = map.keys().collect();\n        let last_key = keys.last();\n        assert_eq!(last_key, Some(&HeaderName::from_static("key3")));\n    }\n\n    #[test]\n    fn test_last_with_single_key() {\n        let mut map = HeaderMap::new();\n        map.insert(HeaderName::from_static("key1"), "value1".into());\n\n        let keys: Vec<_> = map.keys().collect();\n        let last_key = keys.last();\n        assert_eq!(last_key, Some(&HeaderName::from_static("key1")));\n    }\n\n    #[test]\n    fn test_last_with_no_keys() {\n        let map = HeaderMap::new();\n        let keys: Vec<_> = map.keys().collect();\n        let last_key = keys.last();\n        assert_eq!(last_key, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579612, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=291, prompt_tokens=469, total_tokens=760, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclj1EYlKA7Ja54vPGVUlkRFlBVb8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::Keys;\n    use crate::header::HeaderMap;\n    use crate::header::HeaderName;\n\n    #[test]\n    fn test_next() {\n        let mut header_map = HeaderMap::new();\n        let key1 = HeaderName::from_static("key1");\n        let key2 = HeaderName::from_static("key2");\n        header_map.append(key1.clone(), "value1");\n        header_map.append(key2.clone(), "value2");\n\n        let mut keys_iter = Keys { inner: header_map.buckets.iter() };\n        \n        let first_key = keys_iter.next();\n        assert_eq!(first_key, Some(&key1));\n\n        let second_key = keys_iter.next();\n        assert_eq!(second_key, Some(&key2));\n\n        let third_key = keys_iter.next();\n        assert_eq!(third_key, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579619, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=197, prompt_tokens=471, total_tokens=668, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclj624Z2LJpcVm3dqrjKKIPgls2S', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName};\n\n    #[test]\n    fn test_nth() {\n        let mut map = HeaderMap::new();\n        map.append(HeaderName::from_static("header1"), "value1".parse().unwrap());\n        map.append(HeaderName::from_static("header2"), "value2".parse().unwrap());\n        map.append(HeaderName::from_static("header3"), "value3".parse().unwrap());\n\n        let keys = map.keys();\n        \n        assert_eq!(keys.nth(0), Some(&HeaderName::from_static("header1")));\n        assert_eq!(keys.nth(1), Some(&HeaderName::from_static("header2")));\n        assert_eq!(keys.nth(2), Some(&HeaderName::from_static("header3")));\n        assert_eq!(keys.nth(3), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579624, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=194, prompt_tokens=477, total_tokens=671, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcljCSh35H1yGAcQ55gyJ5nyR5bJa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName, HeaderValue};\n\n    #[test]\n    fn test_size_hint() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HeaderName::from_static("content-type"), HeaderValue::from_static("application/json"));\n        headers.insert(HeaderName::from_static("accept"), HeaderValue::from_static("application/json"));\n        \n        let keys: Keys<HeaderValue> = keys(headers.iter());\n        \n        let (lower, upper) = keys.size_hint();\n        assert_eq!(lower, 2); // Lower bound should be the exact number of keys\n        assert_eq!(upper, Some(2)); // Upper bound should also be the exact number of keys\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579630, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=165, prompt_tokens=469, total_tokens=634, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcljIOS57n6LAPEOJogtI1NKoiOMM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName};\n    \n    #[test]\n    fn test_into_iter() {\n        let mut map = HeaderMap::new();\n        let header_name1 = HeaderName::from_static("header1");\n        let header_name2 = HeaderName::from_static("header2");\n        \n        map.insert(header_name1.clone(), "value1".parse().unwrap());\n        map.append(header_name1.clone(), "value2".parse().unwrap());\n        map.insert(header_name2.clone(), "value3".parse().unwrap());\n        \n        let mut iter = map.entry("header1").unwrap().into_iter();\n        assert_eq!(iter.next(), Some(&mut "value1".to_string()));\n        assert_eq!(iter.next(), Some(&mut "value2".to_string()));\n        assert!(iter.next().is_none());\n\n        let mut iter = map.entry("header2").unwrap().into_iter();\n        assert_eq!(iter.next(), Some(&mut "value3".to_string()));\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579636, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=233, prompt_tokens=15775, total_tokens=16008, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcljPW7ywNYzM7rC75cjL5SNu9f2y', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, RawLinks, Bucket, HashValue}; // Adjust import paths as necessary\n\n    #[test]\n    fn test_clone_raw_links() {\n        let key = HeaderName::from_static("test-header");\n        let value = "test-value";\n        let hash = HashValue(42);\n        let links = None; // Replace with actual Links if necessary\n\n        let original_bucket = Bucket {\n            hash,\n            key,\n            value,\n            links,\n        };\n        \n        let raw_links = RawLinks(&mut [original_bucket]);\n        let cloned_raw_links = raw_links.clone();\n\n        assert_eq!(raw_links, cloned_raw_links);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579643, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=154, prompt_tokens=4787, total_tokens=4941, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcljZgWDuJr80CZuBGnVEnmFiMtFx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_index() {\n        // Arrange\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: HeaderName::from_static("header1"),\n            value: "value1",\n            links: Some(Links::new()),\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: HeaderName::from_static("header2"),\n            value: "value2",\n            links: Some(Links::new()),\n        };\n\n        let buckets: Vec<Bucket<&str>> = vec![bucket1, bucket2];\n        let raw_links = RawLinks(buckets.as_ptr() as *mut [Bucket<&str>]);\n\n        // Act\n        let result: &Option<Links> = &raw_links[1];\n\n        // Assert\n        assert!(result.is_some());\n        assert_eq!(result, &Some(Links::new()));\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_out_of_bounds() {\n        // Arrange\n        let bucket = Bucket {\n            hash: HashValue(1),\n            key: HeaderName::from_static("header1"),\n            value: "value1",\n            links: Some(Links::new()),\n        };\n        let buckets: Vec<Bucket<&str>> = vec![bucket];\n        let raw_links = RawLinks(buckets.as_ptr() as *mut [Bucket<&str>]);\n\n        // Act\n        let _result: &Option<Links> = &raw_links[1]; // This should panic\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579653, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=343, prompt_tokens=4803, total_tokens=5146, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcljhxhrp14Lp1tVlRpeMQBqnaq2k', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_index_mut() {\n        let header_name = HeaderName::from_static("test-header");\n        let hash_value = HashValue(1);\n        let bucket = Bucket {\n            hash: hash_value.clone(),\n            key: header_name.clone(),\n            value: "test-value",\n            links: None,\n        };\n\n        let bucket_array: &mut [Bucket<&str>] = &mut [bucket];\n        let raw_links = RawLinks(bucket_array as *mut _);\n\n        // Test mutable indexing\n        let links_mut: &mut Option<Links> = raw_links.index_mut(0);\n        *links_mut = Some(Links::new());\n\n        // Verify the links are mutable and correctly set\n        assert!(raw_links.index(0).is_some());\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_mut_out_of_bounds() {\n        let header_name = HeaderName::from_static("test-header");\n        let hash_value = HashValue(1);\n        let bucket = Bucket {\n            hash: hash_value.clone(),\n            key: header_name.clone(),\n            value: "test-value",\n            links: None,\n        };\n\n        let bucket_array: &mut [Bucket<&str>] = &mut [bucket];\n        let raw_links = RawLinks(bucket_array as *mut _);\n\n        // This should panic as the index is out of bounds\n        let _ = raw_links.index_mut(1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579661, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=320, prompt_tokens=4810, total_tokens=5130, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcljrYFYmtie8o5cXasBKyPWUm39y', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_value_drain_next() {\n        let vec_data = vec![1, 2, 3];\n        let mut drain = ValueDrain {\n            first: Some(0),\n            next: Some(vec_data.clone().into_iter()),\n            lt: PhantomData,\n        };\n\n        assert_eq!(drain.next(), Some(0));\n        assert_eq!(drain.next(), Some(1));\n        assert_eq!(drain.next(), Some(2));\n        assert_eq!(drain.next(), Some(3));\n        assert_eq!(drain.next(), None);\n    }\n\n    #[test]\n    fn test_value_drain_next_only_first() {\n        let mut drain = ValueDrain {\n            first: Some(42),\n            next: None,\n            lt: PhantomData,\n        };\n\n        assert_eq!(drain.next(), Some(42));\n        assert_eq!(drain.next(), None);\n    }\n\n    #[test]\n    fn test_value_drain_next_all_none() {\n        let mut drain = ValueDrain {\n            first: None,\n            next: None,\n            lt: PhantomData,\n        };\n\n        assert_eq!(drain.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579671, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=264, prompt_tokens=629, total_tokens=893, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclk0jjzXyJktUJZ5FOcW92MdeaBi', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_size_hint_with_first_and_no_extras() {\n        let drain = ValueDrain {\n            first: Some(42),\n            next: None,\n            lt: PhantomData,\n        };\n        assert_eq!(drain.size_hint(), (1, Some(1)));\n    }\n\n    #[test]\n    fn test_size_hint_with_first_and_extras() {\n        let extras = vec![1, 2, 3].into_iter();\n        let drain = ValueDrain {\n            first: Some(42),\n            next: Some(extras),\n            lt: PhantomData,\n        };\n        assert_eq!(drain.size_hint(), (4, Some(4)));\n    }\n\n    #[test]\n    fn test_size_hint_with_no_first_and_extras() {\n        let extras = vec![1, 2, 3].into_iter();\n        let drain = ValueDrain {\n            first: None,\n            next: Some(extras),\n            lt: PhantomData,\n        };\n        assert_eq!(drain.size_hint(), (3, Some(3)));\n    }\n\n    #[test]\n    fn test_size_hint_with_no_first_and_no_extras() {\n        let drain = ValueDrain {\n            first: None,\n            next: None,\n            lt: PhantomData,\n        };\n        assert_eq!(drain.size_hint(), (0, Some(0)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579680, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=304, prompt_tokens=718, total_tokens=1022, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclk70WNjhGSfDlaZaMFSP4uUumpU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::marker::PhantomData;\n\n    struct HeaderMap<T> {\n        _marker: PhantomData<T>,\n    }\n\n    #[test]\n    fn test_value_drain_drop() {\n        let first_value = Some(42);\n        let additional_values = vec![43, 44, 45];\n        let iter = additional_values.clone().into_iter();\n        let value_drain = ValueDrain {\n            first: first_value,\n            next: Some(iter),\n            lt: PhantomData,\n        };\n\n        // Ensure that dropping value_drain does not panic, and consumes the values.\n        let _ = std::panic::catch_unwind(|| {\n            drop(value_drain);\n        });\n\n        // Ensure the additional values are consumed\n        assert!(additional_values.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579687, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=177, prompt_tokens=594, total_tokens=771, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclkDjEKqPIIY9Ck79X19AW1wwoBR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{ACCEPT, HOST};\n    use http::HeaderMap;\n\n    #[test]\n    fn test_next_back_with_single_value() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n\n        let mut iter = headers.value_iter(headers.keys_len());\n\n        assert_eq!(iter.next_back(), Some(&"example.com"));\n        assert_eq!(iter.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_with_multiple_values() {\n        let mut headers = HeaderMap::new();\n        headers.append(HOST, "example.com".parse().unwrap());\n        headers.append(HOST, "example.org".parse().unwrap());\n\n        let mut iter = headers.value_iter(headers.keys_len());\n\n        assert_eq!(iter.next_back(), Some(&"example.org"));\n        assert_eq!(iter.next_back(), Some(&"example.com"));\n        assert_eq!(iter.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_empty() {\n        let headers = HeaderMap::new();\n        let mut iter = headers.value_iter(headers.keys_len());\n\n        assert_eq!(iter.next_back(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579693, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=259, prompt_tokens=13335, total_tokens=13594, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclkR8T7BMbVyKbwtPPqvusaMYQlO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, HOST};\n    \n    #[test]\n    fn test_value_iter_next() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut iter = headers.values();\n        assert_eq!(iter.next(), Some(&"example.com"));\n        assert_eq!(iter.next(), Some(&"123"));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_value_iter_next_multiple_values() {\n        let mut headers = HeaderMap::new();\n        headers.append(HOST, "example.com".parse().unwrap());\n        headers.append(HOST, "another.com".parse().unwrap());\n        headers.append(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut iter = headers.get_all(HOST).iter();\n        assert_eq!(iter.next(), Some(&"example.com"));\n        assert_eq!(iter.next(), Some(&"another.com"));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_value_iter_next_empty() {\n        let headers = HeaderMap::new();\n        let mut iter = headers.values();\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579707, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=284, prompt_tokens=13390, total_tokens=13674, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclkZqFmstnSb7spHAqnOt4OvDIGl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n    \n    #[test]\n    fn size_hint_one_value() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        let value_iter = headers.value_iter(Some(0));\n\n        let (lower, upper) = value_iter.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n    }\n\n    #[test]\n    fn size_hint_multiple_values() {\n        let mut headers = HeaderMap::new();\n        headers.append(CONTENT_LENGTH, "123".parse().unwrap());\n        headers.append(CONTENT_LENGTH, "456".parse().unwrap());\n        let value_iter = headers.value_iter(Some(0));\n\n        let (lower, upper) = value_iter.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, None);\n    }\n\n    #[test]\n    fn size_hint_no_values() {\n        let headers = HeaderMap::new();\n        let value_iter = headers.value_iter(None);\n        \n        let (lower, upper) = value_iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn size_hint_empty_iter() {\n        let mut headers = HeaderMap::new();\n        let value_iter = headers.value_iter(None);\n\n        let (lower, upper) = value_iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579715, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=340, prompt_tokens=13274, total_tokens=13614, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclkhz9xekOFY8c1PwLmjVIwL6FP1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{HeaderMap, header::{CONTENT_LENGTH, HOST}};\n\n    #[test]\n    fn test_next_back() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        \n        let mut iter = headers.iter_mut(); // Getting mutable iterator\n        \n        // Manually mutate the HeaderMap to facilitate calls to next_back\n        let last = iter.next_back().unwrap();\n        assert_eq!(*last, "123"); // Check the last value\n        \n        let second_last = iter.next_back().unwrap();\n        assert_eq!(*second_last, "example.com"); // Check the second last value\n        \n        assert!(iter.next_back().is_none()); // No more items\n    }\n\n    #[test]\n    fn test_next_back_empty() {\n        let mut headers = HeaderMap::new();\n        let mut iter = headers.iter_mut();\n        \n        assert!(iter.next_back().is_none()); // Ensure no items\n    }\n\n    #[test]\n    fn test_next_back_multiple_values() {\n        let mut headers = HeaderMap::new();\n        headers.append(HOST, "example.com".parse().unwrap());\n        headers.append(HOST, "example.org".parse().unwrap());\n        headers.append(CONTENT_LENGTH, "123".parse().unwrap());\n        \n        let mut iter = headers.iter_mut();\n        \n        let last = iter.next_back().unwrap();\n        assert_eq!(*last, "123"); // Check the last value\n        \n        let second_last = iter.next_back().unwrap();\n        assert_eq!(*second_last, "example.org"); // Check the second last value\n        \n        let third_last = iter.next_back().unwrap();\n        assert_eq!(*third_last, "example.com"); // Check the third last value\n        \n        assert!(iter.next_back().is_none()); // No more items\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579723, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=413, prompt_tokens=13366, total_tokens=13779, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclkrVJ3DOfN83kP6sUuGDhAVXers', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, CONTENT_TYPE};\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_value_iter_mut_next() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "100".to_string());\n        map.insert(CONTENT_TYPE, "application/json".to_string());\n        map.append(CONTENT_TYPE, "text/plain".to_string());\n\n        let mut iter = map.iter_mut();\n\n        let first_value = iter.next().unwrap();\n        assert_eq!(first_value, &mut "100".to_string());\n\n        let second_value = iter.next().unwrap();\n        assert_eq!(second_value, &mut "application/json".to_string());\n\n        let third_value = iter.next().unwrap();\n        assert_eq!(third_value, &mut "text/plain".to_string());\n\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579733, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=209, prompt_tokens=13415, total_tokens=13624, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclkzfRush69ODNxxUpWkp7XJHEz1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n    use http::HeaderMap;\n\n    #[test]\n    fn test_values_iterator_next() {\n        let mut headers = HeaderMap::new();\n        headers.insert(HOST, "example.com".parse().unwrap());\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut values = headers.values();\n        \n        assert_eq!(values.next(), Some(&"example.com"));\n        assert_eq!(values.next(), Some(&"123"));\n        assert_eq!(values.next(), None);\n    }\n\n    #[test]\n    fn test_values_iterator_multiple_values() {\n        let mut headers = HeaderMap::new();\n        headers.append(HOST, "example.com".parse().unwrap());\n        headers.append(HOST, "example.org".parse().unwrap());\n        headers.append(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut values = headers.values();\n        \n        assert_eq!(values.next(), Some(&"example.com"));\n        assert_eq!(values.next(), Some(&"example.org"));\n        assert_eq!(values.next(), Some(&"123"));\n        assert_eq!(values.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579741, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=254, prompt_tokens=13254, total_tokens=13508, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcll8ObCii35rKSInUiMwarHvOqB0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import necessary items from the module\n    use http::HeaderMap; // Import the HeaderMap\n    use http::header::{HeaderName}; // Import HeaderName\n    use std::collections::HashMap; // Import HashMap\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HeaderMap<String> = HeaderMap::new();\n        let values = map.values();\n        assert_eq!(values.size_hint(), (0, None));\n    }\n\n    #[test]\n    fn test_size_hint_single() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        map.insert(HeaderName::from_static("x-foo"), "bar".to_string());\n        let values = map.values();\n        assert_eq!(values.size_hint(), (1, None));\n    }\n\n    #[test]\n    fn test_size_hint_multiple() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        map.insert(HeaderName::from_static("x-foo"), "bar".to_string());\n        map.append(HeaderName::from_static("x-foo"), "baz".to_string());\n        let values = map.values();\n        assert_eq!(values.size_hint(), (2, None));\n    }\n\n    #[test]\n    fn test_size_hint_with_empty_key() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        map.insert(HeaderName::from_static("x-foo"), "bar".to_string());\n        map.append(HeaderName::from_static("x-foo"), "baz".to_string());\n        map.append(HeaderName::from_static("x-baz"), "qux".to_string());\n        let values = map.values();\n        assert_eq!(values.size_hint(), (3, None));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579750, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=378, prompt_tokens=13253, total_tokens=13631, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllInJWxGeAnWW0haUkpMUgD659L', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, HOST};\n    use http::HeaderMap;\n    \n    #[test]\n    fn test_values_mut_next() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        \n        let mut values_mut = map.values_mut();\n        \n        // First value should be "example.com"\n        let first_value = values_mut.next().unwrap();\n        assert_eq!(*first_value, "example.com");\n\n        // Second value should be "123"\n        let second_value = values_mut.next().unwrap();\n        assert_eq!(*second_value, "123");\n\n        // No more values to retrieve\n        assert!(values_mut.next().is_none());\n    }\n    \n    #[test]\n    fn test_values_mut_next_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.append(HOST, "example.com".parse().unwrap());\n        map.append(HOST, "example.org".parse().unwrap());\n        \n        let mut values_mut = map.values_mut();\n        \n        // First value should be "example.com"\n        let first_value = values_mut.next().unwrap();\n        assert_eq!(*first_value, "example.com");\n\n        // Second value should be "example.org"\n        let second_value = values_mut.next().unwrap();\n        assert_eq!(*second_value, "example.org");\n\n        // No more values to retrieve\n        assert!(values_mut.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579760, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=336, prompt_tokens=13370, total_tokens=13706, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllYRxBYGaJlf5oBJkh5X7PWf5PG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n    use http::HeaderMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HeaderMap<String> = HeaderMap::new();\n        let values_mut = map.values_mut();\n        let hint = values_mut.size_hint();\n        assert_eq!(hint, (0, None));\n    }\n\n    #[test]\n    fn test_size_hint_single_value() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".to_string());\n        let values_mut = map.values_mut();\n        let hint = values_mut.size_hint();\n        assert_eq!(hint, (1, None));\n    }\n\n    #[test]\n    fn test_size_hint_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.append(HOST, "example.com".to_string());\n        map.append(HOST, "example.org".to_string());\n        let values_mut = map.values_mut();\n        let hint = values_mut.size_hint();\n        assert_eq!(hint, (2, None));\n    }\n\n    #[test]\n    fn test_size_hint_after_removal() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".to_string());\n        map.insert(HOST, "example.com".to_string());\n        map.remove(HOST);\n        let values_mut = map.values_mut();\n        let hint = values_mut.size_hint();\n        assert_eq!(hint, (1, None));\n    }\n\n    #[test]\n    fn test_size_hint_with_no_values() {\n        let mut map = HeaderMap::new();\n        map.append(CONTENT_LENGTH, "456".to_string());\n        map.remove(CONTENT_LENGTH);\n        let values_mut = map.values_mut();\n        let hint = values_mut.size_hint();\n        assert_eq!(hint, (0, None));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579776, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=403, prompt_tokens=13369, total_tokens=13772, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclliXkwxDM2GwRyl1dpSIIX5vjGj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{MaxSizeReached, as_header_name::TryEntryError};\n\n    #[test]\n    fn test_from_max_size_reached() {\n        let error = MaxSizeReached::new();\n        let try_entry_error: TryEntryError = TryEntryError::from(error);\n        match try_entry_error {\n            TryEntryError::MaxSizeReached(_) => {}\n            _ => panic!("Expected TryEntryError::MaxSizeReached"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579786, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=112, prompt_tokens=765, total_tokens=877, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllmydeRxyXTGAPnWAyjene0kbWx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::name::InvalidHeaderName;\n    use crate::header::map::as_header_name::TryEntryError;\n\n    #[test]\n    fn test_from_invalid_header_name() {\n        let invalid_header_name = InvalidHeaderName::new();\n        let try_entry_error: TryEntryError = TryEntryError::from(invalid_header_name);\n        \n        match try_entry_error {\n            TryEntryError::InvalidHeaderName(_) => (),\n            _ => panic!("Expected TryEntryError::InvalidHeaderName"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579790, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=125, prompt_tokens=765, total_tokens=890, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllsGHsGU9W3AgqKOLIibFWUQgLZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::Hash;\n    use crate::extensions::IdHasher;\n\n    #[test]\n    fn test_custom_hash() {\n        let custom_header = Custom(ByteStr::from_static("Test-Header"));\n\n        let mut hasher = IdHasher::default();\n        custom_header.hash(&mut hasher);\n        let hash_value = hasher.finish();\n\n        assert_ne!(hash_value, 0, "Hash should not be zero");\n    }\n\n    #[test]\n    fn test_custom_hash_equality() {\n        let header1 = Custom(ByteStr::from_static("Header-One"));\n        let header2 = Custom(ByteStr::from_static("Header-One"));\n        let header3 = Custom(ByteStr::from_static("Header-Two"));\n\n        let mut hasher1 = IdHasher::default();\n        header1.hash(&mut hasher1);\n        let hash1 = hasher1.finish();\n\n        let mut hasher2 = IdHasher::default();\n        header2.hash(&mut hasher2);\n        let hash2 = hasher2.finish();\n\n        let mut hasher3 = IdHasher::default();\n        header3.hash(&mut hasher3);\n        let hash3 = hasher3.finish();\n\n        assert_eq!(hash1, hash2, "Hashes of equal headers should be equal");\n        assert_ne!(hash1, hash3, "Hashes of different headers should not be equal");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579796, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=304, prompt_tokens=1282, total_tokens=1586, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllzoZii9naWYiqNSRh2Wn1eMtgt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::name::{HdrName, StandardHeader};\n\n    #[test]\n    fn test_from_standard_header() {\n        // Given a StandardHeader, create an instance\n        let standard_header = StandardHeader::HeaderName1; // Replace HeaderName1 with a valid variant\n\n        // When using the From implementation\n        let hdr_name: HdrName = HdrName::from(standard_header);\n\n        // Then the inner representation should be a Standard variant\n        match hdr_name.inner {\n            Repr::Standard(ref hdr) => {\n                assert_eq!(*hdr, standard_header);\n            },\n            _ => panic!("Expected inner representation to be Standard"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579803, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=157, prompt_tokens=929, total_tokens=1086, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclm5gryFmQU2Yk69Umn2uueRKnl2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n\n    #[test]\n    fn test_as_str_standard_header() {\n        let header_name = HeaderName::from_static("content-length");\n        assert_eq!(header_name.as_str(), "content-length");\n    }\n\n    #[test]\n    fn test_as_str_custom_header() {\n        let header_name = HeaderName::from_static("custom-header");\n        assert_eq!(header_name.as_str(), "custom-header");\n    }\n\n    #[test]\n    fn test_as_str_empty_header() {\n        let header_name = HeaderName::from_static(" ");\n        assert_eq!(header_name.as_str(), " ");\n    }\n\n    #[test]\n    fn test_as_str_non_ascii_header() {\n        let header_name = HeaderName::from_static("x-custm-header");\n        assert_eq!(header_name.as_str(), "x-custm-header");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579809, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=199, prompt_tokens=4221, total_tokens=4420, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclmDvFoySYswZatbBUsJr540cL0u', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, CONTENT_TYPE};\n    use http::HeaderMap;\n\n    #[test]\n    fn test_find_existing_header() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        map.insert(CONTENT_TYPE, "application/json".parse().unwrap());\n        \n        let header_name = HeaderName::from_static("content-length");\n        let result = header_name.find(&map);\n        \n        assert_eq!(result, Some((0, 0))); // index in the `indices`\n    }\n\n    #[test]\n    fn test_find_non_existing_header() {\n        let map = HeaderMap::new();\n        \n        let header_name = HeaderName::from_static("custom-header");\n        let result = header_name.find(&map);\n        \n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_find_header_case_insensitivity() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        \n        let header_name = HeaderName::from_static("CONTENT_LENGTH");\n        let result = header_name.find(&map);\n        \n        assert_eq!(result, Some((0, 0))); // index in the `indices`\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579817, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=284, prompt_tokens=16361, total_tokens=16645, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclmMXYtCINH3lTzP67Au0hT5MXAa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, HeaderMap, CONTENT_LENGTH};\n    \n    #[test]\n    fn test_try_entry_success() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        \n        let header_name = CONTENT_LENGTH;\n        let entry = header_name.try_entry(&mut map);\n        \n        assert!(entry.is_ok());\n    }\n\n    #[test]\n    fn test_try_entry_fail_invalid() {\n        let mut map = HeaderMap::new();\n        // Attempting to use an invalid HeaderName\n        let invalid_header = HeaderName::from_static("Invalid-Header-Name-123");\n\n        let entry = invalid_header.try_entry(&mut map);\n        \n        assert!(entry.is_err());\n    }\n    \n    #[test]\n    fn test_try_entry_fail_max_size() {\n        let mut map = HeaderMap::with_capacity(1);\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        // Insert one more entry, which should exceed capacity\n        let header_name = HeaderName::from_static("X-Custom-Header");\n        let result = header_name.try_entry(&mut map);\n        \n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579826, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=269, prompt_tokens=16361, total_tokens=16630, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclmannuMGMWoX5h1CJZfLl1hGdEA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n    use http::HeaderMap;\n\n    #[test]\n    fn test_try_append_new_key() {\n        let mut map = HeaderMap::new();\n        let header_name = CONTENT_LENGTH;\n\n        let result = header_name.try_append(&mut map, "123".parse().unwrap()).unwrap();\n        assert!(result);\n        assert_eq!(map.get(&header_name).unwrap(), &"123");\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_try_append_existing_key() {\n        let mut map = HeaderMap::new();\n        let header_name = CONTENT_LENGTH;\n\n        map.insert(header_name, "123".parse().unwrap()).unwrap();\n        let result = header_name.try_append(&mut map, "456".parse().unwrap()).unwrap();\n        assert!(result);\n        let values = map.get_all(header_name);\n        assert_eq!(values.iter().count(), 2);\n    }\n\n    #[test]\n    fn test_try_append_max_size_reached() {\n        let mut map = HeaderMap::new();\n        let header_name = CONTENT_LENGTH;\n\n        // Simulate filling up the map to max size if necessary\n        for i in 0..MAX_SIZE {\n            let _ = header_name.try_append(&mut map, i.to_string().parse().unwrap()).unwrap();\n        }\n\n        let result = header_name.try_append(&mut map, "max".parse().unwrap());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_append_with_different_types() {\n        let mut map = HeaderMap::new();\n        let header_name = HeaderName::from_lowercase(b"custom-header").unwrap();\n\n        let result = header_name.try_append(&mut map, "value1".parse().unwrap()).unwrap();\n        assert!(result);\n        assert_eq!(map.get(&header_name).unwrap(), &"value1");\n        \n        let result2 = header_name.try_append(&mut map, "value2".parse().unwrap()).unwrap();\n        assert!(result2);\n        let values = map.get_all(header_name);\n        assert_eq!(values.iter().count(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579840, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=466, prompt_tokens=16361, total_tokens=16827, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclml6MCf6NNe0Jj8AqTxEVWL4SCJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName, CONTENT_LENGTH, HOST, USER_AGENT};\n    \n    #[test]\n    fn test_try_entry_with_new_key() {\n        let mut map = HeaderMap::new();\n        let key = HeaderName::from_static("x-custom-header");\n        \n        // Trying to enter a new key should succeed\n        let entry = key.try_entry(&mut map).expect("Should succeed");\n        assert!(entry.is_vacant());\n        \n        // Now we can insert a value into the entry\n        entry.insert("value1");\n        assert_eq!(map.get(&key).unwrap(), "value1");\n    }\n    \n    #[test]\n    fn test_try_entry_with_existing_key() {\n        let mut map = HeaderMap::new();\n        let key = HeaderName::from_static("x-custom-header");\n        \n        // Initial insert\n        map.insert(key.clone(), "value1");\n        \n        // Trying to enter an existing key\n        let entry = key.try_entry(&mut map).expect("Should succeed");\n        assert!(entry.is_occupied());\n        \n        // Insert new value into the existing entry\n        entry.insert("value2");\n        assert_eq!(map.get(&key).unwrap(), "value2");\n    }\n    \n    #[test]\n    fn test_try_entry_max_size() {\n        let mut map = HeaderMap::new();\n        // Insert until we hit max size\n        for i in 0..MAX_SIZE {\n            let key = HeaderName::from_static(&format!("x-header-{}", i));\n            map.insert(key, i.to_string());\n        }\n        \n        // This should fail since we hit max size\n        let key = HeaderName::from_static("x-overflow");\n        assert!(key.try_entry(&mut map).is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579851, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=386, prompt_tokens=16361, total_tokens=16747, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclmwlp8pjmVqfRk0qGVa6qpGKjQh', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n\n    #[test]\n    fn test_try_insert_success() {\n        let mut map = HeaderMap::new();\n        let key = HeaderName::from_static("X-Custom-Header");\n\n        // Try to insert a value\n        let result = key.try_insert(&mut map, "value1").unwrap();\n        assert!(result.is_none());\n        assert_eq!(map.get(key).unwrap(), &"value1");\n    }\n\n    #[test]\n    fn test_try_insert_update() {\n        let mut map = HeaderMap::new();\n        let key = HeaderName::from_static("X-Custom-Header");\n\n        // Insert initial value\n        map.try_insert(key, "value1").unwrap();\n        // Try to insert a new value\n        let result = key.try_insert(&mut map, "value2").unwrap();\n        assert_eq!(result, Some("value1"));\n        assert_eq!(map.get(key).unwrap(), &"value2");\n    }\n\n    #[test]\n    fn test_try_insert_max_size_reached() {\n        let mut map = HeaderMap::with_capacity(1);\n        let key = HeaderName::from_static("X-Custom-Header");\n\n        // Insert the first value\n        assert!(key.try_insert(&mut map, "value1").unwrap().is_none());\n        \n        // Insert the second value to exceed capacity\n        let result = key.try_insert(&mut map, "value2");\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579862, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=330, prompt_tokens=16361, total_tokens=16691, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcln4935M6Q1uKueD7zAMRzSUsTCW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n\n    #[test]\n    fn test_borrow_standard_header() {\n        let header_name = HeaderName::from_static("content-length");\n        let borrowed_str: &str = header_name.borrow();\n        assert_eq!(borrowed_str, "content-length");\n    }\n\n    #[test]\n    fn test_borrow_custom_header() {\n        let custom_header_name = HeaderName::from_static("my-custom-header");\n        let borrowed_str: &str = custom_header_name.borrow();\n        assert_eq!(borrowed_str, "my-custom-header");\n    }\n\n    #[test]\n    fn test_borrow_empty_header() {\n        let empty_header_name = HeaderName::from_static("");\n        let borrowed_str: &str = empty_header_name.borrow();\n        assert_eq!(borrowed_str, "");\n    }\n\n    #[test]\n    fn test_borrow_invalid_header() {\n        let invalid_header_result = std::panic::catch_unwind(|| {\n            HeaderName::from_static("Invalid-Header{}");\n        });\n\n        assert!(invalid_header_result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579870, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=240, prompt_tokens=4211, total_tokens=4451, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclnBgFCqcDtqJ6aaXT5MXOHo7rGR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n\n    #[test]\n    fn test_eq_same_standard_header() {\n        let header1 = HeaderName::from_static("content-length");\n        let header2 = HeaderName::from_static("content-length");\n        assert!(header1 == header2);\n    }\n\n    #[test]\n    fn test_eq_different_standard_header() {\n        let header1 = HeaderName::from_static("content-length");\n        let header2 = HeaderName::from_static("content-type");\n        assert!(header1 != header2);\n    }\n\n    #[test]\n    fn test_eq_with_lower_case() {\n        let header = HeaderName::from_static("content-length");\n        assert!(header == "content-length");\n        assert!(header == "Content-Length");\n        assert!(header != "content length");\n    }\n\n    #[test]\n    fn test_eq_with_custom_header() {\n        let custom_header1: &str = "custom-header";\n        let custom_header2: HeaderName = HeaderName::from_static(custom_header1);\n        assert!(custom_header2 == custom_header1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579877, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=245, prompt_tokens=4231, total_tokens=4476, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclnJFuObxri7jt9I2i9tDtNtTDwW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n\n    #[test]\n    fn test_eq_case_insensitive() {\n        let header_name = HeaderName::from_static("content-length");\n        \n        assert!(header_name.eq(&"content-length"));\n        assert!(header_name.eq(&"Content-Length"));\n        assert!(!header_name.eq(&"content length"));\n    }\n\n    #[test]\n    fn test_eq_with_different_cases() {\n        let header_name = HeaderName::from_static("content-type");\n        \n        assert!(header_name.eq(&"content-type"));\n        assert!(header_name.eq(&"Content-Type"));\n        assert!(!header_name.eq(&"Content Type"));\n    }\n\n    #[test]\n    fn test_eq_with_non_standard_header() {\n        let header_name = HeaderName::from_static("X-Custom-Header");\n        \n        assert!(header_name.eq(&"x-custom-header"));\n        assert!(header_name.eq(&"X-Custom-Header"));\n        assert!(!header_name.eq(&"x-customheader"));\n    }\n\n    #[test]\n    fn test_eq_empty_string() {\n        let header_name = HeaderName::from_static("content-length");\n        \n        assert!(!header_name.eq(&""));\n    }\n\n    #[test]\n    fn test_eq_with_different_length() {\n        let header_name = HeaderName::from_static("content-length");\n        \n        assert!(!header_name.eq(&"content-lenght"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579885, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=314, prompt_tokens=4242, total_tokens=4556, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclnQyexyVHClfoRZgil4YCOVwobp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, HdrName, StandardHeader};\n\n    #[test]\n    fn test_eq_standard_headers() {\n        let header_a = HeaderName::from(StandardHeader::CONTENT_LENGTH);\n        let header_b = HdrName::from(StandardHeader::CONTENT_LENGTH);\n        assert!(header_a.eq(&header_b));\n\n        let header_c = HdrName::from(StandardHeader::CONTENT_TYPE);\n        assert!(!header_a.eq(&header_c));\n    }\n\n    #[test]\n    fn test_eq_custom_headers() {\n        let custom_header_a = HdrName::custom(b"X-Custom-Header", false);\n        let custom_header_b = HdrName::custom(b"x-custom-header", false);\n        let header_a = HeaderName::from(Custom(ByteStr::from_static("X-Custom-Header")));\n\n        assert!(header_a.eq(&custom_header_a));\n        assert!(header_a.eq(&custom_header_b));\n\n        let custom_header_c = HdrName::custom(b"x-Custom-Header", true);\n        assert!(!header_a.eq(&custom_header_c));\n    }\n\n    #[test]\n    fn test_eq_mixed_case() {\n        let header_a = HeaderName::from(StandardHeader::CONTENT_LENGTH);\n        let custom_header = HdrName::custom(b"Content-Length", false);\n\n        assert!(header_a.eq(&custom_header));\n    }\n\n    #[test]\n    fn test_eq_different_custom_headers() {\n        let header_a = HdrName::custom(b"custom-header-a", false);\n        let header_b = HdrName::custom(b"custom-header-b", false);\n\n        assert!(!header_a.eq(&header_b));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579892, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=363, prompt_tokens=4750, total_tokens=5113, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclnaqJwOGD7VMLIJioB8UjfLqfzC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::CONTENT_LENGTH;\n\n    #[test]\n    fn test_eq_case_insensitive() {\n        assert_eq!(CONTENT_LENGTH, "content-length");\n        assert_eq!(CONTENT_LENGTH, "Content-Length");\n        assert_eq!(CONTENT_LENGTH, "CONTENT-LENGTH");\n    }\n    \n    #[test]\n    fn test_eq_case_sensitive() {\n        assert_ne!(CONTENT_LENGTH, "content length");\n        assert_ne!(CONTENT_LENGTH, "Content Length");\n    }\n    \n    #[test]\n    fn test_eq_with_non_standard() {\n        let custom_header = HeaderName::from_static("custom-header");\n        assert_eq!(custom_header, "custom-header");\n        assert_eq!(custom_header, "Custom-Header");\n        assert_ne!(custom_header, "custom header");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579902, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=175, prompt_tokens=4294, total_tokens=4469, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclnhr1gM38WNvAYFnlW7jrgzhaOW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n\n    #[test]\n    fn test_as_ref_standard_header() {\n        let header_name = HeaderName::from_static("content-length");\n        let result: &[u8] = header_name.as_ref();\n        assert_eq!(result, b"content-length");\n    }\n\n    #[test]\n    fn test_as_ref_custom_header() {\n        let header_name = HeaderName::from_static("custom-header");\n        let result: &[u8] = header_name.as_ref();\n        assert_eq!(result, b"custom-header");\n    }\n\n    #[test]\n    fn test_as_ref_empty_header() {\n        let header_name = HeaderName::from_static("");\n        let result: &[u8] = header_name.as_ref();\n        assert_eq!(result, b"");\n    }\n\n    #[test]\n    fn test_as_ref_invalid_header() {\n        let header_name = HeaderName::from_static("content{}length");\n        // The `as_ref` method should return the bytes, but we can\'t validate an invalid header name directly since it panics.\n        let result: &[u8] = header_name.as_ref();\n        assert_eq!(result, b"content{}length");\n    }\n\n    #[should_panic]\n    #[test]\n    fn test_as_ref_invalid_static_header() {\n        HeaderName::from_static("InvalidHeaderName!"); // Should panic\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579909, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=306, prompt_tokens=4222, total_tokens=4528, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclnpMm3yEdDeK6oT1k1LtGNYNJat', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderName;\n\n    #[test]\n    fn test_headername_as_ref() {\n        let header_name = HeaderName::from_static("content-length");\n        let header_str: &str = header_name.as_ref();\n        assert_eq!(header_str, "content-length");\n    }\n\n    #[test]\n    fn test_headername_with_custom_name_as_ref() {\n        let header_name = HeaderName::from_static("custom-header");\n        let header_str: &str = header_name.as_ref();\n        assert_eq!(header_str, "custom-header");\n    }\n\n    #[test]\n    fn test_headername_empty_as_ref() {\n        let header_name = HeaderName::from_static("non-empty-header");\n        let header_str: &str = header_name.as_ref();\n        assert!(!header_str.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579917, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=187, prompt_tokens=4215, total_tokens=4402, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclnvZWNDgzAsTcqtKtmc6gnFqzZ0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::*;\n\n    #[test]\n    fn test_header_name_from_clone() {\n        let original = HeaderName::from_static("content-length");\n        let cloned = HeaderName::from(&original);\n        assert_eq!(original, cloned);\n    }\n\n    #[test]\n    fn test_header_name_from_clone_is_different_instance() {\n        let original = HeaderName::from_static("content-length");\n        let cloned = HeaderName::from(&original);\n        assert!(std::ptr::eq(&original, &cloned) == false);\n    }\n\n    #[test]\n    fn test_header_name_from_static_standard() {\n        let standard_header = HeaderName::from_static("accept");\n        assert_eq!(standard_header.as_str(), "accept");\n    }\n\n    #[test]\n    fn test_header_name_from_static_custom() {\n        let custom_header = HeaderName::from_static("x-custom-header");\n        assert_eq!(custom_header.as_str(), "x-custom-header");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_header_name_from_static_invalid() {\n        HeaderName::from_static("Invalid-Header-Name-{}");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579923, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=253, prompt_tokens=4221, total_tokens=4474, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclo2tHgQKUe4Xx4EBw7ouPUjKQWF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use header::name::{Custom, HeaderName};\n\n    #[test]\n    fn test_from_custom() {\n        let custom_header_bytes = b"custom-header";\n        let custom = Custom(ByteStr::from_static("custom-header"));\n        let header_name: HeaderName = HeaderName::from(custom);\n\n        assert_eq!(header_name.as_str(), "custom-header");\n        assert_eq!(header_name.as_ref(), custom_header_bytes);\n    }\n\n    #[test]\n    fn test_from_custom_with_different_value() {\n        let custom_header_bytes = b"another-custom-header";\n        let custom = Custom(ByteStr::from_static("another-custom-header"));\n        let header_name: HeaderName = HeaderName::from(custom);\n\n        assert_eq!(header_name.as_str(), "another-custom-header");\n        assert_eq!(header_name.as_ref(), custom_header_bytes);\n    }\n\n    #[test]\n    fn test_from_custom_with_lowercase() {\n        let custom = Custom(ByteStr::from_static("lowercase-header"));\n        let header_name: HeaderName = HeaderName::from(custom);\n        \n        assert_eq!(header_name.as_str(), "lowercase-header");\n    }\n\n    #[test]\n    fn test_from_custom_with_empty() {\n        let custom = Custom(ByteStr::from_static(""));\n        let header_name: HeaderName = HeaderName::from(custom);\n        \n        assert_eq!(header_name.as_str(), "");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579930, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=301, prompt_tokens=5187, total_tokens=5488, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclo9wgfCiwbsdmFHHkiv5MxSvvKz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HdrName, HeaderName, StandardHeader};\n\n    #[test]\n    fn test_from_standard_header() {\n        let standard_header = StandardHeader::from_bytes(b"content-length").unwrap();\n        let hdr_name: HeaderName = HeaderName::from(HdrName::from(standard_header));\n        assert_eq!(hdr_name.as_str(), "content-length");\n    }\n\n    #[test]\n    fn test_from_custom_header_lower() {\n        let custom_buf: &[u8] = b"custom-header";\n        let hdr_name: HeaderName = HeaderName::from(HdrName::custom(custom_buf, true));\n        assert_eq!(hdr_name.as_str(), "custom-header");\n    }\n\n    #[test]\n    fn test_from_custom_header_upper() {\n        let custom_buf: &[u8] = b"CUSTOM-HEADER";\n        let hdr_name: HeaderName = HeaderName::from(HdrName::custom(custom_buf, false));\n        assert_eq!(hdr_name.as_str(), "custom-header");\n    }\n\n    #[test]\n    fn test_from_invalid_custom_header() {\n        let custom_buf: &[u8] = b"inv@lid-header";\n        let hdr_name: HeaderName = HeaderName::from(HdrName::custom(custom_buf, false));\n        assert_ne!(hdr_name.as_str(), "inv@lid-header");\n    }\n\n    #[test]\n    fn test_from_custom_header_bytes() {\n        let custom_buf: &[u8] = b"header-name";\n        let hdr_name: HeaderName = HeaderName::from(HdrName::custom(custom_buf, false));\n        assert_eq!(hdr_name.as_str(), "header-name");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579937, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=361, prompt_tokens=4915, total_tokens=5276, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcloJ77yMkGVuR3hhVJ68fG6dgel8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, StandardHeader};\n\n    #[test]\n    fn test_header_name_from_standard_header() {\n        // Assuming StandardHeader has variants like CONTENT_LENGTH, CONTENT_TYPE, etc.\n        // You would use actual StandardHeader variants here.\n        let standard_header = StandardHeader::CONTENT_LENGTH; // Example\n        let header_name: HeaderName = HeaderName::from(standard_header);\n\n        // Check that the header name is as expected\n        assert_eq!(header_name.as_str(), "content-length"); // Assuming this is expected output\n    }\n\n    #[test]\n    fn test_header_name_from_other_standard_header() {\n        let standard_header = StandardHeader::CONTENT_TYPE; // Example\n        let header_name: HeaderName = HeaderName::from(standard_header);\n\n        // Check that the header name is as expected\n        assert_eq!(header_name.as_str(), "content-type"); // Assuming this is expected output\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579947, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=210, prompt_tokens=4227, total_tokens=4437, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcloPY38arT6oViyUWOs0ZatAh1u2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderName;\n    \n    #[test]\n    fn test_try_from_valid_bytes() {\n        let valid_bytes = b"Valid-Header-Name";\n        let header_name = HeaderName::try_from(valid_bytes);\n        assert!(header_name.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_bytes() {\n        let invalid_bytes = b"Invalid Header Name";\n        let header_name = HeaderName::try_from(invalid_bytes);\n        assert!(header_name.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_bytes() {\n        let empty_bytes: &[u8] = b"";\n        let header_name = HeaderName::try_from(empty_bytes);\n        assert!(header_name.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579953, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=172, prompt_tokens=176, total_tokens=348, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcloUMH5I0nGFUQVrunHmHeqC10so', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n    use http::header::name::HeaderName;\n\n    #[test]\n    fn test_try_from_valid_string() {\n        let valid_string = String::from("Valid-Header-Name");\n        let result = HeaderName::try_from(&valid_string);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), HeaderName::from_bytes(valid_string.as_bytes()).unwrap());\n    }\n\n    #[test]\n    fn test_try_from_invalid_string() {\n        let invalid_string = String::from("Invalid Header Name");\n        let result = HeaderName::try_from(&invalid_string);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let empty_string = String::from("");\n        let result = HeaderName::try_from(&empty_string);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579958, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=197, prompt_tokens=661, total_tokens=858, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclobKZxNjm04sQR6s45LCgbtYU8S', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n    use http::header::name::HeaderName;\n\n    #[test]\n    fn test_try_from_valid_str() {\n        let valid_str = "Valid-Header-Name";\n        let header_name = HeaderName::try_from(valid_str);\n        assert!(header_name.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_str() {\n        let invalid_str = "Invalid Header Name";\n        let header_name = HeaderName::try_from(invalid_str);\n        assert!(header_name.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_str() {\n        let empty_str = "";\n        let header_name = HeaderName::try_from(empty_str);\n        assert!(header_name.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579965, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=173, prompt_tokens=173, total_tokens=346, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclohQdI4q35TvSPuiS280MFLXqUi', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_string() {\n        let valid_string = String::from("Valid-Header-Name");\n        let result = HeaderName::try_from(valid_string);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let empty_string = String::from("");\n        let result = HeaderName::try_from(empty_string);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_invalid_string() {\n        let invalid_string = String::from("Invalid Header Name!");\n        let result = HeaderName::try_from(invalid_string);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579971, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=165, prompt_tokens=656, total_tokens=821, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclopaafYcBiudr4YsBLz2JdqmoWG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n    use http::header::name::HeaderName;\n\n    #[test]\n    fn test_try_from_valid_vec() {\n        let vec = b"Valid-Header-Name".to_vec();\n        let result = HeaderName::try_from(vec);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_vec() {\n        let vec = b"Invalid Header Name".to_vec(); // space is invalid in header names\n        let result = HeaderName::try_from(vec);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_vec() {\n        let vec = Vec::new();\n        let result = HeaderName::try_from(vec);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579979, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=179, prompt_tokens=176, total_tokens=355, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclox38N4J8wumG29dUodnlf8ScDc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::name::HeaderName;\n    use http::header::name::InvalidHeaderName;\n\n    #[test]\n    fn test_from_str_valid() {\n        let valid_header = "X-Custom-Header";\n        let result = HeaderName::from_str(valid_header);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().as_ref(), valid_header);\n    }\n\n    #[test]\n    fn test_from_str_invalid() {\n        let invalid_header = "Invalid_Header@Name";\n        let result = HeaderName::from_str(invalid_header);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err()._priv, ());\n    }\n\n    #[test]\n    fn test_from_str_empty() {\n        let empty_header = "";\n        let result = HeaderName::from_str(empty_header);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err()._priv, ());\n    }\n\n    #[test]\n    fn test_from_str_special_chars() {\n        let special_header = "X-Custom-Header-!#";\n        let result = HeaderName::from_str(special_header);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err()._priv, ());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579987, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=267, prompt_tokens=181, total_tokens=448, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclp3Ji7v8rTQ9UFm5f5tinl9meW0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::Hasher;\n    use crate::header::name::MaybeLower;\n    use crate::extensions::IdHasher;\n\n    #[test]\n    fn test_hash_lower() {\n        let buf = b"example";\n        let maybe_lower = MaybeLower {\n            buf,\n            lower: true,\n        };\n        let mut hasher = IdHasher::default();\n        maybe_lower.hash(&mut hasher);\n        assert_eq!(hasher.finish(), 6287261747486786162); // Replace with expected value\n    }\n\n    #[test]\n    fn test_hash_not_lower() {\n        let buf = b"example";\n        let maybe_lower = MaybeLower {\n            buf,\n            lower: false,\n        };\n        let mut hasher = IdHasher::default();\n        maybe_lower.hash(&mut hasher);\n        assert_eq!(hasher.finish(), 17703538338929227851); // Replace with expected value\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579993, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=209, prompt_tokens=509, total_tokens=718, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclp9QAoYIi2J2f3oEXZcVU9UGirB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_cmp_equal() {\n        let value1 = HeaderValue::from_static("test");\n        let value2 = HeaderValue::from_static("test");\n        assert_eq!(value1.cmp(&value2), cmp::Ordering::Equal);\n    }\n\n    #[test]\n    fn test_cmp_less() {\n        let value1 = HeaderValue::from_static("apple");\n        let value2 = HeaderValue::from_static("banana");\n        assert_eq!(value1.cmp(&value2), cmp::Ordering::Less);\n    }\n\n    #[test]\n    fn test_cmp_greater() {\n        let value1 = HeaderValue::from_static("banana");\n        let value2 = HeaderValue::from_static("apple");\n        assert_eq!(value1.cmp(&value2), cmp::Ordering::Greater);\n    }\n\n    #[test]\n    fn test_cmp_different_length() {\n        let value1 = HeaderValue::from_static("test");\n        let value2 = HeaderValue::from_static("testing");\n        assert_eq!(value1.cmp(&value2), cmp::Ordering::Less);\n    }\n\n    #[test]\n    fn test_cmp_with_non_ascii() {\n        let value1 = HeaderValue::from_static("abc");\n        let value2 = HeaderValue::from_static("abc\\xFF");\n        assert_eq!(value1.cmp(&value2), cmp::Ordering::Less);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579999, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=317, prompt_tokens=4445, total_tokens=4762, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclpKxFEhMFX4u2pH0uKLPAzAHC85', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_eq_header_value_string() {\n        let header_value = HeaderValue::from_static("test_value");\n        let other_string = String::from("test_value");\n        assert!(header_value.eq(&&other_string));\n    }\n\n    #[test]\n    fn test_eq_header_value_bytes() {\n        let header_value = HeaderValue::from_static("test_value");\n        let other_bytes = b"test_value";\n        assert!(header_value.eq(&&other_bytes[..]));\n    }\n\n    #[test]\n    fn test_eq_header_value_str() {\n        let header_value = HeaderValue::from_static("test_value");\n        let other_str = "test_value";\n        assert!(header_value.eq(&other_str));\n    }\n\n    #[test]\n    fn test_eq_different_value() {\n        let header_value = HeaderValue::from_static("test_value");\n        let other_str = "different_value";\n        assert!(!header_value.eq(&other_str));\n    }\n\n    #[test]\n    fn test_eq_empty() {\n        let header_value = HeaderValue::from_static("");\n        let other_str = "";\n        assert!(header_value.eq(&other_str));\n    }\n\n    #[test]\n    fn test_eq_sensitive() {\n        let mut header_value = HeaderValue::from_static("secret");\n        header_value.set_sensitive(true);\n        let other_str = "secret";\n        assert!(header_value.eq(&other_str));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580010, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=317, prompt_tokens=4448, total_tokens=4765, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclpRC0dCtm3iBDKSPVdZ2iwiX1dz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_eq_with_byte_slice() {\n        let header_value = HeaderValue::from_static("Test");\n        let byte_slice: &[u8] = b"Test";\n\n        assert!(header_value.eq(byte_slice));\n    }\n\n    #[test]\n    fn test_eq_with_different_byte_slice() {\n        let header_value = HeaderValue::from_static("Test");\n        let byte_slice: &[u8] = b"Different";\n\n        assert!(!header_value.eq(byte_slice));\n    }\n\n    #[test]\n    fn test_eq_with_empty_byte_slice() {\n        let header_value = HeaderValue::from_static("");\n        let byte_slice: &[u8] = b"";\n\n        assert!(header_value.eq(byte_slice));\n    }\n\n    #[test]\n    fn test_eq_with_non_empty_empty_byte_slice() {\n        let header_value = HeaderValue::from_static("NonEmpty");\n        let byte_slice: &[u8] = b"";\n\n        assert!(!header_value.eq(byte_slice));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580017, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=234, prompt_tokens=4446, total_tokens=4680, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclpZjGfmcZ4VUImBlcMxJiklwDPj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_eq_with_string() {\n        let header_value = HeaderValue::from_static("test_value");\n        let string_value = String::from("test_value");\n        assert!(header_value.eq(&string_value));\n    }\n\n    #[test]\n    fn test_eq_with_different_string() {\n        let header_value = HeaderValue::from_static("test_value");\n        let string_value = String::from("different_value");\n        assert!(!header_value.eq(&string_value));\n    }\n\n    #[test]\n    fn test_eq_with_empty_string() {\n        let header_value = HeaderValue::from_static("");\n        let string_value = String::from("");\n        assert!(header_value.eq(&string_value));\n    }\n\n    #[test]\n    fn test_eq_with_empty_header_value() {\n        let header_value = HeaderValue::from_static("");\n        let string_value = String::from("not_empty");\n        assert!(!header_value.eq(&string_value));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580025, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=223, prompt_tokens=4931, total_tokens=5154, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclpgSveQ8kabE75Z3hb5J7VFo9AJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_header_value_eq_with_str() {\n        let hv1 = HeaderValue::from_static("test");\n        let hv2 = "test";\n        let hv3 = HeaderValue::from_static("not_test");\n\n        assert!(hv1.eq(hv2));\n        assert!(!hv1.eq(hv3));\n    }\n\n    #[test]\n    fn test_header_value_eq_with_empty_string() {\n        let hv1 = HeaderValue::from_static("");\n        let hv2 = "";\n        let hv3 = HeaderValue::from_static("not_empty");\n\n        assert!(hv1.eq(hv2));\n        assert!(!hv1.eq(hv3));\n    }\n\n    #[test]\n    fn test_header_value_eq_with_non_ascii() {\n        let hv1 = HeaderValue::from_static("test_\\xFF");\n        let hv2 = "test_\\xFF";\n        let hv3 = "test";\n\n        assert!(hv1.eq(hv2));\n        assert!(!hv1.eq(hv3));\n    }\n\n    #[test]\n    fn test_header_value_eq_with_different_lengths() {\n        let hv1 = HeaderValue::from_static("short");\n        let hv2 = "longer_string";\n\n        assert!(!hv1.eq(hv2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580032, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=291, prompt_tokens=4445, total_tokens=4736, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclpoBvn7C7eV7EpsELTKx6sGwwXE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_eq_same_values() {\n        let value1 = HeaderValue::from_static("test");\n        let value2 = HeaderValue::from_static("test");\n        assert!(value1.eq(&value2));\n    }\n\n    #[test]\n    fn test_eq_different_values() {\n        let value1 = HeaderValue::from_static("test1");\n        let value2 = HeaderValue::from_static("test2");\n        assert!(!value1.eq(&value2));\n    }\n\n    #[test]\n    fn test_eq_with_string() {\n        let value = HeaderValue::from_static("test");\n        let string_val = String::from("test");\n        assert!(value.eq(&string_val));\n    }\n\n    #[test]\n    fn test_eq_with_bytes() {\n        let value = HeaderValue::from_static("test");\n        let byte_val = b"test";\n        assert!(value.eq(&byte_val));\n    }\n\n    #[test]\n    fn test_eq_with_str() {\n        let value = HeaderValue::from_static("test");\n        let str_val = "test";\n        assert!(value.eq(&str_val));\n    }\n\n    #[test]\n    fn test_eq_different_types() {\n        let value1 = HeaderValue::from_static("test");\n        let value2 = HeaderValue::from_static("TEST");\n        assert!(!value1.eq(&value2)); // Case sensitive\n    }\n\n    #[test]\n    fn test_eq_with_empty() {\n        let value1 = HeaderValue::from_static("");\n        let value2 = HeaderValue::from_static("");\n        assert!(value1.eq(&value2));\n        let value3 = HeaderValue::from_static("test");\n        assert!(!value1.eq(&value3));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580040, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=385, prompt_tokens=4443, total_tokens=4828, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclpxlxFX4By7ruq62Meyt9YULY2I', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let value1 = HeaderValue::from_static("test");\n        let value2 = HeaderValue::from_static("test");\n        assert_eq!(value1.partial_cmp(&value2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let value1 = HeaderValue::from_static("apple");\n        let value2 = HeaderValue::from_static("banana");\n        assert_eq!(value1.partial_cmp(&value2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let value1 = HeaderValue::from_static("cherry");\n        let value2 = HeaderValue::from_static("banana");\n        assert_eq!(value1.partial_cmp(&value2), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_type() {\n        let value = HeaderValue::from_static("test");\n        let string_value = String::from("test");\n        assert_eq!(value.partial_cmp(&string_value), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_length() {\n        let value1 = HeaderValue::from_static("test");\n        let value2 = HeaderValue::from_static("test!");\n        assert_eq!(value1.partial_cmp(&value2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let value1 = HeaderValue::from_static("");\n        let value2 = HeaderValue::from_static("non-empty");\n        assert_eq!(value1.partial_cmp(&value2), Some(cmp::Ordering::Less));\n        assert_eq!(value2.partial_cmp(&value1), Some(cmp::Ordering::Greater));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580049, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=412, prompt_tokens=4455, total_tokens=4867, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclq9mLzo45gP9gr3qGwnMlGPFgvQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let hv = HeaderValue::from_static("test");\n        let result = hv.partial_cmp(b"test");\n        assert_eq!(result, Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let hv = HeaderValue::from_static("abc");\n        let result = hv.partial_cmp(b"xyz");\n        assert_eq!(result, Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let hv = HeaderValue::from_static("xyz");\n        let result = hv.partial_cmp(b"abc");\n        assert_eq!(result, Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let hv = HeaderValue::from_static("");\n        let result = hv.partial_cmp(b"abc");\n        assert_eq!(result, Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_empty_bytes() {\n        let hv = HeaderValue::from_static("abc");\n        let result = hv.partial_cmp(b"");\n        assert_eq!(result, Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_inconsistent_types() {\n        let hv = HeaderValue::from_static("test");\n        let result = hv.partial_cmp(b"test");\n        assert!(result.is_some());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580061, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=334, prompt_tokens=4456, total_tokens=4790, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclqHwaltPYCnACPXmJgTaQwCUcLo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_partial_cmp_with_equal_strings() {\n        let header_value = HeaderValue::from_static("test_value");\n        let comparable_string = String::from("test_value");\n        assert_eq!(header_value.partial_cmp(&comparable_string), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_greater_string() {\n        let header_value = HeaderValue::from_static("apple");\n        let comparable_string = String::from("banana");\n        assert_eq!(header_value.partial_cmp(&comparable_string), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_smaller_string() {\n        let header_value = HeaderValue::from_static("grape");\n        let comparable_string = String::from("apple");\n        assert_eq!(header_value.partial_cmp(&comparable_string), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_length_strings() {\n        let header_value = HeaderValue::from_static("short");\n        let comparable_string = String::from("longer_string");\n        assert_eq!(header_value.partial_cmp(&comparable_string), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_empty_string() {\n        let header_value = HeaderValue::from_static("non_empty");\n        let comparable_string = String::from("");\n        assert_eq!(header_value.partial_cmp(&comparable_string), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_uppercase_string() {\n        let header_value = HeaderValue::from_static("hello");\n        let comparable_string = String::from("HELLO");\n        assert_eq!(header_value.partial_cmp(&comparable_string), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_invisible_asciis() {\n        let header_value = HeaderValue::from_static("valid");\n        let comparable_string = String::from("invalid\\x7F"); // contains DEL character\n        assert_eq!(header_value.partial_cmp(&comparable_string), Some(cmp::Ordering::Greater)); // behavior dependent on implementation\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580069, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=479, prompt_tokens=4940, total_tokens=5419, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclqS9MdD5eid1piN640wb7hTclms', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let hv = HeaderValue::from_static("test");\n        assert_eq!(hv.partial_cmp("test"), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let hv = HeaderValue::from_static("abc");\n        assert_eq!(hv.partial_cmp("def"), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let hv = HeaderValue::from_static("xyz");\n        assert_eq!(hv.partial_cmp("abc"), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_length() {\n        let hv = HeaderValue::from_static("abcd");\n        assert_eq!(hv.partial_cmp("abc"), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_case_sensitive() {\n        let hv = HeaderValue::from_static("abc");\n        assert_eq!(hv.partial_cmp("ABC"), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let hv = HeaderValue::from_static("");\n        assert_eq!(hv.partial_cmp("nonempty"), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_vs_none() {\n        let hv = HeaderValue::from_static("header");\n        assert!(hv.partial_cmp("header") != None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580080, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=331, prompt_tokens=4455, total_tokens=4786, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclqaXdwpg1C19ZCiMDefGRYwRZyl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming the module is in the same scope\n    use http::header::HeaderValue; // Adjust the import path as necessary\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let value1 = HeaderValue::from_static("test");\n        let value2 = HeaderValue::from_static("test");\n        assert_eq!(value1.partial_cmp(&value2), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let value1 = HeaderValue::from_static("abc");\n        let value2 = HeaderValue::from_static("def");\n        assert_eq!(value1.partial_cmp(&value2), Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let value1 = HeaderValue::from_static("xyz");\n        let value2 = HeaderValue::from_static("abc");\n        assert_eq!(value1.partial_cmp(&value2), Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_cases() {\n        let value1 = HeaderValue::from_static("abc");\n        let value2 = HeaderValue::from_static("ABC");\n        assert_eq!(value1.partial_cmp(&value2), Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_lengths() {\n        let value1 = HeaderValue::from_static("abc");\n        let value2 = HeaderValue::from_static("abcd");\n        assert_eq!(value1.partial_cmp(&value2), Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_bytes() {\n        let value1 = HeaderValue::from_static("hello");\n        let value2: &[u8] = b"hello";\n        assert_eq!(value1.partial_cmp(value2), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_string() {\n        let value1 = HeaderValue::from_static("value");\n        let value2 = String::from("value");\n        assert_eq!(value1.partial_cmp(&value2), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_str() {\n        let value1 = HeaderValue::from_static("rust");\n        let value2 = "rust";\n        assert_eq!(value1.partial_cmp(value2), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_none() {\n        let value1 = HeaderValue::from_static("test");\n        let value2 = HeaderValue::from_static("test2");\n        assert!(value1.partial_cmp(&value2).is_some());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580088, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=574, prompt_tokens=4450, total_tokens=5024, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclqm5NWTbZZCWP8yl4FN06h9MOJy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_as_ref() {\n        let value = HeaderValue::from_static("hello");\n        assert_eq!(value.as_ref(), b"hello");\n\n        let empty_value = HeaderValue::from_static("");\n        assert_eq!(empty_value.as_ref(), b"");\n\n        let value_with_special_chars = HeaderValue::from_static("value\\xFA");\n        assert_eq!(value_with_special_chars.as_ref(), b"value\\xFA");\n    }\n\n    #[test]\n    fn test_as_ref_with_invalid_utf8() {\n        let value_with_invalid_utf8 = HeaderValue::from_bytes(b"hello\\xFF").unwrap();\n        assert_eq!(value_with_invalid_utf8.as_ref(), b"hello\\xFF");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580100, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=174, prompt_tokens=4446, total_tokens=4620, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclqqckxi14rk4TV1B1PlrdQFoFWD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_header_value_from() {\n        let original = HeaderValue::from_static("test_value");\n        let copied = HeaderValue::from(&original);\n        assert_eq!(original, copied);\n        assert!(std::ptr::eq(&original, &copied) == false); // Ensure a clone has been made\n    }\n\n    #[test]\n    fn test_header_value_from_empty() {\n        let original = HeaderValue::from_static("");\n        let copied = HeaderValue::from(&original);\n        assert_eq!(original, copied);\n        assert!(std::ptr::eq(&original, &copied) == false); // Ensure a clone has been made\n    }\n\n    #[test]\n    fn test_header_value_from_different_strings() {\n        let original = HeaderValue::from_static("another_value");\n        let copied = HeaderValue::from(&original);\n        assert_eq!(original, copied);\n        assert!(std::ptr::eq(&original, &copied) == false); // Ensure a clone has been made\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580104, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=242, prompt_tokens=4446, total_tokens=4688, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclqxGiug2LIe1xF5SPgKrDSq7oG2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, HeaderValue};\n\n    #[test]\n    fn test_header_value_from_header_name() {\n        // Test case for a standard header\n        let header_name = HeaderName::from_static("content-length");\n        let header_value: HeaderValue = header_name.into();\n        assert_eq!(header_value.as_bytes(), b"content-length");\n        assert!(!header_value.is_sensitive());\n\n        // Test case for a custom header\n        let custom_header_name = HeaderName::from_static("x-custom-header");\n        let custom_header_value: HeaderValue = custom_header_name.into();\n        assert_eq!(custom_header_value.as_bytes(), b"x-custom-header");\n        assert!(!custom_header_value.is_sensitive());\n    }\n\n    #[test]\n    fn test_header_value_from_custom_header_name() {\n        // Test case for a custom header with different characters\n        let header_name = HeaderName::from_static("x-unique-header");\n        let header_value: HeaderValue = header_name.into();\n        assert_eq!(header_value.as_bytes(), b"x-unique-header");\n        assert!(!header_value.is_sensitive());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580111, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=247, prompt_tokens=8515, total_tokens=8762, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclr4KSksPHevkpqvzFCingku8WPD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_header_value_from_i16() {\n        let value = HeaderValue::from(42i16);\n        assert_eq!(value.to_str().unwrap(), "42");\n        assert_eq!(value.len(), 2);\n        assert!(!value.is_empty());\n        \n        let negative_value = HeaderValue::from(-5i16);\n        assert_eq!(negative_value.to_str().unwrap(), "-5");\n        assert_eq!(negative_value.len(), 2);\n        assert!(!negative_value.is_empty());\n    }\n\n    #[test]\n    fn test_header_value_from_i16_zero() {\n        let value = HeaderValue::from(0i16);\n        assert_eq!(value.to_str().unwrap(), "0");\n        assert_eq!(value.len(), 1);\n        assert!(!value.is_empty());\n    }\n\n    #[test]\n    fn test_header_value_from_i16_large() {\n        let value = HeaderValue::from(32767i16);\n        assert_eq!(value.to_str().unwrap(), "32767");\n        assert_eq!(value.len(), 5);\n        assert!(!value.is_empty());\n    }\n    \n    #[test]\n    fn test_header_value_from_i16_min() {\n        let value = HeaderValue::from(i16::MIN);\n        assert_eq!(value.to_str().unwrap(), "-32768");\n        assert_eq!(value.len(), 6);\n        assert!(!value.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580118, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=321, prompt_tokens=4480, total_tokens=4801, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclrCvCr4rkgMQn211cOt3coBtrBj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_from_integer() {\n        let value = HeaderValue::from(42);\n        assert_eq!(value.to_str().unwrap(), "42");\n    }\n\n    #[test]\n    fn test_from_negative_integer() {\n        let value = HeaderValue::from(-1);\n        assert_eq!(value.to_str().unwrap(), "-1");\n    }\n\n    #[test]\n    fn test_from_zero() {\n        let value = HeaderValue::from(0);\n        assert_eq!(value.to_str().unwrap(), "0");\n    }\n\n    #[test]\n    fn test_from_large_integer() {\n        let value = HeaderValue::from(1_000_000);\n        assert_eq!(value.to_str().unwrap(), "1000000");\n    }\n\n    #[test]\n    fn test_from_integer_to_bytes() {\n        let value = HeaderValue::from(100);\n        assert_eq!(value.as_bytes(), b"100");\n    }\n\n    #[test]\n    fn test_from_integer_is_not_empty() {\n        let value = HeaderValue::from(123);\n        assert!(!value.is_empty());\n    }\n\n    #[test]\n    fn test_from_integer_is_sensitive() {\n        let mut value = HeaderValue::from(456);\n        value.set_sensitive(true);\n        assert!(value.is_sensitive());\n    }\n\n    #[test]\n    fn test_from_integer_clone() {\n        let value = HeaderValue::from(789);\n        let cloned_value = value.clone();\n        assert_eq!(value, cloned_value);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580126, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=336, prompt_tokens=4480, total_tokens=4816, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclrJU6Xb6noU4XcoIpixvRgSWtDF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_header_value_from_i64() {\n        let value: HeaderValue = HeaderValue::from(42);\n        assert_eq!(value.as_bytes(), b"42");\n    }\n    \n    #[test]\n    fn test_header_value_from_negative_i64() {\n        let value: HeaderValue = HeaderValue::from(-42);\n        assert_eq!(value.as_bytes(), b"-42");\n    }\n\n    #[test]\n    fn test_header_value_from_zero_i64() {\n        let value: HeaderValue = HeaderValue::from(0);\n        assert_eq!(value.as_bytes(), b"0");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580133, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=154, prompt_tokens=4480, total_tokens=4634, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclrQCmlEXEgqSJMrdAHPCW8VhKAA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_from_isize() {\n        let value: HeaderValue = HeaderValue::from(123_isize);\n        assert_eq!(value.to_str().unwrap(), "123");\n    }\n\n    #[test]\n    fn test_from_negative_isize() {\n        let value: HeaderValue = HeaderValue::from(-123_isize);\n        assert_eq!(value.to_str().unwrap(), "-123");\n    }\n\n    #[test]\n    fn test_from_zero_isize() {\n        let value: HeaderValue = HeaderValue::from(0_isize);\n        assert_eq!(value.to_str().unwrap(), "0");\n    }\n\n    #[test]\n    fn test_from_large_isize() {\n        let value: HeaderValue = HeaderValue::from(isize::MAX);\n        assert_eq!(value.to_str().unwrap(), &itoa::Buffer::new().format(isize::MAX));\n    }\n\n    #[test]\n    fn test_from_small_isize() {\n        let value: HeaderValue = HeaderValue::from(isize::MIN);\n        assert_eq!(value.to_str().unwrap(), &itoa::Buffer::new().format(isize::MIN));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580140, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=264, prompt_tokens=4481, total_tokens=4745, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclraDZ8st57LWRXTAgtLeV7CXTVp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_from_u16() {\n        let val = HeaderValue::from(42_u16);\n        assert_eq!(val.to_str().unwrap(), "42");\n        assert_eq!(val.len(), 2);\n        assert!(!val.is_empty());\n    }\n\n    #[test]\n    fn test_from_large_u16() {\n        let val = HeaderValue::from(65535_u16);\n        assert_eq!(val.to_str().unwrap(), "65535");\n        assert_eq!(val.len(), 5);\n    }\n\n    #[test]\n    fn test_from_zero() {\n        let val = HeaderValue::from(0_u16);\n        assert_eq!(val.to_str().unwrap(), "0");\n        assert_eq!(val.len(), 1);\n    }\n\n    #[test]\n    fn test_from_u16_negative() {\n        // This test may not be necessary since u16 cannot be negative,\n        // but it\'s here to signify intention to check bounds\n        let val = HeaderValue::from(0_u16);\n        assert_eq!(val.to_str().unwrap(), "0");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580150, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=253, prompt_tokens=4480, total_tokens=4733, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclrj8Oh2NChhsdjpC4pB2yAZH90e', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_header_value_from_u32() {\n        let value = HeaderValue::from(42u32);\n        assert_eq!(value.to_str().unwrap(), "42");\n    }\n\n    #[test]\n    fn test_header_value_from_zero() {\n        let value = HeaderValue::from(0u32);\n        assert_eq!(value.to_str().unwrap(), "0");\n    }\n\n    #[test]\n    fn test_header_value_from_large_number() {\n        let value = HeaderValue::from(1234567890u32);\n        assert_eq!(value.to_str().unwrap(), "1234567890");\n    }\n\n    #[test]\n    fn test_header_value_from_max_value() {\n        let value = HeaderValue::from(u32::MAX);\n        assert_eq!(value.to_str().unwrap(), "4294967295");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580159, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=201, prompt_tokens=4480, total_tokens=4681, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclrq9nt7lzCv8w3LVpJcZJkXBaoK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_from_u64() {\n        let value = HeaderValue::from(42u64);\n        assert_eq!(value.to_str().unwrap(), "42");\n    }\n\n    #[test]\n    fn test_from_u64_zero() {\n        let value = HeaderValue::from(0u64);\n        assert_eq!(value.to_str().unwrap(), "0");\n    }\n\n    #[test]\n    fn test_from_large_u64() {\n        let value = HeaderValue::from(u64::MAX);\n        assert_eq!(value.to_str().unwrap(), "18446744073709551615");\n    }\n\n    #[test]\n    fn test_from_negative_u64() {\n        // Since `u64` cannot be negative, this test is not valid.\n        // If the function is supposed to take signed integers, this test should be modified accordingly.\n        // However, since `u64` is unsigned, we will not create a test for negative values.\n        // Just a placeholder comment.\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580166, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=233, prompt_tokens=4480, total_tokens=4713, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclrxu5ZIEIFso67ciySB3OkKemhe', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_from_usize_zero() {\n        let value = HeaderValue::from(0usize);\n        assert_eq!(value.to_str().unwrap(), "0");\n    }\n\n    #[test]\n    fn test_from_usize_positive() {\n        let value = HeaderValue::from(42usize);\n        assert_eq!(value.to_str().unwrap(), "42");\n    }\n\n    #[test]\n    fn test_from_usize_large() {\n        let value = HeaderValue::from(1000usize);\n        assert_eq!(value.to_str().unwrap(), "1000");\n    }\n\n    #[test]\n    fn test_from_usize_max() {\n        let value = HeaderValue::from(usize::MAX);\n        assert_eq!(value.to_str().unwrap(), &itoa::Buffer::new().format(usize::MAX));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580173, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=198, prompt_tokens=4480, total_tokens=4678, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcls43pB0RrKbo0mr7TMbs9IHimBg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_try_from_valid_bytes() {\n        let valid_bytes = b"valid-header-value";\n        let result = HeaderValue::try_from(valid_bytes as &[u8]);\n        assert!(result.is_ok());\n        let header_value = result.unwrap();\n        assert_eq!(header_value.to_str().unwrap(), "valid-header-value");\n    }\n\n    #[test]\n    fn test_try_from_invalid_bytes() {\n        let invalid_bytes = b"\\x80"; // Invalid header value due to control character\n        let result = HeaderValue::try_from(invalid_bytes as &[u8]);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580180, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=156, prompt_tokens=177, total_tokens=333, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcls9w5ZScRaYNTppAEJV8cEZTqAs', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n    use http::header::value::HeaderValue;\n\n    #[test]\n    fn test_try_from_valid_string() {\n        let valid_string = String::from("ValidHeaderValue");\n        let result = HeaderValue::try_from(&valid_string);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_string() {\n        let invalid_string = String::from(""); // Assuming empty string is invalid\n        let result = HeaderValue::try_from(&invalid_string);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_non_ascii_string() {\n        let non_ascii_string = String::from("HeaderValueWithNonAscii");\n        let result = HeaderValue::try_from(&non_ascii_string);\n        assert!(result.is_err()); // Assuming non-ASCII is invalid for HeaderValue\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580185, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=201, prompt_tokens=661, total_tokens=862, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclsGXHlSiUQ1htWg8LEELXYlKgqC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_try_from_valid_string() {\n        let value = "example-header-value";\n        let result = HeaderValue::try_from(value);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().to_str().unwrap(), value);\n    }\n\n    #[test]\n    fn test_try_from_invalid_string() {\n        let value = "\\u{D800}"; // An example of an invalid UTF-8 character\n        let result = HeaderValue::try_from(value);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let value = "";\n        let result = HeaderValue::try_from(value);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().to_str().unwrap(), value);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580192, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=188, prompt_tokens=168, total_tokens=356, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclsLM2oHrcG0Vfc9pPyRuQ0XklxQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_string() {\n        let input = String::from("valid-header");\n        let result = HeaderValue::try_from(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let input = String::from("");\n        let result = HeaderValue::try_from(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_string() {\n        let input = String::from("invalid\\x00header"); // Contains a null byte\n        let result = HeaderValue::try_from(input);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580197, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=171, prompt_tokens=656, total_tokens=827, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclsQOqL87pMm5O0KfPh1fyYTZthC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::value::HeaderValue;\n\n    #[test]\n    fn test_try_from_valid_vec() {\n        let valid_vec = b"Valid Header Value".to_vec();\n        let result = HeaderValue::try_from(valid_vec);\n        assert!(result.is_ok());\n        let header_value = result.unwrap();\n        assert_eq!(header_value.to_string(), "Valid Header Value");\n    }\n\n    #[test]\n    fn test_try_from_empty_vec() {\n        let empty_vec = Vec::new();\n        let result = HeaderValue::try_from(empty_vec);\n        assert!(result.is_ok());\n        let header_value = result.unwrap();\n        assert_eq!(header_value.to_string(), "");\n    }\n\n    #[test]\n    fn test_try_from_invalid_vec() {\n        let invalid_vec = b"\\xFF".to_vec();\n        let result = HeaderValue::try_from(invalid_vec);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580202, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=206, prompt_tokens=177, total_tokens=383, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclsVY1suMYyBBZIhOhloijIQLNe3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::Hash;\n\n    #[test]\n    fn test_header_value_hash() {\n        let value1 = HeaderValue::from_static("test_value1");\n        let value2 = HeaderValue::from_static("test_value2");\n        let value3 = HeaderValue::from_static("test_value1");\n\n        let mut hasher1 = IdHasher::default();\n        let mut hasher2 = IdHasher::default();\n        let mut hasher3 = IdHasher::default();\n\n        value1.hash(&mut hasher1);\n        value2.hash(&mut hasher2);\n        value3.hash(&mut hasher3);\n\n        // value1 and value3 should hash to the same value\n        assert_eq!(hasher1.finish(), hasher3.finish());\n        // value1 and value2 should hash to different values\n        assert_ne!(hasher1.finish(), hasher2.finish());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580207, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=204, prompt_tokens=4594, total_tokens=4798, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclsbITfDMT7mVir9mvWXy8ByL13D', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_from_str_valid() {\n        let valid_str = "text/plain";\n        let result = HeaderValue::from_str(valid_str);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().to_str().unwrap(), valid_str);\n    }\n\n    #[test]\n    fn test_from_str_invalid() {\n        let invalid_str = "\\u{400}"; // Invalid character\n        let result = HeaderValue::from_str(invalid_str);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_from_str_empty() {\n        let empty_str = "";\n        let result = HeaderValue::from_str(empty_str);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().to_str().unwrap(), empty_str);\n    }\n\n    #[test]\n    fn test_from_str_large_length() {\n        let large_str = "a".repeat(1000);\n        let result = HeaderValue::from_str(&large_str);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().to_str().unwrap(), large_str);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580213, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=257, prompt_tokens=169, total_tokens=426, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclsjBtd6sBja2l4uqOYwgTNmkOrL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_eq_with_same_variant() {\n        let get1 = Method::GET;\n        let get2 = Method::GET;\n        assert!(get1.eq(&&get2));\n    }\n\n    #[test]\n    fn test_eq_with_different_variant() {\n        let get = Method::GET;\n        let post = Method::POST;\n        assert!(!get.eq(&&post));\n    }\n\n    #[test]\n    fn test_eq_with_equal_custom_method() {\n        let inline_method1 = Method::from_bytes(b"PATCH").unwrap();\n        let inline_method2 = Method::from_bytes(b"PATCH").unwrap();\n        assert!(inline_method1.eq(&&inline_method2));\n    }\n\n    #[test]\n    fn test_eq_with_different_custom_method() {\n        let inline_method1 = Method::from_bytes(b"PATCH").unwrap();\n        let inline_method2 = Method::from_bytes(b"DELETE").unwrap();\n        assert!(!inline_method1.eq(&&inline_method2));\n    }\n\n    #[test]\n    fn test_eq_with_different_types() {\n        let get = Method::GET;\n        assert!(get.eq(&&"GET"));\n        assert!(!get.eq(&&"POST"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580221, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=277, prompt_tokens=2364, total_tokens=2641, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclsqJqeSiZL7Bi38thNgp4xSP9Ft', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_eq_method_with_valid_str() {\n        let get_method = Method::GET;\n        let get_str = "GET";\n        assert!(get_method.eq(&get_str));\n    }\n\n    #[test]\n    fn test_eq_method_with_invalid_str() {\n        let post_method = Method::POST;\n        let not_post_str = "GET";\n        assert!(!post_method.eq(&not_post_str));\n    }\n\n    #[test]\n    fn test_eq_method_with_empty_str() {\n        let put_method = Method::PUT;\n        let empty_str = "";\n        assert!(!put_method.eq(&empty_str));\n    }\n\n    #[test]\n    fn test_eq_method_with_extension() {\n        let custom_method = Method::from_bytes(b"MYMETHOD").unwrap();\n        let custom_str = "MYMETHOD";\n        assert!(custom_method.eq(&custom_str));\n    }\n\n    #[test]\n    fn test_eq_method_with_different_case() {\n        let delete_method = Method::DELETE;\n        let delete_str = "delete";\n        assert!(!delete_method.eq(&delete_str));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580228, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=248, prompt_tokens=2365, total_tokens=2613, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclswjVHrOralxI3MUMheR5c1C4lm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_method_eq() {\n        assert!(Method::GET.eq("GET"));\n        assert!(Method::POST.eq("POST"));\n        assert!(Method::PUT.eq("PUT"));\n        assert!(Method::DELETE.eq("DELETE"));\n        assert!(Method::HEAD.eq("HEAD"));\n        assert!(Method::OPTIONS.eq("OPTIONS"));\n        assert!(Method::CONNECT.eq("CONNECT"));\n        assert!(Method::TRACE.eq("TRACE"));\n        assert!(Method::PATCH.eq("PATCH"));\n    }\n\n    #[test]\n    fn test_method_eq_invalid() {\n        assert!(!Method::GET.eq("POST"));\n        assert!(!Method::OPTIONS.eq("GET"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580234, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=161, prompt_tokens=2360, total_tokens=2521, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclt4i0FcsqMYf804q27yeW7ufwAy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_method_as_ref() {\n        assert_eq!(Method::GET.as_ref(), "GET");\n        assert_eq!(Method::POST.as_ref(), "POST");\n        assert_eq!(Method::PUT.as_ref(), "PUT");\n        assert_eq!(Method::DELETE.as_ref(), "DELETE");\n        assert_eq!(Method::HEAD.as_ref(), "HEAD");\n        assert_eq!(Method::OPTIONS.as_ref(), "OPTIONS");\n        assert_eq!(Method::CONNECT.as_ref(), "CONNECT");\n        assert_eq!(Method::PATCH.as_ref(), "PATCH");\n        assert_eq!(Method::TRACE.as_ref(), "TRACE");\n    }\n\n    #[test]\n    fn test_method_as_ref_with_extension() {\n        let custom_method = Method::try_from("CUSTOM_METHOD").unwrap();\n        assert_eq!(custom_method.as_ref(), "CUSTOM_METHOD");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580242, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=197, prompt_tokens=2356, total_tokens=2553, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcltBP8lJzmzSa3VGBA9Bkdrf3OIW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_method_from_clone() {\n        let get_method = Method::GET.clone();\n        let method_from_clone = Method::from(&get_method);\n        assert_eq!(get_method, method_from_clone);\n    }\n\n    #[test]\n    fn test_method_from_take_reference() {\n        let post_method = Method::POST;\n        let method_from_reference = Method::from(&post_method);\n        assert_eq!(post_method, method_from_reference);\n    }\n\n    #[test]\n    fn test_method_from_multiple_reference() {\n        let delete_method = Method::DELETE;\n        let method_from_reference = Method::from(&delete_method);\n        let method_from_reference_again = Method::from(&method_from_reference);\n        assert_eq!(delete_method, method_from_reference_again);\n    }\n\n    #[test]\n    fn test_method_clone_equivalence() {\n        let put_method = Method::PUT;\n        let method_clone = put_method.clone();\n        let method_from_clone = Method::from(&method_clone);\n        assert_eq!(put_method, method_from_clone);\n    }\n\n    #[test]\n    fn test_method_from_equals() {\n        let head_method = Method::HEAD;\n        let method_from_ref = Method::from(&head_method);\n        assert!(method_from_ref == head_method);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580249, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=285, prompt_tokens=2357, total_tokens=2642, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcltIB1EpEn2MXjVKfGXq2PVIcWUd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::method::Method;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_bytes() {\n        let valid_bytes = b"GET";\n        let result = Method::try_from(valid_bytes);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Method::GET);\n    }\n\n    #[test]\n    fn test_try_from_invalid_bytes() {\n        let invalid_bytes = b"INVALID_METHOD";\n        let result = Method::try_from(invalid_bytes);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_bytes() {\n        let empty_bytes = b"";\n        let result = Method::try_from(empty_bytes);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_bytes_case_sensitivity() {\n        let case_sensitive_bytes = b"get";\n        let result = Method::try_from(case_sensitive_bytes);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580256, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=217, prompt_tokens=173, total_tokens=390, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcltQjhSEmKYiCof1nMRFqWV7f4dE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::method::Method;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_method() {\n        assert_eq!(Method::try_from("GET").is_ok(), true);\n        assert_eq!(Method::try_from("POST").is_ok(), true);\n        assert_eq!(Method::try_from("PUT").is_ok(), true);\n        assert_eq!(Method::try_from("DELETE").is_ok(), true);\n    }\n\n    #[test]\n    fn test_try_from_invalid_method() {\n        assert_eq!(Method::try_from("INVALID_METHOD").is_err(), true);\n        assert_eq!(Method::try_from("123").is_err(), true);\n        assert_eq!(Method::try_from("").is_err(), true);\n    }\n\n    #[test]\n    fn test_try_from_case_sensitivity() {\n        assert_eq!(Method::try_from("get").is_err(), true);\n        assert_eq!(Method::try_from("Post").is_err(), true);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580264, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=222, prompt_tokens=171, total_tokens=393, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcltW8JvZJuJsuxrT1UktfI7IJ93G', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_default_method() {\n        // Test that the default method is GET\n        let default_method = Method::default();\n        assert_eq!(default_method, Method::GET);\n    }\n\n    #[test]\n    fn test_method_as_str() {\n        let default_method = Method::default();\n        assert_eq!(default_method.as_str(), "GET");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580270, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=100, prompt_tokens=2347, total_tokens=2447, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcltZn1TyN5ozZfPCCX9Zj3kbPW2C', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use std::str::FromStr;\n    use http::method::Method;\n\n    #[test]\n    fn test_from_str_valid_method() {\n        assert_eq!(Method::from_str("GET").unwrap(), Method::GET);\n        assert_eq!(Method::from_str("POST").unwrap(), Method::POST);\n        assert_eq!(Method::from_str("PUT").unwrap(), Method::PUT);\n        assert_eq!(Method::from_str("DELETE").unwrap(), Method::DELETE);\n    }\n\n    #[test]\n    fn test_from_str_invalid_method() {\n        assert!(Method::from_str("INVALID_METHOD").is_err());\n        assert!(Method::from_str("").is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580273, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=152, prompt_tokens=164, total_tokens=316, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcltdg6bU8erVrh3HsPOPe3LapPW0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::request::Builder;\n\n    #[test]\n    fn test_default_builder() {\n        let builder = Builder::default();\n        assert!(builder.inner.is_ok());\n    }\n\n    #[test]\n    fn test_default_builder_parts() {\n        let builder = Builder::default();\n        let parts = builder.inner.unwrap();\n        // Assuming Parts has some method to confirm it was initialized correctly\n        // If Parts has a specific method to assert that it's a new instance, use it here\n        assert!(parts.is_initialized()); // Replace with actual assertion\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580277, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=130, prompt_tokens=2523, total_tokens=2653, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclti0rnn5lYD0536yuzPoUBZ3hpC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method, Extensions, HeaderMap};\n\n    #[test]\n    fn test_default_request() {\n        let request: Request<()> = Request::default();\n        assert_eq!(request.method(), &Method::GET);\n        assert!(request.uri().path().is_empty());\n        assert!(request.headers().is_empty());\n        assert!(request.extensions().is_empty());\n        assert_eq!(request.body(), &());\n    }\n\n    #[test]\n    fn test_default_request_with_extensions() {\n        let mut extensions = Extensions::new();\n        extensions.insert(42);\n        let mut request: Request<()> = Request::default();\n        request.extensions_mut().extend(extensions);\n        \n        assert_eq!(request.extensions().get::<i32>(), Some(&42));\n    }\n\n    #[test]\n    fn test_default_request_with_headers() {\n        let mut headers = HeaderMap::new();\n        headers.insert(http::header::CONTENT_LENGTH, "0".parse().unwrap());\n        let mut request: Request<()> = Request::default();\n        *request.headers_mut() = headers;\n\n        assert_eq!(request.headers().get(http::header::CONTENT_LENGTH), Some(&"0".parse().unwrap()));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580282, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=258, prompt_tokens=16361, total_tokens=16619, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcltq3qxAKjSU9dOTkwTgufah3Dnr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{response::Builder, Error};\n\n    #[test]\n    fn test_builder_default() {\n        let builder = Builder::default();\n        assert!(builder.inner.is_ok());\n    }\n\n    #[test]\n    fn test_builder_new() {\n        let builder = Builder::new();\n        assert!(builder.inner.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580290, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=84, prompt_tokens=2003, total_tokens=2087, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcltvg0FaatrilKPvUeiUUmqKxPcj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Response;\n\n    #[test]\n    fn test_response_default() {\n        let response: Response<()> = Response::default();\n        assert_eq!(response.status(), http::StatusCode::OK);\n        assert_eq!(response.head.version, http::Version::HTTP_11);\n        assert!(response.head.headers.is_empty());\n        assert!(response.head.extensions.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580295, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=94, prompt_tokens=16361, total_tokens=16455, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclu0LFBGyVDbxEE0uCznXyYcqNPD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_eq() {\n        let status = StatusCode::from_u16(200).unwrap();\n        let other = 200;\n\n        assert!(status.eq(&other));\n    }\n\n    #[test]\n    fn test_eq_not_equal() {\n        let status = StatusCode::from_u16(404).unwrap();\n        let other = 200;\n\n        assert!(!status.eq(&other));\n    }\n\n    #[test]\n    fn test_eq_different_status_code() {\n        let status = StatusCode::from_u16(500).unwrap();\n        let other = 400;\n\n        assert!(!status.eq(&other));\n    }\n\n    #[test]\n    fn test_eq_with_invalid_value() {\n        let status = StatusCode::from_u16(200).unwrap();\n        let other = 300;\n\n        assert!(!status.eq(&other));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580300, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=203, prompt_tokens=2150, total_tokens=2353, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclu6NlBqbgmmFwUm46flo1UmRem4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_from() {\n        let status_code = StatusCode::OK;\n        let cloned_status_code = StatusCode::from(&status_code);\n        assert_eq!(status_code, cloned_status_code);\n        assert_eq!(status_code.as_u16(), cloned_status_code.as_u16());\n    }\n\n    #[test]\n    fn test_from_different_status() {\n        let status_code = StatusCode::NOT_FOUND;\n        let cloned_status_code = StatusCode::from(&status_code);\n        assert_eq!(status_code, cloned_status_code);\n        assert_eq!(status_code.as_u16(), cloned_status_code.as_u16());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580306, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=155, prompt_tokens=2147, total_tokens=2302, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcluBJBUwkBA6NyfEeS3dSrJNNPCe', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::status::StatusCode;\n\n    #[test]\n    fn test_try_from_valid_bytes() {\n        let valid_bytes = b"200"; // HTTP OK\n        let result = StatusCode::try_from(valid_bytes);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), StatusCode::OK);\n    }\n\n    #[test]\n    fn test_try_from_invalid_bytes() {\n        let invalid_bytes = b"invalid"; // Not a valid status code\n        let result = StatusCode::try_from(invalid_bytes);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_bytes() {\n        let empty_bytes = b""; // Empty byte slice\n        let result = StatusCode::try_from(empty_bytes);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580311, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=182, prompt_tokens=174, total_tokens=356, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcluHGQwm6pG1rQA8EQyjZw75Wc7S', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n    use http::status::StatusCode;\n\n    #[test]\n    fn test_try_from_valid_status_code() {\n        let result = StatusCode::try_from("200");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), StatusCode::OK);\n    }\n\n    #[test]\n    fn test_try_from_invalid_status_code() {\n        let result = StatusCode::try_from("999");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_invalid_string() {\n        let result = StatusCode::try_from("not_a_status_code");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let result = StatusCode::try_from("");\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580317, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=185, prompt_tokens=165, total_tokens=350, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcluMbeFLGezhK4sAxiWWKmIqTgZn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::status::StatusCode;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_status_code() {\n        assert_eq!(StatusCode::try_from(200).unwrap(), StatusCode::OK);\n        assert_eq!(StatusCode::try_from(404).unwrap(), StatusCode::NOT_FOUND);\n        assert_eq!(StatusCode::try_from(500).unwrap(), StatusCode::INTERNAL_SERVER_ERROR);\n    }\n\n    #[test]\n    fn test_try_from_invalid_status_code() {\n        assert!(StatusCode::try_from(999).is_err());\n        assert!(StatusCode::try_from(600).is_err());\n    }\n\n    #[test]\n    fn test_try_from_boundary_values() {\n        assert_eq!(StatusCode::try_from(0).unwrap_err(), StatusCode::ERROR);\n        assert_eq!(StatusCode::try_from(1).unwrap_err(), StatusCode::ERROR);\n        assert_eq!(StatusCode::try_from(100).unwrap(), StatusCode::CONTINUE);\n        assert!(StatusCode::try_from(451).is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580322, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=244, prompt_tokens=167, total_tokens=411, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcluU6vESOhQhiEIwVTpnP8ri1rPj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_default_status_code() {\n        let default_status = StatusCode::default();\n        assert_eq!(default_status, StatusCode::OK);\n    }\n\n    #[test]\n    fn test_status_code_as_u16() {\n        let default_status = StatusCode::default();\n        assert_eq!(default_status.as_u16(), 200);\n    }\n\n    #[test]\n    fn test_status_code_as_str() {\n        let default_status = StatusCode::default();\n        assert_eq!(default_status.as_str(), "200");\n    }\n\n    #[test]\n    fn test_status_code_canonical_reason() {\n        let default_status = StatusCode::default();\n        assert_eq!(default_status.canonical_reason(), Some("OK"));\n    }\n\n    #[test]\n    fn test_status_code_is_success() {\n        let default_status = StatusCode::default();\n        assert!(default_status.is_success());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580330, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=208, prompt_tokens=2136, total_tokens=2344, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclua699QTaqxfHlRPnf62LDcaKh2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::status::StatusCode;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_from_str_valid() {\n        assert_eq!(StatusCode::from_str("200"), Ok(StatusCode::OK));\n        assert_eq!(StatusCode::from_str("404"), Ok(StatusCode::NOT_FOUND));\n        assert_eq!(StatusCode::from_str("500"), Ok(StatusCode::INTERNAL_SERVER_ERROR));\n    }\n\n    #[test]\n    fn test_from_str_invalid() {\n        assert!(StatusCode::from_str("abcd").is_err());\n        assert!(StatusCode::from_str("999").is_err());\n        assert!(StatusCode::from_str("").is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580336, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=160, prompt_tokens=165, total_tokens=325, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclugFEObxibvRy7kQoaTnI5f8Skj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::map::as_header_name::Sealed;\n\n    #[test]\n    fn test_as_str() {\n        let string_instance = String::from("test_header");\n        let result = string_instance.as_str();\n        assert_eq!(result, "test_header");\n    }\n\n    #[test]\n    fn test_as_str_empty() {\n        let string_instance = String::new();\n        let result = string_instance.as_str();\n        assert_eq!(result, "");\n    }\n\n    #[test]\n    fn test_as_str_special_characters() {\n        let string_instance = String::from("header_with_@special#chars$");\n        let result = string_instance.as_str();\n        assert_eq!(result, "header_with_@special#chars$");\n    }\n\n    #[test]\n    fn test_as_str_whitespace() {\n        let string_instance = String::from("   ");\n        let result = string_instance.as_str();\n        assert_eq!(result, "   ");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580342, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=217, prompt_tokens=640, total_tokens=857, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcluoAtEMjfMPTX17FTUVOZKbikUQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST, HeaderValue};\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_find_existing_key() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::new();\n        map.insert(HOST, HeaderValue::from_static("example.com"));\n        \n        let key = String::from("host");\n        let result = key.find(&map);\n        \n        assert!(result.is_some());\n        assert_eq!(result, Some((0, 0))); // Adjust expected values based on map implementation\n    }\n\n    #[test]\n    fn test_find_non_existing_key() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, HeaderValue::from_static("123"));\n        \n        let key = String::from("host");\n        let result = key.find(&map);\n        \n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_find_case_insensitive_key() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::new();\n        map.insert(HOST, HeaderValue::from_static("example.com"));\n        \n        let key = String::from("HOST");\n        let result = key.find(&map);\n        \n        assert!(result.is_some());\n        assert_eq!(result, Some((0, 0))); // Adjust expected values based on map implementation\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580350, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=309, prompt_tokens=13052, total_tokens=13361, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcluygsyHeirRPx8lu0KB4QnN3ejN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_try_entry_insert() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n\n        assert!(map.try_entry(HOST).is_err());\n        map.insert(HOST, "example.com".to_string());\n        \n        let entry = HOST.try_entry(&mut map).expect("Failed to get entry");\n        assert_eq!(entry.get(), &"example.com");\n    }\n\n    #[test]\n    fn test_try_entry_overwriting() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n\n        map.insert(HOST, "example.com".to_string());\n        map.insert(HOST, "newdomain.com".to_string());\n\n        let entry = HOST.try_entry(&mut map).expect("Failed to get entry");\n        assert_eq!(entry.get(), &"newdomain.com");\n    }\n\n    #[test]\n    fn test_try_entry_invalid_key() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n\n        assert!(map.try_entry("invalid header").is_err());\n    }\n\n    #[test]\n    fn test_try_entry_capacity() {\n        let mut map: HeaderMap<String> = HeaderMap::with_capacity(2);\n        \n        map.insert(HOST, "example.com".to_string());\n        map.insert(CONTENT_LENGTH, "123".to_string());\n\n        assert_eq!(map.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580360, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=322, prompt_tokens=13056, total_tokens=13378, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclv7pJNo5rZiE8f0quRcHjLTXQVM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::uri::{ErrorKind, InvalidUri};\n\n    #[test]\n    fn test_from_invalid_uri_char() {\n        let error_kind = ErrorKind::InvalidUriChar;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n\n    #[test]\n    fn test_from_invalid_scheme() {\n        let error_kind = ErrorKind::InvalidScheme;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n\n    #[test]\n    fn test_from_invalid_authority() {\n        let error_kind = ErrorKind::InvalidAuthority;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n\n    #[test]\n    fn test_from_invalid_port() {\n        let error_kind = ErrorKind::InvalidPort;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n\n    #[test]\n    fn test_from_invalid_format() {\n        let error_kind = ErrorKind::InvalidFormat;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n\n    #[test]\n    fn test_from_scheme_missing() {\n        let error_kind = ErrorKind::SchemeMissing;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n\n    #[test]\n    fn test_from_authority_missing() {\n        let error_kind = ErrorKind::AuthorityMissing;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n\n    #[test]\n    fn test_from_path_and_query_missing() {\n        let error_kind = ErrorKind::PathAndQueryMissing;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n\n    #[test]\n    fn test_from_too_long() {\n        let error_kind = ErrorKind::TooLong;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n\n    #[test]\n    fn test_from_empty() {\n        let error_kind = ErrorKind::Empty;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n\n    #[test]\n    fn test_from_scheme_too_long() {\n        let error_kind = ErrorKind::SchemeTooLong;\n        let invalid_uri = InvalidUri::from(error_kind);\n        assert_eq!(invalid_uri.0, error_kind);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580369, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=577, prompt_tokens=574, total_tokens=1151, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclvLVNWy79cMSURa5FdarqAl9iIR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::uri::{ErrorKind, InvalidUriParts};\n\n    #[test]\n    fn test_from_error_kind() {\n        let error_kind = ErrorKind::InvalidScheme;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "invalid scheme");\n    }\n\n    #[test]\n    fn test_from_invalid_uri_char() {\n        let error_kind = ErrorKind::InvalidUriChar;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "invalid uri character");\n    }\n\n    #[test]\n    fn test_from_invalid_authority() {\n        let error_kind = ErrorKind::InvalidAuthority;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "invalid authority");\n    }\n\n    #[test]\n    fn test_from_invalid_port() {\n        let error_kind = ErrorKind::InvalidPort;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "invalid port");\n    }\n\n    #[test]\n    fn test_from_invalid_format() {\n        let error_kind = ErrorKind::InvalidFormat;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "invalid format");\n    }\n\n    #[test]\n    fn test_from_scheme_missing() {\n        let error_kind = ErrorKind::SchemeMissing;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "scheme missing");\n    }\n\n    #[test]\n    fn test_from_authority_missing() {\n        let error_kind = ErrorKind::AuthorityMissing;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "authority missing");\n    }\n\n    #[test]\n    fn test_from_path_and_query_missing() {\n        let error_kind = ErrorKind::PathAndQueryMissing;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "path missing");\n    }\n\n    #[test]\n    fn test_from_too_long() {\n        let error_kind = ErrorKind::TooLong;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "uri too long");\n    }\n\n    #[test]\n    fn test_from_empty() {\n        let error_kind = ErrorKind::Empty;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "empty string");\n    }\n\n    #[test]\n    fn test_from_scheme_too_long() {\n        let error_kind = ErrorKind::SchemeTooLong;\n        let invalid_uri_parts = InvalidUriParts::from(error_kind);\n        \n        assert_eq!(invalid_uri_parts.to_string(), "scheme too long");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580383, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=636, prompt_tokens=739, total_tokens=1375, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclvZ3lEcFhDhkXd8PfL8NNSlx6lP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::{Parts, Uri, Authority, PathAndQuery, Scheme};\n\n    #[test]\n    fn test_from_uri_with_scheme_authority_and_path() {\n        let uri: Uri = "https://example.com/path?query=value".parse().unwrap();\n        let parts: Parts = Parts::from(uri);\n        assert_eq!(parts.scheme, Some(Scheme::HTTPS));\n        assert_eq!(parts.authority, Some(Authority::from_static("example.com")));\n        assert_eq!(parts.path_and_query, Some(PathAndQuery::from_static("/path?query=value")));\n    }\n\n    #[test]\n    fn test_from_uri_without_authority() {\n        let uri: Uri = "/path".parse().unwrap();\n        let parts: Parts = Parts::from(uri);\n        assert_eq!(parts.scheme, None);\n        assert_eq!(parts.authority, None);\n        assert_eq!(parts.path_and_query, Some(PathAndQuery::from_static("/path")));\n    }\n\n    #[test]\n    fn test_from_uri_with_empty_authority() {\n        let uri: Uri = "http:///path".parse().unwrap();\n        let parts: Parts = Parts::from(uri);\n        assert_eq!(parts.scheme, Some(Scheme::HTTP));\n        assert_eq!(parts.authority, None);\n        assert_eq!(parts.path_and_query, Some(PathAndQuery::from_static("/path")));\n    }\n    \n    #[test]\n    fn test_from_uri_with_query() {\n        let uri: Uri = "http://example.com/path?foo=bar".parse().unwrap();\n        let parts: Parts = Parts::from(uri);\n        assert_eq!(parts.scheme, Some(Scheme::HTTP));\n        assert_eq!(parts.authority, Some(Authority::from_static("example.com")));\n        assert_eq!(parts.path_and_query, Some(PathAndQuery::from_static("/path?foo=bar")));\n    }\n\n    #[test]\n    fn test_from_uri_with_no_path() {\n        let uri: Uri = "http://example.com".parse().unwrap();\n        let parts: Parts = Parts::from(uri);\n        assert_eq!(parts.scheme, Some(Scheme::HTTP));\n        assert_eq!(parts.authority, Some(Authority::from_static("example.com")));\n        assert_eq!(parts.path_and_query, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580397, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=487, prompt_tokens=14514, total_tokens=15001, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclvmKG0LOOnJqHbRiCEUQyNDk8In', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_uri_eq() {\n        // Test cases for the `eq` method of Uri\n        let uri1: Uri = "http://example.com/path?query=value".parse().unwrap();\n        let uri2: Uri = "http://example.com/path?query=value".parse().unwrap();\n        let uri3: Uri = "http://example.com/different_path".parse().unwrap();\n        let uri4: Uri = "http://example.com/path?query=different_value".parse().unwrap();\n        let uri5: Uri = "http://example.com/path".parse().unwrap();\n\n        // Test for equality\n        assert!(uri1 == "http://example.com/path?query=value");\n        assert!(uri1 == &"http://example.com/path?query=value");\n        assert!(uri1 == uri2);\n        assert!(uri1 != uri3);\n        assert!(uri1 != uri4);\n        assert!(uri1 != uri5);\n    }\n\n    #[test]\n    fn test_uri_eq_empty() {\n        let uri_empty: Uri = "http://example.com/".parse().unwrap();\n        let uri_space: Uri = "http://example.com/path ".parse().unwrap();\n        \n        // Test for empty path\n        assert!(uri_empty == "http://example.com/");\n        assert!(uri_empty != "http://example.com/path ");\n    }\n\n    #[test]\n    fn test_uri_eq_case_insensitivity() {\n        let uri1: Uri = "http://example.com".parse().unwrap();\n        let uri2: Uri = "HTTP://EXAMPLE.COM".parse().unwrap();\n\n        // Test for case-insensitive comparison\n        assert!(uri1 == "http://example.com");\n        assert!(uri1 == &"HTTP://EXAMPLE.COM");\n        assert!(uri1 == uri2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580410, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=404, prompt_tokens=14153, total_tokens=14557, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclvwFgJn0OGHT3uqgC8ZklwscbUx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_uri_eq_absolute() {\n        let uri = Uri::from_static("http://example.com/path?query=1");\n        assert!(uri.eq("http://example.com/path?query=1"));\n        assert!(!uri.eq("http://example.com/path"));\n        assert!(!uri.eq("http://example.com/path?query=2"));\n        assert!(!uri.eq("https://example.com/path?query=1"));\n    }\n\n    #[test]\n    fn test_uri_eq_relative() {\n        let uri = Uri::from_static("/path");\n        assert!(uri.eq("/path"));\n        assert!(!uri.eq("/path/"));\n        assert!(!uri.eq("/otherpath"));\n        assert!(!uri.eq("http://example.com/path"));\n    }\n\n    #[test]\n    fn test_uri_eq_with_query() {\n        let uri = Uri::from_static("http://example.com/path?key=value");\n        assert!(uri.eq("http://example.com/path?key=value"));\n        assert!(!uri.eq("http://example.com/path?key=other"));\n        assert!(!uri.eq("http://example.com/path"));        \n    }\n\n    #[test]\n    fn test_uri_eq_case_insensitivity() {\n        let uri = Uri::from_static("HTTP://example.com/path");\n        assert!(uri.eq("http://example.com/path"));\n        assert!(uri.eq("Http://example.com/path"));\n        assert!(!uri.eq("https://example.com/path"));\n    }\n\n    #[test]\n    fn test_uri_eq_unsupported() {\n        let uri = Uri::from_static("http://example.com/path");\n        assert!(!uri.eq("ftp://example.com/path"));\n        assert!(!uri.eq("http://example.com/otherpath"));\n    }\n\n    #[test]\n    fn test_uri_eq_empty_query() {\n        let uri = Uri::from_static("http://example.com/path?");\n        assert!(uri.eq("http://example.com/path?"));\n        assert!(!uri.eq("http://example.com/path"));\n    }\n\n    #[test]\n    fn test_uri_eq_with_fragment() {\n        let uri = Uri::from_static("http://example.com/path#fragment");\n        assert!(uri.eq("http://example.com/path#fragment"));\n        assert!(!uri.eq("http://example.com/path#otherfragment"));\n    }\n\n    #[test]\n    fn test_uri_eq_no_authority() {\n        let uri = Uri::from_static("/relative/path");\n        assert!(uri.eq("/relative/path"));\n        assert!(!uri.eq("/relative"));\n    }\n\n    #[test]\n    fn test_uri_eq_invalid() {\n        let uri = Uri::from_static("http://example.com/path");\n        assert!(!uri.eq("invalid uri"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580420, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=592, prompt_tokens=14532, total_tokens=15124, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclw8GBNAiKD3ND77fniAiLyVPtyJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::{Authority, PathAndQuery, Scheme, Uri};\n\n    #[test]\n    fn test_uri_eq() {\n        let uri1: Uri = "http://example.com/path?query=value".parse().unwrap();\n        let uri2: Uri = "http://example.com/path?query=value".parse().unwrap();\n        let uri3: Uri = "https://example.com/path?query=value".parse().unwrap();\n        let uri4: Uri = "http://example.com/path?query=other".parse().unwrap();\n        let uri5: Uri = "http://example.com/path".parse().unwrap();\n        let uri6: Uri = "http://example.com/path?query=value#fragment".parse().unwrap();\n\n        assert!(uri1.eq(&uri2)); // same scheme, authority, path, and query\n        assert!(!uri1.eq(&uri3)); // different scheme\n        assert!(!uri1.eq(&uri4)); // same scheme and authority, different query\n        assert!(!uri1.eq(&uri5)); // same scheme and authority, different path\n        assert!(!uri1.eq(&uri6)); // same scheme, authority, path, but different query and has fragment\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580432, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=273, prompt_tokens=14210, total_tokens=14483, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwHIpncXe2oDBNPWfx5U4eigwYy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n    \n    #[test]\n    fn test_from_authority() {\n        let authority = Authority::from_static("example.com:80");\n        let uri: Uri = Uri::from(authority);\n\n        assert!(uri.scheme.is_empty());\n        assert_eq!(uri.authority.as_ref(), "example.com:80");\n        assert!(uri.path_and_query.data.is_empty());\n    }\n\n    #[test]\n    fn test_from_empty_authority() {\n        let authority = Authority::empty();\n        let uri: Uri = Uri::from(authority);\n\n        assert!(uri.scheme.is_empty());\n        assert!(uri.authority.data.is_empty());\n        assert!(uri.path_and_query.data.is_empty());\n    }\n\n    #[test]\n    fn test_from_authority_with_path() {\n        let authority = Authority::from_static("example.com");\n        let uri: Uri = Uri::from(authority);\n\n        assert!(uri.scheme.is_empty());\n        assert_eq!(uri.authority.as_ref(), "example.com");\n        assert!(uri.path_and_query.data.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580441, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=237, prompt_tokens=14169, total_tokens=14406, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwPN1fpZOWS6z1I8esoKJL1R9RO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::{PathAndQuery, Uri};\n\n    #[test]\n    fn test_uri_from_path_and_query() {\n        let path_and_query = PathAndQuery::from_static("/foo?bar=baz");\n        let uri = Uri::from(path_and_query);\n\n        assert_eq!(uri.path(), "/foo");\n        assert_eq!(uri.query(), Some("bar=baz"));\n        assert!(uri.scheme().is_none());\n        assert!(uri.authority().is_none());\n    }\n\n    #[test]\n    fn test_uri_from_empty_path_and_query() {\n        let path_and_query = PathAndQuery::empty();\n        let uri = Uri::from(path_and_query);\n\n        assert_eq!(uri.path(), "");\n        assert!(uri.query().is_none());\n        assert!(uri.scheme().is_none());\n        assert!(uri.authority().is_none());\n    }\n\n    #[test]\n    fn test_uri_from_slash_path_and_query() {\n        let path_and_query = PathAndQuery::slash();\n        let uri = Uri::from(path_and_query);\n\n        assert_eq!(uri.path(), "/");\n        assert!(uri.query().is_none());\n        assert!(uri.scheme().is_none());\n        assert!(uri.authority().is_none());\n    }\n\n    #[test]\n    fn test_uri_from_star_path_and_query() {\n        let path_and_query = PathAndQuery::star();\n        let uri = Uri::from(path_and_query);\n\n        assert_eq!(uri.path(), "*");\n        assert!(uri.query().is_none());\n        assert!(uri.scheme().is_none());\n        assert!(uri.authority().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580449, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=347, prompt_tokens=14172, total_tokens=14519, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwXZH5bqVuSGeqPBIF57IpTunoV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Uri;\n\n    #[test]\n    fn test_try_from_valid_bytes() {\n        let input: &[u8] = b"http://example.com";\n        let result: Result<Uri, _> = Uri::try_from(input);\n        assert!(result.is_ok());\n        let uri = result.unwrap();\n        assert_eq!(uri.to_string(), "http://example.com/");\n    }\n\n    #[test]\n    fn test_try_from_invalid_bytes() {\n        let input: &[u8] = b"invalid_uri";\n        let result: Result<Uri, _> = Uri::try_from(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_bytes() {\n        let input: &[u8] = b"";\n        let result: Result<Uri, _> = Uri::try_from(input);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580457, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=203, prompt_tokens=179, total_tokens=382, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwcXHUG49EEE7WEy8cuKSY2HbtD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n    use http::uri::Uri;\n\n    #[test]\n    fn test_try_from_valid_uri_string() {\n        let uri_string = String::from("http://example.com");\n        let uri_result = Uri::try_from(&uri_string);\n        assert!(uri_result.is_ok());\n        assert_eq!(uri_result.unwrap().to_string(), uri_string);\n    }\n\n    #[test]\n    fn test_try_from_invalid_uri_string() {\n        let uri_string = String::from("invalid_uri");\n        let uri_result = Uri::try_from(&uri_string);\n        assert!(uri_result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let uri_string = String::from("");\n        let uri_result = Uri::try_from(&uri_string);\n        assert!(uri_result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_string_with_spaces() {\n        let uri_string = String::from(" http://example.com ");\n        let uri_result = Uri::try_from(&uri_string);\n        assert!(uri_result.is_ok());\n        assert_eq!(uri_result.unwrap().to_string(), uri_string.trim());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580462, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=258, prompt_tokens=654, total_tokens=912, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwinxE4mYyP569kT0LtCeBuY0Cf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Uri;\n\n    #[test]\n    fn test_try_from_valid_uri() {\n        let valid_uri = "http://example.com";\n        let result = Uri::try_from(valid_uri);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().to_string(), valid_uri);\n    }\n\n    #[test]\n    fn test_try_from_invalid_uri() {\n        let invalid_uri = "invalid_uri";\n        let result = Uri::try_from(invalid_uri);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_uri() {\n        let empty_uri = "";\n        let result = Uri::try_from(empty_uri);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_uri_with_spaces() {\n        let uri_with_spaces = "http://example.com/some path";\n        let result = Uri::try_from(uri_with_spaces);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580468, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=213, prompt_tokens=166, total_tokens=379, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwoyzOuDK8zabQftCRC4HaslF1R', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Uri;\n\n    #[test]\n    fn test_try_from_uri_clone() {\n        let original_uri: Uri = "http://example.com/path?query=value".parse().unwrap();\n        let cloned_uri = Uri::try_from(&original_uri).unwrap();\n        assert_eq!(original_uri, cloned_uri);\n    }\n\n    #[test]\n    fn test_try_from_empty_uri() {\n        let original_uri: Uri = Uri::default();\n        let cloned_uri = Uri::try_from(&original_uri).unwrap();\n        assert_eq!(original_uri, cloned_uri);\n    }\n\n    #[test]\n    fn test_try_from_same_uri_instance() {\n        let original_uri = Uri::default();\n        let cloned_uri = Uri::try_from(&original_uri).unwrap();\n        assert!(std::ptr::eq(&original_uri, &cloned_uri));\n    }\n\n    #[test]\n    fn test_try_from_invalid_uri() {\n        let invalid_uri = Uri::from_static("invalid_uri");\n        let result = Uri::try_from(&invalid_uri);\n        assert!(result.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580474, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=240, prompt_tokens=14161, total_tokens=14401, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwvdRKgcJ8rdJwnPezdZNi0Nl3j', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_string() {\n        let valid_uri_string = String::from("http://example.com");\n        let result = Uri::try_from(valid_uri_string);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_string() {\n        let invalid_uri_string = String::from("invalid_uri");\n        let result = Uri::try_from(invalid_uri_string);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let empty_uri_string = String::from("");\n        let result = Uri::try_from(empty_uri_string);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_string_with_special_characters() {\n        let special_chars_uri_string = String::from("http://example.com/path?query=1");\n        let result = Uri::try_from(special_chars_uri_string);\n        assert!(result.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580481, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=226, prompt_tokens=655, total_tokens=881, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclx5svs6Kd6cFoym0kC97gHXQUv7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_vec() {\n        let vec = b"http://example.com".to_vec();\n        let result = Uri::try_from(vec);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_empty_vec() {\n        let vec: Vec<u8> = Vec::new();\n        let result = Uri::try_from(vec);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_uri_vec() {\n        let vec = b"invalid_uri".to_vec();\n        let result = Uri::try_from(vec);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580491, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=160, prompt_tokens=176, total_tokens=336, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxAW5FAoCBEZ1ESaN274V3ovUxl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::{Uri, Parts};\n    use http::uri::scheme::Scheme;\n    use http::uri::authority::Authority;\n    use http::uri::path_and_query::PathAndQuery;\n\n    #[test]\n    fn test_try_from_valid_parts() {\n        let parts = Parts {\n            scheme: Some(Scheme::from_static("http")),\n            authority: Some(Authority::from_static("example.com")),\n            path_and_query: Some(PathAndQuery::from_static("/path?query")),\n            _priv: (),\n        };\n        \n        let result: Result<Uri, _> = Uri::try_from(parts);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_parts_with_missing_scheme() {\n        let parts = Parts {\n            scheme: None,\n            authority: Some(Authority::from_static("example.com")),\n            path_and_query: Some(PathAndQuery::from_static("/path?query")),\n            _priv: (),\n        };\n\n        let result: Result<Uri, _> = Uri::try_from(parts);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_parts_with_empty_authority() {\n        let parts = Parts {\n            scheme: Some(Scheme::from_static("http")),\n            authority: None,\n            path_and_query: Some(PathAndQuery::from_static("/path?query")),\n            _priv: (),\n        };\n\n        let result: Result<Uri, _> = Uri::try_from(parts);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_parts_with_missing_path_and_query() {\n        let parts = Parts {\n            scheme: Some(Scheme::from_static("http")),\n            authority: Some(Authority::from_static("example.com")),\n            path_and_query: None,\n            _priv: (),\n        };\n\n        let result: Result<Uri, _> = Uri::try_from(parts);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580496, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=421, prompt_tokens=438, total_tokens=859, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxLBjgpNraKSyBXdlyJjjy8yb58', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_uri_default() {\n        let uri = Uri::default();\n        assert_eq!(uri.scheme, Scheme::empty());\n        assert_eq!(uri.authority, Authority::empty());\n        assert_eq!(uri.path_and_query, PathAndQuery::slash());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580507, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=76, prompt_tokens=14166, total_tokens=14242, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxQ6hotuDFNCXjFgJXar09w1sTa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::Hasher;\n\n    #[test]\n    fn test_hash() {\n        let uri1: Uri = "https://example.com/path?query=value".parse().unwrap();\n        let uri2: Uri = "https://example.com/path?query=value".parse().unwrap();\n        let uri3: Uri = "http://example.com/path?query=value".parse().unwrap();\n        \n        let mut hasher1 = extensions::IdHasher::default();\n        uri1.hash(&mut hasher1);\n        \n        let mut hasher2 = extensions::IdHasher::default();\n        uri2.hash(&mut hasher2);\n        \n        let mut hasher3 = extensions::IdHasher::default();\n        uri3.hash(&mut hasher3);\n        \n        // uri1 and uri2 should hash to the same value\n        assert_eq!(hasher1.finish(), hasher2.finish());\n        // uri1 and uri3 should hash to different values\n        assert_ne!(hasher1.finish(), hasher3.finish());\n    }\n\n    #[test]\n    fn test_hash_with_various_uri_components() {\n        let uri1: Uri = "http://username:password@example.com:123/path/to/resource?query=value".parse().unwrap();\n        let uri2: Uri = "http://username:password@example.com:123/path/to/resource?query=value".parse().unwrap();\n        let uri3: Uri = "http://example.com/path/to/resource".parse().unwrap();\n        \n        let mut hasher1 = extensions::IdHasher::default();\n        uri1.hash(&mut hasher1);\n        \n        let mut hasher2 = extensions::IdHasher::default();\n        uri2.hash(&mut hasher2);\n        \n        let mut hasher3 = extensions::IdHasher::default();\n        uri3.hash(&mut hasher3);\n        \n        // uri1 and uri2 should hash to the same value\n        assert_eq!(hasher1.finish(), hasher2.finish());\n        \n        // uri1 with authentication should hash differently from uri3 without authentication\n        assert_ne!(hasher1.finish(), hasher3.finish());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580512, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=457, prompt_tokens=14393, total_tokens=14850, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxdWNGyoCLabdP3714KFReZ2y6W', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n    use http::uri::Uri; // Adjust the path according to your crate\'s structure\n    use http::uri::InvalidUri;\n\n    #[test]\n    fn test_from_str_valid_uri() {\n        let valid_uri = "http://example.com";\n        let result = Uri::from_str(valid_uri);\n        assert!(result.is_ok());\n        let uri = result.unwrap();\n        assert_eq!(uri.scheme_str(), Some("http"));\n        assert_eq!(uri.host(), Some(http::uri::Authority::from_static("example.com").host()));\n    }\n\n    #[test]\n    fn test_from_str_invalid_uri() {\n        let invalid_uri = "invalid_uri";\n        let result = Uri::from_str(invalid_uri);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_from_str_edge_case_empty() {\n        let empty_uri = "";\n        let result = Uri::from_str(empty_uri);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_from_str_edge_case_space() {\n        let space_uri = "   ";\n        let result = Uri::from_str(space_uri);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_from_str_valid_uri_with_port() {\n        let valid_uri_with_port = "http://example.com:8080";\n        let result = Uri::from_str(valid_uri_with_port);\n        assert!(result.is_ok());\n        let uri = result.unwrap();\n        assert_eq!(uri.port_u16(), Some(8080));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580525, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=337, prompt_tokens=166, total_tokens=503, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxlAsucejtfiujDkJ0pGU6pUYeq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_eq_case_insensitive_equal() {\n        let authority1 = Authority::from_static("Example.COM");\n        let authority2 = "example.com";\n        assert!(authority1.eq(&authority2));\n    }\n\n    #[test]\n    fn test_eq_case_insensitive_not_equal() {\n        let authority1 = Authority::from_static("Example.COM");\n        let authority2 = "example.org";\n        assert!(!authority1.eq(&authority2));\n    }\n\n    #[test]\n    fn test_eq_equal_with_different_cases() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = "EXAMPLE.com";\n        assert!(authority1.eq(&authority2));\n    }\n\n    #[test]\n    fn test_eq_empty_authority() {\n        let authority1 = Authority::empty();\n        let authority2 = "";\n        assert!(authority1.eq(&authority2));\n    }\n\n    #[test]\n    fn test_eq_non_empty_empty() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = "";\n        assert!(!authority1.eq(&authority2));\n    }\n\n    #[test]\n    fn test_eq_with_different_authority() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = "example.org";\n        assert!(!authority1.eq(&authority2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580533, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=307, prompt_tokens=4063, total_tokens=4370, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxsiFBIJ3tFLTG8bIhOVGOdwwPF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::string::String;\n\n    #[test]\n    fn test_authority_eq_ignore_case() {\n        let authority = Authority::from_static("example.com");\n        let same_case = String::from("example.com");\n        let different_case = String::from("EXAMPLE.COM");\n        let not_equal = String::from("example.org");\n\n        assert!(authority.eq(&same_case));\n        assert!(authority.eq(&different_case));\n        assert!(!authority.eq(&not_equal));\n    }\n\n    #[test]\n    fn test_authority_eq_with_empty_string() {\n        let authority = Authority::from_static("example.com");\n        let empty_string = String::from("");\n\n        assert!(!authority.eq(&empty_string));\n    }\n\n    #[test]\n    fn test_empty_authority_eq() {\n        let empty_authority = Authority::empty();\n        let empty_string = String::from("");\n\n        assert!(empty_authority.eq(&empty_string));\n    }\n\n    #[test]\n    fn test_authority_eq_case_insensitive() {\n        let authority = Authority::from_static("MYDOMAIN.COM");\n        let other = String::from("mydomain.com");\n\n        assert!(authority.eq(&other));\n    }\n\n    #[test]\n    fn test_authority_eq_with_special_characters() {\n        let authority = Authority::from_static("example.com/path");\n        let other = String::from("EXAMPLE.COM/path");\n\n        assert!(authority.eq(&other));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580540, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=312, prompt_tokens=4548, total_tokens=4860, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxzDzAtuvq5z1r2bKXUR0JBB8mB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_eq_case_insensitive_equal() {\n        let authority = Authority::from_static("example.com");\n        assert!(authority.eq("EXAMPLE.COM"));\n    }\n\n    #[test]\n    fn test_eq_case_insensitive_not_equal() {\n        let authority = Authority::from_static("example.com");\n        assert!(!authority.eq("example.org"));\n    }\n\n    #[test]\n    fn test_eq_equal() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = Authority::from_static("example.com");\n        assert!(authority1.eq(authority2.as_str()));\n    }\n\n    #[test]\n    fn test_eq_not_equal() {\n        let authority = Authority::from_static("example.com");\n        assert!(!authority.eq("example.com:80"));\n    }\n\n    #[test]\n    fn test_eq_empty_string() {\n        let authority = Authority::from_static("example.com");\n        assert!(!authority.eq(""));\n    }\n\n    #[test]\n    fn test_eq_empty_authority() {\n        let authority = Authority::empty();\n        assert!(authority.eq(""));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580547, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=252, prompt_tokens=4059, total_tokens=4311, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcly8xU40VjmPQvyJDJDwE3C3vhwS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_authority_eq() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = Authority::from_static("EXAMPLE.COM");\n        let authority3 = Authority::from_static("example.org");\n\n        assert!(authority1.eq(&authority2));\n        assert!(!authority1.eq(&authority3));\n        assert!(!authority2.eq(&authority3));\n    }\n\n    #[test]\n    fn test_authority_eq_empty() {\n        let authority1 = Authority::empty();\n        let authority2 = Authority::empty();\n        let authority3 = Authority::from_static("example.com");\n\n        assert!(authority1.eq(&authority2));\n        assert!(!authority1.eq(&authority3));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580556, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=177, prompt_tokens=4059, total_tokens=4236, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclyFSOZ8xeOhf6wUGKxhkJc2wuH0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = Authority::from_static("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = Authority::from_static("example.org");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let authority1 = Authority::from_static("example.org");\n        let authority2 = Authority::from_static("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_case_insensitive() {\n        let authority1 = Authority::from_static("Example.com");\n        let authority2 = Authority::from_static("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_case() {\n        let authority1 = Authority::from_static("Example.com");\n        let authority2 = Authority::from_static("EXAMPLE.ORG");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_empty_authority() {\n        let authority1 = Authority::empty();\n        let authority2 = Authority::from_static("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_both_empty_authority() {\n        let authority1 = Authority::empty();\n        let authority2 = Authority::empty();\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580563, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=448, prompt_tokens=4108, total_tokens=4556, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclySafgjuCouuKoYaJUG5aEEaafO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = String::from("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_not_equal() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = String::from("test.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_case_insensitivity() {\n        let authority1 = Authority::from_static("Example.com");\n        let authority2 = String::from("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_length() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = String::from("example.com:8080");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty_authority() {\n        let authority1 = Authority::empty();\n        let authority2 = String::from("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_both_empty() {\n        let authority1 = Authority::empty();\n        let authority2 = String::new();\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580576, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=380, prompt_tokens=4591, total_tokens=4971, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclyZGnMjslBrM1mF2RFdQIDgz31A', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = "example.com";\n        assert_eq!(authority1.partial_cmp(authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_case_insensitive_equal() {\n        let authority1 = Authority::from_static("Example.com");\n        let authority2 = "example.com";\n        assert_eq!(authority1.partial_cmp(authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = "example.org";\n        assert_eq!(authority1.partial_cmp(authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let authority1 = Authority::from_static("example.org");\n        let authority2 = "example.com";\n        assert_eq!(authority1.partial_cmp(authority2), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_lengths() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = "example.comm";\n        assert_eq!(authority1.partial_cmp(authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty_authority() {\n        let authority1 = Authority::empty();\n        let authority2 = "example.com";\n        assert_eq!(authority1.partial_cmp(authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_both_empty() {\n        let authority1 = Authority::empty();\n        let authority2 = Authority::empty();\n        assert_eq!(authority1.partial_cmp(authority2), Some(cmp::Ordering::Equal));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580583, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=420, prompt_tokens=4104, total_tokens=4524, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclyjonXxQQwfhsfpH3UegzNOyREW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_partial_cmp_eq() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = Authority::from_static("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_lt() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = Authority::from_static("example.org");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_gt() {\n        let authority1 = Authority::from_static("example.org");\n        let authority2 = Authority::from_static("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_mixed_case() {\n        let authority1 = Authority::from_static("Example.com");\n        let authority2 = Authority::from_static("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let authority1 = Authority::empty();\n        let authority2 = Authority::empty();\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty_vs_non_empty() {\n        let authority1 = Authority::empty();\n        let authority2 = Authority::from_static("example.com");\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580593, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=377, prompt_tokens=4103, total_tokens=4480, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclyrxVkeNWIGl9LnVav44UgYf4nz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_as_ref() {\n        let authority = Authority::from_static("example.com");\n        let authority_ref: &str = authority.as_ref();\n        assert_eq!(authority_ref, "example.com");\n    }\n\n    #[test]\n    fn test_as_ref_empty() {\n        let authority = Authority::empty();\n        let authority_ref: &str = authority.as_ref();\n        assert_eq!(authority_ref, "");\n    }\n\n    #[test]\n    fn test_as_ref_with_port() {\n        let authority: Authority = "example.com:80".parse().unwrap();\n        let authority_ref: &str = authority.as_ref();\n        assert_eq!(authority_ref, "example.com:80");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580601, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=170, prompt_tokens=4054, total_tokens=4224, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclyxcolxJAvLc9SVGGfVNx9XQCQ0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n    use http::uri::authority::Authority;\n\n    #[test]\n    fn test_try_from_valid_bytes() {\n        let input: &[u8] = b"example.com";\n        let result = Authority::try_from(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_bytes() {\n        let input: &[u8] = b"invalid_bytes!";\n        let result = Authority::try_from(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_bytes() {\n        let input: &[u8] = b"";\n        let result = Authority::try_from(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_bytes_with_special_characters() {\n        let input: &[u8] = b"example~test.com";\n        let result = Authority::try_from(input);\n        assert!(result.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580607, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=222, prompt_tokens=228, total_tokens=450, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclz4EBpU8LfvUmugXrHex6oP64rt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_authority() {\n        let input = "example.com";\n        let result = <uri::authority::Authority as std::convert::TryFrom<&str>>::try_from(input);\n        assert!(result.is_ok());\n    }\n    \n    #[test]\n    fn test_try_from_invalid_authority() {\n        let input = "invalid_authority_with_space ";\n        let result = <uri::authority::Authority as std::convert::TryFrom<&str>>::try_from(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_authority() {\n        let input = "";\n        let result = <uri::authority::Authority as std::convert::TryFrom<&str>>::try_from(input);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580614, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=191, prompt_tokens=175, total_tokens=366, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclz9X78VSZXSr0i8vqdlx2u8jmgM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_string() {\n        let valid_string = String::from("example.com");\n        let result = Authority::try_from(valid_string);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_string() {\n        let invalid_string = String::from("::invalid::authority");\n        let result = Authority::try_from(invalid_string);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let empty_string = String::from("");\n        let result = Authority::try_from(empty_string);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_case_insensitivity() {\n        let mixed_case_string = String::from("Example.Com");\n        let result = Authority::try_from(mixed_case_string.clone()).unwrap();\n        let comparison_string = String::from("example.com");\n        assert_eq!(result.as_str(), comparison_string.as_str());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580619, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=230, prompt_tokens=656, total_tokens=886, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzF5KWuAFXyo7SNcGhLU7tUjfhd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_vector() {\n        let valid_vec = b"example.com".to_vec();\n        let result = Authority::try_from(valid_vec);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_vector() {\n        let invalid_vec = b"invalid_authority!\\0".to_vec();\n        let result = Authority::try_from(invalid_vec);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_vector() {\n        let empty_vec = Vec::new();\n        let result = Authority::try_from(empty_vec);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580625, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=163, prompt_tokens=177, total_tokens=340, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzLD9qNGUlaROLWxs9EvE386oxX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::Hash;\n\n    #[test]\n    fn test_authority_hash() {\n        let authority_str = "example.com";\n        let authority = Authority::from_static(authority_str);\n        let mut hasher = extensions::IdHasher::default();\n        \n        authority.hash(&mut hasher);\n        \n        let hashed_value = hasher.finish();\n        \n        assert!(hashed_value != 0, "Hash should not be zero for valid Authority");\n    }\n\n    #[test]\n    fn test_authority_hash_case_insensitivity() {\n        let authority_str1 = "example.com";\n        let authority_str2 = "EXAMPLE.COM";\n        \n        let authority1 = Authority::from_static(authority_str1);\n        let authority2 = Authority::from_static(authority_str2);\n        \n        let mut hasher1 = extensions::IdHasher::default();\n        authority1.hash(&mut hasher1);\n        let hashed_value1 = hasher1.finish();\n\n        let mut hasher2 = extensions::IdHasher::default();\n        authority2.hash(&mut hasher2);\n        let hashed_value2 = hasher2.finish();\n        \n        assert_eq!(hashed_value1, hashed_value2, "Hash should be the same for case-insensitive Authority");\n    }\n\n    #[test]\n    fn test_authority_hash_empty() {\n        let authority = Authority::empty();\n        let mut hasher = extensions::IdHasher::default();\n        \n        authority.hash(&mut hasher);\n        \n        let hashed_value = hasher.finish();\n\n        assert!(hashed_value != 0, "Hash should not be zero for empty Authority");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580631, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=348, prompt_tokens=4242, total_tokens=4590, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzUgdVa5LxUBL8rFpZUbPp1ULkt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::authority::Authority;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_from_str_valid() {\n        let authority_str = "user:password@host:port";\n        let result = Authority::from_str(authority_str);\n        assert!(result.is_ok());\n        let authority = result.unwrap();\n        assert_eq!(authority.user(), "user");\n        assert_eq!(authority.host(), "host");\n        assert_eq!(authority.port(), Some(Port::from(Port::from(port))));\n    }\n\n    #[test]\n    fn test_from_str_invalid() {\n        let authority_str = "invalid_authority";\n        let result = Authority::from_str(authority_str);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580640, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=171, prompt_tokens=164, total_tokens=335, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzbmXTWeAE4N6zwcT66tR5eUmRS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_builder_from_uri() {\n        let uri: Uri = "http://example.com/path?query=1".parse().unwrap();\n        let builder: uri::Builder = uri.into();\n        \n        assert_eq!(builder.parts.as_ref().unwrap().path_and_query.as_ref().unwrap().as_str(), "/path?query=1");\n        assert_eq!(builder.parts.as_ref().unwrap().scheme.as_ref().unwrap().as_str(), "http");\n        assert_eq!(builder.parts.as_ref().unwrap().authority.as_ref().unwrap().as_str(), "example.com");\n    }\n\n    #[test]\n    fn test_from_uri() {\n        let uri: Uri = "https://example.com/path?query=2".parse().unwrap();\n        let builder: uri::Builder = uri.into();\n        \n        assert_eq!(builder.parts.as_ref().unwrap().path_and_query.as_ref().unwrap().as_str(), "/path?query=2");\n        assert_eq!(builder.parts.as_ref().unwrap().scheme.as_ref().unwrap().as_str(), "https");\n        assert_eq!(builder.parts.as_ref().unwrap().authority.as_ref().unwrap().as_str(), "example.com");\n    }\n    \n    #[test]\n    fn test_builder_default() {\n        let builder = uri::Builder::new();\n        assert!(builder.parts.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580647, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=299, prompt_tokens=15186, total_tokens=15485, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzkMxCzIZAlCvtcg5nJfkwnu6eJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Builder;\n\n    #[test]\n    fn test_builder_default() {\n        let builder = Builder::default();\n        assert!(builder.parts.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580656, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=53, prompt_tokens=1191, total_tokens=1244, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzotM4cGYurF5OZUT6etEYtMvXu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_path_and_query_eq_str() {\n        let path_and_query = PathAndQuery::from_static("/example/path");\n        let other_str = "/example/path";\n\n        assert!(path_and_query == other_str);\n    }\n\n    #[test]\n    fn test_path_and_query_eq_str_different() {\n        let path_and_query = PathAndQuery::from_static("/example/path");\n        let other_str = "/example";\n\n        assert!(!(path_and_query == other_str));\n    }\n\n    #[test]\n    fn test_path_and_query_eq_empty_str() {\n        let path_and_query = PathAndQuery::empty();\n        let other_str = "";\n\n        assert!(path_and_query == other_str);\n    }\n\n    #[test]\n    fn test_path_and_query_eq_varied_whitespace() {\n        let path_and_query = PathAndQuery::from_static("/example/path ");\n        let other_str = "/example/path";\n\n        assert!(!(path_and_query == other_str));\n    }\n\n    #[test]\n    fn test_path_and_query_eq_with_different_static_str() {\n        let path_and_query = PathAndQuery::from_static("/path");\n        let other_str = "/path/";\n\n        assert!(!(path_and_query == other_str));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580660, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=284, prompt_tokens=3917, total_tokens=4201, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzwErgMPjwThYYjj4UQBma2St0a', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_eq_with_identical_strings() {\n        let pq = PathAndQuery::from_static("/path?query");\n        let other = String::from("/path?query");\n        assert!(pq.eq(&other));\n    }\n\n    #[test]\n    fn test_eq_with_different_strings() {\n        let pq = PathAndQuery::from_static("/path?query");\n        let other = String::from("/different_path");\n        assert!(!pq.eq(&other));\n    }\n\n    #[test]\n    fn test_eq_with_empty_string() {\n        let pq = PathAndQuery::from_static("");\n        let other = String::from("");\n        assert!(pq.eq(&other));\n    }\n\n    #[test]\n    fn test_eq_with_empty_path_and_non_empty_string() {\n        let pq = PathAndQuery::from_static("");\n        let other = String::from("/non_empty");\n        assert!(!pq.eq(&other));\n    }\n\n    #[test]\n    fn test_eq_with_static_string() {\n        let pq = PathAndQuery::from_static("/static");\n        let other = String::from("/static");\n        assert!(pq.eq(&other));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580668, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=266, prompt_tokens=4401, total_tokens=4667, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm023coPfq3dnyTnrxQOkTR6F5qN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_eq_same_string() {\n        let path_and_query = PathAndQuery::from_static("/hello/world");\n        let other = "/hello/world";\n        assert!(path_and_query.eq(other));\n    }\n\n    #[test]\n    fn test_eq_different_string() {\n        let path_and_query = PathAndQuery::from_static("/hello/world");\n        let other = "/hello/universe";\n        assert!(!path_and_query.eq(other));\n    }\n\n    #[test]\n    fn test_eq_empty_string() {\n        let path_and_query = PathAndQuery::from_static("");\n        let other = "";\n        assert!(path_and_query.eq(other));\n    }\n\n    #[test]\n    fn test_eq_with_different_length() {\n        let path_and_query = PathAndQuery::from_static("/hello");\n        let other = "/hello/world";\n        assert!(!path_and_query.eq(other));\n    }\n\n    #[test]\n    fn test_eq_with_query_string() {\n        let path_and_query = PathAndQuery::from_static("/hello/world?query=1");\n        let other = "/hello/world?query=1";\n        assert!(path_and_query.eq(other));\n    }\n\n    #[test]\n    fn test_eq_with_no_query_string() {\n        let path_and_query = PathAndQuery::from_static("/hello/world");\n        let other = "/hello/world?query=1";\n        assert!(!path_and_query.eq(other));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580674, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=323, prompt_tokens=3912, total_tokens=4235, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0B8sKPjOSnx26HEzFuVAopnuJy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::uri::path::PathAndQuery;\n\n    #[test]\n    fn test_eq_same() {\n        let path1 = PathAndQuery::from_static("/path?query=value");\n        let path2 = PathAndQuery::from_static("/path?query=value");\n        assert!(path1.eq(&path2));\n    }\n\n    #[test]\n    fn test_eq_different() {\n        let path1 = PathAndQuery::from_static("/path1?query=value");\n        let path2 = PathAndQuery::from_static("/path2?query=value");\n        assert!(!path1.eq(&path2));\n    }\n\n    #[test]\n    fn test_eq_different_query() {\n        let path1 = PathAndQuery::from_static("/path?query=value1");\n        let path2 = PathAndQuery::from_static("/path?query=value2");\n        assert!(!path1.eq(&path2));\n    }\n\n    #[test]\n    fn test_eq_different_path() {\n        let path1 = PathAndQuery::from_static("/path1");\n        let path2 = PathAndQuery::from_static("/path2");\n        assert!(!path1.eq(&path2));\n    }\n\n    #[test]\n    fn test_eq_empty() {\n        let path1 = PathAndQuery::empty();\n        let path2 = PathAndQuery::empty();\n        assert!(path1.eq(&path2));\n    }\n\n    #[test]\n    fn test_eq_empty_non_empty() {\n        let path1 = PathAndQuery::empty();\n        let path2 = PathAndQuery::from_static("/path?query=value");\n        assert!(!path1.eq(&path2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580683, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=363, prompt_tokens=3911, total_tokens=4274, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0JDBgXACAxKHyaVorfGdGdOWIj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let path1 = PathAndQuery::from_static("/hello?world");\n        let path2 = PathAndQuery::from_static("/hello?world");\n        \n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let path1 = PathAndQuery::from_static("/apple?fruit");\n        let path2 = PathAndQuery::from_static("/banana?fruit");\n        \n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let path1 = PathAndQuery::from_static("/banana?fruit");\n        let path2 = PathAndQuery::from_static("/apple?fruit");\n        \n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_query() {\n        let path1 = PathAndQuery::from_static("/path?query1");\n        let path2 = PathAndQuery::from_static("/path?query2");\n        \n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_str() {\n        let path = PathAndQuery::from_static("/hello?world");\n        let other: &str = "/hello?world";\n        \n        assert_eq!(path.partial_cmp(&other), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_str() {\n        let path = PathAndQuery::from_static("/hello");\n        let other: &str = "/world";\n        \n        assert_eq!(path.partial_cmp(&other), Some(cmp::Ordering::Less));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580691, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=421, prompt_tokens=3925, total_tokens=4346, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0V0M0azVP5r8aJjDNtL0QkCHO9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::uri::path::PathAndQuery;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let path_and_query = PathAndQuery::from_static("/test/path");\n        let result = path_and_query.partial_cmp(&"/test/path".to_string());\n        assert_eq!(result, Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let path_and_query = PathAndQuery::from_static("/test/path");\n        let result = path_and_query.partial_cmp(&"/test/path/next".to_string());\n        assert_eq!(result, Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let path_and_query = PathAndQuery::from_static("/test/path/next");\n        let result = path_and_query.partial_cmp(&"/test/path".to_string());\n        assert_eq!(result, Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_paths() {\n        let path_and_query = PathAndQuery::from_static("/test/path");\n        let result = path_and_query.partial_cmp(&"/other/path".to_string());\n        assert_eq!(result, Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty_string() {\n        let path_and_query = PathAndQuery::from_static("/test/path");\n        let result = path_and_query.partial_cmp(&"".to_string());\n        assert_eq!(result, Some(cmp::Ordering::Greater));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580703, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=341, prompt_tokens=4409, total_tokens=4750, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0dvnXsAXbXaoxtUpj4J2uUivSm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let path_and_query = PathAndQuery::from_static("/hello");\n        let result = path_and_query.partial_cmp("/hello");\n        assert_eq!(result, Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let path_and_query = PathAndQuery::from_static("/hello");\n        let result = path_and_query.partial_cmp("/world");\n        assert_eq!(result, Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let path_and_query = PathAndQuery::from_static("/world");\n        let result = path_and_query.partial_cmp("/hello");\n        assert_eq!(result, Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty_string() {\n        let path_and_query = PathAndQuery::from_static("/hello");\n        let result = path_and_query.partial_cmp("");\n        assert_eq!(result, Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_none() {\n        let path_and_query = PathAndQuery::from_static("/hello");\n        let result = path_and_query.partial_cmp(&"non-existent");\n        assert_eq!(result, Some(Ordering::Less));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580711, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=294, prompt_tokens=3920, total_tokens=4214, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0kENb2aujr6WRBMTHGxznSYLVz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let path1 = PathAndQuery::from_static("/test?query=value");\n        let path2 = PathAndQuery::from_static("/test?query=value");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let path1 = PathAndQuery::from_static("/a?query=value");\n        let path2 = PathAndQuery::from_static("/b?query=value");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let path1 = PathAndQuery::from_static("/b?query=value");\n        let path2 = PathAndQuery::from_static("/a?query=value");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_none() {\n        let path1 = PathAndQuery::from_static("/test");\n        let path2 = PathAndQuery::from_static("/test#fragment");\n        assert_eq!(path1.partial_cmp(&path2), None);\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let path1 = PathAndQuery::empty();\n        let path2 = PathAndQuery::from_static("/test");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_queries() {\n        let path1 = PathAndQuery::from_static("/test?query=value1");\n        let path2 = PathAndQuery::from_static("/test?query=value2");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Less));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580718, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=420, prompt_tokens=3922, total_tokens=4342, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0tMHz5Vqn2H66ZDMw4akV4VYVA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Ensure to import the necessary items\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_bytes() {\n        let input: &[u8] = b"/example/path?query=1";\n        let result = PathAndQuery::try_from(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_empty_bytes() {\n        let input: &[u8] = b"";\n        let result = PathAndQuery::try_from(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_bytes() {\n        let input: &[u8] = b"invalid\\xFFdata";\n        let result = PathAndQuery::try_from(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_non_utf8_bytes() {\n        let input: &[u8] = b"\\xFF\\xFF";\n        let result = PathAndQuery::try_from(input);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580727, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=234, prompt_tokens=185, total_tokens=419, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0zbiSClSJLcwwfUziIDwo91LXs', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_path() {\n        let valid_path = "/example/path";\n        let result: Result<uri::path::PathAndQuery, _> = uri::path::PathAndQuery::try_from(valid_path);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_path() {\n        let invalid_path = "\\0invalid/path"; // Example of an invalid path\n        let result: Result<uri::path::PathAndQuery, _> = uri::path::PathAndQuery::try_from(invalid_path);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_path() {\n        let empty_path = "";\n        let result: Result<uri::path::PathAndQuery, _> = uri::path::PathAndQuery::try_from(empty_path);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580733, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=214, prompt_tokens=176, total_tokens=390, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm15xznU1QJJBkp8eLJh2ycfbQeH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n    use http::uri::path::PathAndQuery;\n\n    #[test]\n    fn test_try_from_valid_string() {\n        let valid_string = String::from("/path?query=1");\n        let result = PathAndQuery::try_from(&valid_string);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let empty_string = String::from("");\n        let result = PathAndQuery::try_from(&empty_string);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_string() {\n        let invalid_string = String::from("invalid uri");\n        let result = PathAndQuery::try_from(&invalid_string);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_string_with_special_characters() {\n        let special_string = String::from("/path with spaces?query=1");\n        let result = PathAndQuery::try_from(&special_string);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_string_with_encoded_characters() {\n        let encoded_string = String::from("/path%20with%20spaces?query=1");\n        let result = PathAndQuery::try_from(&encoded_string);\n        assert!(result.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580739, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=297, prompt_tokens=661, total_tokens=958, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1CVoYPsaIfiapsZRvxBEfXMc6C', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::path::PathAndQuery;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_string() {\n        let valid_string = "/test/path?query=1".to_string();\n        let result = PathAndQuery::try_from(valid_string);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let empty_string = "".to_string();\n        let result = PathAndQuery::try_from(empty_string);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_string() {\n        let invalid_string = "invalid character \\x00".to_string();\n        let result = PathAndQuery::try_from(invalid_string);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580746, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=183, prompt_tokens=659, total_tokens=842, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1JcGOe6PNHU6XtyD22FAuw3vGH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_vector() {\n        let valid_vec: Vec<u8> = b"/path?query=value".to_vec();\n        let result = PathAndQuery::try_from(valid_vec);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_empty_vector() {\n        let empty_vec: Vec<u8> = Vec::new();\n        let result = PathAndQuery::try_from(empty_vec);\n        assert!(result.is_ok()); // Assuming empty is valid\n    }\n\n    #[test]\n    fn test_try_from_invalid_vector() {\n        let invalid_vec: Vec<u8> = b"/path\\xFF".to_vec(); // Example of invalid UTF-8 byte\n        let result = PathAndQuery::try_from(invalid_vec);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580753, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=199, prompt_tokens=180, total_tokens=379, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1QHQyz8Dsd2HT1yqWRqWulqePZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::Hash;\n    use extensions::IdHasher;\n\n    #[test]\n    fn test_hash_empty_path_and_query() {\n        let path_and_query = PathAndQuery::empty();\n        let mut hasher = IdHasher::default();\n        path_and_query.hash(&mut hasher);\n        assert_eq!(hasher.finish(), 0);\n    }\n\n    #[test]\n    fn test_hash_single_path() {\n        let path_and_query = PathAndQuery::from_static("/test");\n        let mut hasher = IdHasher::default();\n        path_and_query.hash(&mut hasher);\n        assert_ne!(hasher.finish(), 0);\n    }\n\n    #[test]\n    fn test_hash_path_with_query() {\n        let path_and_query = PathAndQuery::from_static("/test?query=string");\n        let mut hasher = IdHasher::default();\n        path_and_query.hash(&mut hasher);\n        assert_ne!(hasher.finish(), 0);\n    }\n\n    #[test]\n    fn test_hash_different_paths() {\n        let path_a = PathAndQuery::from_static("/test");\n        let path_b = PathAndQuery::from_static("/test2");\n        \n        let mut hasher_a = IdHasher::default();\n        let mut hasher_b = IdHasher::default();\n        \n        path_a.hash(&mut hasher_a);\n        path_b.hash(&mut hasher_b);\n        \n        assert_ne!(hasher_a.finish(), hasher_b.finish());\n    }\n\n    #[test]\n    fn test_hash_same_paths() {\n        let path_a = PathAndQuery::from_static("/test/path");\n        let path_b = PathAndQuery::from_static("/test/path");\n        \n        let mut hasher_a = IdHasher::default();\n        let mut hasher_b = IdHasher::default();\n        \n        path_a.hash(&mut hasher_a);\n        path_b.hash(&mut hasher_b);\n        \n        assert_eq!(hasher_a.finish(), hasher_b.finish());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580760, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=428, prompt_tokens=4062, total_tokens=4490, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1bo8RqWmVcTZeql5EeGZ6LNHDE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n    use http::uri::path::PathAndQuery;\n    use http::uri::InvalidUri;\n\n    #[test]\n    fn test_from_str_valid() {\n        let input = "/path/to/resource";\n        let result = PathAndQuery::from_str(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_from_str_invalid() {\n        let input = "invalid_path_without_leading_slash";\n        let result = PathAndQuery::from_str(input);\n        assert!(result.is_err());\n        match result {\n            Err(InvalidUri::InvalidPath(_)) => {},\n            _ => panic!("Expected InvalidUri::InvalidPath error"),\n        }\n    }\n\n    #[test]\n    fn test_from_str_empty() {\n        let input = "";\n        let result = PathAndQuery::from_str(input);\n        assert!(result.is_err());\n        match result {\n            Err(InvalidUri::InvalidPath(_)) => {},\n            _ => panic!("Expected InvalidUri::InvalidPath error"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580771, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=234, prompt_tokens=168, total_tokens=402, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1irqcsO7cpkGHz6LEqgLIfU8AD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::AsRef;\n\n    #[test]\n    fn test_port_eq() {\n        let port_a = Port { port: 80, repr: "80" };\n        let port_b = 80;\n        let port_c = 90;\n\n        assert!(port_a.eq(&port_b));\n        assert!(!port_a.eq(&port_c));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580778, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=93, prompt_tokens=840, total_tokens=933, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1mvy4qVqMQtGlQil3z93bZ0uFb', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_port_equality() {\n        let port1 = Port {\n            port: 8080,\n            repr: "8080".to_string(),\n        };\n        let port2 = Port {\n            port: 8080,\n            repr: "8080".to_string(),\n        };\n        let port3 = Port {\n            port: 3000,\n            repr: "3000".to_string(),\n        };\n\n        assert!(port1 == port2);\n        assert!(port1 != port3);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580782, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=135, prompt_tokens=846, total_tokens=981, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1qjM6XufgaNIvX8O1fJuf8BkTa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::AsRef;\n\n    #[derive(Debug)]\n    struct TestRepr(String);\n\n    impl AsRef<str> for TestRepr {\n        fn as_ref(&self) -> &str {\n            &self.0\n        }\n    }\n\n    #[test]\n    fn test_as_ref() {\n        let port_repr = TestRepr("8080".to_string());\n        let port = Port { port: 8080, repr: port_repr };\n\n        assert_eq!(port.as_ref(), "8080");\n    }\n\n    #[test]\n    fn test_as_ref_empty() {\n        let port_repr = TestRepr("".to_string());\n        let port = Port { port: 0, repr: port_repr };\n\n        assert_eq!(port.as_ref(), "");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580786, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=179, prompt_tokens=836, total_tokens=1015, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1yzh9EpYyQKLoms2W78Z4N5b0p', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::scheme::{Scheme, Protocol};\n\n    #[test]\n    fn test_eq_http() {\n        let http_scheme = Scheme::HTTP;\n        assert!(http_scheme.eq("http"));\n        assert!(http_scheme.eq("HTTP"));\n        assert!(!http_scheme.eq("https"));\n    }\n\n    #[test]\n    fn test_eq_https() {\n        let https_scheme = Scheme::HTTPS;\n        assert!(https_scheme.eq("https"));\n        assert!(https_scheme.eq("HTTPS"));\n        assert!(!https_scheme.eq("http"));\n    }\n\n    #[test]\n    fn test_eq_none() {\n        let none_scheme = Scheme::empty();\n        assert!(!none_scheme.eq("http"));\n        assert!(!none_scheme.eq("HTTPS"));\n        assert!(!none_scheme.eq("none"));\n    }\n\n    #[test]\n    fn test_eq_other() {\n        let other_scheme = Scheme {\n            inner: Scheme2::Other("custom_scheme".into()),\n        };\n        assert!(other_scheme.eq("custom_scheme"));\n        assert!(other_scheme.eq("CUSTOM_SCHEME"));\n        assert!(!other_scheme.eq("other_scheme"));\n    }\n\n    #[test]\n    fn test_eq_different_cases() {\n        let http_scheme = Scheme::HTTP;\n        let https_scheme = Scheme::HTTPS;\n        assert!(http_scheme.eq("http"));\n        assert!(https_scheme.eq("https"));\n        assert!(!http_scheme.eq(https_scheme.as_str()));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580794, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=311, prompt_tokens=1942, total_tokens=2253, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm24eqyBHpF1CBw8a7JdtWVNcQzP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::uri::scheme::{Protocol, Scheme, Scheme2};\n\n    #[test]\n    fn test_eq_http() {\n        let scheme1 = Scheme::HTTP;\n        let scheme2 = Scheme::HTTP;\n        assert!(scheme1.eq(&scheme2));\n    }\n\n    #[test]\n    fn test_eq_https() {\n        let scheme1 = Scheme::HTTPS;\n        let scheme2 = Scheme::HTTPS;\n        assert!(scheme1.eq(&scheme2));\n    }\n\n    #[test]\n    fn test_eq_other() {\n        let scheme1 = Scheme::from(Scheme2::Other("custom".into()));\n        let scheme2 = Scheme::from(Scheme2::Other("custom".into()));\n        assert!(scheme1.eq(&scheme2));\n    }\n\n    #[test]\n    fn test_eq_other_case_insensitive() {\n        let scheme1 = Scheme::from(Scheme2::Other("custom".into()));\n        let scheme2 = Scheme::from(Scheme2::Other("CUSTOM".into()));\n        assert!(scheme1.eq(&scheme2));\n    }\n\n    #[test]\n    fn test_eq_mismatch() {\n        let scheme1 = Scheme::HTTP;\n        let scheme2 = Scheme::HTTPS;\n        assert!(!scheme1.eq(&scheme2));\n    }\n\n    #[test]\n    fn test_eq_other_mismatch() {\n        let scheme1 = Scheme::from(Scheme2::Other("custom1".into()));\n        let scheme2 = Scheme::from(Scheme2::Other("custom2".into()));\n        assert!(!scheme1.eq(&scheme2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580800, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=341, prompt_tokens=2016, total_tokens=2357, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2CjbvoYzasHXSYA8KbiBrtb3Fz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::scheme::{Scheme, Protocol};\n\n    #[test]\n    fn test_scheme_as_ref_http() {\n        let scheme = Scheme::HTTP;\n        assert_eq!(scheme.as_ref(), "http");\n    }\n\n    #[test]\n    fn test_scheme_as_ref_https() {\n        let scheme = Scheme::HTTPS;\n        assert_eq!(scheme.as_ref(), "https");\n    }\n\n    #[test]\n    fn test_scheme_as_ref_none() {\n        let scheme = Scheme::empty();\n        // Since Scheme::empty() produces a Scheme2::None,\n        // we cannot call as_ref directly. This test might be\n        // used to verify behavior associated with an empty scheme.\n        // Adjust your expectations based on the actual handling of `None`.\n        assert!(scheme.as_ref().is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580808, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=183, prompt_tokens=1938, total_tokens=2121, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2IgFoFBCJxT0MjeyMxtAmDB4yB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::scheme::{Scheme, Scheme2, Protocol};\n\n    #[test]\n    fn test_from_scheme2_http() {\n        let scheme2_http = Scheme2::Standard(Protocol::Http);\n        let scheme: Scheme = Scheme::from(scheme2_http);\n        assert_eq!(scheme.as_str(), "http");\n    }\n\n    #[test]\n    fn test_from_scheme2_https() {\n        let scheme2_https = Scheme2::Standard(Protocol::Https);\n        let scheme: Scheme = Scheme::from(scheme2_https);\n        assert_eq!(scheme.as_str(), "https");\n    }\n\n    #[test]\n    fn test_from_scheme2_other() {\n        let scheme2_other = Scheme2::Other(Box::from("other_scheme"));\n        let scheme: Scheme = Scheme::from(scheme2_other);\n        assert_eq!(scheme.as_str(), "other_scheme");\n    }\n\n    #[test]\n    fn test_from_scheme2_none() {\n        let scheme2_none = Scheme2::None;\n        let scheme: Scheme = Scheme::from(scheme2_none);\n        // We expect a panic or unreachable call since Scheme2::None should never be alright\n        // We can only test construction from Scheme2::None if we handle it in Scheme\n        // Adjust this test based on your error handling strategy\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580814, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=289, prompt_tokens=1939, total_tokens=2228, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2TgYb5wRRZ1thZJCHFhywfdOVB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n    use http::uri::scheme::Scheme;\n\n    #[test]\n    fn test_try_from_standard_scheme() {\n        let input: &[u8] = b"http";\n        let result = Scheme::try_from(input);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Scheme::Standard("http".into()));\n    }\n\n    #[test]\n    fn test_try_from_other_scheme() {\n        let input: &[u8] = b"my-scheme";\n        let result = Scheme::try_from(input);\n        assert!(result.is_ok());\n        if let Scheme::Other(boxed_str) = result.unwrap() {\n            assert_eq!(boxed_str.as_ref(), "my-scheme");\n        } else {\n            panic!("Expected Scheme::Other variant");\n        }\n    }\n\n    #[test]\n    fn test_try_from_invalid_scheme() {\n        let input: &[u8] = b"";\n        let result = Scheme::try_from(input);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580825, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=229, prompt_tokens=282, total_tokens=511, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2cFrOYmxv7egWkL0JDz2bBmWJr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::uri::scheme::Scheme;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_scheme() {\n        let valid_scheme = "http";\n        let result = Scheme::try_from(valid_scheme);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_scheme() {\n        let invalid_scheme = "invalid_scheme";\n        let result = Scheme::try_from(invalid_scheme);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_empty_string() {\n        let empty_string = "";\n        let result = Scheme::try_from(empty_string);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_unicode_scheme() {\n        let unicode_scheme = "http://example.com";\n        let result = Scheme::try_from(unicode_scheme);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580834, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=199, prompt_tokens=175, total_tokens=374, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2hT9roaAKAYZ6uh1mdriT3WVKv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::{Hash, Hasher};\n\n    #[derive(Default)]\n    struct IdHasher(u64);\n\n    impl Hasher for IdHasher {\n        fn write(&mut self, _: &[u8]) {\n            unreachable!("TypeId calls write_u64");\n        }\n\n        #[inline]\n        fn write_u64(&mut self, id: u64) {\n            self.0 = id;\n        }\n\n        #[inline]\n        fn finish(&self) -> u64 {\n            self.0\n        }\n    }\n\n    #[test]\n    fn test_hash_http() {\n        let scheme = Scheme::HTTP;\n        let mut hasher = IdHasher::default();\n        scheme.hash(&mut hasher);\n        assert_eq!(hasher.finish(), 1);\n    }\n\n    #[test]\n    fn test_hash_https() {\n        let scheme = Scheme::HTTPS;\n        let mut hasher = IdHasher::default();\n        scheme.hash(&mut hasher);\n        assert_eq!(hasher.finish(), 2);\n    }\n\n    #[test]\n    fn test_hash_other() {\n        let scheme = Scheme {\n            inner: Scheme2::Other(Box::from("custom")),\n        };\n        let mut hasher = IdHasher::default();\n        scheme.hash(&mut hasher);\n        // The length of "custom" is 6, plus the hash for each byte\n        assert!(hasher.finish() != 1 && hasher.finish() != 2);\n    }\n\n    #[test]\n    fn test_hash_none() {\n        let scheme = Scheme::empty();\n        let mut hasher = IdHasher::default();\n        scheme.hash(&mut hasher);\n        assert_eq!(hasher.finish(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580839, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=367, prompt_tokens=2183, total_tokens=2550, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2qeMrO0ZhashJa09vQs6Z5xhLG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n    use http::uri::scheme::Scheme;\n\n    #[test]\n    fn test_from_str_valid_http() {\n        let scheme = Scheme::from_str("http");\n        assert!(scheme.is_ok());\n        assert_eq!(scheme.unwrap(), Scheme::HTTP);\n    }\n\n    #[test]\n    fn test_from_str_valid_https() {\n        let scheme = Scheme::from_str("https");\n        assert!(scheme.is_ok());\n        assert_eq!(scheme.unwrap(), Scheme::HTTPS);\n    }\n\n    #[test]\n    fn test_from_str_invalid() {\n        let scheme = Scheme::from_str("ftp");\n        assert!(scheme.is_err());\n    }\n\n    #[test]\n    fn test_from_str_empty() {\n        let scheme = Scheme::from_str("");\n        assert!(scheme.is_err());\n    }\n\n    #[test]\n    fn test_from_str_uppercase_http() {\n        let scheme = Scheme::from_str("HTTP");\n        assert!(scheme.is_ok());\n        assert_eq!(scheme.unwrap(), Scheme::HTTP);\n    }\n\n    #[test]\n    fn test_from_str_uppercase_https() {\n        let scheme = Scheme::from_str("HTTPS");\n        assert!(scheme.is_ok());\n        assert_eq!(scheme.unwrap(), Scheme::HTTPS);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580848, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=275, prompt_tokens=165, total_tokens=440, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2wttCsq80bym1fWtYCyDvwG1GM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use uri::scheme::{Protocol, Scheme2};\n\n    #[test]\n    fn test_from_http() {\n        let protocol = Protocol::Http;\n        let scheme: Scheme2<()> = Scheme2::from(protocol);\n        match scheme {\n            Scheme2::Standard(p) => assert_eq!(p, Protocol::Http),\n            _ => panic!("Expected Scheme2::Standard variant"),\n        }\n    }\n\n    #[test]\n    fn test_from_https() {\n        let protocol = Protocol::Https;\n        let scheme: Scheme2<()> = Scheme2::from(protocol);\n        match scheme {\n            Scheme2::Standard(p) => assert_eq!(p, Protocol::Https),\n            _ => panic!("Expected Scheme2::Standard variant"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580854, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=167, prompt_tokens=926, total_tokens=1093, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm31GibaaRFi9QakhbOCDtLLK8bg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_version() {\n        let default_version = Version::default();\n        assert_eq!(default_version, Version::HTTP_11);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580859, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=51, prompt_tokens=645, total_tokens=696, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm34ZTjodvDeYypuiZG5HlE3fgCD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_from_byte_str() {\n        let original_str = "Hello, world!";\n        let byte_str = ByteStr::from_static(original_str);\n        let bytes: Bytes = Bytes::from(byte_str);\n        assert_eq!(bytes, Bytes::from_static(original_str.as_bytes()));\n    }\n\n    #[test]\n    fn test_from_empty_byte_str() {\n        let byte_str = ByteStr::new();\n        let bytes: Bytes = Bytes::from(byte_str);\n        assert!(bytes.is_empty());\n    }\n\n    #[test]\n    fn test_from_byte_str_with_utf8() {\n        let original_str = "Rust programming";\n        let byte_str = ByteStr::from_static(original_str);\n        let bytes: Bytes = Bytes::from(byte_str);\n        assert_eq!(bytes, Bytes::from_static(original_str.as_bytes()));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580862, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=196, prompt_tokens=1001, total_tokens=1197, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm39BgIo8Vpq483eBKe5kq2qz47c', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use byte_str::ByteStr;\n\n    #[test]\n    fn test_from_static_valid_utf8() {\n        let input = "Hello, World!";\n        let byte_str = ByteStr::from_static(input);\n        assert_eq!(byte_str.as_ref(), input);\n    }\n\n    #[test]\n    fn test_from_static_empty_str() {\n        let input = "";\n        let byte_str = ByteStr::from_static(input);\n        assert_eq!(byte_str.as_ref(), input);\n    }\n\n    #[test]\n    fn test_from_static_with_special_characters() {\n        let input = "Hello, Rust! ";\n        let byte_str = ByteStr::from_static(input);\n        assert_eq!(byte_str.as_ref(), input);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580867, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=166, prompt_tokens=1026, total_tokens=1192, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3EG6aTykk2ElgMnO6Jn0HbhlzJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_from_utf8_valid() {\n        let valid_utf8 = Bytes::from("Hello, world!");\n        let result = byte_str::ByteStr::from_utf8(valid_utf8);\n        assert!(result.is_ok());\n        let byte_str = result.unwrap();\n        assert_eq!(byte_str.bytes, valid_utf8);\n    }\n\n    #[test]\n    fn test_from_utf8_invalid() {\n        let invalid_utf8 = Bytes::from(&[0, 159, 146, 150][..]);\n        let result = byte_str::ByteStr::from_utf8(invalid_utf8);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580872, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=159, prompt_tokens=358, total_tokens=517, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3JfVElKj5eTxEPWSwRz7ncJJnB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    #[should_panic(expected = "ByteStr::from_utf8_unchecked() with invalid bytes; error = UTF-8 decode error")]\n    fn test_from_utf8_unchecked_invalid_utf8() {\n        let invalid_utf8 = Bytes::from_static(&[0, 159, 146, 150]); // invalid UTF-8 bytes\n        unsafe {\n            byte_str::ByteStr::from_utf8_unchecked(invalid_utf8);\n        }\n    }\n\n    #[test]\n    fn test_from_utf8_unchecked_valid_utf8() {\n        let valid_utf8 = Bytes::from_static(b"Hello, world!");\n        let byte_str = unsafe { byte_str::ByteStr::from_utf8_unchecked(valid_utf8) };\n        assert_eq!(&*byte_str, "Hello, world!");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580877, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=194, prompt_tokens=1148, total_tokens=1342, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3PWgXKtUXKdeu9v0GskFGjveWV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Make sure to include the super module to access ByteStr and Bytes\n    use bytes::Bytes; // Ensure to import the Bytes type\n\n    #[test]\n    fn test_byte_str_new() {\n        let empty_byte_str = ByteStr::new();\n        assert_eq!(empty_byte_str.deref(), ""); // Verify that the deref yields an empty string\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580883, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=94, prompt_tokens=1013, total_tokens=1107, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3TR24HYast2DEGpixTEQbo5wOa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::error::Error as StdError;\n\n    #[test]\n    fn test_get_ref_max_size_reached() {\n        let inner_error = MaxSizeReached::new();\n        let error: Error = inner_error.into();\n        let ref_error: &(dyn StdError + \'static) = error.get_ref();\n        assert_eq!(ref_error.to_string(), "max size reached");\n    }\n\n    #[test]\n    fn test_get_ref_invalid_header_name() {\n        let inner_error = header::InvalidHeaderName::new();\n        let error: Error = inner_error.into();\n        let ref_error: &(dyn StdError + \'static) = error.get_ref();\n        assert_eq!(ref_error.to_string(), "invalid HTTP header name");\n    }\n\n    #[test]\n    fn test_get_ref_invalid_header_value() {\n        let inner_error = header::InvalidHeaderValue {};\n        let error: Error = inner_error.into();\n        let ref_error: &(dyn StdError + \'static) = error.get_ref();\n        assert_eq!(ref_error.to_string(), "failed to parse header value");\n    }\n\n    #[test]\n    fn test_get_ref_invalid_method() {\n        let inner_error = method::InvalidMethod::new();\n        let error: Error = inner_error.into();\n        let ref_error: &(dyn StdError + \'static) = error.get_ref();\n        assert_eq!(ref_error.to_string(), "invalid HTTP method");\n    }\n\n    #[test]\n    fn test_get_ref_invalid_status_code() {\n        let inner_error = status::InvalidStatusCode::new();\n        let error: Error = inner_error.into();\n        let ref_error: &(dyn StdError + \'static) = error.get_ref();\n        assert_eq!(ref_error.to_string(), "invalid status code");\n    }\n\n    #[test]\n    fn test_get_ref_invalid_uri() {\n        let inner_error = uri::InvalidUri::from(ErrorKind::InvalidAuthority);\n        let error: Error = inner_error.into();\n        let ref_error: &(dyn StdError + \'static) = error.get_ref();\n        assert_eq!(ref_error.to_string(), "invalid authority");\n    }\n\n    #[test]\n    fn test_get_ref_invalid_uri_parts() {\n        let inner_error = uri::InvalidUriParts(uri::InvalidUri::from(ErrorKind::SchemeMissing));\n        let error: Error = inner_error.into();\n        let ref_error: &(dyn StdError + \'static) = error.get_ref();\n        assert_eq!(ref_error.to_string(), "scheme missing");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580887, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=532, prompt_tokens=2736, total_tokens=3268, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3cvx08W08KImfTnHaPzHmwLISI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::error::Error as StdError;\n\n    #[test]\n    fn test_is_max_size_reached() {\n        let error = Error::from(header::map::MaxSizeReached::new());\n        assert!(error.is<header::map::MaxSizeReached>());\n        assert!(!error.is<header::name::InvalidHeaderName>());\n    }\n\n    #[test]\n    fn test_is_invalid_header_name() {\n        let error = Error::from(header::name::InvalidHeaderName::new());\n        assert!(error.is<header::name::InvalidHeaderName>());\n        assert!(!error.is<header::value::InvalidHeaderValue>());\n    }\n\n    #[test]\n    fn test_is_invalid_header_value() {\n        let error = Error::from(header::value::InvalidHeaderValue {});\n        assert!(error.is<header::value::InvalidHeaderValue>());\n        assert!(!error.is<method::InvalidMethod>());\n    }\n\n    #[test]\n    fn test_is_invalid_method() {\n        let error = Error::from(method::InvalidMethod::new());\n        assert!(error.is<method::InvalidMethod>());\n        assert!(!error.is<status::InvalidStatusCode>());\n    }\n\n    #[test]\n    fn test_is_invalid_status_code() {\n        let error = Error::from(status::InvalidStatusCode::new());\n        assert!(error.is<status::InvalidStatusCode>());\n        assert!(!error.is<uri::InvalidUri>());\n    }\n\n    #[test]\n    fn test_is_invalid_uri() {\n        let error = Error::from(uri::InvalidUri(ErrorKind::InvalidUriChar));\n        assert!(error.is<uri::InvalidUri>());\n        assert!(!error.is<uri::InvalidUriParts>());\n    }\n\n    #[test]\n    fn test_is_invalid_uri_parts() {\n        let error = Error::from(uri::InvalidUriParts(uri::InvalidUri(ErrorKind::InvalidScheme)));\n        assert!(error.is<uri::InvalidUriParts>());\n        assert!(!error.is<header::map::MaxSizeReached>());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580896, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=426, prompt_tokens=2741, total_tokens=3167, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3l78GPnRIhEDNGMgPw9dpLCztE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::boxed::Box;\n\n    trait AnyClone {\n        fn clone_box(&self) -> Box<dyn AnyClone + Send + Sync>;\n    }\n\n    #[derive(Clone)]\n    struct TestStruct {\n        value: i32,\n    }\n\n    impl AnyClone for TestStruct {\n        fn clone_box(&self) -> Box<dyn AnyClone + Send + Sync> {\n            Box::new(self.clone())\n        }\n    }\n\n    #[test]\n    fn test_box_clone() {\n        let original: Box<dyn AnyClone + Send + Sync> = Box::new(TestStruct { value: 42 });\n        let cloned = original.clone();\n        assert_ne!(Box::into_raw(original), Box::into_raw(cloned)); // Ensure they are different instances\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580905, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=175, prompt_tokens=250, total_tokens=425, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3rxJ4tQOJ0uQeEzzNwfnOgAEdR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Extensions;\n\n    #[test]\n    fn test_clear_removes_extensions() {\n        let mut ext = Extensions::new();\n        ext.insert(5i32);\n        ext.clear();\n        assert!(ext.get::<i32>().is_none());\n        assert!(ext.is_empty());\n    }\n\n    #[test]\n    fn test_clear_on_empty_extensions() {\n        let mut ext = Extensions::new();\n        ext.clear();\n        assert!(ext.is_empty());\n    }\n\n    #[test]\n    fn test_clear_multiple_inserts() {\n        let mut ext = Extensions::new();\n        ext.insert(5i32);\n        ext.insert(10u8);\n        ext.clear();\n        assert!(ext.get::<i32>().is_none());\n        assert!(ext.get::<u8>().is_none());\n        assert!(ext.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580911, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=187, prompt_tokens=2162, total_tokens=2349, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3z6YD4vYmV70sYHcxGmTbYdsQz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Extensions;\n\n    #[test]\n    fn test_extend() {\n        let mut ext_a = Extensions::new();\n        ext_a.insert(8u8);\n        ext_a.insert(16u16);\n\n        let mut ext_b = Extensions::new();\n        ext_b.insert(4u8);\n        ext_b.insert("hello");\n\n        ext_a.extend(ext_b);\n        assert_eq!(ext_a.len(), 3);\n        assert_eq!(ext_a.get::<u8>(), Some(&4u8));\n        assert_eq!(ext_a.get::<u16>(), Some(&16u16));\n        assert_eq!(ext_a.get::<&\'static str>().copied(), Some("hello"));\n    }\n\n    #[test]\n    fn test_extend_with_overwriting() {\n        let mut ext_a = Extensions::new();\n        ext_a.insert(8u8);\n        ext_a.insert(16u16);\n\n        let mut ext_b = Extensions::new();\n        ext_b.insert(8u8);\n        ext_b.insert("hello");\n\n        ext_a.extend(ext_b);\n        assert_eq!(ext_a.len(), 3);\n        assert_eq!(ext_a.get::<u8>(), Some(&8u8));\n        assert_eq!(ext_a.get::<u16>(), Some(&16u16));\n        assert_eq!(ext_a.get::<&\'static str>().copied(), Some("hello"));\n    }\n\n    #[test]\n    fn test_extend_empty() {\n        let mut ext_a = Extensions::new();\n        ext_a.insert(8u8);\n\n        let ext_b = Extensions::new();\n\n        ext_a.extend(ext_b);\n        assert_eq!(ext_a.len(), 1);\n        assert_eq!(ext_a.get::<u8>(), Some(&8u8));\n    }\n\n    #[test]\n    fn test_extend_with_empty_a() {\n        let mut ext_b = Extensions::new();\n        ext_b.insert(4u8);\n        ext_b.insert("hello");\n\n        let ext_a = Extensions::new();\n\n        ext_a.extend(ext_b);\n        assert_eq!(ext_a.len(), 2);\n        assert_eq!(ext_a.get::<u8>(), Some(&4u8));\n        assert_eq!(ext_a.get::<&\'static str>().copied(), Some("hello"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580919, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=482, prompt_tokens=2311, total_tokens=2793, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm49xpukO8yC8XFh6RT2OYSXJtQ2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Extensions;\n\n    #[test]\n    fn test_get_none_before_insert() {\n        let ext = Extensions::new();\n        assert!(ext.get::<i32>().is_none());\n    }\n\n    #[test]\n    fn test_get_after_insert() {\n        let mut ext = Extensions::new();\n        ext.insert(5i32);\n        assert_eq!(ext.get::<i32>(), Some(&5i32));\n    }\n\n    #[test]\n    fn test_get_unrelated_type() {\n        let mut ext = Extensions::new();\n        ext.insert(5i32);\n        assert!(ext.get::<u32>().is_none());\n    }\n\n    #[test]\n    fn test_get_multiple_insertions() {\n        let mut ext = Extensions::new();\n        ext.insert(5i32);\n        ext.insert(10i32);\n        assert_eq!(ext.get::<i32>(), Some(&10i32));\n    }\n\n    #[test]\n    fn test_get_return_type() {\n        let mut ext = Extensions::new();\n        ext.insert(5i32);\n        let val: Option<&i32> = ext.get();\n        assert_eq!(val, Some(&5));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580929, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=258, prompt_tokens=7267, total_tokens=7525, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4I2zk0YyShybVvMATH37jF9h14', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Extensions;\n\n    #[test]\n    fn test_get_mut_existing() {\n        let mut ext = Extensions::new();\n        ext.insert(String::from("Hello"));\n        let mut_ref = ext.get_mut::<String>().expect("Expected to get mutable reference");\n        mut_ref.push_str(" World");\n        assert_eq!(ext.get::<String>().unwrap(), "Hello World");\n    }\n\n    #[test]\n    fn test_get_mut_non_existent() {\n        let mut ext = Extensions::new();\n        assert!(ext.get_mut::<String>().is_none());\n    }\n\n    #[test]\n    fn test_get_mut_multiple_types() {\n        let mut ext = Extensions::new();\n        ext.insert(42_i32);\n        ext.insert(String::from("Hello"));\n        \n        let mut_ref = ext.get_mut::<String>().expect("Expected to get mutable reference");\n        mut_ref.push_str(" World");\n        \n        assert_eq!(ext.get::<String>().unwrap(), "Hello World");\n        assert_eq!(ext.get::<i32>().unwrap(), &42);\n    }\n\n    #[test]\n    fn test_get_mut_after_remove() {\n        let mut ext = Extensions::new();\n        ext.insert(String::from("Hello"));\n        ext.remove::<String>();\n        assert!(ext.get_mut::<String>().is_none());\n    }\n\n    #[test]\n    fn test_get_mut_with_different_thread_safety() {\n        use std::sync::{Arc, Mutex};\n\n        let ext = Arc::new(Mutex::new(Extensions::new()));\n        let ext_clone = Arc::clone(&ext);\n        \n        ext_clone.lock().unwrap().insert(String::from("Hello"));\n        let mut_ref = ext.lock().unwrap().get_mut::<String>().expect("Expected to get mutable reference");\n        mut_ref.push_str(" World");\n        \n        assert_eq!(ext.lock().unwrap().get::<String>().unwrap(), "Hello World");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580938, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=406, prompt_tokens=7277, total_tokens=7683, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4Rx8KXyMgxDr1ntShvBzUlvsif', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Extensions;\n\n    #[test]\n    fn test_get_or_insert_insert_new_value() {\n        let mut ext = Extensions::new();\n        let value = 10i32;\n        let ref_to_value = ext.get_or_insert(value.clone());\n        *ref_to_value += 2;\n\n        assert_eq!(*ref_to_value, 12);\n        assert_eq!(*ext.get::<i32>().unwrap(), 12);\n    }\n\n    #[test]\n    fn test_get_or_insert_return_existing_value() {\n        let mut ext = Extensions::new();\n        ext.get_or_insert(10i32);\n        let ref_to_value = ext.get_or_insert(20i32);\n\n        assert_eq!(*ref_to_value, 10);\n        assert_eq!(*ext.get::<i32>().unwrap(), 10);\n    }\n\n    #[test]\n    fn test_get_or_insert_with_custom_type() {\n        let mut ext = Extensions::new();\n        let key = "test_key".to_string();\n        let ref_to_value: &mut String = ext.get_or_insert(key.clone());\n        ref_to_value.push_str("_value");\n\n        assert_eq!(*ref_to_value, "test_key_value");\n        assert_eq!(*ext.get::<String>().unwrap(), "test_key_value");\n    }\n\n    #[test]\n    fn test_get_or_insert_with_default() {\n        let mut ext = Extensions::new();\n        let ref_to_value: &mut i32 = ext.get_or_insert_default();\n\n        assert_eq!(*ref_to_value, 0);\n        *ref_to_value += 5;\n\n        assert_eq!(*ext.get::<i32>().unwrap(), 5);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580947, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=359, prompt_tokens=8312, total_tokens=8671, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4aQsR0nvYXdLqhWafq9y4tRek8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import everything from the parent module\n    use http::Extensions;\n\n    #[test]\n    fn test_get_or_insert_default_i32() {\n        let mut ext = Extensions::new();\n        *ext.get_or_insert_default::<i32>() += 2;\n        assert_eq!(*ext.get::<i32>().unwrap(), 2);\n    }\n\n    #[test]\n    fn test_get_or_insert_default_byte_str() {\n        let mut ext = Extensions::new();\n        *ext.get_or_insert_default::<byte_str::ByteStr>() = byte_str::ByteStr::from_static("Hello");\n        assert_eq!(*ext.get::<byte_str::ByteStr>().unwrap(), byte_str::ByteStr::from_static("Hello"));\n    }\n\n    #[test]\n    fn test_get_or_insert_default_header_name() {\n        let mut ext = Extensions::new();\n        let header_name = header::name::HeaderName::from_static("content-type");\n        *ext.get_or_insert_default::<header::name::HeaderName>() = header_name.clone();\n        assert_eq!(*ext.get::<header::name::HeaderName>().unwrap(), header_name);\n    }\n\n    #[test]\n    fn test_get_or_insert_default_multiple_calls() {\n        let mut ext = Extensions::new();\n        *ext.get_or_insert_default::<i32>() += 2;\n        *ext.get_or_insert_default::<i32>() += 3;\n        assert_eq!(*ext.get::<i32>().unwrap(), 5);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580956, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=323, prompt_tokens=8387, total_tokens=8710, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4jkjEeWzsaq9R6mmHwNI9vox3L', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Extensions;\n\n    #[test]\n    fn test_get_or_insert_with() {\n        let mut ext = Extensions::new();\n        \n        // First insertion should work\n        let val: &mut i32 = ext.get_or_insert_with(|| 1i32);\n        *val += 2;\n\n        assert_eq!(*ext.get::<i32>().unwrap(), 3);\n        \n        // Ensure the same reference is returned on subsequent calls\n        let val2: &mut i32 = ext.get_or_insert_with(|| 42);\n        assert_eq!(val as *mut i32, val2 as *mut i32);\n        assert_eq!(*val2, 3); // value should be 3, as it was not reinitialized\n    }\n\n    #[test]\n    fn test_get_or_insert_with_multiple_types() {\n        let mut ext = Extensions::new();\n        \n        let val1: &mut i32 = ext.get_or_insert_with(|| 42);\n        *val1 += 8;\n\n        let val2: &mut String = ext.get_or_insert_with(|| String::from("Hello"));\n        val2.push_str(" World");\n\n        assert_eq!(*ext.get::<i32>().unwrap(), 50);\n        assert_eq!(ext.get::<String>().unwrap().as_str(), "Hello World");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580965, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=290, prompt_tokens=8380, total_tokens=8670, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4sLAKmwgpHC2AXbdKg94OHXNjE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Extensions;\n\n    #[test]\n    fn test_insert_new_value() {\n        let mut ext = Extensions::new();\n        assert!(ext.insert(10i32).is_none());\n        assert_eq!(ext.get::<i32>(), Some(&10i32));\n    }\n\n    #[test]\n    fn test_insert_replaces_value() {\n        let mut ext = Extensions::new();\n        ext.insert(20i32);\n        assert_eq!(ext.insert(30i32), Some(20i32));\n        assert_eq!(ext.get::<i32>(), Some(&30i32));\n    }\n\n    #[test]\n    fn test_insert_with_different_types() {\n        let mut ext = Extensions::new();\n        assert!(ext.insert("test".to_string()).is_none());\n        assert!(ext.insert(42u32).is_none());\n        assert_eq!(ext.get::<String>(), Some(&"test".to_string()));\n        assert_eq!(ext.get::<u32>(), Some(&42u32));\n    }\n\n    #[test]\n    fn test_insert_overwriting_different_types() {\n        let mut ext = Extensions::new();\n        ext.insert("initial".to_string());\n        ext.insert(100u16);\n        assert_eq!(ext.insert("new_value".to_string()), Some("initial".to_string()));\n        assert_eq!(ext.get::<String>(), Some(&"new_value".to_string()));\n        assert_eq!(ext.get::<u16>(), Some(&100u16));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580974, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=321, prompt_tokens=8367, total_tokens=8688, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm53PLMN2g8F954mabNjAA6VDami', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::Extensions;\n\n    #[test]\n    fn test_is_empty() {\n        let ext = Extensions::new();\n        assert!(ext.is_empty());\n\n        let mut ext_with_value = Extensions::new();\n        ext_with_value.insert(5i32);\n        assert!(!ext_with_value.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580985, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=77, prompt_tokens=2165, total_tokens=2242, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm57kSGeFsgczUKKnKrDmnoHjJlB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import necessary items from the parent module\n    use http::Extensions; // Import the Extensions type\n\n    #[test]\n    fn test_len() {\n        let ext = Extensions::new();\n        assert_eq!(ext.len(), 0);\n\n        let mut ext_with_insert = Extensions::new();\n        ext_with_insert.insert(5i32);\n        assert_eq!(ext_with_insert.len(), 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580989, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=101, prompt_tokens=2164, total_tokens=2265, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5BlyuAgdO9oLtfyO9MGxwqsfN0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Extensions;\n\n    #[test]\n    fn test_extensions_new() {\n        let ext = Extensions::new();\n        assert!(ext.is_empty());\n        assert_eq!(ext.len(), 0);\n        assert_eq!(format!("{:?}", ext), "Extensions");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580993, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=73, prompt_tokens=2100, total_tokens=2173, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5EyIFTcFG0BaXS7jfPPr1jYfAi', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Extensions;\n\n    #[test]\n    fn test_remove_existing_extension() {\n        let mut ext = Extensions::new();\n        ext.insert(5i32);\n        assert_eq!(ext.remove::<i32>(), Some(5i32));\n        assert!(ext.get::<i32>().is_none());\n    }\n\n    #[test]\n    fn test_remove_non_existing_extension() {\n        let mut ext = Extensions::new();\n        ext.insert(10u32);\n        assert_eq!(ext.remove::<i32>(), None);\n        assert!(ext.get::<i32>().is_none());\n    }\n\n    #[test]\n    fn test_remove_after_insert() {\n        let mut ext = Extensions::new();\n        ext.insert(7.5);\n        assert_eq!(ext.remove::<f64>(), Some(7.5));\n        assert!(ext.get::<f64>().is_none());\n    }\n\n    #[test]\n    fn test_remove_multiple_insertions() {\n        let mut ext = Extensions::new();\n        ext.insert(1i32);\n        ext.insert(2i32);\n        assert_eq!(ext.remove::<i32>(), Some(1i32));\n        assert_eq!(ext.remove::<i32>(), Some(2i32));\n        assert!(ext.get::<i32>().is_none());\n    }\n\n    #[test]\n    fn test_remove_different_types() {\n        let mut ext = Extensions::new();\n        ext.insert(42u64);\n        ext.insert("Hello".to_string());\n        assert_eq!(ext.remove::<u64>(), Some(42u64));\n        assert_eq!(ext.remove::<String>(), Some("Hello".to_string()));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580996, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=353, prompt_tokens=7281, total_tokens=7634, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5NMxcgaEoKEomfFu2PhEshhrKp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::Danger;\n\n    #[test]\n    fn test_is_red() {\n        let red_danger = Danger::Red(RandomState::new());\n        let yellow_danger = Danger::Yellow;\n        let green_danger = Danger::Green;\n\n        assert!(red_danger.is_red());\n        assert!(!yellow_danger.is_red());\n        assert!(!green_danger.is_red());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581005, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=94, prompt_tokens=454, total_tokens=548, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5R67YYt2vd573SBsN54jwy4ul5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use header::map::Danger;\n\n    #[test]\n    fn test_is_yellow() {\n        let yellow_danger = Danger::Yellow;\n        let green_danger = Danger::Green;\n        let red_danger = Danger::Red(RandomState::new());\n\n        assert!(yellow_danger.is_yellow());\n        assert!(!green_danger.is_yellow());\n        assert!(!red_danger.is_yellow());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581009, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=104, prompt_tokens=456, total_tokens=560, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5UhiJmJWg26lpKui209QHQyljJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::RandomState;\n\n    #[test]\n    fn test_set_green() {\n        let mut danger = Danger::Yellow;\n        assert!(danger.is_yellow());\n        \n        danger.set_green();\n        \n        assert!(!danger.is_yellow());\n        assert!(matches!(danger, Danger::Green));\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_green_should_panic_if_not_yellow() {\n        let mut danger = Danger::Green;\n        \n        danger.set_green(); // This should panic due to the debug assert\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581012, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=133, prompt_tokens=458, total_tokens=591, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5YbQ8Lxu1LpAToQ8Q5JNgcmzdb', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::RandomState;\n\n    #[test]\n    fn test_set_red() {\n        let mut danger = Danger::Yellow;\n\n        danger.set_red();\n        \n        assert!(danger.is_red());\n    }\n\n    #[test]\n    #[should_panic(expected = "assertion failed")]\n    fn test_set_red_panics_when_not_yellow() {\n        let mut danger = Danger::Green;\n\n        danger.set_red(); // This should panic\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581016, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=110, prompt_tokens=462, total_tokens=572, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5cvZFHk5ZJ0SBvyw09OfsPcRJU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use header::map::Danger;\n\n    #[test]\n    fn test_set_yellow() {\n        let mut danger_state = Danger::Green;\n\n        // Ensure it is green before setting yellow\n        assert!(!danger_state.is_yellow());\n\n        // Call the method to set yellow\n        danger_state.set_yellow();\n\n        // Check if the state has changed to yellow\n        assert!(danger_state.is_yellow());\n    }\n\n    #[test]\n    fn test_set_yellow_no_change() {\n        let mut danger_state = Danger::Yellow;\n\n        // Ensure it is yellow before setting yellow\n        assert!(danger_state.is_yellow());\n\n        // Call the method to set yellow\n        danger_state.set_yellow();\n\n        // Check if the state is still yellow\n        assert!(danger_state.is_yellow());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581020, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=184, prompt_tokens=464, total_tokens=648, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5iPx4ApiKgKQ3SGUzlDkK0rX3H', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::HeaderName;\n\n    #[test]\n    fn test_key_from_occupied_entry() {\n        let mut map = HeaderMap::new();\n        map.insert(HeaderName::from_static("x-hello"), "value".parse().unwrap());\n\n        let entry = map.entry("x-hello").or_insert("default".parse().unwrap());\n        assert_eq!(entry.key(), &HeaderName::from_static("x-hello"));\n    }\n\n    #[test]\n    fn test_key_from_vacant_entry() {\n        let mut map = HeaderMap::new();\n        let entry = map.entry("x-world");\n        assert_eq!(entry.key(), &HeaderName::from_static("x-world"));\n    }\n\n    #[test]\n    fn test_key_multiple_insertions() {\n        let mut map = HeaderMap::new();\n        map.insert(HeaderName::from_static("x-hello"), "value".parse().unwrap());\n        map.insert(HeaderName::from_static("x-hello"), "new_value".parse().unwrap());\n\n        if let http::header::Entry::Occupied(entry) = map.entry("x-hello") {\n            assert_eq!(entry.key(), &HeaderName::from_static("x-hello"));\n        } else {\n            panic!("Expected occupied entry");\n        }\n    }\n\n    #[test]\n    fn test_key_with_non_existing_entry() {\n        let mut map = HeaderMap::new();\n        let entry = map.entry("x-nonexistent");\n        assert_eq!(entry.key(), &HeaderName::from_static("x-nonexistent"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581026, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=345, prompt_tokens=16361, total_tokens=16706, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5rjbTUAAZTJ7B0tOerx249f3zn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::{CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn test_or_insert_new_entry() {\n        let mut map: HeaderMap<u32> = HeaderMap::default();\n        let counter = map.entry(HOST).or_insert(0);\n        *counter += 1;\n\n        assert_eq!(map[HOST], 1);\n    }\n\n    #[test]\n    fn test_or_insert_existing_entry() {\n        let mut map: HeaderMap<u32> = HeaderMap::default();\n        map.insert(HOST, 1);\n        let counter = map.entry(HOST).or_insert(0);\n        *counter += 1;\n\n        assert_eq!(map[HOST], 2);\n    }\n\n    #[test]\n    #[should_panic(expected = "size overflows MAX_SIZE")]\n    fn test_or_insert_panic() {\n        let mut map: HeaderMap<u32> = HeaderMap::with_capacity(MAX_SIZE);\n        // Fill the map to maximum capacity\n        for i in 0..MAX_SIZE {\n            map.insert(HOST, i);\n        }\n        // This should panic\n        map.entry(HOST).or_insert(0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581035, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=263, prompt_tokens=16361, total_tokens=16624, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm60NHPGiUvBpL7sXFmekqWwUnYP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::HOST;\n\n    #[test]\n    fn test_or_insert_with_inserts_value() {\n        let mut map = HeaderMap::new();\n        let res = map.entry("x-hello").or_insert_with(|| "world".parse().unwrap());\n        assert_eq!(res, "world");\n    }\n\n    #[test]\n    fn test_or_insert_with_does_not_call_default_if_present() {\n        let mut map = HeaderMap::new();\n        map.try_insert(HOST, "world".parse().unwrap()).unwrap();\n        let res = map.try_entry("host").unwrap().or_try_insert_with(|| unreachable!()).unwrap();\n        assert_eq!(res, "world");\n    }\n\n    #[test]\n    fn test_or_insert_with_with_default_function() {\n        let mut map = HeaderMap::new();\n        let res = map.entry("x-greeting").or_insert_with(|| "hello".parse().unwrap());\n        assert_eq!(res, "hello");\n    }\n\n    #[test]\n    fn test_or_insert_with_when_value_present() {\n        let mut map = HeaderMap::new();\n        map.try_insert(HOST, "example.com".parse().unwrap()).unwrap();\n        let res = map.try_entry("host").unwrap().or_try_insert_with(|| "new_value".parse().unwrap()).unwrap();\n        assert_eq!(res, "example.com");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581044, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=306, prompt_tokens=16361, total_tokens=16667, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm6AT8uU1Qvhfld5HsvcJZEVPANF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::HeaderName;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_or_try_insert_with_vacant_entry() {\n        let mut map: HeaderMap<u32> = HeaderMap::default();\n        let header_name = "x-example";\n\n        let entry = map.entry(header_name);\n        let result = entry.or_try_insert(42);\n        \n        assert!(result.is_ok());\n        assert_eq!(*result.unwrap(), 42);\n        assert_eq!(map.get(header_name).unwrap(), &42);\n    }\n\n    #[test]\n    fn test_or_try_insert_with_occupied_entry() {\n        let mut map: HeaderMap<u32> = HeaderMap::default();\n        let header_name = "x-example";\n        map.insert(header_name, 10);\n\n        let entry = map.entry(header_name);\n        let result = entry.or_try_insert(42);\n        \n        assert!(result.is_ok());\n        assert_eq!(*result.unwrap(), 10);\n        assert_eq!(map.get(header_name).unwrap(), &10);\n    }\n\n    #[test]\n    fn test_or_try_insert_exceed_capacity() {\n        let mut map: HeaderMap<u32> = HeaderMap::with_capacity(1);\n        map.insert("x-example-1", 1);\n\n        let result = map.entry("x-example-2").or_try_insert(42);\n        \n        assert!(result.is_ok());\n        assert_eq!(*result.unwrap(), 42);\n        \n        let result = map.entry("x-example-1").or_try_insert(42);\n        \n        assert!(result.is_ok());\n        assert_eq!(*result.unwrap(), 1);\n        \n        let result = map.entry("x-example-3").or_try_insert(42);\n        \n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_or_try_insert_with_unrecognized_key() {\n        let mut map: HeaderMap<u32> = HeaderMap::default();\n        \n        let result = map.entry("not-found").or_try_insert(100);\n        \n        assert!(result.is_ok());\n        assert_eq!(*result.unwrap(), 100);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581054, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=463, prompt_tokens=16361, total_tokens=16824, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm6NtRxR1IPy4tQmeupGB6BMwebh', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HOST};\n\n    #[test]\n    fn test_or_try_insert_with_from_empty() {\n        let mut map = HeaderMap::new();\n        \n        let res = map.entry("x-hello")\n            .or_try_insert_with(|| "world".parse().unwrap())\n            .unwrap();\n        \n        assert_eq!(res, "world");\n    }\n\n    #[test]\n    fn test_or_try_insert_with_from_occupied() {\n        let mut map = HeaderMap::new();\n        map.try_insert(HOST, "world".parse().unwrap()).unwrap();\n\n        let res = map.try_entry("host")\n            .unwrap()\n            .or_try_insert_with(|| unreachable!())\n            .unwrap();\n\n        assert_eq!(res, "world");\n    }\n\n    #[test]\n    fn test_or_try_insert_with_from_vacant() {\n        let mut map = HeaderMap::new();\n        \n        let res = map.entry("x-hello")\n            .or_try_insert_with(|| {\n                "world".parse().unwrap()\n            })\n            .unwrap();\n        \n        assert_eq!(res, "world");\n\n        // Check if inserting again does not call default fn\n        let res2 = map.entry("x-hello")\n            .or_try_insert_with(|| {\n                panic!("should not be called");\n            })\n            .unwrap();\n        \n        assert_eq!(res2, "world");\n    }\n\n    #[test]\n    fn test_or_try_insert_with_invalid() {\n        let mut map: HeaderMap<u32> = HeaderMap::new();\n\n        let result = map.entry("x-nonexistent")\n            .or_try_insert_with(|| 42);\n        \n        assert_eq!(result.unwrap(), &mut 42);\n        assert_eq!(map.get("x-nonexistent"), Some(&42));\n    }\n\n    #[test]\n    fn test_or_try_insert_with_multiple_inserts() {\n        let mut map = HeaderMap::new();\n\n        let first_insert = map.entry("x-hello")\n            .or_try_insert_with(|| "world".parse().unwrap())\n            .unwrap();\n        \n        assert_eq!(first_insert, "world");\n\n        let second_insert = map.entry("x-hello")\n            .or_try_insert_with(|| "not called".parse().unwrap())\n            .unwrap();\n        \n        assert_eq!(second_insert, "world");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581067, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=499, prompt_tokens=16361, total_tokens=16860, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm6t6K6JhCHoVDqH5GcufnjtL8Z0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::HOST;\n\n    #[test]\n    fn test_iter() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "hello.world".parse().unwrap());\n        map.append(HOST, "hello.earth".parse().unwrap());\n\n        let values = map.get_all("host");\n        let mut iter = values.iter();\n        \n        assert_eq!(iter.next(), Some(&"hello.world"));\n        assert_eq!(iter.next(), Some(&"hello.earth"));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_iter_empty() {\n        let map = HeaderMap::new();\n        let values = map.get_all("host");\n        let mut iter = values.iter();\n        \n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_iter_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "value1".parse().unwrap());\n        map.append(HOST, "value2".parse().unwrap());\n        map.append(HOST, "value3".parse().unwrap());\n\n        let values = map.get_all("host");\n        let mut iter = values.iter();\n        \n        assert_eq!(iter.next(), Some(&"value1"));\n        assert_eq!(iter.next(), Some(&"value2"));\n        assert_eq!(iter.next(), Some(&"value3"));\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581099, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=320, prompt_tokens=13832, total_tokens=14152, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm70xdmMy102aCV0eQnn44D11n53', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HOST, CONTENT_LENGTH};\n\n    #[test]\n    fn test_append_new_key() {\n        let mut map = HeaderMap::new();\n        assert!(map.append(HOST, "localhost".parse().unwrap()));\n        assert_eq!(map.get_all(HOST).iter().count(), 1);\n    }\n\n    #[test]\n    fn test_append_existing_key() {\n        let mut map = HeaderMap::new();\n        map.append(HOST, "localhost".parse().unwrap());\n        assert!(map.append(HOST, "127.0.0.1".parse().unwrap()));\n        \n        let values = map.get_all(HOST);\n        let mut iter = values.iter();\n        assert_eq!("localhost", *iter.next().unwrap());\n        assert_eq!("127.0.0.1", *iter.next().unwrap());\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_append_exceeds_max_capacity() {\n        let mut map = HeaderMap::<u32>::with_capacity(MAX_SIZE);\n        map.append(HOST, "localhost".parse().unwrap());\n        map.append(HOST, "127.0.0.1".parse().unwrap());  // Adjust this test depending on your MAX_SIZE definition\n    }\n\n    #[test]\n    fn test_append_no_key() {\n        let mut map = HeaderMap::new();\n        assert!(map.append(HOST, "localhost".parse().unwrap()));\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_append_key_value_pairs() {\n        let mut map = HeaderMap::new();\n        assert!(map.append(HOST, "localhost".parse().unwrap()));\n        assert!(map.append(HOST, "127.0.0.1".parse().unwrap()));\n        assert!(map.append(CONTENT_LENGTH, "100".parse().unwrap()));\n\n        assert_eq!(map.get_all(HOST).iter().count(), 2);\n        assert_eq!(map.get_all(CONTENT_LENGTH).iter().count(), 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581106, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=444, prompt_tokens=16361, total_tokens=16805, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7AVRnjVAUWiDv4aFd3j5EUgyfC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HOST;\n\n    #[test]\n    fn test_capacity_initial() {\n        let map: HeaderMap = HeaderMap::new();\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_with_insert() {\n        let mut map: HeaderMap = HeaderMap::new();\n        map.insert(HOST, "hello.world".parse().unwrap());\n        assert!(map.capacity() > 0);\n    }\n\n    #[test]\n    fn test_capacity_after_multiple_inserts() {\n        let mut map: HeaderMap = HeaderMap::new();\n        for i in 0..10 {\n            map.insert(HOST, format!("value{}", i).parse().unwrap());\n        }\n        assert!(map.capacity() > 10);\n    }\n\n    #[test]\n    fn test_capacity_with_clear() {\n        let mut map: HeaderMap = HeaderMap::new();\n        map.insert(HOST, "hello.world".parse().unwrap());\n        let capacity_before_clear = map.capacity();\n        map.clear();\n        assert!(map.capacity() >= capacity_before_clear);\n        assert!(map.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581116, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=248, prompt_tokens=12642, total_tokens=12890, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7IMUnahqqFf6VGB13ZS5GklITG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HOST};\n\n    #[test]\n    fn test_clear() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "hello.world".parse().unwrap());\n\n        // Clear the map\n        map.clear();\n        \n        // Check if the map is empty\n        assert!(map.is_empty());\n        \n        // Check if the capacity is greater than 0\n        assert!(map.capacity() > 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581124, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=110, prompt_tokens=12660, total_tokens=12770, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7Qlhrkzsl0YP6laiEEaQvnW0lF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HOST, CONTENT_TYPE};\n\n    #[test]\n    fn test_contains_key() {\n        let mut map = HeaderMap::new();\n        assert!(!map.contains_key(HOST));\n\n        map.insert(HOST, "example.com".parse().unwrap());\n        assert!(map.contains_key(HOST));\n        assert!(map.contains_key("host"));\n        assert!(!map.contains_key(CONTENT_TYPE));\n    }\n\n    #[test]\n    fn test_contains_key_with_custom_key() {\n        let mut map = HeaderMap::new();\n        assert!(!map.contains_key("X-Custom-Header"));\n\n        map.insert("X-Custom-Header", "value".parse().unwrap());\n        assert!(map.contains_key("X-Custom-Header"));\n    }\n\n    #[test]\n    fn test_contains_key_case_insensitivity() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        assert!(map.contains_key("HOST"));\n        assert!(map.contains_key("host"));\n    }\n\n    #[test]\n    fn test_contains_key_after_removal() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        assert!(map.contains_key(HOST));\n\n        map.remove(HOST);\n        assert!(!map.contains_key(HOST));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581132, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=297, prompt_tokens=16361, total_tokens=16658, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7ataeq3dkLOflr9WJycRTLUkOl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust the import based on your module structure\n    use http::header::{CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn test_drain() {\n        let mut map = HeaderMap::new();\n\n        map.insert(HOST, "hello".parse().unwrap());\n        map.append(HOST, "goodbye".parse().unwrap());\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut drain = map.drain();\n\n        assert_eq!(drain.next(), Some((Some(HOST), "hello".parse().unwrap())));\n        assert_eq!(drain.next(), Some((None, "goodbye".parse().unwrap())));\n        assert_eq!(drain.next(), Some((Some(CONTENT_LENGTH), "123".parse().unwrap())));\n        assert_eq!(drain.next(), None);\n    }\n\n    #[test]\n    fn test_drain_empty() {\n        let mut map = HeaderMap::new();\n        let mut drain = map.drain();\n        assert_eq!(drain.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581142, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=229, prompt_tokens=16361, total_tokens=16590, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7hjdeOnMiuRgrLVMlInqAkLNak', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::{HeaderName, HOST};\n\n    #[test]\n    fn test_entry_insert() {\n        let mut map: HeaderMap<u32> = HeaderMap::default();\n        let header = "x-hello";\n\n        let counter = map.entry(header).or_insert(0);\n        assert_eq!(*counter, 0);\n        *counter += 1;\n\n        assert_eq!(map[header], 1);\n    }\n\n    #[test]\n    fn test_entry_insert_multiple() {\n        let mut map: HeaderMap<u32> = HeaderMap::default();\n        let headers = &["content-length", "x-hello", "x-world"];\n\n        for &header in headers {\n            let counter = map.entry(header).or_insert(0);\n            *counter += 1;\n        }\n\n        assert_eq!(map["content-length"], 1);\n        assert_eq!(map["x-hello"], 1);\n        assert_eq!(map["x-world"], 1);\n    }\n\n    #[test]\n    fn test_entry_overwrite() {\n        let mut map: HeaderMap<u32> = HeaderMap::default();\n        let header = "x-hello";\n\n        {\n            let counter = map.entry(header).or_insert(0);\n            *counter += 1;\n        }\n\n        {\n            let counter = map.entry(header).or_insert(0);\n            *counter += 2;\n        }\n\n        assert_eq!(map[header], 3);\n    }\n\n    #[test]\n    #[should_panic(expected = "size overflows MAX_SIZE")]\n    fn test_entry_panic_on_overflow() {\n        let mut map: HeaderMap<u32> = HeaderMap::default();\n        for i in 0..=u32::MAX {\n            map.entry("x-hello").or_insert(i);\n        }\n    }\n\n    #[test]\n    fn test_entry_key() {\n        let mut map = HeaderMap::default();\n        let header = "x-hello";\n\n        map.entry(header).or_insert(0);\n        let entry = map.entry(header);\n        assert_eq!(entry.key(), &HeaderName::from_static(header));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581149, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=464, prompt_tokens=16361, total_tokens=16825, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7uSFcvfyODMqw2TweKEZciLESQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn test_find_existing_key() {\n        let mut header_map = HeaderMap::new();\n        header_map.insert(HOST, "example.com".parse().unwrap());\n        header_map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let result = header_map.find(HOST);\n        assert_eq!(result, Some((0, 0))); // Assuming HOST is hashed to 0, and index 0 is where it is stored\n    }\n\n    #[test]\n    fn test_find_non_existing_key() {\n        let header_map: HeaderMap = HeaderMap::new();\n        let result = header_map.find(HOST);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_find_key_with_collision() {\n        let mut header_map = HeaderMap::new();\n        // Insert entries, assuming they hash to the same index\n        header_map.insert(HOST, "example.com".parse().unwrap());\n        // This first insert will need to hash to a different index or a key collision\n        header_map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        // Re-insert HOST to simulate collision scenario\n        let result = header_map.find(CONTENT_LENGTH);\n        assert_eq!(result, Some((1, 1))); // Assuming CONTENT_LENGTH is hashed to 1 and index 1\n    }\n\n    #[test]\n    fn test_find_empty_header_map() {\n        let header_map: HeaderMap = HeaderMap::new();\n        let result = header_map.find(&HeaderName::from_static("non-existing-header"));\n        assert_eq!(result, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581162, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=366, prompt_tokens=13862, total_tokens=14228, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm83NXDJU70JxiUH5UqueDrsaczS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming the necessary modules are imported here\n    use http::header::{HOST, CONTENT_LENGTH, HeaderName};\n\n    #[test]\n    fn test_get_empty_header_map() {\n        let map: HeaderMap = HeaderMap::new();\n        assert!(map.get(HOST).is_none());\n    }\n\n    #[test]\n    fn test_get_single_insert() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "localhost".parse().unwrap());\n        assert_eq!(map.get(HOST).unwrap(), &"localhost");\n    }\n\n    #[test]\n    fn test_get_case_insensitive() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        assert_eq!(map.get("host").unwrap(), &"example.com");\n    }\n\n    #[test]\n    fn test_get_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.append(HOST, "test.com".parse().unwrap());\n\n        assert_eq!(map.get(HOST).unwrap(), &"example.com");\n    }\n\n    #[test]\n    fn test_get_non_existing_key() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        assert!(map.get(HOST).is_none());\n    }\n\n    #[test]\n    fn test_get_with_nonstandard_header() {\n        let mut map = HeaderMap::new();\n        let custom_header = HeaderName::from_static("x-custom-header");\n        map.insert(custom_header.clone(), "value".parse().unwrap());\n        assert_eq!(map.get(custom_header).unwrap(), &"value");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581171, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=374, prompt_tokens=16361, total_tokens=16735, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm8FAmV0xDeJTpTrlh4vpfDUjBVt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, CONTENT_TYPE};\n\n    #[test]\n    fn test_get2_existing_key() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let key: HeaderName = HeaderName::from_static("content-length");\n        assert_eq!(headers.get2(&key), Some(&"123".parse().unwrap()));\n    }\n\n    #[test]\n    fn test_get2_non_existing_key() {\n        let headers = HeaderMap::<String>::new();\n        \n        let key: HeaderName = HeaderName::from_static("non-existing-header");\n        assert_eq!(headers.get2(&key), None);\n    }\n\n    #[test]\n    fn test_get2_case_insensitivity() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_TYPE, "application/json".parse().unwrap());\n\n        let key: HeaderName = HeaderName::from_static("Content-Type");\n        assert_eq!(headers.get2(&key), Some(&"application/json".parse().unwrap()));\n    }\n\n    #[test]\n    fn test_get2_with_multiple_values() {\n        let mut headers = HeaderMap::new();\n        headers.append(CONTENT_LENGTH, "123".parse().unwrap());\n        headers.append(CONTENT_LENGTH, "456".parse().unwrap());\n\n        let key: HeaderName = HeaderName::from_static("content-length");\n        assert_eq!(headers.get2(&key), Some(&"123".parse().unwrap()));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581183, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=332, prompt_tokens=16361, total_tokens=16693, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm8OS5yo7auU87NV4rre1kF7UcaA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HOST, HeaderValue};\n    use http::HeaderMap;\n\n    #[test]\n    fn test_get_all_empty() {\n        let map: HeaderMap = HeaderMap::new();\n        let view = map.get_all("host");\n        let mut iter = view.iter();\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_get_all_single_value() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, HeaderValue::from_static("example.com"));\n        let view = map.get_all("host");\n        let mut iter = view.iter();\n        assert_eq!(iter.next().unwrap(), &HeaderValue::from_static("example.com"));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_get_all_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, HeaderValue::from_static("example.com"));\n        map.append(HOST, HeaderValue::from_static("test.com"));\n        let view = map.get_all("host");\n        let mut iter = view.iter();\n        assert_eq!(iter.next().unwrap(), &HeaderValue::from_static("example.com"));\n        assert_eq!(iter.next().unwrap(), &HeaderValue::from_static("test.com"));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_get_all_case_insensitivity() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, HeaderValue::from_static("example.com"));\n        map.append(HOST, HeaderValue::from_static("test.com"));\n        let view = map.get_all("HOST"); // Different case\n        let mut iter = view.iter();\n        assert_eq!(iter.next().unwrap(), &HeaderValue::from_static("example.com"));\n        assert_eq!(iter.next().unwrap(), &HeaderValue::from_static("test.com"));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_get_all_non_existent_key() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, HeaderValue::from_static("example.com"));\n        let view = map.get_all("non-existent");\n        let mut iter = view.iter();\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581192, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=488, prompt_tokens=16361, total_tokens=16849, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm8dVOTq1f2NMyadr4RQ5PqOxA09', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HOST;\n\n    #[test]\n    fn test_get_mut_existing_key() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "hello".to_string());\n        let value = map.get_mut(HOST).unwrap();\n        value.push_str("-world");\n        assert_eq!(map.get(HOST).unwrap(), &"hello-world");\n    }\n\n    #[test]\n    fn test_get_mut_non_existent_key() {\n        let mut map = HeaderMap::new();\n        let value = map.get_mut("non-existent");\n        assert!(value.is_none());\n    }\n\n    #[test]\n    fn test_get_mut_multiple_keys() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "hello".to_string());\n        map.append(HOST, "world".to_string());\n        let value = map.get_mut(HOST).unwrap();\n        value.push_str("-updated");\n        let values: Vec<_> = map.get_all(HOST).iter().collect();\n        assert_eq!(values[0], &"hello-updated");\n        assert_eq!(values[1], &"world");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581207, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=253, prompt_tokens=16361, total_tokens=16614, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm8mX1vCI5nXMHjWmCVUff4mrylB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HOST, CONTENT_LENGTH};\n\n    #[test]\n    fn test_insert_new_key() {\n        let mut map = HeaderMap::new();\n        let previous = map.insert(HOST, "localhost".parse().unwrap());\n        assert!(previous.is_none());\n        assert_eq!(map[HOST], "localhost");\n    }\n\n    #[test]\n    fn test_insert_existing_key() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "localhost".parse().unwrap());\n        let previous = map.insert(HOST, "127.0.0.1".parse().unwrap()).unwrap();\n        assert_eq!(previous, "localhost");\n        assert_eq!(map[HOST], "127.0.0.1");\n    }\n\n    #[test]\n    fn test_insert_empty_key() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        let previous = map.insert(HOST, "".to_string());\n        assert!(previous.is_none());\n        assert_eq!(map[HOST], "");\n    }\n\n    #[test]\n    fn test_insert_exceeding_capacity() {\n        let mut map: HeaderMap<i32> = HeaderMap::with_capacity(1);\n        let _ = map.insert(CONTENT_LENGTH, 1);\n        let _ = map.insert(CONTENT_LENGTH, 2); // should not panic, just overwrite\n        assert_eq!(map[CONTENT_LENGTH], 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581216, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=313, prompt_tokens=16361, total_tokens=16674, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm8wmIzAjJ5nbI2hP8YEWxU8i6OJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HOST;\n\n    #[test]\n    fn test_insert_occupied() {\n        let mut header_map: HeaderMap<String> = HeaderMap::new();\n\n        // Inserting a value for HOST\n        header_map.insert(HOST, "initial_value".to_string());\n        \n        // Checking the value before using `insert_occupied`\n        assert_eq!(header_map.get(HOST).unwrap(), &"initial_value");\n\n        // Simulate the insertion of a new value using `insert_occupied`\n        let replaced_value = header_map.insert_occupied(header_map.find(&HOST).unwrap().1, "new_value".to_string());\n\n        // Asserting the value was replaced correctly\n        assert_eq!(replaced_value, "initial_value");\n        assert_eq!(header_map.get(HOST).unwrap(), &"new_value");\n    }\n\n    #[test]\n    fn test_insert_occupied_with_links() {\n        let mut header_map: HeaderMap<String> = HeaderMap::new();\n        \n        // Inserting multiple values to simulate links\n        header_map.insert(HOST, "value1".to_string());\n        header_map.append(HOST, "value2".to_string());\n\n        // Checking the values before using `insert_occupied`\n        assert_eq!(header_map.get_all(HOST).iter().count(), 2);\n\n        // Simulate the insertion of a new value, which will replace the first\n        let replaced_value = header_map.insert_occupied(header_map.find(&HOST).unwrap().1, "new_value".to_string());\n\n        // Asserting that the initial value was returned\n        assert_eq!(replaced_value, "value1");\n        \n        // Asserting the new value is now the first value for HOST\n        assert_eq!(header_map.get(HOST).unwrap(), &"new_value");\n        assert_eq!(header_map.get_all(HOST).iter().count(), 2); // Still 2 values, ensures link was kept\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581226, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=419, prompt_tokens=12607, total_tokens=13026, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm97pS92dnGYJyDAPfdf0EB8oCHX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_TYPE};\n    use std::sync::Arc;\n\n    #[test]\n    fn test_insert_occupied_mult() {\n        let mut map: HeaderMap<Arc<String>> = HeaderMap::new();\n        let key = CONTENT_TYPE;\n\n        // Insert the key with a first value\n        map.insert(key, Arc::new("application/json".to_string()));\n        let value_drain = map.insert_occupied_mult(0, Arc::new("text/plain".to_string()));\n\n        // Check the returned ValueDrain contains the old value\n        assert_eq!(value_drain.first, Some(Arc::new("application/json".to_string())));\n\n        // Check the map contains the new value\n        assert_eq!(map.get(key).unwrap().as_ref(), "text/plain");\n\n        // Check the ValueDrain after insertion\n        let drained_values: Vec<_> = value_drain.collect();\n        assert_eq!(drained_values, vec![Arc::new("application/json".to_string())]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581237, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=229, prompt_tokens=13100, total_tokens=13329, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm9EcD1TX287wudAi1gnw4TdXG5Z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HOST;\n\n    #[test]\n    fn test_is_empty() {\n        let mut map = HeaderMap::new();\n        assert!(map.is_empty());\n\n        map.insert(HOST, "example.com".parse().unwrap());\n        assert!(!map.is_empty());\n\n        map.clear();\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_is_empty_with_multiple_keys() {\n        let mut map = HeaderMap::new();\n        assert!(map.is_empty());\n\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.insert(HOST, "localhost".parse().unwrap());\n        assert!(!map.is_empty());\n\n        map.remove(HOST);\n        assert!(!map.is_empty());\n\n        map.remove(HOST);\n        assert!(map.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581244, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=182, prompt_tokens=12618, total_tokens=12800, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm9KRO4nLRLJCm4uHyvh4zk7TCSk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn iter_yields_correct_key_value_pairs() {\n        let mut map = HeaderMap::new();\n\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.append(HOST, "example.org".parse().unwrap());\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let mut iter = map.iter();\n\n        // Test HOST key-value pairs\n        let (key1, value1) = iter.next().unwrap();\n        assert_eq!(key1, &HOST);\n        assert_eq!(value1, &"example.com".parse().unwrap());\n\n        let (key2, value2) = iter.next().unwrap();\n        assert_eq!(key2, &HOST);\n        assert_eq!(value2, &"example.org".parse().unwrap());\n\n        // Test CONTENT_LENGTH key-value pair\n        let (key3, value3) = iter.next().unwrap();\n        assert_eq!(key3, &CONTENT_LENGTH);\n        assert_eq!(value3, &"123".parse().unwrap());\n\n        // Ensure there are no more items\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn iter_multiple_values() {\n        let mut map = HeaderMap::new();\n\n        map.append(HOST, "one.com".parse().unwrap());\n        map.append(HOST, "two.com".parse().unwrap());\n\n        let mut iter = map.iter();\n        \n        let (key1, value1) = iter.next().unwrap();\n        assert_eq!(key1, &HOST);\n        assert_eq!(value1, &"one.com".parse().unwrap());\n\n        let (key2, value2) = iter.next().unwrap();\n        assert_eq!(key2, &HOST);\n        assert_eq!(value2, &"two.com".parse().unwrap());\n\n        assert!(iter.next().is_none());\n    }\n    \n    #[test]\n    fn iter_empty_map() {\n        let map: HeaderMap = HeaderMap::new();\n        assert!(map.iter().next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581250, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=451, prompt_tokens=13239, total_tokens=13690, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm9W7Uu3jq535sEL9nHyVAQZzNlA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn test_iter_mut() {\n        let mut map = HeaderMap::default();\n\n        map.insert(HOST, "hello".to_string());\n        map.append(HOST, "goodbye".to_string());\n        map.insert(CONTENT_LENGTH, "123".to_string());\n\n        for (key, value) in map.iter_mut() {\n            value.push_str("-test");\n        }\n\n        assert_eq!(map.get(HOST).unwrap(), "hello-test");\n        assert_eq!(map.get_all(HOST).len(), 2);\n        assert_eq!(map.get_all(HOST).iter().nth(1).unwrap(), &"goodbye-test");\n        assert_eq!(map.get(CONTENT_LENGTH).unwrap(), "123-test");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581262, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=182, prompt_tokens=13374, total_tokens=13556, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm9cyT9QVaTXdx9ZibKlz43kIW5B', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::{CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn test_keys() {\n        let mut map = HeaderMap::new();\n\n        assert_eq!(map.keys().count(), 0);\n\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        map.append(HOST, "another.com".parse().unwrap());\n\n        let keys: Vec<_> = map.keys().collect();\n\n        assert_eq!(keys.len(), 2);\n        assert!(keys.contains(&&*HOST));\n        assert!(keys.contains(&&*CONTENT_LENGTH));\n    }\n\n    #[test]\n    fn test_keys_no_duplicates() {\n        let mut map = HeaderMap::new();\n\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.append(HOST, "another.com".parse().unwrap());\n\n        let keys: Vec<_> = map.keys().collect();\n\n        assert_eq!(keys.len(), 1);\n        assert_eq!(keys[0], &*HOST);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581268, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=242, prompt_tokens=12992, total_tokens=13234, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmA1kARl3iNLPZ6evZGB3P9dzufS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{ACCEPT, HOST};\n\n    #[test]\n    fn test_keys_len() {\n        let mut map = HeaderMap::new();\n        assert_eq!(0, map.keys_len());\n\n        map.insert(ACCEPT, "text/plain".parse().unwrap());\n        map.insert(HOST, "localhost".parse().unwrap());\n        assert_eq!(2, map.keys_len());\n\n        map.insert(ACCEPT, "text/html".parse().unwrap());\n        assert_eq!(2, map.keys_len());\n\n        map.clear();\n        assert_eq!(0, map.keys_len());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581293, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=137, prompt_tokens=12687, total_tokens=12824, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmA7ker10gGEsk9CVDvhjAQcK37g', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{ACCEPT, HOST};\n\n    #[test]\n    fn test_len_empty() {\n        let map = HeaderMap::new();\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_len_single_insert() {\n        let mut map = HeaderMap::new();\n        map.insert(ACCEPT, "text/plain".parse().unwrap());\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_len_multiple_inserts() {\n        let mut map = HeaderMap::new();\n        map.insert(ACCEPT, "text/plain".parse().unwrap());\n        map.insert(HOST, "localhost".parse().unwrap());\n        assert_eq!(map.len(), 2);\n    }\n\n    #[test]\n    fn test_len_multiple_values_for_key() {\n        let mut map = HeaderMap::new();\n        map.insert(ACCEPT, "text/plain".parse().unwrap());\n        map.append(ACCEPT, "text/html".parse().unwrap());\n        assert_eq!(map.len(), 2);\n    }\n\n    #[test]\n    fn test_len_with_multiple_keys_and_values() {\n        let mut map = HeaderMap::new();\n        map.insert(ACCEPT, "text/plain".parse().unwrap());\n        map.insert(HOST, "localhost".parse().unwrap());\n        map.append(ACCEPT, "text/html".parse().unwrap());\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn test_len_clear() {\n        let mut map = HeaderMap::new();\n        map.insert(ACCEPT, "text/plain".parse().unwrap());\n        map.insert(HOST, "localhost".parse().unwrap());\n        map.clear();\n        assert_eq!(map.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581299, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=382, prompt_tokens=12707, total_tokens=13089, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmAH3CLcNQLzkah5jtPjkVK22PXv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderName;\n\n    #[test]\n    fn test_raw_links() {\n        let mut map: HeaderMap<u32> = HeaderMap::new();\n        let header_name = HeaderName::from_static("X-Custom-Header");\n\n        map.insert(header_name.clone(), 10);\n        let raw_links = map.raw_links();\n        \n        assert_eq!(raw_links[0].is_some(), true);\n        assert_eq!(map.entries[0].value, 10);\n\n        // Insert more entries to test multiple raw links\n        map.insert(header_name.clone(), 20);\n        assert_eq!(raw_links[0].is_some(), true);\n        assert_eq!(map.entries.len(), 2);\n        assert_eq!(map.entries[1].value, 20);\n    }\n\n    #[test]\n    fn test_raw_links_empty() {\n        let mut map: HeaderMap<u32> = HeaderMap::new();\n        let raw_links = map.raw_links();\n        \n        assert_eq!(raw_links[0].is_none(), true);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581309, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=233, prompt_tokens=16361, total_tokens=16594, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmAQpeuDc8rw20ZpSUr0ItXLa4E8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, CONTENT_TYPE};\n\n    #[test]\n    fn test_rebuild_with_elements() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_TYPE, "application/json".parse().unwrap());\n        map.insert(CONTENT_TYPE, "text/html".parse().unwrap());\n        \n        map.rebuild();\n        \n        assert_eq!(map.len(), 2);\n        assert!(map.contains_key(CONTENT_TYPE));\n    }\n\n    #[test]\n    fn test_rebuild_with_no_elements() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        \n        map.rebuild();\n        \n        assert_eq!(map.len(), 0);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_rebuild_with_duplicates() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_TYPE, "text/plain".parse().unwrap());\n        map.append(CONTENT_TYPE, "text/plain".parse().unwrap()); // Duplicate\n        \n        map.rebuild();\n        \n        let values = map.get_all(CONTENT_TYPE);\n        let mut iter = values.iter();\n        \n        assert_eq!(iter.next().unwrap(), &"text/plain");\n        assert_eq!(iter.next().unwrap(), &"text/plain");\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_rebuild_with_varied_keys() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_TYPE, "application/xml".parse().unwrap());\n        map.append(CONTENT_TYPE, "application/json".parse().unwrap());\n        \n        // Adding another header\n        map.append("X-Custom-Header".parse().unwrap(), "test".parse().unwrap());\n\n        map.rebuild();\n        \n        assert_eq!(map.len(), 3);\n        assert!(map.contains_key("X-Custom-Header"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581318, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=408, prompt_tokens=12752, total_tokens=13160, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmAdseTkQQycHUw8alnhmNO5CSaz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_reinsert_entry_in_order() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::new();\n\n        let key = "test-header";\n        let value = HeaderValue::from_static("test-value");\n\n        // Insert an entry\n        let pos = map.insert(key, value).unwrap();\n\n        // Get the index and hash for the current entry\n        let (index, hash) = pos.resolve().unwrap();\n\n        // Create a new Pos to reinsert\n        let new_pos = Pos::new(index, hash);\n\n        // Call reinsert_entry_in_order\n        map.reinsert_entry_in_order(new_pos);\n\n        // Check if the entry is still present in the HeaderMap\n        assert_eq!(map.get(key).unwrap(), &HeaderValue::from_static("test-value"));\n    }\n\n    #[test]\n    fn test_reinsert_entry_in_order_empty_bucket() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);\n\n        let key = "header-key";\n        let value = HeaderValue::from_static("header-value");\n\n        // Insert an entry\n        let pos = map.insert(key, value).unwrap();\n\n        // Get the index and hash for the current entry\n        let (index, hash) = pos.resolve().unwrap();\n\n        // Create a new Pos for the reinsert\n        let new_pos = Pos::new(index, hash);\n\n        // Call reinsert_entry_in_order\n        map.reinsert_entry_in_order(new_pos);\n\n        // Verify the entry is still present\n        assert_eq!(map.get(key).unwrap(), &HeaderValue::from_static("header-value"));\n    }\n\n    #[test]\n    fn test_reinsert_entry_in_order_with_collision() {\n        let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(2);\n\n        let key1 = "header1";\n        let value1 = HeaderValue::from_static("value1");\n        let key2 = "header2"; // Assume it would collide in a real hash function\n        let value2 = HeaderValue::from_static("value2");\n\n        // Insert the first entry\n        let pos1 = map.insert(key1, value1).unwrap();\n        let pos2 = map.insert(key2, value2).unwrap();\n\n        // Get the positions\n        let (index1, hash1) = pos1.resolve().unwrap();\n        let (index2, hash2) = pos2.resolve().unwrap();\n\n        // Create new Pos for reinsert\n        let new_pos1 = Pos::new(index1, hash1);\n        let new_pos2 = Pos::new(index2, hash2);\n\n        // Call reinsert_entry_in_order\n        map.reinsert_entry_in_order(new_pos1);\n        map.reinsert_entry_in_order(new_pos2);\n\n        // Verify that entries still exist\n        assert_eq!(map.get(key1).unwrap(), &HeaderValue::from_static("value1"));\n        assert_eq!(map.get(key2).unwrap(), &HeaderValue::from_static("value2"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581331, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=660, prompt_tokens=13066, total_tokens=13726, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmAtFVDohfhfHLF0IzF0W5BcP7Xf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HOST, HeaderName};\n\n    #[test]\n    fn test_remove_existing_key() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        \n        let removed_value = map.remove(HOST);\n        assert_eq!(removed_value, Some("example.com".parse().unwrap()));\n        assert!(map.get(HOST).is_none());\n    }\n\n    #[test]\n    fn test_remove_non_existing_key() {\n        let mut map = HeaderMap::new();\n        assert!(map.remove(HOST).is_none());\n        \n        map.insert(HOST, "example.com".parse().unwrap());\n        map.remove(HOST);\n        assert!(map.remove(HOST).is_none());\n    }\n\n    #[test]\n    fn test_remove_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.append(HOST, "example.org".parse().unwrap());\n        \n        let removed_value = map.remove(HOST);\n        assert_eq!(removed_value, Some("example.com".parse().unwrap()));\n\n        let values = map.get_all(HOST);\n        let mut iter = values.iter();\n        assert_eq!(iter.next().unwrap(), "example.org");\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_remove_key_after_multiple_appends() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "initial_value".parse().unwrap());\n        map.append(HOST, "subsequent_value".parse().unwrap());\n        \n        assert_eq!(map.len(), 2);\n        \n        let removed_value = map.remove(HOST);\n        assert_eq!(removed_value, Some("initial_value".parse().unwrap()));\n        assert_eq!(map.len(), 1);\n        assert!(map.get(HOST).is_some());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581347, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=406, prompt_tokens=16361, total_tokens=16767, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmB6qeiOoaEuNl9PVkO6Ou3yQAGg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_TYPE, CONTENT_LENGTH};\n\n    #[test]\n    fn test_remove_all_extra_values() {\n        // Create a HeaderMap with some entries\n        let mut header_map = HeaderMap::new();\n        header_map.insert(CONTENT_TYPE, "application/json".parse().unwrap());\n        header_map.append(CONTENT_LENGTH, "123".parse().unwrap());\n        header_map.append(CONTENT_LENGTH, "456".parse().unwrap());\n\n        // Manually set some extra values for testing\n        let extra_value1 = ExtraValue::new(...); // Replace with appropriate initialization\n        let extra_value2 = ExtraValue::new(...); // Replace with appropriate initialization\n        header_map.extra_values.push(extra_value1);\n        header_map.extra_values.push(extra_value2);\n        \n        // Ensure extra values exist before removal\n        assert_eq!(header_map.extra_values.len(), 2);\n        \n        // Manually set up links to extra values\n        let links = ...; // Set up to point to extra values that need to be removed\n        header_map.entries[0].links = Some(links);\n        \n        // Call the method under test\n        header_map.remove_all_extra_values(0);\n        \n        // Assert that extra values have been removed\n        assert_eq!(header_map.extra_values.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581360, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=294, prompt_tokens=12585, total_tokens=12879, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmBEhMWWUDxh0fJseTMhThm08k9z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n    \n    #[test]\n    fn test_remove_extra_value() {\n        let mut header_map: HeaderMap<String> = HeaderMap::new();\n        \n        // Insert some extra values\n        header_map.append(HOST, "example.com".to_string());\n        header_map.append(HOST, "test.com".to_string());\n        \n        // Check length before removal\n        assert_eq!(header_map.len(), 2);\n        \n        // Remove extra value at index 0\n        let removed_value = header_map.remove_extra_value(0);\n        \n        // Check removed value\n        assert_eq!(removed_value.value, "test.com".to_string());\n        \n        // Check length after removal\n        assert_eq!(header_map.len(), 1);\n        \n        // Check if the remaining value is correct\n        let remaining_value = header_map.get_all(HOST);\n        let mut values = remaining_value.iter();\n        assert_eq!(values.next().unwrap(), "example.com");\n        assert!(values.next().is_none());\n    }\n    \n    #[test]\n    #[should_panic]\n    fn test_remove_extra_value_out_of_bounds() {\n        let mut header_map: HeaderMap<String> = HeaderMap::new();\n        header_map.remove_extra_value(0); // This should panic since there are no extra values\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581368, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=292, prompt_tokens=12806, total_tokens=13098, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmBR2vDN4uPKWTJl76ya6dI8VTtr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn test_remove_found() {\n        let mut map = HeaderMap::new();\n        \n        map.insert(HOST, "example.com".parse().unwrap());\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        \n        assert_eq!(map.len(), 2);\n        \n        let idx = map.find(&HOST).unwrap().1;\n        let probe = map.find(&HOST).unwrap().0;\n\n        let removed_bucket = map.remove_found(probe, idx);\n        \n        assert_eq!(removed_bucket.key, HOST);\n        assert_eq!(removed_bucket.value, "example.com");\n        assert_eq!(map.len(), 1);\n        assert!(!map.contains_key(HOST));\n    }\n\n    #[test]\n    fn test_remove_found_with_multiple_entries() {\n        let mut map = HeaderMap::new();\n        \n        map.insert(HOST, "example.com".parse().unwrap());\n        map.append(HOST, "example.org".parse().unwrap());\n        \n        assert_eq!(map.len(), 2);\n        \n        let idx = map.find(&HOST).unwrap().1;\n        let probe = map.find(&HOST).unwrap().0;\n\n        let removed_bucket = map.remove_found(probe, idx);\n        \n        assert_eq!(removed_bucket.key, HOST);\n        assert_eq!(removed_bucket.value, "example.com");\n        assert_eq!(map.len(), 1);\n        assert!(map.get_all(HOST).iter().count(), 1);\n    }\n\n    #[test]\n    fn test_remove_found_empty_map() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        \n        assert!(map.is_empty());\n        \n        let result = std::panic::catch_unwind(|| {\n            map.remove_found(0, 0);\n        });\n        \n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581381, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=404, prompt_tokens=16361, total_tokens=16765, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmBcCMtHseW0ASOdf9I0HItx8pzL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::HOST;\n\n    #[test]\n    fn test_reserve() {\n        let mut map = HeaderMap::new();\n        map.reserve(10);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    #[should_panic(expected = "size overflows MAX_SIZE")]\n    fn test_reserve_overflow() {\n        let mut map = HeaderMap::new();\n        // Assuming MAX_SIZE is known; replace `MAX_SIZE` with the actual max size.\n        map.reserve(MAX_SIZE + 1);\n    }\n\n    #[test]\n    fn test_reserve_multiple_calls() {\n        let mut map = HeaderMap::new();\n        map.reserve(5);\n        map.reserve(10);\n        assert!(map.capacity() >= 15);\n    }\n\n    #[test]\n    fn test_reserve_with_capacity() {\n        let mut map = HeaderMap::with_capacity(5);\n        map.reserve(5);\n        assert!(map.capacity() >= 10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581392, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=228, prompt_tokens=12712, total_tokens=12940, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmBjSF8qNTg2RkYQ16EW5aAazAsu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HOST;\n\n    #[test]\n    fn test_try_append_new_key() {\n        let mut map = HeaderMap::new();\n        assert!(map.try_append(HOST, "world".parse().unwrap()).unwrap() == false);\n        assert_eq!(map.get_all("host").iter().count(), 1);\n        assert_eq!(map.get_all("host").iter().next().unwrap(), "world");\n    }\n\n    #[test]\n    fn test_try_append_existing_key() {\n        let mut map = HeaderMap::new();\n        map.try_append(HOST, "world".parse().unwrap()).unwrap();\n        assert!(map.try_append(HOST, "earth".parse().unwrap()).unwrap() == true);\n        let values = map.get_all("host");\n        let mut iter = values.iter();\n        assert_eq!(iter.next().unwrap(), "world");\n        assert_eq!(iter.next().unwrap(), "earth");\n    }\n\n    #[test]\n    fn test_try_append_exceeding_capacity() {\n        let mut map = HeaderMap::try_with_capacity(1).unwrap();\n        map.try_append(HOST, "value1".parse().unwrap()).unwrap();\n        let result = map.try_append(HOST, "value2".parse().unwrap());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_append_invalid_key() {\n        let mut map = HeaderMap::new();\n        // Assuming we have a custom header name that does not conform\n        // let result = map.try_append("Invalid-Header-Name".parse().unwrap(), "value".parse().unwrap());\n        // assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581399, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=358, prompt_tokens=16361, total_tokens=16719, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmBvsXqgRngPSwrqjANQLHQTsEQ2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_TYPE};\n\n    #[test]\n    fn test_try_append2_vacant() {\n        let mut header_map = HeaderMap::new();\n        let key = HeaderName::from_static("example-header");\n        let value = Bytes::from("example-value");\n\n        let result = header_map.try_append2(key.clone(), value.clone()).unwrap();\n        assert!(!result); // Should return false, as it was vacant\n        assert_eq!(header_map.get(key.clone()).unwrap(), &value);\n    }\n\n    #[test]\n    fn test_try_append2_occupied() {\n        let mut header_map = HeaderMap::new();\n        let key = HeaderName::from_static("example-header");\n        let value1 = Bytes::from("value1");\n        let value2 = Bytes::from("value2");\n\n        // Initial insertion\n        header_map.try_append2(key.clone(), value1.clone()).unwrap();\n        let result = header_map.try_append2(key.clone(), value2.clone()).unwrap();\n        \n        assert!(result); // Should return true, as it was occupied\n        let values = header_map.get_all(key.clone()).iter().collect::<Vec<_>>();\n        assert_eq!(values.len(), 2);\n        assert_eq!(values[0], &value1);\n        assert_eq!(values[1], &value2);\n    }\n\n    #[test]\n    fn test_try_append2_exceed_capacity() {\n        let mut header_map = HeaderMap::new();\n        let key = HeaderName::from_static("example-header");\n        for i in 0..MAX_SIZE {\n            let value = Bytes::from(format!("value{}", i));\n            assert!(header_map.try_append2(key.clone(), value).is_ok());\n        }\n\n        // Now it\'s at max capacity, next append should fail\n        let value_over_capacity = Bytes::from("this-should-fail");\n        let result = header_map.try_append2(key.clone(), value_over_capacity);\n        assert!(result.is_err()); // Should return an error\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581411, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=438, prompt_tokens=13856, total_tokens=14294, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmC7CcmdSyZOxU5FzU4d8lnA24hR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, CONTENT_TYPE};\n\n    #[test]\n    fn test_try_entry_valid_header_name() {\n        let mut header_map = HeaderMap::new();\n        header_map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let entry = header_map.try_entry(CONTENT_LENGTH).unwrap();\n        assert_eq!(entry.get(), "123");\n    }\n\n    #[test]\n    fn test_try_entry_invalid_header_name() {\n        let mut header_map = HeaderMap::new();\n        \n        let entry_result: Result<Entry<\'_, HeaderValue>, InvalidHeaderName> = header_map.try_entry("Invalid-Header");\n        assert!(entry_result.is_err());\n    }\n\n    #[test]\n    fn test_try_entry_exceeding_capacity() {\n        let mut header_map = HeaderMap::with_capacity(MAX_SIZE);\n\n        for i in 0..MAX_SIZE {\n            header_map.insert(CONTENT_TYPE, i.to_string().parse().unwrap());\n        }\n\n        let entry_result = header_map.try_entry(CONTENT_TYPE);\n        assert!(entry_result.is_err()); // Should return InvalidHeaderName due to capacity\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581423, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=250, prompt_tokens=16361, total_tokens=16611, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmCFjtBNOv6Mns6XiQEFYnNY1Omy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_TYPE};\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_entry2_inserts_entry() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        let key = HeaderName::from_static("test-header");\n        let result = map.try_entry2(key.clone());\n\n        assert!(result.is_ok());\n        let entry = result.unwrap();\n        assert!(entry.is_vacant());\n        entry.insert("test-value".to_string());\n\n        assert_eq!(map.get(key).unwrap(), "test-value");\n    }\n\n    #[test]\n    fn test_try_entry2_reserves_space() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        for i in 0..10 {\n            map.try_entry2(HeaderName::from_static(&format!("header-{}", i))).unwrap();\n        }\n\n        assert_eq!(map.len(), 10);\n    }\n\n    #[test]\n    fn test_try_entry2_max_size_reached() {\n        let mut map: HeaderMap<String> = HeaderMap::with_capacity(2);\n        map.try_entry2(HeaderName::from_static("header-1")).unwrap();\n        map.try_entry2(HeaderName::from_static("header-2")).unwrap();\n        \n        let result = map.try_entry2(HeaderName::from_static("header-3"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_entry2_inserts_into occupied_entry() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        let key = HeaderName::from_static("header");\n        map.insert(key.clone(), "initial-value".to_string());\n\n        let entry = map.try_entry2(key.clone()).unwrap();\n        entry.insert("new-value".to_string());\n\n        assert_eq!(map.get(key).unwrap(), "new-value");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581431, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=405, prompt_tokens=13838, total_tokens=14243, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmCROZ5E1D6ifbwYFqcmYUmyKxvW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::HeaderMap;\n    use crate::header::MAX_SIZE;\n\n    #[test]\n    fn test_try_grow_success() {\n        let mut header_map = HeaderMap::with_capacity(4);\n        header_map.insert("Header1", "Value1").unwrap();\n        header_map.insert("Header2", "Value2").unwrap();\n        \n        let result = header_map.try_grow(8);\n        assert!(result.is_ok());\n        assert!(header_map.capacity() >= 8);\n    }\n\n    #[test]\n    fn test_try_grow_exceeds_max_size() {\n        let mut header_map = HeaderMap::with_capacity(8);\n        header_map.insert("Header1", "Value1").unwrap();\n        header_map.insert("Header2", "Value2").unwrap();\n        \n        let result = header_map.try_grow(MAX_SIZE + 1);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_grow_with_no_entries() {\n        let mut header_map = HeaderMap::with_capacity(4);\n        let result = header_map.try_grow(8);\n        assert!(result.is_ok());\n        assert!(header_map.capacity() >= 8);\n    }\n\n    #[test]\n    fn test_try_grow_with_existing_data() {\n        let mut header_map = HeaderMap::with_capacity(4);\n        header_map.insert("Header1", "Value1").unwrap();\n        header_map.insert("Header2", "Value2").unwrap();\n        \n        header_map.try_grow(8).unwrap();\n        \n        assert_eq!(header_map.len(), 2);\n    }\n\n    #[test]\n    fn test_try_grow_no_empty_slots() {\n        let mut header_map = HeaderMap::with_capacity(4);\n        header_map.insert("Header1", "Value1").unwrap();\n        header_map.insert("Header2", "Value2").unwrap();\n        header_map.insert("Header3", "Value3").unwrap();\n        header_map.insert("Header4", "Value4").unwrap();\n\n        // Try to grow without empty slots\n        let result = header_map.try_grow(8);\n        assert!(result.is_ok());\n        assert!(header_map.capacity() >= 8);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581443, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=477, prompt_tokens=12812, total_tokens=13289, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmCdAsped48eXplwMngodgR1Z9yC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HOST, CONTENT_LENGTH};\n    \n    #[test]\n    fn test_try_insert_new_key() {\n        let mut map = HeaderMap::new();\n        let result = map.try_insert(HOST, "localhost".parse().unwrap()).unwrap();\n        assert!(result.is_none());\n        assert_eq!(map.get(HOST).unwrap(), &"localhost");\n    }\n    \n    #[test]\n    fn test_try_insert_existing_key() {\n        let mut map = HeaderMap::new();\n        map.try_insert(HOST, "example.com".parse().unwrap()).unwrap();\n        let previous_value = map.try_insert(HOST, "localhost".parse().unwrap()).unwrap().unwrap();\n        assert_eq!(previous_value, "example.com");\n        assert_eq!(map.get(HOST).unwrap(), &"localhost");\n    }\n    \n    #[test]\n    fn test_try_insert_over_capacity() {\n        let mut map = HeaderMap::try_with_capacity(1).unwrap();\n        map.try_insert(HOST, "localhost".parse().unwrap()).unwrap();\n        // Attempt to insert another entry, this should not exceed capacity\n        let result = map.try_insert(HOST, "example.com".parse().unwrap());\n        assert!(result.is_ok());\n    }\n    \n    #[test]\n    fn test_try_insert_none_key() {\n        let mut map = HeaderMap::new();\n        let result = map.try_insert("X-Custom-Header".parse().unwrap(), "value".parse().unwrap()).unwrap();\n        assert!(result.is_none());\n        assert_eq!(map.get("X-Custom-Header").unwrap(), &"value");\n    }\n    \n    #[test]\n    fn test_try_insert_with_invalid_key() {\n        let mut map = HeaderMap::new();\n        let result = map.try_insert("Invalid Header".parse().unwrap(), "value".parse().unwrap());\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581455, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=407, prompt_tokens=16361, total_tokens=16768, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmCoQuwkLXrhN8kyLrxVctLOFwma', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_TYPE};\n    use bytes::Bytes;\n    use std::hash::Hash;\n\n    #[test]\n    fn test_try_insert2_new_entry() {\n        let mut header_map = HeaderMap::new();\n        let key = HeaderName::from_static("content-type");\n        let value = Bytes::from_static(b"application/json");\n\n        let result = header_map.try_insert2(key.clone(), value.clone()).unwrap();\n\n        assert!(result.is_none());\n        assert_eq!(header_map.get(key).unwrap(), &value);\n    }\n\n    #[test]\n    fn test_try_insert2_existing_entry() {\n        let mut header_map = HeaderMap::new();\n        let key = HeaderName::from_static("content-type");\n        let value1 = Bytes::from_static(b"application/json");\n        let value2 = Bytes::from_static(b"application/xml");\n\n        header_map.try_insert2(key.clone(), value1.clone()).unwrap();\n        let result = header_map.try_insert2(key.clone(), value2.clone()).unwrap();\n\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), value1);\n        assert_eq!(header_map.get(key).unwrap(), &value2);\n    }\n\n    #[test]\n    fn test_try_insert2_max_size_reached() {\n        let mut header_map = HeaderMap::try_with_capacity(MAX_SIZE).unwrap();\n        \n        let key = HeaderName::from_static("content-type");\n        for i in 0..=MAX_SIZE {\n            let value = Bytes::from_static(format!("application/json-{}", i).as_bytes());\n            let result = header_map.try_insert2(key.clone(), value.clone()).unwrap();\n            if i < MAX_SIZE {\n                assert!(result.is_none());\n            } else {\n                assert!(result.is_err());\n            }\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581466, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=391, prompt_tokens=13846, total_tokens=14237, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmD2wLSla84f5HAvUqIM7DbcDl6g', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n    \n    #[test]\n    fn test_try_insert_entry_success() {\n        let mut header_map = HeaderMap::new();\n        let key = HeaderName::from_static("my-header");\n        let value = "my-value";\n\n        let hash = HashValue(123);\n        let result = header_map.try_insert_entry(hash, key, value);\n\n        assert!(result.is_ok());\n        assert_eq!(header_map.len(), 1);\n    }\n\n    #[test]\n    fn test_try_insert_entry_failure_max_size() {\n        let mut header_map = HeaderMap::with_capacity(1);\n        let key = HeaderName::from_static("header-1");\n        let value_1 = "value-1";\n        let value_2 = "value-2";\n\n        let hash = HashValue(123);\n        header_map.try_insert_entry(hash, key, value_1).unwrap();\n\n        let key_2 = HeaderName::from_static("header-2");\n        let result = header_map.try_insert_entry(hash, key_2, value_2);\n\n        assert!(result.is_err());\n        assert_eq!(header_map.len(), 1);\n    }\n\n    #[test]\n    fn test_try_insert_entry_with_collision() {\n        let mut header_map = HeaderMap::new();\n        let key_1 = HeaderName::from_static("header-1");\n        let key_2 = HeaderName::from_static("header-2");\n        let value_1 = "value-1";\n        let value_2 = "value-2";\n        \n        let hash_1 = HashValue(123);\n        let hash_2 = HashValue(123); // Intentional collision\n        \n        header_map.try_insert_entry(hash_1, key_1, value_1).unwrap();\n        header_map.try_insert_entry(hash_2, key_2, value_2).unwrap();\n\n        assert_eq!(header_map.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581480, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=423, prompt_tokens=16361, total_tokens=16784, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmDDDvh3vfuTBNqtmvFyykX5ypH8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName, CONTENT_LENGTH}; // Add necessary imports for HeaderMap and HeaderName\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_insert_phase_two() {\n        let mut map = HeaderMap::new();\n        let key = HeaderName::from_static("example-header");\n        let value = "example-value";\n        let hash = HashValue(42); \n        let probe = 0;\n        let danger = false;\n\n        // Insert an entry and expect it to succeed\n        let result = map.try_insert_phase_two(key.clone(), value, hash, probe, danger);\n        assert!(result.is_ok());\n        let index = result.unwrap();\n\n        // Verify that the entry is correctly inserted\n        assert_eq!(map.entries.len(), 1);\n        assert_eq!(map.entries[index].key, key);\n        assert_eq!(map.entries[index].value, value);\n        \n        // Test danger state change\n        let danger = true; // Change danger to true\n        let result = map.try_insert_phase_two(key.clone(), value, hash, probe, danger);\n        assert!(result.is_ok());\n        assert!(map.danger.is_yellow());\n\n        // Test insertion with an existing key\n        let another_value = "new-value";\n        let result = map.try_insert_phase_two(key.clone(), another_value, hash, probe, danger);\n        assert!(result.is_ok());\n        assert_eq!(map.entries[index].value, another_value); // Verify the value is updated\n    }\n\n    #[test]\n    fn test_try_insert_phase_two_with_max_size() {\n        let mut map = HeaderMap::with_capacity(1);\n        let key = HeaderName::from_static("header-1");\n        let value = "value-1";\n        let hash = HashValue(1);\n        let probe = 0;\n        let danger = false;\n\n        // Insert the first entry, should succeed\n        assert!(map.try_insert_phase_two(key.clone(), value, hash, probe, danger).is_ok());\n\n        // Insert the second entry, should also succeed, replacing the first\n        let key2 = HeaderName::from_static("header-2");\n        let value2 = "value-2";\n        assert!(map.try_insert_phase_two(key2.clone(), value2, hash, probe, danger).is_ok());\n\n        // Verify the map contains the second entry\n        assert_eq!(map.entries.len(), 2);\n        assert_eq!(map.entries[0].key, key2);\n        assert_eq!(map.entries[0].value, value2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581491, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=554, prompt_tokens=16361, total_tokens=16915, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmDTvO0wmJUzSiwnyBAUXOcikgOy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::HOST;\n\n    #[test]\n    fn test_try_reserve_success() {\n        let mut map = HeaderMap::new();\n        assert!(map.try_reserve(10).is_ok());\n        assert!(map.try_reserve(5).is_ok());\n    }\n\n    #[test]\n    fn test_try_reserve_overflow() {\n        let mut map = HeaderMap::new();\n        let capacity = usize::MAX; // Simulate an overflow\n        map.try_reserve(capacity);\n        assert!(map.try_reserve(capacity).is_err());\n    }\n\n    #[test]\n    fn test_try_reserve_empty() {\n        let mut map: HeaderMap<u32> = HeaderMap::new();\n        assert!(map.try_reserve(0).is_ok()); // Reserve zero should always succeed\n    }\n\n    #[test]\n    fn test_try_reserve_with_existing_headers() {\n        let mut map = HeaderMap::new();\n        let _ = map.try_insert(HOST, "localhost".parse().unwrap());\n        assert!(map.try_reserve(10).is_ok());\n    }\n\n    #[test]\n    fn test_try_reserve_exceed_max_size() {\n        let mut map = HeaderMap::new();\n        let maximum_reserve = 1; // Assuming this will exceed the max size\n        assert!(map.try_reserve(maximum_reserve).is_ok());\n        // Add logic here to exceed the max size to ensure it errors out\n        // This might depend on the specific implementation details\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581507, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=339, prompt_tokens=12914, total_tokens=13253, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmDgf0LBsyQt3D8lcx99tdvKagwd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::HOST;\n\n    #[test]\n    fn test_try_reserve_one_empty() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        assert_eq!(map.try_reserve_one(), Ok(()));\n        assert_eq!(map.capacity(), 8);\n    }\n\n    #[test]\n    fn test_try_reserve_one_non_empty() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        map.insert(HOST, "test.com".to_string());\n        assert_eq!(map.try_reserve_one(), Ok(()));\n        assert!(map.capacity() > 1);\n    }\n\n    #[test]\n    fn test_try_reserve_one_rebuild() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        for i in 0..16 {\n            map.insert(hyper::header::HeaderName::from_static("header"), i.to_string());\n        }\n        assert_eq!(map.try_reserve_one(), Ok(()));\n        assert!(map.capacity() > 16);\n    }\n\n    #[test]\n    fn test_try_reserve_one_exceeding_capacity() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        for _ in 0..usize::MAX {\n            let _ = map.insert(HOST, "test.com".to_string());\n        }\n        let result = map.try_reserve_one();\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581520, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=319, prompt_tokens=12789, total_tokens=13108, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmDrdmlMQl73GIMqmA3s85WPLlKE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{HeaderMap, MaxSizeReached};\n\n    #[test]\n    fn test_try_with_capacity_zero() {\n        let map: HeaderMap<u32> = HeaderMap::try_with_capacity(0).unwrap();\n        assert!(map.is_empty());\n        assert_eq!(0, map.capacity());\n    }\n\n    #[test]\n    fn test_try_with_capacity_positive() {\n        let map: HeaderMap<u32> = HeaderMap::try_with_capacity(10).unwrap();\n        assert!(map.is_empty());\n        assert!(map.capacity() >= 10); // capacity may be more than requested\n    }\n\n    #[test]\n    fn test_try_with_capacity_exceeds_max_size() {\n        let result = HeaderMap::<u32>::try_with_capacity(usize::MAX);\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap()._priv, ());\n    }\n\n    #[test]\n    fn test_try_with_capacity_large_value() {\n        let result = HeaderMap::<u32>::try_with_capacity(1_000_000);\n        assert!(result.is_ok());\n        let map = result.unwrap();\n        assert!(map.capacity() >= 1_000_000); // capacity may be more than requested\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581531, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=268, prompt_tokens=514, total_tokens=782, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmE0qATUjxFuO860dH0MwKBxNxJK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_TYPE};\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_value_iter_with_valid_index() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_TYPE, "application/json".parse().unwrap());\n        headers.append(CONTENT_TYPE, "application/xml".parse().unwrap());\n\n        let mut iter = headers.value_iter(Some(0));\n        assert_eq!(iter.next(), Some(&"application/json"));\n        assert_eq!(iter.next(), Some(&"application/xml"));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_value_iter_with_empty_map() {\n        let headers: HeaderMap = HeaderMap::new();\n        let iter = headers.value_iter(Some(0));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_value_iter_with_invalid_index() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_TYPE, "text/plain".parse().unwrap());\n\n        let iter = headers.value_iter(Some(1));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_value_iter_with_none_index() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_TYPE, "text/html".parse().unwrap());\n        headers.append(CONTENT_TYPE, "text/css".parse().unwrap());\n\n        let iter = headers.value_iter(None);\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_value_iter_back() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_TYPE, "text/plain".parse().unwrap());\n        headers.append(CONTENT_TYPE, "text/html".parse().unwrap());\n\n        let mut iter = headers.value_iter(Some(0));\n        assert_eq!(iter.next_back(), Some(&"text/html"));\n        assert_eq!(iter.next_back(), Some(&"text/plain"));\n        assert_eq!(iter.next_back(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581540, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=434, prompt_tokens=13302, total_tokens=13736, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEARwp5tHv65aCEdBnDKXdMS22x', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{HeaderMap, header::{CONTENT_LENGTH, HOST}};\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_value_iter_mut() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        map.insert(HOST, "example.com".to_string());\n        map.append(HOST, "example.org".to_string());\n        map.append(CONTENT_LENGTH, "123".to_string());\n\n        let mut iter = map.value_iter_mut(0); // Should start iterating from HOST entry\n\n        assert_eq!(iter.next(), Some(&mut "example.com".to_string()));\n        assert_eq!(iter.next(), Some(&mut "example.org".to_string()));\n        assert!(iter.next().is_none()); // No more values for HOST\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_value_iter_mut_panic_out_of_bounds() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        map.insert(HOST, "example.com".to_string());\n\n        let _iter = map.value_iter_mut(1); // Index 1 does not exist\n    }\n\n    #[test]\n    fn test_value_iter_mut_multiple_values() {\n        let mut map: HeaderMap<String> = HeaderMap::new();\n        map.insert(HOST, "example.com".to_string());\n        map.append(HOST, "example.org".to_string());\n        map.append(HOST, "example.net".to_string());\n\n        let mut iter = map.value_iter_mut(0); // First position for HOST entry\n\n        assert_eq!(iter.next(), Some(&mut "example.com".to_string()));\n        assert_eq!(iter.next(), Some(&mut "example.org".to_string()));\n        assert_eq!(iter.next(), Some(&mut "example.net".to_string()));\n        assert!(iter.next().is_none()); // No more values for HOST\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581550, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=408, prompt_tokens=13283, total_tokens=13691, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEMyGwVXAlDFDgOpus8feTnSJrX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn test_values() {\n        let mut map = HeaderMap::new();\n\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.insert(HOST, "hello.world".parse().unwrap());\n        map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n\n        let values: Vec<_> = map.values().collect();\n        assert_eq!(values.len(), 3);\n        assert!(values.contains(&&"example.com".parse::<HeaderValue>().unwrap()));\n        assert!(values.contains(&&"hello.world".parse::<HeaderValue>().unwrap()));\n        assert!(values.contains(&&"123".parse::<HeaderValue>().unwrap()));\n    }\n\n    #[test]\n    fn test_values_with_duplicates() {\n        let mut map = HeaderMap::new();\n\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.append(HOST, "example.com".parse().unwrap());\n\n        let values: Vec<_> = map.values().collect();\n        assert_eq!(values.len(), 3); // 2 for HOST + 1 for CONTENT_LENGTH\n        assert!(values.contains(&&"example.com".parse::<HeaderValue>().unwrap()));\n        assert_eq!(values.iter().filter(|&&v| v == "example.com").count(), 2);\n    }\n\n    #[test]\n    fn test_empty_values() {\n        let map: HeaderMap = HeaderMap::new();\n        let values: Vec<_> = map.values().collect();\n        assert!(values.is_empty());\n    }\n\n    #[test]\n    fn test_values_after_clearing() {\n        let mut map = HeaderMap::new();\n\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.clear();\n\n        let values: Vec<_> = map.values().collect();\n        assert!(values.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581562, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=405, prompt_tokens=13365, total_tokens=13770, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEXao7RLaaupOJXqqumjwgwFzb7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HOST};\n\n    #[test]\n    fn test_values_mut() {\n        let mut map = HeaderMap::default();\n\n        map.insert(HOST, "hello".to_string());\n        map.append(HOST, "goodbye".to_string());\n        map.insert(CONTENT_LENGTH, "123".to_string());\n\n        for value in map.values_mut() {\n            value.push_str("-boop");\n        }\n\n        assert_eq!(map.get(HOST).unwrap(), "hello-boop");\n        assert_eq!(map.get_all(HOST).iter().count(), 2); // HOST should have 2 values\n        assert_eq!(map.get_all(HOST).iter().last().unwrap(), &"goodbye-boop");\n        assert_eq!(map.get(CONTENT_LENGTH).unwrap(), "123-boop");\n    }\n\n    #[test]\n    fn test_values_mut_empty() {\n        let mut map: HeaderMap<String> = HeaderMap::default();\n        let values: Vec<&mut String> = map.values_mut().collect();\n        assert_eq!(values.len(), 0); // should be empty\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581573, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=250, prompt_tokens=13490, total_tokens=13740, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEgH2W4Z7wXLNzQRj6QDQHh074k', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n\n    #[test]\n    #[should_panic(expected = "size overflows MAX_SIZE")]\n    fn test_with_capacity_panic_exceeding_max_capacity() {\n        let _ = HeaderMap::<u32>::with_capacity(MAX_SIZE + 1);\n    }\n\n    #[test]\n    fn test_with_capacity() {\n        let map: HeaderMap<u32> = HeaderMap::with_capacity(10);\n        assert!(map.is_empty());\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let map: HeaderMap<u32> = HeaderMap::with_capacity(0);\n        assert!(map.is_empty());\n        assert_eq!(map.capacity(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581582, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=172, prompt_tokens=12702, total_tokens=12874, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEmrxI7CuwEBFi7OkMPjpbib2FH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n\n    #[test]\n    fn test_header_map_new() {\n        let map = HeaderMap::new();\n        assert!(map.is_empty());\n        assert_eq!(0, map.capacity());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581588, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=62, prompt_tokens=12607, total_tokens=12669, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEsYMsCTaXpj5IpciQr7VNpxIWk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n    use http::HeaderMap;\n\n    #[test]\n    fn test_next_unsafe() {\n        let mut headers = HeaderMap::new();\n        headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        headers.insert(CONTENT_LENGTH, "456".parse().unwrap());\n        \n        let mut iter = headers.iter_mut();\n\n        // The first call should yield the first key-value pair\n        let (key, ptr) = iter.next_unsafe().unwrap();\n        assert_eq!(key, &CONTENT_LENGTH);\n        assert_eq!(unsafe { *ptr }, "123");\n        \n        // The second call should yield the second key-value pair\n        let (key, ptr) = iter.next_unsafe().unwrap();\n        assert_eq!(key, &CONTENT_LENGTH);\n        assert_eq!(unsafe { *ptr }, "456");\n\n        // At this point, there are no more items\n        assert!(iter.next_unsafe().is_none());\n    }\n\n    #[test]\n    fn test_next_unsafe_empty() {\n        let mut headers = HeaderMap::new();\n        let mut iter = headers.iter_mut();\n\n        // Should return None immediately as the HeaderMap is empty\n        assert!(iter.next_unsafe().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581594, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=281, prompt_tokens=13377, total_tokens=13658, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmF4RZQB9hKc2N9S1DunDdqF0EFA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::error::Error;\n\n    #[test]\n    fn test_max_size_reached_new() {\n        let error = MaxSizeReached::new();\n        assert_eq!(format!("{}", error), "max size reached");\n        assert_eq!(format!("{:?}", error), "MaxSizeReached");\n        assert!(error.source().is_none()); // MaxSizeReached has no source error\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581606, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=96, prompt_tokens=359, total_tokens=455, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmF9P7zQlKemSPybVDL4dtSvXpcE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HOST};\n\n    #[test]\n    fn test_append() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "world".parse().unwrap());\n\n        if let Entry::Occupied(mut e) = map.entry("host") {\n            e.append("earth".parse().unwrap());\n        }\n\n        let values = map.get_all("host");\n        let mut iter = values.iter();\n        assert_eq!("world", *iter.next().unwrap());\n        assert_eq!("earth", *iter.next().unwrap());\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_append_multiple() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "foo".parse().unwrap());\n        map.append(HOST, "bar".parse().unwrap());\n        map.append(HOST, "baz".parse().unwrap());\n\n        let values = map.get_all("host");\n        let mut iter = values.iter();\n        assert_eq!("foo", *iter.next().unwrap());\n        assert_eq!("bar", *iter.next().unwrap());\n        assert_eq!("baz", *iter.next().unwrap());\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_append_to_nonexistent_key() {\n        let mut map = HeaderMap::new();\n        let result = map.append(HOST, "new".parse().unwrap());\n        assert_eq!(result, false); // append returns false if there\'s no existing key\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581611, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=326, prompt_tokens=15281, total_tokens=15607, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmFPEW0PIg4epNQsMKHVAXcNDczl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HOST};\n\n    #[test]\n    #[should_panic(expected = "index out of bounds")]\n    fn test_get_panics_on_empty() {\n        let map: HeaderMap<String> = HeaderMap::new();\n        let entry = map.entry(HOST).or_insert("default_value".to_string());\n        let _ = entry.get(); // This should panic since the entry is empty\n    }\n\n    #[test]\n    fn test_get_success() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        let entry = map.entry("host").or_insert("default_value".to_string());\n        assert_eq!(entry.get(), &"example.com");\n    }\n\n    #[test]\n    fn test_get_after_append() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        {\n            let mut entry = map.entry("host").or_insert("default_value".to_string());\n            entry.append("example.org".parse().unwrap());\n            assert_eq!(entry.get(), &"example.com");\n        }\n    }\n\n    #[test]\n    fn test_get_mut() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        {\n            let mut entry = map.entry("host").or_insert("default_value".to_string());\n            entry.get_mut().push_str("!");\n            assert_eq!(entry.get(), &"example.com!");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581627, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=337, prompt_tokens=15247, total_tokens=15584, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmFY4hSt1Uki4RLs9h0QzguI94Gq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import everything from the current module\n    use http::header::{HeaderMap, HOST};\n\n    #[test]\n    fn test_get_mut_when_exists() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "hello.world".to_string());\n\n        if let Entry::Occupied(mut entry) = map.entry(HOST) {\n            entry.get_mut().push_str("-test");\n            assert_eq!(entry.get(), &"hello.world-test");\n        } else {\n            panic!("Expected entry to be occupied.");\n        }\n    }\n\n    #[test]\n    fn test_get_mut_panics_when_not_exists() {\n        let mut map = HeaderMap::new();\n        let result = std::panic::catch_unwind(|| {\n            if let Entry::Occupied(mut entry) = map.entry(HOST) {\n                entry.get_mut();\n            }\n        });\n        assert!(result.is_err(), "Expected panic when accessing get_mut on a vacant entry.");\n    }\n\n    #[test]\n    fn test_get_mut_multiple_insertions() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "hello".to_string());\n        map.insert(HOST, "world".to_string());\n\n        if let Entry::Occupied(mut entry) = map.entry(HOST) {\n            entry.get_mut().push_str("!");\n            assert_eq!(entry.get(), &"world!");\n        } else {\n            panic!("Expected entry to be occupied.");\n        }\n    }\n\n    #[test]\n    fn test_get_mut_without_panic() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "test".to_string());\n\n        // Ensure we can get_mut and modify\n        if let Entry::Occupied(mut entry) = map.entry(HOST) {\n            let value = entry.get_mut();\n            assert_eq!(value, &mut "test");\n            value.push_str(" modified");\n        }\n\n        assert_eq!(map.get(HOST), Some(&"test modified".to_string()));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581636, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=424, prompt_tokens=15241, total_tokens=15665, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmFkdUMx6yNuvzaycspCLRVybOlt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName, HOST};\n\n    #[test]\n    fn test_insert_new_entry() {\n        let mut map = HeaderMap::new();\n        let prev_value = map.insert(HOST, "example.com".parse().unwrap());\n        assert!(prev_value.is_none());\n        assert_eq!(map[HOST], "example.com");\n    }\n\n    #[test]\n    fn test_insert_existing_entry() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        let prev_value = map.insert(HOST, "new.domain.com".parse().unwrap());\n        assert_eq!(prev_value.unwrap(), "example.com");\n        assert_eq!(map[HOST], "new.domain.com");\n    }\n\n    #[test]\n    fn test_insert_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.insert(HOST, "new.domain.com".parse().unwrap());\n        assert_eq!(map[HOST], "new.domain.com");\n        assert_eq!(map.len(), 1); // Only the latest value should count\n    }\n\n    #[test]\n    fn test_insert_with_different_keys() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.insert(HeaderName::from_static("User-Agent"), "my-agent".parse().unwrap());\n        assert_eq!(map[HOST], "example.com");\n        assert_eq!(map["User-Agent"], "my-agent");\n        assert_eq!(map.len(), 2); // Two distinct keys\n    }\n\n    #[test]\n    fn test_insert_invalid_key() {\n        let mut map = HeaderMap::new();\n        let key = "invalid_key";\n        let prev_value = map.insert(key.parse().unwrap(), "some_value".parse().unwrap());\n        assert!(prev_value.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581648, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=418, prompt_tokens=15248, total_tokens=15666, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmFwPrvs8wuFl4MDP08jVPdJPO0a', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HOST, HeaderValue};\n\n    #[test]\n    fn test_insert_mult() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, HeaderValue::from_static("world"));\n        map.append(HOST, HeaderValue::from_static("world2"));\n\n        if let Entry::Occupied(mut e) = map.entry("host") {\n            let mut prev = e.insert_mult(HeaderValue::from_static("earth"));\n            assert_eq!("world", prev.next().unwrap());\n            assert_eq!("world2", prev.next().unwrap());\n            assert!(prev.next().is_none());\n        }\n\n        assert_eq!(HeaderValue::from_static("earth"), map[HOST]);\n    }\n\n    #[test]\n    fn test_insert_mult_empty() {\n        let mut map = HeaderMap::new();\n        if let Entry::Occupied(mut e) = map.entry("host") {\n            let mut prev = e.insert_mult(HeaderValue::from_static("earth"));\n            assert!(prev.next().is_none());\n        }\n        assert_eq!(HeaderValue::from_static("earth"), map[HOST]);\n    }\n\n    #[test]\n    fn test_insert_mult_multiple_insertions() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, HeaderValue::from_static("one"));\n        map.append(HOST, HeaderValue::from_static("two"));\n        map.append(HOST, HeaderValue::from_static("three"));\n\n        if let Entry::Occupied(mut e) = map.entry("host") {\n            let mut prev = e.insert_mult(HeaderValue::from_static("four"));\n            assert_eq!("one", prev.next().unwrap());\n            assert_eq!("two", prev.next().unwrap());\n            assert_eq!("three", prev.next().unwrap());\n            assert!(prev.next().is_none());\n        }\n\n        assert_eq!(HeaderValue::from_static("four"), map[HOST]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581660, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=407, prompt_tokens=15727, total_tokens=16134, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmGAx1wbu8kkEKtAaY263c2Pii0E', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HOST};\n\n    #[test]\n    #[should_panic(expected = "attempt to access value of empty entry")]\n    fn test_into_mut_panics_on_empty_entry() {\n        let mut map = HeaderMap::new();\n        let entry = map.entry("host");\n        if let Entry::Occupied(e) = entry {\n            e.into_mut();\n        }\n    }\n\n    #[test]\n    fn test_into_mut_updates_value() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "hello.world".to_string());\n        map.append(HOST, "hello.earth".to_string());\n\n        if let Entry::Occupied(mut e) = map.entry("host") {\n            e.into_mut().push_str("-updated");\n        }\n\n        assert_eq!(map[HOST], "hello.world-updated");\n    }\n\n    #[test]\n    fn test_into_mut_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".to_string());\n        map.append(HOST, "test.com".to_string());\n\n        if let Entry::Occupied(mut e) = map.entry("host") {\n            let mut value = e.into_mut();\n            value.push_str("?updated");\n        }\n\n        assert_eq!(map[HOST], "example.com-updated");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581674, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=291, prompt_tokens=15263, total_tokens=15554, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmGKVXp2KTxTVv28ZWKpok4hbeN6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HOST};\n\n    #[test]\n    fn test_iter() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "world".parse().unwrap());\n        map.append(HOST, "earth".parse().unwrap());\n\n        if let Entry::Occupied(e) = map.entry("host") {\n            let mut iter = e.iter();\n            assert_eq!(iter.next().unwrap(), &"world");\n            assert_eq!(iter.next().unwrap(), &"earth");\n            assert!(iter.next().is_none());\n        } else {\n            panic!("Expected an occupied entry");\n        }\n    }\n\n    #[test]\n    fn test_iter_empty() {\n        let mut map = HeaderMap::new();\n\n        if let Entry::Occupied(e) = map.entry("host") {\n            assert!(e.iter().next().is_none());\n        } else {\n            panic!("Expected an occupied entry");\n        }\n    }\n\n    #[test]\n    fn test_iter_multiple_values() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "one".parse().unwrap());\n        map.append(HOST, "two".parse().unwrap());\n        map.append(HOST, "three".parse().unwrap());\n\n        if let Entry::Occupied(e) = map.entry("host") {\n            let mut iter = e.iter();\n            assert_eq!(iter.next().unwrap(), &"one");\n            assert_eq!(iter.next().unwrap(), &"two");\n            assert_eq!(iter.next().unwrap(), &"three");\n            assert!(iter.next().is_none());\n        } else {\n            panic!("Expected an occupied entry");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581684, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=358, prompt_tokens=15896, total_tokens=16254, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmGVbfNNr5lL1xieWKPKg0s9cOcD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, Entry, HOST};\n\n    #[test]\n    fn test_iter_mut() {\n        let mut map = HeaderMap::default();\n        map.insert(HOST, "world".to_string());\n        map.append(HOST, "earth".to_string());\n\n        if let Entry::Occupied(mut entry) = map.entry("host") {\n            for value in entry.iter_mut() {\n                value.push_str("-boop");\n            }\n        }\n\n        let values = map.get_all("host");\n        let mut iter = values.iter();\n        assert_eq!(&"world-boop", iter.next().unwrap());\n        assert_eq!(&"earth-boop", iter.next().unwrap());\n        assert!(iter.next().is_none());\n    }\n    \n    #[test]\n    fn test_iter_mut_empty() {\n        let mut map = HeaderMap::default();\n        assert!(map.is_empty());\n\n        if let Entry::Occupied(entry) = map.entry("host") {\n            let mut iter = entry.iter_mut();\n            assert!(iter.next().is_none());\n        }\n    }\n    \n    #[test]\n    fn test_iter_mut_multiple_appends() {\n        let mut map = HeaderMap::default();\n        map.insert(HOST, "world".to_string());\n        map.append(HOST, "earth".to_string());\n        map.append(HOST, "mars".to_string());\n\n        if let Entry::Occupied(mut entry) = map.entry("host") {\n            for value in entry.iter_mut() {\n                value.push_str("-boop");\n            }\n        }\n\n        let values = map.get_all("host");\n        let mut iter = values.iter();\n        assert_eq!(&"world-boop", iter.next().unwrap());\n        assert_eq!(&"earth-boop", iter.next().unwrap());\n        assert_eq!(&"mars-boop", iter.next().unwrap());\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581695, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=409, prompt_tokens=15938, total_tokens=16347, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmGnJ5UPEIHED2XwLJKmSRsT4fyE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HOST};\n\n    #[test]\n    fn test_key() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n\n        if let Entry::Occupied(e) = map.entry("host") {\n            assert_eq!(e.key().as_str(), "host");\n        } else {\n            panic!("Expected an occupied entry for the key \'host\'");\n        }\n    }\n\n    #[test]\n    fn test_key_on_empty_entry() {\n        let mut map = HeaderMap::new();\n        if let Entry::Vacant(_) = map.entry("host") {\n            // expected to be empty\n        } else {\n            panic!("Expected a vacant entry for the key \'host\'");\n        }\n    }\n\n    #[test]\n    fn test_key_after_insert() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "localhost".parse().unwrap());\n        let entry = map.entry("host");\n\n        if let Entry::Occupied(e) = entry {\n            assert_eq!(e.key().as_str(), "host");\n        } else {\n            panic!("Expected an occupied entry after insertion");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581713, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=262, prompt_tokens=16361, total_tokens=16623, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmGvSinE67KHQeBobwn73mTPoTgJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HOST};\n\n    #[test]\n    fn test_remove_entry() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n\n        if let Entry::Occupied(entry) = map.entry(HOST) {\n            let removed_value = entry.remove();\n            assert_eq!(removed_value, "example.com");\n            assert!(!map.contains_key(HOST));\n        }\n    }\n\n    #[test]\n    fn test_remove_nonexistent_key() {\n        let mut map = HeaderMap::new();\n        assert!(map.remove(HOST).is_none());\n    }\n\n    #[test]\n    fn test_remove_multiple_entries() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n        map.append(HOST, "example.net".parse().unwrap());\n\n        if let Entry::Occupied(entry) = map.entry(HOST) {\n            let removed_value = entry.remove();\n            assert_eq!(removed_value, "example.com");\n            assert!(map.contains_key(HOST));\n        }\n\n        if let Entry::Occupied(entry) = map.entry(HOST) {\n            let removed_value = entry.remove();\n            assert_eq!(removed_value, "example.net");\n            assert!(!map.contains_key(HOST));\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581721, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=289, prompt_tokens=15229, total_tokens=15518, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmH8x4bt6liWwAHs5iUS75j14n51', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HOST};\n\n    #[test]\n    fn test_remove_entry() {\n        let mut map = HeaderMap::new();\n        map.insert(HOST, "example.com".parse().unwrap());\n\n        if let Entry::Occupied(e) = map.entry("host") {\n            let (key, prev) = e.remove_entry();\n            assert_eq!("host", key.as_str());\n            assert_eq!("example.com", prev);\n        }\n\n        assert!(!map.contains_key("host"));\n    }\n\n    #[test]\n    fn test_remove_entry_empty_map() {\n        let mut map = HeaderMap::new();\n        assert!(map.get("host").is_none());\n\n        let result = map.remove(HOST);\n        assert!(result.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581734, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=174, prompt_tokens=16361, total_tokens=16535, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHEShzBZhLg0pxYwR2WAIdaRNlR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName, CONTENT_TYPE};\n    use http::header::InvalidHeaderName;\n\n    #[test]\n    fn test_remove_entry_mult() {\n        let mut map = HeaderMap::new();\n\n        // Insert multiple values for the same key\n        map.insert(CONTENT_TYPE, "text/plain".parse().unwrap());\n        map.append(CONTENT_TYPE, "text/html".parse().unwrap());\n        map.append(CONTENT_TYPE, "application/json".parse().unwrap());\n        \n        // Get an occupied entry\n        let entry = map.entry(CONTENT_TYPE).unwrap();\n\n        // Remove the entry and capture the values\n        let (key, mut values_drain) = entry.remove_entry_mult();\n\n        // Verify the correct key is returned\n        assert_eq!(key, HeaderName::from_str("content-type").unwrap());\n        \n        // Verify the values drained\n        let values: Vec<_> = values_drain.collect();\n        assert_eq!(values, vec!["text/plain".parse().unwrap(), "text/html".parse().unwrap(), "application/json".parse().unwrap()]);\n\n        // Verify the map is empty afterwards\n        assert!(!map.contains_key(CONTENT_TYPE));\n    }\n\n    #[test]\n    fn test_remove_entry_mult_empty() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_TYPE, "text/plain".parse().unwrap());\n\n        let entry = map.entry(CONTENT_TYPE).unwrap();\n\n        // Remove the entry and capture the values\n        let (key, values_drain) = entry.remove_entry_mult();\n\n        // Verify the key is correct\n        assert_eq!(key, HeaderName::from_str("content-type").unwrap());\n\n        // Verify the drained value\n        let values: Vec<_> = values_drain.collect();\n        assert_eq!(values, vec!["text/plain".parse().unwrap()]);\n\n        // Verify the map is empty afterwards\n        assert!(!map.contains_key(CONTENT_TYPE));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581740, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=433, prompt_tokens=16361, total_tokens=16794, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHQoK3PjhffyBIdItJQCrJjllwb', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{Pos, HashValue};\n\n    #[test]\n    fn test_pos_is_none() {\n        let pos_none = Pos::none();\n        assert!(pos_none.is_none());\n\n        let pos_some = Pos::new(1, HashValue(123));\n        assert!(!pos_some.is_none());\n\n        let pos_another_some = Pos::new(0, HashValue(456));\n        assert!(!pos_another_some.is_none());\n\n        let pos_edge_none = Pos::new(!0 as usize, HashValue(789));\n        assert!(pos_edge_none.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581752, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=142, prompt_tokens=584, total_tokens=726, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHYLPFKdPMXSAET7DQ5KJNLQf0Z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{HashValue, Pos};\n\n    #[test]\n    fn test_pos_is_some() {\n        let hash_value = HashValue(1);\n        let pos = Pos::new(0, hash_value);\n        assert!(pos.is_some());\n\n        let none_pos = Pos::none();\n        assert!(!none_pos.is_some());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581760, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=91, prompt_tokens=583, total_tokens=674, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHcUdCUJINDsCv5TTuT46VLrETm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{HashValue, Pos};\n\n    #[test]\n    fn test_pos_new() {\n        let hash_value = HashValue(123);\n        let index = 5;\n\n        let pos = Pos::new(index, hash_value);\n        \n        assert_eq!(pos.index, index as Size);\n        assert_eq!(pos.hash, hash_value);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_pos_new_out_of_bounds() {\n        let hash_value = HashValue(123);\n        \n        // This index should trigger a debug assertion failure\n        let _ = Pos::new(MAX_SIZE, hash_value);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581764, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=150, prompt_tokens=604, total_tokens=754, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHkBBR1scE0QZHHUjL3HZ4eov1p', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pos_none() {\n        let pos = Pos::none();\n        assert_eq!(pos.index, !0);\n        assert_eq!(pos.hash, HashValue(0));\n        assert!(pos.is_none());\n        assert!(!pos.is_some());\n        assert_eq!(pos.resolve(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581772, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=83, prompt_tokens=591, total_tokens=674, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHnXcfaPdx8EJKs4gaG6GkBh8VQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use header::map::{HashValue, Pos};\n\n    #[test]\n    fn test_resolve_some() {\n        let hash_value = HashValue(42);\n        let pos = Pos::new(10, hash_value);\n        assert_eq!(pos.resolve(), Some((10, hash_value)));\n    }\n\n    #[test]\n    fn test_resolve_none() {\n        let pos = Pos::none();\n        assert_eq!(pos.resolve(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581775, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=109, prompt_tokens=607, total_tokens=716, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHsPXNyzKvtnYWt8vkqsZZ7ibP4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName, CONTENT_TYPE};\n\n    #[test]\n    fn test_insert_into_vacant_entry() {\n        let mut map = HeaderMap::new();\n        let key = HeaderName::from_static("x-hello");\n        \n        // Insert value into vacant entry\n        if let Entry::Vacant(vacant) = map.entry(key.clone()) {\n            let value = "world".parse().unwrap();\n            let inserted_value = vacant.insert(value);\n            assert_eq!(inserted_value, &mut map[key]);\n            assert_eq!(map[key], "world");\n        } else {\n            panic!("Expected VacantEntry");\n        }\n    }\n\n    #[test]\n    fn test_insert_overwrite_previous_value() {\n        let mut map = HeaderMap::new();\n        map.insert(CONTENT_TYPE, "text/plain".parse().unwrap());\n        assert_eq!(map[CONTENT_TYPE], "text/plain");\n        \n        // Insert new value into existing key\n        let old_value = map.insert(CONTENT_TYPE, "application/json".parse().unwrap()).unwrap();\n        assert_eq!(old_value, "text/plain");\n        assert_eq!(map[CONTENT_TYPE], "application/json");\n    }\n\n    #[test]\n    fn test_insert_with_exceeding_capacity() {\n        let mut map = HeaderMap::new();\n        \n        // Simulating a case where adding too many entries could cause overflow\n        for i in 0..(MAX_SIZE + 1) {\n            let key = HeaderName::from_static(&format!("x-header-{}", i));\n            let value = "test".parse().unwrap();\n            if let Err(_) = map.try_insert(key, value) {\n                assert!(true); // Expect an overflow error on the last insert\n                break;\n            }\n        }\n    }\n\n    #[test]\n    fn test_insert_return_mutable_reference() {\n        let mut map = HeaderMap::new();\n        if let Entry::Vacant(vacant) = map.entry("x-accepted") {\n            let inserted_ref = vacant.insert("value".parse().unwrap());\n            *inserted_ref = "new_value".parse().unwrap();\n        }\n\n        assert_eq!(map["x-accepted"], "new_value");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581780, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=480, prompt_tokens=16361, total_tokens=16841, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmI7VhUsxAtoN0zv2av32KNE4ECC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderMap;\n\n    #[test]\n    fn test_insert_entry() {\n        let mut map = HeaderMap::new();\n        \n        if let Entry::Vacant(v) = map.try_entry("x-hello").unwrap() {\n            let mut e = v.try_insert_entry("world".parse().unwrap()).unwrap();\n            e.insert("world2".parse().unwrap());\n        }\n\n        assert_eq!(map["x-hello"], "world2");\n    }\n\n    #[test]\n    fn test_insert_entry_with_existing_key() {\n        let mut map = HeaderMap::new();\n        \n        if let Entry::Vacant(v) = map.try_entry("x-hello").unwrap() {\n            v.try_insert_entry("world".parse().unwrap()).unwrap();\n        }\n\n        if let Entry::Vacant(v) = map.try_entry("x-hello").unwrap() {\n            let mut e = v.try_insert_entry("new_world".parse().unwrap()).unwrap();\n            e.insert("final_world".parse().unwrap());\n        }\n\n        assert_eq!(map["x-hello"], "final_world");\n    }\n\n    #[test]\n    fn test_insert_entry_panic_on_overflow() {\n        let mut map = HeaderMap::with_capacity(1);\n        \n        let mut e = {\n            if let Entry::Vacant(v) = map.try_entry("x-hello").unwrap() {\n                v.try_insert_entry("world".parse().unwrap()).unwrap()\n            } else {\n                panic!("Could not create vacant entry");\n            }\n        };\n\n        assert!(std::panic::catch_unwind(|| {\n            e.insert("world2".parse().unwrap());\n        }).is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581795, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=364, prompt_tokens=16361, total_tokens=16725, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmIOSEaLZI7Cog7qwi5BY5lj93jM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming you\'re in the http::header::map module\n    use http::header::{HeaderMap, HeaderName};\n\n    #[test]\n    fn test_into_key() {\n        let mut map = HeaderMap::new();\n\n        if let Entry::Vacant(v) = map.entry("x-hello") {\n            assert_eq!(v.into_key().as_str(), "x-hello");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581812, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=100, prompt_tokens=16361, total_tokens=16461, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmIUnXWzEb3qDAr93Sq2g7DYQWun', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::HeaderMap;\n    use http::header::HeaderName;\n\n    #[test]\n    fn test_vacant_entry_key() {\n        let mut map = HeaderMap::new();\n        let name = "x-hello";\n        \n        if let Entry::Vacant(vacant_entry) = map.entry(name) {\n            assert_eq!(vacant_entry.key().as_str(), name);\n        } else {\n            panic!("Expected a VacantEntry");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581818, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=115, prompt_tokens=16361, total_tokens=16476, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmImXYWrAL1Ov2zBPc7vlCrQ2GMF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderMap, HeaderName, CONTENT_TYPE, CONTENT_LENGTH};\n    use std::str::FromStr;\n\n    #[test]\n    fn test_try_insert_new_entry() {\n        let mut map = HeaderMap::new();\n        let key = HeaderName::from_str("x-hello").unwrap();\n        let result = map.entry(key.clone()).unwrap().insert("world".parse().unwrap());\n\n        assert_eq!(result, "world");\n        assert_eq!(map[key], "world");\n    }\n\n    #[test]\n    fn test_try_insert_existing_entry() {\n        let mut map = HeaderMap::new();\n        let key = HeaderName::from_str("x-hello").unwrap();\n        map.insert(key.clone(), "world".parse().unwrap());\n\n        let result = map.entry(key.clone()).unwrap().insert("earth".parse().unwrap());\n\n        assert_eq!(result, "world");\n        assert_eq!(map[key], "earth");\n    }\n\n    #[test]\n    fn test_try_insert_full_map() {\n        let mut map = HeaderMap::new();\n        let key1 = HeaderName::from_str("x-hello").unwrap();\n        let key2 = HeaderName::from_str("x-world").unwrap();\n\n        map.insert(key1.clone(), "world".parse().unwrap());\n\n        // Fill the map to its capacity if needed\n        for i in 1..=10 {\n            map.insert(key2.clone(), format!("value{}", i).parse().unwrap());\n        }\n\n        let result = map.entry(key1).unwrap().try_insert("new".parse().unwrap());\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_insert_key_value() {\n        let mut map = HeaderMap::new();\n        let key = HeaderName::from_str("x-hello").unwrap();\n\n        let result = map.entry(key.clone()).unwrap().try_insert("world".parse().unwrap());\n\n        assert!(result.is_ok());\n        assert_eq!(map[key], "world");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581836, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=431, prompt_tokens=16361, total_tokens=16792, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJ0JgIZG6aHZac8Ny4rxO5msCsQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::*;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_try_insert_entry() {\n        let mut map = HeaderMap::new();\n\n        // Test initial insertion\n        let key = HeaderName::from_str("x-hello").unwrap();\n        let value = "world".parse().unwrap();\n\n        if let Entry::Vacant(v) = map.try_entry(key.clone()).unwrap() {\n            let entry = v.try_insert_entry(value.clone()).unwrap();\n            assert_eq!(map[key], value);\n            assert_eq!(entry.key(), &key);\n        }\n\n        // Test overwriting previous value\n        let new_value = "new_world".parse().unwrap();\n        if let Entry::Occupied(mut e) = map.try_entry(key.clone()).unwrap() {\n            e.insert(new_value.clone());\n        }\n\n        // Verify the change\n        assert_eq!(map[key], new_value);\n    }\n\n    #[test]\n    fn test_try_insert_entry_max_size_reached() {\n        // Configure your HeaderMap to reach the max size if needed (assuming there\'s a pre-set max)\n        let mut map = HeaderMap::new();\n        let key = HeaderName::from_str("x-full").unwrap();\n\n        // Fill the map to max size\n        for i in 0..MAX_HEADER_COUNT {\n            let value = format!("value{}", i).parse().unwrap();\n            if let Entry::Vacant(v) = map.try_entry(key.clone()).unwrap() {\n                v.try_insert_entry(value).unwrap();\n            }\n        }\n\n        // Attempting to insert another entry should fail\n        let new_value = "overflow".parse().unwrap();\n        let entry_result = map.try_entry(key).unwrap().try_insert_entry(new_value);\n        assert!(entry_result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581850, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=385, prompt_tokens=16361, total_tokens=16746, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJIFWiP0gvwgFs1F7CP4GkRD6AW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{Bucket, ExtraValue, Links, Link, HashValue};\n    use crate::header::name::{HeaderName, StandardHeader};\n\n    #[test]\n    fn test_append_value_with_existing_links() {\n        let mut extra = Vec::new();\n        let entry_idx = 0;\n        let mut entry = Bucket {\n            hash: HashValue(1),\n            key: HeaderName::from_static("example-header"),\n            value: 42,\n            links: Some(Links {\n                tail: 1,\n                next: 1,\n            }),\n        };\n\n        append_value(entry_idx, &mut entry, &mut extra, 100);\n\n        assert_eq!(extra.len(), 2);\n        assert_eq!(extra[1].value, 100);\n        assert_eq!(entry.links.as_ref().unwrap().tail, 1);\n        assert!(matches!(extra[1].prev, Link::Extra(1)));\n        assert!(matches!(extra[1].next, Link::Entry(0)));\n    }\n\n    #[test]\n    fn test_append_value_without_existing_links() {\n        let mut extra = Vec::new();\n        let entry_idx = 0;\n        let mut entry = Bucket {\n            hash: HashValue(1),\n            key: HeaderName::from_static("new-header"),\n            value: 42,\n            links: None,\n        };\n\n        append_value(entry_idx, &mut entry, &mut extra, 200);\n\n        assert_eq!(extra.len(), 1);\n        assert_eq!(extra[0].value, 200);\n        assert!(entry.links.is_some());\n        let links = entry.links.as_ref().unwrap();\n        assert_eq!(links.tail, 0);\n        assert_eq!(links.next, 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581868, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=381, prompt_tokens=4687, total_tokens=5068, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJRN1VMARcFSqcRKP4qdUtKB8VY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use header::map::{desired_pos, HashValue};\n\n    #[test]\n    fn test_desired_pos() {\n        let mask: Size = 0b1111111111111111; // Example mask with all bits set\n        let hash = HashValue(0b0000001000000001); // Example hash value\n\n        let result = desired_pos(mask, hash);\n        assert_eq!(result, 0b0000001000000001 as usize);\n    }\n\n    #[test]\n    fn test_desired_pos_with_zero_hash() {\n        let mask: Size = 0b1111111111111111; // Example mask\n        let hash = HashValue(0); // Hash value set to zero\n\n        let result = desired_pos(mask, hash);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_desired_pos_with_different_masks() {\n        let hash = HashValue(0b0000111100001111); // Example hash value\n\n        // Testing with a mask that will select lower bits\n        let mask: Size = 0b0000000000001111;\n        let result = desired_pos(mask, hash);\n        assert_eq!(result, 0b0000111100001111 & mask as usize);\n\n        // Testing with a mask that will select upper bits\n        let mask: Size = 0b1111000000000000;\n        let result = desired_pos(mask, hash);\n        assert_eq!(result, 0b0000111100001111 & mask as usize);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581877, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=342, prompt_tokens=302, total_tokens=644, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJcY0ETYuTiTzgoSAYzjUYhhoP3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use header::map::{do_insert_phase_two, HashValue, Pos};\n\n    #[test]\n    fn test_insert_phase_two_with_empty_spot() {\n        let mut indices = vec![Pos::none(); 5];\n        let probe = 0;\n        let old_pos = Pos::new(1, HashValue(10));\n        \n        let displaced = do_insert_phase_two(&mut indices, probe, old_pos);\n        \n        assert_eq!(displaced, 0);\n        assert!(indices[0].is_some());\n        assert_eq!(indices[0].resolve(), Some((1, HashValue(10))));\n    }\n\n    #[test]\n    fn test_insert_phase_two_with_displacements() {\n        let mut indices = vec![Pos::new(0, HashValue(1)), Pos::none(), \n                               Pos::new(1, HashValue(2)), Pos::none(), \n                               Pos::new(2, HashValue(3))];\n        let probe = 0;\n        let old_pos = Pos::new(3, HashValue(4));\n\n        let displaced = do_insert_phase_two(&mut indices, probe, old_pos);\n\n        assert_eq!(displaced, 3);\n        assert!(indices[0].is_some());\n        assert_eq!(indices[0].resolve(), Some((0, HashValue(1))));\n        assert!(indices[1].is_some());\n        assert_eq!(indices[1].resolve(), Some((1, HashValue(2))));\n        assert!(indices[2].is_some());\n        assert_eq!(indices[2].resolve(), Some((2, HashValue(3))));\n        assert!(indices[3].is_some());\n        assert_eq!(indices[3].resolve(), Some((3, HashValue(4))));\n    }\n\n    #[test]\n    fn test_insert_phase_two_with_full_indices() {\n        let mut indices = vec![Pos::new(i, HashValue(i as u16)); 5];\n        let probe = 0;\n        let old_pos = Pos::new(5, HashValue(5));\n\n        let displaced = do_insert_phase_two(&mut indices, probe, old_pos);\n\n        assert_eq!(displaced, 5);\n        assert!(indices[0].is_some());\n        assert_eq!(indices[0].resolve(), Some((0, HashValue(0))));\n        assert!(indices[1].is_some());\n        assert_eq!(indices[1].resolve(), Some((1, HashValue(1))));\n        assert!(indices[2].is_some());\n        assert_eq!(indices[2].resolve(), Some((2, HashValue(2))));\n        assert!(indices[3].is_some());\n        assert_eq!(indices[3].resolve(), Some((3, HashValue(3))));\n        assert!(indices[4].is_some());\n        assert_eq!(indices[4].resolve(), Some((4, HashValue(4))));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581888, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=615, prompt_tokens=702, total_tokens=1317, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJvY8HaBJUWaTmQ9e4Wmxj4NUL5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{Bucket, HashValue, RawLinks};\n    use crate::header::name::HeaderName;\n\n    #[test]\n    fn test_drain_all_extra_values() {\n        // Setup\n        let value1 = "value1";\n        let value2 = "value2";\n        let value3 = "value3";\n        \n        let header_name = HeaderName::from_static("test-header");\n        let hash_value = HashValue(1);\n        \n        let extra_value1 = ExtraValue { value: value1, next: Link::Extra(1) };\n        let extra_value2 = ExtraValue { value: value2, next: Link::Extra(2) };\n        let extra_value3 = ExtraValue { value: value3, next: Link::None };\n\n        let mut extra_values = vec![extra_value1, extra_value2, extra_value3];\n        let bucket = Bucket {\n            hash: hash_value,\n            key: header_name,\n            value: value1,\n            links: Some(Links { extra: Link::Extra(0) }),\n        };\n\n        let raw_links = RawLinks::new(&mut [bucket]);\n        let mut head = 0;\n\n        // Call the function to test\n        let result = drain_all_extra_values(raw_links, &mut extra_values, head);\n\n        // Assertions\n        assert_eq!(result.len(), 3);\n        assert_eq!(result[0], value1);\n        assert_eq!(result[1], value2);\n        assert_eq!(result[2], value3);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581907, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=339, prompt_tokens=4871, total_tokens=5210, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmK6xEcoT7kPKmuyiVGLkGI2Dc9F', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use byte_str::ByteStr;\n    use std::hash::Hasher;\n    use fnv::FnvHasher;\n    use std::collections::hash_map::DefaultHasher;\n\n    #[test]\n    fn test_hash_elem_using_safe_hash() {\n        let danger = Danger::Red(RandomState::new());\n        let key = ByteStr::from_static("test_key");\n        let hash_value = hash_elem_using(&danger, &key);\n        let expected_hash = {\n            let mut hasher = DefaultHasher::new();\n            key.hash(&mut hasher);\n            (hasher.finish() & ((MAX_SIZE as u64) - 1)) as u16\n        };\n        assert_eq!(hash_value, HashValue(expected_hash));\n    }\n    \n    #[test]\n    fn test_hash_elem_using_fast_hash() {\n        let danger = Danger::Green;\n        let key = ByteStr::from_static("test_key");\n        let hash_value = hash_elem_using(&danger, &key);\n        let expected_hash = {\n            let mut hasher = FnvHasher::default();\n            key.hash(&mut hasher);\n            (hasher.finish() & ((MAX_SIZE as u64) - 1)) as u16\n        };\n        assert_eq!(hash_value, HashValue(expected_hash));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581918, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=283, prompt_tokens=1697, total_tokens=1980, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKFqmw6FikXz9RBYaE6qoJnaJzd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::map::{probe_distance, HashValue};\n\n    #[test]\n    fn test_probe_distance() {\n        let mask: Size = 15; // Example mask\n        let hash = HashValue(5); // Example hash value\n        let current: usize = 10; // Example current index\n\n        let result = probe_distance(mask, hash, current);\n        assert_eq!(result, 5); // Expected value based on desired_pos computation\n    }\n\n    #[test]\n    fn test_probe_distance_wraparound() {\n        let mask: Size = 7; // Example mask for wrapping\n        let hash = HashValue(3); // Example hash value\n        let current: usize = 10; // Example current index, chosen to cause wrapping\n\n        let result = probe_distance(mask, hash, current);\n        assert_eq!(result, 5); // Expected value based on desired_pos computation\n    }\n\n    // Additional tests can be added to cover edge cases\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581927, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=219, prompt_tokens=331, total_tokens=550, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKNYDyyuYJAl4KuGRxSeYgi1faC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec::Vec;\n\n    #[test]\n    fn test_remove_extra_value() {\n        let mut extra_values = vec![\n            ExtraValue {\n                value: "Value1",\n                prev: Link::Entry(0),\n                next: Link::Extra(1),\n            },\n            ExtraValue {\n                value: "Value2",\n                prev: Link::Extra(0),\n                next: Link::Extra(2),\n            },\n            ExtraValue {\n                value: "Value3",\n                prev: Link::Extra(1),\n                next: Link::Entry(3),\n            },\n        ];\n\n        let mut raw_links = RawLinks(Box::into_raw(Box::new([\n            Bucket {\n                hash: HashValue(1),\n                key: HeaderName::from_static("header1"),\n                value: "ValueA",\n                links: Some(Links {\n                    next: 1,\n                }),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: HeaderName::from_static("header2"),\n                value: "ValueB",\n                links: Some(Links {\n                    next: 2,\n                }),\n            },\n            Bucket {\n                hash: HashValue(3),\n                key: HeaderName::from_static("header3"),\n                value: "ValueC",\n                links: None,\n            },\n        ])));\n\n        let extra_value = remove_extra_value(raw_links, &mut extra_values, 1);\n\n        // Validate that the returned value is correct\n        assert_eq!(extra_value.value, "Value2");\n\n        // Validate the integrity of the remaining extra values\n        assert_eq!(extra_values.len(), 2);\n        assert_eq!(extra_values[0].next, Link::Extra(1)); // previous next should be updated\n        assert_eq!(extra_values[1].prev, Link::Extra(0)); // next prev should point back\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581935, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=403, prompt_tokens=5774, total_tokens=6177, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKU71nyVeJgxHF1qkK443FOHis1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_to_raw_capacity() {\n        assert_eq!(to_raw_capacity(0), 0);\n        assert_eq!(to_raw_capacity(3), 4);\n        assert_eq!(to_raw_capacity(6), 8);\n        assert_eq!(to_raw_capacity(9), 12);\n        assert_eq!(to_raw_capacity(12), 16);\n    }\n\n    #[test]\n    #[should_panic(expected = "requested capacity 18446744073709551615 too large: overflow while converting to raw capacity")]\n    fn test_to_raw_capacity_panic() {\n        to_raw_capacity(usize::MAX);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581942, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=148, prompt_tokens=190, total_tokens=338, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKZ173RO2ndGZdIrJRNV8NxaiVv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::usable_capacity;\n\n    #[test]\n    fn test_usable_capacity() {\n        assert_eq!(usable_capacity(0), 0);\n        assert_eq!(usable_capacity(1), 0);\n        assert_eq!(usable_capacity(4), 3);\n        assert_eq!(usable_capacity(5), 4);\n        assert_eq!(usable_capacity(10), 7);\n        assert_eq!(usable_capacity(100), 75);\n        assert_eq!(usable_capacity(1000), 750);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581947, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=118, prompt_tokens=150, total_tokens=268, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKg9qdcVdmegI0qpamwf9IPQCSJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, CONTENT_LENGTH};\n\n    #[test]\n    fn test_eq_case_insensitive() {\n        let header_name: HeaderName = HeaderName::from_static("content-length");\n        assert!(header_name.eq("content-length"));\n        assert!(header_name.eq("Content-Length"));\n        assert!(!header_name.eq("content length"));\n    }\n\n    #[test]\n    fn test_eq_with_different_cases() {\n        let header_name: HeaderName = HeaderName::from_static("User-Agent");\n        assert!(header_name.eq("user-agent"));\n        assert!(header_name.eq("USER-AGENT"));\n        assert!(!header_name.eq("UserAgent"));\n    }\n\n    #[test]\n    fn test_eq_with_non_matching_values() {\n        let header_name: HeaderName = HeaderName::from_static("Accept");\n        assert!(!header_name.eq("accept-encoding"));\n        assert!(!header_name.eq("accept "));\n    }\n\n    #[test]\n    fn test_eq_with_standard_headers() {\n        let header_name: HeaderName = HeaderName::from_static("content-type");\n        assert!(header_name.eq("content-type"));\n        assert!(header_name.eq("Content-Type"));\n    }\n\n    #[test]\n    fn test_eq_with_custom_headers() {\n        let header_name: HeaderName = HeaderName::from_static("x-custom-header");\n        assert!(header_name.eq("x-custom-header"));\n        assert!(header_name.eq("X-Custom-Header"));\n        assert!(!header_name.eq("x-custom"));\n    }\n\n    #[test]\n    fn test_eq_with_empty_string() {\n        let header_name: HeaderName = HeaderName::from_static("X-Empty");\n        assert!(!header_name.eq(""));\n    }\n\n    #[test]\n    fn test_eq_with_valid_non_header_name() {\n        let header_name: HeaderName = HeaderName::from_static("Valid-Header");\n        assert!(!header_name.eq("INVALID-HEADER"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581954, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=419, prompt_tokens=4246, total_tokens=4665, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKpl6B9USQYS4K29HTddbpA4iov', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{CONTENT_LENGTH, HeaderName};\n\n    #[test]\n    fn test_header_name_eq_case_insensitivity() {\n        let header_name = HeaderName::from_static("content-length");\n\n        assert_eq!(header_name, "content-length");\n        assert_eq!(header_name, "Content-Length");\n        assert_ne!(header_name, "content length");\n    }\n\n    #[test]\n    fn test_standard_header_eq_case_insensitivity() {\n        assert_eq!(CONTENT_LENGTH, "content-length");\n        assert_eq!(CONTENT_LENGTH, "Content-Length");\n        assert_ne!(CONTENT_LENGTH, "content length");\n    }\n\n    #[test]\n    fn test_eq_different_case() {\n        let header_name1 = HeaderName::from_static("custom-header");\n        let header_name2 = HeaderName::from_static("Custom-Header");\n\n        assert_eq!(header_name1, header_name2);\n    }\n\n    #[test]\n    fn test_eq_different_value() {\n        let header_name1 = HeaderName::from_static("another-header");\n        let header_name2 = HeaderName::from_static("not-another-header");\n\n        assert_ne!(header_name1, header_name2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581963, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=259, prompt_tokens=4294, total_tokens=4553, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKwOmyP3FZSizyrHuLz7hs40RU7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import everything from the parent module\n    use bytes::Bytes;\n    use byte_str::ByteStr;\n    \n    #[derive(Debug, Clone, PartialEq)]\n    struct Custom(ByteStr);\n\n    #[test]\n    fn test_from_custom() {\n        let custom_str = "test_string";\n        let custom = Custom(ByteStr::from_static(custom_str));\n\n        let result: Bytes = Bytes::from(custom.clone());\n        let expected: Bytes = Bytes::from(custom_str);\n\n        assert_eq!(result, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581970, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=123, prompt_tokens=1126, total_tokens=1249, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmL3lxLsMgI383tyCqjWFcrkY0Ra', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_from_standard() {\n        let header = StandardHeader::ContentLength; // Assuming ContentLength is a valid variant\n        let repr = Repr::Standard(header);\n        let result = Bytes::from(repr);\n        let expected = Bytes::from_static(b"Content-Length"); // Replace with the appropriate byte array\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_from_custom() {\n        let custom_header = Custom::new("X-Custom-Header".to_string()); // Assuming Custom::new() exists\n        let repr = Repr::Custom(custom_header);\n        let result = Bytes::from(repr);\n        let expected = Bytes::from("X-Custom-Header");\n        assert_eq!(result, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581977, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=185, prompt_tokens=694, total_tokens=879, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmL8FpiNYju04vjigZaaeos0EVQK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use header::name::HdrName;\n    \n    #[test]\n    fn test_custom_hdr_name() {\n        let buf: &[u8] = b"Custom-Header";\n        let lower = true;\n        let hdr_name = HdrName::custom(buf, lower);\n\n        match hdr_name.inner {\n            Repr::Custom(ref maybe_lower) => {\n                assert_eq!(maybe_lower.buf, buf);\n                assert_eq!(maybe_lower.lower, lower);\n            },\n            _ => panic!("Expected Repr::Custom"),\n        }\n    }\n\n    #[test]\n    fn test_custom_hdr_name_not_lower() {\n        let buf: &[u8] = b"Another-Header";\n        let lower = false;\n        let hdr_name = HdrName::custom(buf, lower);\n\n        match hdr_name.inner {\n            Repr::Custom(ref maybe_lower) => {\n                assert_eq!(maybe_lower.buf, buf);\n                assert_eq!(maybe_lower.lower, lower);\n            },\n            _ => panic!("Expected Repr::Custom"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581982, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=230, prompt_tokens=943, total_tokens=1173, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLFSwXPb2ETZgOCX1odJcvNIjui', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::name::{HdrName, InvalidHeaderName};\n\n    #[test]\n    fn test_from_bytes_valid_input() {\n        let input = b"valid-header-name";\n        let result = HdrName::from_bytes(input, |hdr| hdr);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_from_bytes_invalid_input() {\n        let input = b"invalid header name";\n        let result = HdrName::from_bytes(input, |hdr| hdr);\n        assert!(result.is_err());\n        if let Err(e) = result {\n            assert_eq!(e, InvalidHeaderName);\n        }\n    }\n\n    #[test]\n    fn test_from_bytes_empty_input() {\n        let input = b"";\n        let result = HdrName::from_bytes(input, |hdr| hdr);\n        assert!(result.is_err());\n        if let Err(e) = result {\n            assert_eq!(e, InvalidHeaderName);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581989, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=217, prompt_tokens=230, total_tokens=447, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLLWUGQ6r1etF51HPTVqTiGSBVT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::name::HdrName;\n\n    #[test]\n    fn test_from_static_valid_header() {\n        let result = HdrName::from_static("Valid-Header", |hdr| {\n            assert_eq!(hdr.as_str(), "Valid-Header");\n            hdr\n        });\n        \n        // Additional assertions can be made based on expected behavior\n        assert!(result.is_some());\n    }\n\n    #[test]\n    #[should_panic(expected = "static str is invalid name")]\n    fn test_from_static_invalid_header() {\n        HdrName::from_static("Invalid Header!", |hdr| {\n            // Should not reach here\n            hdr\n        });\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581995, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=155, prompt_tokens=235, total_tokens=390, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLQr3wUmrnalU24sGDOdGZ3sRuc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, StandardHeader};\n\n    #[test]\n    fn test_as_str_standard_header() {\n        let header_name = HeaderName::from(StandardHeader::CONTENT_LENGTH);\n        assert_eq!(header_name.as_str(), "content-length");\n    }\n\n    #[test]\n    fn test_as_str_custom_header() {\n        let custom_header = HeaderName::from_bytes(b"custom-header").unwrap();\n        assert_eq!(custom_header.as_str(), "custom-header");\n    }\n\n    #[test]\n    fn test_as_str_lowercase() {\n        let header_name = HeaderName::from_bytes(b"X-Custom-Header").unwrap();\n        assert_eq!(header_name.as_str(), "x-custom-header");\n    }\n\n    #[test]\n    fn test_as_str_with_standard_header() {\n        let header_name = HeaderName::from(StandardHeader::USER_AGENT);\n        assert_eq!(header_name.as_str(), "user-agent");\n    }\n\n    #[test]\n    fn test_as_str_with_custom_encoding() {\n        let header_name = HeaderName::from_lowercase(b"custom-encoded-header").unwrap();\n        assert_eq!(header_name.as_str(), "custom-encoded-header");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582000, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=260, prompt_tokens=4258, total_tokens=4518, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLZmryxW5aiUz1zL4aWdfg7KMLb', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust this based on the module structure in your crate\n    use http::header::name::HeaderName;\n    use http::header::InvalidHeaderName;\n\n    #[test]\n    fn test_from_bytes_valid_header() {\n        let header_name_bytes: &[u8] = b"Content-Type";\n        let result = HeaderName::from_bytes(header_name_bytes);\n        assert!(result.is_ok());\n        let header_name = result.unwrap();\n        assert_eq!(header_name.as_ref(), "Content-Type");\n    }\n\n    #[test]\n    fn test_from_bytes_invalid_header() {\n        let header_name_bytes: &[u8] = b"Invalid\\xFFHeader";\n        let result = HeaderName::from_bytes(header_name_bytes);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), "Invalid Header Name");\n    }\n\n    #[test]\n    fn test_from_bytes_empty() {\n        let header_name_bytes: &[u8] = b"";\n        let result = HeaderName::from_bytes(header_name_bytes);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), "Invalid Header Name");\n    }\n\n    #[test]\n    fn test_from_bytes_non_ascii() {\n        let header_name_bytes: &[u8] = b"X-Custom-Header";\n        let result = HeaderName::from_bytes(header_name_bytes);\n        assert!(result.is_ok());\n        let header_name = result.unwrap();\n        assert_eq!(header_name.as_ref(), "X-Custom-Header");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582009, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=333, prompt_tokens=476, total_tokens=809, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLjlYlhQsP1hXKqrxkNbVedz8bS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::*;\n\n    #[test]\n    fn test_from_lowercase_valid() {\n        let hdr = HeaderName::from_lowercase(b"content-length").unwrap();\n        assert_eq!(CONTENT_LENGTH, hdr);\n    }\n\n    #[test]\n    fn test_from_lowercase_invalid_uppercase() {\n        assert!(HeaderName::from_lowercase(b"Content-Length").is_err());\n    }\n\n    #[test]\n    fn test_from_lowercase_invalid_characters() {\n        assert!(HeaderName::from_lowercase(b"content-length\\xFF").is_err());\n    }\n\n    #[test]\n    fn test_from_lowercase_empty() {\n        assert!(HeaderName::from_lowercase(b"").is_err());\n    }\n\n    #[test]\n    fn test_from_lowercase_valid_custom() {\n        let hdr = HeaderName::from_lowercase(b"custom-header").unwrap();\n        // Assuming there\'s a custom header defined elsewhere\n        assert_eq!(/* your custom header */, hdr);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582019, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=217, prompt_tokens=573, total_tokens=790, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLqYu1FaD25EaiWHUHlNQpRrEfy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Make sure to import everything from the file\n    use http::header::*;\n\n    #[test]\n    fn test_from_static_valid_standard_header() {\n        let hdr = HeaderName::from_static("content-length");\n        assert_eq!(hdr.as_str(), "content-length");\n    }\n\n    #[test]\n    fn test_from_static_valid_custom_header() {\n        let custom_header: &\'static str = "custom-header";\n        let hdr = HeaderName::from_static(custom_header);\n        assert_eq!(hdr.as_str(), "custom-header");\n    }\n\n    #[test]\n    #[should_panic(expected = "index out of bounds: the length is 0 but the index is 0")]\n    fn test_from_static_empty() {\n        HeaderName::from_static("");\n    }\n\n    #[test]\n    #[should_panic(expected = "index out of bounds: the length is 0 but the index is 0")]\n    fn test_from_static_invalid_uppercase() {\n        HeaderName::from_static("Uppercase-Header");\n    }\n\n    #[test]\n    #[should_panic(expected = "index out of bounds: the length is 0 but the index is 0")]\n    fn test_from_static_invalid_symbols() {\n        HeaderName::from_static("invalid{}header");\n    }\n\n    #[test]\n    fn test_from_static_valid_lowercase() {\n        let hdr = HeaderName::from_static("valid-header");\n        assert_eq!(hdr.as_str(), "valid-header");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582026, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=318, prompt_tokens=4975, total_tokens=5293, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLy2sFtcTNH0VpWFsDJyyPb6tLq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::name::{HeaderName, StandardHeader};\n    use bytes::Bytes;\n\n    #[test]\n    fn test_into_bytes_standard_header() {\n        let header_name: HeaderName = HeaderName::from(StandardHeader::CONTENT_LENGTH);\n        let bytes: Bytes = header_name.into_bytes();\n        assert_eq!(&bytes, b"content-length");\n    }\n\n    #[test]\n    fn test_into_bytes_custom_header() {\n        let header_name: HeaderName = HeaderName::from_static("custom-header");\n        let bytes: Bytes = header_name.into_bytes();\n        assert_eq!(&bytes, b"custom-header");\n    }\n\n    #[test]\n    fn test_into_bytes_empty_header() {\n        let header_name: HeaderName = HeaderName::from_static("empty-header");\n        let bytes: Bytes = header_name.into_bytes();\n        assert_eq!(&bytes, b"empty-header");\n    }\n\n    #[test]\n    fn test_into_bytes_large_header() {\n        let header_name: HeaderName = HeaderName::from_static("x-very-large-header-name");\n        let bytes: Bytes = header_name.into_bytes();\n        assert_eq!(&bytes, b"x-very-large-header-name");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582034, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=264, prompt_tokens=4378, total_tokens=4642, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMAjkSKKXC4v1ZkknWIcwH9Cs3B', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::InvalidHeaderName;\n\n    #[test]\n    fn test_invalid_header_name_new() {\n        let error = InvalidHeaderName::new();\n        assert_eq!(format!("{}", error), "invalid HTTP header name");\n        assert!(error.is_err());\n    }\n\n    #[test]\n    fn test_invalid_header_name_debug() {\n        let error = InvalidHeaderName::new();\n        assert_eq!(format!("{:?}", error), "InvalidHeaderName");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582046, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=106, prompt_tokens=367, total_tokens=473, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMGmfHXpAedSfFIluIictDslUxq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::name::StandardHeader;\n\n    #[test]\n    fn test_as_str() {\n        // Assuming you have defined StandardHeader variants with corresponding byte arrays\n        // Replace with actual variants and byte arrays\n        assert_eq!(StandardHeader::Header1.as_str(), "Header1");\n        assert_eq!(StandardHeader::Header2.as_str(), "Header2");\n        assert_eq!(StandardHeader::Header3.as_str(), "Header3");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582052, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=112, prompt_tokens=437, total_tokens=549, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMK3bf7L1lsWmcx3ivphRdxYnll', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::header::name::StandardHeader;\n\n    #[test]\n    fn test_from_bytes_valid() {\n        assert_eq!(StandardHeader::from_bytes(b"valid_name"), Some(StandardHeader::ValidHeaderVariant));\n    }\n    \n    #[test]\n    fn test_from_bytes_invalid() {\n        assert_eq!(StandardHeader::from_bytes(b"invalid_name"), None);\n    }\n    \n    #[test]\n    fn test_from_bytes_empty() {\n        assert_eq!(StandardHeader::from_bytes(b""), None);\n    }\n    \n    #[test]\n    fn test_from_bytes_with_special_characters() {\n        assert_eq!(StandardHeader::from_bytes(b"special_char_name!"), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582056, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=159, prompt_tokens=180, total_tokens=339, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMVK6WBgN2W6xdqzHckva4sKJhh', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_eq_ignore_ascii_case_equal() {\n        let lower: &[u8] = b"header";\n        let s: &[u8] = b"HEADER";\n        assert!(eq_ignore_ascii_case(lower, s));\n    }\n\n    #[test]\n    fn test_eq_ignore_ascii_case_not_equal() {\n        let lower: &[u8] = b"header";\n        let s: &[u8] = b"HEAder";\n        assert!(eq_ignore_ascii_case(lower, s));\n    }\n\n    #[test]\n    fn test_eq_ignore_ascii_case_different_lengths() {\n        let lower: &[u8] = b"header";\n        let s: &[u8] = b"head";\n        assert!(!eq_ignore_ascii_case(lower, s));\n    }\n\n    #[test]\n    fn test_eq_ignore_ascii_case_empty() {\n        let lower: &[u8] = b"";\n        let s: &[u8] = b"";\n        assert!(eq_ignore_ascii_case(lower, s));\n    }\n\n    #[test]\n    fn test_eq_ignore_ascii_case_lowercase_vs_uppercase() {\n        let lower: &[u8] = b"test";\n        let s: &[u8] = b"TEST";\n        assert!(eq_ignore_ascii_case(lower, s));\n    }\n\n    #[test]\n    fn test_eq_ignore_ascii_case_special_characters() {\n        let lower: &[u8] = b"header!";\n        let s: &[u8] = b"HEADER!";\n        assert!(eq_ignore_ascii_case(lower, s));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582067, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=344, prompt_tokens=204, total_tokens=548, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMebvf5hPwbNAwtZY1KxWexnRfh', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem::MaybeUninit;\n    \n    #[test]\n    fn test_parse_hdr_valid_standard() {\n        let data: &[u8] = b"Content-Type";\n        let mut buffer: [MaybeUninit<u8>; SCRATCH_BUF_SIZE] = unsafe { MaybeUninit::uninit().assume_init() };\n        let table: [u8; 256] = /* Initialize with appropriate mapping */ [0; 256]; // Fill with actual values\n\n        let result = parse_hdr(data, &mut buffer, &table);\n        assert!(result.is_ok());\n        if let Ok(hdr_name) = result {\n            assert_eq!(hdr_name.to_string(), "Content-Type");\n        }\n    }\n\n    #[test]\n    fn test_parse_hdr_empty() {\n        let data: &[u8] = b"";\n        let mut buffer: [MaybeUninit<u8>; SCRATCH_BUF_SIZE] = unsafe { MaybeUninit::uninit().assume_init() };\n        let table: [u8; 256] = /* Initialize with appropriate mapping */ [0; 256]; // Fill with actual values\n\n        let result = parse_hdr(data, &mut buffer, &table);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_hdr_invalid_character() {\n        let data: &[u8] = b"Invalid\\x00Header";\n        let mut buffer: [MaybeUninit<u8>; SCRATCH_BUF_SIZE] = unsafe { MaybeUninit::uninit().assume_init() };\n        let table: [u8; 256] = /* Initialize with appropriate mapping */ [0; 256]; // Fill with actual values\n\n        let result = parse_hdr(data, &mut buffer, &table);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_hdr_overflow() {\n        let data: &[u8] = b"TooLongHeaderThatExceedsTheMaximumAllowedLength";\n        let mut buffer: [MaybeUninit<u8>; SCRATCH_BUF_SIZE] = unsafe { MaybeUninit::uninit().assume_init() };\n        let table: [u8; 256] = /* Initialize with appropriate mapping */ [0; 256]; // Fill with actual values\n\n        let result = parse_hdr(data, &mut buffer, &table);\n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_parse_hdr_custom_name() {\n        let data: &[u8] = b"X-Custom-Header";\n        let mut buffer: [MaybeUninit<u8>; SCRATCH_BUF_SIZE] = unsafe { MaybeUninit::uninit().assume_init() };\n        let table: [u8; 256] = /* Initialize with appropriate mapping */ [0; 256]; // Fill with actual values\n\n        let result = parse_hdr(data, &mut buffer, &table);\n        assert!(result.is_ok());\n        if let Ok(hdr_name) = result {\n            assert_eq!(hdr_name.to_string(), "X-Custom-Header");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582076, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=658, prompt_tokens=407, total_tokens=1065, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMqOE5JLjZgN0qdCDlZpdMD2vDz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem::MaybeUninit;\n\n    #[test]\n    fn test_slice_assume_init_valid() {\n        let input: &[MaybeUninit<i32>] = &[MaybeUninit::new(1), MaybeUninit::new(2), MaybeUninit::new(3)];\n        let output: &[i32] = unsafe { slice_assume_init(input) };\n        assert_eq!(output, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn test_slice_assume_init_empty() {\n        let input: &[MaybeUninit<i32>] = &[];\n        let output: &[i32] = unsafe { slice_assume_init(input) };\n        assert_eq!(output, &[]);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_slice_assume_init_uninitialized() {\n        let input: &[MaybeUninit<i32>] = &[MaybeUninit::uninit(), MaybeUninit::uninit()];\n        let _output: &[i32] = unsafe { slice_assume_init(input) };\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582088, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=237, prompt_tokens=174, total_tokens=411, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNAJaJCBCX4st5U1QldM3tkgkWC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem::MaybeUninit;\n\n    const SCRATCH_BUF_SIZE: usize = 10; // Define SCRATCH_BUF_SIZE for the test\n\n    #[test]\n    fn test_uninit_u8_array() {\n        let array: [MaybeUninit<u8>; SCRATCH_BUF_SIZE] = uninit_u8_array();\n\n        // Check that the array length matches SCRATCH_BUF_SIZE\n        assert_eq!(array.len(), SCRATCH_BUF_SIZE);\n\n        // Check that all elements in the array are uninitialized\n        for element in array.iter() {\n            assert!(element.as_ptr().is_null());\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582108, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=145, prompt_tokens=224, total_tokens=369, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNHx7xhEM31rvgP0SoDFDoeiMOU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_eq_with_matching_str() {\n        let header_value = HeaderValue::from_static("test_value");\n        let test_str = "test_value";\n        assert!(header_value.eq(test_str));\n    }\n\n    #[test]\n    fn test_eq_with_non_matching_str() {\n        let header_value = HeaderValue::from_static("test_value");\n        let test_str = "different_value";\n        assert!(!header_value.eq(test_str));\n    }\n\n    #[test]\n    fn test_eq_with_empty_str() {\n        let header_value = HeaderValue::from_static("");\n        let test_str = "";\n        assert!(header_value.eq(test_str));\n    }\n\n    #[test]\n    fn test_eq_with_non_empty_str() {\n        let header_value = HeaderValue::from_static("non_empty");\n        let test_str = "";\n        assert!(!header_value.eq(test_str));\n    }\n\n    #[test]\n    fn test_eq_with_special_chars() {\n        let header_value = HeaderValue::from_static("value_with_special_chars!@#");\n        let test_str = "value_with_special_chars!@#";\n        assert!(header_value.eq(test_str));\n    }\n\n    #[test]\n    fn test_eq_with_partial_matching() {\n        let header_value = HeaderValue::from_static("header_value");\n        let test_str = "header";\n        assert!(!header_value.eq(test_str));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582115, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=312, prompt_tokens=4452, total_tokens=4764, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNQHV8m38Nx5Y7UqUIVb2bCaV33', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import everything from the parent module\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_eq_with_same_header_value() {\n        let hv1 = HeaderValue::from_static("test");\n        let hv2 = HeaderValue::from_static("test");\n        assert!(hv1.eq(&hv2));\n    }\n\n    #[test]\n    fn test_eq_with_different_header_value() {\n        let hv1 = HeaderValue::from_static("test");\n        let hv2 = HeaderValue::from_static("different");\n        assert!(!hv1.eq(&hv2));\n    }\n\n    #[test]\n    fn test_eq_with_empty_header_value() {\n        let hv1 = HeaderValue::from_static("");\n        let hv2 = HeaderValue::from_static("");\n        assert!(hv1.eq(&hv2));\n    }\n\n    #[test]\n    fn test_eq_with_bytes() {\n        let hv = HeaderValue::from_static("test");\n        let bytes: &[u8] = b"test";\n        assert!(hv.eq(bytes));\n    }\n\n    #[test]\n    fn test_eq_with_str() {\n        let hv = HeaderValue::from_static("test");\n        let string: &str = "test";\n        assert!(hv.eq(string));\n    }\n\n    #[test]\n    fn test_eq_with_different_bytes() {\n        let hv = HeaderValue::from_static("test");\n        let bytes: &[u8] = b"not_test";\n        assert!(!hv.eq(bytes));\n    }\n\n    #[test]\n    fn test_eq_with_different_str() {\n        let hv = HeaderValue::from_static("test");\n        let string: &str = "not_test";\n        assert!(!hv.eq(string));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582124, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=374, prompt_tokens=4453, total_tokens=4827, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNecd5i7WQBnWOWKLfdrYXAF11c', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_eq_with_matching_header_value() {\n        let header_value = HeaderValue::from_static("example");\n        let string_value = String::from("example");\n        assert!(header_value.eq(&string_value));\n    }\n\n    #[test]\n    fn test_eq_with_non_matching_header_value() {\n        let header_value = HeaderValue::from_static("example");\n        let string_value = String::from("test");\n        assert!(!header_value.eq(&string_value));\n    }\n\n    #[test]\n    fn test_eq_with_empty_string() {\n        let header_value = HeaderValue::from_static("");\n        let string_value = String::from("");\n        assert!(header_value.eq(&string_value));\n    }\n\n    #[test]\n    fn test_eq_with_empty_header_value() {\n        let header_value = HeaderValue::from_static("test");\n        let string_value = String::from("");\n        assert!(!header_value.eq(&string_value));\n    }\n\n    #[test]\n    fn test_eq_with_different_case() {\n        let header_value = HeaderValue::from_static("example");\n        let string_value = String::from("EXAMPLE");\n        assert!(!header_value.eq(&string_value)); // case-sensitive check\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582138, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=278, prompt_tokens=4938, total_tokens=5216, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNntWf8Filh2l0TzPVklLWQtnM6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_eq_with_matching_string() {\n        let header_value = HeaderValue::from_static("test_value");\n        let result = header_value.eq("test_value");\n        assert!(result);\n    }\n\n    #[test]\n    fn test_eq_with_non_matching_string() {\n        let header_value = HeaderValue::from_static("test_value");\n        let result = header_value.eq("other_value");\n        assert!(!result);\n    }\n\n    #[test]\n    fn test_eq_with_partial_eq_header_value() {\n        let header_value1 = HeaderValue::from_static("test_value");\n        let header_value2 = HeaderValue::from_static("test_value");\n        let result = header_value1.eq(&header_value2);\n        assert!(result);\n    }\n\n    #[test]\n    fn test_eq_with_different_header_value() {\n        let header_value1 = HeaderValue::from_static("test_value");\n        let header_value2 = HeaderValue::from_static("other_value");\n        let result = header_value1.eq(&header_value2);\n        assert!(!result);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582147, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=248, prompt_tokens=4450, total_tokens=4698, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNxLcOanbGsvgR9gAmcLTwLZkJk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let header_value = HeaderValue::from_static("test");\n        let result = "test".partial_cmp(&header_value);\n        assert_eq!(result, Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let header_value = HeaderValue::from_static("test");\n        let result = "apple".partial_cmp(&header_value);\n        assert_eq!(result, Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let header_value = HeaderValue::from_static("test");\n        let result = "zebra".partial_cmp(&header_value);\n        assert_eq!(result, Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_lengths() {\n        let header_value = HeaderValue::from_static("short");\n        let result = "longer string".partial_cmp(&header_value);\n        assert_eq!(result, Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_empty_string() {\n        let header_value = HeaderValue::from_static("non-empty");\n        let result = "".partial_cmp(&header_value);\n        assert_eq!(result, Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_case() {\n        let header_value = HeaderValue::from_static("Test");\n        let result = "test".partial_cmp(&header_value);\n        assert_eq!(result, Some(cmp::Ordering::Greater));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582157, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=360, prompt_tokens=4463, total_tokens=4823, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmO8paz3UdIY0eZNIAtaieiukg5z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let header_value1 = HeaderValue::from_static("hello");\n        let header_value2 = HeaderValue::from_static("hello");\n        let result = header_value1.partial_cmp(&header_value2);\n        assert_eq!(result, Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let header_value1 = HeaderValue::from_static("apple");\n        let header_value2 = HeaderValue::from_static("banana");\n        let result = header_value1.partial_cmp(&header_value2);\n        assert_eq!(result, Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let header_value1 = HeaderValue::from_static("banana");\n        let header_value2 = HeaderValue::from_static("apple");\n        let result = header_value1.partial_cmp(&header_value2);\n        assert_eq!(result, Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let header_value1 = HeaderValue::from_static("apple");\n        let header_value2 = HeaderValue::from_static("");\n        let result = header_value1.partial_cmp(&header_value2);\n        assert_eq!(result, Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_cases() {\n        let header_value1 = HeaderValue::from_static("hello");\n        let header_value2 = HeaderValue::from_static("Hello");\n        let result = header_value1.partial_cmp(&header_value2);\n        assert_eq!(result, Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_strings() {\n        let header_value1 = HeaderValue::from_static("apple");\n        let header_value2 = HeaderValue::from_static("apple pie");\n        let result = header_value1.partial_cmp(&header_value2);\n        assert_eq!(result, Some(Ordering::Less));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582168, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=440, prompt_tokens=4461, total_tokens=4901, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmOKOO9wuc5I41PeTGBAzRv4tOur', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let string_value = String::from("header-value");\n        let header_value = HeaderValue::from_static("header-value");\n        assert_eq!(string_value.partial_cmp(&header_value), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let string_value = String::from("header-value-a");\n        let header_value = HeaderValue::from_static("header-value");\n        assert_eq!(string_value.partial_cmp(&header_value), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let string_value = String::from("header-value-b");\n        let header_value = HeaderValue::from_static("header-value");\n        assert_eq!(string_value.partial_cmp(&header_value), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_length() {\n        let string_value = String::from("header-value");\n        let header_value = HeaderValue::from_static("header-value-extra");\n        assert_eq!(string_value.partial_cmp(&header_value), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_non_ascii() {\n        let string_value = String::from("header-value-");\n        let header_value = HeaderValue::from_static("header-value");\n        assert_eq!(string_value.partial_cmp(&header_value), Some(cmp::Ordering::Greater));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582180, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=336, prompt_tokens=4949, total_tokens=5285, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmOTi9q03New94tIgE4hERFgo2K5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let header_value = HeaderValue::from_static("test");\n        let result = "test".partial_cmp(&header_value);\n        assert_eq!(result, Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let header_value = HeaderValue::from_static("test");\n        let result = "a".partial_cmp(&header_value);\n        assert_eq!(result, Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let header_value = HeaderValue::from_static("test");\n        let result = "z".partial_cmp(&header_value);\n        assert_eq!(result, Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_none() {\n        let header_value = HeaderValue::from_static("test");\n        let result = "test\\xFF".partial_cmp(&header_value); // Invalid comparison case\n        assert_eq!(result, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582189, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=243, prompt_tokens=4461, total_tokens=4704, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmObgbKf3O89SycofrOmfGY3O6Wg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_as_bytes() {\n        let val = HeaderValue::from_static("hello");\n        assert_eq!(val.as_bytes(), b"hello");\n    }\n\n    #[test]\n    fn test_as_bytes_empty() {\n        let val = HeaderValue::from_static("");\n        assert_eq!(val.as_bytes(), b"");\n    }\n\n    #[test]\n    fn test_as_bytes_non_ascii() {\n        let val = HeaderValue::from_static("hello\\xfa");\n        assert_eq!(val.as_bytes(), b"hello\\xfa");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582197, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=140, prompt_tokens=4488, total_tokens=4628, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmOhZz6BgRSViGJPhobgHDg6ldsW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n    use http::header::InvalidHeaderValue;\n\n    #[test]\n    fn test_valid_header_value() {\n        let result = HeaderValue::from_bytes(b"valid_value");\n        assert!(result.is_ok());\n        let val = result.unwrap();\n        assert_eq!(val.as_bytes(), b"valid_value");\n    }\n\n    #[test]\n    fn test_invalid_header_value() {\n        let result = HeaderValue::from_bytes(b"\\n");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_character() {\n        let result = HeaderValue::from_bytes(b"hello\\x7f");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_valid_bytes_boundary() {\n        let result = HeaderValue::from_bytes(b" ");\n        assert!(result.is_ok());\n        let val = result.unwrap();\n        assert_eq!(val.as_bytes(), b" ");\n        \n        let result = HeaderValue::from_bytes(b"\\xFF");\n        assert!(result.is_ok());\n        let val = result.unwrap();\n        assert_eq!(val.as_bytes(), b"\\xFF");\n    }\n\n    #[test]\n    fn test_empty_bytes() {\n        let result = HeaderValue::from_bytes(b"");\n        assert!(result.is_ok());\n        let val = result.unwrap();\n        assert_eq!(val.as_bytes(), b"");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582203, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=303, prompt_tokens=340, total_tokens=643, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmOpnG0hVaSPBYlKAYfYQ6f0ucU6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_from_maybe_shared_with_bytes() {\n        let bytes = Bytes::from_static(b"test-header");\n        let result = HeaderValue::from_maybe_shared(bytes.clone());\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().to_str().unwrap(), "test-header");\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_slice() {\n        let slice: &[u8] = b"test-header-slice";\n        let result = HeaderValue::from_maybe_shared(slice);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().to_str().unwrap(), "test-header-slice");\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_invalid_data() {\n        let invalid_slice: &[u8] = b"\\xFF"; // Invalid byte\n        let result = HeaderValue::from_maybe_shared(invalid_slice);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_empty_bytes() {\n        let empty_bytes = Bytes::from_static(b"");\n        let result = HeaderValue::from_maybe_shared(empty_bytes);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582211, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=270, prompt_tokens=4364, total_tokens=4634, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmP05cmclMicsr5diFvedcMXQO9C', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_from_maybe_shared_unchecked_valid_utf8() {\n        let header_value = unsafe {\n            HeaderValue::from_maybe_shared_unchecked("valid header value")\n        };\n        assert_eq!(header_value.as_ref(), b"valid header value");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_from_maybe_shared_unchecked_invalid_utf8_debug() {\n        let invalid_bytes = b"\\xFF\\xFF\\xFF"; // Invalid UTF-8\n        let _header_value = unsafe {\n            HeaderValue::from_maybe_shared_unchecked(invalid_bytes)\n        };\n    }\n\n    #[test]\n    fn test_from_maybe_shared_unchecked_valid_bytes() {\n        let bytes = Bytes::from("valid bytes");\n        let header_value = unsafe {\n            HeaderValue::from_maybe_shared_unchecked(bytes)\n        };\n        assert_eq!(header_value.as_ref(), b"valid bytes");\n    }\n\n    #[test]\n    fn test_from_maybe_shared_unchecked_empty() {\n        let header_value = unsafe {\n            HeaderValue::from_maybe_shared_unchecked("")\n        };\n        assert!(header_value.is_empty());\n    }\n\n    #[test]\n    fn test_from_maybe_shared_unchecked_sensitive() {\n        let mut header_value = unsafe {\n            HeaderValue::from_maybe_shared_unchecked("sensitive header")\n        };\n        header_value.set_sensitive(true);\n        assert!(header_value.is_sensitive());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582222, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=321, prompt_tokens=8787, total_tokens=9108, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPCXBm9VzHyfwACKMPDvLBo8NW6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderValue, HeaderName, ACCEPT};\n\n    #[test]\n    fn test_from_name_standard_header() {\n        let val = HeaderValue::from_name(ACCEPT);\n        assert_eq!(val, HeaderValue::from_bytes(b"accept").unwrap());\n    }\n\n    #[test]\n    fn test_from_name_custom_header() {\n        let custom_header = HeaderName::from_static("x-custom-header");\n        let val = HeaderValue::from_name(custom_header);\n        assert_eq!(val, HeaderValue::from_bytes(b"x-custom-header").unwrap());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582234, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=135, prompt_tokens=8580, total_tokens=8715, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPIFE4spMQDVr5MHZH2wYz4KkNz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n    use http::header::value::HeaderValue;\n    use http::header::InvalidHeaderValue;\n    \n    #[test]\n    fn test_from_shared_valid() {\n        let valid_input = Bytes::from_static(b"valid-header-value");\n        let result = HeaderValue::from_shared(valid_input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_from_shared_empty() {\n        let empty_input = Bytes::from_static(b"");\n        let result = HeaderValue::from_shared(empty_input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_from_shared_invalid() {\n        let invalid_input = Bytes::from_static(b"invalid\\x80header\\x80value");\n        let result = HeaderValue::from_shared(invalid_input);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().kind(), InvalidHeaderValueKind::Invalid);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582240, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=207, prompt_tokens=336, total_tokens=543, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPPmDlNiy89CsNJOLzKQGTX2bLQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_from_static_valid() {\n        let val = HeaderValue::from_static("valid-header");\n        assert_eq!(val.as_bytes(), b"valid-header");\n    }\n\n    #[test]\n    fn test_from_static_empty() {\n        let val = HeaderValue::from_static("");\n        assert!(val.is_empty());\n    }\n\n    #[test]\n    fn test_from_static_length() {\n        let val = HeaderValue::from_static("length-check");\n        assert_eq!(val.len(), 13);\n    }\n\n    #[test]\n    #[should_panic(expected = "any use of this value will cause an error")]\n    fn test_from_static_invalid_control_character() {\n        HeaderValue::from_static("invalid\\nheader");\n    }\n\n    #[test]\n    #[should_panic(expected = "any use of this value will cause an error")]\n    fn test_from_static_invalid_non_ascii() {\n        HeaderValue::from_static("invalid\\xFFheader");\n    }\n\n    #[test]\n    fn test_from_static_sensitive() {\n        let mut val = HeaderValue::from_static("sensitive");\n        val.set_sensitive(true);\n        assert!(val.is_sensitive());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582247, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=265, prompt_tokens=4959, total_tokens=5224, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPgW71hs0zcaoyZTyGT0bWilfjs', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n    use http::header::InvalidHeaderValue;\n\n    #[test]\n    fn test_from_str_valid() {\n        let val = HeaderValue::from_str("hello").unwrap();\n        assert_eq!(val.to_str().unwrap(), "hello");\n    }\n\n    #[test]\n    fn test_from_str_invalid() {\n        let val = HeaderValue::from_str("\\n");\n        assert!(val.is_err());\n    }\n\n    #[test]\n    fn test_from_str_empty() {\n        let val = HeaderValue::from_str("");\n        assert!(val.is_ok());\n        assert_eq!(val.unwrap().to_str().unwrap(), "");\n    }\n\n    #[test]\n    fn test_from_str_with_spaces() {\n        let val = HeaderValue::from_str("  ");\n        assert!(val.is_ok());\n        assert_eq!(val.unwrap().to_str().unwrap(), "  ");\n    }\n\n    #[test]\n    fn test_from_str_non_ascii() {\n        let val = HeaderValue::from_str("hello\\x80");\n        assert!(val.is_err());\n    }\n\n    #[test]\n    fn test_from_str_control_character() {\n        let val = HeaderValue::from_str("\\x1B");\n        assert!(val.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582264, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=274, prompt_tokens=359, total_tokens=633, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPp28X8jYjq8hDuye4Yyx4wSJ55', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_is_empty() {\n        let empty_val = HeaderValue::from_static("");\n        assert!(empty_val.is_empty());\n\n        let non_empty_val = HeaderValue::from_static("hello");\n        assert!(!non_empty_val.is_empty());\n\n        let another_non_empty_val = HeaderValue::from_static("test");\n        assert!(!another_non_empty_val.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582273, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=107, prompt_tokens=4505, total_tokens=4612, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPwav8k464hirMs7QYOz4HIoXCR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming the necessary imports are in place\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_is_sensitive() {\n        let mut val = HeaderValue::from_static("my secret");\n        \n        val.set_sensitive(true);\n        assert!(val.is_sensitive(), "Expected the header value to be sensitive");\n\n        val.set_sensitive(false);\n        assert!(!val.is_sensitive(), "Expected the header value to not be sensitive");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582280, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=109, prompt_tokens=4616, total_tokens=4725, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQ0zyGyhkNHhj5G2MTfCiRDJ7EF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_len() {\n        let val1 = HeaderValue::from_static("hello");\n        assert_eq!(val1.len(), 5);\n\n        let val2 = HeaderValue::from_static("");\n        assert_eq!(val2.len(), 0);\n\n        let val3 = HeaderValue::from_static("byte_length_test");\n        assert_eq!(val3.len(), 17);\n\n        let val4 = HeaderValue::from_static("1234567890");\n        assert_eq!(val4.len(), 10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582284, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=136, prompt_tokens=4485, total_tokens=4621, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQ9cRBNBRoN1tm8o2MS9eRK0bsO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_set_sensitive() {\n        let mut val = HeaderValue::from_static("my secret");\n\n        val.set_sensitive(true);\n        assert!(val.is_sensitive());\n\n        val.set_sensitive(false);\n        assert!(!val.is_sensitive());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582293, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=79, prompt_tokens=4504, total_tokens=4583, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQFiphbX9eBVDj25kvtz4YVcKlk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_to_str_valid() {\n        let val = HeaderValue::from_static("hello");\n        assert_eq!(val.to_str().unwrap(), "hello");\n    }\n\n    #[test]\n    fn test_to_str_empty() {\n        let val = HeaderValue::from_static("");\n        assert_eq!(val.to_str().unwrap(), "");\n    }\n\n    #[test]\n    fn test_to_str_invalid() {\n        let val = HeaderValue::from_static("hello\\xFF");\n        assert!(val.to_str().is_err());\n\n        let val = HeaderValue::from_static("hello\\n");\n        assert!(val.to_str().is_err());\n\n        let val = HeaderValue::from_static("hello\\x80");\n        assert!(val.to_str().is_err());\n    }\n\n    #[test]\n    fn test_to_str_non_ascii() {\n        let val = HeaderValue::from_static("");\n        assert!(val.to_str().is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582299, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=221, prompt_tokens=4567, total_tokens=4788, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQMInMWtioiBjE75nXzbe6Uxzyc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderValue, HeaderName};\n\n    #[test]\n    fn test_try_from_generic_valid() {\n        let input = b"valid-header-name";\n        let result = HeaderValue::try_from_generic(input, |src| Bytes::copy_from_slice(src.as_ref()));\n        assert!(result.is_ok());\n        let header_value = result.unwrap();\n        assert_eq!(header_value.as_str(), "valid-header-name");\n    }\n\n    #[test]\n    fn test_try_from_generic_invalid() {\n        let input = b"invalid\\x80header";\n        let result = HeaderValue::try_from_generic(input, |src| Bytes::copy_from_slice(src.as_ref()));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_generic_empty() {\n        let input = b"";\n        let result = HeaderValue::try_from_generic(input, |src| Bytes::copy_from_slice(src.as_ref()));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_from_generic_sensitive() {\n        let input = b"valid-sensitive-header";\n        let result = HeaderValue::try_from_generic(input, |src| Bytes::copy_from_slice(src.as_ref()));\n        assert!(result.is_ok());\n        let header_value = result.unwrap();\n        assert_eq!(header_value.as_str(), "valid-sensitive-header");\n        // Assuming is_sensitive is publicly accessible or can be tested via another means\n        // assert!(!header_value.is_sensitive); // Uncomment if is_sensitive is accessible\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582306, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=328, prompt_tokens=4343, total_tokens=4671, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQUs4wyOUMz2xUiCbNQlH6tkwUT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_valid() {\n        assert!(is_valid(b'A')); // Valid ASCII character\n        assert!(is_valid(b'\\t')); // Tab character\n        assert!(is_valid(b' ')); // Space character\n        assert!(!is_valid(b'\\n')); // Newline character\n        assert!(!is_valid(127)); // Delete character\n        assert!(!is_valid(31)); // Control character\n        assert!(is_valid(255)); // Valid extended ASCII character\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582314, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=123, prompt_tokens=160, total_tokens=283, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQZrqocmUez2ObroPqg3KCkdlUo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::header::value::is_visible_ascii;\n\n    #[test]\n    fn test_visible_ascii() {\n        assert!(is_visible_ascii(b'A')); // Visible\n        assert!(is_visible_ascii(b'z')); // Visible\n        assert!(is_visible_ascii(b' ')); // Space\n        assert!(is_visible_ascii(b'\\t')); // Tab\n        assert!(!is_visible_ascii(b'\\n')); // Newline\n        assert!(!is_visible_ascii(b'\\r')); // Carriage return\n        assert!(!is_visible_ascii(b'\\0')); // Null\n        assert!(!is_visible_ascii(b'!')); // Visible\n        assert!(!is_visible_ascii(b'@')); // Visible\n        assert!(!is_visible_ascii(b'\\x1f')); // Control character\n        assert!(!is_visible_ascii(b'\\x7f')); // Delete character\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582319, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=194, prompt_tokens=161, total_tokens=355, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQe4T08ql8vkj7utQKQUtQgN70V', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_eq_with_matching_method() {\n        let method_str = "GET";\n        let method = Method::GET;\n\n        assert!(method_str.eq(&method));\n    }\n\n    #[test]\n    fn test_eq_with_non_matching_method() {\n        let method_str = "POST";\n        let method = Method::GET;\n\n        assert!(!method_str.eq(&method));\n    }\n\n    #[test]\n    fn test_eq_with_different_method() {\n        let method_str = "PUT";\n        let method = Method::POST;\n\n        assert!(!method_str.eq(&method));\n    }\n\n    #[test]\n    fn test_eq_with_extension() {\n        let method_str = "CUSTOM";\n        let method = Method::from_bytes(method_str.as_bytes()).unwrap(); // Assuming it gets converted correctly\n\n        assert!(method_str.eq(&method));\n    }\n\n    #[test]\n    fn test_eq_with_empty() {\n        let method_str = "";\n        let method = Method::GET;\n\n        assert!(!method_str.eq(&method));\n    }\n\n    #[test]\n    fn test_eq_with_long_extension() {\n        let method_str = "LONGCUSTOMEXTENSION";\n        let method = Method::from_bytes(method_str.as_bytes()).unwrap(); // Assuming it gets converted correctly\n\n        assert!(method_str.eq(&method));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582324, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=294, prompt_tokens=2366, total_tokens=2660, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQnhvlGWWH7HbHlE9mKZPWX5H3A', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_eq_with_same_method() {\n        let method1 = Method::GET;\n        let method2 = Method::GET;\n        assert!(method1 == method2);\n    }\n\n    #[test]\n    fn test_eq_with_different_method() {\n        let method1 = Method::GET;\n        let method2 = Method::POST;\n        assert!(method1 != method2);\n    }\n\n    #[test]\n    fn test_eq_with_str_representation() {\n        let method = Method::POST;\n        assert!(method == "POST");\n    }\n\n    #[test]\n    fn test_eq_with_invalid_str() {\n        let method = Method::PUT;\n        assert!(method != "INVALID");\n    }\n\n    #[test]\n    fn test_eq_with_extension_inline() {\n        let method = Method::from_bytes(b"MYMETHOD").unwrap();\n        assert!(method == "MYMETHOD");\n    }\n\n    #[test]\n    fn test_eq_with_extension_allocated() {\n        let method = Method::from_bytes(b"ALLOCATEDMETHOD").unwrap();\n        assert!(method == "ALLOCATEDMETHOD");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582333, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=251, prompt_tokens=2363, total_tokens=2614, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQtxdRrtcUMPkjRTvHU1bjc3qFm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::error::Error;\n\n    #[test]\n    fn test_invalid_method_new() {\n        let invalid_method = method::InvalidMethod::new();\n        \n        // Check that we can create an InvalidMethod instance\n        assert!(invalid_method.is_err()); // Assuming we want to validate an error instance\n    }\n\n    #[test]\n    fn test_invalid_method_display() {\n        let invalid_method = method::InvalidMethod::new();\n        let display_output = format!("{}", invalid_method);\n\n        assert_eq!(display_output, "invalid HTTP method");\n    }\n\n    #[test]\n    fn test_invalid_method_debug() {\n        let invalid_method = method::InvalidMethod::new();\n        let debug_output = format!("{:?}", invalid_method);\n\n        assert_eq!(debug_output, "InvalidMethod");\n    }\n\n    #[test]\n    fn test_invalid_method_is_error() {\n        let invalid_method = method::InvalidMethod::new();\n\n        // Check that InvalidMethod implements Error\n        assert!(invalid_method.is_err()); // Assuming we have a way to check error\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582339, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=232, prompt_tokens=339, total_tokens=571, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmR0GJe1NDpKb8SXfV2KG8MDZiH4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::method::{Method, extension::AllocatedExtension, extension::InlineExtension};\n\n    #[test]\n    fn test_as_str_for_standard_methods() {\n        assert_eq!(Method::GET.as_str(), "GET");\n        assert_eq!(Method::POST.as_str(), "POST");\n        assert_eq!(Method::PUT.as_str(), "PUT");\n        assert_eq!(Method::DELETE.as_str(), "DELETE");\n        assert_eq!(Method::HEAD.as_str(), "HEAD");\n        assert_eq!(Method::OPTIONS.as_str(), "OPTIONS");\n        assert_eq!(Method::CONNECT.as_str(), "CONNECT");\n        assert_eq!(Method::TRACE.as_str(), "TRACE");\n        assert_eq!(Method::PATCH.as_str(), "PATCH");\n    }\n\n    #[test]\n    fn test_as_str_for_inline_extension() {\n        let inline_method = InlineExtension::new(b"MYMETHOD").unwrap();\n        let method = Method::from_bytes(b"MYMETHOD").unwrap();\n        assert_eq!(method.as_str(), inline_method.as_str());\n    }\n\n    #[test]\n    fn test_as_str_for_allocated_extension() {\n        let allocated_method = AllocatedExtension::new(b"AllocatedMethod").unwrap();\n        let method = Method::from_bytes(b"AllocatedMethod").unwrap();\n        assert_eq!(method.as_str(), allocated_method.as_str());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582346, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=289, prompt_tokens=2438, total_tokens=2727, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmR97jZvGB7uDM4WgvmlmlM5iOgn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::method::{Method, InvalidMethod};\n    use http::method::extension_inline;\n\n    #[test]\n    fn test_extension_inline_valid() {\n        let src = b"example_extension";\n        let result = extension_inline(src);\n        assert!(result.is_ok());\n        let method = result.unwrap();\n        assert_eq!(method, Method(ExtensionInline(InlineExtension::new(src).unwrap())));\n    }\n\n    #[test]\n    fn test_extension_inline_invalid() {\n        let src = b""; // Invalid input for InlineExtension\n        let result = extension_inline(src);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582355, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=143, prompt_tokens=166, total_tokens=309, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmREBXkLTcAxLQDl7gcHorkwj8C3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::method::{Method, InvalidMethod};\n\n    #[test]\n    fn test_from_bytes_get() {\n        let result = Method::from_bytes(b"GET");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Method::Get);\n    }\n\n    #[test]\n    fn test_from_bytes_post() {\n        let result = Method::from_bytes(b"POST");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Method::Post);\n    }\n\n    #[test]\n    fn test_from_bytes_invalid_method() {\n        let result = Method::from_bytes(b"");\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), InvalidMethod::new());\n    }\n\n    #[test]\n    fn test_from_bytes_extension_inline() {\n        let result = Method::from_bytes(b"FOOBAR");\n        assert!(result.is_ok());\n        match result.unwrap() {\n            Method::ExtensionInline(ref ext) => {\n                assert_eq!(ext, b"FOOBAR");\n            },\n            _ => panic!("Expected Inline extension"),\n        }\n    }\n\n    #[test]\n    fn test_from_bytes_long_extension() {\n        let long_method = b"LONGMETHODNAME";\n        let result = Method::from_bytes(long_method);\n        assert!(result.is_ok());\n        match result.unwrap() {\n            Method::ExtensionAllocated(ref ext) => {\n                assert_eq!(ext.as_slice(), long_method);\n            },\n            _ => panic!("Expected Allocated extension"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582360, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=323, prompt_tokens=414, total_tokens=737, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRNJb9ZuvzsOsx4TdF1gqqRGQLN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_is_idempotent() {\n        assert!(Method::PUT.is_idempotent());\n        assert!(Method::DELETE.is_idempotent());\n        assert!(Method::GET.is_idempotent());\n        assert!(Method::HEAD.is_idempotent());\n        assert!(Method::OPTIONS.is_idempotent());\n        assert!(Method::TRACE.is_idempotent());\n        assert!(Method::CONNECT.is_idempotent());\n        assert!(Method::PATCH.is_idempotent());\n        assert!(!Method::POST.is_idempotent());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582369, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=137, prompt_tokens=2423, total_tokens=2560, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRTKGzE2VWyXkyI1o1EYtXhUn0p', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n\n    #[test]\n    fn test_is_safe() {\n        assert!(Method::GET.is_safe());\n        assert!(Method::HEAD.is_safe());\n        assert!(Method::OPTIONS.is_safe());\n        assert!(Method::TRACE.is_safe());\n        assert!(!Method::POST.is_safe());\n        assert!(!Method::PUT.is_safe());\n        assert!(!Method::DELETE.is_safe());\n        assert!(!Method::CONNECT.is_safe());\n        assert!(!Method::PATCH.is_safe());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582375, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=121, prompt_tokens=2403, total_tokens=2524, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRYzK4fFru9uaxgmptcJjAsvXol', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::method::extension::AllocatedExtension;\n    use crate::InvalidMethod;\n\n    #[test]\n    fn test_as_str_valid_utf8() {\n        let input = b"valid utf8";\n        let allocated_extension = AllocatedExtension::new(input).expect("Failed to create AllocatedExtension");\n        let result = allocated_extension.as_str();\n        assert_eq!(result, "valid utf8");\n    }\n\n    #[test]\n    fn test_as_str_empty() {\n        let input = b"";\n        let allocated_extension = AllocatedExtension::new(input).expect("Failed to create AllocatedExtension");\n        let result = allocated_extension.as_str();\n        assert_eq!(result, "");\n    }\n\n    #[test]\n    fn test_as_str_with_special_characters() {\n        let input = b"hello, world! ";\n        let allocated_extension = AllocatedExtension::new(input).expect("Failed to create AllocatedExtension");\n        let result = allocated_extension.as_str();\n        assert_eq!(result, "hello, world! ");\n    }\n\n    #[test]\n    fn test_as_str_invalid_utf8() {\n        let input = b"\\xff\\xfe\\xfd"; // Invalid UTF-8 sequence\n        let result = AllocatedExtension::new(input);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582380, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=288, prompt_tokens=499, total_tokens=787, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRfjdsxdOH4j56U4BIgQD7xyMhO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::method::extension::AllocatedExtension;\n    use http::method::InvalidMethod;\n\n    #[test]\n    fn test_new_valid_input() {\n        let input: &[u8] = b"valid_extension";\n        let result = AllocatedExtension::new(input);\n        assert!(result.is_ok());\n        let allocated = result.unwrap();\n        assert_eq!(allocated.0.as_ref(), input);\n    }\n\n    #[test]\n    fn test_new_invalid_utf8() {\n        let input: &[u8] = &[0, 159, 146, 150]; // Invalid UTF-8 sequence\n        let result = AllocatedExtension::new(input);\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap(), InvalidMethod);\n    }\n\n    #[test]\n    fn test_new_empty_input() {\n        let input: &[u8] = b"";\n        let result = AllocatedExtension::new(input);\n        assert!(result.is_ok());\n        let allocated = result.unwrap();\n        assert_eq!(allocated.0.as_ref(), input);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582387, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=237, prompt_tokens=221, total_tokens=458, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRmthdeICcjFv0zhoqQ7QF4wIJt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::method::extension::InlineExtension;\n\n    #[test]\n    fn test_as_str() {\n        // Test with valid UTF-8 data\n        let bytes: &[u8] = b"GET";\n        let inline_ext = InlineExtension::new(bytes).expect("Failed to create InlineExtension");\n        assert_eq!(inline_ext.as_str(), "GET");\n\n        // Test with edge case: empty string\n        let empty_bytes: &[u8] = b"";\n        let empty_inline_ext = InlineExtension::new(empty_bytes).expect("Failed to create InlineExtension");\n        assert_eq!(empty_inline_ext.as_str(), "");\n\n        // Test with a valid UTF-8 string that is less than the maximum length\n        let long_bytes: &[u8] = b"POST";\n        let long_inline_ext = InlineExtension::new(long_bytes).expect("Failed to create InlineExtension");\n        assert_eq!(long_inline_ext.as_str(), "POST");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_as_str_invalid_utf8() {\n        // Test with invalid UTF-8 data, should panic or fail\n        let invalid_bytes: &[u8] = &[0, 159, 146, 150]; // Invalid UTF-8\n        let _ = InlineExtension::new(invalid_bytes).expect("Failed to create InlineExtension");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582394, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=300, prompt_tokens=483, total_tokens=783, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRvs4k1NcUTvait4GZfpANE7B03', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::method::extension::InlineExtension;\n    use http::method::InvalidMethod;\n\n    #[test]\n    fn test_new_success() {\n        let valid_input: &[u8] = b"GET";\n        let result = InlineExtension::new(valid_input);\n        assert!(result.is_ok());\n        let inline_extension = result.unwrap();\n        assert_eq!(inline_extension.1, valid_input.len() as u8);\n    }\n    \n    #[test]\n    fn test_new_invalid_utf8() {\n        let invalid_input: &[u8] = &[0, 159, 146, 150]; // invalid UTF-8 sequence\n        let result = InlineExtension::new(invalid_input);\n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_new_too_large_input() {\n        let large_input = vec![b\'A\'; InlineExtension::MAX + 1]; // Exceeds the MAX limit\n        let result = InlineExtension::new(&large_input);\n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_new_empty_input() {\n        let empty_input: &[u8] = b"";\n        let result = InlineExtension::new(empty_input);\n        assert!(result.is_ok());\n        let inline_extension = result.unwrap();\n        assert_eq!(inline_extension.1, 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582403, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=297, prompt_tokens=217, total_tokens=514, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmS3OvCVd5fryY84BmoER6wPlNIY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::method::extension::{write_checked, InvalidMethod};\n\n    #[test]\n    fn test_write_checked_valid() {\n        let src: &[u8] = b"GET";\n        let mut dst = [0u8; 3];\n        let result = write_checked(src, &mut dst);\n        assert!(result.is_ok());\n        assert_eq!(&dst, b"GET");\n    }\n\n    #[test]\n    fn test_write_checked_invalid() {\n        let src: &[u8] = b"INVALID_METHOD";\n        let mut dst = [0u8; 14];\n        let result = write_checked(src, &mut dst);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), "Invalid HTTP method");\n    }\n\n    #[test]\n    fn test_write_checked_partial_valid() {\n        let src: &[u8] = b"GET\\xFF";\n        let mut dst = [0u8; 4];\n        let result = write_checked(src, &mut dst);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), "Invalid HTTP method");\n    }\n\n    #[test]\n    fn test_write_checked_empty() {\n        let src: &[u8] = b"";\n        let mut dst = [0u8; 0];\n        let result = write_checked(src, &mut dst);\n        assert!(result.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582411, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=312, prompt_tokens=210, total_tokens=522, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmSDoT3LOf6cA3NIuQKhZVlITeon', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::request::Builder;\n    use http::Request;\n    use http::header::HeaderValue;\n    use http::Error;\n\n    #[test]\n    fn test_and_then_success() {\n        let builder = Builder::new();\n\n        let result = builder.and_then(|parts| {\n            assert!(parts.method.is_http());\n\n            // Modify parts here if needed\n            Ok(parts)\n        });\n        \n        assert!(result.inner.is_ok());\n    }\n\n    #[test]\n    fn test_and_then_failure() {\n        let builder = Builder::new();\n\n        let result = builder.and_then(|_parts| {\n            // Simulate an error\n            Err(Error::new("simulated error"))\n        });\n\n        assert!(result.inner.is_err());\n    }\n\n    #[test]\n    fn test_and_then_correct_method() {\n        let builder = Builder::new()\n            .method("GET");\n\n        let result = builder.and_then(|parts| {\n            assert_eq!(parts.method.as_str(), "GET");\n            Ok(parts)\n        });\n\n        assert!(result.inner.is_ok());\n    }\n\n    #[test]\n    fn test_and_then_modify_parts() {\n        let builder = Builder::new();\n\n        let result = builder.and_then(|mut parts| {\n            parts.method = http::Method::POST; // Change method\n            Ok(parts)\n        });\n\n        assert!(result.inner.is_ok());\n        assert_eq!(result.method_ref(), Some(&http::Method::POST));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582421, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=315, prompt_tokens=2541, total_tokens=2856, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmSQ7VgXtfefgbcqjvXAzHv714Dj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method, Version};\n\n    #[test]\n    fn test_body_success() {\n        let request = request::Builder::new()\n            .method(Method::GET)\n            .uri("http://example.com")\n            .body("Sample body")\n            .unwrap();\n\n        assert_eq!(request.method(), &Method::GET);\n        assert_eq!(request.uri(), "http://example.com");\n        assert_eq!(request.into_body(), "Sample body");\n    }\n\n    #[test]\n    fn test_body_with_invalid_method() {\n        let request = request::Builder::new()\n            .method("INVALID_METHOD")\n            .body("Sample body");\n        \n        assert!(request.is_err());\n    }\n\n    #[test]\n    fn test_body_with_invalid_uri() {\n        let request = request::Builder::new()\n            .uri("INVALID_URI")\n            .body("Sample body");\n        \n        assert!(request.is_err());\n    }\n\n    #[test]\n    fn test_body_with_no_body() {\n        let request = request::Builder::new()\n            .method(Method::POST)\n            .uri("http://example.com")\n            .body(())\n            .unwrap();\n\n        assert_eq!(request.method(), &Method::POST);\n        assert_eq!(request.uri(), "http://example.com");\n        assert_eq!(request.into_body(), ());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582434, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=290, prompt_tokens=2652, total_tokens=2942, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmSact3VGo5fpfQheaCWxNYbVy6c', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Request;\n\n    #[test]\n    fn test_extension_with_string() {\n        let req = Request::builder()\n            .extension("My Extension")\n            .body(())\n            .unwrap();\n\n        assert_eq!(req.extensions_ref().unwrap().get::<&\'static str>(), Some(&"My Extension"));\n    }\n\n    #[test]\n    fn test_extension_with_u32() {\n        let req = Request::builder()\n            .extension(42u32)\n            .body(())\n            .unwrap();\n\n        assert_eq!(req.extensions_ref().unwrap().get::<u32>(), Some(&42u32));\n    }\n\n    #[test]\n    fn test_multiple_extensions() {\n        let req = Request::builder()\n            .extension("My Extension")\n            .extension(5u32)\n            .body(())\n            .unwrap();\n\n        let extensions = req.extensions_ref().unwrap();\n        assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n        assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    }\n\n    #[test]\n    fn test_no_extension() {\n        let req = Request::builder()\n            .body(())\n            .unwrap();\n\n        assert!(req.extensions_ref().unwrap().get::<&\'static str>().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582444, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=278, prompt_tokens=8732, total_tokens=9010, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmSfsM77Mfx0EzDjjIXhrQ78IQ1M', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Extensions};\n\n    #[test]\n    fn test_extensions_mut() {\n        let mut req = Request::builder().extension("My Extension");\n        let mut extensions = req.extensions_mut().unwrap();\n        assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n        extensions.insert(5u32);\n        assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    }\n\n    #[test]\n    fn test_extensions_mut_on_error() {\n        let mut req = Request::builder(); // No extensions added yet\n        let extensions = req.extensions_mut();\n        assert!(extensions.is_none()); // Should return None\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582449, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=154, prompt_tokens=2634, total_tokens=2788, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmSltvR8DIEj5ZgXwGkzmz5w62lk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Extensions};\n\n    #[test]\n    fn test_extensions_ref_success() {\n        let req = Request::builder()\n            .extension("My Extension")\n            .extension(5u32)\n            .body(())\n            .unwrap();\n        \n        let extensions = req.extensions_ref().unwrap();\n        assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n        assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    }\n    \n    #[test]\n    fn test_extensions_ref_no_extensions() {\n        let req = Request::builder().body(()).unwrap();\n        assert!(req.extensions_ref().is_none());\n    }\n    \n    #[test]\n    fn test_extensions_ref_error_state() {\n        let req = Request::builder()\n            .body(Err("Some error"))\n            .unwrap_err();\n        \n        assert!(req.extensions_ref().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582455, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=202, prompt_tokens=2626, total_tokens=2828, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmSrnNQLj2R4hfTLYA0Bno8rg2x7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, header::HeaderValue};\n\n    #[test]\n    fn test_header_append() {\n        let req = Request::builder()\n            .header("Accept", "text/html")\n            .header("X-Custom-Foo", "bar")\n            .body(())\n            .unwrap();\n        \n        let headers = req.headers_ref().unwrap();\n        assert_eq!(headers["Accept"], "text/html");\n        assert_eq!(headers["X-Custom-Foo"], "bar");\n    }\n\n    #[test]\n    fn test_header_invalid_key() {\n        let req = Request::builder()\n            .header(vec![0, 159, 146, 150], "value");\n        assert!(req.headers_ref().is_none());\n    }\n\n    #[test]\n    fn test_header_invalid_value() {\n        let req = Request::builder()\n            .header("Key", "\\r\\nInvalid Value");\n        assert!(req.headers_ref().is_none());\n    }\n\n    #[test]\n    fn test_multiple_headers() {\n        let req = Request::builder()\n            .header("Header-One", "value1")\n            .header("Header-Two", "value2")\n            .header("Header-Three", "value3")\n            .body(())\n            .unwrap();\n        \n        let headers = req.headers_ref().unwrap();\n        assert_eq!(headers["Header-One"], "value1");\n        assert_eq!(headers["Header-Two"], "value2");\n        assert_eq!(headers["Header-Three"], "value3");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582461, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=328, prompt_tokens=2740, total_tokens=3068, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmT3G9wHTZWtsypC8DefORjVADa2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{header::HeaderValue, Request};\n\n    #[test]\n    fn test_headers_mut() {\n        let mut req = Request::builder();\n        {\n            let headers = req.headers_mut().unwrap();\n            headers.insert("Accept", HeaderValue::from_static("text/html"));\n            headers.insert("X-Custom-Foo", HeaderValue::from_static("bar"));\n        }\n        let headers = req.headers_ref().unwrap();\n        assert_eq!(headers["Accept"], "text/html");\n        assert_eq!(headers["X-Custom-Foo"], "bar");\n    }\n\n    #[test]\n    fn test_headers_mut_with_error() {\n        let req = Request::builder();\n        let headers = req.headers_mut();\n        assert!(headers.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582473, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=171, prompt_tokens=2664, total_tokens=2835, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmT9MMBJdrf9uvI8hRWkoSpcKKQ7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, header::{HeaderValue, HeaderName}};\n    \n    #[test]\n    fn test_headers_ref() {\n        let req = Request::builder()\n            .header("Accept", "text/html")\n            .header("X-Custom-Foo", "bar")\n            .body(())\n            .unwrap();\n        \n        let headers = req.headers_ref().unwrap();\n        assert_eq!(headers["Accept"], "text/html");\n        assert_eq!(headers["X-Custom-Foo"], "bar");\n    }\n\n    #[test]\n    fn test_headers_ref_with_error() {\n        let req = Request::builder()\n            .header("Invalid-Header", "Invalid\\r\\nValue")\n            .body(())\n            .unwrap_err();\n        \n        let req = req.ok();\n        assert!(req.headers_ref().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582479, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=185, prompt_tokens=2631, total_tokens=2816, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmTFvyqxaBxxRWGH6SqxYanS38LA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Method, Request};\n\n    #[test]\n    fn test_default_method() {\n        let req = Request::builder()\n            .body(())\n            .unwrap();\n        assert_eq!(req.method_ref(), Some(&Method::GET));\n    }\n\n    #[test]\n    fn test_set_method_post() {\n        let req = Request::builder()\n            .method("POST")\n            .body(())\n            .unwrap();\n        assert_eq!(req.method_ref(), Some(&Method::POST));\n    }\n\n    #[test]\n    fn test_set_method_invalid() {\n        let req = Request::builder()\n            .method("INVALID_METHOD")\n            .body(())\n            .unwrap_err();\n        assert!(req.is_err());\n    }\n\n    #[test]\n    fn test_chain_method_with_uri() {\n        let req = Request::builder()\n            .method("PUT")\n            .uri("https://example.com")\n            .body(())\n            .unwrap();\n        assert_eq!(req.method_ref(), Some(&Method::PUT));\n        assert_eq!(req.uri_ref().unwrap().to_string(), "https://example.com");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582485, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=241, prompt_tokens=2628, total_tokens=2869, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmTMV0avg3YH2tR0dp9VV9LZSVwv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import the necessary items from the parent module\n    use http::{Method, Request};\n\n    #[test]\n    fn test_method_ref_default() {\n        let req = Request::builder();\n        assert_eq!(req.method_ref(), Some(&Method::GET));\n    }\n\n    #[test]\n    fn test_method_ref_after_setting_method() {\n        let req = Request::builder().method("POST").body(()).unwrap();\n        assert_eq!(req.method_ref(), Some(&Method::POST));\n    }\n\n    #[test]\n    fn test_method_ref_with_invalid_method() {\n        let req = Request::builder().method("INVALID_METHOD").body(());\n        assert!(req.is_err());\n        let req = req.unwrap_err();\n        assert_eq!(req.method_ref(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582492, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=175, prompt_tokens=2605, total_tokens=2780, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmTS9tujZg5TRYH8uEU3z02GZCNO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method};\n\n    #[test]\n    fn test_builder_new_default() {\n        let builder = request::Builder::new();\n        assert!(builder.method_ref().is_none());\n        assert!(builder.uri_ref().is_none());\n        assert!(builder.version_ref().is_none());\n    }\n\n    #[test]\n    fn test_builder_default_method() {\n        let builder = request::Builder::new();\n        assert_eq!(builder.method_ref(), None);\n    }\n\n    #[test]\n    fn test_builder_default_uri() {\n        let builder = request::Builder::new();\n        assert_eq!(builder.uri_ref(), None);\n    }\n\n    #[test]\n    fn test_builder_default_version() {\n        let builder = request::Builder::new();\n        assert_eq!(builder.version_ref(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582498, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=180, prompt_tokens=2565, total_tokens=2745, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmTbuiM4hDu3zT38ZCMOzU7AsWQa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method, Uri, Error};\n\n    #[test]\n    fn test_uri_success() {\n        let req = Request::builder()\n            .uri("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n        assert_eq!(req.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n    }\n\n    #[test]\n    fn test_uri_default() {\n        let req = Request::builder()\n            .body(())\n            .unwrap();\n        assert_eq!(req.uri_ref().unwrap().to_string(), "/");\n    }\n\n    #[test]\n    fn test_uri_invalid() {\n        let result: Result<Request<()>, Error> = Request::builder()\n            .uri("invalid_uri")\n            .body(());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_uri_with_method() {\n        let req = Request::builder()\n            .method(Method::POST)\n            .uri("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n        assert_eq!(req.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n        assert_eq!(req.method_ref().unwrap(), &Method::POST);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582507, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=269, prompt_tokens=2626, total_tokens=2895, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmTlpIuxJW6FavqdpQC5BGxOCOBv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Uri};\n\n    #[test]\n    fn test_uri_ref_default() {\n        let req = Request::builder();\n        assert_eq!(req.uri_ref().unwrap().to_string(), "/");\n    }\n\n    #[test]\n    fn test_uri_ref_with_uri() {\n        let req = Request::builder()\n            .uri("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n        assert_eq!(req.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n    }\n\n    #[test]\n    fn test_uri_ref_with_invalid_uri() {\n        let req = Request::builder()\n            .uri("invalid_uri")\n            .body(())\n            .unwrap();\n        assert!(req.uri_ref().is_some());\n    }\n\n    #[test]\n    fn test_uri_ref_with_error() {\n        let req = Request::builder()\n            .method("POST")\n            .uri("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n        assert_eq!(req.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582517, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=246, prompt_tokens=2607, total_tokens=2853, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmTtABDqqPDwycylviJPFmtCC1kP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Version};\n\n    #[test]\n    fn test_version_http_2() {\n        let req = Request::builder()\n            .version(Version::HTTP_2)\n            .body(())\n            .unwrap();\n        assert_eq!(req.version_ref(), Some(&Version::HTTP_2));\n    }\n\n    #[test]\n    fn test_version_http_11_default() {\n        let req = Request::builder()\n            .body(())\n            .unwrap();\n        assert_eq!(req.version_ref(), Some(&Version::HTTP_11));\n    }\n\n    #[test]\n    fn test_version_http_3() {\n        let req = Request::builder()\n            .version(Version::HTTP_3)\n            .body(())\n            .unwrap();\n        assert_eq!(req.version_ref(), Some(&Version::HTTP_3));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582525, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=186, prompt_tokens=3085, total_tokens=3271, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmU0AxNyCsTDJ94AtfQFBsMmNiTH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Version};\n\n    #[test]\n    fn test_default_version_ref() {\n        let req = Request::builder();\n        assert_eq!(req.version_ref().unwrap(), &Version::HTTP_11);\n    }\n\n    #[test]\n    fn test_set_version_ref() {\n        let req = Request::builder().version(Version::HTTP_2);\n        assert_eq!(req.version_ref().unwrap(), &Version::HTTP_2);\n    }\n\n    #[test]\n    fn test_version_ref_none() {\n        let req = Request::builder().version(Version::HTTP_2);\n        let req_with_none = req.version(Version::HTTP_11);\n        assert_eq!(req_with_none.version_ref().unwrap(), &Version::HTTP_11);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582532, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=174, prompt_tokens=2611, total_tokens=2785, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmU7JOzQpS0lrlCQkmegI3o8VoGv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, HeaderMap, Method, Version, Extensions, Uri};\n\n    #[test]\n    fn test_parts_new() {\n        let parts = request::Parts::new();\n\n        // Checking default method\n        assert_eq!(parts.method, Method::default());\n\n        // Checking default uri\n        assert_eq!(parts.uri, Uri::default());\n\n        // Checking default version\n        assert_eq!(parts.version, Version::default());\n\n        // Checking default headers\n        assert!(parts.headers.is_empty());\n\n        // Checking default extensions\n        assert!(parts.extensions.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582539, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=135, prompt_tokens=16361, total_tokens=16496, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmUHriizqLMk3mBBCTJUm9usC69p', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust import to fit the test module structure\n    use http::{Request, Method, Version};\n    use http::header::HeaderValue;\n\n    #[test]\n    fn test_builder_method() {\n        let req = Request::builder()\n            .method("POST")\n            .body(())\n            .unwrap();\n        assert_eq!(req.method_ref().unwrap(), &Method::POST);\n    }\n\n    #[test]\n    fn test_builder_uri() {\n        let req = Request::builder()\n            .uri("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n        assert_eq!(req.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n    }\n\n    #[test]\n    fn test_builder_version() {\n        let req = Request::builder()\n            .version(Version::HTTP_2)\n            .body(())\n            .unwrap();\n        assert_eq!(req.version_ref().unwrap(), &Version::HTTP_2);\n    }\n\n    #[test]\n    fn test_builder_header() {\n        let req = Request::builder()\n            .header("Accept", "text/html")\n            .header("X-Custom-Foo", "bar")\n            .body(())\n            .unwrap();\n        let headers = req.headers_ref().unwrap();\n        assert_eq!(headers["Accept"], "text/html");\n        assert_eq!(headers["X-Custom-Foo"], "bar");\n    }\n\n    #[test]\n    fn test_builder_extensions() {\n        let req = Request::builder()\n            .extension("My Extension")\n            .body(())\n            .unwrap();\n        assert_eq!(req.extensions_ref().unwrap().get::<&\'static str>(), Some(&"My Extension"));\n    }\n\n    #[test]\n    fn test_builder_complete() {\n        let req = Request::builder()\n            .method("GET")\n            .uri("https://www.rust-lang.org/")\n            .header("Custom-Header", "value")\n            .version(Version::HTTP_11)\n            .extension(42u32)\n            .body(())\n            .unwrap();\n        assert_eq!(req.method_ref().unwrap(), &Method::GET);\n        assert_eq!(req.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n        assert_eq!(req.version_ref().unwrap(), &Version::HTTP_11);\n        assert_eq!(req.extensions_ref().unwrap().get::<u32>(), Some(&42u32));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582549, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=514, prompt_tokens=2612, total_tokens=3126, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmUZN2C3WnkZO1fv2vU0zScjx3Eg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Request;\n\n    #[test]\n    fn test_connect_method() {\n        let uri = "https://www.rust-lang.org/";\n        let request = Request::connect(uri)\n            .body(())\n            .unwrap();\n\n        assert_eq!(request.method_ref(), Some(&Method::CONNECT));\n        assert_eq!(request.uri_ref().unwrap().to_string(), uri);\n    }\n\n    #[test]\n    fn test_connect_method_invalid_uri() {\n        let uri = "invalid_uri";\n        let result = Request::connect(uri).body(());\n\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582567, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=136, prompt_tokens=2627, total_tokens=2763, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmUdFBiNATBzui1W4ea4aUOSBivy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method};\n\n    #[test]\n    fn test_delete_request() {\n        let request = Request::delete("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n\n        assert_eq!(request.method_ref().unwrap(), &Method::DELETE);\n        assert_eq!(request.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n    }\n\n    #[test]\n    fn test_delete_request_invalid_uri() {\n        let request = Request::delete("invalid_uri");\n        assert!(request.inner.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582571, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=132, prompt_tokens=2627, total_tokens=2759, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmUjNwidZkXc1UMUzSZpdqw4n6kx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method, Uri};\n\n    #[test]\n    fn test_get_request_builder() {\n        let uri = "https://www.rust-lang.org/";\n        let builder = Request::<()>::get(uri);\n        let request = builder.body(()).unwrap();\n\n        assert_eq!(request.method_ref(), Some(&Method::GET));\n        assert_eq!(request.uri_ref().unwrap().to_string(), uri);\n    }\n\n    #[test]\n    fn test_get_request_builder_with_invalid_uri() {\n        let uri = "invalid_uri";\n        let result = Request::<()>::get(uri);\n        assert!(result.uri::<String>().is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582577, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=150, prompt_tokens=2627, total_tokens=2777, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmUtNSmlUFRKJFM12GDbYNYjeuZ2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use http::{Request, Method};\n\n    #[test]\n    fn test_head_request_builder() {\n        let request = Request::head("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n\n        assert_eq!(request.method_ref(), Some(&Method::HEAD));\n        assert_eq!(request.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n    }\n\n    #[test]\n    fn test_head_request_builder_invalid_uri() {\n        let request = Request::head("invalid_uri");\n        assert!(request.uri_ref().is_none());\n    }\n\n    #[test]\n    fn test_head_request_builder_with_headers() {\n        let request = Request::head("https://www.rust-lang.org/")\n            .header("Custom-Header", "HeaderValue")\n            .body(())\n            .unwrap();\n\n        let headers = request.headers_ref().unwrap();\n        assert_eq!(headers["Custom-Header"], "HeaderValue");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582587, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=207, prompt_tokens=2627, total_tokens=2834, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmV1gUXsEtiv06RqpGZWvs5eO1HO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method};\n\n    #[test]\n    fn test_options_method() {\n        let request = Request::options("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n        assert_eq!(*request.method(), Method::OPTIONS);\n    }\n\n    #[test]\n    fn test_options_method_invalid_uri() {\n        let result = Request::options("invalid_uri")\n            .body(())\n            .unwrap_err();\n        // Add assertions based on expected error type if necessary\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582595, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=120, prompt_tokens=2640, total_tokens=2760, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmV6Us2fzRuloi1iBrG3iQBwgHKO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming the patch function is in the current scope\n    use http::{Request, Method};\n\n    #[test]\n    fn test_patch_request() {\n        let request = Request::patch("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n\n        assert_eq!(request.method_ref(), Some(&Method::PATCH));\n        assert_eq!(request.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n    }\n\n    #[test]\n    fn test_patch_request_with_invalid_uri() {\n        // Using an invalid URI type to test error handling\n        let result = Request::patch(12345); // Assuming an invalid type\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_patch_request_with_query() {\n        let request = Request::patch("https://www.rust-lang.org/?query=testing")\n            .body(())\n            .unwrap();\n\n        assert_eq!(request.method_ref(), Some(&Method::PATCH));\n        assert_eq!(request.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/?query=testing");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582600, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=244, prompt_tokens=2627, total_tokens=2871, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVHIAGPEDcTXriq7kgdRGgj1bjo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method};\n\n    #[test]\n    fn test_post_request_builder() {\n        let request = Request::post("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n\n        assert_eq!(request.method_ref(), Some(&Method::POST));\n        assert_eq!(request.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n    }\n\n    #[test]\n    fn test_post_request_error_handling() {\n        // Test with an invalid URI should fail\n        let result = Request::post("invalid_uri").body(()); // Should fail to create a valid request\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_post_request_with_method() {\n        let request = Request::post("https://www.rust-lang.org/")\n            .method("POST")\n            .body(())\n            .unwrap();\n\n        assert_eq!(request.method_ref(), Some(&Method::POST));\n    }\n\n    #[test]\n    fn test_post_request_with_missing_uri() {\n        let result = Request::post("").body(()); // Should fail to create a valid request\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_post_request_default_method() {\n        let request = Request::post("https://www.rust-lang.org/")\n            .body(())\n            .unwrap();\n\n        assert_eq!(request.method_ref(), Some(&Method::POST));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582611, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=309, prompt_tokens=2627, total_tokens=2936, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVSFRgfDaEdUXXwvo2et1hGAa0y', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request};\n\n    #[test]\n    fn test_put_method() {\n        let uri = "https://www.rust-lang.org/";\n        let request = Request::put(uri)\n            .body(())\n            .unwrap();\n\n        assert_eq!(request.method_ref().unwrap(), &Method::PUT);\n        assert_eq!(request.uri_ref().unwrap().to_string(), uri);\n    }\n\n    #[test]\n    fn test_put_method_invalid_uri() {\n        let uri = "invalid_uri";\n        let result = Request::put(uri).body(());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_put_method_with_additional_headers() {\n        let uri = "https://www.rust-lang.org/";\n        let request = Request::put(uri)\n            .header("Content-Type", "application/json")\n            .body(())\n            .unwrap();\n\n        let headers = request.headers_ref().unwrap();\n        assert_eq!(headers["Content-Type"], "application/json");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582622, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=218, prompt_tokens=2627, total_tokens=2845, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVZu3m37uuafISsdNssmIy44ujA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method};\n\n    #[test]\n    fn test_trace_request() {\n        let request = Request::trace("https://www.rust-lang.org/")\n            .body(())\n            .expect("Failed to create TRACE request");\n\n        assert_eq!(request.method_ref(), Some(&Method::TRACE));\n        assert_eq!(request.uri_ref().unwrap().to_string(), "https://www.rust-lang.org/");\n    }\n\n    #[test]\n    fn test_trace_request_invalid_uri() {\n        let request = Request::trace("invalid_uri")\n            .body(())\n            .unwrap_err();\n\n        assert!(request.is_err());\n    }\n\n    #[test]\n    fn test_trace_request_without_body() {\n        let request = Request::trace("https://www.rust-lang.org/")\n            .body(())\n            .expect("Failed to create TRACE request");\n\n        assert!(request.body().is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582629, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=199, prompt_tokens=2627, total_tokens=2826, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVgW6zhGhmZzKY7YzdFZCNs6EvB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Request;\n\n    #[test]\n    fn test_body_empty() {\n        let request: Request<String> = Request::default();\n        assert!(request.body().is_empty());\n    }\n\n    #[test]\n    fn test_body_not_empty() {\n        let body_content = String::from("Hello, World!");\n        let request: Request<String> = Request::builder().body(body_content.clone()).unwrap();\n        assert_eq!(request.body(), &body_content);\n    }\n\n    #[test]\n    fn test_body_reference() {\n        let body_content = String::from("Test body");\n        let request: Request<String> = Request::builder().body(body_content.clone()).unwrap();\n        let body_ref = request.body();\n        assert_eq!(body_ref, &body_content);\n    }\n\n    #[test]\n    fn test_body_change() {\n        let mut body_content = String::from("Initial body");\n        let mut request: Request<String> = Request::builder().body(body_content.clone()).unwrap();\n        \n        body_content.push_str(" - updated");\n        request = Request::builder().body(body_content.clone()).unwrap();\n        \n        assert_eq!(request.body(), &body_content);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582636, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=258, prompt_tokens=16361, total_tokens=16619, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVpUjPUgVdhNclj3D2GkDDv4muK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Request;\n\n    #[test]\n    fn test_body_mut() {\n        let mut request: Request<String> = Request::default();\n        request.body_mut().push_str("hello world");\n        assert_eq!(request.body(), "hello world");\n        assert!(!request.body().is_empty());\n    }\n\n    #[test]\n    fn test_body_mut_empty() {\n        let mut request: Request<String> = Request::default();\n        assert!(request.body().is_empty());\n        request.body_mut().push_str("Empty test");\n        assert!(!request.body().is_empty());\n        assert_eq!(request.body(), "Empty test");\n    }\n\n    #[test]\n    fn test_body_mut_multiple_pushes() {\n        let mut request: Request<String> = Request::default();\n        request.body_mut().push_str("First part.");\n        request.body_mut().push_str(" Second part.");\n        assert_eq!(request.body(), "First part. Second part.");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582645, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=213, prompt_tokens=16361, total_tokens=16574, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVwsBq34M4xtBIXZJi8drfb9fBz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Request;\n\n    #[test]\n    fn test_extensions_initially_empty() {\n        let request: Request<()> = Request::default();\n        assert!(request.extensions().get::<i32>().is_none());\n    }\n\n    #[test]\n    fn test_extensions_insert_and_get() {\n        let mut request: Request<()> = Request::default();\n        let mut extensions = request.extensions();\n        \n        extensions.insert(5i32);\n        assert_eq!(extensions.get::<i32>(), Some(&5i32));\n    }\n\n    #[test]\n    fn test_extensions_replace() {\n        let mut request: Request<()> = Request::default();\n        let mut extensions = request.extensions();\n\n        extensions.insert(5i32);\n        assert_eq!(extensions.get::<i32>(), Some(&5i32));\n\n        assert_eq!(extensions.insert(10i32), Some(5i32));\n        assert_eq!(extensions.get::<i32>(), Some(&10i32));\n    }\n\n    #[test]\n    fn test_extensions_remove() {\n        let mut request: Request<()> = Request::default();\n        let mut extensions = request.extensions();\n\n        extensions.insert(5i32);\n        assert_eq!(extensions.get::<i32>(), Some(&5i32));\n\n        assert_eq!(extensions.remove::<i32>(), Some(5i32));\n        assert!(extensions.get::<i32>().is_none());\n    }\n\n    #[test]\n    fn test_extensions_clear() {\n        let mut request: Request<()> = Request::default();\n        let mut extensions = request.extensions();\n\n        extensions.insert(5i32);\n        assert_eq!(extensions.get::<i32>(), Some(&5i32));\n        \n        extensions.clear();\n        assert!(extensions.get::<i32>().is_none());\n    }\n\n    #[test]\n    fn test_extensions_is_empty() {\n        let request: Request<()> = Request::default();\n        let extensions = request.extensions();\n        \n        assert!(extensions.is_empty());\n    }\n\n    #[test]\n    fn test_extensions_len() {\n        let mut request: Request<()> = Request::default();\n        let mut extensions = request.extensions();\n\n        assert_eq!(extensions.len(), 0);\n        extensions.insert(5i32);\n        assert_eq!(extensions.len(), 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582652, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=472, prompt_tokens=16361, total_tokens=16833, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmWANJ7tIhdp0n1iEuYBE2EXXfOY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Request;\n\n    #[test]\n    fn test_extensions_mut_insert_and_get() {\n        let mut request: Request<()> = Request::default();\n        request.extensions_mut().insert("hello");\n        assert_eq!(request.extensions().get::<&str>(), Some(&"hello"));\n    }\n\n    #[test]\n    fn test_extensions_mut_replace() {\n        let mut request: Request<()> = Request::default();\n        request.extensions_mut().insert("hello");\n        assert_eq!(request.extensions().get::<&str>(), Some(&"hello"));\n        request.extensions_mut().insert("world");\n        assert_eq!(request.extensions().get::<&str>(), Some(&"world"));\n    }\n\n    #[test]\n    fn test_extensions_mut_remove() {\n        let mut request: Request<()> = Request::default();\n        request.extensions_mut().insert("hello");\n        assert_eq!(request.extensions().get::<&str>(), Some(&"hello"));\n        request.extensions_mut().remove::<&str>();\n        assert_eq!(request.extensions().get::<&str>(), None);\n    }\n\n    #[test]\n    fn test_extensions_mut_clear() {\n        let mut request: Request<()> = Request::default();\n        request.extensions_mut().insert("hello");\n        request.extensions_mut().clear();\n        assert!(request.extensions().is_empty());\n    }\n\n    #[test]\n    fn test_extensions_mut_multiple_types() {\n        let mut request: Request<()> = Request::default();\n        request.extensions_mut().insert(42);\n        request.extensions_mut().insert("hello");\n        assert_eq!(request.extensions().get::<i32>(), Some(&42));\n        assert_eq!(request.extensions().get::<&str>(), Some(&"hello"));\n    }\n\n    #[test]\n    fn test_extensions_mut_type_replace() {\n        let mut request: Request<()> = Request::default();\n        request.extensions_mut().insert(42);\n        assert_eq!(request.extensions().get::<i32>(), Some(&42));\n        request.extensions_mut().insert(100);\n        assert_eq!(request.extensions().get::<i32>(), Some(&100));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582666, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=436, prompt_tokens=16361, total_tokens=16797, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmWNWL1sKGGYy6dIUdEnVohuumb1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, method::Method, header::HeaderMap, Extensions};\n\n    #[test]\n    fn test_request_from_parts() {\n        // Setup parts with a method and an empty header map\n        let parts = Parts {\n            method: Method::GET,\n            headers: HeaderMap::new(),\n            uri: "http://example.com".parse().unwrap(),\n            extensions: Extensions::new(),\n        };\n\n        // Body is an empty string\n        let body = "";\n\n        // Call the from_parts function\n        let request = Request::from_parts(parts, body);\n\n        // Check that the request has the right method\n        assert_eq!(request.method(), &Method::GET);\n\n        // Check that the request body is the same as provided\n        assert_eq!(request.body(), &body);\n        \n        // Check that the request uri is as expected\n        assert_eq!(request.uri(), "http://example.com");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582679, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=207, prompt_tokens=16361, total_tokens=16568, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmWVklszwgNkG389uzMBZw2yBgjB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, header::{CONTENT_TYPE, HEADER_NAME}};\n\n    #[test]\n    fn test_headers_initially_empty() {\n        let request: Request<()> = Request::default();\n        assert!(request.headers().is_empty());\n    }\n\n    #[test]\n    fn test_headers_not_empty_after_insert() {\n        let mut request: Request<()> = Request::default();\n        request.headers_mut().insert(CONTENT_TYPE, "application/json".parse().unwrap());\n        assert!(!request.headers().is_empty());\n    }\n\n    #[test]\n    fn test_headers_insert_multiple() {\n        let mut request: Request<()> = Request::default();\n        request.headers_mut().insert(CONTENT_TYPE, "application/json".parse().unwrap());\n        request.headers_mut().insert(CONTENT_TYPE, "text/plain".parse().unwrap());\n        let headers = request.headers();\n        assert_eq!(headers.get(CONTENT_TYPE).unwrap(), "text/plain");\n    }\n\n    #[test]\n    fn test_headers_after_clear() {\n        let mut request: Request<()> = Request::default();\n        request.headers_mut().insert(CONTENT_TYPE, "application/json".parse().unwrap());\n        request.headers_mut().clear();\n        assert!(request.headers().is_empty());\n    }\n\n    #[test]\n    fn test_headers_contains() {\n        let mut request: Request<()> = Request::default();\n        request.headers_mut().insert(CONTENT_TYPE, "application/json".parse().unwrap());\n        assert!(request.headers().contains_key(CONTENT_TYPE));\n        assert!(!request.headers().contains_key(HEADER_NAME));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582687, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=342, prompt_tokens=16361, total_tokens=16703, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmWgszRcj6yx9FWPlkKhzpZx8GV4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HOST, HeaderValue};\n    use http::Request;\n\n    #[test]\n    fn test_headers_mut_insert() {\n        let mut request: Request<()> = Request::default();\n        request.headers_mut().insert(HOST, HeaderValue::from_static("example.com"));\n        assert!(!request.headers().is_empty());\n        assert_eq!(request.headers().get(HOST).unwrap(), &HeaderValue::from_static("example.com"));\n    }\n\n    #[test]\n    fn test_headers_mut_multiple_inserts() {\n        let mut request: Request<()> = Request::default();\n        request.headers_mut().insert(HOST, HeaderValue::from_static("example.com"));\n        request.headers_mut().insert(HOST, HeaderValue::from_static("test.com"));\n        assert_eq!(request.headers().get(HOST).unwrap(), &HeaderValue::from_static("test.com"));\n    }\n\n    #[test]\n    fn test_headers_mut_empty_headers() {\n        let mut request: Request<()> = Request::default();\n        assert!(request.headers().is_empty());\n    }\n\n    #[test]\n    fn test_headers_mut_update_header() {\n        let mut request: Request<()> = Request::default();\n        request.headers_mut().insert(HOST, HeaderValue::from_static("example.com"));\n        request.headers_mut().insert(HOST, HeaderValue::from_static("updated.com"));\n        assert_eq!(request.headers().get(HOST).unwrap(), &HeaderValue::from_static("updated.com"));\n    }\n\n    #[test]\n    fn test_headers_mut_no_header() {\n        let request: Request<()> = Request::default();\n        assert!(request.headers().get(HOST).is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582698, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=358, prompt_tokens=16361, total_tokens=16719, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmX3NI9RfJIv6koJTfyt5kJMFwtN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Request;\n\n    #[test]\n    fn test_into_body_with_integer() {\n        let request = Request::new(10);\n        let body = request.into_body();\n        assert_eq!(body, 10);\n    }\n\n    #[test]\n    fn test_into_body_with_bytes() {\n        let request = Request::new(bytes::Bytes::from_static(b"Hello, world!"));\n        let body = request.into_body();\n        assert_eq!(body.to_vec(), b"Hello, world!".to_vec());\n    }\n\n    #[test]\n    fn test_into_body_with_bytes_with_clone() {\n        let data = bytes::Bytes::from_static(b"Hello, Clone!");\n        let request = Request::new(data.clone());\n        let body = request.into_body();\n        assert_eq!(body.to_vec(), b"Hello, Clone!".to_vec());\n    }\n\n    #[test]\n    fn test_into_body_with_bytess_str() {\n        let request = Request::new(byte_str::ByteStr::from_static("Hello, ByteStr!"));\n        let body = request.into_body();\n        assert_eq!(body.deref(), "Hello, ByteStr!");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582721, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=254, prompt_tokens=16361, total_tokens=16615, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmXD8CJSxWhb0wS6UZu2MfQPYbi3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method};\n\n    #[test]\n    fn test_into_parts() {\n        // Create a new request with a body\n        let request = Request::builder()\n            .method(Method::GET)\n            .body(())\n            .unwrap();\n\n        // Call the into_parts method\n        let (parts, body) = request.into_parts();\n\n        // Check that the method is GET\n        assert_eq!(parts.method, Method::GET);\n        // Check that the body is of the expected type, here it's unit type ()\n        assert_eq!(body, ());\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582731, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=134, prompt_tokens=16361, total_tokens=16495, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmXMnJUgVaVpNDljXGbfwJ25U9Zl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, header::{CONTENT_TYPE, USER_AGENT}};\n\n    #[test]\n    fn test_map_request_body_to_bytes() {\n        let request = Request::builder()\n            .header(CONTENT_TYPE, "application/json")\n            .header(USER_AGENT, "test")\n            .body("some string")\n            .unwrap();\n\n        let mapped_request: Request<&[u8]> = request.map(|b| {\n            assert_eq!(b, "some string");\n            b.as_bytes()\n        });\n\n        assert_eq!(mapped_request.body(), &"some string".as_bytes());\n        assert_eq!(mapped_request.headers().get(CONTENT_TYPE).unwrap(), "application/json");\n        assert_eq!(mapped_request.headers().get(USER_AGENT).unwrap(), "test");\n    }\n\n    #[test]\n    fn test_map_request_body_to_empty() {\n        let request = Request::builder()\n            .body("")\n            .unwrap();\n\n        let mapped_request: Request<&[u8]> = request.map(|b| {\n            assert_eq!(b, "");\n            b.as_bytes()\n        });\n\n        assert_eq!(mapped_request.body(), &b""[..]);\n    }\n\n    #[test]\n    fn test_map_request_body_changes_type() {\n        let request = Request::builder()\n            .body("body content")\n            .unwrap();\n\n        let mapped_request: Request<ByteStr> = request.map(|b| {\n            assert_eq!(b, "body content");\n            ByteStr::from(b)\n        });\n\n        assert_eq!(mapped_request.body().as_ref(), "body content");\n    }\n\n    #[test]\n    fn test_map_request_body_to_bytes_with_assert() {\n        let request = Request::builder()\n            .body("test body")\n            .unwrap();\n\n        let num_calls = std::sync::Arc::new(std::sync::Mutex::new(0));\n        let num_calls_clone = num_calls.clone();\n\n        let mapped_request: Request<&[u8]> = request.map(|b| {\n            let mut count = num_calls_clone.lock().unwrap();\n            *count += 1;\n            assert_eq!(b, "test body");\n            b.as_bytes()\n        });\n\n        assert_eq!(*num_calls.lock().unwrap(), 1);\n        assert_eq!(mapped_request.body(), &b"test body"[..]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582740, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=491, prompt_tokens=16361, total_tokens=16852, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmXamiid4gLvYLNEqhcCSsX9oHnV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n    use http::request::Request;\n\n    #[test]\n    fn test_method_default() {\n        let request: Request<()> = Request::default();\n        assert_eq!(*request.method(), Method::GET);\n    }\n    \n    #[test]\n    fn test_method_custom() {\n        let mut request = Request::default();\n        let custom_method = Method::from_bytes(b"POST").unwrap();\n        request.method = custom_method;\n        assert_eq!(*request.method(), Method::from_bytes(b"POST").unwrap());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582754, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=129, prompt_tokens=16361, total_tokens=16490, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmXgkKSTknKRsHGFwwSA7TKY5SCf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Method;\n    use http::request::Request;\n\n    #[test]\n    fn test_method_mut() {\n        let mut request: Request<()> = Request::default();\n        *request.method_mut() = Method::PUT;\n        assert_eq!(*request.method(), Method::PUT);\n    }\n\n    #[test]\n    fn test_method_mut_default() {\n        let mut request: Request<()> = Request::default();\n        assert_eq!(*request.method(), Method::GET); // Default method\n        *request.method_mut() = Method::POST;\n        assert_eq!(*request.method(), Method::POST);\n    }\n\n    #[test]\n    fn test_method_mut_multiple_calls() {\n        let mut request: Request<()> = Request::default();\n        *request.method_mut() = Method::DELETE;\n        assert_eq!(*request.method(), Method::DELETE);\n        *request.method_mut() = Method::GET;\n        assert_eq!(*request.method(), Method::GET);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582760, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=216, prompt_tokens=16361, total_tokens=16577, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmXvuzkgY382ETAlfuNZ3hb6ScvQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Method};\n\n    #[test]\n    fn test_request_new() {\n        let body = "hello world";\n        let request: Request<&str> = Request::new(body);\n\n        assert_eq!(*request.method(), Method::GET);\n        assert_eq!(*request.body(), body);\n    }\n\n    #[test]\n    fn test_request_new_with_different_body() {\n        let body = "another body";\n        let request: Request<&str> = Request::new(body);\n\n        assert_eq!(*request.method(), Method::GET);\n        assert_eq!(*request.body(), body);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582775, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=142, prompt_tokens=16361, total_tokens=16503, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmY4byTqOqZ4BrV2sxPWwQ02nW8w', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Uri};\n\n    #[test]\n    fn test_uri_default_request() {\n        let request: Request<()> = Request::default();\n        assert_eq!(*request.uri(), *"/");\n    }\n\n    #[test]\n    fn test_uri_custom_request() {\n        let custom_uri: Uri = "http://example.com".parse().unwrap();\n        let mut request = Request::default();\n        request.head.uri = custom_uri.clone(); // Assuming a way to directly set uri\n        assert_eq!(*request.uri(), custom_uri);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582784, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=129, prompt_tokens=16361, total_tokens=16490, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYAogUBkSxnNROIIGQd620FavoX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Uri};\n\n    #[test]\n    fn test_uri_mut() {\n        let mut request: Request<()> = Request::default();\n        *request.uri_mut() = "http://example.com/hello".parse::<Uri>().unwrap();\n        assert_eq!(request.uri().to_string(), "http://example.com/hello");\n    }\n\n    #[test]\n    fn test_uri_mut_with_invalid_uri() {\n        let mut request: Request<()> = Request::default();\n        let result = std::panic::catch_unwind(|| {\n            *request.uri_mut() = "invalid_uri".parse::<Uri>().unwrap();\n        });\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582790, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=155, prompt_tokens=16361, total_tokens=16516, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYIsAAnrb0uney8LGng8rMZUIj3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Request, Version};\n\n    #[test]\n    fn test_request_version_default() {\n        let request: Request<()> = Request::default();\n        assert_eq!(request.version(), Version::HTTP_11);\n    }\n\n    #[test]\n    fn test_request_version_custom() {\n        let mut request: Request<()> = Request::default();\n        request.head.version = Version::HTTP_10; // Assuming we have access to modify the head/version directly\n        assert_eq!(request.version(), Version::HTTP_10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582798, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=124, prompt_tokens=16361, total_tokens=16485, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYNqqE2EBIkzeeu52DgNa8keoJH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Request;\n    use http::version::Version;\n\n    #[test]\n    fn test_version_mut() {\n        let mut request: Request<()> = Request::default();\n        *request.version_mut() = Version::HTTP_2;\n        assert_eq!(request.version(), Version::HTTP_2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582803, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=81, prompt_tokens=16361, total_tokens=16442, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYTSP42wtikUFdrTjoU3KC6Qeta', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{response::Builder, Response, StatusCode};\n    use std::convert::TryInto;\n\n    #[test]\n    fn test_and_then_success() {\n        let builder = Builder::new();\n\n        let result = builder.and_then(|parts| {\n            // Modify parts and return\n            parts.status = StatusCode::OK;\n            Ok(parts)\n        });\n\n        assert!(result.inner.is_ok());\n    }\n\n    #[test]\n    fn test_and_then_failure() {\n        let builder = Builder::new();\n\n        let result = builder.and_then(|parts| {\n            // Simulate an error\n            Err("Some error".into())\n        });\n\n        assert!(result.inner.is_err());\n    }\n\n    #[test]\n    fn test_and_then_with_status() {\n        let builder = Builder::new()\n            .status(200);\n\n        let result = builder.and_then(|parts| {\n            // Ensure that parts can be modified\n            assert_eq!(parts.status, StatusCode::OK);\n            Ok(parts)\n        });\n\n        assert!(result.inner.is_ok());\n    }\n\n    #[test]\n    fn test_and_then_with_header() {\n        let builder = Builder::new()\n            .header("X-Custom-Header", "value");\n\n        let result = builder.and_then(|parts| {\n            // Ensure headers are available and valid\n            assert!(parts.headers.contains("X-Custom-Header"));\n            Ok(parts)\n        });\n\n        assert!(result.inner.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582809, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=317, prompt_tokens=2021, total_tokens=2338, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYbasFTsCmVtaX83VlGMenRb0RU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, StatusCode};\n\n    #[test]\n    fn test_body_with_unit() {\n        let response = response::Builder::new()\n            .status(200)\n            .body(())\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n    }\n\n    #[test]\n    fn test_body_with_string() {\n        let response = response::Builder::new()\n            .status(200)\n            .body("Hello, World!")\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n        assert_eq!(response.body(), "Hello, World!");\n    }\n\n    #[test]\n    fn test_body_with_error() {\n        let result = response::Builder::new()\n            .header("Invalid-Header", "Invalid\\r\\n")\n            .body(())\n            .err().is_some();\n        assert!(result);\n    }\n\n    #[test]\n    fn test_body_with_custom_struct() {\n        #[derive(Debug)]\n        struct CustomBody {\n            content: String,\n        }\n\n        let body = CustomBody { content: String::from("Hello, custom body!") };\n        let response = response::Builder::new()\n            .status(200)\n            .body(body)\n            .unwrap();\n        assert_eq!(response.status(), StatusCode::OK);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582817, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=283, prompt_tokens=2132, total_tokens=2415, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYhd9DIIoIu9Kwx3bJ0G7nOI29A', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, header::HeaderName};\n\n    #[test]\n    fn test_extension_with_str() {\n        let response = Response::builder()\n            .extension("My Extension")\n            .body(())\n            .unwrap();\n\n        assert_eq!(response.extensions().get::<&\'static str>(), Some(&"My Extension"));\n    }\n\n    #[test]\n    fn test_extension_with_bytes() {\n        let response = Response::builder()\n            .extension(Bytes::from_static(b"My Bytes Extension"))\n            .body(())\n            .unwrap();\n\n        assert_eq!(response.extensions().get::<Bytes>(), Some(&Bytes::from_static(b"My Bytes Extension")));\n    }\n\n    #[test]\n    fn test_extension_with_header_name() {\n        let header_name = HeaderName::from_static("X-Custom-Header");\n        let response = Response::builder()\n            .extension(header_name.clone())\n            .body(())\n            .unwrap();\n\n        assert_eq!(response.extensions().get::<HeaderName>(), Some(&header_name));\n    }\n\n    #[test]\n    fn test_multiple_extensions() {\n        let response = Response::builder()\n            .extension("First Extension")\n            .extension(42u32)\n            .body(())\n            .unwrap();\n\n        assert_eq!(response.extensions().get::<&\'static str>(), Some(&"First Extension"));\n        assert_eq!(response.extensions().get::<u32>(), Some(&42u32));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582823, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=302, prompt_tokens=8212, total_tokens=8514, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYsyuoFPcuNEY9dZs1ValMhml7u', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{response::Builder, Extensions};\n\n    #[test]\n    fn test_extensions_mut() {\n        let mut builder = Builder::new().extension("My Extension");\n        let mut extensions = builder.extensions_mut().unwrap();\n        \n        assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n        extensions.insert(5u32);\n        assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    }\n\n    #[test]\n    fn test_extensions_mut_none_when_error() {\n        // Simulate a builder error\n        let mut builder = Builder::default();\n        // Simulate some failure (in actual use, this would depend on real error conditions)\n        builder = builder.status(300); // This is a valid status, but used here as placeholder for error state\n        let extensions_mut = builder.extensions_mut();\n        assert!(extensions_mut.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582834, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=200, prompt_tokens=2114, total_tokens=2314, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYvvzbt8syW93dFrcN9jH1aXyj3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Response;\n\n    #[test]\n    fn test_extensions_ref() {\n        let res = Response::builder()\n            .extension("My Extension")\n            .extension(5u32)\n            .body(())\n            .unwrap();\n        let extensions = res.extensions_ref().unwrap();\n        assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n        assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    }\n\n    #[test]\n    fn test_extensions_ref_none() {\n        let res = Response::builder().body(()).unwrap();\n        assert!(res.extensions_ref().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582837, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=147, prompt_tokens=2106, total_tokens=2253, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZ0uRTQTxuat5rfct5uAHttsWcA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n    use http::response::Builder;\n\n    #[test]\n    fn test_header() {\n        let response = Builder::new()\n            .header("Content-Type", "text/html")\n            .header("X-Custom-Foo", "bar")\n            .header("content-length", 0)\n            .body(())\n            .unwrap();\n\n        let headers = response.headers_ref().unwrap();\n        assert_eq!(headers["Content-Type"], "text/html");\n        assert_eq!(headers["X-Custom-Foo"], "bar");\n        assert_eq!(headers["content-length"], "0");\n    }\n\n    #[test]\n    fn test_invalid_header_name() {\n        let builder = Builder::new().header("Invalid-Header\\r\\n", "value");\n        assert!(builder.body(()).is_err());\n    }\n\n    #[test]\n    fn test_invalid_header_value() {\n        let builder = Builder::new().header("X-Custom-Foo", "Invalid-Value\\r\\n");\n        assert!(builder.body(()).is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582842, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=235, prompt_tokens=2232, total_tokens=2467, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZ9UAkAmr42f2VkzIwv7QgK7bFX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderValue;\n    use http::response::Builder;\n\n    #[test]\n    fn test_headers_mut() {\n        let mut res = Builder::new();\n        {\n            let headers = res.headers_mut().unwrap();\n            headers.insert("Accept", HeaderValue::from_static("text/html"));\n            headers.insert("X-Custom-Foo", HeaderValue::from_static("bar"));\n        }\n        let headers = res.headers_ref().unwrap();\n        assert_eq!(headers["Accept"], "text/html");\n        assert_eq!(headers["X-Custom-Foo"], "bar");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582851, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=139, prompt_tokens=2157, total_tokens=2296, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZEJTt9t5TYbxyqowtCFd5XT6WL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, header::HeaderValue};\n\n    #[test]\n    fn test_headers_ref() {\n        let res = Response::builder()\n            .header("Accept", "text/html")\n            .header("X-Custom-Foo", "bar")\n            .body(())\n            .unwrap();\n\n        let headers = res.headers_ref().unwrap();\n        assert_eq!(headers["Accept"], "text/html");\n        assert_eq!(headers["X-Custom-Foo"], "bar");\n    }\n\n    #[test]\n    fn test_headers_ref_when_builder_has_error() {\n        let res = Response::builder()\n            .header("Invalid-Header", "text/html\\r\\n")\n            .body(())\n            .unwrap_err();\n\n        let headers = res.headers_ref();\n        assert!(headers.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582856, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=179, prompt_tokens=2120, total_tokens=2299, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZKv57kiJydKpvIbWezOqH7D1xx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{response::Builder, Response};\n\n    #[test]\n    fn test_builder_new() {\n        let builder = Builder::new();\n        assert!(builder.headers_ref().is_none());\n        assert!(builder.extensions_ref().is_none());\n    }\n\n    #[test]\n    fn test_builder_default_status() {\n        let response = Builder::new().status(200).body(()).unwrap();\n        assert_eq!(response.status(), 200);\n    }\n\n    #[test]\n    fn test_builder_with_extension() {\n        let response = Builder::new()\n            .extension("Test Extension")\n            .body(())\n            .unwrap();\n        assert_eq!(response.extensions_ref().unwrap().get::<&str>(), Some(&"Test Extension"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582862, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=166, prompt_tokens=2053, total_tokens=2219, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZZQbYwvo35ZMS4E6fVepbzTdHP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{StatusCode, Response};\n\n    #[test]\n    fn test_status_set_200() {\n        let response = Builder::new()\n            .status(200)\n            .body(())\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::OK);\n    }\n\n    #[test]\n    fn test_status_set_404() {\n        let response = Builder::new()\n            .status(404)\n            .body(())\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::NOT_FOUND);\n    }\n\n    #[test]\n    fn test_status_set_500() {\n        let response = Builder::new()\n            .status(500)\n            .body(())\n            .unwrap();\n\n        assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);\n    }\n\n    #[test]\n    fn test_status_invalid() {\n        let result = Builder::new()\n            .status(999) // Invalid status code\n            .body(());\n            \n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582877, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=221, prompt_tokens=2104, total_tokens=2325, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZfyV4o1d3fpCC8bhiUfxvrulDr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::response::Builder;\n    use http::Version;\n\n    #[test]\n    fn test_version_sets_http_version() {\n        let response = Builder::new()\n            .version(Version::HTTP_2)\n            .body(())\n            .unwrap();\n        assert_eq!(response.head.version, Version::HTTP_2);\n    }\n\n    #[test]\n    fn test_default_version() {\n        let response = Builder::new()\n            .body(())\n            .unwrap();\n        assert_eq!(response.head.version, Version::HTTP_11);\n    }\n\n    #[test]\n    fn test_version_changes_after_setting() {\n        let builder = Builder::new();\n        let response = builder\n            .version(Version::HTTP_3)\n            .body(())\n            .unwrap();\n        assert_eq!(response.head.version, Version::HTTP_3);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582883, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=189, prompt_tokens=2565, total_tokens=2754, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZldDtp0Q9Dj82tl6mbhtvAzwlP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{StatusCode, Version, HeaderValue};\n\n    #[test]\n    fn test_parts_new() {\n        let parts = Parts::new();\n\n        // Check default status\n        assert_eq!(parts.status, StatusCode::OK);\n\n        // Check default version\n        assert_eq!(parts.version, Version::default());\n\n        // Check default headers\n        assert!(parts.headers.is_empty());\n\n        // Check default extensions\n        assert!(parts.extensions.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582889, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=112, prompt_tokens=16361, total_tokens=16473, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZr17mZKj9EGORwg0hbz0ay1eAB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, StatusCode};\n\n    #[test]\n    fn test_builder_creates_response() {\n        let response = Response::builder()\n            .status(200)\n            .header("X-Custom-Foo", "Bar")\n            .body(())\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::OK);\n        assert_eq!(response.headers()["X-Custom-Foo"], "Bar");\n    }\n\n    #[test]\n    fn test_builder_with_no_headers() {\n        let response = Response::builder()\n            .body(())\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::OK);\n        assert!(response.headers().is_empty());\n    }\n\n    #[test]\n    fn test_builder_with_custom_status() {\n        let response = Response::builder()\n            .status(404)\n            .body(())\n            .unwrap();\n        \n        assert_eq!(response.status(), StatusCode::NOT_FOUND);\n    }\n\n    #[test]\n    fn test_builder_with_extensions() {\n        let response = Response::builder()\n            .extension("My Extension")\n            .body(())\n            .unwrap();\n        \n        assert_eq!(response.extensions().get::<&str>(), Some(&"My Extension"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582895, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=264, prompt_tokens=2079, total_tokens=2343, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcma0dXX10vqUEYLBGBsw3qgokT0U', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import the items from the parent module\n    use http::{Response, StatusCode};\n\n    #[test]\n    fn test_body_empty() {\n        let response: Response<String> = Response::default();\n        assert!(response.body().is_empty());\n    }\n\n    #[test]\n    fn test_body_content() {\n        let response = Response::new("hello world".to_string());\n        assert_eq!(response.body(), &"hello world".to_string());\n    }\n\n    #[test]\n    fn test_body_mutability() {\n        let mut response = Response::new("initial".to_string());\n        let body = response.body();\n        assert_eq!(body, &"initial".to_string());\n\n        // Since body is a reference, we cannot mutate it directly\n        // but we can replace the body and check the new value\n        response = Response::new("updated".to_string());\n        assert_eq!(response.body(), &"updated".to_string());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582904, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=213, prompt_tokens=16361, total_tokens=16574, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcma7gYio8sxcuxwSXbXZWr12Q7hc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, StatusCode};\n\n    #[test]\n    fn test_body_mut() {\n        // Create a new default response\n        let mut response: Response<String> = Response::default();\n\n        // Modify the body using body_mut\n        response.body_mut().push_str("hello world");\n\n        // Assert that the body is not empty\n        assert!(!response.body().is_empty());\n        assert_eq!(response.body(), "hello world");\n    }\n\n    #[test]\n    fn test_body_mut_empty() {\n        // Create a new default response\n        let mut response: Response<String> = Response::default();\n\n        // Assert that the body is empty at creation\n        assert!(response.body().is_empty());\n\n        // Modify the body using body_mut\n        response.body_mut().push_str("");\n\n        // Assert that the body is still empty\n        assert!(response.body().is_empty());\n    }\n\n    #[test]\n    fn test_body_mut_overwrite() {\n        // Create a new default response\n        let mut response: Response<String> = Response::default();\n\n        // Modify the body using body_mut\n        response.body_mut().push_str("hello");\n\n        // Modify the body again using body_mut\n        response.body_mut().clear();\n        response.body_mut().push_str("world");\n\n        // Assert that the body is "world"\n        assert_eq!(response.body(), "world");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582911, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=303, prompt_tokens=16361, total_tokens=16664, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmaFQQb2QFRAfIVeR8hUFKHMQaMD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, Extensions};\n\n    #[test]\n    fn test_extensions_empty() {\n        let response: Response<()> = Response::default();\n        assert!(response.extensions().is_empty());\n    }\n\n    #[test]\n    fn test_extensions_insert_and_get() {\n        let mut response: Response<()> = Response::default();\n        response.extensions_mut().insert(123i32);\n        assert_eq!(response.extensions().get::<i32>(), Some(&123i32));\n    }\n\n    #[test]\n    fn test_extensions_overwrite() {\n        let mut response: Response<()> = Response::default();\n        response.extensions_mut().insert(123i32);\n        response.extensions_mut().insert(456i32);\n        assert_eq!(response.extensions().get::<i32>(), Some(&456i32));\n    }\n\n    #[test]\n    fn test_extensions_remove() {\n        let mut response: Response<()> = Response::default();\n        response.extensions_mut().insert(123i32);\n        assert_eq!(response.extensions_mut().remove::<i32>(), Some(123i32));\n        assert!(response.extensions().get::<i32>().is_none());\n    }\n\n    #[test]\n    fn test_extensions_clear() {\n        let mut response: Response<()> = Response::default();\n        response.extensions_mut().insert(123i32);\n        response.extensions_mut().clear();\n        assert!(response.extensions().get::<i32>().is_none());\n    }\n\n    #[test]\n    fn test_extensions_len() {\n        let mut response: Response<()> = Response::default();\n        assert_eq!(response.extensions().len(), 0);\n        response.extensions_mut().insert(123i32);\n        assert_eq!(response.extensions().len(), 1);\n    }\n\n    #[test]\n    fn test_extensions_is_empty() {\n        let response: Response<()> = Response::default();\n        assert!(response.extensions().is_empty());\n        response.extensions_mut().insert(123i32);\n        assert!(!response.extensions().is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582919, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=420, prompt_tokens=16361, total_tokens=16781, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmaQkiPZOI7CllO38iLikc6QMsjz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Extensions, Response};\n\n    #[test]\n    fn test_extensions_mut() {\n        let mut response: Response<()> = Response::default();\n        \n        // Mutably insert a value into extensions\n        response.extensions_mut().insert("hello");\n        \n        // Assert that the value is retrievable from extensions\n        assert_eq!(response.extensions().get::<&str>(), Some(&"hello"));\n        \n        // Insert a different value\n        response.extensions_mut().insert("world");\n        \n        // Assert that the value is updated\n        assert_eq!(response.extensions().get::<&str>(), Some(&"world"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582930, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=143, prompt_tokens=16361, total_tokens=16504, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmaXVDRqc9hhsphKKp0t1sRJs6OB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::Response;\n    use http::{Parts, StatusCode};\n\n    #[test]\n    fn test_from_parts() {\n        let mut parts = Parts::new();\n        parts.status = StatusCode::OK;\n        let body = "hello world";\n\n        let response = Response::from_parts(parts.clone(), body.to_string());\n\n        assert_eq!(response.head.status, StatusCode::OK);\n        assert_eq!(response.body, "hello world");\n\n        parts.status = StatusCode::BAD_REQUEST;\n        let response_changed = Response::from_parts(parts, body.to_string());\n\n        assert_eq!(response_changed.head.status, StatusCode::BAD_REQUEST);\n        assert_eq!(response_changed.body, "hello world");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582937, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=157, prompt_tokens=16361, total_tokens=16518, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmacTJfxbgvJIiUvL6bGtNj8nSGI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, header::{CONTENT_LENGTH, CONTENT_TYPE}};\n\n    #[test]\n    fn test_headers_empty() {\n        let response: Response<()> = Response::default();\n        assert!(response.headers().is_empty());\n    }\n\n    #[test]\n    fn test_headers_insert() {\n        let mut response: Response<()> = Response::default();\n        response.head.headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n        assert!(!response.headers().is_empty());\n        assert_eq!(response.headers().get(CONTENT_LENGTH).unwrap(), "123");\n    }\n\n    #[test]\n    fn test_headers_multiple() {\n        let mut response: Response<()> = Response::default();\n        response.head.headers.insert(CONTENT_TYPE, "application/json".parse().unwrap());\n        response.head.headers.append(CONTENT_TYPE, "text/html".parse().unwrap());\n        let types: Vec<_> = response.headers().get_all(CONTENT_TYPE).iter().collect();\n        assert_eq!(types.len(), 2);\n        assert_eq!(types[0], &"application/json");\n        assert_eq!(types[1], &"text/html");\n    }\n\n    #[test]\n    fn test_headers_remove() {\n        let mut response: Response<()> = Response::default();\n        response.head.headers.insert(CONTENT_LENGTH, "100".parse().unwrap());\n        assert_eq!(response.headers().remove(CONTENT_LENGTH).unwrap(), "100");\n        assert!(response.headers().get(CONTENT_LENGTH).is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582942, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=328, prompt_tokens=16361, total_tokens=16689, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmakE8BxbyWEqhANrvF2XYXXj43V', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderValue, HOST};\n    \n    #[test]\n    fn test_headers_mut() {\n        let mut response: Response<()> = Response::default();\n        let headers_mut = response.headers_mut();\n        headers_mut.insert(HOST, HeaderValue::from_static("example.com"));\n        \n        assert!(!response.headers().is_empty());\n        assert_eq!(response.headers().get(HOST).unwrap(), "example.com");\n        \n        headers_mut.insert(HOST, HeaderValue::from_static("another.com"));\n        assert_eq!(response.headers().get(HOST).unwrap(), "another.com");\n    }\n\n    #[test]\n    fn test_headers_mut_empty() {\n        let mut response: Response<()> = Response::default();\n        let headers_mut = response.headers_mut();\n        \n        assert!(response.headers().is_empty());\n        headers_mut.insert(HOST, HeaderValue::from_static("localhost"));\n        assert!(!response.headers().is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582950, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=210, prompt_tokens=16361, total_tokens=16571, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmavyTBIScXqhfBnC8AO349wVVAO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Response;\n\n    #[test]\n    fn test_into_body() {\n        let response = Response::new(10);\n        let body = response.into_body();\n        assert_eq!(body, 10);\n    }\n\n    #[test]\n    fn test_into_body_with_different_types() {\n        let response = Response::new("Hello, world!");\n        let body = response.into_body();\n        assert_eq!(body, "Hello, world!");\n    }\n\n    #[test]\n    fn test_into_body_with_struct() {\n        #[derive(PartialEq, Debug)]\n        struct MyStruct {\n            value: i32,\n        }\n\n        let response = Response::new(MyStruct { value: 42 });\n        let body: MyStruct = response.into_body();\n        assert_eq!(body, MyStruct { value: 42 });\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582961, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=187, prompt_tokens=16361, total_tokens=16548, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmb3VrntZIpGZOEkcDCUvnivDzsS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, StatusCode};\n\n    #[test]\n    fn test_into_parts() {\n        let response: Response<()> = Response::default();\n        let (parts, body) = response.into_parts();\n        assert_eq!(parts.status, StatusCode::OK);\n        assert!(std::mem::size_of_val(&body) == 0); // body is of type ()\n    }\n\n    #[test]\n    fn test_into_parts_non_default_body() {\n        let custom_body = "This is a test body";\n        let response = Response::new(custom_body);\n        let (parts, body) = response.into_parts();\n        assert_eq!(parts.status, StatusCode::OK);\n        assert_eq!(body, "This is a test body");\n    }\n\n    #[test]\n    fn test_into_parts_with_status() {\n        let mut response = Response::default();\n        response.head.status = StatusCode::CREATED; // Change the status\n        let (parts, body) = response.into_parts();\n        assert_eq!(parts.status, StatusCode::CREATED);\n        assert!(std::mem::size_of_val(&body) == 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582969, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=253, prompt_tokens=16361, total_tokens=16614, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmbBlsvAV9wmfnpOAMuWvOK6UNKe', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, StatusCode};\n\n    #[test]\n    fn test_map_function() {\n        let response = Response::builder().body("some string").unwrap();\n        let mapped_response: Response<&[u8]> = response.map(|b| {\n            assert_eq!(b, "some string");\n            b.as_bytes()\n        });\n        assert_eq!(mapped_response.body(), &b"some string"[..]);\n    }\n\n    #[test]\n    fn test_map_function_with_empty_body() {\n        let response = Response::builder().body("").unwrap();\n        let mapped_response: Response<&[u8]> = response.map(|b| {\n            assert_eq!(b, "");\n            b.as_bytes()\n        });\n        assert_eq!(mapped_response.body(), &b""[..]);\n    }\n\n    #[test]\n    fn test_map_function_with_numbers() {\n        let response = Response::builder().body(42).unwrap();\n        let mapped_response: Response<i32> = response.map(|b| {\n            assert_eq!(b, 42);\n            b * 2\n        });\n        assert_eq!(mapped_response.body(), &84);\n    }\n\n    #[test]\n    fn test_map_function_with_custom_struct() {\n        #[derive(Debug, PartialEq)]\n        struct CustomStruct {\n            value: i32,\n        }\n\n        let response = Response::builder().body(CustomStruct { value: 10 }).unwrap();\n        let mapped_response: Response<i32> = response.map(|b| {\n            assert_eq!(b.value, 10);\n            b.value + 10\n        });\n        assert_eq!(mapped_response.body(), &20);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582977, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=352, prompt_tokens=16361, total_tokens=16713, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmbNp147JjYw9kedmqRnKKJQwaqG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, StatusCode};\n\n    #[test]\n    fn test_response_new() {\n        let response = Response::new("hello world");\n\n        assert_eq!(response.status(), StatusCode::OK);\n        assert_eq!(*response.body(), "hello world");\n    }\n\n    #[test]\n    fn test_response_new_empty_body() {\n        let response: Response<()> = Response::new(());\n\n        assert_eq!(response.status(), StatusCode::OK);\n    }\n\n    #[test]\n    fn test_response_new_with_different_body_type() {\n        let response: Response<i32> = Response::new(42);\n\n        assert_eq!(response.status(), StatusCode::OK);\n        assert_eq!(*response.body(), 42);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582989, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=168, prompt_tokens=16361, total_tokens=16529, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmbaLrWNcISwvBdbmxAdfnynvgUz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, StatusCode};\n\n    #[test]\n    fn test_default_status() {\n        let response: Response<()> = Response::default();\n        assert_eq!(response.status(), StatusCode::OK);\n    }\n\n    #[test]\n    fn test_custom_status() {\n        let mut response: Response<()> = Response::default();\n        response.head.status = StatusCode::NOT_FOUND;\n        assert_eq!(response.status(), StatusCode::NOT_FOUND);\n    }\n\n    #[test]\n    fn test_response_status_after_modification() {\n        let mut response: Response<()> = Response::new(());\n        assert_eq!(response.status(), StatusCode::OK);\n        response.head.status = StatusCode::CREATED;\n        assert_eq!(response.status(), StatusCode::CREATED);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583002, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=175, prompt_tokens=16361, total_tokens=16536, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmbidZYDDvSp3YP4ADOu7Vvujghb', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, StatusCode};\n\n    #[test]\n    fn test_status_mut() {\n        let mut response: Response<()> = Response::default();\n        *response.status_mut() = StatusCode::CREATED;\n        assert_eq!(response.status(), StatusCode::CREATED);\n    }\n\n    #[test]\n    fn test_status_mut_default() {\n        let mut response: Response<()> = Response::new(());\n        assert_eq!(response.status(), StatusCode::OK);\n        *response.status_mut() = StatusCode::NO_CONTENT;\n        assert_eq!(response.status(), StatusCode::NO_CONTENT);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583010, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=141, prompt_tokens=16361, total_tokens=16502, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmbtUpOfEw3zw0LoeCABdCaA3fxt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, Version};\n\n    #[test]\n    fn test_version_default_response() {\n        let response: Response<()> = Response::default();\n        assert_eq!(response.version(), Version::HTTP_11);\n    }\n\n    #[test]\n    fn test_version_custom_response() {\n        let mut response = Response::new(());\n        response.head.version = Version::HTTP_2;\n        assert_eq!(response.version(), Version::HTTP_2);\n    }\n\n    #[test]\n    fn test_version_change_response() {\n        let mut response: Response<()> = Response::default();\n        response.head.version = Version::HTTP_2;\n        assert_eq!(response.version(), Version::HTTP_2);\n    }\n\n    #[test]\n    fn test_version_after_default() {\n        let response: Response<()> = Response::new(());\n        assert_eq!(response.version(), Version::HTTP_11);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583021, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=199, prompt_tokens=16361, total_tokens=16560, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmc2vTlN7n51W1IEx2qXyDPbkNxY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Response, version::Version};\n\n    #[test]\n    fn version_mut_test() {\n        let mut response: Response<()> = Response::default();\n        *response.version_mut() = Version::HTTP_2;\n        assert_eq!(response.version(), Version::HTTP_2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583030, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=77, prompt_tokens=16361, total_tokens=16438, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmc7gNONcPlE8DJxLQcxqrZ6hxyy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_status_code_eq() {\n        let status_code = StatusCode::from_u16(200).unwrap();\n        let value: u16 = 200;\n\n        assert!(status_code.eq(&value));\n        assert!(!status_code.eq(&(404 as u16)));\n    }\n\n    #[test]\n    fn test_status_code_eq_with_non_status() {\n        let status_code = StatusCode::from_u16(404).unwrap();\n        let value: u16 = 500;\n\n        assert!(!status_code.eq(&value));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583035, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=138, prompt_tokens=2154, total_tokens=2292, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcER9Rtv2avBJ97bkvUUfuI352Q', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_status_code_to_u16() {\n        // Test for a known status code\n        let status = StatusCode::OK;\n        assert_eq!(u16::from(status), 200);\n\n        // Test for another known status code\n        let status = StatusCode::NOT_FOUND;\n        assert_eq!(u16::from(status), 404);\n\n        // Test for a status code in the 500 range\n        let status = StatusCode::from_u16(500).unwrap();\n        assert_eq!(u16::from(status), 500);\n\n        // Test for a status code in the 300 range\n        let status = StatusCode::from_u16(300).unwrap();\n        assert_eq!(u16::from(status), 300);\n\n        // Test for a status code in the 100 range\n        let status = StatusCode::from_u16(100).unwrap();\n        assert_eq!(u16::from(status), 100);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583042, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=225, prompt_tokens=2147, total_tokens=2372, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcIrwlfYxVFTIAxSZVhNAwGN6cV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt;\n\n    #[test]\n    fn test_invalid_status_code_new() {\n        let error = InvalidStatusCode::new();\n        \n        // Check that the error can be formatted\n        let formatted = format!("{}", error);\n        assert_eq!(formatted, "invalid status code");\n        \n        // Check that the error can be debugged\n        let debugged = format!("{:?}", error);\n        assert!(debugged.contains("InvalidStatusCode"));\n        \n        // Check that the error implements the Error trait\n        let _: &dyn std::error::Error = &error;\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583046, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=137, prompt_tokens=390, total_tokens=527, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcO8XZvc1iy3aMhq1Xu6FkIVHQk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_status_code_as_str() {\n        assert_eq!(StatusCode::from_u16(200).unwrap().as_str(), "200");\n        assert_eq!(StatusCode::from_u16(404).unwrap().as_str(), "404");\n        assert_eq!(StatusCode::from_u16(500).unwrap().as_str(), "500");\n        assert_eq!(StatusCode::from_u16(301).unwrap().as_str(), "301");\n        assert_eq!(StatusCode::from_u16(204).unwrap().as_str(), "204");\n    }\n\n    #[test]\n    fn test_out_of_bounds() {\n        assert!(StatusCode::from_u16(99).is_err());\n        assert!(StatusCode::from_u16(1000).is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583052, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=188, prompt_tokens=2310, total_tokens=2498, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcTrOJo9ri0ip0b1qHX9hoTMKWK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_as_u16() {\n        assert_eq!(StatusCode::OK.as_u16(), 200);\n        assert_eq!(StatusCode::NOT_FOUND.as_u16(), 404);\n        assert_eq!(StatusCode::BAD_REQUEST.as_u16(), 400);\n        assert_eq!(StatusCode::INTERNAL_SERVER_ERROR.as_u16(), 500);\n        assert_eq!(StatusCode::CREATED.as_u16(), 201);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583057, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=118, prompt_tokens=2239, total_tokens=2357, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcWUcgFq4v99W1jBcnF5vaaM8Bd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_canonical_reason() {\n        assert_eq!(StatusCode::from_u16(200).unwrap().canonical_reason(), Some("OK"));\n        assert_eq!(StatusCode::from_u16(404).unwrap().canonical_reason(), Some("Not Found"));\n        assert_eq!(StatusCode::from_u16(500).unwrap().canonical_reason(), Some("Internal Server Error"));\n        assert_eq!(StatusCode::from_u16(301).unwrap().canonical_reason(), Some("Moved Permanently"));\n        assert_eq!(StatusCode::from_u16(302).unwrap().canonical_reason(), Some("Found"));\n    }\n\n    #[test]\n    fn test_invalid_canonical_reason() {\n        assert!(StatusCode::from_u16(99).is_err());\n        assert!(StatusCode::from_u16(600).is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583060, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=197, prompt_tokens=2275, total_tokens=2472, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcaxzzFLWid0ZiZJctoNN5r1zs3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::status::StatusCode;\n    use http::status::InvalidStatusCode;\n\n    #[test]\n    fn test_from_bytes_valid() {\n        assert_eq!(StatusCode::from_bytes(b"200"), Ok(StatusCode::from_u16(200).unwrap()));\n        assert_eq!(StatusCode::from_bytes(b"404"), Ok(StatusCode::from_u16(404).unwrap()));\n        assert_eq!(StatusCode::from_bytes(b"500"), Ok(StatusCode::from_u16(500).unwrap()));\n    }\n\n    #[test]\n    fn test_from_bytes_invalid_length() {\n        assert_eq!(StatusCode::from_bytes(b"20"), Err(InvalidStatusCode::new()));\n        assert_eq!(StatusCode::from_bytes(b"2000"), Err(InvalidStatusCode::new()));\n        assert_eq!(StatusCode::from_bytes(b"20a"), Err(InvalidStatusCode::new()));\n        assert_eq!(StatusCode::from_bytes(b""), Err(InvalidStatusCode::new()));\n    }\n\n    #[test]\n    fn test_from_bytes_invalid_digit() {\n        assert_eq!(StatusCode::from_bytes(b"2a0"), Err(InvalidStatusCode::new()));\n        assert_eq!(StatusCode::from_bytes(b"2-0"), Err(InvalidStatusCode::new()));\n        assert_eq!(StatusCode::from_bytes(b"20!"), Err(InvalidStatusCode::new()));\n    }\n\n    #[test]\n    fn test_from_bytes_non_numeric() {\n        assert_eq!(StatusCode::from_bytes(b"abc"), Err(InvalidStatusCode::new()));\n    }\n\n    #[test]\n    fn test_from_bytes_leading_zeroes() {\n        assert_eq!(StatusCode::from_bytes(b"007"), Ok(StatusCode::from_u16(7).unwrap()));\n        assert_eq!(StatusCode::from_bytes(b"040"), Ok(StatusCode::from_u16(40).unwrap()));\n    }\n\n    #[test]\n    fn test_from_bytes_zero_status_code() {\n        assert_eq!(StatusCode::from_bytes(b"000"), Err(InvalidStatusCode::new()));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583064, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=447, prompt_tokens=324, total_tokens=771, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmckdNoKMXRnE2VsrE33M7pZWqoZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import everything from the parent module\n    use http::StatusCode;\n    use http::status::InvalidStatusCode;\n\n    #[test]\n    fn test_from_u16_valid() {\n        let ok = StatusCode::from_u16(200).unwrap();\n        assert_eq!(ok, StatusCode::OK);\n    }\n\n    #[test]\n    fn test_from_u16_invalid_below_range() {\n        let err = StatusCode::from_u16(99);\n        assert!(err.is_err());\n    }\n\n    #[test]\n    fn test_from_u16_invalid_above_range() {\n        let err = StatusCode::from_u16(1000);\n        assert!(err.is_err());\n    }\n\n    #[test]\n    fn test_from_u16_invalid_zero() {\n        let err = StatusCode::from_u16(0);\n        assert!(err.is_err());\n    }\n\n    #[test]\n    fn test_from_u16_invalid_negative() {\n        // In the context of Rust, we can't provide negative values to a u16\n        // Hence, this test will just focus on valid cases within the u16 range\n        // With u16, we can't test negative, but we can ensure valid processing\n        assert!(StatusCode::from_u16(u16::MAX).is_err());\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583074, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=283, prompt_tokens=306, total_tokens=589, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcsSf5n0M1JryQpppql3DlONqUp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_is_client_error() {\n        assert!(StatusCode::from_u16(400).unwrap().is_client_error());\n        assert!(StatusCode::from_u16(404).unwrap().is_client_error());\n        assert!(!StatusCode::from_u16(200).unwrap().is_client_error());\n        assert!(!StatusCode::from_u16(500).unwrap().is_client_error());\n        assert!(!StatusCode::from_u16(299).unwrap().is_client_error());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583082, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=130, prompt_tokens=2156, total_tokens=2286, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcxbxTaTgl1djBFUEmDNIpwIFYW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust this import as per your module structure\n    use http::StatusCode;\n\n    #[test]\n    fn test_is_informational() {\n        assert!(StatusCode::from_u16(100).unwrap().is_informational());\n        assert!(StatusCode::from_u16(199).unwrap().is_informational());\n        assert!(!StatusCode::from_u16(200).unwrap().is_informational());\n        assert!(!StatusCode::from_u16(99).is_ok() && !StatusCode::from_u16(99).unwrap().is_informational());\n        assert!(!StatusCode::from_u16(300).unwrap().is_informational());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583087, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=161, prompt_tokens=2159, total_tokens=2320, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmd36g8yG2fSqKoFX1sXVUTcTuAv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust the import based on the module structure\n    use http::StatusCode;\n\n    #[test]\n    fn test_is_redirection() {\n        assert!(StatusCode::from_u16(301).unwrap().is_redirection());\n        assert!(StatusCode::from_u16(302).unwrap().is_redirection());\n        assert!(StatusCode::from_u16(303).unwrap().is_redirection());\n        assert!(StatusCode::from_u16(307).unwrap().is_redirection());\n        assert!(StatusCode::from_u16(308).unwrap().is_redirection());\n        assert!(!StatusCode::from_u16(200).unwrap().is_redirection());\n        assert!(!StatusCode::from_u16(404).unwrap().is_redirection());\n        assert!(!StatusCode::from_u16(500).unwrap().is_redirection());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583093, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=195, prompt_tokens=2156, total_tokens=2351, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmdBdYbvht0i6OnlbxatboVDpp1t', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_is_server_error() {\n        assert!(StatusCode::from_u16(500).unwrap().is_server_error());\n        assert!(StatusCode::from_u16(501).unwrap().is_server_error());\n        assert!(StatusCode::from_u16(599).unwrap().is_server_error());\n        assert!(!StatusCode::from_u16(200).unwrap().is_server_error());\n        assert!(!StatusCode::from_u16(404).unwrap().is_server_error());\n        assert!(!StatusCode::from_u16(600).is_ok() && StatusCode::from_u16(600).unwrap_err().is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583101, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=161, prompt_tokens=2156, total_tokens=2317, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmdGRyqcSINWIKCuAIhiMUEeWKSY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::StatusCode;\n\n    #[test]\n    fn test_is_success() {\n        assert!(StatusCode::from_u16(200).unwrap().is_success());\n        assert!(StatusCode::from_u16(201).unwrap().is_success());\n        assert!(StatusCode::from_u16(299).unwrap().is_success());\n        assert!(!StatusCode::from_u16(199).unwrap().is_success());\n        assert!(!StatusCode::from_u16(300).unwrap().is_success());\n        assert!(!StatusCode::from_u16(404).unwrap().is_success());\n        assert!(!StatusCode::from_u16(500).unwrap().is_success());\n    }\n\n    #[test]\n    fn test_is_success_invalid() {\n        assert!(StatusCode::from_u16(0).is_err());\n        assert!(StatusCode::from_u16(100).is_err());\n        assert!(StatusCode::from_u16(600).is_err());\n        assert!(StatusCode::from_u16(1000).is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583106, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=234, prompt_tokens=2153, total_tokens=2387, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmdNuDaCWQTYE6aMOydjQHsGv4EG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_canonical_reason() {\n        assert_eq!(canonical_reason(200), Some("OK"));\n        assert_eq!(canonical_reason(404), Some("Not Found"));\n        assert_eq!(canonical_reason(500), Some("Internal Server Error"));\n        assert_eq!(canonical_reason(123), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583113, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=83, prompt_tokens=167, total_tokens=250, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmdQxIlp0w4YJBlxxJ4g1Tw5ID7U', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_eq_with_matching_string() {\n        let uri: Uri = "http://example.com".parse().unwrap();\n        let str_uri = "http://example.com";\n        assert!(str_uri.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_differing_string() {\n        let uri: Uri = "http://example.com".parse().unwrap();\n        let str_uri = "http://rust-lang.org";\n        assert!(!str_uri.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_case_insensitivity() {\n        let uri: Uri = "http://example.com".parse().unwrap();\n        let str_uri = "HTTP://example.com";\n        assert!(str_uri.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_empty_string() {\n        let uri: Uri = "/".parse().unwrap();\n        let str_uri = "";\n        assert!(!str_uri.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_empty_uri() {\n        let uri: Uri = "/".parse().unwrap();\n        let str_uri = "/";\n        assert!(str_uri.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_different_parts() {\n        let uri: Uri = "http://example.com/path?query=value".parse().unwrap();\n        let str_uri = "http://example.com/path";\n        assert!(!str_uri.eq(&uri));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583116, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=326, prompt_tokens=14155, total_tokens=14481, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmdeyMBg4WlYNEp2QTcqzs7u6ymg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_eq_with_matching_uri() {\n        let uri: Uri = "http://example.com".parse().unwrap();\n        let s = "http://example.com";\n\n        assert!(s.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_non_matching_uri() {\n        let uri: Uri = "http://example.com".parse().unwrap();\n        let s = "http://different.com";\n\n        assert!(!s.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_empty_uri() {\n        let uri: Uri = "http://example.com".parse().unwrap();\n        let s = "";\n\n        assert!(!s.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_uri_with_fragment() {\n        let uri: Uri = "http://example.com#fragment".parse().unwrap();\n        let s = "http://example.com#fragment";\n\n        assert!(s.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_uri_with_query() {\n        let uri: Uri = "http://example.com?key=value".parse().unwrap();\n        let s = "http://example.com?key=value";\n\n        assert!(s.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_uri_with_path() {\n        let uri: Uri = "http://example.com/path".parse().unwrap();\n        let s = "http://example.com/path";\n\n        assert!(s.eq(&uri));\n    }\n\n    #[test]\n    fn test_eq_with_different_schemes() {\n        let uri: Uri = "https://example.com".parse().unwrap();\n        let s = "http://example.com";\n\n        assert!(!s.eq(&uri));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583130, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=382, prompt_tokens=14152, total_tokens=14534, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmdne8jPnnEeTomJ6j3BKaNLdN6n', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_invalid_uri_char() {\n        let error = InvalidUri::from(ErrorKind::InvalidUriChar);\n        assert_eq!(error.s(), "invalid uri character");\n    }\n\n    #[test]\n    fn test_invalid_scheme() {\n        let error = InvalidUri::from(ErrorKind::InvalidScheme);\n        assert_eq!(error.s(), "invalid scheme");\n    }\n\n    #[test]\n    fn test_invalid_authority() {\n        let error = InvalidUri::from(ErrorKind::InvalidAuthority);\n        assert_eq!(error.s(), "invalid authority");\n    }\n\n    #[test]\n    fn test_invalid_port() {\n        let error = InvalidUri::from(ErrorKind::InvalidPort);\n        assert_eq!(error.s(), "invalid port");\n    }\n\n    #[test]\n    fn test_invalid_format() {\n        let error = InvalidUri::from(ErrorKind::InvalidFormat);\n        assert_eq!(error.s(), "invalid format");\n    }\n\n    #[test]\n    fn test_scheme_missing() {\n        let error = InvalidUri::from(ErrorKind::SchemeMissing);\n        assert_eq!(error.s(), "scheme missing");\n    }\n\n    #[test]\n    fn test_authority_missing() {\n        let error = InvalidUri::from(ErrorKind::AuthorityMissing);\n        assert_eq!(error.s(), "authority missing");\n    }\n\n    #[test]\n    fn test_path_and_query_missing() {\n        let error = InvalidUri::from(ErrorKind::PathAndQueryMissing);\n        assert_eq!(error.s(), "path missing");\n    }\n\n    #[test]\n    fn test_too_long() {\n        let error = InvalidUri::from(ErrorKind::TooLong);\n        assert_eq!(error.s(), "uri too long");\n    }\n\n    #[test]\n    fn test_empty() {\n        let error = InvalidUri::from(ErrorKind::Empty);\n        assert_eq!(error.s(), "empty string");\n    }\n\n    #[test]\n    fn test_scheme_too_long() {\n        let error = InvalidUri::from(ErrorKind::SchemeTooLong);\n        assert_eq!(error.s(), "scheme too long");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583139, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=448, prompt_tokens=691, total_tokens=1139, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmdvLZgw2DL1LxO7nZFcVMyfMlpQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_authority_absolute_uri() {\n        let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n        assert_eq!(uri.authority().map(|a| a.as_str()), Some("example.org:80"));\n    }\n\n    #[test]\n    fn test_authority_relative_uri() {\n        let uri: Uri = "/hello/world".parse().unwrap();\n        assert!(uri.authority().is_none());\n    }\n\n    #[test]\n    fn test_authority_empty_uri() {\n        let uri: Uri = "".parse().unwrap();\n        assert!(uri.authority().is_none());\n    }\n\n    #[test]\n    fn test_authority_with_username_password() {\n        let uri: Uri = "http://username:password@example.com:123/path/data".parse().unwrap();\n        assert_eq!(uri.authority().map(|a| a.as_str()), Some("username:password@example.com:123"));\n    }\n\n    #[test]\n    fn test_authority_non_standard_uri() {\n        let uri: Uri = "ftp://example.com/path".parse().unwrap();\n        assert_eq!(uri.authority().map(|a| a.as_str()), Some("example.com"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583147, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=275, prompt_tokens=14399, total_tokens=14674, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcme3fEC7YRR6FoiBSg1q9yt38xM0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_uri_builder() {\n        let uri = Uri::builder()\n            .scheme("https")\n            .authority("hyper.rs")\n            .path_and_query("/")\n            .build()\n            .unwrap();\n\n        assert_eq!(uri.scheme().unwrap(), "https");\n        assert_eq!(uri.authority().unwrap().as_str(), "hyper.rs");\n        assert_eq!(uri.path_and_query().unwrap().as_str(), "/");\n    }\n\n    #[test]\n    fn test_uri_builder_default() {\n        let uri = Uri::builder()\n            .build()\n            .unwrap();\n\n        assert!(uri.scheme().is_none());\n        assert!(uri.authority().is_none());\n        assert!(uri.path_and_query().is_none());\n    }\n\n    #[test]\n    fn test_invalid_scheme() {\n        let result = Uri::builder()\n            .scheme("!@#%/^^")\n            .build();\n\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583155, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=218, prompt_tokens=1260, total_tokens=1478, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcme9ukck77vnFHzAE8IQDzPZQY2n', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderName;\n\n    #[test]\n    fn test_from_maybe_shared_with_bytes() {\n        let header_name = HeaderName::from_static("content-length");\n        let bytes: Bytes = header_name.as_ref().to_vec().into();\n        let uri_result = uri::Uri::from_maybe_shared(bytes);\n\n        assert!(uri_result.is_ok());\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_header_name() {\n        let header_name = HeaderName::from_static("content-length");\n        let uri_result = uri::Uri::from_maybe_shared(header_name);\n\n        assert!(uri_result.is_ok());\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_invalid_bytes() {\n        let invalid_bytes = b"invalid_uri_bytes";\n        let uri_result = uri::Uri::from_maybe_shared(invalid_bytes);\n\n        assert!(uri_result.is_err());\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_invalid_header_name() {\n        let invalid_header_name: HeaderName = HeaderName::from_static("Invalid_Header");\n        let uri_result = uri::Uri::from_maybe_shared(invalid_header_name);\n\n        assert!(uri_result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583161, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=268, prompt_tokens=4356, total_tokens=4624, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmeGt6cON6UXyR2q0mPFGgD4uXT2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::*;\n\n    #[test]\n    fn test_from_parts_relative_uri() {\n        let mut parts = Parts::default();\n        parts.path_and_query = Some("/foo".parse().unwrap());\n\n        let uri = Uri::from_parts(parts).unwrap();\n        \n        assert_eq!(uri.path(), "/foo");\n        assert!(uri.scheme().is_none());\n        assert!(uri.authority().is_none());\n    }\n\n    #[test]\n    fn test_from_parts_absolute_uri() {\n        let mut parts = Parts::default();\n        parts.scheme = Some("http".parse().unwrap());\n        parts.authority = Some("foo.com".parse().unwrap());\n        parts.path_and_query = Some("/foo".parse().unwrap());\n\n        let uri = Uri::from_parts(parts).unwrap();\n        \n        assert_eq!(uri.scheme().unwrap().as_str(), "http");\n        assert_eq!(uri.authority().unwrap(), "foo.com");\n        assert_eq!(uri.path(), "/foo");\n    }\n\n    #[test]\n    fn test_from_parts_missing_authority() {\n        let mut parts = Parts::default();\n        parts.scheme = Some("http".parse().unwrap());\n        parts.path_and_query = Some("/foo".parse().unwrap());\n\n        let result = Uri::from_parts(parts);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().kind(), ErrorKind::AuthorityMissing);\n    }\n\n    #[test]\n    fn test_from_parts_missing_path_and_query() {\n        let mut parts = Parts::default();\n        parts.scheme = Some("http".parse().unwrap());\n        parts.authority = Some("foo.com".parse().unwrap());\n\n        let result = Uri::from_parts(parts);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().kind(), ErrorKind::PathAndQueryMissing);\n    }\n\n    #[test]\n    fn test_from_parts_scheme_missing() {\n        let mut parts = Parts::default();\n        parts.authority = Some("foo.com".parse().unwrap());\n        parts.path_and_query = Some("/foo".parse().unwrap());\n\n        let result = Uri::from_parts(parts);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().kind(), ErrorKind::SchemeMissing);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583168, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=474, prompt_tokens=825, total_tokens=1299, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmeQegQdaDwVLYt0GgRknGuItCod', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_from_shared_empty() {\n        let result = Uri::from_shared(Bytes::from(""));\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap().kind(), ErrorKind::Empty);\n    }\n\n    #[test]\n    fn test_from_shared_too_long() {\n        let long_bytes = Bytes::from(vec![0u8; MAX_LEN + 1]);\n        let result = Uri::from_shared(long_bytes);\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap().kind(), ErrorKind::TooLong);\n    }\n\n    #[test]\n    fn test_from_shared_slash() {\n        let result = Uri::from_shared(Bytes::from(b"/"));\n        assert!(result.is_ok());\n        let uri = result.unwrap();\n        assert_eq!(uri.path_and_query, PathAndQuery::slash());\n    }\n\n    #[test]\n    fn test_from_shared_star() {\n        let result = Uri::from_shared(Bytes::from(b"*"));\n        assert!(result.is_ok());\n        let uri = result.unwrap();\n        assert_eq!(uri.path_and_query, PathAndQuery::star());\n    }\n\n    #[test]\n    fn test_from_shared_authority() {\n        let authority_bytes = Bytes::from("example.com");\n        let result = Uri::from_shared(authority_bytes);\n        assert!(result.is_ok());\n        let uri = result.unwrap();\n        assert_eq!(uri.authority, Authority::from_shared(authority_bytes).unwrap());\n        assert_eq!(uri.path_and_query, PathAndQuery::empty());\n    }\n\n    #[test]\n    fn test_from_shared_path_and_query() {\n        let uri_bytes = Bytes::from(b"/path?query");\n        let result = Uri::from_shared(uri_bytes);\n        assert!(result.is_ok());\n        let uri = result.unwrap();\n        assert_eq!(uri.path_and_query, PathAndQuery::from_shared(uri_bytes).unwrap());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583178, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=427, prompt_tokens=558, total_tokens=985, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmebA5nfpmTDXZVVargXxqi36BqC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Uri;\n    \n    #[test]\n    fn test_from_static_valid_uri() {\n        let uri = Uri::from_static("http://example.com/foo");\n        assert_eq!(uri.host().unwrap(), "example.com");\n        assert_eq!(uri.path(), "/foo");\n    }\n\n    #[test]\n    #[should_panic(expected = "static str is not valid URI")]\n    fn test_from_static_invalid_uri() {\n        let _ = Uri::from_static("http://");\n    }\n\n    #[test]\n    fn test_from_static_valid_uri_https() {\n        let uri = Uri::from_static("https://example.com/foo");\n        assert_eq!(uri.host().unwrap(), "example.com");\n        assert_eq!(uri.path(), "/foo");\n    }\n\n    #[test]\n    fn test_from_static_absolute_uri() {\n        let uri = Uri::from_static("ftp://example.com/foo");\n        assert_eq!(uri.host().unwrap(), "example.com");\n        assert_eq!(uri.path(), "/foo");\n    }\n\n    #[test]\n    #[should_panic(expected = "static str is not valid URI")]\n    fn test_from_static_empty_uri() {\n        let _ = Uri::from_static("");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583189, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=266, prompt_tokens=14287, total_tokens=14553, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmejFu7dxQyU4WSJfOz1WoPTvSg9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::{Uri, Authority, PathAndQuery, Scheme};\n\n    #[test]\n    fn test_has_path_absolute_uri() {\n        let uri: Uri = "https://example.com/path?query=1".parse().unwrap();\n        assert!(uri.has_path());\n    }\n\n    #[test]\n    fn test_has_path_relative_uri() {\n        let uri: Uri = "/path".parse().unwrap();\n        assert!(uri.has_path());\n    }\n\n    #[test]\n    fn test_has_path_uri_without_path() {\n        let uri: Uri = "https://example.com".parse().unwrap();\n        assert!(!uri.has_path());\n    }\n\n    #[test]\n    fn test_has_path_empty_uri() {\n        let uri: Uri = "".parse().unwrap();\n        assert!(!uri.has_path());\n    }\n\n    #[test]\n    fn test_has_path_uri_with_empty_query() {\n        let uri: Uri = "https://example.com/path?".parse().unwrap();\n        assert!(uri.has_path());\n    }\n\n    #[test]\n    fn test_has_path_uri_with_empty_path() {\n        let uri: Uri = "https://example.com?".parse().unwrap();\n        assert!(!uri.has_path());\n    }\n\n    #[test]\n    fn test_has_path_uri_with_wildcard_path() {\n        let uri: Uri = "https://example.com/*".parse().unwrap();\n        assert!(uri.has_path());\n    }\n\n    #[test]\n    fn test_has_path_uri_with_slash_path() {\n        let uri: Uri = "https://example.com/".parse().unwrap();\n        assert!(uri.has_path());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583197, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=351, prompt_tokens=14150, total_tokens=14501, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmeuA3dqChM6MVC8TZqBclNWyrBf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_host_absolute_uri() {\n        let uri: Uri = "http://example.com:80/path".parse().unwrap();\n        assert_eq!(uri.host(), Some("example.com"));\n    }\n\n    #[test]\n    fn test_host_absolute_uri_with_port() {\n        let uri: Uri = "http://example.com:8080/path".parse().unwrap();\n        assert_eq!(uri.host(), Some("example.com"));\n    }\n\n    #[test]\n    fn test_host_absolute_uri_with_ipv4() {\n        let uri: Uri = "http://192.168.1.1:80/path".parse().unwrap();\n        assert_eq!(uri.host(), Some("192.168.1.1"));\n    }\n\n    #[test]\n    fn test_host_absolute_uri_with_ipv6() {\n        let uri: Uri = "http://[::1]:80/path".parse().unwrap();\n        assert_eq!(uri.host(), Some("::1"));\n    }\n\n    #[test]\n    fn test_host_relative_uri() {\n        let uri: Uri = "/path".parse().unwrap();\n        assert!(uri.host().is_none());\n    }\n\n    #[test]\n    fn test_host_uri_without_auth() {\n        let uri: Uri = "http:///path".parse().unwrap();\n        assert!(uri.host().is_none());\n    }\n\n    #[test]\n    fn test_host_uri_with_empty_auth() {\n        let uri: Uri = "http://:80/path".parse().unwrap();\n        assert!(uri.host().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583208, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=339, prompt_tokens=14342, total_tokens=14681, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmf49AgjpJSpRb8oN40VdDPqSdld', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_into_parts_relative_uri() {\n        let uri: Uri = "/foo/bar".parse().unwrap();\n        let parts = uri.into_parts();\n        assert_eq!(parts.path_and_query.unwrap(), "/foo/bar");\n        assert!(parts.scheme.is_none());\n        assert!(parts.authority.is_none());\n    }\n\n    #[test]\n    fn test_into_parts_absolute_uri() {\n        let uri: Uri = "https://example.com/path?query".parse().unwrap();\n        let parts = uri.into_parts();\n        assert_eq!(parts.path_and_query.unwrap(), "/path?query");\n        assert_eq!(parts.scheme.unwrap().as_str(), "https");\n        assert_eq!(parts.authority.unwrap().as_str(), "example.com");\n    }\n\n    #[test]\n    fn test_into_parts_empty_uri() {\n        let uri: Uri = "".parse().unwrap();\n        let parts = uri.into_parts();\n        assert_eq!(parts.path_and_query.unwrap(), "/");\n        assert!(parts.scheme.is_none());\n        assert!(parts.authority.is_none());\n    }\n\n    #[test]\n    fn test_into_parts_with_authority() {\n        let uri: Uri = "http://localhost:8080/".parse().unwrap();\n        let parts = uri.into_parts();\n        assert_eq!(parts.path_and_query.unwrap(), "/");\n        assert_eq!(parts.scheme.unwrap().as_str(), "http");\n        assert_eq!(parts.authority.unwrap().as_str(), "localhost:8080");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583218, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=327, prompt_tokens=14514, total_tokens=14841, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmfDjJlIKda48asUtdv0tBqdOrxp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_relative_uri_path() {\n        let uri: Uri = "/hello/world".parse().unwrap();\n        assert_eq!(uri.path(), "/hello/world");\n    }\n\n    #[test]\n    fn test_absolute_uri_path() {\n        let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n        assert_eq!(uri.path(), "/hello/world");\n    }\n\n    #[test]\n    fn test_empty_path_uri() {\n        let uri: Uri = "http://example.org".parse().unwrap();\n        assert_eq!(uri.path(), "/");\n    }\n\n    #[test]\n    fn test_star_uri() {\n        let uri: Uri = "*".parse().unwrap();\n        assert_eq!(uri.path(), "*");\n    }\n\n    #[test]\n    fn test_uri_with_empty_path() {\n        let uri: Uri = "http://example.org/".parse().unwrap();\n        assert_eq!(uri.path(), "/");\n    }\n\n    #[test]\n    fn test_uri_with_no_path() {\n        let uri: Uri = "http://example.org:80".parse().unwrap();\n        assert_eq!(uri.path(), "/");\n    }\n\n    #[test]\n    fn test_uri_with_only_query() {\n        let uri: Uri = "http://example.org?key=value".parse().unwrap();\n        assert_eq!(uri.path(), "/");\n    }\n\n    #[test]\n    fn test_uri_with_path_and_query() {\n        let uri: Uri = "http://example.org/path?key=value".parse().unwrap();\n        assert_eq!(uri.path(), "/path");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583227, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=350, prompt_tokens=14350, total_tokens=14700, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmfNr0qk4jIA5W5uMaSXkUkwJOh2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::{PathAndQuery, Scheme, Authority, Uri};\n\n    #[test]\n    fn test_path_and_query_with_scheme_and_authority() {\n        let uri: Uri = "http://example.com/path?query=value".parse().unwrap();\n        let path_and_query = uri.path_and_query().unwrap();\n        assert_eq!(path_and_query.path(), "/path");\n        assert_eq!(path_and_query.query(), Some("query=value"));\n    }\n\n    #[test]\n    fn test_path_and_query_with_scheme_only() {\n        let uri: Uri = "http:/path".parse().unwrap();\n        let path_and_query = uri.path_and_query().unwrap();\n        assert_eq!(path_and_query.path(), "/path");\n        assert!(path_and_query.query().is_none());\n    }\n\n    #[test]\n    fn test_path_and_query_with_authority_only() {\n        let uri: Uri = "example.com/path?query=value".parse().unwrap();\n        let path_and_query = uri.path_and_query().unwrap();\n        assert_eq!(path_and_query.path(), "/path");\n        assert_eq!(path_and_query.query(), Some("query=value"));\n    }\n\n    #[test]\n    fn test_path_and_query_with_no_scheme_no_authority() {\n        let uri: Uri = "/path".parse().unwrap();\n        let path_and_query = uri.path_and_query().unwrap();\n        assert_eq!(path_and_query.path(), "/path");\n        assert!(path_and_query.query().is_none());\n    }\n\n    #[test]\n    fn test_path_and_query_with_no_scheme_no_authority_empty() {\n        let uri: Uri = "".parse::<Uri>().unwrap();\n        assert!(uri.path_and_query().is_none());\n    }\n\n    #[test]\n    fn test_path_and_query_empty_path() {\n        let uri: Uri = "http://example.com".parse().unwrap();\n        let path_and_query = uri.path_and_query().unwrap();\n        assert_eq!(path_and_query.path(), "/");\n        assert!(path_and_query.query().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583237, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=434, prompt_tokens=14189, total_tokens=14623, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmfYDilSoyUi0rIZg0UY7M6whOwC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_port_with_port() {\n        let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n        let port = uri.port().unwrap();\n        assert_eq!(port.as_u16(), 80);\n    }\n\n    #[test]\n    fn test_port_without_port() {\n        let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n        assert!(uri.port().is_none());\n    }\n\n    #[test]\n    fn test_port_relative_uri() {\n        let uri: Uri = "/hello/world".parse().unwrap();\n        assert!(uri.port().is_none());\n    }\n\n    #[test]\n    fn test_port_with_https() {\n        let uri: Uri = "https://example.com:443/path".parse().unwrap();\n        let port = uri.port().unwrap();\n        assert_eq!(port.as_u16(), 443);\n    }\n\n    #[test]\n    fn test_port_with_non_standard_port() {\n        let uri: Uri = "http://example.com:8080/path".parse().unwrap();\n        let port = uri.port().unwrap();\n        assert_eq!(port.as_u16(), 8080);\n    }\n\n    #[test]\n    fn test_empty_uri() {\n        let uri: Uri = "/".parse().unwrap();\n        assert!(uri.port().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583248, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=303, prompt_tokens=14415, total_tokens=14718, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmffFyxIQf2cxKjHlrGpBdEX11v1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_port_u16_with_port() {\n        let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n        assert_eq!(uri.port_u16(), Some(80));\n    }\n\n    #[test]\n    fn test_port_u16_without_port() {\n        let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n        assert_eq!(uri.port_u16(), None);\n    }\n    \n    #[test]\n    fn test_port_u16_with_non_standard_port() {\n        let uri: Uri = "http://example.org:8080/hello/world".parse().unwrap();\n        assert_eq!(uri.port_u16(), Some(8080));\n    }\n\n    #[test]\n    fn test_port_u16_with_empty_uri() {\n        let uri: Uri = "/hello/world".parse().unwrap();\n        assert_eq!(uri.port_u16(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583255, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=215, prompt_tokens=14220, total_tokens=14435, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmfm2B9ctonRMVDTKnw5DSalB01P', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_query_with_absolute_uri() {\n        let uri: Uri = "http://example.org/hello/world?key=value".parse().unwrap();\n        assert_eq!(uri.query(), Some("key=value"));\n    }\n\n    #[test]\n    fn test_query_with_relative_uri() {\n        let uri: Uri = "/hello/world?key=value&foo=bar".parse().unwrap();\n        assert_eq!(uri.query(), Some("key=value&foo=bar"));\n    }\n\n    #[test]\n    fn test_query_without_query_string() {\n        let uri: Uri = "/hello/world".parse().unwrap();\n        assert!(uri.query().is_none());\n    }\n\n    #[test]\n    fn test_query_with_empty_uri() {\n        let uri: Uri = "/".parse().unwrap();\n        assert!(uri.query().is_none());\n    }\n\n    #[test]\n    fn test_query_with_encoded_query() {\n        let uri: Uri = "http://example.com/path?key=value%20with%20spaces".parse().unwrap();\n        assert_eq!(uri.query(), Some("key=value with spaces"));\n    }\n\n    #[test]\n    fn test_query_with_special_characters() {\n        let uri: Uri = "http://example.com/path?key=value&key2=value&key3=foo%20bar".parse().unwrap();\n        assert_eq!(uri.query(), Some("key=value&key2=value&key3=foo bar"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583262, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=322, prompt_tokens=14438, total_tokens=14760, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmfv3DE9DEbux0nmegott0QnqjVT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::{Scheme, Uri};\n\n    #[test]\n    fn test_scheme_absolute_uri() {\n        let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n        assert_eq!(uri.scheme(), Some(&Scheme::HTTP));\n    }\n\n    #[test]\n    fn test_scheme_https_uri() {\n        let uri: Uri = "https://example.com".parse().unwrap();\n        assert_eq!(uri.scheme(), Some(&Scheme::HTTPS));\n    }\n\n    #[test]\n    fn test_scheme_no_scheme() {\n        let uri: Uri = "/hello/world".parse().unwrap();\n        assert!(uri.scheme().is_none());\n    }\n\n    #[test]\n    fn test_scheme_empty_uri() {\n        let uri: Uri = "".parse::<Uri>().unwrap_err();\n        assert!(uri.scheme().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583271, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=189, prompt_tokens=14360, total_tokens=14549, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmg4xkuPcZY2HaqsK0p4knevY8Bc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::Uri;\n\n    #[test]\n    fn test_scheme_str_with_http() {\n        let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n        assert_eq!(uri.scheme_str(), Some("http"));\n    }\n\n    #[test]\n    fn test_scheme_str_with_https() {\n        let uri: Uri = "https://example.org/hello/world".parse().unwrap();\n        assert_eq!(uri.scheme_str(), Some("https"));\n    }\n\n    #[test]\n    fn test_scheme_str_with_no_scheme() {\n        let uri: Uri = "/hello/world".parse().unwrap();\n        assert_eq!(uri.scheme_str(), None);\n    }\n\n    #[test]\n    fn test_scheme_str_with_empty_string() {\n        let uri: Uri = "".parse::<Uri>().unwrap_err();\n        assert!(uri.scheme_str().is_none());\n    }\n\n    #[test]\n    fn test_scheme_str_with_invalid_uri() {\n        let uri: Result<Uri, _> = "invalid_uri_string".parse();\n        assert!(uri.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583280, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=235, prompt_tokens=14224, total_tokens=14459, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgBa16vU0PQfxtGWmEWqBuecbYy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_eq_with_equal_case() {\n        let authority_str = "example.com";\n        let authority = Authority::from_static(authority_str);\n        assert!(authority_str.eq(&authority));\n    }\n\n    #[test]\n    fn test_eq_with_equal_case_insensitive() {\n        let authority_str = "Example.Com";\n        let authority = Authority::from_static("example.com");\n        assert!(authority_str.eq(&authority));\n    }\n\n    #[test]\n    fn test_eq_with_different_case() {\n        let authority_str = "example.com";\n        let authority = Authority::from_static("EXAMPLE.COM");\n        assert!(authority_str.eq(&authority));\n    }\n\n    #[test]\n    fn test_eq_with_different_authority() {\n        let authority_str = "example.com";\n        let authority = Authority::from_static("test.com");\n        assert!(!authority_str.eq(&authority));\n    }\n\n    #[test]\n    fn test_eq_with_empty_authority() {\n        let authority_str = "example.com";\n        let authority = Authority::empty();\n        assert!(!authority_str.eq(&authority));\n    }\n\n    #[test]\n    fn test_eq_with_empty_string() {\n        let authority_str = "";\n        let authority = Authority::empty();\n        assert!(authority_str.eq(&authority));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583287, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=292, prompt_tokens=4068, total_tokens=4360, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgJk3YDO8oVpj6zTBFLWxskoEtl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_eq_case_insensitive() {\n        let authority_str = "EXAMPLE.COM";\n        let authority = Authority::from_static("example.com");\n\n        assert!(authority_str.eq(&authority));\n    }\n\n    #[test]\n    fn test_eq_case_sensitive_different() {\n        let authority_str = "EXAMPLE.COM";\n        let authority = Authority::from_static("example.org");\n\n        assert!(!authority_str.eq(&authority));\n    }\n\n    #[test]\n    fn test_eq_empty_case_insensitive() {\n        let authority_str = "";\n        let authority = Authority::empty();\n\n        assert!(authority_str.eq(&authority));\n    }\n\n    #[test]\n    fn test_eq_with_special_chars() {\n        let authority_str = "example.com:80";\n        let authority = Authority::from_static("EXAMPLE.COM:80");\n\n        assert!(authority_str.eq(&authority));\n    }\n\n    #[test]\n    fn test_eq_different_length() {\n        let authority_str = "example.com";\n        let authority = Authority::from_static("example.com:8080");\n\n        assert!(!authority_str.eq(&authority));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583295, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=256, prompt_tokens=4557, total_tokens=4813, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgRD0ZNDpgHqQezSNmZqEC73D9g', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_eq_case_insensitive() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = Authority::from_static("Example.Com");\n        let authority3 = Authority::from_static("example.org");\n\n        assert!(authority1.eq("EXAMPLE.COM"));\n        assert!(authority1.eq(&authority2));\n        assert!(!authority1.eq("example.org"));\n        assert!(!authority1.eq(&authority3));\n    }\n\n    #[test]\n    fn test_eq_empty() {\n        let authority_empty = Authority::empty();\n        let non_empty = Authority::from_static("example.com");\n\n        assert!(authority_empty.eq(""));\n        assert!(!non_empty.eq(""));\n    }\n\n    #[test]\n    fn test_eq_with_different_case() {\n        let authority1 = Authority::from_static("my_host");\n        let authority2 = Authority::from_static("MY_HOST");\n\n        assert!(authority1.eq(&authority2));\n        assert!(authority1.eq("MY_HOST"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583303, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=233, prompt_tokens=4066, total_tokens=4299, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgYltrOx1HhBCKiWXLZl5k4GCVh', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let auth_str = "example.com";\n        let authority = Authority::from_static("example.com");\n        assert_eq!(auth_str.partial_cmp(&authority), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let auth_str = "example.com";\n        let authority = Authority::from_static("example.org");\n        assert_eq!(auth_str.partial_cmp(&authority), Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let auth_str = "example.org";\n        let authority = Authority::from_static("example.com");\n        assert_eq!(auth_str.partial_cmp(&authority), Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_case_insensitive() {\n        let auth_str = "EXAMPLE.COM";\n        let authority = Authority::from_static("example.com");\n        assert_eq!(auth_str.partial_cmp(&authority), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty_string() {\n        let auth_str = "";\n        let authority = Authority::empty();\n        assert_eq!(auth_str.partial_cmp(&authority), Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_non_empty_against_empty() {\n        let auth_str = "nonempty.com";\n        let authority = Authority::empty();\n        assert_eq!(auth_str.partial_cmp(&authority), Some(Ordering::Greater));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583310, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=335, prompt_tokens=4112, total_tokens=4447, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmghZ9LziW2Ojtak9kEVP4VkIfXS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Make sure to import the items from the main module\n    use http::uri::Authority;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let authority1: String = "example.com".into();\n        let authority2 = Authority::from_static("example.com");\n\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_case_insensitive_equal() {\n        let authority1: String = "Example.COM".into();\n        let authority2 = Authority::from_static("example.com");\n\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let authority1: String = "example.com".into();\n        let authority2 = Authority::from_static("example.net");\n\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let authority1: String = "example.net".into();\n        let authority2 = Authority::from_static("example.com");\n\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_length() {\n        let authority1: String = "example.com".into();\n        let authority2 = Authority::from_static("example.com:80");\n\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let authority1: String = "".into();\n        let authority2 = Authority::from_static("example.com");\n\n        assert_eq!(authority1.partial_cmp(&authority2), Some(cmp::Ordering::Less));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583319, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=402, prompt_tokens=4598, total_tokens=5000, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgpYlaXqHMWduOAozxXIlunFkFd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = Authority::from_static("example.com");\n        let result = "example.com".partial_cmp(&authority2);\n        assert_eq!(result, Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_case_insensitive_equal() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = Authority::from_static("Example.com");\n        let result = "example.com".partial_cmp(&authority2);\n        assert_eq!(result, Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let authority1 = Authority::from_static("abc.com");\n        let authority2 = Authority::from_static("example.com");\n        let result = "abc.com".partial_cmp(&authority2);\n        assert_eq!(result, Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let authority1 = Authority::from_static("example.com");\n        let authority2 = Authority::from_static("abc.com");\n        let result = "example.com".partial_cmp(&authority2);\n        assert_eq!(result, Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_not_equal() {\n        let authority1 = Authority::from_static("notexample.com");\n        let authority2 = Authority::from_static("example.com");\n        let result = "notexample.com".partial_cmp(&authority2);\n        assert_eq!(result, Some(cmp::Ordering::Greater));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583327, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=373, prompt_tokens=4110, total_tokens=4483, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgzRmdvTwZfNLMWUhEi20pEgtoA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_as_str() {\n        let authority = Authority::from_static("example.com");\n        assert_eq!(authority.as_str(), "example.com");\n\n        let authority_with_port = Authority::from_static("example.com:8080");\n        assert_eq!(authority_with_port.as_str(), "example.com:8080");\n\n        let empty_authority = Authority::empty();\n        assert_eq!(empty_authority.as_str(), "");\n\n        let authority_with_ipv6 = Authority::from_static("[::1]:8080");\n        assert_eq!(authority_with_ipv6.as_str(), "[::1]:8080");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583337, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=152, prompt_tokens=4059, total_tokens=4211, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmh3UmtrX1bBVqOhfGIysN3wW6ja', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_authority_empty() {\n        let authority = Authority::empty();\n        assert_eq!(authority.as_str(), "");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583341, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=55, prompt_tokens=4050, total_tokens=4105, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmh7xtCkv15FkjSmh23g6NLEkTWG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::HeaderName;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_from_maybe_shared_with_bytes() {\n        let hdr_name_bytes: Bytes = Bytes::from_static(b"content-length");\n        let result = Authority::from_maybe_shared(hdr_name_bytes);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().as_str(), "content-length");\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_vec() {\n        let hdr_name_vec = vec![b\'c\', b\'o\', b\'n\', b\'t\', b\'e\', b\'n\', b\'t\', b\'-\', b\'l\', b\'e\', b\'n\', b\'g\', b\'t\', b\'h\'];\n        let result = Authority::from_maybe_shared(hdr_name_vec);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().as_str(), "content-length");\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_string() {\n        let hdr_name_string = String::from("content-length");\n        let result = Authority::from_maybe_shared(hdr_name_string);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().as_str(), "content-length");\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_invalid_bytes() {\n        let hdr_name_invalid: Bytes = Bytes::from_static(b"");\n        let result = Authority::from_maybe_shared(hdr_name_invalid);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_invalid_vec() {\n        let hdr_name_invalid_vec = vec![b\'!\'];\n        let result = Authority::from_maybe_shared(hdr_name_invalid_vec);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583345, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=383, prompt_tokens=4359, total_tokens=4742, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmhFaegq3VPaxIlBFNODMPUc33kq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n    use crate::uri::authority::{Authority, InvalidUri};\n\n    #[test]\n    fn test_from_shared_valid_bytes() {\n        let input = Bytes::from_static(b"example.com");\n        let result = Authority::from_shared(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_from_shared_empty_bytes() {\n        let input = Bytes::from_static(b"");\n        let result = Authority::from_shared(input);\n        assert!(result.is_err());\n        // You can add more specific assertions here, if InvalidUri contains useful information.\n    }\n\n    #[test]\n    fn test_from_shared_invalid_bytes() {\n        // Define some invalid bytes according to your URI validation requirements\n        let input = Bytes::from_static(b"invalid_uri");\n        let result = Authority::from_shared(input);\n        assert!(result.is_err());\n        // You can add more specific assertions here, if InvalidUri contains useful information.\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583353, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=215, prompt_tokens=353, total_tokens=568, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmhOvAS7wvUCyl32cGURlaZFSqkE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_from_static_valid() {\n        let authority = Authority::from_static("example.com");\n        assert_eq!(authority.host(), "example.com");\n    }\n\n    #[test]\n    #[should_panic(expected = "static str is not valid authority")]\n    fn test_from_static_empty() {\n        Authority::from_static("");\n    }\n\n    #[test]\n    #[should_panic(expected = "static str is not valid authority")]\n    fn test_from_static_invalid_character() {\n        Authority::from_static("example.com:80:90");\n    }\n\n    #[test]\n    fn test_from_static_with_port() {\n        let authority = Authority::from_static("example.com:8080");\n        assert_eq!(authority.host(), "example.com");\n        assert_eq!(authority.port().unwrap().as_u16(), 8080);\n    }\n\n    #[test]\n    fn test_from_static_with_ipv6() {\n        let authority = Authority::from_static("[::1]:8080");\n        assert_eq!(authority.host(), "[::1]");\n        assert_eq!(authority.port().unwrap().as_u16(), 8080);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583362, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=256, prompt_tokens=4166, total_tokens=4422, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmhXu0pUtar0GSdOEUoTfVDG6cYC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_host_with_valid_authority() {\n        let authority: Authority = "example.org:80".parse().unwrap();\n        assert_eq!(authority.host(), "example.org");\n    }\n\n    #[test]\n    fn test_host_with_valid_authority_no_port() {\n        let authority: Authority = "example.com".parse().unwrap();\n        assert_eq!(authority.host(), "example.com");\n    }\n\n    #[test]\n    fn test_host_with_ip_literal() {\n        let authority: Authority = "[::1]:8080".parse().unwrap();\n        assert_eq!(authority.host(), "::1");\n    }\n\n    #[test]\n    fn test_host_with_ipv4() {\n        let authority: Authority = "192.168.1.1:8080".parse().unwrap();\n        assert_eq!(authority.host(), "192.168.1.1");\n    }\n\n    #[test]\n    fn test_host_with_subdomain() {\n        let authority: Authority = "sub.example.org:80".parse().unwrap();\n        assert_eq!(authority.host(), "sub.example.org");\n    }\n\n    #[test]\n    fn test_host_case_insensitivity() {\n        let authority: Authority = "Example.org:80".parse().unwrap();\n        assert_eq!(authority.host(), "example.org");\n    }\n\n    #[test]\n    fn test_host_empty_authority() {\n        let authority: Authority = Authority::empty();\n        assert_eq!(authority.host(), ""); // Assumes that empty authority has empty host\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583371, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=335, prompt_tokens=4192, total_tokens=4527, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmheeLlAir82JCy06iji6D4m9o63', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_valid_authority() {\n        let valid_uri = b"username:password@hostname:80";\n        assert_eq!(Authority::parse(valid_uri).is_ok(), true);\n\n        let valid_ipv6 = b"[::1]:80";\n        assert_eq!(Authority::parse(valid_ipv6).is_ok(), true);\n\n        let valid_no_port = b"hostname";\n        assert_eq!(Authority::parse(valid_no_port).is_ok(), true);\n    }\n\n    #[test]\n    fn test_parse_invalid_authority() {\n        let invalid_uri = b"username:password@hostname:80:443";\n        assert_eq!(Authority::parse(invalid_uri).is_err(), true);\n\n        let invalid_ipv6 = b"[::1:80";\n        assert_eq!(Authority::parse(invalid_ipv6).is_err(), true);\n\n        let invalid_percent = b"hostname%20";\n        assert_eq!(Authority::parse(invalid_percent).is_err(), true);\n\n        let invalid_char = b"hostname@";\n        assert_eq!(Authority::parse(invalid_char).is_err(), true);\n\n        let invalid_colons = b"localhost:80:90";\n        assert_eq!(Authority::parse(invalid_colons).is_err(), true);\n    }\n\n    #[test]\n    fn test_parse_edge_cases() {\n        let edge_case_no_colon = b"";\n        assert_eq!(Authority::parse(edge_case_no_colon).is_err(), true);\n\n        let edge_case_at_sign_end = b"hostname@";\n        assert_eq!(Authority::parse(edge_case_at_sign_end).is_err(), true);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583378, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=352, prompt_tokens=911, total_tokens=1263, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmhnCgkqIALDrf0jyGH6uE2Zq6Rt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::authority::Authority;\n    use http::uri::InvalidUri;\n    \n    #[test]\n    fn test_parse_non_empty_valid() {\n        let input = b"localhost:8080";\n        let result = Authority::parse_non_empty(input);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), input.len());\n    }\n    \n    #[test]\n    fn test_parse_non_empty_empty() {\n        let input: &[u8] = b"";\n        let result = Authority::parse_non_empty(input);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().kind(), InvalidUri::Empty);\n    }\n    \n    #[test]\n    fn test_parse_non_empty_invalid() {\n        let input = b"invalid_authority";\n        let result = Authority::parse_non_empty(input);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583387, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=195, prompt_tokens=178, total_tokens=373, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmhtVtR1816mqD3jrjDCiFQSXLvz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_port_with_port() {\n        let authority: Authority = "example.org:80".parse().unwrap();\n        let port = authority.port().unwrap();\n        assert_eq!(port.as_u16(), 80);\n        assert_eq!(port.as_str(), "80");\n    }\n\n    #[test]\n    fn test_port_without_port() {\n        let authority: Authority = "example.org".parse().unwrap();\n        assert!(authority.port().is_none());\n    }\n\n    #[test]\n    fn test_port_with_custom_port() {\n        let authority: Authority = "example.com:8080".parse().unwrap();\n        let port = authority.port().unwrap();\n        assert_eq!(port.as_u16(), 8080);\n        assert_eq!(port.as_str(), "8080");\n    }\n\n    #[test]\n    fn test_port_with_ipv6_address() {\n        let authority: Authority = "[::1]:3000".parse().unwrap();\n        let port = authority.port().unwrap();\n        assert_eq!(port.as_u16(), 3000);\n        assert_eq!(port.as_str(), "3000");\n    }\n\n    #[test]\n    fn test_port_with_non_numeric_port() {\n        let authority: Authority = "example.com:abc".parse().unwrap();\n        assert!(authority.port().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583393, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=297, prompt_tokens=4311, total_tokens=4608, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmi3qk4z4Ht3mSSY821cP0gAEIxH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_port_u16_with_port() {\n        let authority: Authority = "example.org:80".parse().unwrap();\n        assert_eq!(authority.port_u16(), Some(80));\n    }\n\n    #[test]\n    fn test_port_u16_without_port() {\n        let authority: Authority = "example.org".parse().unwrap();\n        assert_eq!(authority.port_u16(), None);\n    }\n\n    #[test]\n    fn test_port_u16_with_non_standard_port() {\n        let authority: Authority = "example.org:65535".parse().unwrap();\n        assert_eq!(authority.port_u16(), Some(65535));\n    }\n\n    #[test]\n    fn test_port_u16_invalid_port() {\n        let authority: Authority = "example.org:abcd".parse().unwrap();\n        assert_eq!(authority.port_u16(), None); // This assumes the parse fails for invalid format\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583403, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=212, prompt_tokens=4119, total_tokens=4331, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmiADfpS0x3RWPO5tsvs3gqzqT78', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::header::{HeaderName, InvalidHeaderName};\n\n    #[test]\n    fn test_create_authority_valid() {\n        let input: &[u8] = b"example.com";\n        let result = create_authority(input, |b| Bytes::copy_from_slice(b));\n        assert!(result.is_ok());\n        \n        let authority = result.unwrap();\n        assert_eq!(authority.as_str(), "example.com");\n    }\n\n    #[test]\n    fn test_create_authority_invalid() {\n        let input: &[u8] = b"invalid uri";\n        let result = create_authority(input, |b| Bytes::copy_from_slice(b));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_create_authority_UTF8_conversion() {\n        let input: &[u8] = b"valid-authority";\n        let result = create_authority(input, |b| Bytes::copy_from_slice(b));\n        assert!(result.is_ok());\n\n        let authority = result.unwrap();\n        assert_eq!(authority.as_str(), "valid-authority");\n    }\n\n    #[test]\n    fn test_create_authority_empty() {\n        let input: &[u8] = b"";\n        let result = create_authority(input, |b| Bytes::copy_from_slice(b));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_create_authority_invalid_characters() {\n        let input: &[u8] = b"invalid%authority";\n        let result = create_authority(input, |b| Bytes::copy_from_slice(b));\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583410, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=348, prompt_tokens=4409, total_tokens=4757, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmiMJ93ScBF3gPoegLHG0XteysRY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::host;\n\n    #[test]\n    fn test_host_with_plain_host() {\n        let auth = "user:password@hostname:8080";\n        let result = host(auth);\n        assert_eq!(result, "hostname");\n    }\n\n    #[test]\n    fn test_host_with_ipv4() {\n        let auth = "user:password@192.168.1.1:8080";\n        let result = host(auth);\n        assert_eq!(result, "192.168.1.1");\n    }\n\n    #[test]\n    fn test_host_with_ipv6() {\n        let auth = "user:password@[::1]:8080";\n        let result = host(auth);\n        assert_eq!(result, "[::1]");\n    }\n\n    #[test]\n    fn test_host_with_no_port() {\n        let auth = "user:password@hostname";\n        let result = host(auth);\n        assert_eq!(result, "hostname");\n    }\n\n    #[test]\n    fn test_host_with_only_host() {\n        let auth = "hostname";\n        let result = host(auth);\n        assert_eq!(result, "hostname");\n    }\n\n    #[test]\n    fn test_host_with_no_auth() {\n        let auth = "@hostname:8080";\n        let result = host(auth);\n        assert_eq!(result, "hostname");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583422, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=288, prompt_tokens=268, total_tokens=556, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmiVuJETBAVdKpFvY6Tx5i9u49g8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Importing everything in the current module.\n    use http::uri::{Builder, Authority}; // Change the import path based on your crate structure\n    use std::convert::TryInto;\n\n    #[test]\n    fn test_authority_valid() {\n        let builder = Builder::new();\n        let result = builder.authority("example.com").build();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_authority_with_path() {\n        let builder = Builder::new();\n        let result = builder\n            .authority("example.com")\n            .path_and_query("/path")\n            .build();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_authority_invalid() {\n        let builder = Builder::new();\n        let result = builder.authority("::invalid_authority").build();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_authority_empty() {\n        let builder = Builder::new();\n        let result = builder.authority("").build();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_authority_with_special_chars() {\n        let builder = Builder::new();\n        let result = builder.authority("user@host.com").build();\n        assert!(result.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583431, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=282, prompt_tokens=1294, total_tokens=1576, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmicabzBouzce9v7HRAtnZgUhI0z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::uri::Builder;\n    use crate::Error;\n\n    #[test]\n    fn test_build_valid_uri() {\n        let uri = Builder::new()\n            .scheme("https")\n            .authority("hyper.rs")\n            .path_and_query("/")\n            .build()\n            .unwrap();\n        \n        assert_eq!(uri.to_string(), "https://hyper.rs/");\n    }\n\n    #[test]\n    fn test_build_uri_without_scheme() {\n        let result = Builder::new()\n            .authority("hyper.rs")\n            .path_and_query("/")\n            .build();\n        \n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), "Scheme is required"); // Adjust error message for actual implementation\n    }\n\n    #[test]\n    fn test_build_uri_with_invalid_scheme() {\n        let result = Builder::new()\n            .scheme("!@#%/^")\n            .authority("hyper.rs")\n            .path_and_query("/")\n            .build();\n        \n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), "Invalid scheme"); // Adjust error message for actual implementation\n    }\n\n    #[test]\n    fn test_build_uri_with_all_parts() {\n        let uri = Builder::new()\n            .scheme("http")\n            .authority("example.com")\n            .path_and_query("/path")\n            .build()\n            .unwrap();\n        \n        assert_eq!(uri.to_string(), "http://example.com/path");\n    }\n\n    #[test]\n    fn test_build_empty_uri() {\n        let result = Builder::new().build();\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), "Scheme is required"); // Adjust error message for actual implementation\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583438, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=372, prompt_tokens=1365, total_tokens=1737, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmihL9UxZJoSuypiYN65HKDFoMW4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::uri::builder::{Builder, Parts};\n    use crate::Error;\n\n    #[test]\n    fn test_map_success() {\n        let builder = Builder::new();\n        let result = builder.map(|mut parts| {\n            parts.scheme = Some("http".try_into().unwrap());\n            Ok(parts)\n        });\n        assert!(result.parts.is_ok());\n        assert_eq!(result.parts.unwrap().scheme, Some("http".try_into().unwrap()));\n    }\n\n    #[test]\n    fn test_map_failure() {\n        let builder = Builder::new();\n        let result = builder.map(|mut parts| {\n            Err(Error::from("Failed to map parts"))\n        });\n        assert!(result.parts.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583443, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=165, prompt_tokens=1210, total_tokens=1375, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmim0fPOWahK1x3L07S8vGbA1ZO0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri;\n\n    #[test]\n    fn test_builder_new() {\n        let builder = uri::Builder::new();\n        assert!(builder.parts.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583448, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=53, prompt_tokens=1248, total_tokens=1301, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmipM6QTHKjUyEvnBv0RVeGN5j5M', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Uri, PathAndQuery, Error};\n\n    #[test]\n    fn test_path_and_query_valid() {\n        let uri = uri::Builder::new()\n            .path_and_query("/hello?foo=bar")\n            .build()\n            .unwrap();\n\n        assert_eq!(uri.path_and_query().unwrap().as_str(), "/hello?foo=bar");\n    }\n\n    #[test]\n    fn test_path_and_query_no_query() {\n        let uri = uri::Builder::new()\n            .path_and_query("/hello")\n            .build()\n            .unwrap();\n\n        assert_eq!(uri.path_and_query().unwrap().as_str(), "/hello");\n    }\n\n    #[test]\n    fn test_path_and_query_invalid() {\n        let result = uri::Builder::new()\n            .path_and_query("/hello?foo=bar")\n            .authority("example.com")\n            .scheme("http")\n            .build();\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_path_and_query_invalid_uri() {\n        let result = uri::Builder::new()\n            .path_and_query("invalid_path_with_no_slash?")\n            .build();\n\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583451, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=264, prompt_tokens=1317, total_tokens=1581, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmizqJuzQ77kpuYYBjANLnpopuCL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::{Scheme, Uri};\n    use std::convert::TryInto;\n\n    #[test]\n    fn test_scheme() {\n        let builder = uri::Builder::new();\n        let builder = builder.scheme("https").build();\n        assert!(builder.is_ok());\n\n        let uri = builder.unwrap();\n        assert_eq!(uri.scheme_str(), Some("https"));\n\n        let builder = uri::Builder::new();\n        let builder = builder.scheme("http").build();\n        assert!(builder.is_ok());\n\n        let uri = builder.unwrap();\n        assert_eq!(uri.scheme_str(), Some("http"));\n\n        let builder = uri::Builder::new();\n        let builder = builder.scheme("invalid_scheme!").build();\n        assert!(builder.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583461, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=169, prompt_tokens=1282, total_tokens=1451, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmj3AqpJwKVZgbeY7j2W15y56bYr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n    use http::uri::parse_full;\n\n    #[test]\n    fn test_parse_full_valid_uri() {\n        let input = Bytes::from("http://example.com/path?query=123");\n        let result = parse_full(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_full_invalid_scheme() {\n        let input = Bytes::from("://example.com/path");\n        let result = parse_full(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_full_missing_authority() {\n        let input = Bytes::from("http:/path");\n        let result = parse_full(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_full_valid_uri_without_path() {\n        let input = Bytes::from("ftp://example.com");\n        let result = parse_full(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_full_invalid_format() {\n        let input = Bytes::from("http://");\n        let result = parse_full(input);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583465, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=251, prompt_tokens=679, total_tokens=930, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjAw4rCrGHXpN8JbmGWJN4F7C0P', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::path::PathAndQuery;\n\n    #[test]\n    fn test_eq_with_equal_str() {\n        let path_and_query = PathAndQuery::from_static("/test");\n        let result = "/test".eq(&path_and_query);\n        assert!(result);\n    }\n\n    #[test]\n    fn test_eq_with_different_str() {\n        let path_and_query = PathAndQuery::from_static("/test");\n        let result = "/different".eq(&path_and_query);\n        assert!(!result);\n    }\n\n    #[test]\n    fn test_eq_with_empty_string() {\n        let path_and_query = PathAndQuery::empty();\n        let result = "".eq(&path_and_query);\n        assert!(result);\n    }\n\n    #[test]\n    fn test_eq_with_empty_path_and_query() {\n        let path_and_query = PathAndQuery::empty();\n        let result = "/non-empty".eq(&path_and_query);\n        assert!(!result);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583472, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=218, prompt_tokens=3922, total_tokens=4140, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjH7ISJqk2oG8UjJqawc4cqwJbU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_eq_same_path() {\n        let path_string = String::from("/test/path");\n        let path_query = PathAndQuery::from_static("/test/path");\n        assert!(path_string.eq(&path_query));\n    }\n\n    #[test]\n    fn test_eq_different_path() {\n        let path_string = String::from("/test/path");\n        let path_query = PathAndQuery::from_static("/different/path");\n        assert!(!path_string.eq(&path_query));\n    }\n\n    #[test]\n    fn test_eq_empty_path() {\n        let path_string = String::from("");\n        let path_query = PathAndQuery::from_static("");\n        assert!(path_string.eq(&path_query));\n    }\n\n    #[test]\n    fn test_eq_path_with_query() {\n        let path_string = String::from("/test/path?query=1");\n        let path_query = PathAndQuery::from_static("/test/path?query=1");\n        assert!(path_string.eq(&path_query));\n    }\n\n    #[test]\n    fn test_eq_path_with_different_query() {\n        let path_string = String::from("/test/path?query=1");\n        let path_query = PathAndQuery::from_static("/test/path?query=2");\n        assert!(!path_string.eq(&path_query));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583479, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=298, prompt_tokens=4410, total_tokens=4708, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjP3UOhZxZBrSkKcWpKnR54xPkF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_eq_with_equal_strings() {\n        let path: &str = "/hello/world";\n        let path_and_query = PathAndQuery::from_static("/hello/world");\n\n        assert!(path.eq(&path_and_query));\n    }\n\n    #[test]\n    fn test_eq_with_different_strings() {\n        let path: &str = "/hello/world";\n        let path_and_query = PathAndQuery::from_static("/hello/universe");\n\n        assert!(!path.eq(&path_and_query));\n    }\n\n    #[test]\n    fn test_eq_with_empty_string() {\n        let path: &str = "";\n        let path_and_query = PathAndQuery::empty();\n\n        assert!(path.eq(&path_and_query));\n    }\n\n    #[test]\n    fn test_eq_with_root() {\n        let path: &str = "/";\n        let path_and_query = PathAndQuery::slash();\n\n        assert!(path.eq(&path_and_query));\n    }\n\n    #[test]\n    fn test_eq_with_star() {\n        let path: &str = "*";\n        let path_and_query = PathAndQuery::star();\n\n        assert!(path.eq(&path_and_query));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583487, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=267, prompt_tokens=3919, total_tokens=4186, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjVjCVZrTM0FkapUCKcTJRE3dZK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust the import based on the actual module structure\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let path_str = "/hello/world";\n        let path_and_query = PathAndQuery::from_static("/hello/world");\n        assert_eq!(path_str.partial_cmp(&path_and_query), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let path_str = "/hello";\n        let path_and_query = PathAndQuery::from_static("/hello/world");\n        assert_eq!(path_str.partial_cmp(&path_and_query), Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let path_str = "/hello/world/z";\n        let path_and_query = PathAndQuery::from_static("/hello/world");\n        assert_eq!(path_str.partial_cmp(&path_and_query), Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_different_self_types() {\n        let path_str = "/abc";\n        let path_and_query = PathAndQuery::from_static("/abc?query=1");\n        assert_eq!(path_str.partial_cmp(&path_and_query), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let path_str = "";\n        let path_and_query = PathAndQuery::from_static("/hello");\n        assert_eq!(path_str.partial_cmp(&path_and_query), Some(Ordering::Less));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583493, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=331, prompt_tokens=3930, total_tokens=4261, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjevJHuSZ9Ax5KWusHFz6A5nOrq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let path: String = String::from("/hello/world");\n        let other: PathAndQuery = PathAndQuery::from_static("/hello/world");\n        assert_eq!(path.partial_cmp(&other), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let path: String = String::from("/hello");\n        let other: PathAndQuery = PathAndQuery::from_static("/hello/world");\n        assert_eq!(path.partial_cmp(&other), Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let path: String = String::from("/hello/world/something");\n        let other: PathAndQuery = PathAndQuery::from_static("/hello/world");\n        assert_eq!(path.partial_cmp(&other), Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_differing() {\n        let path: String = String::from("/hello/world");\n        let other: PathAndQuery = PathAndQuery::from_static("/goodbye/world");\n        assert_eq!(path.partial_cmp(&other), Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let path: String = String::from("");\n        let other: PathAndQuery = PathAndQuery::from_static("/path");\n        assert_eq!(path.partial_cmp(&other), Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_query() {\n        let path: String = String::from("/hello/world?query=test");\n        let other: PathAndQuery = PathAndQuery::from_static("/hello/world?query=test");\n        assert_eq!(path.partial_cmp(&other), Some(Ordering::Equal));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583502, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=398, prompt_tokens=4418, total_tokens=4816, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjoMwt0mKLRyv6o16lWg3PksUP8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import everything in the scope\n    use http::uri::path::{PathAndQuery};\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let path1 = PathAndQuery::from_static("/test");\n        let path2 = PathAndQuery::from_static("/test");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less_than() {\n        let path1 = PathAndQuery::from_static("/abc");\n        let path2 = PathAndQuery::from_static("/xyz");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater_than() {\n        let path1 = PathAndQuery::from_static("/xyz");\n        let path2 = PathAndQuery::from_static("/abc");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let path1 = PathAndQuery::from_static("");\n        let path2 = PathAndQuery::from_static("/abc");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty_equal() {\n        let path1 = PathAndQuery::from_static("");\n        let path2 = PathAndQuery::from_static("");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_with_static_string() {\n        let path1 = PathAndQuery::from_static("/static");\n        let path2 = String::from("/static");\n        assert_eq!(path1.partial_cmp(&path2), Some(cmp::Ordering::Equal));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583512, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=405, prompt_tokens=3927, total_tokens=4332, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjyvA6eqlnA3JNdxgRBaW67dxBB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_as_str_with_query() {\n        let path_and_query: PathAndQuery = "/hello/world?key=value&foo=bar".parse().unwrap();\n        assert_eq!(path_and_query.as_str(), "/hello/world?key=value&foo=bar");\n    }\n\n    #[test]\n    fn test_as_str_without_query() {\n        let path_and_query: PathAndQuery = "/hello/world".parse().unwrap();\n        assert_eq!(path_and_query.as_str(), "/hello/world");\n    }\n\n    #[test]\n    fn test_as_str_empty() {\n        let path_and_query: PathAndQuery = "/".parse().unwrap();\n        assert_eq!(path_and_query.as_str(), "/");\n    }\n\n    #[test]\n    fn test_as_str_empty_query() {\n        let path_and_query: PathAndQuery = "/hello/world?".parse().unwrap();\n        assert_eq!(path_and_query.as_str(), "/hello/world?");\n    }\n\n    #[test]\n    fn test_as_str_with_special_chars() {\n        let path_and_query: PathAndQuery = "/path/with space?query=hello%20world".parse().unwrap();\n        assert_eq!(path_and_query.as_str(), "/path/with space?query=hello%20world");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583522, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=289, prompt_tokens=4048, total_tokens=4337, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmk4JnCqTpGSMk9ntl7MRKQI3WqD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::PathAndQuery;\n\n    #[test]\n    fn test_empty_path_and_query() {\n        let path_and_query = PathAndQuery::empty();\n        assert_eq!(path_and_query.as_str(), "/");\n        assert!(path_and_query.query().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583528, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=70, prompt_tokens=3908, total_tokens=3978, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmk8RNfu82KtPEMTF98DtIijxehM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n\n    #[test]\n    fn test_from_maybe_shared_with_shared_bytes() {\n        let bytes = Bytes::from_static(b"/path?query=value");\n        let result = PathAndQuery::from_maybe_shared(bytes.clone());\n        assert!(result.is_ok());\n        let path_and_query = result.unwrap();\n        assert_eq!(path_and_query.as_str(), "/path?query=value");\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_owned_bytes() {\n        let bytes = b"/path?query=value".to_vec();\n        let result = PathAndQuery::from_maybe_shared(bytes);\n        assert!(result.is_ok());\n        let path_and_query = result.unwrap();\n        assert_eq!(path_and_query.as_str(), "/path?query=value");\n    }\n\n    #[test]\n    fn test_from_maybe_shared_with_invalid_bytes() {\n        let bytes: &[u8] = b"\\xFF"; // Invalid UTF-8\n        let result = PathAndQuery::from_maybe_shared(bytes);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583532, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=239, prompt_tokens=4366, total_tokens=4605, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkF9zWN9Srb4iJpQbZcVIuk31O3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bytes::Bytes;\n    use crate::uri::path::PathAndQuery;\n    use crate::InvalidUri;\n\n    #[test]\n    fn test_from_shared_valid_path() {\n        let bytes = Bytes::from_static(b"/valid/path");\n        let result = PathAndQuery::from_shared(bytes);\n        assert!(result.is_ok());\n        let path_and_query = result.unwrap();\n        assert_eq!(path_and_query.data, ByteStr::from_static(b"/valid/path"));\n        assert_eq!(path_and_query.query, NONE);\n    }\n\n    #[test]\n    fn test_from_shared_valid_path_with_query() {\n        let bytes = Bytes::from_static(b"/path?query=1");\n        let result = PathAndQuery::from_shared(bytes);\n        assert!(result.is_ok());\n        let path_and_query = result.unwrap();\n        assert_eq!(path_and_query.data, ByteStr::from_static(b"/path"));\n        assert_eq!(path_and_query.query, 5); // index of \'?\'\n    }\n\n    #[test]\n    fn test_from_shared_valid_path_with_fragment() {\n        let bytes = Bytes::from_static(b"/path#fragment");\n        let result = PathAndQuery::from_shared(bytes);\n        assert!(result.is_ok());\n        let path_and_query = result.unwrap();\n        assert_eq!(path_and_query.data, ByteStr::from_static(b"/path"));\n        assert_eq!(path_and_query.query, NONE);\n    }\n\n    #[test]\n    fn test_from_shared_invalid_character() {\n        let bytes = Bytes::from_static(b"/path\\xFF");\n        let result = PathAndQuery::from_shared(bytes);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().kind(), InvalidUri::InvalidUriChar);\n    }\n\n    #[test]\n    fn test_from_shared_invalid_percent_encoding() {\n        let bytes = Bytes::from_static(b"/path\\x20with space");\n        let result = PathAndQuery::from_shared(bytes);\n        assert!(result.is_ok());\n        let path_and_query = result.unwrap();\n        assert_eq!(path_and_query.data, ByteStr::from_static(b"/path with space"));\n        assert_eq!(path_and_query.query, NONE);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583539, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=467, prompt_tokens=1022, total_tokens=1489, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkQPINy7TVUJFGvljUZnaCAMwDA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    #[should_panic(expected = "invalid path and query")]\n    fn test_from_static_invalid_path() {\n        // This path is invalid, according to the logic provided in from_shared.\n        let _ = PathAndQuery::from_static("invalid path with spaces");\n    }\n\n    #[test]\n    fn test_from_static_valid_path() {\n        let path_and_query = PathAndQuery::from_static("/hello?world");\n        assert_eq!(path_and_query.path(), "/hello");\n        assert_eq!(path_and_query.query(), Some("world"));\n    }\n\n    #[test]\n    fn test_from_static_empty_path() {\n        let path_and_query = PathAndQuery::from_static("/");\n        assert_eq!(path_and_query.path(), "/");\n        assert!(path_and_query.query().is_none());\n    }\n\n    #[test]\n    fn test_from_static_path_without_query() {\n        let path_and_query = PathAndQuery::from_static("/hello");\n        assert_eq!(path_and_query.path(), "/hello");\n        assert!(path_and_query.query().is_none());\n    }\n\n    #[test]\n    fn test_from_static_query_only() {\n        let path_and_query = PathAndQuery::from_static("?key=value");\n        assert_eq!(path_and_query.path(), "/");\n        assert_eq!(path_and_query.query(), Some("key=value"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583550, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=303, prompt_tokens=4024, total_tokens=4327, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkZxtiIzmvKc9WNbDYpI6fC1xGy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_path_only() {\n        let path_and_query: PathAndQuery = "/hello/world".parse().unwrap();\n        assert_eq!(path_and_query.path(), "/hello/world");\n    }\n\n    #[test]\n    fn test_path_with_query() {\n        let path_and_query: PathAndQuery = "/hello/world?key=value".parse().unwrap();\n        assert_eq!(path_and_query.path(), "/hello/world");\n    }\n\n    #[test]\n    fn test_empty_path() {\n        let path_and_query: PathAndQuery = "".parse().unwrap();\n        assert_eq!(path_and_query.path(), "/");\n    }\n\n    #[test]\n    fn test_star_path() {\n        let path_and_query: PathAndQuery = "*".parse().unwrap();\n        assert_eq!(path_and_query.path(), "*");\n    }\n\n    #[test]\n    fn test_path_with_fragment() {\n        let path_and_query: PathAndQuery = "/hello/world#frag".parse().unwrap();\n        assert_eq!(path_and_query.path(), "/hello/world");\n    }\n\n    #[test]\n    fn test_single_slash_path() {\n        let path_and_query: PathAndQuery = "/".parse().unwrap();\n        assert_eq!(path_and_query.path(), "/");\n    }\n\n    #[test]\n    fn test_no_path_with_query() {\n        let path_and_query: PathAndQuery = "?key=value".parse().unwrap();\n        assert_eq!(path_and_query.path(), "/");\n    }\n\n    #[test]\n    fn test_path_with_multiple_queries() {\n        let path_and_query: PathAndQuery = "/hello/world?key1=value1&key2=value2".parse().unwrap();\n        assert_eq!(path_and_query.path(), "/hello/world");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583559, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=386, prompt_tokens=4063, total_tokens=4449, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmkj9lmBxz2KmJtA1GM5rKfEcZyJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_query_with_query_string() {\n        let path_and_query: PathAndQuery = "/hello/world?key=value&foo=bar".parse().unwrap();\n        assert_eq!(path_and_query.query(), Some("key=value&foo=bar"));\n    }\n\n    #[test]\n    fn test_query_without_query_string() {\n        let path_and_query: PathAndQuery = "/hello/world".parse().unwrap();\n        assert!(path_and_query.query().is_none());\n    }\n\n    #[test]\n    fn test_query_with_only_query_string() {\n        let path_and_query: PathAndQuery = "/hello/world?key=val&key2=val2#fragment".parse().unwrap();\n        assert_eq!(path_and_query.query(), Some("key=val&key2=val2"));\n    }\n\n    #[test]\n    fn test_query_with_fragment() {\n        let path_and_query: PathAndQuery = "/path/to/resource?query=value#fragment".parse().unwrap();\n        assert_eq!(path_and_query.query(), Some("query=value"));\n    }\n\n    #[test]\n    fn test_query_with_empty_query() {\n        let path_and_query: PathAndQuery = "/path/to/resource?".parse().unwrap();\n        assert_eq!(path_and_query.query(), Some(""));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583569, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=292, prompt_tokens=4174, total_tokens=4466, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkuhQZzQvObf6eXL1VImYzkWvgJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::PathAndQuery;\n\n    #[test]\n    fn test_slash() {\n        let pq = PathAndQuery::slash();\n        assert_eq!(pq.data.as_str(), "/");\n        assert_eq!(pq.query, NONE);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583580, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=69, prompt_tokens=3910, total_tokens=3979, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcml1P3cRAW8CDwnYetdrhvSzq49X', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust path as needed to import PathAndQuery\n    use http::uri::path::PathAndQuery;\n\n    #[test]\n    fn test_star() {\n        let path_and_query = PathAndQuery::star();\n        assert_eq!(path_and_query.as_str(), "*");\n        assert!(path_and_query.query().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583587, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=87, prompt_tokens=3910, total_tokens=3997, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcml4DORsX8V0oviTMQ7gxnL6wvBG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::port::Port;\n\n    #[test]\n    fn test_eq_with_same_port() {\n        let port1 = Port { port: 80, repr: "80" };\n        let port2 = 80u16;\n\n        assert!(port1.eq(&port2));\n    }\n\n    #[test]\n    fn test_eq_with_different_port() {\n        let port1 = Port { port: 80, repr: "80" };\n        let port2 = 81u16;\n\n        assert!(!port1.eq(&port2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583590, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=134, prompt_tokens=846, total_tokens=980, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcml8wIY2IaLRi6bGLLexwRJd9YNN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::uri::port::Port;\n\n    #[test]\n    fn test_from_port() {\n        let port_value = 80;\n        let port = Port {\n            port: port_value,\n            repr: "80".to_string(), // Using a String as repr\n        };\n        let u16_value: u16 = From::from(port);\n        assert_eq!(u16_value, port_value);\n    }\n\n    #[test]\n    fn test_from_port_eq() {\n        let port = Port {\n            port: 8080,\n            repr: "8080".to_string(),\n        };\n        let u16_value: u16 = From::from(port);\n        assert_eq!(u16_value, 8080);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583594, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=167, prompt_tokens=840, total_tokens=1007, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmlDCQL2M0o8XgySaebFSwJFLilI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_port_as_str() {\n        let authority: Authority = "example.org:80".parse().unwrap();\n        let port = authority.port().unwrap();\n        assert_eq!(port.as_str(), "80");\n    }\n\n    #[test]\n    fn test_port_as_str_invalid() {\n        let invalid_authority: Authority = "example.org:invalid".parse().unwrap_err();\n        assert!(invalid_authority.is_err());\n    }\n\n    #[test]\n    fn test_port_as_str_multiple_digits() {\n        let authority: Authority = "example.org:12345".parse().unwrap();\n        let port = authority.port().unwrap();\n        assert_eq!(port.as_str(), "12345");\n    }\n\n    #[test]\n    fn test_port_as_str_zero() {\n        let authority: Authority = "example.org:0".parse().unwrap();\n        let port = authority.port().unwrap();\n        assert_eq!(port.as_str(), "0");\n    }\n\n    #[test]\n    fn test_port_as_str_max() {\n        let authority: Authority = "example.org:65535".parse().unwrap();\n        let port = authority.port().unwrap();\n        assert_eq!(port.as_str(), "65535");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583599, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=275, prompt_tokens=899, total_tokens=1174, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmlJZzaUbcheviXMIsXVvIKKfOLS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Authority;\n\n    #[test]\n    fn test_as_u16() {\n        let authority: Authority = "example.org:80".parse().unwrap();\n        let port = authority.port().unwrap();\n        assert_eq!(port.as_u16(), 80);\n    }\n\n    #[test]\n    fn test_as_u16_another_port() {\n        let authority: Authority = "example.org:443".parse().unwrap();\n        let port = authority.port().unwrap();\n        assert_eq!(port.as_u16(), 443);\n    }\n\n    #[test]\n    fn test_as_u16_invalid_port() {\n        let authority: Authority = "example.org:invalid".parse();\n        assert!(authority.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583605, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=166, prompt_tokens=903, total_tokens=1069, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmlONcldNBwMpanlUPfX6L13S5Qc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::str::FromStr;\n\n    #[test]\n    fn test_from_str_valid() {\n        let valid_port_str = "8080";\n        let port = Port::<&str>::from_str(valid_port_str).unwrap();\n        assert_eq!(port.port, 8080);\n        assert_eq!(port.repr, valid_port_str);\n    }\n\n    #[test]\n    fn test_from_str_invalid() {\n        let invalid_port_str = "abc";\n        let result = Port::<&str>::from_str(invalid_port_str);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_from_str_out_of_range() {\n        let out_of_range_str = "70000";\n        let result = Port::<&str>::from_str(out_of_range_str);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583610, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=185, prompt_tokens=218, total_tokens=403, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmlWSrX1K0hbtod8rVWsPaTlMKCI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::scheme::{Scheme, Protocol};\n\n    #[test]\n    fn test_eq_http() {\n        let http_scheme = Scheme::HTTP;\n        let http_str = "http";\n        assert!(http_scheme.eq(http_str));\n    }\n\n    #[test]\n    fn test_eq_https() {\n        let https_scheme = Scheme::HTTPS;\n        let https_str = "https";\n        assert!(https_scheme.eq(https_str));\n    }\n\n    #[test]\n    fn test_eq_case_insensitivity() {\n        let http_scheme = Scheme::HTTP;\n        let http_str = "HTTP";\n        assert!(http_scheme.eq(http_str));\n        \n        let https_scheme = Scheme::HTTPS;\n        let https_str = "HTTPS";\n        assert!(https_scheme.eq(https_str));\n    }\n\n    #[test]\n    fn test_eq_different_schemes() {\n        let http_scheme = Scheme::HTTP;\n        let https_scheme = Scheme::HTTPS;\n        assert!(!http_scheme.eq(&https_scheme));\n        assert!(!https_scheme.eq(&http_scheme));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583618, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=233, prompt_tokens=1942, total_tokens=2175, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmldTfXxqp1yxrp1lLm6aNpMVVbz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::super::super::uri::scheme::Protocol;\n\n    #[test]\n    fn test_protocol_len() {\n        assert_eq!(Protocol::Http.len(), 4);\n        assert_eq!(Protocol::Https.len(), 5);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583625, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=63, prompt_tokens=273, total_tokens=336, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmlhmc5cYicE1r0EkWeF8ugOlIfP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use uri::scheme::Scheme2;\n\n    #[test]\n    fn test_is_none() {\n        let none_scheme: Scheme2<()> = Scheme2::None;\n        let standard_http: Scheme2<()> = Scheme2::Standard(Protocol::Http);\n        let standard_https: Scheme2<()> = Scheme2::Standard(Protocol::Https);\n        let other_scheme: Scheme2<()> = Scheme2::Other(());\n\n        assert!(none_scheme.is_none());\n        assert!(!standard_http.is_none());\n        assert!(!standard_https.is_none());\n        assert!(!other_scheme.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583629, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=138, prompt_tokens=923, total_tokens=1061, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmll0jwcYA5kVItoeU2k8MWeDX8L', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::uri::scheme::{Scheme2, InvalidUri};\n\n    #[test]\n    fn test_parse_http() {\n        let input = b"http://example.com";\n        let result = Scheme2::<usize>::parse(input);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Scheme2::Http);\n    }\n\n    #[test]\n    fn test_parse_https() {\n        let input = b"https://example.com";\n        let result = Scheme2::<usize>::parse(input);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Scheme2::Https);\n    }\n\n    #[test]\n    fn test_parse_custom_scheme() {\n        let input = b"custom://example.com";\n        let result = Scheme2::<usize>::parse(input);\n        assert!(result.is_ok());\n        if let Scheme2::Other(len) = result.unwrap() {\n            assert_eq!(len, 6); // Length of \'custom\'\n        } else {\n            panic!("Expected Scheme2::Other");\n        }\n    }\n\n    #[test]\n    fn test_parse_invalid_scheme() {\n        let input = b"invalid://";\n        let result = Scheme2::<usize>::parse(input);\n        assert!(result.is_ok());\n        if let Scheme2::Other(len) = result.unwrap() {\n            assert_eq!(len, 7); // Length of \'invalid\'\n        } else {\n            panic!("Expected Scheme2::Other");\n        }\n    }\n\n    #[test]\n    fn test_parse_scheme_too_long() {\n        let input = b"this-is-a-very-very-long-scheme://example.com";\n        let result = Scheme2::<usize>::parse(input);\n        assert!(result.is_err());\n        assert!(matches!(result.unwrap_err(), InvalidUri::SchemeTooLong));\n    }\n\n    #[test]\n    fn test_parse_no_scheme() {\n        let input = b"example.com";\n        let result = Scheme2::<usize>::parse(input);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Scheme2::None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583633, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=437, prompt_tokens=419, total_tokens=856, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmluiSWXdstleWglXzSnJtJwTJAE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::uri::scheme::Scheme2;\n    use crate::uri::InvalidUri;\n\n    #[test]\n    fn test_parse_exact_http() {\n        let result = Scheme2::<()>::parse_exact(b"http");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Scheme2::Http(()));\n    }\n\n    #[test]\n    fn test_parse_exact_https() {\n        let result = Scheme2::<()>::parse_exact(b"https");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Scheme2::Https(()));\n    }\n\n    #[test]\n    fn test_parse_exact_invalid_scheme() {\n        let result = Scheme2::<()>::parse_exact(b"ftp");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), Scheme2::Other(()));\n    }\n\n    #[test]\n    fn test_parse_exact_scheme_too_long() {\n        let result = Scheme2::<()>::parse_exact(b"abcdefghijabcdefghij");\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().kind(), &ErrorKind::SchemeTooLong);\n    }\n\n    #[test]\n    fn test_parse_exact_invalid_char() {\n        let result = Scheme2::<()>::parse_exact(b"http:abc");\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().kind(), &ErrorKind::InvalidScheme);\n    }\n\n    #[test]\n    fn test_parse_exact_invalid_utf8() {\n        let result = Scheme2::<()>::parse_exact(b"\\xFF");\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().kind(), &ErrorKind::InvalidScheme);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583642, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=353, prompt_tokens=326, total_tokens=679, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmm3PQcRlzMQEHATLEGMoj3DgHMv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::Scheme;\n\n    #[test]\n    fn test_as_str_http() {\n        let scheme: Scheme = "http".parse().unwrap();\n        assert_eq!(scheme.as_str(), "http");\n    }\n\n    #[test]\n    fn test_as_str_https() {\n        let scheme: Scheme = "https".parse().unwrap();\n        assert_eq!(scheme.as_str(), "https");\n    }\n\n    #[test]\n    fn test_as_str_other() {\n        let scheme: Scheme = "ftp".parse().unwrap(); // Assuming "ftp" is valid\n        assert_eq!(scheme.as_str(), "ftp");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_as_str_none() {\n        let scheme = Scheme::empty();\n        scheme.as_str(); // This should panic due to unreachable!\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583651, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=187, prompt_tokens=2026, total_tokens=2213, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmm9VJYRvXcKwqAG5tkw57si06oc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use http::uri::scheme::Scheme;\n\n    #[test]\n    fn test_scheme_empty() {\n        let scheme = Scheme::empty();\n        assert!(scheme.inner.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583657, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=55, prompt_tokens=1931, total_tokens=1986, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
({'dependencies': {"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str": ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find": ['header::map::Danger', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry": ['header::map::Danger', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_append": ['header::map::Danger', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry": ['header::map::Danger', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert": ['header::map::Danger', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq": ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq": ['bytes::Bytes', 'header::value::HeaderValue'], "<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp": ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::option::Option'], "<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq": ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], "<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<&'a std::string::String as header::map::as_header_name::Sealed>::as_str": ['std::string::String'], "<&'a std::string::String as header::map::as_header_name::Sealed>::find": ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::string::String', 'std::vec::Vec'], "<&'a std::string::String as header::map::as_header_name::Sealed>::try_entry": ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::string::String', 'std::vec::Vec'], "<&'a str as header::map::as_header_name::Sealed>::as_str": [], "<&'a str as header::map::as_header_name::Sealed>::find": ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<&'a str as header::map::as_header_name::Sealed>::try_entry": ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": ['header::map::Danger', 'header::map::GetAll', 'header::map::HeaderMap', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::ValueIterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<&'static str as header::map::into_header_name::Sealed>::try_append": ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "<&'static str as header::map::into_header_name::Sealed>::try_entry": ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "<&'static str as header::map::into_header_name::Sealed>::try_insert": ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<T as extensions::AnyClone>::as_any': [], '<T as extensions::AnyClone>::as_any_mut': [], '<T as extensions::AnyClone>::clone_box': ['std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<T as extensions::AnyClone>::into_any': ['std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<byte_str::ByteStr as std::clone::Clone>::clone': ['byte_str::ByteStr', 'bytes::Bytes'], '<byte_str::ByteStr as std::cmp::Eq>::assert_receiver_is_total_eq': ['byte_str::ByteStr', 'bytes::Bytes'], '<byte_str::ByteStr as std::cmp::Ord>::cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::cmp::Ordering'], '<byte_str::ByteStr as std::cmp::PartialEq>::eq': ['byte_str::ByteStr', 'bytes::Bytes'], '<byte_str::ByteStr as std::cmp::PartialOrd>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option'], "<byte_str::ByteStr as std::convert::From<&'a str>>::from": ['byte_str::ByteStr', 'bytes::Bytes'], '<byte_str::ByteStr as std::convert::From<std::string::String>>::from': ['byte_str::ByteStr', 'bytes::Bytes', 'std::string::String'], '<byte_str::ByteStr as std::fmt::Debug>::fmt': ['byte_str::ByteStr', 'bytes::Bytes', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<byte_str::ByteStr as std::hash::Hash>::hash': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::IdHasher', 'std::hash::Hasher', 'std::marker::Sized'], '<byte_str::ByteStr as std::ops::Deref>::deref': ['byte_str::ByteStr', 'bytes::Bytes'], '<error::Error as std::convert::From<header::map::MaxSizeReached>>::from': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<error::Error as std::convert::From<method::InvalidMethod>>::from': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<error::Error as std::convert::From<status::InvalidStatusCode>>::from': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<error::Error as std::convert::From<std::convert::Infallible>>::from': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'std::convert::Infallible', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<error::Error as std::convert::From<uri::InvalidUri>>::from': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<error::Error as std::convert::From<uri::InvalidUriParts>>::from': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<error::Error as std::error::Error>::source': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'std::marker::Sized', 'std::option::Option', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<error::Error as std::fmt::Debug>::fmt': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<error::Error as std::fmt::Display>::fmt': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<extensions::Extensions as std::clone::Clone>::clone': ['extensions::Extensions', 'std::marker::Sized', 'std::option::Option'], '<extensions::Extensions as std::default::Default>::default': ['extensions::Extensions', 'std::marker::Sized', 'std::option::Option'], '<extensions::Extensions as std::fmt::Debug>::fmt': ['extensions::Extensions', 'std::fmt::Formatter', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], '<extensions::IdHasher as std::default::Default>::default': ['extensions::IdHasher'], '<extensions::IdHasher as std::hash::Hasher>::finish': ['extensions::IdHasher'], '<extensions::IdHasher as std::hash::Hasher>::write': ['extensions::IdHasher'], '<extensions::IdHasher as std::hash::Hasher>::write_u64': ['extensions::IdHasher'], '<header::map::Bucket<T> as std::clone::Clone>::clone': ['header::map::Bucket', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized', 'std::option::Option'], '<header::map::Bucket<T> as std::fmt::Debug>::fmt': ['header::map::Bucket', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::fmt::Formatter', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], '<header::map::Cursor as std::clone::Clone>::clone': ['header::map::Cursor'], '<header::map::Cursor as std::cmp::Eq>::assert_receiver_is_total_eq': ['header::map::Cursor'], '<header::map::Cursor as std::cmp::PartialEq>::eq': ['header::map::Cursor'], '<header::map::Cursor as std::fmt::Debug>::fmt': ['header::map::Cursor', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::map::Danger as std::clone::Clone>::clone': ['header::map::Danger', 'std::hash::RandomState'], "<header::map::Drain<'a, T> as std::fmt::Debug>::fmt": ['header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::fmt::Formatter', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::Vec'], "<header::map::Drain<'a, T> as std::iter::Iterator>::next": ['header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint": ['header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::Drain<'a, T> as std::ops::Drop>::drop": ['header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::Entry<'a, T> as std::fmt::Debug>::fmt": ['header::map::Danger', 'header::map::Entry', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<header::map::ExtraValue<T> as std::clone::Clone>::clone': ['header::map::ExtraValue', 'header::map::Link', 'std::marker::Sized'], '<header::map::ExtraValue<T> as std::fmt::Debug>::fmt': ['header::map::ExtraValue', 'header::map::Link', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], "<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq": ['header::map::Danger', 'header::map::GetAll', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::GetAll<'a, T> as std::fmt::Debug>::fmt": ['header::map::Danger', 'header::map::GetAll', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::Vec'], "<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": ['header::map::Danger', 'header::map::GetAll', 'header::map::HeaderMap', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], '<header::map::HashValue as std::clone::Clone>::clone': ['header::map::HashValue'], '<header::map::HashValue as std::cmp::Eq>::assert_receiver_is_total_eq': ['header::map::HashValue'], '<header::map::HashValue as std::cmp::PartialEq>::eq': ['header::map::HashValue'], '<header::map::HashValue as std::fmt::Debug>::fmt': ['header::map::HashValue', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::map::HeaderMap<T> as std::clone::Clone>::clone': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], '<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "<header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V, S>>>::try_from": ['std::collections::HashMap', 'std::marker::Sized', 'std::result::Result'], '<header::map::HeaderMap<T> as std::default::Default>::default': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], '<header::map::HeaderMap<T> as std::fmt::Debug>::fmt': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend': ['header::map::Danger', 'header::map::GetAll', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::iter::IntoIterator', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], '<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend': ['header::map::Danger', 'header::map::GetAll', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::iter::IntoIterator', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], '<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter': ['header::map::Danger', 'header::map::GetAll', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::iter::IntoIterator', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], '<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IntoIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::IntoIter', 'std::vec::Vec'], '<header::map::HeaderMap<T> as std::ops::Index<K>>::index': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], '<header::map::IntoIter<T> as std::fmt::Debug>::fmt': ['header::map::IntoIter', 'std::alloc::Allocator', 'std::fmt::Formatter', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::IntoIter', 'std::vec::Vec'], '<header::map::IntoIter<T> as std::iter::Iterator>::next': ['header::map::IntoIter', 'std::alloc::Allocator', 'std::marker::Sized', 'std::option::Option', 'std::vec::IntoIter', 'std::vec::Vec'], '<header::map::IntoIter<T> as std::iter::Iterator>::size_hint': ['header::map::IntoIter', 'std::alloc::Allocator', 'std::marker::Sized', 'std::option::Option', 'std::vec::IntoIter', 'std::vec::Vec'], '<header::map::IntoIter<T> as std::ops::Drop>::drop': ['header::map::IntoIter', 'std::alloc::Allocator', 'std::marker::Sized', 'std::option::Option', 'std::vec::IntoIter', 'std::vec::Vec'], "<header::map::Iter<'a, T> as std::fmt::Debug>::fmt": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::Vec'], "<header::map::Iter<'a, T> as std::iter::Iterator>::next": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::IterMut<'a, T> as std::fmt::Debug>::fmt": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::Vec'], "<header::map::IterMut<'a, T> as std::iter::Iterator>::next": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::Keys<'a, T> as std::fmt::Debug>::fmt": ['header::map::Keys', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'std::slice::Iter'], "<header::map::Keys<'a, T> as std::iter::Iterator>::count": ['header::map::Keys', 'std::marker::Sized', 'std::slice::Iter'], "<header::map::Keys<'a, T> as std::iter::Iterator>::last": ['header::map::Keys', 'std::marker::Sized', 'std::option::Option', 'std::slice::Iter'], "<header::map::Keys<'a, T> as std::iter::Iterator>::next": ['header::map::Keys', 'std::marker::Sized', 'std::option::Option', 'std::slice::Iter'], "<header::map::Keys<'a, T> as std::iter::Iterator>::nth": ['header::map::Keys', 'std::marker::Sized', 'std::option::Option', 'std::slice::Iter'], "<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint": ['header::map::Keys', 'std::marker::Sized', 'std::option::Option', 'std::slice::Iter'], '<header::map::Link as std::clone::Clone>::clone': ['header::map::Link'], '<header::map::Link as std::cmp::Eq>::assert_receiver_is_total_eq': ['header::map::Link'], '<header::map::Link as std::cmp::PartialEq>::eq': ['header::map::Link'], '<header::map::Link as std::fmt::Debug>::fmt': ['header::map::Link', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::map::Links as std::clone::Clone>::clone': ['header::map::Links'], '<header::map::Links as std::fmt::Debug>::fmt': ['header::map::Links', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::map::MaxSizeReached as std::fmt::Debug>::fmt': ['header::map::MaxSizeReached', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::map::MaxSizeReached as std::fmt::Display>::fmt': ['header::map::MaxSizeReached', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], "<header::map::OccupiedEntry<'a, T> as std::fmt::Debug>::fmt": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::ValueIterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], '<header::map::Pos as std::clone::Clone>::clone': ['header::map::HashValue', 'header::map::Pos'], '<header::map::RawLinks<T> as std::clone::Clone>::clone': ['header::map::Bucket', 'header::map::HashValue', 'header::map::RawLinks', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized', 'std::option::Option'], '<header::map::RawLinks<T> as std::fmt::Debug>::fmt': ['header::map::Bucket', 'header::map::HashValue', 'header::map::RawLinks', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::fmt::Formatter', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], '<header::map::RawLinks<T> as std::ops::Index<usize>>::index': ['header::map::Bucket', 'header::map::HashValue', 'header::map::RawLinks', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized', 'std::option::Option'], '<header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut': ['header::map::Bucket', 'header::map::HashValue', 'header::map::RawLinks', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized', 'std::option::Option'], "<header::map::VacantEntry<'a, T> as std::fmt::Debug>::fmt": ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "<header::map::ValueDrain<'a, T> as std::fmt::Debug>::fmt": ['header::map::ValueDrain', 'std::fmt::Formatter', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next": ['header::map::ValueDrain', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option'], "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint": ['header::map::ValueDrain', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option'], "<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop": ['header::map::ValueDrain', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option'], "<header::map::ValueIter<'a, T> as std::fmt::Debug>::fmt": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::Vec'], "<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::ValueIter<'a, T> as std::iter::Iterator>::next": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::ValueIterMut<'a, T> as std::fmt::Debug>::fmt": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::Vec'], "<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::Values<'a, T> as std::fmt::Debug>::fmt": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'header::map::Values', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::Vec'], "<header::map::Values<'a, T> as std::iter::Iterator>::next": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'header::map::Values', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::Values<'a, T> as std::iter::Iterator>::size_hint": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'header::map::Values', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::ValuesMut<'a, T> as std::fmt::Debug>::fmt": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'header::map::ValuesMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::Vec'], "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'header::map::ValuesMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'header::map::ValuesMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], '<header::map::as_header_name::TryEntryError as std::convert::From<header::map::MaxSizeReached>>::from': ['header::map::MaxSizeReached', 'header::map::as_header_name::TryEntryError', 'header::name::InvalidHeaderName'], '<header::map::as_header_name::TryEntryError as std::convert::From<header::name::InvalidHeaderName>>::from': ['header::map::MaxSizeReached', 'header::map::as_header_name::TryEntryError', 'header::name::InvalidHeaderName'], '<header::name::Custom as std::clone::Clone>::clone': ['byte_str::ByteStr', 'bytes::Bytes', 'header::name::Custom'], '<header::name::Custom as std::cmp::Eq>::assert_receiver_is_total_eq': ['byte_str::ByteStr', 'bytes::Bytes', 'header::name::Custom'], '<header::name::Custom as std::cmp::PartialEq>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'header::name::Custom'], '<header::name::Custom as std::fmt::Debug>::fmt': ['byte_str::ByteStr', 'bytes::Bytes', 'header::name::Custom', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::name::Custom as std::hash::Hash>::hash': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::IdHasher', 'header::name::Custom', 'std::hash::Hasher', 'std::marker::Sized'], "<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from": ['header::name::HdrName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "<header::name::HdrName<'a> as std::fmt::Debug>::fmt": ['header::name::HdrName', 'header::name::Repr', 'header::name::StandardHeader', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], "<header::name::HdrName<'a> as std::hash::Hash>::hash": ['extensions::IdHasher', 'header::name::HdrName', 'header::name::Repr', 'header::name::StandardHeader', 'std::hash::Hasher', 'std::marker::Sized'], '<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::HeaderName as header::map::as_header_name::Sealed>::find': ['header::map::Danger', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], '<header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry': ['header::map::Danger', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<header::name::HeaderName as header::map::into_header_name::Sealed>::try_append': ['header::map::Danger', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry': ['header::map::Danger', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert': ['header::map::Danger', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<header::name::HeaderName as std::borrow::Borrow<str>>::borrow': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::HeaderName as std::clone::Clone>::clone': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::HeaderName as std::cmp::Eq>::assert_receiver_is_total_eq': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq": ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq": ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq": ['header::name::HdrName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::HeaderName as std::cmp::PartialEq<str>>::eq': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::HeaderName as std::cmp::PartialEq>::eq': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::HeaderName as std::convert::AsRef<str>>::as_ref': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from": ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::HeaderName as std::convert::From<header::name::Custom>>::from': ['byte_str::ByteStr', 'bytes::Bytes', 'header::name::Custom', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from": ['header::name::HdrName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "<header::name::HeaderName as std::convert::TryFrom<&'a [u8]>>::try_from": ['std::marker::Sized', 'std::result::Result'], "<header::name::HeaderName as std::convert::TryFrom<&'a std::string::String>>::try_from": ['std::marker::Sized', 'std::result::Result', 'std::string::String'], "<header::name::HeaderName as std::convert::TryFrom<&'a str>>::try_from": ['std::marker::Sized', 'std::result::Result'], '<header::name::HeaderName as std::convert::TryFrom<std::string::String>>::try_from': ['std::marker::Sized', 'std::result::Result', 'std::string::String'], '<header::name::HeaderName as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['std::alloc::Allocator', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<header::name::HeaderName as std::fmt::Debug>::fmt': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::name::HeaderName as std::fmt::Display>::fmt': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::name::HeaderName as std::hash::Hash>::hash': ['extensions::IdHasher', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::hash::Hasher', 'std::marker::Sized'], '<header::name::HeaderName as std::str::FromStr>::from_str': ['std::marker::Sized', 'std::result::Result'], '<header::name::InvalidHeaderName as std::fmt::Debug>::fmt': ['header::name::InvalidHeaderName', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::name::InvalidHeaderName as std::fmt::Display>::fmt': ['header::name::InvalidHeaderName', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], "<header::name::MaybeLower<'a> as std::clone::Clone>::clone": ['header::name::MaybeLower'], "<header::name::MaybeLower<'a> as std::fmt::Debug>::fmt": ['header::name::MaybeLower', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], "<header::name::MaybeLower<'a> as std::hash::Hash>::hash": ['extensions::IdHasher', 'header::name::MaybeLower', 'std::hash::Hasher', 'std::marker::Sized'], '<header::name::Repr<T> as std::clone::Clone>::clone': ['header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::Repr<T> as std::cmp::Eq>::assert_receiver_is_total_eq': ['header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::Repr<T> as std::cmp::PartialEq>::eq': ['header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], '<header::name::Repr<T> as std::fmt::Debug>::fmt': ['header::name::Repr', 'header::name::StandardHeader', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::name::Repr<T> as std::hash::Hash>::hash': ['extensions::IdHasher', 'header::name::Repr', 'header::name::StandardHeader', 'std::hash::Hasher', 'std::marker::Sized'], '<header::name::StandardHeader as std::clone::Clone>::clone': ['header::name::StandardHeader'], '<header::name::StandardHeader as std::cmp::Eq>::assert_receiver_is_total_eq': ['header::name::StandardHeader'], '<header::name::StandardHeader as std::cmp::PartialEq>::eq': ['header::name::StandardHeader'], '<header::name::StandardHeader as std::fmt::Debug>::fmt': ['header::name::StandardHeader', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::name::StandardHeader as std::hash::Hash>::hash': ['extensions::IdHasher', 'header::name::StandardHeader', 'std::hash::Hasher', 'std::marker::Sized'], '<header::value::HeaderValue as std::clone::Clone>::clone': ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::cmp::Ord>::cmp': ['bytes::Bytes', 'header::value::HeaderValue', 'std::cmp::Ordering'], "<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq": ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq': ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq': ['bytes::Bytes', 'header::value::HeaderValue', 'std::string::String'], '<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq': ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::cmp::PartialEq>::eq': ['bytes::Bytes', 'header::value::HeaderValue'], "<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp": ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::option::Option'], '<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp': ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::option::Option'], '<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp': ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::option::Option', 'std::string::String'], '<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp': ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::option::Option'], '<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp': ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::option::Option'], '<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref': ['bytes::Bytes', 'header::value::HeaderValue'], "<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from": ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from': ['bytes::Bytes', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'header::value::HeaderValue', 'std::marker::Sized'], '<header::value::HeaderValue as std::convert::From<i16>>::from': ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::convert::From<i32>>::from': ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::convert::From<i64>>::from': ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::convert::From<isize>>::from': ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::convert::From<u16>>::from': ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::convert::From<u32>>::from': ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::convert::From<u64>>::from': ['bytes::Bytes', 'header::value::HeaderValue'], '<header::value::HeaderValue as std::convert::From<usize>>::from': ['bytes::Bytes', 'header::value::HeaderValue'], "<header::value::HeaderValue as std::convert::TryFrom<&'a [u8]>>::try_from": ['std::marker::Sized', 'std::result::Result'], "<header::value::HeaderValue as std::convert::TryFrom<&'a std::string::String>>::try_from": ['std::marker::Sized', 'std::result::Result', 'std::string::String'], "<header::value::HeaderValue as std::convert::TryFrom<&'a str>>::try_from": ['std::marker::Sized', 'std::result::Result'], '<header::value::HeaderValue as std::convert::TryFrom<std::string::String>>::try_from': ['std::marker::Sized', 'std::result::Result', 'std::string::String'], '<header::value::HeaderValue as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['std::alloc::Allocator', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<header::value::HeaderValue as std::fmt::Debug>::fmt': ['bytes::Bytes', 'header::value::HeaderValue', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::value::HeaderValue as std::hash::Hash>::hash': ['bytes::Bytes', 'extensions::IdHasher', 'header::value::HeaderValue', 'std::hash::Hasher', 'std::marker::Sized'], '<header::value::HeaderValue as std::str::FromStr>::from_str': ['std::marker::Sized', 'std::result::Result'], '<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt': ['header::value::InvalidHeaderValue', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::value::InvalidHeaderValue as std::fmt::Display>::fmt': ['header::value::InvalidHeaderValue', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::value::ToStrError as std::fmt::Debug>::fmt': ['header::value::ToStrError', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<header::value::ToStrError as std::fmt::Display>::fmt': ['header::value::ToStrError', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<method::Inner as std::clone::Clone>::clone': ['method::Inner', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::Inner as std::cmp::Eq>::assert_receiver_is_total_eq': ['method::Inner', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::Inner as std::cmp::PartialEq>::eq': ['method::Inner', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::Inner as std::hash::Hash>::hash': ['extensions::IdHasher', 'method::Inner', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::Hasher', 'std::marker::Sized'], '<method::InvalidMethod as std::fmt::Debug>::fmt': ['method::InvalidMethod', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<method::InvalidMethod as std::fmt::Display>::fmt': ['method::InvalidMethod', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<method::Method as std::clone::Clone>::clone': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::Method as std::cmp::Eq>::assert_receiver_is_total_eq': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], "<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq": ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], "<method::Method as std::cmp::PartialEq<&'a str>>::eq": ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::Method as std::cmp::PartialEq<str>>::eq': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::Method as std::cmp::PartialEq>::eq': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::Method as std::convert::AsRef<str>>::as_ref': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], "<method::Method as std::convert::From<&'a method::Method>>::from": ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], "<method::Method as std::convert::TryFrom<&'a [u8]>>::try_from": ['std::marker::Sized', 'std::result::Result'], "<method::Method as std::convert::TryFrom<&'a str>>::try_from": ['std::marker::Sized', 'std::result::Result'], '<method::Method as std::default::Default>::default': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::Method as std::fmt::Debug>::fmt': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<method::Method as std::fmt::Display>::fmt': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<method::Method as std::hash::Hash>::hash': ['extensions::IdHasher', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::Hasher', 'std::marker::Sized'], '<method::Method as std::str::FromStr>::from_str': ['std::marker::Sized', 'std::result::Result'], '<method::extension::AllocatedExtension as std::clone::Clone>::clone': ['method::extension::AllocatedExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::extension::AllocatedExtension as std::cmp::Eq>::assert_receiver_is_total_eq': ['method::extension::AllocatedExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::extension::AllocatedExtension as std::cmp::PartialEq>::eq': ['method::extension::AllocatedExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], '<method::extension::AllocatedExtension as std::hash::Hash>::hash': ['extensions::IdHasher', 'method::extension::AllocatedExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::Hasher', 'std::marker::Sized'], '<method::extension::InlineExtension as std::clone::Clone>::clone': ['method::extension::InlineExtension'], '<method::extension::InlineExtension as std::cmp::Eq>::assert_receiver_is_total_eq': ['method::extension::InlineExtension'], '<method::extension::InlineExtension as std::cmp::PartialEq>::eq': ['method::extension::InlineExtension'], '<method::extension::InlineExtension as std::hash::Hash>::hash': ['extensions::IdHasher', 'method::extension::InlineExtension', 'std::hash::Hasher', 'std::marker::Sized'], '<request::Builder as std::default::Default>::default': ['request::Builder', 'std::marker::Sized', 'std::result::Result'], '<request::Builder as std::fmt::Debug>::fmt': ['request::Builder', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<request::Parts as std::clone::Clone>::clone': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], '<request::Parts as std::fmt::Debug>::fmt': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], '<request::Request<T> as std::clone::Clone>::clone': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], '<request::Request<T> as std::default::Default>::default': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], '<request::Request<T> as std::fmt::Debug>::fmt': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], '<response::Builder as std::default::Default>::default': ['response::Builder', 'std::marker::Sized', 'std::result::Result'], '<response::Builder as std::fmt::Debug>::fmt': ['response::Builder', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<response::Parts as std::clone::Clone>::clone': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], '<response::Parts as std::fmt::Debug>::fmt': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::result::Result', 'std::vec::Vec', 'version::Http', 'version::Version'], '<response::Response<T> as std::clone::Clone>::clone': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], '<response::Response<T> as std::default::Default>::default': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], '<response::Response<T> as std::fmt::Debug>::fmt': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::fmt::Formatter', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::result::Result', 'std::vec::Vec', 'version::Http', 'version::Version'], '<status::InvalidStatusCode as std::fmt::Debug>::fmt': ['status::InvalidStatusCode', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<status::InvalidStatusCode as std::fmt::Display>::fmt': ['status::InvalidStatusCode', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], '<status::StatusCode as std::clone::Clone>::clone': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], '<status::StatusCode as std::cmp::Eq>::assert_receiver_is_total_eq': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], '<status::StatusCode as std::cmp::Ord>::cmp': ['status::StatusCode', 'std::cmp::Ordering', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], '<status::StatusCode as std::cmp::PartialEq<u16>>::eq': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], '<status::StatusCode as std::cmp::PartialEq>::eq': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], '<status::StatusCode as std::cmp::PartialOrd>::partial_cmp': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option'], "<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from": ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], "<status::StatusCode as std::convert::TryFrom<&'a [u8]>>::try_from": ['std::marker::Sized', 'std::result::Result'], "<status::StatusCode as std::convert::TryFrom<&'a str>>::try_from": ['std::marker::Sized', 'std::result::Result'], '<status::StatusCode as std::convert::TryFrom<u16>>::try_from': ['std::marker::Sized', 'std::result::Result'], '<status::StatusCode as std::default::Default>::default': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], '<status::StatusCode as std::fmt::Debug>::fmt': ['status::StatusCode', 'std::fmt::Formatter', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::result::Result'], '<status::StatusCode as std::fmt::Display>::fmt': ['status::StatusCode', 'std::fmt::Formatter', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::result::Result'], '<status::StatusCode as std::hash::Hash>::hash': ['extensions::IdHasher', 'status::StatusCode', 'std::hash::Hasher', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], '<status::StatusCode as std::str::FromStr>::from_str': ['std::marker::Sized', 'std::result::Result'], '<std::string::String as header::map::as_header_name::Sealed>::as_str': ['std::string::String'], '<std::string::String as header::map::as_header_name::Sealed>::find': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::string::String', 'std::vec::Vec'], '<std::string::String as header::map::as_header_name::Sealed>::try_entry': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::string::String', 'std::vec::Vec'], '<uri::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq': ['uri::ErrorKind'], '<uri::ErrorKind as std::cmp::PartialEq>::eq': ['uri::ErrorKind'], '<uri::ErrorKind as std::fmt::Debug>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::ErrorKind'], '<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from': ['uri::ErrorKind', 'uri::InvalidUri'], '<uri::InvalidUri as std::fmt::Debug>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::ErrorKind', 'uri::InvalidUri'], '<uri::InvalidUri as std::fmt::Display>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::ErrorKind', 'uri::InvalidUri'], '<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from': ['uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<uri::InvalidUriParts as std::fmt::Debug>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<uri::InvalidUriParts as std::fmt::Display>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], '<uri::Parts as std::convert::From<uri::Uri>>::from': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::Parts', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::Parts as std::default::Default>::default': ['std::marker::Sized', 'std::option::Option', 'uri::Parts'], '<uri::Parts as std::fmt::Debug>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::option::Option', 'std::result::Result', 'uri::Parts'], '<uri::Uri as std::clone::Clone>::clone': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], "<uri::Uri as std::cmp::PartialEq<&'a str>>::eq": ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::Uri as std::cmp::PartialEq<str>>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::Uri as std::cmp::PartialEq>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::Uri as std::convert::From<uri::authority::Authority>>::from': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::Uri as std::convert::From<uri::path::PathAndQuery>>::from': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], "<uri::Uri as std::convert::TryFrom<&'a [u8]>>::try_from": ['std::marker::Sized', 'std::result::Result'], "<uri::Uri as std::convert::TryFrom<&'a std::string::String>>::try_from": ['std::marker::Sized', 'std::result::Result', 'std::string::String'], "<uri::Uri as std::convert::TryFrom<&'a str>>::try_from": ['std::marker::Sized', 'std::result::Result'], "<uri::Uri as std::convert::TryFrom<&'a uri::Uri>>::try_from": ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::result::Result', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::Uri as std::convert::TryFrom<std::string::String>>::try_from': ['std::marker::Sized', 'std::result::Result', 'std::string::String'], '<uri::Uri as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['std::alloc::Allocator', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<uri::Uri as std::convert::TryFrom<uri::Parts>>::try_from': ['std::marker::Sized', 'std::option::Option', 'std::result::Result', 'uri::Parts'], '<uri::Uri as std::default::Default>::default': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::Uri as std::fmt::Debug>::fmt': ['byte_str::ByteStr', 'bytes::Bytes', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::Uri as std::fmt::Display>::fmt': ['byte_str::ByteStr', 'bytes::Bytes', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::Uri as std::hash::Hash>::hash': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::IdHasher', 'std::hash::Hasher', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::Uri as std::str::FromStr>::from_str': ['std::marker::Sized', 'std::result::Result'], '<uri::authority::Authority as std::clone::Clone>::clone': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], "<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq": ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], '<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'std::string::String', 'uri::authority::Authority'], '<uri::authority::Authority as std::cmp::PartialEq<str>>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], '<uri::authority::Authority as std::cmp::PartialEq>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], "<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp": ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::authority::Authority'], '<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'std::string::String', 'uri::authority::Authority'], '<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::authority::Authority'], '<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::authority::Authority'], '<uri::authority::Authority as std::convert::AsRef<str>>::as_ref': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], "<uri::authority::Authority as std::convert::TryFrom<&'a [u8]>>::try_from": ['std::marker::Sized', 'std::result::Result'], "<uri::authority::Authority as std::convert::TryFrom<&'a str>>::try_from": ['std::marker::Sized', 'std::result::Result'], '<uri::authority::Authority as std::convert::TryFrom<std::string::String>>::try_from': ['std::marker::Sized', 'std::result::Result', 'std::string::String'], '<uri::authority::Authority as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['std::alloc::Allocator', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<uri::authority::Authority as std::fmt::Debug>::fmt': ['byte_str::ByteStr', 'bytes::Bytes', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::authority::Authority'], '<uri::authority::Authority as std::fmt::Display>::fmt': ['byte_str::ByteStr', 'bytes::Bytes', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::authority::Authority'], '<uri::authority::Authority as std::hash::Hash>::hash': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::IdHasher', 'std::hash::Hasher', 'std::marker::Sized', 'uri::authority::Authority'], '<uri::authority::Authority as std::str::FromStr>::from_str': ['std::marker::Sized', 'std::result::Result'], '<uri::builder::Builder as std::convert::From<uri::Uri>>::from': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::result::Result', 'uri::Uri', 'uri::authority::Authority', 'uri::builder::Builder', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::builder::Builder as std::default::Default>::default': ['std::marker::Sized', 'std::result::Result', 'uri::builder::Builder'], '<uri::builder::Builder as std::fmt::Debug>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::builder::Builder'], '<uri::path::PathAndQuery as std::clone::Clone>::clone': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], "<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq": ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], '<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'std::string::String', 'uri::path::PathAndQuery'], '<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], '<uri::path::PathAndQuery as std::cmp::PartialEq>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], "<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp": ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::path::PathAndQuery'], '<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'std::string::String', 'uri::path::PathAndQuery'], '<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::path::PathAndQuery'], '<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::path::PathAndQuery'], "<uri::path::PathAndQuery as std::convert::TryFrom<&'a [u8]>>::try_from": ['std::marker::Sized', 'std::result::Result'], "<uri::path::PathAndQuery as std::convert::TryFrom<&'a str>>::try_from": ['std::marker::Sized', 'std::result::Result'], '<uri::path::PathAndQuery as std::convert::TryFrom<&std::string::String>>::try_from': ['std::marker::Sized', 'std::result::Result', 'std::string::String'], '<uri::path::PathAndQuery as std::convert::TryFrom<std::string::String>>::try_from': ['std::marker::Sized', 'std::result::Result', 'std::string::String'], '<uri::path::PathAndQuery as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['std::alloc::Allocator', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], '<uri::path::PathAndQuery as std::fmt::Debug>::fmt': ['byte_str::ByteStr', 'bytes::Bytes', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::path::PathAndQuery'], '<uri::path::PathAndQuery as std::fmt::Display>::fmt': ['byte_str::ByteStr', 'bytes::Bytes', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::path::PathAndQuery'], '<uri::path::PathAndQuery as std::hash::Hash>::hash': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::IdHasher', 'std::hash::Hasher', 'std::marker::Sized', 'uri::path::PathAndQuery'], '<uri::path::PathAndQuery as std::str::FromStr>::from_str': ['std::marker::Sized', 'std::result::Result'], '<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq': ['std::marker::Sized', 'uri::port::Port'], '<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq': ['std::marker::Sized', 'uri::port::Port'], '<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref': ['std::marker::Sized', 'uri::port::Port'], '<uri::port::Port<T> as std::fmt::Debug>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::port::Port'], '<uri::port::Port<T> as std::fmt::Display>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::port::Port'], '<uri::scheme::Protocol as std::clone::Clone>::clone': ['uri::scheme::Protocol'], '<uri::scheme::Protocol as std::fmt::Debug>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::scheme::Protocol'], '<uri::scheme::Scheme as std::clone::Clone>::clone': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::scheme::Scheme as std::cmp::PartialEq>::eq': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], "<uri::scheme::Scheme as std::convert::TryFrom<&'a [u8]>>::try_from": ['std::marker::Sized', 'std::result::Result'], "<uri::scheme::Scheme as std::convert::TryFrom<&'a str>>::try_from": ['std::marker::Sized', 'std::result::Result'], '<uri::scheme::Scheme as std::fmt::Debug>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::scheme::Scheme as std::fmt::Display>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::scheme::Scheme as std::hash::Hash>::hash': ['extensions::IdHasher', 'std::hash::Hasher', 'std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], '<uri::scheme::Scheme as std::str::FromStr>::from_str': ['std::marker::Sized', 'std::result::Result'], '<uri::scheme::Scheme2<T> as std::clone::Clone>::clone': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme2'], '<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme2'], '<uri::scheme::Scheme2<T> as std::fmt::Debug>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'uri::scheme::Protocol', 'uri::scheme::Scheme2'], '<version::Http as std::clone::Clone>::clone': ['version::Http'], '<version::Http as std::cmp::Eq>::assert_receiver_is_total_eq': ['version::Http'], '<version::Http as std::cmp::Ord>::cmp': ['std::cmp::Ordering', 'version::Http'], '<version::Http as std::cmp::PartialEq>::eq': ['version::Http'], '<version::Http as std::cmp::PartialOrd>::partial_cmp': ['std::marker::Sized', 'std::option::Option', 'version::Http'], '<version::Http as std::hash::Hash>::hash': ['extensions::IdHasher', 'std::hash::Hasher', 'std::marker::Sized', 'version::Http'], '<version::Version as std::clone::Clone>::clone': ['version::Http', 'version::Version'], '<version::Version as std::cmp::Eq>::assert_receiver_is_total_eq': ['version::Http', 'version::Version'], '<version::Version as std::cmp::Ord>::cmp': ['std::cmp::Ordering', 'version::Http', 'version::Version'], '<version::Version as std::cmp::PartialEq>::eq': ['version::Http', 'version::Version'], '<version::Version as std::cmp::PartialOrd>::partial_cmp': ['std::marker::Sized', 'std::option::Option', 'version::Http', 'version::Version'], '<version::Version as std::default::Default>::default': ['version::Http', 'version::Version'], '<version::Version as std::fmt::Debug>::fmt': ['std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'version::Http', 'version::Version'], '<version::Version as std::hash::Hash>::hash': ['extensions::IdHasher', 'std::hash::Hasher', 'std::marker::Sized', 'version::Http', 'version::Version'], 'byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from': ['byte_str::ByteStr', 'bytes::Bytes'], 'byte_str::ByteStr': ['byte_str::ByteStr', 'bytes::Bytes'], 'byte_str::ByteStr::from_static': ['byte_str::ByteStr', 'bytes::Bytes'], 'byte_str::ByteStr::from_utf8': ['bytes::Bytes', 'std::marker::Sized', 'std::result::Result'], 'byte_str::ByteStr::from_utf8_unchecked': ['byte_str::ByteStr', 'bytes::Bytes'], 'byte_str::ByteStr::new': ['byte_str::ByteStr', 'bytes::Bytes'], 'error::Error': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], 'error::Error::get_ref': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], 'error::Error::is': ['error::Error', 'error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'std::error::Error', 'std::marker::Sized', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], 'error::ErrorKind': ['error::ErrorKind', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], "extensions::<impl std::clone::Clone for std::boxed::Box<(dyn extensions::AnyClone + std::marker::Send + std::marker::Sync + 'static)>>::clone": ['std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'extensions::AnyClone::as_any': [], 'extensions::AnyClone::as_any_mut': [], 'extensions::AnyClone::clone_box': ['std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'extensions::AnyClone::into_any': ['std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'extensions::Extensions': ['extensions::Extensions', 'std::marker::Sized', 'std::option::Option'], 'extensions::Extensions::clear': ['extensions::Extensions', 'std::marker::Sized', 'std::option::Option'], 'extensions::Extensions::extend': ['extensions::Extensions', 'std::marker::Sized', 'std::option::Option'], 'extensions::Extensions::get': ['extensions::Extensions', 'header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::marker::PhantomData', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::vec::Vec'], 'extensions::Extensions::get_mut': ['extensions::Extensions', 'header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::marker::PhantomData', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::vec::Vec'], 'extensions::Extensions::get_or_insert': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::clone::Clone', 'std::marker::PhantomData', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::vec::Vec'], 'extensions::Extensions::get_or_insert_default': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::clone::Clone', 'std::default::Default', 'std::marker::PhantomData', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::vec::Vec'], 'extensions::Extensions::get_or_insert_with': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::clone::Clone', 'std::marker::PhantomData', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::ops::FnOnce', 'std::option::Option', 'std::vec::Vec'], 'extensions::Extensions::insert': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::clone::Clone', 'std::marker::PhantomData', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::vec::Vec'], 'extensions::Extensions::is_empty': ['extensions::Extensions', 'std::marker::Sized', 'std::option::Option'], 'extensions::Extensions::len': ['extensions::Extensions', 'std::marker::Sized', 'std::option::Option'], 'extensions::Extensions::new': ['extensions::Extensions', 'std::marker::Sized', 'std::option::Option'], 'extensions::Extensions::remove': ['extensions::Extensions', 'header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::marker::PhantomData', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::vec::Vec'], 'extensions::IdHasher': ['extensions::IdHasher'], 'header::map::Bucket': ['header::map::Bucket', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized', 'std::option::Option'], 'header::map::Cursor': ['header::map::Cursor'], 'header::map::Danger': ['header::map::Danger', 'std::hash::RandomState'], 'header::map::Danger::is_red': ['header::map::Danger', 'std::hash::RandomState'], 'header::map::Danger::is_yellow': ['header::map::Danger', 'std::hash::RandomState'], 'header::map::Danger::set_green': ['header::map::Danger', 'std::hash::RandomState'], 'header::map::Danger::set_red': ['header::map::Danger', 'std::hash::RandomState'], 'header::map::Danger::set_yellow': ['header::map::Danger', 'std::hash::RandomState'], 'header::map::Drain': ['header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::Entry': ['header::map::Danger', 'header::map::Entry', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::Entry::<'a, T>::key": ['header::map::Danger', 'header::map::Entry', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::Entry::<'a, T>::or_insert": ['header::map::Danger', 'header::map::Entry', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::Entry::<'a, T>::or_insert_with": ['header::map::Danger', 'header::map::Entry', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::ops::FnOnce', 'std::vec::Vec'], "header::map::Entry::<'a, T>::or_try_insert": ['header::map::Danger', 'header::map::Entry', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "header::map::Entry::<'a, T>::or_try_insert_with": ['header::map::Danger', 'header::map::Entry', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::ops::FnOnce', 'std::result::Result', 'std::vec::Vec'], 'header::map::ExtraValue': ['header::map::ExtraValue', 'header::map::Link', 'std::marker::Sized'], 'header::map::GetAll': ['header::map::Danger', 'header::map::GetAll', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "header::map::GetAll::<'a, T>::iter": ['header::map::Danger', 'header::map::GetAll', 'header::map::HeaderMap', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HashValue': ['header::map::HashValue'], 'header::map::HeaderMap': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::append': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::into_header_name::IntoHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::capacity': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::clear': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::contains_key': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::as_header_name::AsHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::drain': ['header::map::Bucket', 'header::map::Danger', 'header::map::Drain', 'header::map::HashValue', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::entry': ['header::map::Danger', 'header::map::Entry', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::VacantEntry', 'header::map::into_header_name::IntoHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::find': ['byte_str::ByteStr', 'bytes::Bytes', 'header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::cmp::PartialEq', 'std::convert::Into', 'std::hash::Hash', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::get': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::as_header_name::AsHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::get2': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::as_header_name::AsHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::get_all': ['header::map::Danger', 'header::map::GetAll', 'header::map::HeaderMap', 'header::map::as_header_name::AsHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::get_mut': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::as_header_name::AsHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::insert': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::into_header_name::IntoHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::insert_occupied': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::insert_occupied_mult': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueDrain', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::is_empty': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::iter': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::iter_mut': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::keys': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Keys', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::slice::Iter', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::keys_len': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::len': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::raw_links': ['header::map::Bucket', 'header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::RawLinks', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::rebuild': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::reinsert_entry_in_order': ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::Pos', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::remove': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::as_header_name::AsHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::remove_all_extra_values': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::remove_extra_value': ['header::map::Danger', 'header::map::ExtraValue', 'header::map::HeaderMap', 'header::map::Link', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::remove_found': ['header::map::Bucket', 'header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::reserve': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_append': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::into_header_name::IntoHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_append2': ['byte_str::ByteStr', 'bytes::Bytes', 'header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::cmp::PartialEq', 'std::convert::Into', 'std::hash::Hash', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_entry': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::as_header_name::AsHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_entry2': ['byte_str::ByteStr', 'bytes::Bytes', 'header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::cmp::PartialEq', 'std::convert::Into', 'std::hash::Hash', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_grow': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_insert': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::into_header_name::IntoHeaderName', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_insert2': ['byte_str::ByteStr', 'bytes::Bytes', 'header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::cmp::PartialEq', 'std::convert::Into', 'std::hash::Hash', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_insert_entry': ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_insert_phase_two': ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_reserve': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_reserve_one': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::try_with_capacity': ['std::marker::Sized', 'std::result::Result'], 'header::map::HeaderMap::<T>::value_iter': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::value_iter_mut': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::values': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'header::map::Values', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::values_mut': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'header::map::ValuesMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::HeaderMap::<T>::with_capacity': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::HeaderMap::new': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], 'header::map::IntoIter': ['header::map::IntoIter', 'std::alloc::Allocator', 'std::marker::Sized', 'std::option::Option', 'std::vec::IntoIter', 'std::vec::Vec'], 'header::map::Iter': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::IterMut': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "header::map::IterMut::<'a, T>::next_unsafe": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::Keys': ['header::map::Keys', 'std::marker::Sized', 'std::slice::Iter'], 'header::map::Link': ['header::map::Link'], 'header::map::Links': ['header::map::Links'], 'header::map::MaxSizeReached': ['header::map::MaxSizeReached'], 'header::map::MaxSizeReached::new': ['header::map::MaxSizeReached'], 'header::map::OccupiedEntry': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::append": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::get": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::get_mut": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::insert": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::insert_mult": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::ValueDrain', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::into_mut": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::iter": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::iter_mut": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::ValueIterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::key": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::remove": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::remove_entry": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::OccupiedEntry::<'a, T>::remove_entry_mult": ['header::map::Danger', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::ValueDrain', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::Pos': ['header::map::HashValue', 'header::map::Pos'], 'header::map::Pos::is_none': ['header::map::HashValue', 'header::map::Pos'], 'header::map::Pos::is_some': ['header::map::HashValue', 'header::map::Pos'], 'header::map::Pos::new': ['header::map::HashValue', 'header::map::Pos'], 'header::map::Pos::none': ['header::map::HashValue', 'header::map::Pos'], 'header::map::Pos::resolve': ['header::map::HashValue', 'header::map::Pos', 'std::marker::Sized', 'std::option::Option'], 'header::map::RawLinks': ['header::map::Bucket', 'header::map::HashValue', 'header::map::RawLinks', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized', 'std::option::Option'], 'header::map::VacantEntry': ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::VacantEntry::<'a, T>::insert": ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::VacantEntry::<'a, T>::insert_entry": ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::OccupiedEntry', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::VacantEntry::<'a, T>::into_key": ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::VacantEntry::<'a, T>::key": ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::vec::Vec'], "header::map::VacantEntry::<'a, T>::try_insert": ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], "header::map::VacantEntry::<'a, T>::try_insert_entry": ['header::map::Danger', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::VacantEntry', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::ValueDrain': ['header::map::ValueDrain', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option'], 'header::map::ValueIter': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIter', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::ValueIterMut': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::ValueIterMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::Values': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::Iter', 'header::map::Values', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::ValuesMut': ['header::map::Danger', 'header::map::HeaderMap', 'header::map::IterMut', 'header::map::ValuesMut', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::PhantomData', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::append_value': ['header::map::Bucket', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::as_header_name::Sealed::as_str': [], 'header::map::as_header_name::Sealed::find': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::as_header_name::Sealed::try_entry': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::as_header_name::TryEntryError': ['header::map::MaxSizeReached', 'header::map::as_header_name::TryEntryError', 'header::name::InvalidHeaderName'], 'header::map::desired_pos': ['header::map::HashValue'], 'header::map::do_insert_phase_two': ['header::map::HashValue', 'header::map::Pos'], 'header::map::drain_all_extra_values': ['header::map::Bucket', 'header::map::HashValue', 'header::map::RawLinks', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::hash_elem_using': ['byte_str::ByteStr', 'bytes::Bytes', 'header::map::Danger', 'header::map::HashValue', 'std::hash::Hash', 'std::hash::RandomState'], 'header::map::into_header_name::Sealed::try_append': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::into_header_name::Sealed::try_entry': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::into_header_name::Sealed::try_insert': ['header::map::Danger', 'header::map::HeaderMap', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::result::Result', 'std::vec::Vec'], 'header::map::probe_distance': ['header::map::HashValue'], 'header::map::remove_extra_value': ['header::map::Bucket', 'header::map::ExtraValue', 'header::map::HashValue', 'header::map::Link', 'header::map::RawLinks', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::alloc::Allocator', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec'], 'header::map::to_raw_capacity': [], 'header::map::usable_capacity': [], "header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq": ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], 'header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], 'header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from': ['byte_str::ByteStr', 'bytes::Bytes', 'header::name::Custom'], 'header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from': ['bytes::Bytes', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], 'header::name::Custom': ['byte_str::ByteStr', 'bytes::Bytes', 'header::name::Custom'], 'header::name::HdrName': ['header::name::HdrName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "header::name::HdrName::<'a>::custom": ['header::name::HdrName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], "header::name::HdrName::<'a>::from_bytes": ['std::marker::Sized', 'std::ops::FnOnce', 'std::result::Result'], "header::name::HdrName::<'a>::from_static": ['std::marker::Sized', 'std::ops::FnOnce'], 'header::name::HeaderName': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], 'header::name::HeaderName::as_str': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], 'header::name::HeaderName::from_bytes': ['std::marker::Sized', 'std::result::Result'], 'header::name::HeaderName::from_lowercase': ['std::marker::Sized', 'std::result::Result'], 'header::name::HeaderName::from_static': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], 'header::name::HeaderName::into_bytes': ['bytes::Bytes', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], 'header::name::InvalidHeaderName': ['header::name::InvalidHeaderName'], 'header::name::InvalidHeaderName::new': ['header::name::InvalidHeaderName'], 'header::name::MaybeLower': ['header::name::MaybeLower'], 'header::name::Repr': ['header::name::Repr', 'header::name::StandardHeader', 'std::marker::Sized'], 'header::name::StandardHeader': ['header::name::StandardHeader'], 'header::name::StandardHeader::as_str': ['header::name::StandardHeader'], 'header::name::StandardHeader::from_bytes': ['std::marker::Sized', 'std::option::Option'], 'header::name::eq_ignore_ascii_case': [], 'header::name::parse_hdr': ['std::marker::Sized', 'std::mem::MaybeUninit', 'std::result::Result'], 'header::name::slice_assume_init': ['std::marker::Sized', 'std::mem::MaybeUninit'], 'header::name::uninit_u8_array': ['std::marker::Sized', 'std::mem::MaybeUninit'], "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq": ['bytes::Bytes', 'header::value::HeaderValue'], 'header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq': ['bytes::Bytes', 'header::value::HeaderValue'], 'header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq': ['bytes::Bytes', 'header::value::HeaderValue', 'std::string::String'], 'header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq': ['bytes::Bytes', 'header::value::HeaderValue'], "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp": ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::option::Option'], 'header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp': ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::option::Option'], 'header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp': ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::option::Option', 'std::string::String'], 'header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp': ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::option::Option'], 'header::value::HeaderValue': ['bytes::Bytes', 'header::value::HeaderValue'], 'header::value::HeaderValue::as_bytes': ['bytes::Bytes', 'header::value::HeaderValue'], 'header::value::HeaderValue::from_bytes': ['std::marker::Sized', 'std::result::Result'], 'header::value::HeaderValue::from_maybe_shared': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'header::value::HeaderValue::from_maybe_shared_unchecked': ['bytes::Bytes', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'header::value::HeaderValue', 'std::convert::AsRef', 'std::marker::Sized'], 'header::value::HeaderValue::from_name': ['bytes::Bytes', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'header::value::HeaderValue', 'std::marker::Sized'], 'header::value::HeaderValue::from_shared': ['bytes::Bytes', 'std::marker::Sized', 'std::result::Result'], 'header::value::HeaderValue::from_static': ['bytes::Bytes', 'header::value::HeaderValue'], 'header::value::HeaderValue::from_str': ['std::marker::Sized', 'std::result::Result'], 'header::value::HeaderValue::is_empty': ['bytes::Bytes', 'header::value::HeaderValue'], 'header::value::HeaderValue::is_sensitive': ['bytes::Bytes', 'header::value::HeaderValue'], 'header::value::HeaderValue::len': ['bytes::Bytes', 'header::value::HeaderValue'], 'header::value::HeaderValue::set_sensitive': ['bytes::Bytes', 'header::value::HeaderValue'], 'header::value::HeaderValue::to_str': ['bytes::Bytes', 'header::value::HeaderValue', 'std::marker::Sized', 'std::result::Result'], 'header::value::HeaderValue::try_from_generic': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::convert::AsRef', 'std::marker::Sized', 'std::ops::FnOnce', 'std::result::Result'], 'header::value::InvalidHeaderValue': ['header::value::InvalidHeaderValue'], 'header::value::ToStrError': ['header::value::ToStrError'], 'header::value::is_valid': [], 'header::value::is_visible_ascii': [], "method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq": ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'method::<impl std::cmp::PartialEq<method::Method> for str>::eq': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'method::Inner': ['method::Inner', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'method::InvalidMethod': ['method::InvalidMethod'], 'method::InvalidMethod::new': ['method::InvalidMethod'], 'method::Method': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'method::Method::as_str': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'method::Method::extension_inline': ['std::marker::Sized', 'std::result::Result'], 'method::Method::from_bytes': ['std::marker::Sized', 'std::result::Result'], 'method::Method::is_idempotent': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'method::Method::is_safe': ['method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'method::extension::AllocatedExtension': ['method::extension::AllocatedExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'method::extension::AllocatedExtension::as_str': ['method::extension::AllocatedExtension', 'std::alloc::Allocator', 'std::boxed::Box', 'std::marker::Sized'], 'method::extension::AllocatedExtension::new': ['std::marker::Sized', 'std::result::Result'], 'method::extension::InlineExtension': ['method::extension::InlineExtension'], 'method::extension::InlineExtension::as_str': ['method::extension::InlineExtension'], 'method::extension::InlineExtension::new': ['std::marker::Sized', 'std::result::Result'], 'method::extension::write_checked': ['std::marker::Sized', 'std::result::Result'], 'request::Builder': ['request::Builder', 'std::marker::Sized', 'std::result::Result'], 'request::Builder::and_then': ['request::Builder', 'std::marker::Sized', 'std::ops::FnOnce', 'std::result::Result'], 'request::Builder::body': ['request::Builder', 'std::marker::Sized', 'std::result::Result'], 'request::Builder::extension': ['byte_str::ByteStr', 'bytes::Bytes', 'header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'request::Builder', 'std::alloc::Allocator', 'std::any::Any', 'std::clone::Clone', 'std::marker::PhantomData', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'std::vec::Vec'], 'request::Builder::extensions_mut': ['request::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'request::Builder::extensions_ref': ['request::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'request::Builder::header': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Builder::headers_mut': ['request::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'request::Builder::headers_ref': ['request::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'request::Builder::method': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Builder::method_ref': ['request::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'request::Builder::new': ['request::Builder', 'std::marker::Sized', 'std::result::Result'], 'request::Builder::uri': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Builder::uri_ref': ['request::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'request::Builder::version': ['request::Builder', 'std::marker::Sized', 'std::result::Result', 'version::Http', 'version::Version'], 'request::Builder::version_ref': ['request::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'request::Parts': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Parts::new': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<()>::builder': ['request::Builder', 'std::marker::Sized', 'std::result::Result'], 'request::Request::<()>::connect': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Request::<()>::delete': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Request::<()>::get': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Request::<()>::head': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Request::<()>::options': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Request::<()>::patch': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Request::<()>::post': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Request::<()>::put': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Request::<()>::trace': ['request::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'request::Request::<T>::body': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::body_mut': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::extensions': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::extensions_mut': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::from_parts': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::headers': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::headers_mut': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::into_body': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::into_parts': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::map': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::ops::FnOnce', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::method': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::method_mut': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::new': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::uri': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::uri_mut': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::version': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'request::Request::<T>::version_mut': ['byte_str::ByteStr', 'bytes::Bytes', 'extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::option::Option', 'std::vec::Vec', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'response::Builder': ['response::Builder', 'std::marker::Sized', 'std::result::Result'], 'response::Builder::and_then': ['response::Builder', 'std::marker::Sized', 'std::ops::FnOnce', 'std::result::Result'], 'response::Builder::body': ['response::Builder', 'std::marker::Sized', 'std::result::Result'], 'response::Builder::extension': ['byte_str::ByteStr', 'bytes::Bytes', 'header::map::Bucket', 'header::map::Drain', 'header::map::HashValue', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'response::Builder', 'std::alloc::Allocator', 'std::any::Any', 'std::clone::Clone', 'std::marker::PhantomData', 'std::marker::Send', 'std::marker::Sized', 'std::marker::Sync', 'std::option::Option', 'std::result::Result', 'std::vec::Vec'], 'response::Builder::extensions_mut': ['response::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'response::Builder::extensions_ref': ['response::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'response::Builder::header': ['response::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'response::Builder::headers_mut': ['response::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'response::Builder::headers_ref': ['response::Builder', 'std::marker::Sized', 'std::option::Option', 'std::result::Result'], 'response::Builder::new': ['response::Builder', 'std::marker::Sized', 'std::result::Result'], 'response::Builder::status': ['response::Builder', 'std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result'], 'response::Builder::version': ['response::Builder', 'std::marker::Sized', 'std::result::Result', 'version::Http', 'version::Version'], 'response::Parts': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Parts::new': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<()>::builder': ['response::Builder', 'std::marker::Sized', 'std::result::Result'], 'response::Response::<T>::body': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::body_mut': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::extensions': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::extensions_mut': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::from_parts': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::headers': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::headers_mut': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::into_body': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::into_parts': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::map': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::ops::FnOnce', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::new': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::status': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::status_mut': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::version': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'response::Response::<T>::version_mut': ['extensions::Extensions', 'header::map::Danger', 'header::map::HeaderMap', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::alloc::Allocator', 'std::boxed::Box', 'std::hash::RandomState', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option', 'std::vec::Vec', 'version::Http', 'version::Version'], 'status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], 'status::<impl std::convert::From<status::StatusCode> for u16>::from': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], 'status::InvalidStatusCode': ['status::InvalidStatusCode'], 'status::InvalidStatusCode::new': ['status::InvalidStatusCode'], 'status::StatusCode': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], 'status::StatusCode::as_str': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], 'status::StatusCode::as_u16': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], 'status::StatusCode::canonical_reason': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive', 'std::option::Option'], 'status::StatusCode::from_bytes': ['std::marker::Sized', 'std::result::Result'], 'status::StatusCode::from_u16': ['std::marker::Sized', 'std::result::Result'], 'status::StatusCode::is_client_error': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], 'status::StatusCode::is_informational': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], 'status::StatusCode::is_redirection': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], 'status::StatusCode::is_server_error': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], 'status::StatusCode::is_success': ['status::StatusCode', 'std::marker::Sized', 'std::num::NonZero', 'std::num::ZeroablePrimitive'], 'status::canonical_reason': ['std::marker::Sized', 'std::option::Option'], "uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq": ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::ErrorKind': ['uri::ErrorKind'], 'uri::InvalidUri': ['uri::ErrorKind', 'uri::InvalidUri'], 'uri::InvalidUri::s': ['uri::ErrorKind', 'uri::InvalidUri'], 'uri::InvalidUriParts': ['uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts'], 'uri::Parts': ['std::marker::Sized', 'std::option::Option', 'uri::Parts'], 'uri::Uri': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::authority': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::builder': ['std::marker::Sized', 'std::result::Result', 'uri::builder::Builder'], 'uri::Uri::from_maybe_shared': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'uri::Uri::from_parts': ['std::marker::Sized', 'std::option::Option', 'std::result::Result', 'uri::Parts'], 'uri::Uri::from_shared': ['bytes::Bytes', 'std::marker::Sized', 'std::result::Result'], 'uri::Uri::from_static': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::has_path': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::host': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::into_parts': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::Parts', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::path': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::path_and_query': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::port': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::port_u16': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::query': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::scheme': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::Uri::scheme_str': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq": ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], 'uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'std::string::String', 'uri::authority::Authority'], 'uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp": ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::authority::Authority'], 'uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'std::string::String', 'uri::authority::Authority'], 'uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::authority::Authority'], 'uri::authority::Authority': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], 'uri::authority::Authority::as_str': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], 'uri::authority::Authority::empty': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], 'uri::authority::Authority::from_maybe_shared': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'uri::authority::Authority::from_shared': ['bytes::Bytes', 'std::marker::Sized', 'std::result::Result'], 'uri::authority::Authority::from_static': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], 'uri::authority::Authority::host': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::authority::Authority'], 'uri::authority::Authority::parse': ['std::marker::Sized', 'std::result::Result'], 'uri::authority::Authority::parse_non_empty': ['std::marker::Sized', 'std::result::Result'], 'uri::authority::Authority::port': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::authority::Authority'], 'uri::authority::Authority::port_u16': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::authority::Authority'], 'uri::authority::create_authority': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::convert::AsRef', 'std::marker::Sized', 'std::ops::FnOnce', 'std::result::Result'], 'uri::authority::host': [], 'uri::builder::Builder': ['std::marker::Sized', 'std::result::Result', 'uri::builder::Builder'], 'uri::builder::Builder::authority': ['std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result', 'uri::builder::Builder'], 'uri::builder::Builder::build': ['std::marker::Sized', 'std::result::Result', 'uri::builder::Builder'], 'uri::builder::Builder::map': ['std::marker::Sized', 'std::ops::FnOnce', 'std::result::Result', 'uri::builder::Builder'], 'uri::builder::Builder::new': ['std::marker::Sized', 'std::result::Result', 'uri::builder::Builder'], 'uri::builder::Builder::path_and_query': ['std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result', 'uri::builder::Builder'], 'uri::builder::Builder::scheme': ['std::convert::Into', 'std::convert::TryInto', 'std::marker::Sized', 'std::result::Result', 'uri::builder::Builder'], 'uri::parse_full': ['bytes::Bytes', 'std::marker::Sized', 'std::result::Result'], "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq": ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], 'uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'std::string::String', 'uri::path::PathAndQuery'], 'uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp": ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::path::PathAndQuery'], 'uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'std::string::String', 'uri::path::PathAndQuery'], 'uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::path::PathAndQuery'], 'uri::path::PathAndQuery': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], 'uri::path::PathAndQuery::as_str': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], 'uri::path::PathAndQuery::empty': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], 'uri::path::PathAndQuery::from_maybe_shared': ['header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'std::convert::AsRef', 'std::marker::Sized', 'std::result::Result'], 'uri::path::PathAndQuery::from_shared': ['bytes::Bytes', 'std::marker::Sized', 'std::result::Result'], 'uri::path::PathAndQuery::from_static': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], 'uri::path::PathAndQuery::path': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], 'uri::path::PathAndQuery::query': ['byte_str::ByteStr', 'bytes::Bytes', 'std::marker::Sized', 'std::option::Option', 'uri::path::PathAndQuery'], 'uri::path::PathAndQuery::slash': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], 'uri::path::PathAndQuery::star': ['byte_str::ByteStr', 'bytes::Bytes', 'uri::path::PathAndQuery'], 'uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq': ['std::marker::Sized', 'uri::port::Port'], 'uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from': ['std::marker::Sized', 'uri::port::Port'], 'uri::port::Port': ['std::marker::Sized', 'uri::port::Port'], 'uri::port::Port::<T>::as_str': ['std::marker::Sized', 'uri::port::Port'], 'uri::port::Port::<T>::as_u16': ['std::marker::Sized', 'uri::port::Port'], 'uri::port::Port::<T>::from_str': ['std::marker::Sized', 'std::result::Result'], 'uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::scheme::Protocol': ['uri::scheme::Protocol'], 'uri::scheme::Protocol::len': ['uri::scheme::Protocol'], 'uri::scheme::Scheme': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::scheme::Scheme2': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme2'], 'uri::scheme::Scheme2::<T>::is_none': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme2'], 'uri::scheme::Scheme2::<usize>::parse': ['std::marker::Sized', 'std::result::Result'], 'uri::scheme::Scheme2::<usize>::parse_exact': ['std::marker::Sized', 'std::result::Result'], 'uri::scheme::Scheme::as_str': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'uri::scheme::Scheme::empty': ['std::marker::Sized', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'version::Http': ['version::Http'], 'version::Version': ['version::Http', 'version::Version']}, 'glob_path_import': {}, 'self_to_fn': {'<T as extensions::AnyClone>::T': ["impl<T: Clone + Send + Sync + 'static> AnyClone for T {\n    fn clone_box(&self) -> Box<dyn AnyClone + Send + Sync> {\n        Box::new(self.clone())\n    }\n\n    fn as_any(&self) -> &dyn Any {\n        self\n    }\n\n    fn as_any_mut(&mut self) -> &mut dyn Any {\n        self\n    }\n\n    fn into_any(self: Box<Self>) -> Box<dyn Any> {\n        self\n    }\n}"], 'byte_str::ByteStr': ['Clone', 'Debug', 'Eq', 'Hash', 'Ord', 'PartialEq', 'PartialOrd', 'impl ByteStr {\n    #[inline]\n    pub fn new() -> ByteStr {\n        ByteStr {\n            // Invariant: the empty slice is trivially valid UTF-8.\n            bytes: Bytes::new(),\n        }\n    }\n\n    #[inline]\n    pub const fn from_static(val: &\'static str) -> ByteStr {\n        ByteStr {\n            // Invariant: val is a str so contains valid UTF-8.\n            bytes: Bytes::from_static(val.as_bytes()),\n        }\n    }\n\n    #[inline]\n    /// ## Panics\n    /// In a debug build this will panic if `bytes` is not valid UTF-8.\n    ///\n    /// ## Safety\n    /// `bytes` must contain valid UTF-8. In a release build it is undefined\n    /// behavior to call this with `bytes` that is not valid UTF-8.\n    pub unsafe fn from_utf8_unchecked(bytes: Bytes) -> ByteStr {\n        if cfg!(debug_assertions) {\n            match str::from_utf8(&bytes) {\n                Ok(_) => (),\n                Err(err) => panic!(\n                    "ByteStr::from_utf8_unchecked() with invalid bytes; error = {}, bytes = {:?}",\n                    err, bytes\n                ),\n            }\n        }\n        // Invariant: assumed by the safety requirements of this function.\n        ByteStr { bytes }\n    }\n\n    pub(crate) fn from_utf8(bytes: Bytes) -> Result<ByteStr, std::str::Utf8Error> {\n        str::from_utf8(&bytes)?;\n        // Invariant: just checked is utf8\n        Ok(ByteStr { bytes })\n    }\n}', 'impl From<String> for ByteStr {\n    #[inline]\n    fn from(src: String) -> ByteStr {\n        ByteStr {\n            // Invariant: src is a String so contains valid UTF-8.\n            bytes: Bytes::from(src),\n        }\n    }\n}', 'impl ops::Deref for ByteStr {\n    type Target = str;\n\n    #[inline]\n    fn deref(&self) -> &str {\n        let b: &[u8] = self.bytes.as_ref();\n        // Safety: the invariant of `bytes` is that it contains valid UTF-8.\n        unsafe { str::from_utf8_unchecked(b) }\n    }\n}', "impl<'a> From<&'a str> for ByteStr {\n    #[inline]\n    fn from(src: &'a str) -> ByteStr {\n        ByteStr {\n            // Invariant: src is a str so contains valid UTF-8.\n            bytes: Bytes::copy_from_slice(src.as_bytes()),\n        }\n    }\n}"], 'bytes::Bytes': ['impl From<ByteStr> for Bytes {\n    fn from(src: ByteStr) -> Self {\n        src.bytes\n    }\n}', 'impl From<Custom> for Bytes {\n    #[inline]\n    fn from(Custom(inner): Custom) -> Bytes {\n        Bytes::from(inner)\n    }\n}', 'impl<T> From<Repr<T>> for Bytes\nwhere\n    T: Into<Bytes>,\n{\n    fn from(repr: Repr<T>) -> Bytes {\n        match repr {\n            Repr::Standard(header) => Bytes::from_static(header.as_str().as_bytes()),\n            Repr::Custom(header) => header.into(),\n        }\n    }\n}'], 'error::Error': ["impl Error {\n    /// Return true if the underlying error has the same type as T.\n    pub fn is<T: error::Error + 'static>(&self) -> bool {\n        self.get_ref().is::<T>()\n    }\n\n    /// Return a reference to the lower level, inner error.\n    pub fn get_ref(&self) -> &(dyn error::Error + 'static) {\n        use self::ErrorKind::*;\n\n        match self.inner {\n            StatusCode(ref e) => e,\n            Method(ref e) => e,\n            Uri(ref e) => e,\n            UriParts(ref e) => e,\n            HeaderName(ref e) => e,\n            HeaderValue(ref e) => e,\n            MaxSizeReached(ref e) => e,\n        }\n    }\n}", 'impl From<MaxSizeReached> for Error {\n    fn from(err: MaxSizeReached) -> Error {\n        Error {\n            inner: ErrorKind::MaxSizeReached(err),\n        }\n    }\n}', 'impl From<header::InvalidHeaderName> for Error {\n    fn from(err: header::InvalidHeaderName) -> Error {\n        Error {\n            inner: ErrorKind::HeaderName(err),\n        }\n    }\n}', 'impl From<header::InvalidHeaderValue> for Error {\n    fn from(err: header::InvalidHeaderValue) -> Error {\n        Error {\n            inner: ErrorKind::HeaderValue(err),\n        }\n    }\n}', 'impl From<method::InvalidMethod> for Error {\n    fn from(err: method::InvalidMethod) -> Error {\n        Error {\n            inner: ErrorKind::Method(err),\n        }\n    }\n}', 'impl From<status::InvalidStatusCode> for Error {\n    fn from(err: status::InvalidStatusCode) -> Error {\n        Error {\n            inner: ErrorKind::StatusCode(err),\n        }\n    }\n}', 'impl From<std::convert::Infallible> for Error {\n    fn from(err: std::convert::Infallible) -> Error {\n        match err {}\n    }\n}', 'impl From<uri::InvalidUri> for Error {\n    fn from(err: uri::InvalidUri) -> Error {\n        Error {\n            inner: ErrorKind::Uri(err),\n        }\n    }\n}', 'impl From<uri::InvalidUriParts> for Error {\n    fn from(err: uri::InvalidUriParts) -> Error {\n        Error {\n            inner: ErrorKind::UriParts(err),\n        }\n    }\n}', "impl error::Error for Error {\n    // Return any available cause from the inner error. Note the inner error is\n    // not itself the cause.\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        self.get_ref().source()\n    }\n}", 'impl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple("http::Error")\n            // Skip the noise of the ErrorKind enum\n            .field(&self.get_ref())\n            .finish()\n    }\n}', "impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.get_ref(), f)\n    }\n}"], 'extensions::Extensions': ['Clone', 'Default', 'impl Extensions {\n    /// Create an empty `Extensions`.\n    #[inline]\n    pub fn new() -> Extensions {\n        Extensions { map: None }\n    }\n\n    /// Insert a type into this `Extensions`.\n    ///\n    /// If a extension of this type already existed, it will\n    /// be returned and replaced with the new one.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// assert!(ext.insert(5i32).is_none());\n    /// assert!(ext.insert(4u8).is_none());\n    /// assert_eq!(ext.insert(9i32), Some(5i32));\n    /// ```\n    pub fn insert<T: Clone + Send + Sync + \'static>(&mut self, val: T) -> Option<T> {\n        self.map\n            .get_or_insert_with(Box::default)\n            .insert(TypeId::of::<T>(), Box::new(val))\n            .and_then(|boxed| boxed.into_any().downcast().ok().map(|boxed| *boxed))\n    }\n\n    /// Get a reference to a type previously inserted on this `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// assert!(ext.get::<i32>().is_none());\n    /// ext.insert(5i32);\n    ///\n    /// assert_eq!(ext.get::<i32>(), Some(&5i32));\n    /// ```\n    pub fn get<T: Send + Sync + \'static>(&self) -> Option<&T> {\n        self.map\n            .as_ref()\n            .and_then(|map| map.get(&TypeId::of::<T>()))\n            .and_then(|boxed| (**boxed).as_any().downcast_ref())\n    }\n\n    /// Get a mutable reference to a type previously inserted on this `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// ext.insert(String::from("Hello"));\n    /// ext.get_mut::<String>().unwrap().push_str(" World");\n    ///\n    /// assert_eq!(ext.get::<String>().unwrap(), "Hello World");\n    /// ```\n    pub fn get_mut<T: Send + Sync + \'static>(&mut self) -> Option<&mut T> {\n        self.map\n            .as_mut()\n            .and_then(|map| map.get_mut(&TypeId::of::<T>()))\n            .and_then(|boxed| (**boxed).as_any_mut().downcast_mut())\n    }\n\n    /// Get a mutable reference to a type, inserting `value` if not already present on this\n    /// `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// *ext.get_or_insert(1i32) += 2;\n    ///\n    /// assert_eq!(*ext.get::<i32>().unwrap(), 3);\n    /// ```\n    pub fn get_or_insert<T: Clone + Send + Sync + \'static>(&mut self, value: T) -> &mut T {\n        self.get_or_insert_with(|| value)\n    }\n\n    /// Get a mutable reference to a type, inserting the value created by `f` if not already present\n    /// on this `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// *ext.get_or_insert_with(|| 1i32) += 2;\n    ///\n    /// assert_eq!(*ext.get::<i32>().unwrap(), 3);\n    /// ```\n    pub fn get_or_insert_with<T: Clone + Send + Sync + \'static, F: FnOnce() -> T>(\n        &mut self,\n        f: F,\n    ) -> &mut T {\n        let out = self\n            .map\n            .get_or_insert_with(Box::default)\n            .entry(TypeId::of::<T>())\n            .or_insert_with(|| Box::new(f()));\n        (**out).as_any_mut().downcast_mut().unwrap()\n    }\n\n    /// Get a mutable reference to a type, inserting the type\'s default value if not already present\n    /// on this `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// *ext.get_or_insert_default::<i32>() += 2;\n    ///\n    /// assert_eq!(*ext.get::<i32>().unwrap(), 2);\n    /// ```\n    pub fn get_or_insert_default<T: Default + Clone + Send + Sync + \'static>(&mut self) -> &mut T {\n        self.get_or_insert_with(T::default)\n    }\n\n    /// Remove a type from this `Extensions`.\n    ///\n    /// If a extension of this type existed, it will be returned.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// ext.insert(5i32);\n    /// assert_eq!(ext.remove::<i32>(), Some(5i32));\n    /// assert!(ext.get::<i32>().is_none());\n    /// ```\n    pub fn remove<T: Send + Sync + \'static>(&mut self) -> Option<T> {\n        self.map\n            .as_mut()\n            .and_then(|map| map.remove(&TypeId::of::<T>()))\n            .and_then(|boxed| boxed.into_any().downcast().ok().map(|boxed| *boxed))\n    }\n\n    /// Clear the `Extensions` of all inserted extensions.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// ext.insert(5i32);\n    /// ext.clear();\n    ///\n    /// assert!(ext.get::<i32>().is_none());\n    /// ```\n    #[inline]\n    pub fn clear(&mut self) {\n        if let Some(ref mut map) = self.map {\n            map.clear();\n        }\n    }\n\n    /// Check whether the extension set is empty or not.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// assert!(ext.is_empty());\n    /// ext.insert(5i32);\n    /// assert!(!ext.is_empty());\n    /// ```\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.map.as_ref().map_or(true, |map| map.is_empty())\n    }\n\n    /// Get the number of extensions available.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// assert_eq!(ext.len(), 0);\n    /// ext.insert(5i32);\n    /// assert_eq!(ext.len(), 1);\n    /// ```\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.map.as_ref().map_or(0, |map| map.len())\n    }\n\n    /// Extends `self` with another `Extensions`.\n    ///\n    /// If an instance of a specific type exists in both, the one in `self` is overwritten with the\n    /// one from `other`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext_a = Extensions::new();\n    /// ext_a.insert(8u8);\n    /// ext_a.insert(16u16);\n    ///\n    /// let mut ext_b = Extensions::new();\n    /// ext_b.insert(4u8);\n    /// ext_b.insert("hello");\n    ///\n    /// ext_a.extend(ext_b);\n    /// assert_eq!(ext_a.len(), 3);\n    /// assert_eq!(ext_a.get::<u8>(), Some(&4u8));\n    /// assert_eq!(ext_a.get::<u16>(), Some(&16u16));\n    /// assert_eq!(ext_a.get::<&\'static str>().copied(), Some("hello"));\n    /// ```\n    pub fn extend(&mut self, other: Self) {\n        if let Some(other) = other.map {\n            if let Some(map) = &mut self.map {\n                map.extend(*other);\n            } else {\n                self.map = Some(other);\n            }\n        }\n    }\n}', 'impl fmt::Debug for Extensions {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("Extensions").finish()\n    }\n}'], 'extensions::IdHasher': ['Default', 'impl Hasher for IdHasher {\n    fn write(&mut self, _: &[u8]) {\n        unreachable!("TypeId calls write_u64");\n    }\n\n    #[inline]\n    fn write_u64(&mut self, id: u64) {\n        self.0 = id;\n    }\n\n    #[inline]\n    fn finish(&self) -> u64 {\n        self.0\n    }\n}'], 'header::map::Bucket': ['Clone', 'Debug'], 'header::map::Cursor': ['Clone', 'Copy', 'Debug', 'Eq', 'PartialEq'], 'header::map::Danger': ['Clone', 'impl Danger {\n    fn is_red(&self) -> bool {\n        matches!(*self, Danger::Red(_))\n    }\n\n    fn set_red(&mut self) {\n        debug_assert!(self.is_yellow());\n        *self = Danger::Red(RandomState::new());\n    }\n\n    fn is_yellow(&self) -> bool {\n        matches!(*self, Danger::Yellow)\n    }\n\n    fn set_yellow(&mut self) {\n        if let Danger::Green = *self {\n            *self = Danger::Yellow;\n        }\n    }\n\n    fn set_green(&mut self) {\n        debug_assert!(self.is_yellow());\n        *self = Danger::Green;\n    }\n}'], 'header::map::Drain': ['Debug', "impl<'a, T> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        for _ in self {}\n    }\n}", "impl<'a, T> FusedIterator for Drain<'a, T> {}", "impl<'a, T> Iterator for Drain<'a, T> {\n    type Item = (Option<HeaderName>, T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(next) = self.next {\n            // Remove the extra value\n\n            let raw_links = RawLinks(self.entries);\n            let extra = unsafe { remove_extra_value(raw_links, &mut *self.extra_values, next) };\n\n            match extra.next {\n                Link::Extra(idx) => self.next = Some(idx),\n                Link::Entry(_) => self.next = None,\n            }\n\n            return Some((None, extra.value));\n        }\n\n        let idx = self.idx;\n\n        if idx == self.len {\n            return None;\n        }\n\n        self.idx += 1;\n\n        unsafe {\n            let entry = &(*self.entries)[idx];\n\n            // Read the header name\n            let key = ptr::read(&entry.key as *const _);\n            let value = ptr::read(&entry.value as *const _);\n            self.next = entry.links.map(|l| l.next);\n\n            Some((Some(key), value))\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // At least this many names... It's unknown if the user wants\n        // to count the extra_values on top.\n        //\n        // For instance, extending a new `HeaderMap` wouldn't need to\n        // reserve the upper-bound in `entries`, only the lower-bound.\n        let lower = self.len - self.idx;\n        let upper = unsafe { (*self.extra_values).len() } + lower;\n        (lower, Some(upper))\n    }\n}", "unsafe impl<'a, T: Send> Send for Drain<'a, T> {}", "unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}"], 'header::map::Entry': ['Debug', 'impl<\'a, T> Entry<\'a, T> {\n    /// Ensures a value is in the entry by inserting the default if empty.\n    ///\n    /// Returns a mutable reference to the **first** value in the entry.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if capacity exceeds max `HeaderMap` capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map: HeaderMap<u32> = HeaderMap::default();\n    ///\n    /// let headers = &[\n    ///     "content-length",\n    ///     "x-hello",\n    ///     "Content-Length",\n    ///     "x-world",\n    /// ];\n    ///\n    /// for &header in headers {\n    ///     let counter = map.entry(header)\n    ///         .or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(map["content-length"], 2);\n    /// assert_eq!(map["x-hello"], 1);\n    /// ```\n    pub fn or_insert(self, default: T) -> &\'a mut T {\n        self.or_try_insert(default)\n            .expect("size overflows MAX_SIZE")\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty.\n    ///\n    /// Returns a mutable reference to the **first** value in the entry.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if `HeaderMap` exceeds max capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map: HeaderMap<u32> = HeaderMap::default();\n    ///\n    /// let headers = &[\n    ///     "content-length",\n    ///     "x-hello",\n    ///     "Content-Length",\n    ///     "x-world",\n    /// ];\n    ///\n    /// for &header in headers {\n    ///     let counter = map.entry(header)\n    ///         .or_try_insert(0)\n    ///         .unwrap();\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(map["content-length"], 2);\n    /// assert_eq!(map["x-hello"], 1);\n    /// ```\n    pub fn or_try_insert(self, default: T) -> Result<&\'a mut T, MaxSizeReached> {\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => Ok(e.into_mut()),\n            Vacant(e) => e.try_insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default\n    /// function if empty.\n    ///\n    /// The default function is not called if the entry exists in the map.\n    /// Returns a mutable reference to the **first** value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage.\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// let res = map.entry("x-hello")\n    ///     .or_insert_with(|| "world".parse().unwrap());\n    ///\n    /// assert_eq!(res, "world");\n    /// ```\n    ///\n    /// The default function is not called if the entry exists in the map.\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.try_insert(HOST, "world".parse().unwrap()).unwrap();\n    ///\n    /// let res = map.try_entry("host")\n    ///     .unwrap()\n    ///     .or_try_insert_with(|| unreachable!())\n    ///     .unwrap();\n    ///\n    ///\n    /// assert_eq!(res, "world");\n    /// ```\n    pub fn or_insert_with<F: FnOnce() -> T>(self, default: F) -> &\'a mut T {\n        self.or_try_insert_with(default)\n            .expect("size overflows MAX_SIZE")\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default\n    /// function if empty.\n    ///\n    /// The default function is not called if the entry exists in the map.\n    /// Returns a mutable reference to the **first** value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage.\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// let res = map.entry("x-hello")\n    ///     .or_insert_with(|| "world".parse().unwrap());\n    ///\n    /// assert_eq!(res, "world");\n    /// ```\n    ///\n    /// The default function is not called if the entry exists in the map.\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.try_insert(HOST, "world".parse().unwrap()).unwrap();\n    ///\n    /// let res = map.try_entry("host")\n    ///     .unwrap()\n    ///     .or_try_insert_with(|| unreachable!())\n    ///     .unwrap();\n    ///\n    ///\n    /// assert_eq!(res, "world");\n    /// ```\n    pub fn or_try_insert_with<F: FnOnce() -> T>(\n        self,\n        default: F,\n    ) -> Result<&\'a mut T, MaxSizeReached> {\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => Ok(e.into_mut()),\n            Vacant(e) => e.try_insert(default()),\n        }\n    }\n\n    /// Returns a reference to the entry\'s key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(map.entry("x-hello").key(), "x-hello");\n    /// ```\n    pub fn key(&self) -> &HeaderName {\n        use self::Entry::*;\n\n        match *self {\n            Vacant(ref e) => e.key(),\n            Occupied(ref e) => e.key(),\n        }\n    }\n}'], 'header::map::ExtraValue': ['Clone', 'Debug'], 'header::map::GetAll': ['Debug', 'impl<\'a, T: \'a> GetAll<\'a, T> {\n    /// Returns an iterator visiting all values associated with the entry.\n    ///\n    /// Values are iterated in insertion order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "hello.world".parse().unwrap());\n    /// map.append(HOST, "hello.earth".parse().unwrap());\n    ///\n    /// let values = map.get_all("host");\n    /// let mut iter = values.iter();\n    /// assert_eq!(&"hello.world", iter.next().unwrap());\n    /// assert_eq!(&"hello.earth", iter.next().unwrap());\n    /// assert!(iter.next().is_none());\n    /// ```\n    pub fn iter(&self) -> ValueIter<\'a, T> {\n        // This creates a new GetAll struct so that the lifetime\n        // isn\'t bound to &self.\n        GetAll {\n            map: self.map,\n            index: self.index,\n        }\n        .into_iter()\n    }\n}', "impl<'a, T: PartialEq> PartialEq for GetAll<'a, T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.iter().eq(other.iter())\n    }\n}", "impl<'a, T> IntoIterator for GetAll<'a, T> {\n    type Item = &'a T;\n    type IntoIter = ValueIter<'a, T>;\n\n    fn into_iter(self) -> ValueIter<'a, T> {\n        self.map.value_iter(self.index)\n    }\n}"], 'header::map::HashValue': ['Clone', 'Copy', 'Debug', 'Eq', 'PartialEq'], 'header::map::HeaderMap': ['Clone', 'impl HeaderMap {\n    /// Create an empty `HeaderMap`.\n    ///\n    /// The map will be created without any capacity. This function will not\n    /// allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let map = HeaderMap::new();\n    ///\n    /// assert!(map.is_empty());\n    /// assert_eq!(0, map.capacity());\n    /// ```\n    pub fn new() -> Self {\n        HeaderMap::try_with_capacity(0).unwrap()\n    }\n}', "impl<'a, K, V, S, T> TryFrom<&'a HashMap<K, V, S>> for HeaderMap<T>\nwhere\n    K: Eq + Hash,\n    HeaderName: TryFrom<&'a K>,\n    <HeaderName as TryFrom<&'a K>>::Error: Into<crate::Error>,\n    T: TryFrom<&'a V>,\n    T::Error: Into<crate::Error>,\n{\n    type Error = Error;\n\n    fn try_from(c: &'a HashMap<K, V, S>) -> Result<Self, Self::Error> {\n        c.iter()\n            .map(|(k, v)| -> crate::Result<(HeaderName, T)> {\n                let name = TryFrom::try_from(k).map_err(Into::into)?;\n                let value = TryFrom::try_from(v).map_err(Into::into)?;\n                Ok((name, value))\n            })\n            .collect()\n    }\n}", 'impl<K, T> ops::Index<K> for HeaderMap<T>\nwhere\n    K: AsHeaderName,\n{\n    type Output = T;\n\n    /// # Panics\n    /// Using the index operator will cause a panic if the header you\'re querying isn\'t set.\n    #[inline]\n    fn index(&self, index: K) -> &T {\n        match self.get2(&index) {\n            Some(val) => val,\n            None => panic!("no entry found for key {:?}", index.as_str()),\n        }\n    }\n}', 'impl<T: Eq> Eq for HeaderMap<T> {}', 'impl<T: PartialEq> PartialEq for HeaderMap<T> {\n    fn eq(&self, other: &HeaderMap<T>) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.keys()\n            .all(|key| self.get_all(key) == other.get_all(key))\n    }\n}', "impl<T: fmt::Debug> fmt::Debug for HeaderMap<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_map().entries(self.iter()).finish()\n    }\n}", 'impl<T> Default for HeaderMap<T> {\n    fn default() -> Self {\n        HeaderMap::try_with_capacity(0).expect("zero capacity should never fail")\n    }\n}', 'impl<T> Extend<(HeaderName, T)> for HeaderMap<T> {\n    fn extend<I: IntoIterator<Item = (HeaderName, T)>>(&mut self, iter: I) {\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let iter = iter.into_iter();\n\n        let reserve = if self.is_empty() {\n            iter.size_hint().0\n        } else {\n            (iter.size_hint().0 + 1) / 2\n        };\n\n        self.reserve(reserve);\n\n        for (k, v) in iter {\n            self.append(k, v);\n        }\n    }\n}', 'impl<T> Extend<(Option<HeaderName>, T)> for HeaderMap<T> {\n    /// Extend a `HeaderMap` with the contents of another `HeaderMap`.\n    ///\n    /// This function expects the yielded items to follow the same structure as\n    /// `IntoIter`.\n    ///\n    /// # Panics\n    ///\n    /// This panics if the first yielded item does not have a `HeaderName`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(ACCEPT, "text/plain".parse().unwrap());\n    /// map.insert(HOST, "hello.world".parse().unwrap());\n    ///\n    /// let mut extra = HeaderMap::new();\n    ///\n    /// extra.insert(HOST, "foo.bar".parse().unwrap());\n    /// extra.insert(COOKIE, "hello".parse().unwrap());\n    /// extra.append(COOKIE, "world".parse().unwrap());\n    ///\n    /// map.extend(extra);\n    ///\n    /// assert_eq!(map["host"], "foo.bar");\n    /// assert_eq!(map["accept"], "text/plain");\n    /// assert_eq!(map["cookie"], "hello");\n    ///\n    /// let v = map.get_all("host");\n    /// assert_eq!(1, v.iter().count());\n    ///\n    /// let v = map.get_all("cookie");\n    /// assert_eq!(2, v.iter().count());\n    /// ```\n    fn extend<I: IntoIterator<Item = (Option<HeaderName>, T)>>(&mut self, iter: I) {\n        let mut iter = iter.into_iter();\n\n        // The structure of this is a bit weird, but it is mostly to make the\n        // borrow checker happy.\n        let (mut key, mut val) = match iter.next() {\n            Some((Some(key), val)) => (key, val),\n            Some((None, _)) => panic!("expected a header name, but got None"),\n            None => return,\n        };\n\n        \'outer: loop {\n            let mut entry = match self.try_entry2(key).expect("size overflows MAX_SIZE") {\n                Entry::Occupied(mut e) => {\n                    // Replace all previous values while maintaining a handle to\n                    // the entry.\n                    e.insert(val);\n                    e\n                }\n                Entry::Vacant(e) => e.insert_entry(val),\n            };\n\n            // As long as `HeaderName` is none, keep inserting the value into\n            // the current entry\n            loop {\n                match iter.next() {\n                    Some((Some(k), v)) => {\n                        key = k;\n                        val = v;\n                        continue \'outer;\n                    }\n                    Some((None, v)) => {\n                        entry.append(v);\n                    }\n                    None => {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}', 'impl<T> FromIterator<(HeaderName, T)> for HeaderMap<T> {\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (HeaderName, T)>,\n    {\n        let mut map = HeaderMap::default();\n        map.extend(iter);\n        map\n    }\n}', 'impl<T> HeaderMap<T> {\n    /// Create an empty `HeaderMap` with the specified capacity.\n    ///\n    /// The returned map will allocate internal storage in order to hold about\n    /// `capacity` elements without reallocating. However, this is a "best\n    /// effort" as there are usage patterns that could cause additional\n    /// allocations before `capacity` headers are stored in the map.\n    ///\n    /// More capacity than requested may be allocated.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if capacity exceeds max `HeaderMap` capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let map: HeaderMap<u32> = HeaderMap::with_capacity(10);\n    ///\n    /// assert!(map.is_empty());\n    /// assert_eq!(12, map.capacity());\n    /// ```\n    pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n        Self::try_with_capacity(capacity).expect("size overflows MAX_SIZE")\n    }\n\n    /// Create an empty `HeaderMap` with the specified capacity.\n    ///\n    /// The returned map will allocate internal storage in order to hold about\n    /// `capacity` elements without reallocating. However, this is a "best\n    /// effort" as there are usage patterns that could cause additional\n    /// allocations before `capacity` headers are stored in the map.\n    ///\n    /// More capacity than requested may be allocated.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if `HeaderMap` exceeds max capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let map: HeaderMap<u32> = HeaderMap::try_with_capacity(10).unwrap();\n    ///\n    /// assert!(map.is_empty());\n    /// assert_eq!(12, map.capacity());\n    /// ```\n    pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n        if capacity == 0 {\n            Ok(HeaderMap {\n                mask: 0,\n                indices: Box::new([]), // as a ZST, this doesn\'t actually allocate anything\n                entries: Vec::new(),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            })\n        } else {\n            let raw_cap = match to_raw_capacity(capacity).checked_next_power_of_two() {\n                Some(c) => c,\n                None => return Err(MaxSizeReached { _priv: () }),\n            };\n            if raw_cap > MAX_SIZE {\n                return Err(MaxSizeReached { _priv: () });\n            }\n            debug_assert!(raw_cap > 0);\n\n            Ok(HeaderMap {\n                mask: (raw_cap - 1) as Size,\n                indices: vec![Pos::none(); raw_cap].into_boxed_slice(),\n                entries: Vec::with_capacity(usable_capacity(raw_cap)),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            })\n        }\n    }\n\n    /// Returns the number of headers stored in the map.\n    ///\n    /// This number represents the total number of **values** stored in the map.\n    /// This number can be greater than or equal to the number of **keys**\n    /// stored given that a single key may have more than one associated value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{ACCEPT, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(0, map.len());\n    ///\n    /// map.insert(ACCEPT, "text/plain".parse().unwrap());\n    /// map.insert(HOST, "localhost".parse().unwrap());\n    ///\n    /// assert_eq!(2, map.len());\n    ///\n    /// map.append(ACCEPT, "text/html".parse().unwrap());\n    ///\n    /// assert_eq!(3, map.len());\n    /// ```\n    pub fn len(&self) -> usize {\n        self.entries.len() + self.extra_values.len()\n    }\n\n    /// Returns the number of keys stored in the map.\n    ///\n    /// This number will be less than or equal to `len()` as each key may have\n    /// more than one associated value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{ACCEPT, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(0, map.keys_len());\n    ///\n    /// map.insert(ACCEPT, "text/plain".parse().unwrap());\n    /// map.insert(HOST, "localhost".parse().unwrap());\n    ///\n    /// assert_eq!(2, map.keys_len());\n    ///\n    /// map.insert(ACCEPT, "text/html".parse().unwrap());\n    ///\n    /// assert_eq!(2, map.keys_len());\n    /// ```\n    pub fn keys_len(&self) -> usize {\n        self.entries.len()\n    }\n\n    /// Returns true if the map contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert!(map.is_empty());\n    ///\n    /// map.insert(HOST, "hello.world".parse().unwrap());\n    ///\n    /// assert!(!map.is_empty());\n    /// ```\n    pub fn is_empty(&self) -> bool {\n        self.entries.len() == 0\n    }\n\n    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n    /// for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "hello.world".parse().unwrap());\n    ///\n    /// map.clear();\n    /// assert!(map.is_empty());\n    /// assert!(map.capacity() > 0);\n    /// ```\n    pub fn clear(&mut self) {\n        self.entries.clear();\n        self.extra_values.clear();\n        self.danger = Danger::Green;\n\n        for e in self.indices.iter_mut() {\n            *e = Pos::none();\n        }\n    }\n\n    /// Returns the number of headers the map can hold without reallocating.\n    ///\n    /// This number is an approximation as certain usage patterns could cause\n    /// additional allocations before the returned capacity is filled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(0, map.capacity());\n    ///\n    /// map.insert(HOST, "hello.world".parse().unwrap());\n    /// assert_eq!(6, map.capacity());\n    /// ```\n    pub fn capacity(&self) -> usize {\n        usable_capacity(self.indices.len())\n    }\n\n    /// Reserves capacity for at least `additional` more headers to be inserted\n    /// into the `HeaderMap`.\n    ///\n    /// The header map may reserve more space to avoid frequent reallocations.\n    /// Like with `with_capacity`, this will be a "best effort" to avoid\n    /// allocations until `additional` more headers are inserted. Certain usage\n    /// patterns could cause additional allocations before the number is\n    /// reached.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new allocation size overflows `HeaderMap` `MAX_SIZE`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.reserve(10);\n    /// # map.insert(HOST, "bar".parse().unwrap());\n    /// ```\n    pub fn reserve(&mut self, additional: usize) {\n        self.try_reserve(additional)\n            .expect("size overflows MAX_SIZE")\n    }\n\n    /// Reserves capacity for at least `additional` more headers to be inserted\n    /// into the `HeaderMap`.\n    ///\n    /// The header map may reserve more space to avoid frequent reallocations.\n    /// Like with `with_capacity`, this will be a "best effort" to avoid\n    /// allocations until `additional` more headers are inserted. Certain usage\n    /// patterns could cause additional allocations before the number is\n    /// reached.\n    ///\n    /// # Errors\n    ///\n    /// This method differs from `reserve` by returning an error instead of\n    /// panicking if the value is too large.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.try_reserve(10).unwrap();\n    /// # map.try_insert(HOST, "bar".parse().unwrap()).unwrap();\n    /// ```\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), MaxSizeReached> {\n        // TODO: This can\'t overflow if done properly... since the max # of\n        // elements is u16::MAX.\n        let cap = self\n            .entries\n            .len()\n            .checked_add(additional)\n            .ok_or_else(MaxSizeReached::new)?;\n\n        let raw_cap = to_raw_capacity(cap);\n\n        if raw_cap > self.indices.len() {\n            let raw_cap = raw_cap\n                .checked_next_power_of_two()\n                .ok_or_else(MaxSizeReached::new)?;\n            if raw_cap > MAX_SIZE {\n                return Err(MaxSizeReached::new());\n            }\n\n            if self.entries.is_empty() {\n                self.mask = raw_cap as Size - 1;\n                self.indices = vec![Pos::none(); raw_cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(raw_cap));\n            } else {\n                self.try_grow(raw_cap)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Returns a reference to the value associated with the key.\n    ///\n    /// If there are multiple values associated with the key, then the first one\n    /// is returned. Use `get_all` to get all values associated with a given\n    /// key. Returns `None` if there are no values associated with the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.get("host").is_none());\n    ///\n    /// map.insert(HOST, "hello".parse().unwrap());\n    /// assert_eq!(map.get(HOST).unwrap(), &"hello");\n    /// assert_eq!(map.get("host").unwrap(), &"hello");\n    ///\n    /// map.append(HOST, "world".parse().unwrap());\n    /// assert_eq!(map.get("host").unwrap(), &"hello");\n    /// ```\n    pub fn get<K>(&self, key: K) -> Option<&T>\n    where\n        K: AsHeaderName,\n    {\n        self.get2(&key)\n    }\n\n    fn get2<K>(&self, key: &K) -> Option<&T>\n    where\n        K: AsHeaderName,\n    {\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &self.entries[found];\n                Some(&entry.value)\n            }\n            None => None,\n        }\n    }\n\n    /// Returns a mutable reference to the value associated with the key.\n    ///\n    /// If there are multiple values associated with the key, then the first one\n    /// is returned. Use `entry` to get all values associated with a given\n    /// key. Returns `None` if there are no values associated with the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, "hello".to_string());\n    /// map.get_mut("host").unwrap().push_str("-world");\n    ///\n    /// assert_eq!(map.get(HOST).unwrap(), &"hello-world");\n    /// ```\n    pub fn get_mut<K>(&mut self, key: K) -> Option<&mut T>\n    where\n        K: AsHeaderName,\n    {\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &mut self.entries[found];\n                Some(&mut entry.value)\n            }\n            None => None,\n        }\n    }\n\n    /// Returns a view of all values associated with a key.\n    ///\n    /// The returned view does not incur any allocations and allows iterating\n    /// the values associated with the key.  See [`GetAll`] for more details.\n    /// Returns `None` if there are no values associated with the key.\n    ///\n    /// [`GetAll`]: struct.GetAll.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, "hello".parse().unwrap());\n    /// map.append(HOST, "goodbye".parse().unwrap());\n    ///\n    /// let view = map.get_all("host");\n    ///\n    /// let mut iter = view.iter();\n    /// assert_eq!(&"hello", iter.next().unwrap());\n    /// assert_eq!(&"goodbye", iter.next().unwrap());\n    /// assert!(iter.next().is_none());\n    /// ```\n    pub fn get_all<K>(&self, key: K) -> GetAll<\'_, T>\n    where\n        K: AsHeaderName,\n    {\n        GetAll {\n            map: self,\n            index: key.find(self).map(|(_, i)| i),\n        }\n    }\n\n    /// Returns true if the map contains a value for the specified key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(!map.contains_key(HOST));\n    ///\n    /// map.insert(HOST, "world".parse().unwrap());\n    /// assert!(map.contains_key("host"));\n    /// ```\n    pub fn contains_key<K>(&self, key: K) -> bool\n    where\n        K: AsHeaderName,\n    {\n        key.find(self).is_some()\n    }\n\n    /// An iterator visiting all key-value pairs.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version. Each key will be yielded once per associated\n    /// value. So, if a key has 3 associated values, it will be yielded 3 times.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, "hello".parse().unwrap());\n    /// map.append(HOST, "goodbye".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n    ///\n    /// for (key, value) in map.iter() {\n    ///     println!("{:?}: {:?}", key, value);\n    /// }\n    /// ```\n    pub fn iter(&self) -> Iter<\'_, T> {\n        Iter {\n            map: self,\n            entry: 0,\n            cursor: self.entries.first().map(|_| Cursor::Head),\n        }\n    }\n\n    /// An iterator visiting all key-value pairs, with mutable value references.\n    ///\n    /// The iterator order is arbitrary, but consistent across platforms for the\n    /// same crate version. Each key will be yielded once per associated value,\n    /// so if a key has 3 associated values, it will be yielded 3 times.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::default();\n    ///\n    /// map.insert(HOST, "hello".to_string());\n    /// map.append(HOST, "goodbye".to_string());\n    /// map.insert(CONTENT_LENGTH, "123".to_string());\n    ///\n    /// for (key, value) in map.iter_mut() {\n    ///     value.push_str("-boop");\n    /// }\n    /// ```\n    pub fn iter_mut(&mut self) -> IterMut<\'_, T> {\n        IterMut {\n            map: self as *mut _,\n            entry: 0,\n            cursor: self.entries.first().map(|_| Cursor::Head),\n            lt: PhantomData,\n        }\n    }\n\n    /// An iterator visiting all keys.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version. Each key will be yielded only once even if it\n    /// has multiple associated values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, "hello".parse().unwrap());\n    /// map.append(HOST, "goodbye".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n    ///\n    /// for key in map.keys() {\n    ///     println!("{:?}", key);\n    /// }\n    /// ```\n    pub fn keys(&self) -> Keys<\'_, T> {\n        Keys {\n            inner: self.entries.iter(),\n        }\n    }\n\n    /// An iterator visiting all values.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, "hello".parse().unwrap());\n    /// map.append(HOST, "goodbye".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n    ///\n    /// for value in map.values() {\n    ///     println!("{:?}", value);\n    /// }\n    /// ```\n    pub fn values(&self) -> Values<\'_, T> {\n        Values { inner: self.iter() }\n    }\n\n    /// An iterator visiting all values mutably.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::default();\n    ///\n    /// map.insert(HOST, "hello".to_string());\n    /// map.append(HOST, "goodbye".to_string());\n    /// map.insert(CONTENT_LENGTH, "123".to_string());\n    ///\n    /// for value in map.values_mut() {\n    ///     value.push_str("-boop");\n    /// }\n    /// ```\n    pub fn values_mut(&mut self) -> ValuesMut<\'_, T> {\n        ValuesMut {\n            inner: self.iter_mut(),\n        }\n    }\n\n    /// Clears the map, returning all entries as an iterator.\n    ///\n    /// The internal memory is kept for reuse.\n    ///\n    /// For each yielded item that has `None` provided for the `HeaderName`,\n    /// then the associated header name is the same as that of the previously\n    /// yielded item. The first yielded item will have `HeaderName` set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, "hello".parse().unwrap());\n    /// map.append(HOST, "goodbye".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n    ///\n    /// let mut drain = map.drain();\n    ///\n    ///\n    /// assert_eq!(drain.next(), Some((Some(HOST), "hello".parse().unwrap())));\n    /// assert_eq!(drain.next(), Some((None, "goodbye".parse().unwrap())));\n    ///\n    /// assert_eq!(drain.next(), Some((Some(CONTENT_LENGTH), "123".parse().unwrap())));\n    ///\n    /// assert_eq!(drain.next(), None);\n    /// ```\n    pub fn drain(&mut self) -> Drain<\'_, T> {\n        for i in self.indices.iter_mut() {\n            *i = Pos::none();\n        }\n\n        // Memory safety\n        //\n        // When the Drain is first created, it shortens the length of\n        // the source vector to make sure no uninitialized or moved-from\n        // elements are accessible at all if the Drain\'s destructor never\n        // gets to run.\n\n        let entries = &mut self.entries[..] as *mut _;\n        let extra_values = &mut self.extra_values as *mut _;\n        let len = self.entries.len();\n        unsafe {\n            self.entries.set_len(0);\n        }\n\n        Drain {\n            idx: 0,\n            len,\n            entries,\n            extra_values,\n            next: None,\n            lt: PhantomData,\n        }\n    }\n\n    fn value_iter(&self, idx: Option<usize>) -> ValueIter<\'_, T> {\n        use self::Cursor::*;\n\n        if let Some(idx) = idx {\n            let back = {\n                let entry = &self.entries[idx];\n\n                entry.links.map(|l| Values(l.tail)).unwrap_or(Head)\n            };\n\n            ValueIter {\n                map: self,\n                index: idx,\n                front: Some(Head),\n                back: Some(back),\n            }\n        } else {\n            ValueIter {\n                map: self,\n                index: usize::MAX,\n                front: None,\n                back: None,\n            }\n        }\n    }\n\n    fn value_iter_mut(&mut self, idx: usize) -> ValueIterMut<\'_, T> {\n        use self::Cursor::*;\n\n        let back = {\n            let entry = &self.entries[idx];\n\n            entry.links.map(|l| Values(l.tail)).unwrap_or(Head)\n        };\n\n        ValueIterMut {\n            map: self as *mut _,\n            index: idx,\n            front: Some(Head),\n            back: Some(back),\n            lt: PhantomData,\n        }\n    }\n\n    /// Gets the given key\'s corresponding entry in the map for in-place\n    /// manipulation.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if capacity exceeds max `HeaderMap` capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map: HeaderMap<u32> = HeaderMap::default();\n    ///\n    /// let headers = &[\n    ///     "content-length",\n    ///     "x-hello",\n    ///     "Content-Length",\n    ///     "x-world",\n    /// ];\n    ///\n    /// for &header in headers {\n    ///     let counter = map.entry(header).or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(map["content-length"], 2);\n    /// assert_eq!(map["x-hello"], 1);\n    /// ```\n    pub fn entry<K>(&mut self, key: K) -> Entry<\'_, T>\n    where\n        K: IntoHeaderName,\n    {\n        key.try_entry(self).expect("size overflows MAX_SIZE")\n    }\n\n    /// Gets the given key\'s corresponding entry in the map for in-place\n    /// manipulation.\n    ///\n    /// # Errors\n    ///\n    /// This method differs from `entry` by allowing types that may not be\n    /// valid `HeaderName`s to passed as the key (such as `String`). If they\n    /// do not parse as a valid `HeaderName`, this returns an\n    /// `InvalidHeaderName` error.\n    ///\n    /// If reserving space goes over the maximum, this will also return an\n    /// error. However, to prevent breaking changes to the return type, the\n    /// error will still say `InvalidHeaderName`, unlike other `try_*` methods\n    /// which return a `MaxSizeReached` error.\n    pub fn try_entry<K>(&mut self, key: K) -> Result<Entry<\'_, T>, InvalidHeaderName>\n    where\n        K: AsHeaderName,\n    {\n        key.try_entry(self).map_err(|err| match err {\n            as_header_name::TryEntryError::InvalidHeaderName(e) => e,\n            as_header_name::TryEntryError::MaxSizeReached(_e) => {\n                // Unfortunately, we cannot change the return type of this\n                // method, so the max size reached error needs to be converted\n                // into an InvalidHeaderName. Yay.\n                InvalidHeaderName::new()\n            }\n        })\n    }\n\n    fn try_entry2<K>(&mut self, key: K) -> Result<Entry<\'_, T>, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,\n    {\n        // Ensure that there is space in the map\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash,\n                key: key.into(),\n                probe,\n                danger,\n            }),\n            Entry::Occupied(OccupiedEntry {\n                map: self,\n                index: pos,\n                probe,\n            }),\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash,\n                key: key.into(),\n                probe,\n                danger,\n            })\n        ))\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not previously have this key present, then `None` is\n    /// returned.\n    ///\n    /// If the map did have this key present, the new value is associated with\n    /// the key and all previous values are removed. **Note** that only a single\n    /// one of the previous values is returned. If there are multiple values\n    /// that have been previously associated with the key, then the first one is\n    /// returned. See `insert_mult` on `OccupiedEntry` for an API that returns\n    /// all values.\n    ///\n    /// The key is not updated, though; this matters for types that can be `==`\n    /// without being identical.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if capacity exceeds max `HeaderMap` capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.insert(HOST, "world".parse().unwrap()).is_none());\n    /// assert!(!map.is_empty());\n    ///\n    /// let mut prev = map.insert(HOST, "earth".parse().unwrap()).unwrap();\n    /// assert_eq!("world", prev);\n    /// ```\n    pub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n    where\n        K: IntoHeaderName,\n    {\n        self.try_insert(key, val).expect("size overflows MAX_SIZE")\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not previously have this key present, then `None` is\n    /// returned.\n    ///\n    /// If the map did have this key present, the new value is associated with\n    /// the key and all previous values are removed. **Note** that only a single\n    /// one of the previous values is returned. If there are multiple values\n    /// that have been previously associated with the key, then the first one is\n    /// returned. See `insert_mult` on `OccupiedEntry` for an API that returns\n    /// all values.\n    ///\n    /// The key is not updated, though; this matters for types that can be `==`\n    /// without being identical.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if `HeaderMap` exceeds max capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.try_insert(HOST, "world".parse().unwrap()).unwrap().is_none());\n    /// assert!(!map.is_empty());\n    ///\n    /// let mut prev = map.try_insert(HOST, "earth".parse().unwrap()).unwrap().unwrap();\n    /// assert_eq!("world", prev);\n    /// ```\n    pub fn try_insert<K>(&mut self, key: K, val: T) -> Result<Option<T>, MaxSizeReached>\n    where\n        K: IntoHeaderName,\n    {\n        key.try_insert(self, val)\n    }\n\n    #[inline]\n    fn try_insert2<K>(&mut self, key: K, value: T) -> Result<Option<T>, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,\n    {\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            // Vacant\n            {\n                let _ = danger; // Make lint happy\n                let index = self.entries.len();\n                self.try_insert_entry(hash, key.into(), value)?;\n                self.indices[probe] = Pos::new(index, hash);\n                None\n            },\n            // Occupied\n            Some(self.insert_occupied(pos, value)),\n            // Robinhood\n            {\n                self.try_insert_phase_two(key.into(), value, hash, probe, danger)?;\n                None\n            }\n        ))\n    }\n\n    /// Set an occupied bucket to the given value\n    #[inline]\n    fn insert_occupied(&mut self, index: usize, value: T) -> T {\n        if let Some(links) = self.entries[index].links {\n            self.remove_all_extra_values(links.next);\n        }\n\n        let entry = &mut self.entries[index];\n        mem::replace(&mut entry.value, value)\n    }\n\n    fn insert_occupied_mult(&mut self, index: usize, value: T) -> ValueDrain<\'_, T> {\n        let old;\n        let links;\n\n        {\n            let entry = &mut self.entries[index];\n\n            old = mem::replace(&mut entry.value, value);\n            links = entry.links.take();\n        }\n\n        let raw_links = self.raw_links();\n        let extra_values = &mut self.extra_values;\n\n        let next =\n            links.map(|l| drain_all_extra_values(raw_links, extra_values, l.next).into_iter());\n\n        ValueDrain {\n            first: Some(old),\n            next,\n            lt: PhantomData,\n        }\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not previously have this key present, then `false` is\n    /// returned.\n    ///\n    /// If the map did have this key present, the new value is pushed to the end\n    /// of the list of values currently associated with the key. The key is not\n    /// updated, though; this matters for types that can be `==` without being\n    /// identical.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if capacity exceeds max `HeaderMap` capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.insert(HOST, "world".parse().unwrap()).is_none());\n    /// assert!(!map.is_empty());\n    ///\n    /// map.append(HOST, "earth".parse().unwrap());\n    ///\n    /// let values = map.get_all("host");\n    /// let mut i = values.iter();\n    /// assert_eq!("world", *i.next().unwrap());\n    /// assert_eq!("earth", *i.next().unwrap());\n    /// ```\n    pub fn append<K>(&mut self, key: K, value: T) -> bool\n    where\n        K: IntoHeaderName,\n    {\n        self.try_append(key, value)\n            .expect("size overflows MAX_SIZE")\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not previously have this key present, then `false` is\n    /// returned.\n    ///\n    /// If the map did have this key present, the new value is pushed to the end\n    /// of the list of values currently associated with the key. The key is not\n    /// updated, though; this matters for types that can be `==` without being\n    /// identical.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if `HeaderMap` exceeds max capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.try_insert(HOST, "world".parse().unwrap()).unwrap().is_none());\n    /// assert!(!map.is_empty());\n    ///\n    /// map.try_append(HOST, "earth".parse().unwrap()).unwrap();\n    ///\n    /// let values = map.get_all("host");\n    /// let mut i = values.iter();\n    /// assert_eq!("world", *i.next().unwrap());\n    /// assert_eq!("earth", *i.next().unwrap());\n    /// ```\n    pub fn try_append<K>(&mut self, key: K, value: T) -> Result<bool, MaxSizeReached>\n    where\n        K: IntoHeaderName,\n    {\n        key.try_append(self, value)\n    }\n\n    #[inline]\n    fn try_append2<K>(&mut self, key: K, value: T) -> Result<bool, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,\n    {\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            // Vacant\n            {\n                let _ = danger;\n                let index = self.entries.len();\n                self.try_insert_entry(hash, key.into(), value)?;\n                self.indices[probe] = Pos::new(index, hash);\n                false\n            },\n            // Occupied\n            {\n                append_value(pos, &mut self.entries[pos], &mut self.extra_values, value);\n                true\n            },\n            // Robinhood\n            {\n                self.try_insert_phase_two(key.into(), value, hash, probe, danger)?;\n\n                false\n            }\n        ))\n    }\n\n    #[inline]\n    fn find<K>(&self, key: &K) -> Option<(usize, usize)>\n    where\n        K: Hash + Into<HeaderName> + ?Sized,\n        HeaderName: PartialEq<K>,\n    {\n        if self.entries.is_empty() {\n            return None;\n        }\n\n        let hash = hash_elem_using(&self.danger, key);\n        let mask = self.mask;\n        let mut probe = desired_pos(mask, hash);\n        let mut dist = 0;\n\n        probe_loop!(probe < self.indices.len(), {\n            if let Some((i, entry_hash)) = self.indices[probe].resolve() {\n                if dist > probe_distance(mask, entry_hash, probe) {\n                    // give up when probe distance is too long\n                    return None;\n                } else if entry_hash == hash && self.entries[i].key == *key {\n                    return Some((probe, i));\n                }\n            } else {\n                return None;\n            }\n\n            dist += 1;\n        });\n    }\n\n    /// phase 2 is post-insert where we forward-shift `Pos` in the indices.\n    #[inline]\n    fn try_insert_phase_two(\n        &mut self,\n        key: HeaderName,\n        value: T,\n        hash: HashValue,\n        probe: usize,\n        danger: bool,\n    ) -> Result<usize, MaxSizeReached> {\n        // Push the value and get the index\n        let index = self.entries.len();\n        self.try_insert_entry(hash, key, value)?;\n\n        let num_displaced = do_insert_phase_two(&mut self.indices, probe, Pos::new(index, hash));\n\n        if danger || num_displaced >= DISPLACEMENT_THRESHOLD {\n            // Increase danger level\n            self.danger.set_yellow();\n        }\n\n        Ok(index)\n    }\n\n    /// Removes a key from the map, returning the value associated with the key.\n    ///\n    /// Returns `None` if the map does not contain the key. If there are\n    /// multiple values associated with the key, then the first one is returned.\n    /// See `remove_entry_mult` on `OccupiedEntry` for an API that yields all\n    /// values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "hello.world".parse().unwrap());\n    ///\n    /// let prev = map.remove(HOST).unwrap();\n    /// assert_eq!("hello.world", prev);\n    ///\n    /// assert!(map.remove(HOST).is_none());\n    /// ```\n    pub fn remove<K>(&mut self, key: K) -> Option<T>\n    where\n        K: AsHeaderName,\n    {\n        match key.find(self) {\n            Some((probe, idx)) => {\n                if let Some(links) = self.entries[idx].links {\n                    self.remove_all_extra_values(links.next);\n                }\n\n                let entry = self.remove_found(probe, idx);\n\n                Some(entry.value)\n            }\n            None => None,\n        }\n    }\n\n    /// Remove an entry from the map.\n    ///\n    /// Warning: To avoid inconsistent state, extra values _must_ be removed\n    /// for the `found` index (via `remove_all_extra_values` or similar)\n    /// _before_ this method is called.\n    #[inline]\n    fn remove_found(&mut self, probe: usize, found: usize) -> Bucket<T> {\n        // index `probe` and entry `found` is to be removed\n        // use swap_remove, but then we need to update the index that points\n        // to the other entry that has to move\n        self.indices[probe] = Pos::none();\n        let entry = self.entries.swap_remove(found);\n\n        // correct index that points to the entry that had to swap places\n        if let Some(entry) = self.entries.get(found) {\n            // was not last element\n            // examine new element in `found` and find it in indices\n            let mut probe = desired_pos(self.mask, entry.hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((i, _)) = self.indices[probe].resolve() {\n                    if i >= self.entries.len() {\n                        // found it\n                        self.indices[probe] = Pos::new(found, entry.hash);\n                        break;\n                    }\n                }\n            });\n\n            // Update links\n            if let Some(links) = entry.links {\n                self.extra_values[links.next].prev = Link::Entry(found);\n                self.extra_values[links.tail].next = Link::Entry(found);\n            }\n        }\n\n        // backward shift deletion in self.indices\n        // after probe, shift all non-ideally placed indices backward\n        if !self.entries.is_empty() {\n            let mut last_probe = probe;\n            let mut probe = probe + 1;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    if probe_distance(self.mask, entry_hash, probe) > 0 {\n                        self.indices[last_probe] = self.indices[probe];\n                        self.indices[probe] = Pos::none();\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n\n                last_probe = probe;\n            });\n        }\n\n        entry\n    }\n\n    /// Removes the `ExtraValue` at the given index.\n    #[inline]\n    fn remove_extra_value(&mut self, idx: usize) -> ExtraValue<T> {\n        let raw_links = self.raw_links();\n        remove_extra_value(raw_links, &mut self.extra_values, idx)\n    }\n\n    fn remove_all_extra_values(&mut self, mut head: usize) {\n        loop {\n            let extra = self.remove_extra_value(head);\n\n            if let Link::Extra(idx) = extra.next {\n                head = idx;\n            } else {\n                break;\n            }\n        }\n    }\n\n    #[inline]\n    fn try_insert_entry(\n        &mut self,\n        hash: HashValue,\n        key: HeaderName,\n        value: T,\n    ) -> Result<(), MaxSizeReached> {\n        if self.entries.len() >= MAX_SIZE {\n            return Err(MaxSizeReached::new());\n        }\n\n        self.entries.push(Bucket {\n            hash,\n            key,\n            value,\n            links: None,\n        });\n\n        Ok(())\n    }\n\n    fn rebuild(&mut self) {\n        // Loop over all entries and re-insert them into the map\n        \'outer: for (index, entry) in self.entries.iter_mut().enumerate() {\n            let hash = hash_elem_using(&self.danger, &entry.key);\n            let mut probe = desired_pos(self.mask, hash);\n            let mut dist = 0;\n\n            // Update the entry\'s hash code\n            entry.hash = hash;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    // if existing element probed less than us, swap\n                    let their_dist = probe_distance(self.mask, entry_hash, probe);\n\n                    if their_dist < dist {\n                        // Robinhood\n                        break;\n                    }\n                } else {\n                    // Vacant slot\n                    self.indices[probe] = Pos::new(index, hash);\n                    continue \'outer;\n                }\n\n                dist += 1;\n            });\n\n            do_insert_phase_two(&mut self.indices, probe, Pos::new(index, hash));\n        }\n    }\n\n    fn reinsert_entry_in_order(&mut self, pos: Pos) {\n        if let Some((_, entry_hash)) = pos.resolve() {\n            // Find first empty bucket and insert there\n            let mut probe = desired_pos(self.mask, entry_hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if self.indices[probe].resolve().is_none() {\n                    // empty bucket, insert here\n                    self.indices[probe] = pos;\n                    return;\n                }\n            });\n        }\n    }\n\n    fn try_reserve_one(&mut self) -> Result<(), MaxSizeReached> {\n        let len = self.entries.len();\n\n        if self.danger.is_yellow() {\n            let load_factor = self.entries.len() as f32 / self.indices.len() as f32;\n\n            if load_factor >= LOAD_FACTOR_THRESHOLD {\n                // Transition back to green danger level\n                self.danger.set_green();\n\n                // Double the capacity\n                let new_cap = self.indices.len() * 2;\n\n                // Grow the capacity\n                self.try_grow(new_cap)?;\n            } else {\n                self.danger.set_red();\n\n                // Rebuild hash table\n                for index in self.indices.iter_mut() {\n                    *index = Pos::none();\n                }\n\n                self.rebuild();\n            }\n        } else if len == self.capacity() {\n            if len == 0 {\n                let new_raw_cap = 8;\n                self.mask = 8 - 1;\n                self.indices = vec![Pos::none(); new_raw_cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(new_raw_cap));\n            } else {\n                let raw_cap = self.indices.len();\n                self.try_grow(raw_cap << 1)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    #[inline]\n    fn try_grow(&mut self, new_raw_cap: usize) -> Result<(), MaxSizeReached> {\n        if new_raw_cap > MAX_SIZE {\n            return Err(MaxSizeReached::new());\n        }\n\n        // find first ideally placed element -- start of cluster\n        let mut first_ideal = 0;\n\n        for (i, pos) in self.indices.iter().enumerate() {\n            if let Some((_, entry_hash)) = pos.resolve() {\n                if 0 == probe_distance(self.mask, entry_hash, i) {\n                    first_ideal = i;\n                    break;\n                }\n            }\n        }\n\n        // visit the entries in an order where we can simply reinsert them\n        // into self.indices without any bucket stealing.\n        let old_indices = mem::replace(\n            &mut self.indices,\n            vec![Pos::none(); new_raw_cap].into_boxed_slice(),\n        );\n        self.mask = new_raw_cap.wrapping_sub(1) as Size;\n\n        for &pos in &old_indices[first_ideal..] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        for &pos in &old_indices[..first_ideal] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        // Reserve additional entry slots\n        let more = self.capacity() - self.entries.len();\n        self.entries.reserve_exact(more);\n        Ok(())\n    }\n\n    #[inline]\n    fn raw_links(&mut self) -> RawLinks<T> {\n        RawLinks(&mut self.entries[..] as *mut _)\n    }\n}', 'impl<T> IntoIterator for HeaderMap<T> {\n    type Item = (Option<HeaderName>, T);\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, one that moves keys and values\n    /// out of the map in arbitrary order. The map cannot be used after calling\n    /// this.\n    ///\n    /// For each yielded item that has `None` provided for the `HeaderName`,\n    /// then the associated header name is the same as that of the previously\n    /// yielded item. The first yielded item will have `HeaderName` set.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage.\n    ///\n    /// ```\n    /// # use http::header;\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(header::CONTENT_LENGTH, "123".parse().unwrap());\n    /// map.insert(header::CONTENT_TYPE, "json".parse().unwrap());\n    ///\n    /// let mut iter = map.into_iter();\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), "123".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), "json".parse().unwrap())));\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// Multiple values per key.\n    ///\n    /// ```\n    /// # use http::header;\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.append(header::CONTENT_LENGTH, "123".parse().unwrap());\n    /// map.append(header::CONTENT_LENGTH, "456".parse().unwrap());\n    ///\n    /// map.append(header::CONTENT_TYPE, "json".parse().unwrap());\n    /// map.append(header::CONTENT_TYPE, "html".parse().unwrap());\n    /// map.append(header::CONTENT_TYPE, "xml".parse().unwrap());\n    ///\n    /// let mut iter = map.into_iter();\n    ///\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), "123".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((None, "456".parse().unwrap())));\n    ///\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), "json".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((None, "html".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((None, "xml".parse().unwrap())));\n    /// assert!(iter.next().is_none());\n    /// ```\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter {\n            next: None,\n            entries: self.entries.into_iter(),\n            extra_values: self.extra_values,\n        }\n    }\n}'], 'header::map::IntoIter': ['Debug', 'impl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        // Ensure the iterator is consumed\n        for _ in self.by_ref() {}\n\n        // All the values have already been yielded out.\n        unsafe {\n            self.extra_values.set_len(0);\n        }\n    }\n}', 'impl<T> FusedIterator for IntoIter<T> {}', 'impl<T> Iterator for IntoIter<T> {\n    type Item = (Option<HeaderName>, T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(next) = self.next {\n            self.next = match self.extra_values[next].next {\n                Link::Entry(_) => None,\n                Link::Extra(v) => Some(v),\n            };\n\n            let value = unsafe { ptr::read(&self.extra_values[next].value) };\n\n            return Some((None, value));\n        }\n\n        if let Some(bucket) = self.entries.next() {\n            self.next = bucket.links.map(|l| l.next);\n            let name = Some(bucket.key);\n            let value = bucket.value;\n\n            return Some((name, value));\n        }\n\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, _) = self.entries.size_hint();\n        // There could be more than just the entries upper, as there\n        // could be items in the `extra_values`. We could guess, saying\n        // `upper + extra_values.len()`, but that could overestimate by a lot.\n        (lower, None)\n    }\n}'], 'header::map::Iter': ['Debug', "impl<'a, T> FusedIterator for Iter<'a, T> {}", "impl<'a, T> Iterator for Iter<'a, T> {\n    type Item = (&'a HeaderName, &'a T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        if self.cursor.is_none() {\n            if (self.entry + 1) >= self.map.entries.len() {\n                return None;\n            }\n\n            self.entry += 1;\n            self.cursor = Some(Cursor::Head);\n        }\n\n        let entry = &self.map.entries[self.entry];\n\n        match self.cursor.unwrap() {\n            Head => {\n                self.cursor = entry.links.map(|l| Values(l.next));\n                Some((&entry.key, &entry.value))\n            }\n            Values(idx) => {\n                let extra = &self.map.extra_values[idx];\n\n                match extra.next {\n                    Link::Entry(_) => self.cursor = None,\n                    Link::Extra(i) => self.cursor = Some(Values(i)),\n                }\n\n                Some((&entry.key, &extra.value))\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let map = self.map;\n        debug_assert!(map.entries.len() >= self.entry);\n\n        let lower = map.entries.len() - self.entry;\n        // We could pessimistically guess at the upper bound, saying\n        // that its lower + map.extra_values.len(). That could be\n        // way over though, such as if we're near the end, and have\n        // already gone through several extra values...\n        (lower, None)\n    }\n}", "unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}", "unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}"], 'header::map::IterMut': ['Debug', "impl<'a, T> FusedIterator for IterMut<'a, T> {}", "impl<'a, T> IterMut<'a, T> {\n    fn next_unsafe(&mut self) -> Option<(&'a HeaderName, *mut T)> {\n        use self::Cursor::*;\n\n        if self.cursor.is_none() {\n            if (self.entry + 1) >= unsafe { &*self.map }.entries.len() {\n                return None;\n            }\n\n            self.entry += 1;\n            self.cursor = Some(Cursor::Head);\n        }\n\n        let entry = unsafe { &mut (*self.map).entries[self.entry] };\n\n        match self.cursor.unwrap() {\n            Head => {\n                self.cursor = entry.links.map(|l| Values(l.next));\n                Some((&entry.key, &mut entry.value as *mut _))\n            }\n            Values(idx) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                match extra.next {\n                    Link::Entry(_) => self.cursor = None,\n                    Link::Extra(i) => self.cursor = Some(Values(i)),\n                }\n\n                Some((&entry.key, &mut extra.value as *mut _))\n            }\n        }\n    }\n}", "impl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = (&'a HeaderName, &'a mut T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next_unsafe()\n            .map(|(key, ptr)| (key, unsafe { &mut *ptr }))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let map = unsafe { &*self.map };\n        debug_assert!(map.entries.len() >= self.entry);\n\n        let lower = map.entries.len() - self.entry;\n        // We could pessimistically guess at the upper bound, saying\n        // that its lower + map.extra_values.len(). That could be\n        // way over though, such as if we're near the end, and have\n        // already gone through several extra values...\n        (lower, None)\n    }\n}", "unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}", "unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}"], 'header::map::Keys': ['Debug', "impl<'a, T> ExactSizeIterator for Keys<'a, T> {}", "impl<'a, T> FusedIterator for Keys<'a, T> {}", "impl<'a, T> Iterator for Keys<'a, T> {\n    type Item = &'a HeaderName;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|b| &b.key)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        self.inner.nth(n).map(|b| &b.key)\n    }\n\n    fn count(self) -> usize {\n        self.inner.count()\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        self.inner.last().map(|b| &b.key)\n    }\n}"], 'header::map::Link': ['Clone', 'Copy', 'Debug', 'Eq', 'PartialEq'], 'header::map::Links': ['Clone', 'Copy', 'Debug'], 'header::map::MaxSizeReached': ['impl MaxSizeReached {\n    fn new() -> Self {\n        MaxSizeReached { _priv: () }\n    }\n}', 'impl fmt::Debug for MaxSizeReached {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct("MaxSizeReached")\n            // skip _priv noise\n            .finish()\n    }\n}', 'impl fmt::Display for MaxSizeReached {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.write_str("max size reached")\n    }\n}', 'impl std::error::Error for MaxSizeReached {}'], 'header::map::OccupiedEntry': ['Debug', "impl<'a, T> IntoIterator for OccupiedEntry<'a, T> {\n    type Item = &'a mut T;\n    type IntoIter = ValueIterMut<'a, T>;\n\n    fn into_iter(self) -> ValueIterMut<'a, T> {\n        self.map.value_iter_mut(self.index)\n    }\n}", 'impl<\'a, T> OccupiedEntry<\'a, T> {\n    /// Returns a reference to the entry\'s key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "world".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry("host") {\n    ///     assert_eq!("host", e.key());\n    /// }\n    /// ```\n    pub fn key(&self) -> &HeaderName {\n        &self.map.entries[self.index].key\n    }\n\n    /// Get a reference to the first value in the entry.\n    ///\n    /// Values are stored in insertion order.\n    ///\n    /// # Panics\n    ///\n    /// `get` panics if there are no values associated with the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "hello.world".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry("host") {\n    ///     assert_eq!(e.get(), &"hello.world");\n    ///\n    ///     e.append("hello.earth".parse().unwrap());\n    ///\n    ///     assert_eq!(e.get(), &"hello.world");\n    /// }\n    /// ```\n    pub fn get(&self) -> &T {\n        &self.map.entries[self.index].value\n    }\n\n    /// Get a mutable reference to the first value in the entry.\n    ///\n    /// Values are stored in insertion order.\n    ///\n    /// # Panics\n    ///\n    /// `get_mut` panics if there are no values associated with the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, "hello.world".to_string());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry("host") {\n    ///     e.get_mut().push_str("-2");\n    ///     assert_eq!(e.get(), &"hello.world-2");\n    /// }\n    /// ```\n    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.map.entries[self.index].value\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the **first**\n    /// value.\n    ///\n    /// The lifetime of the returned reference is bound to the original map.\n    ///\n    /// # Panics\n    ///\n    /// `into_mut` panics if there are no values associated with the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, "hello.world".to_string());\n    /// map.append(HOST, "hello.earth".to_string());\n    ///\n    /// if let Entry::Occupied(e) = map.entry("host") {\n    ///     e.into_mut().push_str("-2");\n    /// }\n    ///\n    /// assert_eq!("hello.world-2", map["host"]);\n    /// ```\n    pub fn into_mut(self) -> &\'a mut T {\n        &mut self.map.entries[self.index].value\n    }\n\n    /// Sets the value of the entry.\n    ///\n    /// All previous values associated with the entry are removed and the first\n    /// one is returned. See `insert_mult` for an API that returns all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "hello.world".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry("host") {\n    ///     let mut prev = e.insert("earth".parse().unwrap());\n    ///     assert_eq!("hello.world", prev);\n    /// }\n    ///\n    /// assert_eq!("earth", map["host"]);\n    /// ```\n    pub fn insert(&mut self, value: T) -> T {\n        self.map.insert_occupied(self.index, value)\n    }\n\n    /// Sets the value of the entry.\n    ///\n    /// This function does the same as `insert` except it returns an iterator\n    /// that yields all values previously associated with the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "world".parse().unwrap());\n    /// map.append(HOST, "world2".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry("host") {\n    ///     let mut prev = e.insert_mult("earth".parse().unwrap());\n    ///     assert_eq!("world", prev.next().unwrap());\n    ///     assert_eq!("world2", prev.next().unwrap());\n    ///     assert!(prev.next().is_none());\n    /// }\n    ///\n    /// assert_eq!("earth", map["host"]);\n    /// ```\n    pub fn insert_mult(&mut self, value: T) -> ValueDrain<\'_, T> {\n        self.map.insert_occupied_mult(self.index, value)\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The new value is appended to the end of the entry\'s value list. All\n    /// previous values associated with the entry are retained.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "world".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry("host") {\n    ///     e.append("earth".parse().unwrap());\n    /// }\n    ///\n    /// let values = map.get_all("host");\n    /// let mut i = values.iter();\n    /// assert_eq!("world", *i.next().unwrap());\n    /// assert_eq!("earth", *i.next().unwrap());\n    /// ```\n    pub fn append(&mut self, value: T) {\n        let idx = self.index;\n        let entry = &mut self.map.entries[idx];\n        append_value(idx, entry, &mut self.map.extra_values, value);\n    }\n\n    /// Remove the entry from the map.\n    ///\n    /// All values associated with the entry are removed and the first one is\n    /// returned. See `remove_entry_mult` for an API that returns all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "world".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry("host") {\n    ///     let mut prev = e.remove();\n    ///     assert_eq!("world", prev);\n    /// }\n    ///\n    /// assert!(!map.contains_key("host"));\n    /// ```\n    pub fn remove(self) -> T {\n        self.remove_entry().1\n    }\n\n    /// Remove the entry from the map.\n    ///\n    /// The key and all values associated with the entry are removed and the\n    /// first one is returned. See `remove_entry_mult` for an API that returns\n    /// all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "world".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry("host") {\n    ///     let (key, mut prev) = e.remove_entry();\n    ///     assert_eq!("host", key.as_str());\n    ///     assert_eq!("world", prev);\n    /// }\n    ///\n    /// assert!(!map.contains_key("host"));\n    /// ```\n    pub fn remove_entry(self) -> (HeaderName, T) {\n        if let Some(links) = self.map.entries[self.index].links {\n            self.map.remove_all_extra_values(links.next);\n        }\n\n        let entry = self.map.remove_found(self.probe, self.index);\n\n        (entry.key, entry.value)\n    }\n\n    /// Remove the entry from the map.\n    ///\n    /// The key and all values associated with the entry are removed and\n    /// returned.\n    pub fn remove_entry_mult(self) -> (HeaderName, ValueDrain<\'a, T>) {\n        let raw_links = self.map.raw_links();\n        let extra_values = &mut self.map.extra_values;\n\n        let next = self.map.entries[self.index]\n            .links\n            .map(|l| drain_all_extra_values(raw_links, extra_values, l.next).into_iter());\n\n        let entry = self.map.remove_found(self.probe, self.index);\n\n        let drain = ValueDrain {\n            first: Some(entry.value),\n            next,\n            lt: PhantomData,\n        };\n        (entry.key, drain)\n    }\n\n    /// Returns an iterator visiting all values associated with the entry.\n    ///\n    /// Values are iterated in insertion order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, "world".parse().unwrap());\n    /// map.append(HOST, "earth".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry("host") {\n    ///     let mut iter = e.iter();\n    ///     assert_eq!(&"world", iter.next().unwrap());\n    ///     assert_eq!(&"earth", iter.next().unwrap());\n    ///     assert!(iter.next().is_none());\n    /// }\n    /// ```\n    pub fn iter(&self) -> ValueIter<\'_, T> {\n        self.map.value_iter(Some(self.index))\n    }\n\n    /// Returns an iterator mutably visiting all values associated with the\n    /// entry.\n    ///\n    /// Values are iterated in insertion order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, "world".to_string());\n    /// map.append(HOST, "earth".to_string());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry("host") {\n    ///     for e in e.iter_mut() {\n    ///         e.push_str("-boop");\n    ///     }\n    /// }\n    ///\n    /// let mut values = map.get_all("host");\n    /// let mut i = values.iter();\n    /// assert_eq!(&"world-boop", i.next().unwrap());\n    /// assert_eq!(&"earth-boop", i.next().unwrap());\n    /// ```\n    pub fn iter_mut(&mut self) -> ValueIterMut<\'_, T> {\n        self.map.value_iter_mut(self.index)\n    }\n}'], 'header::map::Pos': ['Clone', 'Copy', 'impl Pos {\n    #[inline]\n    fn new(index: usize, hash: HashValue) -> Self {\n        debug_assert!(index < MAX_SIZE);\n        Pos {\n            index: index as Size,\n            hash,\n        }\n    }\n\n    #[inline]\n    fn none() -> Self {\n        Pos {\n            index: !0,\n            hash: HashValue(0),\n        }\n    }\n\n    #[inline]\n    fn is_some(&self) -> bool {\n        !self.is_none()\n    }\n\n    #[inline]\n    fn is_none(&self) -> bool {\n        self.index == !0\n    }\n\n    #[inline]\n    fn resolve(&self) -> Option<(usize, HashValue)> {\n        if self.is_some() {\n            Some((self.index as usize, self.hash))\n        } else {\n            None\n        }\n    }\n}'], 'header::map::RawLinks': ['Debug', 'impl<T> Clone for RawLinks<T> {\n    fn clone(&self) -> RawLinks<T> {\n        *self\n    }\n}', 'impl<T> Copy for RawLinks<T> {}', 'impl<T> ops::Index<usize> for RawLinks<T> {\n    type Output = Option<Links>;\n\n    fn index(&self, idx: usize) -> &Self::Output {\n        unsafe { &(*self.0)[idx].links }\n    }\n}', 'impl<T> ops::IndexMut<usize> for RawLinks<T> {\n    fn index_mut(&mut self, idx: usize) -> &mut Self::Output {\n        unsafe { &mut (*self.0)[idx].links }\n    }\n}'], 'header::map::VacantEntry': ['Debug', 'impl<\'a, T> VacantEntry<\'a, T> {\n    /// Returns a reference to the entry\'s key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(map.entry("x-hello").key().as_str(), "x-hello");\n    /// ```\n    pub fn key(&self) -> &HeaderName {\n        &self.key\n    }\n\n    /// Take ownership of the key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry("x-hello") {\n    ///     assert_eq!(v.into_key().as_str(), "x-hello");\n    /// }\n    /// ```\n    pub fn into_key(self) -> HeaderName {\n        self.key\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The value will be associated with this entry\'s key. A mutable reference\n    /// to the inserted value will be returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry("x-hello") {\n    ///     v.insert("world".parse().unwrap());\n    /// }\n    ///\n    /// assert_eq!(map["x-hello"], "world");\n    /// ```\n    pub fn insert(self, value: T) -> &\'a mut T {\n        self.try_insert(value).expect("size overflows MAX_SIZE")\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The value will be associated with this entry\'s key. A mutable reference\n    /// to the inserted value will be returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry("x-hello") {\n    ///     v.insert("world".parse().unwrap());\n    /// }\n    ///\n    /// assert_eq!(map["x-hello"], "world");\n    /// ```\n    pub fn try_insert(self, value: T) -> Result<&\'a mut T, MaxSizeReached> {\n        // Ensure that there is space in the map\n        let index =\n            self.map\n                .try_insert_phase_two(self.key, value, self.hash, self.probe, self.danger)?;\n\n        Ok(&mut self.map.entries[index].value)\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The value will be associated with this entry\'s key. The new\n    /// `OccupiedEntry` is returned, allowing for further manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.try_entry("x-hello").unwrap() {\n    ///     let mut e = v.try_insert_entry("world".parse().unwrap()).unwrap();\n    ///     e.insert("world2".parse().unwrap());\n    /// }\n    ///\n    /// assert_eq!(map["x-hello"], "world2");\n    /// ```\n    pub fn insert_entry(self, value: T) -> OccupiedEntry<\'a, T> {\n        self.try_insert_entry(value)\n            .expect("size overflows MAX_SIZE")\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The value will be associated with this entry\'s key. The new\n    /// `OccupiedEntry` is returned, allowing for further manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.try_entry("x-hello").unwrap() {\n    ///     let mut e = v.try_insert_entry("world".parse().unwrap()).unwrap();\n    ///     e.insert("world2".parse().unwrap());\n    /// }\n    ///\n    /// assert_eq!(map["x-hello"], "world2");\n    /// ```\n    pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<\'a, T>, MaxSizeReached> {\n        // Ensure that there is space in the map\n        let index =\n            self.map\n                .try_insert_phase_two(self.key, value, self.hash, self.probe, self.danger)?;\n\n        Ok(OccupiedEntry {\n            map: self.map,\n            index,\n            probe: self.probe,\n        })\n    }\n}'], 'header::map::ValueDrain': ['Debug', "impl<'a, T> Drop for ValueDrain<'a, T> {\n    fn drop(&mut self) {\n        for _ in self.by_ref() {}\n    }\n}", "impl<'a, T> FusedIterator for ValueDrain<'a, T> {}", "impl<'a, T> Iterator for ValueDrain<'a, T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        if self.first.is_some() {\n            self.first.take()\n        } else if let Some(ref mut extras) = self.next {\n            extras.next()\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match (&self.first, &self.next) {\n            // Exactly 1\n            (&Some(_), &None) => (1, Some(1)),\n            // 1 + extras\n            (&Some(_), Some(extras)) => {\n                let (l, u) = extras.size_hint();\n                (l + 1, u.map(|u| u + 1))\n            }\n            // Extras only\n            (&None, Some(extras)) => extras.size_hint(),\n            // No more\n            (&None, &None) => (0, Some(0)),\n        }\n    }\n}", "unsafe impl<'a, T: Send> Send for ValueDrain<'a, T> {}", "unsafe impl<'a, T: Sync> Sync for ValueDrain<'a, T> {}"], 'header::map::ValueIter': ['Debug', "impl<'a, T: 'a> DoubleEndedIterator for ValueIter<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&self.map.entries[self.index].value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }\n}", "impl<'a, T: 'a> Iterator for ValueIter<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        match self.front {\n            Some(Head) => {\n                let entry = &self.map.entries[self.index];\n\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match (self.front, self.back) {\n            // Exactly 1 value...\n            (Some(Cursor::Head), Some(Cursor::Head)) => (1, Some(1)),\n            // At least 1...\n            (Some(_), _) => (1, None),\n            // No more values...\n            (None, _) => (0, Some(0)),\n        }\n    }\n}", "impl<'a, T> FusedIterator for ValueIter<'a, T> {}"], 'header::map::ValueIterMut': ['Debug', "impl<'a, T: 'a> DoubleEndedIterator for ValueIterMut<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }\n}", "impl<'a, T: 'a> Iterator for ValueIterMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.front {\n            Some(Head) => {\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }\n}", "impl<'a, T> FusedIterator for ValueIterMut<'a, T> {}", "unsafe impl<'a, T: Send> Send for ValueIterMut<'a, T> {}", "unsafe impl<'a, T: Sync> Sync for ValueIterMut<'a, T> {}"], 'header::map::Values': ['Debug', "impl<'a, T> FusedIterator for Values<'a, T> {}", "impl<'a, T> Iterator for Values<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|(_, v)| v)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}"], 'header::map::ValuesMut': ['Debug', "impl<'a, T> FusedIterator for ValuesMut<'a, T> {}", "impl<'a, T> Iterator for ValuesMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|(_, v)| v)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}"], 'header::map::as_header_name::TryEntryError': ['impl From<InvalidHeaderName> for TryEntryError {\n        fn from(e: InvalidHeaderName) -> TryEntryError {\n            TryEntryError::InvalidHeaderName(e)\n        }\n    }', 'impl From<MaxSizeReached> for TryEntryError {\n        fn from(e: MaxSizeReached) -> TryEntryError {\n            TryEntryError::MaxSizeReached(e)\n        }\n    }'], 'header::name::Custom': ['Clone', 'Debug', 'Eq', 'PartialEq', 'impl Hash for Custom {\n    #[inline]\n    fn hash<H: Hasher>(&self, hasher: &mut H) {\n        hasher.write(self.0.as_bytes())\n    }\n}'], 'header::name::HdrName': ['Debug', 'Hash', "impl<'a> From<StandardHeader> for HdrName<'a> {\n    fn from(hdr: StandardHeader) -> HdrName<'a> {\n        HdrName {\n            inner: Repr::Standard(hdr),\n        }\n    }\n}", 'impl<\'a> HdrName<\'a> {\n    // Precondition: if lower then buf is valid UTF-8\n    fn custom(buf: &\'a [u8], lower: bool) -> HdrName<\'a> {\n        HdrName {\n            // Invariant (on MaybeLower): follows from the precondition\n            inner: Repr::Custom(MaybeLower { buf, lower }),\n        }\n    }\n\n    pub fn from_bytes<F, U>(hdr: &[u8], f: F) -> Result<U, InvalidHeaderName>\n    where\n        F: FnOnce(HdrName<\'_>) -> U,\n    {\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n        let hdr = parse_hdr(hdr, &mut buf, &HEADER_CHARS)?;\n        Ok(f(hdr))\n    }\n\n    pub fn from_static<F, U>(hdr: &\'static str, f: F) -> U\n    where\n        F: FnOnce(HdrName<\'_>) -> U,\n    {\n        let mut buf = uninit_u8_array();\n        let hdr =\n            // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n            parse_hdr(hdr.as_bytes(), &mut buf, &HEADER_CHARS).expect("static str is invalid name");\n        f(hdr)\n    }\n}'], 'header::name::HeaderName': ['Clone', 'Eq', 'Hash', 'PartialEq', 'impl AsHeaderName for HeaderName {}', 'impl AsRef<[u8]> for HeaderName {\n    fn as_ref(&self) -> &[u8] {\n        self.as_str().as_bytes()\n    }\n}', 'impl AsRef<str> for HeaderName {\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}', 'impl Borrow<str> for HeaderName {\n    fn borrow(&self) -> &str {\n        self.as_str()\n    }\n}', 'impl From<Custom> for HeaderName {\n    fn from(src: Custom) -> HeaderName {\n        HeaderName {\n            inner: Repr::Custom(src),\n        }\n    }\n}', 'impl From<StandardHeader> for HeaderName {\n    fn from(src: StandardHeader) -> HeaderName {\n        HeaderName {\n            inner: Repr::Standard(src),\n        }\n    }\n}', 'impl FromStr for HeaderName {\n    type Err = InvalidHeaderName;\n\n    fn from_str(s: &str) -> Result<HeaderName, InvalidHeaderName> {\n        HeaderName::from_bytes(s.as_bytes()).map_err(|_| InvalidHeaderName { _priv: () })\n    }\n}', 'impl HeaderName {\n    /// Converts a slice of bytes to an HTTP header name.\n    ///\n    /// This function normalizes the input.\n    pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n        match parse_hdr(src, &mut buf, &HEADER_CHARS)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                use bytes::BufMut;\n                let mut dst = BytesMut::with_capacity(buf.len());\n\n                for b in buf.iter() {\n                    // HEADER_CHARS maps all bytes to valid single-byte UTF-8\n                    let b = HEADER_CHARS[*b as usize];\n\n                    if b == 0 {\n                        return Err(InvalidHeaderName::new());\n                    }\n\n                    dst.put_u8(b);\n                }\n\n                // Safety: the loop above maps all bytes in buf to valid single byte\n                // UTF-8 before copying them into dst. This means that dst (and hence\n                // dst.freeze()) is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                Ok(Custom(val).into())\n            }\n        }\n    }\n\n    /// Converts a slice of bytes to an HTTP header name.\n    ///\n    /// This function expects the input to only contain lowercase characters.\n    /// This is useful when decoding HTTP/2.0 or HTTP/3.0 headers. Both\n    /// require that all headers be represented in lower case.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    ///\n    /// // Parsing a lower case header\n    /// let hdr = HeaderName::from_lowercase(b"content-length").unwrap();\n    /// assert_eq!(CONTENT_LENGTH, hdr);\n    ///\n    /// // Parsing a header that contains uppercase characters\n    /// assert!(HeaderName::from_lowercase(b"Content-Length").is_err());\n    /// ```\n    pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS_H2 is a valid table for parse_hdr()\n        match parse_hdr(src, &mut buf, &HEADER_CHARS_H2)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                for &b in buf.iter() {\n                    // HEADER_CHARS_H2 maps all bytes that are not valid single-byte\n                    // UTF-8 to 0 so this check returns an error for invalid UTF-8.\n                    if HEADER_CHARS_H2[b as usize] == 0 {\n                        return Err(InvalidHeaderName::new());\n                    }\n                }\n\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the loop above checks that each byte of buf (either\n                // version) is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n        }\n    }\n\n    /// Converts a static string to a HTTP header name.\n    ///\n    /// This function requires the static string to only contain lowercase\n    /// characters, numerals and symbols, as per the HTTP/2.0 specification\n    /// and header names internal representation within this library.\n    ///\n    /// # Panics\n    ///\n    /// This function panics when the static string is a invalid header.\n    ///\n    /// Until [Allow panicking in constants](https://github.com/rust-lang/rfcs/pull/2345)\n    /// makes its way into stable, the panic message at compile-time is\n    /// going to look cryptic, but should at least point at your header value:\n    ///\n    /// ```text\n    /// error: any use of this value will cause an error\n    ///     --> http/src/header/name.rs:1241:13\n    ///      |\n    /// 1241 |             ([] as [u8; 0])[0]; // Invalid header name\n    ///      |             ^^^^^^^^^^^^^^^^^^\n    ///      |             |\n    ///      |             index out of bounds: the length is 0 but the index is 0\n    ///      |             inside `http::HeaderName::from_static` at http/src/header/name.rs:1241:13\n    ///      |             inside `INVALID_NAME` at src/main.rs:3:34\n    ///      |\n    ///     ::: src/main.rs:3:1\n    ///      |\n    /// 3    | const INVALID_NAME: HeaderName = HeaderName::from_static("Capitalized");\n    ///      | ------------------------------------------------------------------------\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// // Parsing a standard header\n    /// let hdr = HeaderName::from_static("content-length");\n    /// assert_eq!(CONTENT_LENGTH, hdr);\n    ///\n    /// // Parsing a custom header\n    /// let CUSTOM_HEADER: &\'static str = "custom-header";\n    ///\n    /// let a = HeaderName::from_lowercase(b"custom-header").unwrap();\n    /// let b = HeaderName::from_static(CUSTOM_HEADER);\n    /// assert_eq!(a, b);\n    /// ```\n    ///\n    /// ```should_panic\n    /// # use http::header::*;\n    /// #\n    /// // Parsing a header that contains invalid symbols(s):\n    /// HeaderName::from_static("content{}{}length"); // This line panics!\n    ///\n    /// // Parsing a header that contains invalid uppercase characters.\n    /// let a = HeaderName::from_static("foobar");\n    /// let b = HeaderName::from_static("FOOBAR"); // This line panics!\n    /// ```\n    #[allow(unconditional_panic)] // required for the panic circumvention\n    pub const fn from_static(src: &\'static str) -> HeaderName {\n        let name_bytes = src.as_bytes();\n        if let Some(standard) = StandardHeader::from_bytes(name_bytes) {\n            return HeaderName {\n                inner: Repr::Standard(standard),\n            };\n        }\n\n        if name_bytes.is_empty() || name_bytes.len() > super::MAX_HEADER_NAME_LEN || {\n            let mut i = 0;\n            loop {\n                if i >= name_bytes.len() {\n                    break false;\n                } else if HEADER_CHARS_H2[name_bytes[i] as usize] == 0 {\n                    break true;\n                }\n                i += 1;\n            }\n        } {\n            // TODO: When msrv is bumped to larger than 1.57, this should be\n            // replaced with `panic!` macro.\n            // https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html#panic-in-const-contexts\n            //\n            // See the panics section of this method\'s document for details.\n            #[allow(clippy::no_effect, clippy::out_of_bounds_indexing)]\n            ([] as [u8; 0])[0]; // Invalid header name\n        }\n\n        HeaderName {\n            inner: Repr::Custom(Custom(ByteStr::from_static(src))),\n        }\n    }\n\n    /// Returns a `str` representation of the header.\n    ///\n    /// The returned string will always be lower case.\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        match self.inner {\n            Repr::Standard(v) => v.as_str(),\n            Repr::Custom(ref v) => &v.0,\n        }\n    }\n\n    pub(super) fn into_bytes(self) -> Bytes {\n        self.inner.into()\n    }\n}', 'impl IntoHeaderName for HeaderName {}', 'impl PartialEq<str> for HeaderName {\n    /// Performs a case-insensitive comparison of the string against the header\n    /// name\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use http::header::CONTENT_LENGTH;\n    ///\n    /// assert_eq!(CONTENT_LENGTH, "content-length");\n    /// assert_eq!(CONTENT_LENGTH, "Content-Length");\n    /// assert_ne!(CONTENT_LENGTH, "content length");\n    /// ```\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        eq_ignore_ascii_case(self.as_ref(), other.as_bytes())\n    }\n}', "impl Sealed for HeaderName {\n        #[inline]\n        fn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError> {\n            Ok(map.try_entry2(self)?)\n        }\n\n        #[inline]\n        fn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)> {\n            map.find(self)\n        }\n\n        fn as_str(&self) -> &str {\n            <HeaderName>::as_str(self)\n        }\n    }", "impl Sealed for HeaderName {\n        #[inline]\n        fn try_insert<T>(\n            self,\n            map: &mut HeaderMap<T>,\n            val: T,\n        ) -> Result<Option<T>, MaxSizeReached> {\n            map.try_insert2(self, val)\n        }\n\n        #[inline]\n        fn try_append<T>(self, map: &mut HeaderMap<T>, val: T) -> Result<bool, MaxSizeReached> {\n            map.try_append2(self, val)\n        }\n\n        #[inline]\n        fn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, MaxSizeReached> {\n            map.try_entry2(self)\n        }\n    }", 'impl TryFrom<String> for HeaderName {\n    type Error = InvalidHeaderName;\n\n    #[inline]\n    fn try_from(s: String) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}', 'impl TryFrom<Vec<u8>> for HeaderName {\n    type Error = InvalidHeaderName;\n\n    #[inline]\n    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {\n        Self::from_bytes(&vec)\n    }\n}', "impl fmt::Debug for HeaderName {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.as_str(), fmt)\n    }\n}", "impl fmt::Display for HeaderName {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.as_str(), fmt)\n    }\n}", "impl<'a> From<&'a HeaderName> for HeaderName {\n    fn from(src: &'a HeaderName) -> HeaderName {\n        src.clone()\n    }\n}", "impl<'a> From<HdrName<'a>> for HeaderName {\n    fn from(src: HdrName<'a>) -> HeaderName {\n        match src.inner {\n            Repr::Standard(s) => HeaderName {\n                inner: Repr::Standard(s),\n            },\n            Repr::Custom(maybe_lower) => {\n                if maybe_lower.lower {\n                    let buf = Bytes::copy_from_slice(maybe_lower.buf);\n                    // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                    let byte_str = unsafe { ByteStr::from_utf8_unchecked(buf) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(byte_str)),\n                    }\n                } else {\n                    use bytes::BufMut;\n                    let mut dst = BytesMut::with_capacity(maybe_lower.buf.len());\n\n                    for b in maybe_lower.buf.iter() {\n                        // HEADER_CHARS maps each byte to a valid single-byte UTF-8\n                        // codepoint.\n                        dst.put_u8(HEADER_CHARS[*b as usize]);\n                    }\n\n                    // Safety: the loop above maps each byte of maybe_lower.buf to a\n                    // valid single-byte UTF-8 codepoint before copying it into dst.\n                    // dst (and hence dst.freeze()) is thus valid UTF-8.\n                    let buf = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(buf)),\n                    }\n                }\n            }\n        }\n    }\n}", "impl<'a> PartialEq<&'a HeaderName> for HeaderName {\n    #[inline]\n    fn eq(&self, other: &&'a HeaderName) -> bool {\n        *self == **other\n    }\n}", "impl<'a> PartialEq<&'a str> for HeaderName {\n    /// Performs a case-insensitive comparison of the string against the header\n    /// name\n    #[inline]\n    fn eq(&self, other: &&'a str) -> bool {\n        *self == **other\n    }\n}", "impl<'a> PartialEq<HdrName<'a>> for HeaderName {\n    #[inline]\n    fn eq(&self, other: &HdrName<'a>) -> bool {\n        match self.inner {\n            Repr::Standard(a) => match other.inner {\n                Repr::Standard(b) => a == b,\n                _ => false,\n            },\n            Repr::Custom(Custom(ref a)) => match other.inner {\n                Repr::Custom(ref b) => {\n                    if b.lower {\n                        a.as_bytes() == b.buf\n                    } else {\n                        eq_ignore_ascii_case(a.as_bytes(), b.buf)\n                    }\n                }\n                _ => false,\n            },\n        }\n    }\n}", "impl<'a> TryFrom<&'a String> for HeaderName {\n    type Error = InvalidHeaderName;\n    #[inline]\n    fn try_from(s: &'a String) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}", "impl<'a> TryFrom<&'a [u8]> for HeaderName {\n    type Error = InvalidHeaderName;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        Self::from_bytes(s)\n    }\n}", "impl<'a> TryFrom<&'a str> for HeaderName {\n    type Error = InvalidHeaderName;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}"], 'header::name::InvalidHeaderName': ['impl Error for InvalidHeaderName {}', 'impl InvalidHeaderName {\n    pub(super) fn new() -> InvalidHeaderName {\n        InvalidHeaderName { _priv: () }\n    }\n}', 'impl fmt::Debug for InvalidHeaderName {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct("InvalidHeaderName")\n            // skip _priv noise\n            .finish()\n    }\n}', 'impl fmt::Display for InvalidHeaderName {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.write_str("invalid HTTP header name")\n    }\n}'], 'header::name::MaybeLower': ['Clone', 'Debug', "impl<'a> Hash for MaybeLower<'a> {\n    #[inline]\n    fn hash<H: Hasher>(&self, hasher: &mut H) {\n        if self.lower {\n            hasher.write(self.buf);\n        } else {\n            for &b in self.buf {\n                hasher.write(&[HEADER_CHARS[b as usize]]);\n            }\n        }\n    }\n}"], 'header::name::Repr': ['Clone', 'Debug', 'Eq', 'Hash', 'PartialEq'], 'header::name::StandardHeader': ['Clone', 'Copy', 'Debug', 'Eq', 'Hash', 'PartialEq', "impl StandardHeader {\n            #[inline]\n            fn as_str(&self) -> &'static str {\n                match *self {\n                    // Safety: test_parse_standard_headers ensures these &[u8]s are &str-safe.\n                    $(\n                    StandardHeader::$konst => unsafe { std::str::from_utf8_unchecked( $name_bytes ) },\n                    )+\n                }\n            }\n\n            const fn from_bytes(name_bytes: &[u8]) -> Option<StandardHeader> {\n                match name_bytes {\n                    $(\n                        $name_bytes => Some(StandardHeader::$konst),\n                    )+\n                    _ => None,\n                }\n            }\n        }"], 'header::value::HeaderValue': ['Clone', 'impl AsRef<[u8]> for HeaderValue {\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n        self.inner.as_ref()\n    }\n}', 'impl Eq for HeaderValue {}', 'impl From<$t> for HeaderValue {\n            fn from(num: $t) -> HeaderValue {\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }\n        }', 'impl From<HeaderName> for HeaderValue {\n    #[inline]\n    fn from(h: HeaderName) -> HeaderValue {\n        HeaderValue {\n            inner: h.into_bytes(),\n            is_sensitive: false,\n        }\n    }\n}', 'impl FromStr for HeaderValue {\n    type Err = InvalidHeaderValue;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<HeaderValue, Self::Err> {\n        HeaderValue::from_str(s)\n    }\n}', 'impl Hash for HeaderValue {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.inner.hash(state);\n    }\n}', 'impl HeaderValue {\n    /// Convert a static string to a `HeaderValue`.\n    ///\n    /// This function will not perform any copying, however the string is\n    /// checked to ensure that no invalid characters are present. Only visible\n    /// ASCII characters (32-127) are permitted.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument contains invalid header value\n    /// characters.\n    ///\n    /// Until [Allow panicking in constants](https://github.com/rust-lang/rfcs/pull/2345)\n    /// makes its way into stable, the panic message at compile-time is\n    /// going to look cryptic, but should at least point at your header value:\n    ///\n    /// ```text\n    /// error: any use of this value will cause an error\n    ///   --> http/src/header/value.rs:67:17\n    ///    |\n    /// 67 |                 ([] as [u8; 0])[0]; // Invalid header value\n    ///    |                 ^^^^^^^^^^^^^^^^^^\n    ///    |                 |\n    ///    |                 index out of bounds: the length is 0 but the index is 0\n    ///    |                 inside `HeaderValue::from_static` at http/src/header/value.rs:67:17\n    ///    |                 inside `INVALID_HEADER` at src/main.rs:73:33\n    ///    |\n    ///   ::: src/main.rs:73:1\n    ///    |\n    /// 73 | const INVALID_HEADER: HeaderValue = HeaderValue::from_static("some value");\n    ///    | ----------------------------------------------------------------------------\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static("hello");\n    /// assert_eq!(val, "hello");\n    /// ```\n    #[inline]\n    #[allow(unconditional_panic)] // required for the panic circumvention\n    pub const fn from_static(src: &\'static str) -> HeaderValue {\n        let bytes = src.as_bytes();\n        let mut i = 0;\n        while i < bytes.len() {\n            if !is_visible_ascii(bytes[i]) {\n                // TODO: When msrv is bumped to larger than 1.57, this should be\n                // replaced with `panic!` macro.\n                // https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html#panic-in-const-contexts\n                //\n                // See the panics section of this method\'s document for details.\n                #[allow(clippy::no_effect, clippy::out_of_bounds_indexing)]\n                ([] as [u8; 0])[0]; // Invalid header value\n            }\n            i += 1;\n        }\n\n        HeaderValue {\n            inner: Bytes::from_static(bytes),\n            is_sensitive: false,\n        }\n    }\n\n    /// Attempt to convert a string to a `HeaderValue`.\n    ///\n    /// If the argument contains invalid header value characters, an error is\n    /// returned. Only visible ASCII characters (32-127) are permitted. Use\n    /// `from_bytes` to create a `HeaderValue` that includes opaque octets\n    /// (128-255).\n    ///\n    /// This function is intended to be replaced in the future by a `TryFrom`\n    /// implementation once the trait is stabilized in std.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_str("hello").unwrap();\n    /// assert_eq!(val, "hello");\n    /// ```\n    ///\n    /// An invalid value\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_str("\\n");\n    /// assert!(val.is_err());\n    /// ```\n    #[inline]\n    #[allow(clippy::should_implement_trait)]\n    pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n        HeaderValue::try_from_generic(src, |s| Bytes::copy_from_slice(s.as_bytes()))\n    }\n\n    /// Converts a HeaderName into a HeaderValue\n    ///\n    /// Since every valid HeaderName is a valid HeaderValue this is done infallibly.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderValue, HeaderName};\n    /// # use http::header::ACCEPT;\n    /// let val = HeaderValue::from_name(ACCEPT);\n    /// assert_eq!(val, HeaderValue::from_bytes(b"accept").unwrap());\n    /// ```\n    #[inline]\n    pub fn from_name(name: HeaderName) -> HeaderValue {\n        name.into()\n    }\n\n    /// Attempt to convert a byte slice to a `HeaderValue`.\n    ///\n    /// If the argument contains invalid header value bytes, an error is\n    /// returned. Only byte values between 32 and 255 (inclusive) are permitted,\n    /// excluding byte 127 (DEL).\n    ///\n    /// This function is intended to be replaced in the future by a `TryFrom`\n    /// implementation once the trait is stabilized in std.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_bytes(b"hello\\xfa").unwrap();\n    /// assert_eq!(val, &b"hello\\xfa"[..]);\n    /// ```\n    ///\n    /// An invalid value\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_bytes(b"\\n");\n    /// assert!(val.is_err());\n    /// ```\n    #[inline]\n    pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n        HeaderValue::try_from_generic(src, Bytes::copy_from_slice)\n    }\n\n    /// Attempt to convert a `Bytes` buffer to a `HeaderValue`.\n    ///\n    /// This will try to prevent a copy if the type passed is the type used\n    /// internally, and will copy the data if it is not.\n    pub fn from_maybe_shared<T>(src: T) -> Result<HeaderValue, InvalidHeaderValue>\n    where\n        T: AsRef<[u8]> + \'static,\n    {\n        if_downcast_into!(T, Bytes, src, {\n            return HeaderValue::from_shared(src);\n        });\n\n        HeaderValue::from_bytes(src.as_ref())\n    }\n\n    /// Convert a `Bytes` directly into a `HeaderValue` without validating.\n    ///\n    /// This function does NOT validate that illegal bytes are not contained\n    /// within the buffer.\n    ///\n    /// ## Panics\n    /// In a debug build this will panic if `src` is not valid UTF-8.\n    ///\n    /// ## Safety\n    /// `src` must contain valid UTF-8. In a release build it is undefined\n    /// behaviour to call this with `src` that is not valid UTF-8.\n    pub unsafe fn from_maybe_shared_unchecked<T>(src: T) -> HeaderValue\n    where\n        T: AsRef<[u8]> + \'static,\n    {\n        if cfg!(debug_assertions) {\n            match HeaderValue::from_maybe_shared(src) {\n                Ok(val) => val,\n                Err(_err) => {\n                    panic!("HeaderValue::from_maybe_shared_unchecked() with invalid bytes");\n                }\n            }\n        } else {\n            if_downcast_into!(T, Bytes, src, {\n                return HeaderValue {\n                    inner: src,\n                    is_sensitive: false,\n                };\n            });\n\n            let src = Bytes::copy_from_slice(src.as_ref());\n            HeaderValue {\n                inner: src,\n                is_sensitive: false,\n            }\n        }\n    }\n\n    fn from_shared(src: Bytes) -> Result<HeaderValue, InvalidHeaderValue> {\n        HeaderValue::try_from_generic(src, std::convert::identity)\n    }\n\n    fn try_from_generic<T: AsRef<[u8]>, F: FnOnce(T) -> Bytes>(\n        src: T,\n        into: F,\n    ) -> Result<HeaderValue, InvalidHeaderValue> {\n        for &b in src.as_ref() {\n            if !is_valid(b) {\n                return Err(InvalidHeaderValue { _priv: () });\n            }\n        }\n        Ok(HeaderValue {\n            inner: into(src),\n            is_sensitive: false,\n        })\n    }\n\n    /// Yields a `&str` slice if the `HeaderValue` only contains visible ASCII\n    /// chars.\n    ///\n    /// This function will perform a scan of the header value, checking all the\n    /// characters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static("hello");\n    /// assert_eq!(val.to_str().unwrap(), "hello");\n    /// ```\n    pub fn to_str(&self) -> Result<&str, ToStrError> {\n        let bytes = self.as_ref();\n\n        for &b in bytes {\n            if !is_visible_ascii(b) {\n                return Err(ToStrError { _priv: () });\n            }\n        }\n\n        unsafe { Ok(str::from_utf8_unchecked(bytes)) }\n    }\n\n    /// Returns the length of `self`.\n    ///\n    /// This length is in bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static("hello");\n    /// assert_eq!(val.len(), 5);\n    /// ```\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.as_ref().len()\n    }\n\n    /// Returns true if the `HeaderValue` has a length of zero bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static("");\n    /// assert!(val.is_empty());\n    ///\n    /// let val = HeaderValue::from_static("hello");\n    /// assert!(!val.is_empty());\n    /// ```\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Converts a `HeaderValue` to a byte slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static("hello");\n    /// assert_eq!(val.as_bytes(), b"hello");\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8] {\n        self.as_ref()\n    }\n\n    /// Mark that the header value represents sensitive information.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let mut val = HeaderValue::from_static("my secret");\n    ///\n    /// val.set_sensitive(true);\n    /// assert!(val.is_sensitive());\n    ///\n    /// val.set_sensitive(false);\n    /// assert!(!val.is_sensitive());\n    /// ```\n    #[inline]\n    pub fn set_sensitive(&mut self, val: bool) {\n        self.is_sensitive = val;\n    }\n\n    /// Returns `true` if the value represents sensitive data.\n    ///\n    /// Sensitive data could represent passwords or other data that should not\n    /// be stored on disk or in memory. By marking header values as sensitive,\n    /// components using this crate can be instructed to treat them with special\n    /// care for security reasons. For example, caches can avoid storing\n    /// sensitive values, and HPACK encoders used by HTTP/2.0 implementations\n    /// can choose not to compress them.\n    ///\n    /// Additionally, sensitive values will be masked by the `Debug`\n    /// implementation of `HeaderValue`.\n    ///\n    /// Note that sensitivity is not factored into equality or ordering.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let mut val = HeaderValue::from_static("my secret");\n    ///\n    /// val.set_sensitive(true);\n    /// assert!(val.is_sensitive());\n    ///\n    /// val.set_sensitive(false);\n    /// assert!(!val.is_sensitive());\n    /// ```\n    #[inline]\n    pub fn is_sensitive(&self) -> bool {\n        self.is_sensitive\n    }\n}', 'impl Ord for HeaderValue {\n    #[inline]\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n        self.inner.cmp(&other.inner)\n    }\n}', 'impl PartialEq for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &HeaderValue) -> bool {\n        self.inner == other.inner\n    }\n}', 'impl PartialEq<String> for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n        *self == other[..]\n    }\n}', 'impl PartialEq<[u8]> for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &[u8]) -> bool {\n        self.inner == other\n    }\n}', 'impl PartialEq<str> for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        self.inner == other.as_bytes()\n    }\n}', 'impl PartialOrd for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}', 'impl PartialOrd<String> for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {\n        self.inner.partial_cmp(other.as_bytes())\n    }\n}', 'impl PartialOrd<[u8]> for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &[u8]) -> Option<cmp::Ordering> {\n        (*self.inner).partial_cmp(other)\n    }\n}', 'impl PartialOrd<str> for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        (*self.inner).partial_cmp(other.as_bytes())\n    }\n}', 'impl TryFrom<String> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(t: String) -> Result<Self, Self::Error> {\n        HeaderValue::from_shared(t.into())\n    }\n}', 'impl TryFrom<Vec<u8>> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {\n        HeaderValue::from_shared(vec.into())\n    }\n}', 'impl fmt::Debug for HeaderValue {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        if self.is_sensitive {\n            f.write_str("Sensitive")\n        } else {\n            f.write_str("\\"")?;\n            let mut from = 0;\n            let bytes = self.as_bytes();\n            for (i, &b) in bytes.iter().enumerate() {\n                if !is_visible_ascii(b) || b == b\'"\' {\n                    if from != i {\n                        f.write_str(unsafe { str::from_utf8_unchecked(&bytes[from..i]) })?;\n                    }\n                    if b == b\'"\' {\n                        f.write_str("\\\\\\"")?;\n                    } else {\n                        write!(f, "\\\\x{:x}", b)?;\n                    }\n                    from = i + 1;\n                }\n            }\n\n            f.write_str(unsafe { str::from_utf8_unchecked(&bytes[from..]) })?;\n            f.write_str("\\"")\n        }\n    }\n}', "impl<'a, T: ?Sized> PartialEq<&'a T> for HeaderValue\nwhere\n    HeaderValue: PartialEq<T>,\n{\n    #[inline]\n    fn eq(&self, other: &&'a T) -> bool {\n        *self == **other\n    }\n}", "impl<'a, T: ?Sized> PartialOrd<&'a T> for HeaderValue\nwhere\n    HeaderValue: PartialOrd<T>,\n{\n    #[inline]\n    fn partial_cmp(&self, other: &&'a T) -> Option<cmp::Ordering> {\n        self.partial_cmp(*other)\n    }\n}", "impl<'a> From<&'a HeaderValue> for HeaderValue {\n    #[inline]\n    fn from(t: &'a HeaderValue) -> Self {\n        t.clone()\n    }\n}", "impl<'a> TryFrom<&'a String> for HeaderValue {\n    type Error = InvalidHeaderValue;\n    #[inline]\n    fn try_from(s: &'a String) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}", "impl<'a> TryFrom<&'a [u8]> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        HeaderValue::from_bytes(t)\n    }\n}", "impl<'a> TryFrom<&'a str> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}"], 'header::value::InvalidHeaderValue': ['impl Error for InvalidHeaderValue {}', 'impl fmt::Debug for InvalidHeaderValue {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct("InvalidHeaderValue")\n            // skip _priv noise\n            .finish()\n    }\n}', 'impl fmt::Display for InvalidHeaderValue {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.write_str("failed to parse header value")\n    }\n}'], 'header::value::ToStrError': ['Debug', 'impl Error for ToStrError {}', 'impl fmt::Display for ToStrError {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.write_str("failed to convert header to a str")\n    }\n}'], 'method::Inner': ['Clone', 'Eq', 'Hash', 'PartialEq'], 'method::InvalidMethod': ['impl Error for InvalidMethod {}', 'impl InvalidMethod {\n    fn new() -> InvalidMethod {\n        InvalidMethod { _priv: () }\n    }\n}', 'impl fmt::Debug for InvalidMethod {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct("InvalidMethod")\n            // skip _priv noise\n            .finish()\n    }\n}', 'impl fmt::Display for InvalidMethod {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.write_str("invalid HTTP method")\n    }\n}'], 'method::Method': ['Clone', 'Eq', 'Hash', 'PartialEq', 'impl AsRef<str> for Method {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}', 'impl Default for Method {\n    #[inline]\n    fn default() -> Method {\n        Method::GET\n    }\n}', 'impl FromStr for Method {\n    type Err = InvalidMethod;\n\n    #[inline]\n    fn from_str(t: &str) -> Result<Self, Self::Err> {\n        TryFrom::try_from(t)\n    }\n}', 'impl Method {\n    /// GET\n    pub const GET: Method = Method(Get);\n\n    /// POST\n    pub const POST: Method = Method(Post);\n\n    /// PUT\n    pub const PUT: Method = Method(Put);\n\n    /// DELETE\n    pub const DELETE: Method = Method(Delete);\n\n    /// HEAD\n    pub const HEAD: Method = Method(Head);\n\n    /// OPTIONS\n    pub const OPTIONS: Method = Method(Options);\n\n    /// CONNECT\n    pub const CONNECT: Method = Method(Connect);\n\n    /// PATCH\n    pub const PATCH: Method = Method(Patch);\n\n    /// TRACE\n    pub const TRACE: Method = Method(Trace);\n\n    /// Converts a slice of bytes to an HTTP method.\n    pub fn from_bytes(src: &[u8]) -> Result<Method, InvalidMethod> {\n        match src.len() {\n            0 => Err(InvalidMethod::new()),\n            3 => match src {\n                b"GET" => Ok(Method(Get)),\n                b"PUT" => Ok(Method(Put)),\n                _ => Method::extension_inline(src),\n            },\n            4 => match src {\n                b"POST" => Ok(Method(Post)),\n                b"HEAD" => Ok(Method(Head)),\n                _ => Method::extension_inline(src),\n            },\n            5 => match src {\n                b"PATCH" => Ok(Method(Patch)),\n                b"TRACE" => Ok(Method(Trace)),\n                _ => Method::extension_inline(src),\n            },\n            6 => match src {\n                b"DELETE" => Ok(Method(Delete)),\n                _ => Method::extension_inline(src),\n            },\n            7 => match src {\n                b"OPTIONS" => Ok(Method(Options)),\n                b"CONNECT" => Ok(Method(Connect)),\n                _ => Method::extension_inline(src),\n            },\n            _ => {\n                if src.len() <= InlineExtension::MAX {\n                    Method::extension_inline(src)\n                } else {\n                    let allocated = AllocatedExtension::new(src)?;\n\n                    Ok(Method(ExtensionAllocated(allocated)))\n                }\n            }\n        }\n    }\n\n    fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod> {\n        let inline = InlineExtension::new(src)?;\n\n        Ok(Method(ExtensionInline(inline)))\n    }\n\n    /// Whether a method is considered "safe", meaning the request is\n    /// essentially read-only.\n    ///\n    /// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.1)\n    /// for more words.\n    pub fn is_safe(&self) -> bool {\n        matches!(self.0, Get | Head | Options | Trace)\n    }\n\n    /// Whether a method is considered "idempotent", meaning the request has\n    /// the same result if executed multiple times.\n    ///\n    /// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.2) for\n    /// more words.\n    pub fn is_idempotent(&self) -> bool {\n        match self.0 {\n            Put | Delete => true,\n            _ => self.is_safe(),\n        }\n    }\n\n    /// Return a &str representation of the HTTP method\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        match self.0 {\n            Options => "OPTIONS",\n            Get => "GET",\n            Post => "POST",\n            Put => "PUT",\n            Delete => "DELETE",\n            Head => "HEAD",\n            Trace => "TRACE",\n            Connect => "CONNECT",\n            Patch => "PATCH",\n            ExtensionInline(ref inline) => inline.as_str(),\n            ExtensionAllocated(ref allocated) => allocated.as_str(),\n        }\n    }\n}', 'impl PartialEq<str> for Method {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        self.as_ref() == other\n    }\n}', "impl fmt::Debug for Method {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_ref())\n    }\n}", "impl fmt::Display for Method {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.write_str(self.as_ref())\n    }\n}", "impl<'a> From<&'a Method> for Method {\n    #[inline]\n    fn from(t: &'a Method) -> Self {\n        t.clone()\n    }\n}", "impl<'a> PartialEq<&'a Method> for Method {\n    #[inline]\n    fn eq(&self, other: &&'a Method) -> bool {\n        self == *other\n    }\n}", "impl<'a> PartialEq<&'a str> for Method {\n    #[inline]\n    fn eq(&self, other: &&'a str) -> bool {\n        self.as_ref() == *other\n    }\n}", "impl<'a> TryFrom<&'a [u8]> for Method {\n    type Error = InvalidMethod;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        Method::from_bytes(t)\n    }\n}", "impl<'a> TryFrom<&'a str> for Method {\n    type Error = InvalidMethod;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        TryFrom::try_from(t.as_bytes())\n    }\n}"], 'method::extension::AllocatedExtension': ['Clone', 'Eq', 'Hash', 'PartialEq', 'impl AllocatedExtension {\n        pub fn new(src: &[u8]) -> Result<AllocatedExtension, InvalidMethod> {\n            let mut data: Vec<u8> = vec![0; src.len()];\n\n            write_checked(src, &mut data)?;\n\n            // Invariant: data is exactly src.len() long and write_checked\n            // ensures that the first src.len() bytes of data are valid UTF-8.\n            Ok(AllocatedExtension(data.into_boxed_slice()))\n        }\n\n        pub fn as_str(&self) -> &str {\n            // Safety: the invariant of AllocatedExtension ensures that self.0\n            // contains valid UTF-8.\n            unsafe { str::from_utf8_unchecked(&self.0) }\n        }\n    }'], 'method::extension::InlineExtension': ['Clone', 'Eq', 'Hash', 'PartialEq', 'impl InlineExtension {\n        // Method::from_bytes() assumes this is at least 7\n        pub const MAX: usize = 15;\n\n        pub fn new(src: &[u8]) -> Result<InlineExtension, InvalidMethod> {\n            let mut data: [u8; InlineExtension::MAX] = Default::default();\n\n            write_checked(src, &mut data)?;\n\n            // Invariant: write_checked ensures that the first src.len() bytes\n            // of data are valid UTF-8.\n            Ok(InlineExtension(data, src.len() as u8))\n        }\n\n        pub fn as_str(&self) -> &str {\n            let InlineExtension(ref data, len) = self;\n            // Safety: the invariant of InlineExtension ensures that the first\n            // len bytes of data contain valid UTF-8.\n            unsafe { str::from_utf8_unchecked(&data[..*len as usize]) }\n        }\n    }'], 'request::Builder': ['Debug', 'impl Builder {\n    /// Creates a new default instance of `Builder` to construct a `Request`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = request::Builder::new()\n    ///     .method("POST")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn new() -> Builder {\n        Builder::default()\n    }\n\n    /// Set the HTTP method for this request.\n    ///\n    /// By default this is `GET`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .method("POST")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn method<T>(self, method: T) -> Builder\n    where\n        T: TryInto<Method>,\n        <T as TryInto<Method>>::Error: Into<crate::Error>,\n    {\n        self.and_then(move |mut head| {\n            let method = method.try_into().map_err(Into::into)?;\n            head.method = method;\n            Ok(head)\n        })\n    }\n\n    /// Get the HTTP Method for this request.\n    ///\n    /// By default this is `GET`. If builder has error, returns None.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let mut req = Request::builder();\n    /// assert_eq!(req.method_ref(),Some(&Method::GET));\n    ///\n    /// req = req.method("POST");\n    /// assert_eq!(req.method_ref(),Some(&Method::POST));\n    /// ```\n    pub fn method_ref(&self) -> Option<&Method> {\n        self.inner.as_ref().ok().map(|h| &h.method)\n    }\n\n    /// Set the URI for this request.\n    ///\n    /// By default this is `/`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .uri("https://www.rust-lang.org/")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn uri<T>(self, uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        self.and_then(move |mut head| {\n            head.uri = uri.try_into().map_err(Into::into)?;\n            Ok(head)\n        })\n    }\n\n    /// Get the URI for this request\n    ///\n    /// By default this is `/`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let mut req = Request::builder();\n    /// assert_eq!(req.uri_ref().unwrap(), "/" );\n    ///\n    /// req = req.uri("https://www.rust-lang.org/");\n    /// assert_eq!(req.uri_ref().unwrap(), "https://www.rust-lang.org/" );\n    /// ```\n    pub fn uri_ref(&self) -> Option<&Uri> {\n        self.inner.as_ref().ok().map(|h| &h.uri)\n    }\n\n    /// Set the HTTP version for this request.\n    ///\n    /// By default this is HTTP/1.1\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .version(Version::HTTP_2)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn version(self, version: Version) -> Builder {\n        self.and_then(move |mut head| {\n            head.version = version;\n            Ok(head)\n        })\n    }\n\n    /// Get the HTTP version for this request\n    ///\n    /// By default this is HTTP/1.1.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let mut req = Request::builder();\n    /// assert_eq!(req.version_ref().unwrap(), &Version::HTTP_11 );\n    ///\n    /// req = req.version(Version::HTTP_2);\n    /// assert_eq!(req.version_ref().unwrap(), &Version::HTTP_2 );\n    /// ```\n    pub fn version_ref(&self) -> Option<&Version> {\n        self.inner.as_ref().ok().map(|h| &h.version)\n    }\n\n    /// Appends a header to this request builder.\n    ///\n    /// This function will append the provided key/value as a header to the\n    /// internal `HeaderMap` being constructed. Essentially this is equivalent\n    /// to calling `HeaderMap::append`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    ///\n    /// let req = Request::builder()\n    ///     .header("Accept", "text/html")\n    ///     .header("X-Custom-Foo", "bar")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn header<K, V>(self, key: K, value: V) -> Builder\n    where\n        K: TryInto<HeaderName>,\n        <K as TryInto<HeaderName>>::Error: Into<crate::Error>,\n        V: TryInto<HeaderValue>,\n        <V as TryInto<HeaderValue>>::Error: Into<crate::Error>,\n    {\n        self.and_then(move |mut head| {\n            let name = key.try_into().map_err(Into::into)?;\n            let value = value.try_into().map_err(Into::into)?;\n            head.headers.try_append(name, value)?;\n            Ok(head)\n        })\n    }\n\n    /// Get header on this request builder.\n    /// when builder has error returns None\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Request;\n    /// let req = Request::builder()\n    ///     .header("Accept", "text/html")\n    ///     .header("X-Custom-Foo", "bar");\n    /// let headers = req.headers_ref().unwrap();\n    /// assert_eq!( headers["Accept"], "text/html" );\n    /// assert_eq!( headers["X-Custom-Foo"], "bar" );\n    /// ```\n    pub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>> {\n        self.inner.as_ref().ok().map(|h| &h.headers)\n    }\n\n    /// Get headers on this request builder.\n    ///\n    /// When builder has error returns None.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::{header::HeaderValue, Request};\n    /// let mut req = Request::builder();\n    /// {\n    ///   let headers = req.headers_mut().unwrap();\n    ///   headers.insert("Accept", HeaderValue::from_static("text/html"));\n    ///   headers.insert("X-Custom-Foo", HeaderValue::from_static("bar"));\n    /// }\n    /// let headers = req.headers_ref().unwrap();\n    /// assert_eq!( headers["Accept"], "text/html" );\n    /// assert_eq!( headers["X-Custom-Foo"], "bar" );\n    /// ```\n    pub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>> {\n        self.inner.as_mut().ok().map(|h| &mut h.headers)\n    }\n\n    /// Adds an extension to this builder\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .extension("My Extension")\n    ///     .body(())\n    ///     .unwrap();\n    ///\n    /// assert_eq!(req.extensions().get::<&\'static str>(),\n    ///            Some(&"My Extension"));\n    /// ```\n    pub fn extension<T>(self, extension: T) -> Builder\n    where\n        T: Clone + Any + Send + Sync + \'static,\n    {\n        self.and_then(move |mut head| {\n            head.extensions.insert(extension);\n            Ok(head)\n        })\n    }\n\n    /// Get a reference to the extensions for this request builder.\n    ///\n    /// If the builder has an error, this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Request;\n    /// let req = Request::builder().extension("My Extension").extension(5u32);\n    /// let extensions = req.extensions_ref().unwrap();\n    /// assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n    /// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    /// ```\n    pub fn extensions_ref(&self) -> Option<&Extensions> {\n        self.inner.as_ref().ok().map(|h| &h.extensions)\n    }\n\n    /// Get a mutable reference to the extensions for this request builder.\n    ///\n    /// If the builder has an error, this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Request;\n    /// let mut req = Request::builder().extension("My Extension");\n    /// let mut extensions = req.extensions_mut().unwrap();\n    /// assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n    /// extensions.insert(5u32);\n    /// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    /// ```\n    pub fn extensions_mut(&mut self) -> Option<&mut Extensions> {\n        self.inner.as_mut().ok().map(|h| &mut h.extensions)\n    }\n\n    /// "Consumes" this builder, using the provided `body` to return a\n    /// constructed `Request`.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if any previously configured argument\n    /// failed to parse or get converted to the internal representation. For\n    /// example if an invalid `head` was specified via `header("Foo",\n    /// "Bar\\r\\n")` the error will be returned when this function is called\n    /// rather than when `header` was called.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::builder()\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn body<T>(self, body: T) -> Result<Request<T>> {\n        self.inner.map(move |head| Request { head, body })\n    }\n\n    // private\n\n    fn and_then<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts>,\n    {\n        Builder {\n            inner: self.inner.and_then(func),\n        }\n    }\n}', 'impl Default for Builder {\n    #[inline]\n    fn default() -> Builder {\n        Builder {\n            inner: Ok(Parts::new()),\n        }\n    }\n}'], 'request::Parts': ['Clone', 'impl Parts {\n    /// Creates a new default instance of `Parts`\n    fn new() -> Parts {\n        Parts {\n            method: Method::default(),\n            uri: Uri::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }\n}', 'impl fmt::Debug for Parts {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("Parts")\n            .field("method", &self.method)\n            .field("uri", &self.uri)\n            .field("version", &self.version)\n            .field("headers", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }\n}'], 'request::Request': ['Clone', 'impl Request<()> {\n    /// Creates a new builder-style object to manufacture a `Request`\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::builder()\n    ///     .method("GET")\n    ///     .uri("https://www.rust-lang.org/")\n    ///     .header("X-Custom-Foo", "Bar")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn builder() -> Builder {\n        Builder::new()\n    }\n\n    /// Creates a new `Builder` initialized with a GET method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::get("https://www.rust-lang.org/")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn get<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::GET).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a PUT method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::put("https://www.rust-lang.org/")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn put<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::PUT).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a POST method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::post("https://www.rust-lang.org/")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn post<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::POST).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a DELETE method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::delete("https://www.rust-lang.org/")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn delete<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::DELETE).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with an OPTIONS method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::options("https://www.rust-lang.org/")\n    ///     .body(())\n    ///     .unwrap();\n    /// # assert_eq!(*request.method(), Method::OPTIONS);\n    /// ```\n    pub fn options<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::OPTIONS).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a HEAD method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::head("https://www.rust-lang.org/")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn head<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::HEAD).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a CONNECT method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::connect("https://www.rust-lang.org/")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn connect<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::CONNECT).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a PATCH method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::patch("https://www.rust-lang.org/")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn patch<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::PATCH).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a TRACE method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::trace("https://www.rust-lang.org/")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn trace<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::TRACE).uri(uri)\n    }\n}', 'impl<T: Default> Default for Request<T> {\n    fn default() -> Request<T> {\n        Request::new(T::default())\n    }\n}', 'impl<T: fmt::Debug> fmt::Debug for Request<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("Request")\n            .field("method", self.method())\n            .field("uri", self.uri())\n            .field("version", &self.version())\n            .field("headers", self.headers())\n            // omits Extensions because not useful\n            .field("body", self.body())\n            .finish()\n    }\n}', 'impl<T> Request<T> {\n    /// Creates a new blank `Request` with the body\n    ///\n    /// The component parts of this request will be set to their default, e.g.\n    /// the GET method, no headers, etc.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::new("hello world");\n    ///\n    /// assert_eq!(*request.method(), Method::GET);\n    /// assert_eq!(*request.body(), "hello world");\n    /// ```\n    #[inline]\n    pub fn new(body: T) -> Request<T> {\n        Request {\n            head: Parts::new(),\n            body,\n        }\n    }\n\n    /// Creates a new `Request` with the given components parts and body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::new("hello world");\n    /// let (mut parts, body) = request.into_parts();\n    /// parts.method = Method::POST;\n    ///\n    /// let request = Request::from_parts(parts, body);\n    /// ```\n    #[inline]\n    pub fn from_parts(parts: Parts, body: T) -> Request<T> {\n        Request { head: parts, body }\n    }\n\n    /// Returns a reference to the associated HTTP method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert_eq!(*request.method(), Method::GET);\n    /// ```\n    #[inline]\n    pub fn method(&self) -> &Method {\n        &self.head.method\n    }\n\n    /// Returns a mutable reference to the associated HTTP method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<()> = Request::default();\n    /// *request.method_mut() = Method::PUT;\n    /// assert_eq!(*request.method(), Method::PUT);\n    /// ```\n    #[inline]\n    pub fn method_mut(&mut self) -> &mut Method {\n        &mut self.head.method\n    }\n\n    /// Returns a reference to the associated URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert_eq!(*request.uri(), *"/");\n    /// ```\n    #[inline]\n    pub fn uri(&self) -> &Uri {\n        &self.head.uri\n    }\n\n    /// Returns a mutable reference to the associated URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<()> = Request::default();\n    /// *request.uri_mut() = "/hello".parse().unwrap();\n    /// assert_eq!(*request.uri(), *"/hello");\n    /// ```\n    #[inline]\n    pub fn uri_mut(&mut self) -> &mut Uri {\n        &mut self.head.uri\n    }\n\n    /// Returns the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert_eq!(request.version(), Version::HTTP_11);\n    /// ```\n    #[inline]\n    pub fn version(&self) -> Version {\n        self.head.version\n    }\n\n    /// Returns a mutable reference to the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<()> = Request::default();\n    /// *request.version_mut() = Version::HTTP_2;\n    /// assert_eq!(request.version(), Version::HTTP_2);\n    /// ```\n    #[inline]\n    pub fn version_mut(&mut self) -> &mut Version {\n        &mut self.head.version\n    }\n\n    /// Returns a reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert!(request.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers(&self) -> &HeaderMap<HeaderValue> {\n        &self.head.headers\n    }\n\n    /// Returns a mutable reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut request: Request<()> = Request::default();\n    /// request.headers_mut().insert(HOST, HeaderValue::from_static("world"));\n    /// assert!(!request.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue> {\n        &mut self.head.headers\n    }\n\n    /// Returns a reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert!(request.extensions().get::<i32>().is_none());\n    /// ```\n    #[inline]\n    pub fn extensions(&self) -> &Extensions {\n        &self.head.extensions\n    }\n\n    /// Returns a mutable reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut request: Request<()> = Request::default();\n    /// request.extensions_mut().insert("hello");\n    /// assert_eq!(request.extensions().get(), Some(&"hello"));\n    /// ```\n    #[inline]\n    pub fn extensions_mut(&mut self) -> &mut Extensions {\n        &mut self.head.extensions\n    }\n\n    /// Returns a reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<String> = Request::default();\n    /// assert!(request.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body(&self) -> &T {\n        &self.body\n    }\n\n    /// Returns a mutable reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<String> = Request::default();\n    /// request.body_mut().push_str("hello world");\n    /// assert!(!request.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body_mut(&mut self) -> &mut T {\n        &mut self.body\n    }\n\n    /// Consumes the request, returning just the body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::Request;\n    /// let request = Request::new(10);\n    /// let body = request.into_body();\n    /// assert_eq!(body, 10);\n    /// ```\n    #[inline]\n    pub fn into_body(self) -> T {\n        self.body\n    }\n\n    /// Consumes the request returning the head and body parts.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::new(());\n    /// let (parts, body) = request.into_parts();\n    /// assert_eq!(parts.method, Method::GET);\n    /// ```\n    #[inline]\n    pub fn into_parts(self) -> (Parts, T) {\n        (self.head, self.body)\n    }\n\n    /// Consumes the request returning a new request with body mapped to the\n    /// return type of the passed in function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::builder().body("some string").unwrap();\n    /// let mapped_request: Request<&[u8]> = request.map(|b| {\n    ///   assert_eq!(b, "some string");\n    ///   b.as_bytes()\n    /// });\n    /// assert_eq!(mapped_request.body(), &"some string".as_bytes());\n    /// ```\n    #[inline]\n    pub fn map<F, U>(self, f: F) -> Request<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        Request {\n            body: f(self.body),\n            head: self.head,\n        }\n    }\n}'], 'response::Builder': ['Debug', 'impl Builder {\n    /// Creates a new default instance of `Builder` to construct either a\n    /// `Head` or a `Response`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = response::Builder::new()\n    ///     .status(200)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn new() -> Builder {\n        Builder::default()\n    }\n\n    /// Set the HTTP status for this response.\n    ///\n    /// By default this is `200`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .status(200)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn status<T>(self, status: T) -> Builder\n    where\n        T: TryInto<StatusCode>,\n        <T as TryInto<StatusCode>>::Error: Into<crate::Error>,\n    {\n        self.and_then(move |mut head| {\n            head.status = status.try_into().map_err(Into::into)?;\n            Ok(head)\n        })\n    }\n\n    /// Set the HTTP version for this response.\n    ///\n    /// By default this is HTTP/1.1\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .version(Version::HTTP_2)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn version(self, version: Version) -> Builder {\n        self.and_then(move |mut head| {\n            head.version = version;\n            Ok(head)\n        })\n    }\n\n    /// Appends a header to this response builder.\n    ///\n    /// This function will append the provided key/value as a header to the\n    /// internal `HeaderMap` being constructed. Essentially this is equivalent\n    /// to calling `HeaderMap::append`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    ///\n    /// let response = Response::builder()\n    ///     .header("Content-Type", "text/html")\n    ///     .header("X-Custom-Foo", "bar")\n    ///     .header("content-length", 0)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn header<K, V>(self, key: K, value: V) -> Builder\n    where\n        K: TryInto<HeaderName>,\n        <K as TryInto<HeaderName>>::Error: Into<crate::Error>,\n        V: TryInto<HeaderValue>,\n        <V as TryInto<HeaderValue>>::Error: Into<crate::Error>,\n    {\n        self.and_then(move |mut head| {\n            let name = key.try_into().map_err(Into::into)?;\n            let value = value.try_into().map_err(Into::into)?;\n            head.headers.try_append(name, value)?;\n            Ok(head)\n        })\n    }\n\n    /// Get header on this response builder.\n    ///\n    /// When builder has error returns None.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Response;\n    /// # use http::header::HeaderValue;\n    /// let res = Response::builder()\n    ///     .header("Accept", "text/html")\n    ///     .header("X-Custom-Foo", "bar");\n    /// let headers = res.headers_ref().unwrap();\n    /// assert_eq!( headers["Accept"], "text/html" );\n    /// assert_eq!( headers["X-Custom-Foo"], "bar" );\n    /// ```\n    pub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>> {\n        self.inner.as_ref().ok().map(|h| &h.headers)\n    }\n\n    /// Get header on this response builder.\n    /// when builder has error returns None\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    /// # use http::response::Builder;\n    /// let mut res = Response::builder();\n    /// {\n    ///   let headers = res.headers_mut().unwrap();\n    ///   headers.insert("Accept", HeaderValue::from_static("text/html"));\n    ///   headers.insert("X-Custom-Foo", HeaderValue::from_static("bar"));\n    /// }\n    /// let headers = res.headers_ref().unwrap();\n    /// assert_eq!( headers["Accept"], "text/html" );\n    /// assert_eq!( headers["X-Custom-Foo"], "bar" );\n    /// ```\n    pub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>> {\n        self.inner.as_mut().ok().map(|h| &mut h.headers)\n    }\n\n    /// Adds an extension to this builder\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .extension("My Extension")\n    ///     .body(())\n    ///     .unwrap();\n    ///\n    /// assert_eq!(response.extensions().get::<&\'static str>(),\n    ///            Some(&"My Extension"));\n    /// ```\n    pub fn extension<T>(self, extension: T) -> Builder\n    where\n        T: Clone + Any + Send + Sync + \'static,\n    {\n        self.and_then(move |mut head| {\n            head.extensions.insert(extension);\n            Ok(head)\n        })\n    }\n\n    /// Get a reference to the extensions for this response builder.\n    ///\n    /// If the builder has an error, this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Response;\n    /// let res = Response::builder().extension("My Extension").extension(5u32);\n    /// let extensions = res.extensions_ref().unwrap();\n    /// assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n    /// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    /// ```\n    pub fn extensions_ref(&self) -> Option<&Extensions> {\n        self.inner.as_ref().ok().map(|h| &h.extensions)\n    }\n\n    /// Get a mutable reference to the extensions for this response builder.\n    ///\n    /// If the builder has an error, this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Response;\n    /// let mut res = Response::builder().extension("My Extension");\n    /// let mut extensions = res.extensions_mut().unwrap();\n    /// assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n    /// extensions.insert(5u32);\n    /// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    /// ```\n    pub fn extensions_mut(&mut self) -> Option<&mut Extensions> {\n        self.inner.as_mut().ok().map(|h| &mut h.extensions)\n    }\n\n    /// "Consumes" this builder, using the provided `body` to return a\n    /// constructed `Response`.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if any previously configured argument\n    /// failed to parse or get converted to the internal representation. For\n    /// example if an invalid `head` was specified via `header("Foo",\n    /// "Bar\\r\\n")` the error will be returned when this function is called\n    /// rather than when `header` was called.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn body<T>(self, body: T) -> Result<Response<T>> {\n        self.inner.map(move |head| Response { head, body })\n    }\n\n    // private\n\n    fn and_then<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts>,\n    {\n        Builder {\n            inner: self.inner.and_then(func),\n        }\n    }\n}', 'impl Default for Builder {\n    #[inline]\n    fn default() -> Builder {\n        Builder {\n            inner: Ok(Parts::new()),\n        }\n    }\n}'], 'response::Parts': ['Clone', 'impl Parts {\n    /// Creates a new default instance of `Parts`\n    fn new() -> Parts {\n        Parts {\n            status: StatusCode::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }\n}', 'impl fmt::Debug for Parts {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("Parts")\n            .field("status", &self.status)\n            .field("version", &self.version)\n            .field("headers", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }\n}'], 'response::Response': ['Clone', 'impl Response<()> {\n    /// Creates a new builder-style object to manufacture a `Response`\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Response`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::builder()\n    ///     .status(200)\n    ///     .header("X-Custom-Foo", "Bar")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn builder() -> Builder {\n        Builder::new()\n    }\n}', 'impl<T: Default> Default for Response<T> {\n    #[inline]\n    fn default() -> Response<T> {\n        Response::new(T::default())\n    }\n}', 'impl<T: fmt::Debug> fmt::Debug for Response<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("Response")\n            .field("status", &self.status())\n            .field("version", &self.version())\n            .field("headers", self.headers())\n            // omits Extensions because not useful\n            .field("body", self.body())\n            .finish()\n    }\n}', 'impl<T> Response<T> {\n    /// Creates a new blank `Response` with the body\n    ///\n    /// The component parts of this response will be set to their default, e.g.\n    /// the ok status, no headers, etc.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::new("hello world");\n    ///\n    /// assert_eq!(response.status(), StatusCode::OK);\n    /// assert_eq!(*response.body(), "hello world");\n    /// ```\n    #[inline]\n    pub fn new(body: T) -> Response<T> {\n        Response {\n            head: Parts::new(),\n            body,\n        }\n    }\n\n    /// Creates a new `Response` with the given head and body\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::new("hello world");\n    /// let (mut parts, body) = response.into_parts();\n    ///\n    /// parts.status = StatusCode::BAD_REQUEST;\n    /// let response = Response::from_parts(parts, body);\n    ///\n    /// assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n    /// assert_eq!(*response.body(), "hello world");\n    /// ```\n    #[inline]\n    pub fn from_parts(parts: Parts, body: T) -> Response<T> {\n        Response { head: parts, body }\n    }\n\n    /// Returns the `StatusCode`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert_eq!(response.status(), StatusCode::OK);\n    /// ```\n    #[inline]\n    pub fn status(&self) -> StatusCode {\n        self.head.status\n    }\n\n    /// Returns a mutable reference to the associated `StatusCode`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut response: Response<()> = Response::default();\n    /// *response.status_mut() = StatusCode::CREATED;\n    /// assert_eq!(response.status(), StatusCode::CREATED);\n    /// ```\n    #[inline]\n    pub fn status_mut(&mut self) -> &mut StatusCode {\n        &mut self.head.status\n    }\n\n    /// Returns a reference to the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert_eq!(response.version(), Version::HTTP_11);\n    /// ```\n    #[inline]\n    pub fn version(&self) -> Version {\n        self.head.version\n    }\n\n    /// Returns a mutable reference to the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut response: Response<()> = Response::default();\n    /// *response.version_mut() = Version::HTTP_2;\n    /// assert_eq!(response.version(), Version::HTTP_2);\n    /// ```\n    #[inline]\n    pub fn version_mut(&mut self) -> &mut Version {\n        &mut self.head.version\n    }\n\n    /// Returns a reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert!(response.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers(&self) -> &HeaderMap<HeaderValue> {\n        &self.head.headers\n    }\n\n    /// Returns a mutable reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut response: Response<()> = Response::default();\n    /// response.headers_mut().insert(HOST, HeaderValue::from_static("world"));\n    /// assert!(!response.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue> {\n        &mut self.head.headers\n    }\n\n    /// Returns a reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert!(response.extensions().get::<i32>().is_none());\n    /// ```\n    #[inline]\n    pub fn extensions(&self) -> &Extensions {\n        &self.head.extensions\n    }\n\n    /// Returns a mutable reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut response: Response<()> = Response::default();\n    /// response.extensions_mut().insert("hello");\n    /// assert_eq!(response.extensions().get(), Some(&"hello"));\n    /// ```\n    #[inline]\n    pub fn extensions_mut(&mut self) -> &mut Extensions {\n        &mut self.head.extensions\n    }\n\n    /// Returns a reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<String> = Response::default();\n    /// assert!(response.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body(&self) -> &T {\n        &self.body\n    }\n\n    /// Returns a mutable reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut response: Response<String> = Response::default();\n    /// response.body_mut().push_str("hello world");\n    /// assert!(!response.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body_mut(&mut self) -> &mut T {\n        &mut self.body\n    }\n\n    /// Consumes the response, returning just the body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::Response;\n    /// let response = Response::new(10);\n    /// let body = response.into_body();\n    /// assert_eq!(body, 10);\n    /// ```\n    #[inline]\n    pub fn into_body(self) -> T {\n        self.body\n    }\n\n    /// Consumes the response returning the head and body parts.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// let (parts, body) = response.into_parts();\n    /// assert_eq!(parts.status, StatusCode::OK);\n    /// ```\n    #[inline]\n    pub fn into_parts(self) -> (Parts, T) {\n        (self.head, self.body)\n    }\n\n    /// Consumes the response returning a new response with body mapped to the\n    /// return type of the passed in function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::builder().body("some string").unwrap();\n    /// let mapped_response: Response<&[u8]> = response.map(|b| {\n    ///   assert_eq!(b, "some string");\n    ///   b.as_bytes()\n    /// });\n    /// assert_eq!(mapped_response.body(), &"some string".as_bytes());\n    /// ```\n    #[inline]\n    pub fn map<F, U>(self, f: F) -> Response<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        Response {\n            body: f(self.body),\n            head: self.head,\n        }\n    }\n}'], 'status::InvalidStatusCode': ['impl Error for InvalidStatusCode {}', 'impl InvalidStatusCode {\n    fn new() -> InvalidStatusCode {\n        InvalidStatusCode { _priv: () }\n    }\n}', 'impl fmt::Debug for InvalidStatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct("InvalidStatusCode")\n            // skip _priv noise\n            .finish()\n    }\n}', 'impl fmt::Display for InvalidStatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.write_str("invalid status code")\n    }\n}'], 'status::StatusCode': ['Clone', 'Copy', 'Eq', 'Hash', 'Ord', 'PartialEq', 'PartialOrd', 'impl Default for StatusCode {\n    #[inline]\n    fn default() -> StatusCode {\n        StatusCode::OK\n    }\n}', 'impl FromStr for StatusCode {\n    type Err = InvalidStatusCode;\n\n    fn from_str(s: &str) -> Result<StatusCode, InvalidStatusCode> {\n        StatusCode::from_bytes(s.as_ref())\n    }\n}', 'impl PartialEq<u16> for StatusCode {\n    #[inline]\n    fn eq(&self, other: &u16) -> bool {\n        self.as_u16() == *other\n    }\n}', 'impl StatusCode {\n        $(\n            $(#[$docs])*\n            pub const $konst: StatusCode = StatusCode(unsafe { NonZeroU16::new_unchecked($num) });\n        )+\n\n        }', 'impl StatusCode {\n    /// Converts a u16 to a status code.\n    ///\n    /// The function validates the correctness of the supplied u16. It must be\n    /// greater or equal to 100 and less than 1000.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use http::StatusCode;\n    ///\n    /// let ok = StatusCode::from_u16(200).unwrap();\n    /// assert_eq!(ok, StatusCode::OK);\n    ///\n    /// let err = StatusCode::from_u16(99);\n    /// assert!(err.is_err());\n    /// ```\n    #[inline]\n    pub fn from_u16(src: u16) -> Result<StatusCode, InvalidStatusCode> {\n        if !(100..1000).contains(&src) {\n            return Err(InvalidStatusCode::new());\n        }\n\n        NonZeroU16::new(src)\n            .map(StatusCode)\n            .ok_or_else(InvalidStatusCode::new)\n    }\n\n    /// Converts a `&[u8]` to a status code.\n    pub fn from_bytes(src: &[u8]) -> Result<StatusCode, InvalidStatusCode> {\n        if src.len() != 3 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let a = src[0].wrapping_sub(b\'0\') as u16;\n        let b = src[1].wrapping_sub(b\'0\') as u16;\n        let c = src[2].wrapping_sub(b\'0\') as u16;\n\n        if a == 0 || a > 9 || b > 9 || c > 9 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let status = (a * 100) + (b * 10) + c;\n        NonZeroU16::new(status)\n            .map(StatusCode)\n            .ok_or_else(InvalidStatusCode::new)\n    }\n\n    /// Returns the `u16` corresponding to this `StatusCode`.\n    ///\n    /// # Note\n    ///\n    /// This is the same as the `From<StatusCode>` implementation, but\n    /// included as an inherent method because that implementation doesn\'t\n    /// appear in rustdocs, as well as a way to force the type instead of\n    /// relying on inference.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let status = http::StatusCode::OK;\n    /// assert_eq!(status.as_u16(), 200);\n    /// ```\n    #[inline]\n    pub const fn as_u16(&self) -> u16 {\n        self.0.get()\n    }\n\n    /// Returns a &str representation of the `StatusCode`\n    ///\n    /// The return value only includes a numerical representation of the\n    /// status code. The canonical reason is not included.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let status = http::StatusCode::OK;\n    /// assert_eq!(status.as_str(), "200");\n    /// ```\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        let offset = (self.0.get() - 100) as usize;\n        let offset = offset * 3;\n\n        // Invariant: self has checked range [100, 999] and CODE_DIGITS is\n        // ASCII-only, of length 900 * 3 = 2700 bytes\n\n        #[cfg(debug_assertions)]\n        {\n            &CODE_DIGITS[offset..offset + 3]\n        }\n\n        #[cfg(not(debug_assertions))]\n        unsafe {\n            CODE_DIGITS.get_unchecked(offset..offset + 3)\n        }\n    }\n\n    /// Get the standardised `reason-phrase` for this status code.\n    ///\n    /// This is mostly here for servers writing responses, but could potentially have application\n    /// at other times.\n    ///\n    /// The reason phrase is defined as being exclusively for human readers. You should avoid\n    /// deriving any meaning from it at all costs.\n    ///\n    /// Bear in mind also that in HTTP/2.0 and HTTP/3.0 the reason phrase is abolished from\n    /// transmission, and so this canonical reason phrase really is the only reason phrase youll\n    /// find.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let status = http::StatusCode::OK;\n    /// assert_eq!(status.canonical_reason(), Some("OK"));\n    /// ```\n    pub fn canonical_reason(&self) -> Option<&\'static str> {\n        canonical_reason(self.0.get())\n    }\n\n    /// Check if status is within 100-199.\n    #[inline]\n    pub fn is_informational(&self) -> bool {\n        (100..200).contains(&self.0.get())\n    }\n\n    /// Check if status is within 200-299.\n    #[inline]\n    pub fn is_success(&self) -> bool {\n        (200..300).contains(&self.0.get())\n    }\n\n    /// Check if status is within 300-399.\n    #[inline]\n    pub fn is_redirection(&self) -> bool {\n        (300..400).contains(&self.0.get())\n    }\n\n    /// Check if status is within 400-499.\n    #[inline]\n    pub fn is_client_error(&self) -> bool {\n        (400..500).contains(&self.0.get())\n    }\n\n    /// Check if status is within 500-599.\n    #[inline]\n    pub fn is_server_error(&self) -> bool {\n        (500..600).contains(&self.0.get())\n    }\n}', 'impl TryFrom<u16> for StatusCode {\n    type Error = InvalidStatusCode;\n\n    #[inline]\n    fn try_from(t: u16) -> Result<Self, Self::Error> {\n        StatusCode::from_u16(t)\n    }\n}', "impl fmt::Debug for StatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.0, f)\n    }\n}", 'impl fmt::Display for StatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        write!(\n            f,\n            "{} {}",\n            u16::from(*self),\n            self.canonical_reason().unwrap_or("<unknown status code>")\n        )\n    }\n}', "impl<'a> From<&'a StatusCode> for StatusCode {\n    #[inline]\n    fn from(t: &'a StatusCode) -> Self {\n        t.to_owned()\n    }\n}", "impl<'a> TryFrom<&'a [u8]> for StatusCode {\n    type Error = InvalidStatusCode;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        StatusCode::from_bytes(t)\n    }\n}", "impl<'a> TryFrom<&'a str> for StatusCode {\n    type Error = InvalidStatusCode;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}"], 'std::boxed::Box': ['impl Clone for Box<dyn AnyClone + Send + Sync> {\n    fn clone(&self) -> Self {\n        (**self).clone_box()\n    }\n}'], 'std::string::String': ['impl AsHeaderName for String {}', 'impl PartialEq<Authority> for String {\n    fn eq(&self, other: &Authority) -> bool {\n        self.as_str().eq_ignore_ascii_case(other.as_str())\n    }\n}', 'impl PartialEq<HeaderValue> for String {\n    #[inline]\n    fn eq(&self, other: &HeaderValue) -> bool {\n        *other == *self\n    }\n}', 'impl PartialEq<PathAndQuery> for String {\n    #[inline]\n    fn eq(&self, other: &PathAndQuery) -> bool {\n        self.as_str() == other.as_str()\n    }\n}', 'impl PartialOrd<Authority> for String {\n    fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering> {\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}', 'impl PartialOrd<HeaderValue> for String {\n    #[inline]\n    fn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering> {\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }\n}', 'impl PartialOrd<PathAndQuery> for String {\n    #[inline]\n    fn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other.as_str())\n    }\n}', "impl Sealed for String {\n        #[inline]\n        fn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError> {\n            self.as_str().try_entry(map)\n        }\n\n        #[inline]\n        fn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)> {\n            Sealed::find(&self.as_str(), map)\n        }\n\n        fn as_str(&self) -> &str {\n            self\n        }\n    }"], 'uri::ErrorKind': ['Debug', 'Eq', 'PartialEq'], 'uri::InvalidUri': ['Debug', 'impl Error for InvalidUri {}', 'impl From<ErrorKind> for InvalidUri {\n    fn from(src: ErrorKind) -> InvalidUri {\n        InvalidUri(src)\n    }\n}', 'impl InvalidUri {\n    fn s(&self) -> &str {\n        match self.0 {\n            ErrorKind::InvalidUriChar => "invalid uri character",\n            ErrorKind::InvalidScheme => "invalid scheme",\n            ErrorKind::InvalidAuthority => "invalid authority",\n            ErrorKind::InvalidPort => "invalid port",\n            ErrorKind::InvalidFormat => "invalid format",\n            ErrorKind::SchemeMissing => "scheme missing",\n            ErrorKind::AuthorityMissing => "authority missing",\n            ErrorKind::PathAndQueryMissing => "path missing",\n            ErrorKind::TooLong => "uri too long",\n            ErrorKind::Empty => "empty string",\n            ErrorKind::SchemeTooLong => "scheme too long",\n        }\n    }\n}', "impl fmt::Display for InvalidUri {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.s().fmt(f)\n    }\n}"], 'uri::InvalidUriParts': ['Debug', 'impl Error for InvalidUriParts {}', 'impl From<ErrorKind> for InvalidUriParts {\n    fn from(src: ErrorKind) -> InvalidUriParts {\n        InvalidUriParts(src.into())\n    }\n}', "impl fmt::Display for InvalidUriParts {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}"], 'uri::Parts': ['Debug', 'Default', 'impl From<Uri> for Parts {\n    fn from(src: Uri) -> Self {\n        let path_and_query = if src.has_path() {\n            Some(src.path_and_query)\n        } else {\n            None\n        };\n\n        let scheme = match src.scheme.inner {\n            Scheme2::None => None,\n            _ => Some(src.scheme),\n        };\n\n        let authority = if src.authority.data.is_empty() {\n            None\n        } else {\n            Some(src.authority)\n        };\n\n        Parts {\n            scheme,\n            authority,\n            path_and_query,\n            _priv: (),\n        }\n    }\n}'], 'uri::Uri': ['Clone', 'impl Default for Uri {\n    #[inline]\n    fn default() -> Uri {\n        Uri {\n            scheme: Scheme::empty(),\n            authority: Authority::empty(),\n            path_and_query: PathAndQuery::slash(),\n        }\n    }\n}', 'impl Eq for Uri {}', 'impl From<Authority> for Uri {\n    fn from(authority: Authority) -> Self {\n        Self {\n            scheme: Scheme::empty(),\n            authority,\n            path_and_query: PathAndQuery::empty(),\n        }\n    }\n}', 'impl From<PathAndQuery> for Uri {\n    fn from(path_and_query: PathAndQuery) -> Self {\n        Self {\n            scheme: Scheme::empty(),\n            authority: Authority::empty(),\n            path_and_query,\n        }\n    }\n}', 'impl FromStr for Uri {\n    type Err = InvalidUri;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<Uri, InvalidUri> {\n        Uri::try_from(s.as_bytes())\n    }\n}', "impl Hash for Uri {\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        if !self.scheme.inner.is_none() {\n            self.scheme.hash(state);\n            state.write_u8(0xff);\n        }\n\n        if let Some(auth) = self.authority() {\n            auth.hash(state);\n        }\n\n        Hash::hash_slice(self.path().as_bytes(), state);\n\n        if let Some(query) = self.query() {\n            b'?'.hash(state);\n            Hash::hash_slice(query.as_bytes(), state);\n        }\n    }\n}", 'impl PartialEq for Uri {\n    fn eq(&self, other: &Uri) -> bool {\n        if self.scheme() != other.scheme() {\n            return false;\n        }\n\n        if self.authority() != other.authority() {\n            return false;\n        }\n\n        if self.path() != other.path() {\n            return false;\n        }\n\n        if self.query() != other.query() {\n            return false;\n        }\n\n        true\n    }\n}', 'impl PartialEq<str> for Uri {\n    fn eq(&self, other: &str) -> bool {\n        let mut other = other.as_bytes();\n        let mut absolute = false;\n\n        if let Some(scheme) = self.scheme() {\n            let scheme = scheme.as_str().as_bytes();\n            absolute = true;\n\n            if other.len() < scheme.len() + 3 {\n                return false;\n            }\n\n            if !scheme.eq_ignore_ascii_case(&other[..scheme.len()]) {\n                return false;\n            }\n\n            other = &other[scheme.len()..];\n\n            if &other[..3] != b"://" {\n                return false;\n            }\n\n            other = &other[3..];\n        }\n\n        if let Some(auth) = self.authority() {\n            let len = auth.data.len();\n            absolute = true;\n\n            if other.len() < len {\n                return false;\n            }\n\n            if !auth.data.as_bytes().eq_ignore_ascii_case(&other[..len]) {\n                return false;\n            }\n\n            other = &other[len..];\n        }\n\n        let path = self.path();\n\n        if other.len() < path.len() || path.as_bytes() != &other[..path.len()] {\n            if absolute && path == "/" {\n                // PathAndQuery can be omitted, fall through\n            } else {\n                return false;\n            }\n        } else {\n            other = &other[path.len()..];\n        }\n\n        if let Some(query) = self.query() {\n            if other.is_empty() {\n                return query.is_empty();\n            }\n\n            if other[0] != b\'?\' {\n                return false;\n            }\n\n            other = &other[1..];\n\n            if other.len() < query.len() {\n                return false;\n            }\n\n            if query.as_bytes() != &other[..query.len()] {\n                return false;\n            }\n\n            other = &other[query.len()..];\n        }\n\n        other.is_empty() || other[0] == b\'#\'\n    }\n}', 'impl TryFrom<Parts> for Uri {\n    type Error = InvalidUriParts;\n\n    #[inline]\n    fn try_from(src: Parts) -> Result<Self, Self::Error> {\n        Uri::from_parts(src)\n    }\n}', 'impl TryFrom<String> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: String) -> Result<Self, Self::Error> {\n        Uri::from_shared(Bytes::from(t))\n    }\n}', 'impl TryFrom<Vec<u8>> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {\n        Uri::from_shared(Bytes::from(vec))\n    }\n}', 'impl Uri {\n    /// Creates a new builder-style object to manufacture a `Uri`.\n    ///\n    /// This method returns an instance of `Builder` which can be usd to\n    /// create a `Uri`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use http::Uri;\n    ///\n    /// let uri = Uri::builder()\n    ///     .scheme("https")\n    ///     .authority("hyper.rs")\n    ///     .path_and_query("/")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn builder() -> Builder {\n        Builder::new()\n    }\n\n    /// Attempt to convert a `Parts` into a `Uri`.\n    ///\n    /// # Examples\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let mut parts = Parts::default();\n    /// parts.path_and_query = Some("/foo".parse().unwrap());\n    ///\n    /// let uri = Uri::from_parts(parts).unwrap();\n    ///\n    /// assert_eq!(uri.path(), "/foo");\n    ///\n    /// assert!(uri.scheme().is_none());\n    /// assert!(uri.authority().is_none());\n    /// ```\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let mut parts = Parts::default();\n    /// parts.scheme = Some("http".parse().unwrap());\n    /// parts.authority = Some("foo.com".parse().unwrap());\n    /// parts.path_and_query = Some("/foo".parse().unwrap());\n    ///\n    /// let uri = Uri::from_parts(parts).unwrap();\n    ///\n    /// assert_eq!(uri.scheme().unwrap().as_str(), "http");\n    /// assert_eq!(uri.authority().unwrap(), "foo.com");\n    /// assert_eq!(uri.path(), "/foo");\n    /// ```\n    pub fn from_parts(src: Parts) -> Result<Uri, InvalidUriParts> {\n        if src.scheme.is_some() {\n            if src.authority.is_none() {\n                return Err(ErrorKind::AuthorityMissing.into());\n            }\n\n            if src.path_and_query.is_none() {\n                return Err(ErrorKind::PathAndQueryMissing.into());\n            }\n        } else if src.authority.is_some() && src.path_and_query.is_some() {\n            return Err(ErrorKind::SchemeMissing.into());\n        }\n\n        let scheme = match src.scheme {\n            Some(scheme) => scheme,\n            None => Scheme {\n                inner: Scheme2::None,\n            },\n        };\n\n        let authority = match src.authority {\n            Some(authority) => authority,\n            None => Authority::empty(),\n        };\n\n        let path_and_query = match src.path_and_query {\n            Some(path_and_query) => path_and_query,\n            None => PathAndQuery::empty(),\n        };\n\n        Ok(Uri {\n            scheme,\n            authority,\n            path_and_query,\n        })\n    }\n\n    /// Attempt to convert a `Bytes` buffer to a `Uri`.\n    ///\n    /// This will try to prevent a copy if the type passed is the type used\n    /// internally, and will copy the data if it is not.\n    pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + \'static,\n    {\n        if_downcast_into!(T, Bytes, src, {\n            return Uri::from_shared(src);\n        });\n\n        Uri::try_from(src.as_ref())\n    }\n\n    // Not public while `bytes` is unstable.\n    fn from_shared(s: Bytes) -> Result<Uri, InvalidUri> {\n        use self::ErrorKind::*;\n\n        if s.len() > MAX_LEN {\n            return Err(TooLong.into());\n        }\n\n        match s.len() {\n            0 => {\n                return Err(Empty.into());\n            }\n            1 => match s[0] {\n                b\'/\' => {\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority: Authority::empty(),\n                        path_and_query: PathAndQuery::slash(),\n                    });\n                }\n                b\'*\' => {\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority: Authority::empty(),\n                        path_and_query: PathAndQuery::star(),\n                    });\n                }\n                _ => {\n                    let authority = Authority::from_shared(s)?;\n\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority,\n                        path_and_query: PathAndQuery::empty(),\n                    });\n                }\n            },\n            _ => {}\n        }\n\n        if s[0] == b\'/\' {\n            return Ok(Uri {\n                scheme: Scheme::empty(),\n                authority: Authority::empty(),\n                path_and_query: PathAndQuery::from_shared(s)?,\n            });\n        }\n\n        parse_full(s)\n    }\n\n    /// Convert a `Uri` from a static string.\n    ///\n    /// This function will not perform any copying, however the string is\n    /// checked to ensure that it is valid.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument is an invalid URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::Uri;\n    /// let uri = Uri::from_static("http://example.com/foo");\n    ///\n    /// assert_eq!(uri.host().unwrap(), "example.com");\n    /// assert_eq!(uri.path(), "/foo");\n    /// ```\n    pub fn from_static(src: &\'static str) -> Self {\n        let s = Bytes::from_static(src.as_bytes());\n        match Uri::from_shared(s) {\n            Ok(uri) => uri,\n            Err(e) => panic!("static str is not valid URI: {}", e),\n        }\n    }\n\n    /// Convert a `Uri` into `Parts`.\n    ///\n    /// # Note\n    ///\n    /// This is just an inherent method providing the same functionality as\n    /// `let parts: Parts = uri.into()`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let uri: Uri = "/foo".parse().unwrap();\n    ///\n    /// let parts = uri.into_parts();\n    ///\n    /// assert_eq!(parts.path_and_query.unwrap(), "/foo");\n    ///\n    /// assert!(parts.scheme.is_none());\n    /// assert!(parts.authority.is_none());\n    /// ```\n    #[inline]\n    pub fn into_parts(self) -> Parts {\n        self.into()\n    }\n\n    /// Returns the path & query components of the Uri\n    #[inline]\n    pub fn path_and_query(&self) -> Option<&PathAndQuery> {\n        if !self.scheme.inner.is_none() || self.authority.data.is_empty() {\n            Some(&self.path_and_query)\n        } else {\n            None\n        }\n    }\n\n    /// Get the path of this `Uri`.\n    ///\n    /// Both relative and absolute URIs contain a path component, though it\n    /// might be the empty string. The path component is **case sensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                        |--------|\n    ///                                             |\n    ///                                           path\n    /// ```\n    ///\n    /// If the URI is `*` then the path component is equal to `*`.\n    ///\n    /// # Examples\n    ///\n    /// A relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    ///\n    /// let uri: Uri = "/hello/world".parse().unwrap();\n    ///\n    /// assert_eq!(uri.path(), "/hello/world");\n    /// ```\n    ///\n    /// An absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n    ///\n    /// assert_eq!(uri.path(), "/hello/world");\n    /// ```\n    #[inline]\n    pub fn path(&self) -> &str {\n        if self.has_path() {\n            self.path_and_query.path()\n        } else {\n            ""\n        }\n    }\n\n    /// Get the scheme of this `Uri`.\n    ///\n    /// The URI scheme refers to a specification for assigning identifiers\n    /// within that scheme. Only absolute URIs contain a scheme component, but\n    /// not all absolute URIs will contain a scheme component.  Although scheme\n    /// names are case-insensitive, the canonical form is lowercase.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    /// |-|\n    ///  |\n    /// scheme\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// use http::uri::{Scheme, Uri};\n    ///\n    /// let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n    ///\n    /// assert_eq!(uri.scheme(), Some(&Scheme::HTTP));\n    /// ```\n    ///\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "/hello/world".parse().unwrap();\n    ///\n    /// assert!(uri.scheme().is_none());\n    /// ```\n    #[inline]\n    pub fn scheme(&self) -> Option<&Scheme> {\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(&self.scheme)\n        }\n    }\n\n    /// Get the scheme of this `Uri` as a `&str`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n    ///\n    /// assert_eq!(uri.scheme_str(), Some("http"));\n    /// ```\n    #[inline]\n    pub fn scheme_str(&self) -> Option<&str> {\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(self.scheme.as_str())\n        }\n    }\n\n    /// Get the authority of this `Uri`.\n    ///\n    /// The authority is a hierarchical element for naming authority such that\n    /// the remainder of the URI is delegated to that authority. For HTTP, the\n    /// authority consists of the host and port. The host portion of the\n    /// authority is **case-insensitive**.\n    ///\n    /// The authority also includes a `username:password` component, however\n    /// the use of this is deprecated and should be avoided.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///       |-------------------------------|\n    ///                     |\n    ///                 authority\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n    ///\n    /// assert_eq!(uri.authority().map(|a| a.as_str()), Some("example.org:80"));\n    /// ```\n    ///\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "/hello/world".parse().unwrap();\n    ///\n    /// assert!(uri.authority().is_none());\n    /// ```\n    #[inline]\n    pub fn authority(&self) -> Option<&Authority> {\n        if self.authority.data.is_empty() {\n            None\n        } else {\n            Some(&self.authority)\n        }\n    }\n\n    /// Get the host of this `Uri`.\n    ///\n    /// The host subcomponent of authority is identified by an IP literal\n    /// encapsulated within square brackets, an IPv4 address in dotted- decimal\n    /// form, or a registered name.  The host subcomponent is **case-insensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                         |---------|\n    ///                              |\n    ///                             host\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n    ///\n    /// assert_eq!(uri.host(), Some("example.org"));\n    /// ```\n    ///\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "/hello/world".parse().unwrap();\n    ///\n    /// assert!(uri.host().is_none());\n    /// ```\n    #[inline]\n    pub fn host(&self) -> Option<&str> {\n        self.authority().map(|a| a.host())\n    }\n\n    /// Get the port part of this `Uri`.\n    ///\n    /// The port subcomponent of authority is designated by an optional port\n    /// number following the host and delimited from it by a single colon (":")\n    /// character. It can be turned into a decimal port number with the `as_u16`\n    /// method or as a `str` with the `as_str` method.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                     |-|\n    ///                                      |\n    ///                                     port\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI with port\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n    ///\n    /// let port = uri.port().unwrap();\n    /// assert_eq!(port.as_u16(), 80);\n    /// ```\n    ///\n    /// Absolute URI without port\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n    ///\n    /// assert!(uri.port().is_none());\n    /// ```\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "/hello/world".parse().unwrap();\n    ///\n    /// assert!(uri.port().is_none());\n    /// ```\n    pub fn port(&self) -> Option<Port<&str>> {\n        self.authority().and_then(|a| a.port())\n    }\n\n    /// Get the port of this `Uri` as a `u16`.\n    ///\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::{Uri, uri::Port};\n    /// let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n    ///\n    /// assert_eq!(uri.port_u16(), Some(80));\n    /// ```\n    pub fn port_u16(&self) -> Option<u16> {\n        self.port().map(|p| p.as_u16())\n    }\n\n    /// Get the query string of this `Uri`, starting after the `?`.\n    ///\n    /// The query component contains non-hierarchical data that, along with data\n    /// in the path component, serves to identify a resource within the scope of\n    /// the URI\'s scheme and naming authority (if any). The query component is\n    /// indicated by the first question mark ("?") character and terminated by a\n    /// number sign ("#") character or by the end of the URI.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                                   |-------------------|\n    ///                                                             |\n    ///                                                           query\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "http://example.org/hello/world?key=value".parse().unwrap();\n    ///\n    /// assert_eq!(uri.query(), Some("key=value"));\n    /// ```\n    ///\n    /// Relative URI with a query string component\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "/hello/world?key=value&foo=bar".parse().unwrap();\n    ///\n    /// assert_eq!(uri.query(), Some("key=value&foo=bar"));\n    /// ```\n    ///\n    /// Relative URI without a query string component\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = "/hello/world".parse().unwrap();\n    ///\n    /// assert!(uri.query().is_none());\n    /// ```\n    #[inline]\n    pub fn query(&self) -> Option<&str> {\n        self.path_and_query.query()\n    }\n\n    fn has_path(&self) -> bool {\n        !self.path_and_query.data.is_empty() || !self.scheme.inner.is_none()\n    }\n}', "impl fmt::Debug for Uri {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}", 'impl fmt::Display for Uri {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        if let Some(scheme) = self.scheme() {\n            write!(f, "{}://", scheme)?;\n        }\n\n        if let Some(authority) = self.authority() {\n            write!(f, "{}", authority)?;\n        }\n\n        write!(f, "{}", self.path())?;\n\n        if let Some(query) = self.query() {\n            write!(f, "?{}", query)?;\n        }\n\n        Ok(())\n    }\n}', "impl<'a> PartialEq<&'a str> for Uri {\n    fn eq(&self, other: &&'a str) -> bool {\n        self == *other\n    }\n}", "impl<'a> TryFrom<&'a String> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: &'a String) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}", "impl<'a> TryFrom<&'a Uri> for Uri {\n    type Error = crate::Error;\n\n    #[inline]\n    fn try_from(src: &'a Uri) -> Result<Self, Self::Error> {\n        Ok(src.clone())\n    }\n}", "impl<'a> TryFrom<&'a [u8]> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        Uri::from_shared(Bytes::copy_from_slice(t))\n    }\n}", "impl<'a> TryFrom<&'a str> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}"], 'uri::authority::Authority': ['Clone', 'impl AsRef<str> for Authority {\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}', 'impl Authority {\n    pub(super) fn empty() -> Self {\n        Authority {\n            data: ByteStr::new(),\n        }\n    }\n\n    // Not public while `bytes` is unstable.\n    pub(super) fn from_shared(s: Bytes) -> Result<Self, InvalidUri> {\n        // Precondition on create_authority: trivially satisfied by the\n        // identity closure\n        create_authority(s, |s| s)\n    }\n\n    /// Attempt to convert an `Authority` from a static string.\n    ///\n    /// This function will not perform any copying, and the string will be\n    /// checked if it is empty or contains an invalid character.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument contains invalid characters or\n    /// is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority = Authority::from_static("example.com");\n    /// assert_eq!(authority.host(), "example.com");\n    /// ```\n    pub fn from_static(src: &\'static str) -> Self {\n        Authority::from_shared(Bytes::from_static(src.as_bytes()))\n            .expect("static str is not valid authority")\n    }\n\n    /// Attempt to convert a `Bytes` buffer to a `Authority`.\n    ///\n    /// This will try to prevent a copy if the type passed is the type used\n    /// internally, and will copy the data if it is not.\n    pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + \'static,\n    {\n        if_downcast_into!(T, Bytes, src, {\n            return Authority::from_shared(src);\n        });\n\n        Authority::try_from(src.as_ref())\n    }\n\n    // Note: this may return an *empty* Authority. You might want `parse_non_empty`.\n    // Postcondition: for all Ok() returns, s[..ret.unwrap()] is valid UTF-8 where\n    // ret is the return value.\n    pub(super) fn parse(s: &[u8]) -> Result<usize, InvalidUri> {\n        let mut colon_cnt = 0u32;\n        let mut start_bracket = false;\n        let mut end_bracket = false;\n        let mut has_percent = false;\n        let mut end = s.len();\n        let mut at_sign_pos = None;\n        const MAX_COLONS: u32 = 8; // e.g., [FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:80\n\n        // Among other things, this loop checks that every byte in s up to the\n        // first \'/\', \'?\', or \'#\' is a valid URI character (or in some contexts,\n        // a \'%\'). This means that each such byte is a valid single-byte UTF-8\n        // code point.\n        for (i, &b) in s.iter().enumerate() {\n            match URI_CHARS[b as usize] {\n                b\'/\' | b\'?\' | b\'#\' => {\n                    end = i;\n                    break;\n                }\n                b\':\' => {\n                    if colon_cnt >= MAX_COLONS {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    colon_cnt += 1;\n                }\n                b\'[\' => {\n                    if has_percent || start_bracket {\n                        // Something other than the userinfo has a `%`, so reject it.\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    start_bracket = true;\n                }\n                b\']\' => {\n                    if (!start_bracket) || end_bracket {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    end_bracket = true;\n\n                    // Those were part of an IPv6 hostname, so forget them...\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                b\'@\' => {\n                    at_sign_pos = Some(i);\n\n                    // Those weren\'t a port colon, but part of the\n                    // userinfo, so it needs to be forgotten.\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                0 if b == b\'%\' => {\n                    // Per https://tools.ietf.org/html/rfc3986#section-3.2.1 and\n                    // https://url.spec.whatwg.org/#authority-state\n                    // the userinfo can have a percent-encoded username and password,\n                    // so record that a `%` was found. If this turns out to be\n                    // part of the userinfo, this flag will be cleared.\n                    // Also per https://tools.ietf.org/html/rfc6874, percent-encoding can\n                    // be used to indicate a zone identifier.\n                    // If the flag hasn\'t been cleared at the end, that means this\n                    // was part of the hostname (and not part of an IPv6 address), and\n                    // will fail with an error.\n                    has_percent = true;\n                }\n                0 => {\n                    return Err(ErrorKind::InvalidUriChar.into());\n                }\n                _ => {}\n            }\n        }\n\n        if start_bracket ^ end_bracket {\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if colon_cnt > 1 {\n            // Things like \'localhost:8080:3030\' are rejected.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if end > 0 && at_sign_pos == Some(end - 1) {\n            // If there\'s nothing after an `@`, this is bonkers.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if has_percent {\n            // Something after the userinfo has a `%`, so reject it.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        Ok(end)\n    }\n\n    // Parse bytes as an Authority, not allowing an empty string.\n    //\n    // This should be used by functions that allow a user to parse\n    // an `Authority` by itself.\n    //\n    // Postcondition: for all Ok() returns, s[..ret.unwrap()] is valid UTF-8 where\n    // ret is the return value.\n    fn parse_non_empty(s: &[u8]) -> Result<usize, InvalidUri> {\n        if s.is_empty() {\n            return Err(ErrorKind::Empty.into());\n        }\n        Authority::parse(s)\n    }\n\n    /// Get the host of this `Authority`.\n    ///\n    /// The host subcomponent of authority is identified by an IP literal\n    /// encapsulated within square brackets, an IPv4 address in dotted- decimal\n    /// form, or a registered name.  The host subcomponent is **case-insensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                         |---------|\n    ///                              |\n    ///                             host\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let authority: Authority = "example.org:80".parse().unwrap();\n    ///\n    /// assert_eq!(authority.host(), "example.org");\n    /// ```\n    #[inline]\n    pub fn host(&self) -> &str {\n        host(self.as_str())\n    }\n\n    /// Get the port part of this `Authority`.\n    ///\n    /// The port subcomponent of authority is designated by an optional port\n    /// number following the host and delimited from it by a single colon (":")\n    /// character. It can be turned into a decimal port number with the `as_u16`\n    /// method or as a `str` with the `as_str` method.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                     |-|\n    ///                                      |\n    ///                                     port\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Authority with port\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = "example.org:80".parse().unwrap();\n    ///\n    /// let port = authority.port().unwrap();\n    /// assert_eq!(port.as_u16(), 80);\n    /// assert_eq!(port.as_str(), "80");\n    /// ```\n    ///\n    /// Authority without port\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = "example.org".parse().unwrap();\n    ///\n    /// assert!(authority.port().is_none());\n    /// ```\n    pub fn port(&self) -> Option<Port<&str>> {\n        let bytes = self.as_str();\n        bytes\n            .rfind(\':\')\n            .and_then(|i| Port::from_str(&bytes[i + 1..]).ok())\n    }\n\n    /// Get the port of this `Authority` as a `u16`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = "example.org:80".parse().unwrap();\n    ///\n    /// assert_eq!(authority.port_u16(), Some(80));\n    /// ```\n    pub fn port_u16(&self) -> Option<u16> {\n        self.port().map(|p| p.as_u16())\n    }\n\n    /// Return a str representation of the authority\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        &self.data[..]\n    }\n}', 'impl Eq for Authority {}', 'impl FromStr for Authority {\n    type Err = InvalidUri;\n\n    fn from_str(s: &str) -> Result<Self, InvalidUri> {\n        TryFrom::try_from(s)\n    }\n}', 'impl Hash for Authority {\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.data.len().hash(state);\n        for &b in self.data.as_bytes() {\n            state.write_u8(b.to_ascii_lowercase());\n        }\n    }\n}', 'impl PartialEq for Authority {\n    fn eq(&self, other: &Authority) -> bool {\n        self.data.eq_ignore_ascii_case(&other.data)\n    }\n}', 'impl PartialEq<String> for Authority {\n    fn eq(&self, other: &String) -> bool {\n        self.data.eq_ignore_ascii_case(other.as_str())\n    }\n}', 'impl PartialEq<str> for Authority {\n    fn eq(&self, other: &str) -> bool {\n        self.data.eq_ignore_ascii_case(other)\n    }\n}', 'impl PartialOrd for Authority {\n    fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}', 'impl PartialOrd<String> for Authority {\n    fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}', 'impl PartialOrd<str> for Authority {\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}', 'impl TryFrom<String> for Authority {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: String) -> Result<Self, Self::Error> {\n        Authority::from_shared(t.into())\n    }\n}', 'impl TryFrom<Vec<u8>> for Authority {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {\n        Authority::from_shared(vec.into())\n    }\n}', "impl fmt::Debug for Authority {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}", "impl fmt::Display for Authority {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}", "impl<'a> PartialEq<&'a str> for Authority {\n    fn eq(&self, other: &&'a str) -> bool {\n        self.data.eq_ignore_ascii_case(other)\n    }\n}", "impl<'a> PartialOrd<&'a str> for Authority {\n    fn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}", "impl<'a> TryFrom<&'a [u8]> for Authority {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        // parse first, and only turn into Bytes if valid\n\n        // Preconditon on create_authority: copy_from_slice() copies all of\n        // bytes from the [u8] parameter into a new Bytes\n        create_authority(s, Bytes::copy_from_slice)\n    }\n}", "impl<'a> TryFrom<&'a str> for Authority {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        TryFrom::try_from(s.as_bytes())\n    }\n}"], 'uri::builder::Builder': ['Debug', 'impl Builder {\n    /// Creates a new default instance of `Builder` to construct a `Uri`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = uri::Builder::new()\n    ///     .scheme("https")\n    ///     .authority("hyper.rs")\n    ///     .path_and_query("/")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn new() -> Builder {\n        Builder::default()\n    }\n\n    /// Set the `Scheme` for this URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let mut builder = uri::Builder::new();\n    /// builder.scheme("https");\n    /// ```\n    pub fn scheme<T>(self, scheme: T) -> Self\n    where\n        T: TryInto<Scheme>,\n        <T as TryInto<Scheme>>::Error: Into<crate::Error>,\n    {\n        self.map(move |mut parts| {\n            let scheme = scheme.try_into().map_err(Into::into)?;\n            parts.scheme = Some(scheme);\n            Ok(parts)\n        })\n    }\n\n    /// Set the `Authority` for this URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = uri::Builder::new()\n    ///     .authority("tokio.rs")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn authority<T>(self, auth: T) -> Self\n    where\n        T: TryInto<Authority>,\n        <T as TryInto<Authority>>::Error: Into<crate::Error>,\n    {\n        self.map(move |mut parts| {\n            let auth = auth.try_into().map_err(Into::into)?;\n            parts.authority = Some(auth);\n            Ok(parts)\n        })\n    }\n\n    /// Set the `PathAndQuery` for this URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = uri::Builder::new()\n    ///     .path_and_query("/hello?foo=bar")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn path_and_query<T>(self, p_and_q: T) -> Self\n    where\n        T: TryInto<PathAndQuery>,\n        <T as TryInto<PathAndQuery>>::Error: Into<crate::Error>,\n    {\n        self.map(move |mut parts| {\n            let p_and_q = p_and_q.try_into().map_err(Into::into)?;\n            parts.path_and_query = Some(p_and_q);\n            Ok(parts)\n        })\n    }\n\n    /// Consumes this builder, and tries to construct a valid `Uri` from\n    /// the configured pieces.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if any previously configured argument\n    /// failed to parse or get converted to the internal representation. For\n    /// example if an invalid `scheme` was specified via `scheme("!@#%/^")`\n    /// the error will be returned when this function is called rather than\n    /// when `scheme` was called.\n    ///\n    /// Additionally, the various forms of URI require certain combinations of\n    /// parts to be set to be valid. If the parts don\'t fit into any of the\n    /// valid forms of URI, a new error is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = Uri::builder()\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn build(self) -> Result<Uri, crate::Error> {\n        let parts = self.parts?;\n        Uri::from_parts(parts).map_err(Into::into)\n    }\n\n    // private\n\n    fn map<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts, crate::Error>,\n    {\n        Builder {\n            parts: self.parts.and_then(func),\n        }\n    }\n}', 'impl Default for Builder {\n    #[inline]\n    fn default() -> Builder {\n        Builder {\n            parts: Ok(Parts::default()),\n        }\n    }\n}', 'impl From<Uri> for Builder {\n    fn from(uri: Uri) -> Self {\n        Self {\n            parts: Ok(uri.into_parts()),\n        }\n    }\n}'], 'uri::path::PathAndQuery': ['Clone', 'impl Eq for PathAndQuery {}', 'impl FromStr for PathAndQuery {\n    type Err = InvalidUri;\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, InvalidUri> {\n        TryFrom::try_from(s)\n    }\n}', 'impl PartialEq for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &PathAndQuery) -> bool {\n        self.data == other.data\n    }\n}', 'impl PartialEq<String> for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n        self.as_str() == other.as_str()\n    }\n}', 'impl PartialEq<str> for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        self.as_str() == other\n    }\n}', 'impl PartialOrd for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other.as_str())\n    }\n}', 'impl PartialOrd<String> for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other.as_str())\n    }\n}', 'impl PartialOrd<str> for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other)\n    }\n}', 'impl PathAndQuery {\n    // Not public while `bytes` is unstable.\n    pub(super) fn from_shared(mut src: Bytes) -> Result<Self, InvalidUri> {\n        let mut query = NONE;\n        let mut fragment = None;\n\n        let mut is_maybe_not_utf8 = false;\n\n        // block for iterator borrow\n        {\n            let mut iter = src.as_ref().iter().enumerate();\n\n            // path ...\n            for (i, &b) in &mut iter {\n                // See https://url.spec.whatwg.org/#path-state\n                match b {\n                    b\'?\' => {\n                        debug_assert_eq!(query, NONE);\n                        query = i as u16;\n                        break;\n                    }\n                    b\'#\' => {\n                        fragment = Some(i);\n                        break;\n                    }\n\n                    // This is the range of bytes that don\'t need to be\n                    // percent-encoded in the path. If it should have been\n                    // percent-encoded, then error.\n                    #[rustfmt::skip]\n                    0x21 |\n                    0x24..=0x3B |\n                    0x3D |\n                    0x40..=0x5F |\n                    0x61..=0x7A |\n                    0x7C |\n                    0x7E => {}\n\n                    // potentially utf8, might not, should check\n                    0x7F..=0xFF => {\n                        is_maybe_not_utf8 = true;\n                    }\n\n                    // These are code points that are supposed to be\n                    // percent-encoded in the path but there are clients\n                    // out there sending them as is and httparse accepts\n                    // to parse those requests, so they are allowed here\n                    // for parity.\n                    //\n                    // For reference, those are code points that are used\n                    // to send requests with JSON directly embedded in\n                    // the URI path. Yes, those things happen for real.\n                    #[rustfmt::skip]\n                    b\'"\' |\n                    b\'{\' | b\'}\' => {}\n\n                    _ => return Err(ErrorKind::InvalidUriChar.into()),\n                }\n            }\n\n            // query ...\n            if query != NONE {\n                for (i, &b) in iter {\n                    match b {\n                        // While queries *should* be percent-encoded, most\n                        // bytes are actually allowed...\n                        // See https://url.spec.whatwg.org/#query-state\n                        //\n                        // Allowed: 0x21 / 0x24 - 0x3B / 0x3D / 0x3F - 0x7E\n                        #[rustfmt::skip]\n                        0x21 |\n                        0x24..=0x3B |\n                        0x3D |\n                        0x3F..=0x7E => {}\n\n                        0x7F..=0xFF => {\n                            is_maybe_not_utf8 = true;\n                        }\n\n                        b\'#\' => {\n                            fragment = Some(i);\n                            break;\n                        }\n\n                        _ => return Err(ErrorKind::InvalidUriChar.into()),\n                    }\n                }\n            }\n        }\n\n        if let Some(i) = fragment {\n            src.truncate(i);\n        }\n\n        let data = if is_maybe_not_utf8 {\n            ByteStr::from_utf8(src).map_err(|_| ErrorKind::InvalidUriChar)?\n        } else {\n            unsafe { ByteStr::from_utf8_unchecked(src) }\n        };\n\n        Ok(PathAndQuery { data, query })\n    }\n\n    /// Convert a `PathAndQuery` from a static string.\n    ///\n    /// This function will not perform any copying, however the string is\n    /// checked to ensure that it is valid.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument is an invalid path and query.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let v = PathAndQuery::from_static("/hello?world");\n    ///\n    /// assert_eq!(v.path(), "/hello");\n    /// assert_eq!(v.query(), Some("world"));\n    /// ```\n    #[inline]\n    pub fn from_static(src: &\'static str) -> Self {\n        let src = Bytes::from_static(src.as_bytes());\n\n        PathAndQuery::from_shared(src).unwrap()\n    }\n\n    /// Attempt to convert a `Bytes` buffer to a `PathAndQuery`.\n    ///\n    /// This will try to prevent a copy if the type passed is the type used\n    /// internally, and will copy the data if it is not.\n    pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + \'static,\n    {\n        if_downcast_into!(T, Bytes, src, {\n            return PathAndQuery::from_shared(src);\n        });\n\n        PathAndQuery::try_from(src.as_ref())\n    }\n\n    pub(super) fn empty() -> Self {\n        PathAndQuery {\n            data: ByteStr::new(),\n            query: NONE,\n        }\n    }\n\n    pub(super) fn slash() -> Self {\n        PathAndQuery {\n            data: ByteStr::from_static("/"),\n            query: NONE,\n        }\n    }\n\n    pub(super) fn star() -> Self {\n        PathAndQuery {\n            data: ByteStr::from_static("*"),\n            query: NONE,\n        }\n    }\n\n    /// Returns the path component\n    ///\n    /// The path component is **case sensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                        |--------|\n    ///                                             |\n    ///                                           path\n    /// ```\n    ///\n    /// If the URI is `*` then the path component is equal to `*`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    ///\n    /// let path_and_query: PathAndQuery = "/hello/world".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.path(), "/hello/world");\n    /// ```\n    #[inline]\n    pub fn path(&self) -> &str {\n        let ret = if self.query == NONE {\n            &self.data[..]\n        } else {\n            &self.data[..self.query as usize]\n        };\n\n        if ret.is_empty() {\n            return "/";\n        }\n\n        ret\n    }\n\n    /// Returns the query string component\n    ///\n    /// The query component contains non-hierarchical data that, along with data\n    /// in the path component, serves to identify a resource within the scope of\n    /// the URI\'s scheme and naming authority (if any). The query component is\n    /// indicated by the first question mark ("?") character and terminated by a\n    /// number sign ("#") character or by the end of the URI.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                                   |-------------------|\n    ///                                                             |\n    ///                                                           query\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// With a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = "/hello/world?key=value&foo=bar".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.query(), Some("key=value&foo=bar"));\n    /// ```\n    ///\n    /// Without a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = "/hello/world".parse().unwrap();\n    ///\n    /// assert!(path_and_query.query().is_none());\n    /// ```\n    #[inline]\n    pub fn query(&self) -> Option<&str> {\n        if self.query == NONE {\n            None\n        } else {\n            let i = self.query + 1;\n            Some(&self.data[i as usize..])\n        }\n    }\n\n    /// Returns the path and query as a string component.\n    ///\n    /// # Examples\n    ///\n    /// With a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = "/hello/world?key=value&foo=bar".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.as_str(), "/hello/world?key=value&foo=bar");\n    /// ```\n    ///\n    /// Without a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = "/hello/world".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.as_str(), "/hello/world");\n    /// ```\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        let ret = &self.data[..];\n        if ret.is_empty() {\n            return "/";\n        }\n        ret\n    }\n}', 'impl TryFrom<&String> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &String) -> Result<Self, Self::Error> {\n        TryFrom::try_from(s.as_bytes())\n    }\n}', 'impl TryFrom<String> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: String) -> Result<Self, Self::Error> {\n        PathAndQuery::from_shared(s.into())\n    }\n}', 'impl TryFrom<Vec<u8>> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {\n        PathAndQuery::from_shared(vec.into())\n    }\n}', "impl fmt::Debug for PathAndQuery {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}", 'impl fmt::Display for PathAndQuery {\n    fn fmt(&self, fmt: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        if !self.data.is_empty() {\n            match self.data.as_bytes()[0] {\n                b\'/\' | b\'*\' => write!(fmt, "{}", &self.data[..]),\n                _ => write!(fmt, "/{}", &self.data[..]),\n            }\n        } else {\n            write!(fmt, "/")\n        }\n    }\n}', 'impl hash::Hash for PathAndQuery {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        self.data.hash(state);\n    }\n}', "impl<'a> PartialEq<&'a str> for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &&'a str) -> bool {\n        self.as_str() == *other\n    }\n}", "impl<'a> PartialOrd<&'a str> for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(*other)\n    }\n}", "impl<'a> TryFrom<&'a [u8]> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        PathAndQuery::from_shared(Bytes::copy_from_slice(s))\n    }\n}", "impl<'a> TryFrom<&'a str> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        TryFrom::try_from(s.as_bytes())\n    }\n}"], 'uri::port::Port': ['impl<T, U> PartialEq<Port<U>> for Port<T> {\n    fn eq(&self, other: &Port<U>) -> bool {\n        self.port == other.port\n    }\n}', 'impl<T> AsRef<str> for Port<T>\nwhere\n    T: AsRef<str>,\n{\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}', 'impl<T> PartialEq<u16> for Port<T> {\n    fn eq(&self, other: &u16) -> bool {\n        self.port == *other\n    }\n}', 'impl<T> Port<T>\nwhere\n    T: AsRef<str>,\n{\n    /// Converts a `str` to a port number.\n    ///\n    /// The supplied `str` must be a valid u16.\n    pub(crate) fn from_str(bytes: T) -> Result<Self, InvalidUri> {\n        bytes\n            .as_ref()\n            .parse::<u16>()\n            .map(|port| Port { port, repr: bytes })\n            .map_err(|_| ErrorKind::InvalidPort.into())\n    }\n\n    /// Returns the port number as a `str`.\n    ///\n    /// # Examples\n    ///\n    /// Port as `str`.\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = "example.org:80".parse().unwrap();\n    ///\n    /// let port = authority.port().unwrap();\n    /// assert_eq!(port.as_str(), "80");\n    /// ```\n    pub fn as_str(&self) -> &str {\n        self.repr.as_ref()\n    }\n}', 'impl<T> Port<T> {\n    /// Returns the port number as a `u16`.\n    ///\n    /// # Examples\n    ///\n    /// Port as `u16`.\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = "example.org:80".parse().unwrap();\n    ///\n    /// let port = authority.port().unwrap();\n    /// assert_eq!(port.as_u16(), 80);\n    /// ```\n    pub const fn as_u16(&self) -> u16 {\n        self.port\n    }\n}', 'impl<T> fmt::Debug for Port<T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_tuple("Port").field(&self.port).finish()\n    }\n}', "impl<T> fmt::Display for Port<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Use `u16::fmt` so that it respects any formatting flags that\n        // may have been set (like padding, align, etc).\n        fmt::Display::fmt(&self.port, f)\n    }\n}"], 'uri::scheme::Protocol': ['Clone', 'Copy', 'Debug', 'impl Protocol {\n    pub(super) fn len(&self) -> usize {\n        match *self {\n            Protocol::Http => 4,\n            Protocol::Https => 5,\n        }\n    }\n}'], 'uri::scheme::Scheme': ['Clone', 'impl AsRef<str> for Scheme {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}', 'impl Eq for Scheme {}', 'impl From<Scheme2> for Scheme {\n    fn from(src: Scheme2) -> Self {\n        Scheme { inner: src }\n    }\n}', 'impl FromStr for Scheme {\n    type Err = InvalidUri;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        TryFrom::try_from(s)\n    }\n}', 'impl Hash for Scheme {\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        match self.inner {\n            Scheme2::None => (),\n            Scheme2::Standard(Protocol::Http) => state.write_u8(1),\n            Scheme2::Standard(Protocol::Https) => state.write_u8(2),\n            Scheme2::Other(ref other) => {\n                other.len().hash(state);\n                for &b in other.as_bytes() {\n                    state.write_u8(b.to_ascii_lowercase());\n                }\n            }\n        }\n    }\n}', 'impl PartialEq for Scheme {\n    fn eq(&self, other: &Scheme) -> bool {\n        use self::Protocol::*;\n        use self::Scheme2::*;\n\n        match (&self.inner, &other.inner) {\n            (&Standard(Http), &Standard(Http)) => true,\n            (&Standard(Https), &Standard(Https)) => true,\n            (Other(a), Other(b)) => a.eq_ignore_ascii_case(b),\n            (&None, _) | (_, &None) => unreachable!(),\n            _ => false,\n        }\n    }\n}', 'impl PartialEq<str> for Scheme {\n    fn eq(&self, other: &str) -> bool {\n        self.as_str().eq_ignore_ascii_case(other)\n    }\n}', 'impl Scheme {\n    /// HTTP protocol scheme\n    pub const HTTP: Scheme = Scheme {\n        inner: Scheme2::Standard(Protocol::Http),\n    };\n\n    /// HTTP protocol over TLS.\n    pub const HTTPS: Scheme = Scheme {\n        inner: Scheme2::Standard(Protocol::Https),\n    };\n\n    pub(super) fn empty() -> Self {\n        Scheme {\n            inner: Scheme2::None,\n        }\n    }\n\n    /// Return a str representation of the scheme\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let scheme: Scheme = "http".parse().unwrap();\n    /// assert_eq!(scheme.as_str(), "http");\n    /// ```\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        use self::Protocol::*;\n        use self::Scheme2::*;\n\n        match self.inner {\n            Standard(Http) => "http",\n            Standard(Https) => "https",\n            Other(ref v) => &v[..],\n            None => unreachable!(),\n        }\n    }\n}', "impl fmt::Debug for Scheme {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.as_str(), f)\n    }\n}", "impl fmt::Display for Scheme {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}", "impl<'a> TryFrom<&'a [u8]> for Scheme {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        use self::Scheme2::*;\n\n        match Scheme2::parse_exact(s)? {\n            None => Err(ErrorKind::InvalidScheme.into()),\n            Standard(p) => Ok(Standard(p).into()),\n            Other(_) => {\n                let bytes = Bytes::copy_from_slice(s);\n\n                // Safety: postcondition on parse_exact() means that s and\n                // hence bytes are valid UTF-8.\n                let string = unsafe { ByteStr::from_utf8_unchecked(bytes) };\n\n                Ok(Other(Box::new(string)).into())\n            }\n        }\n    }\n}", "impl<'a> TryFrom<&'a str> for Scheme {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        TryFrom::try_from(s.as_bytes())\n    }\n}"], 'uri::scheme::Scheme2': ['Clone', 'Debug', 'impl Scheme2<usize> {\n    // Postcondition: On all Ok() returns, s is valid UTF-8\n    fn parse_exact(s: &[u8]) -> Result<Scheme2<()>, InvalidUri> {\n        match s {\n            b"http" => Ok(Protocol::Http.into()),\n            b"https" => Ok(Protocol::Https.into()),\n            _ => {\n                if s.len() > MAX_SCHEME_LEN {\n                    return Err(ErrorKind::SchemeTooLong.into());\n                }\n\n                // check that each byte in s is a SCHEME_CHARS which implies\n                // that it is a valid single byte UTF-8 code point.\n                for &b in s {\n                    match SCHEME_CHARS[b as usize] {\n                        b\':\' => {\n                            // Don\'t want :// here\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        0 => {\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        _ => {}\n                    }\n                }\n\n                Ok(Scheme2::Other(()))\n            }\n        }\n    }\n\n    pub(super) fn parse(s: &[u8]) -> Result<Scheme2<usize>, InvalidUri> {\n        if s.len() >= 7 {\n            // Check for HTTP\n            if s[..7].eq_ignore_ascii_case(b"http://") {\n                // Prefix will be striped\n                return Ok(Protocol::Http.into());\n            }\n        }\n\n        if s.len() >= 8 {\n            // Check for HTTPs\n            if s[..8].eq_ignore_ascii_case(b"https://") {\n                return Ok(Protocol::Https.into());\n            }\n        }\n\n        if s.len() > 3 {\n            for i in 0..s.len() {\n                let b = s[i];\n\n                match SCHEME_CHARS[b as usize] {\n                    b\':\' => {\n                        // Not enough data remaining\n                        if s.len() < i + 3 {\n                            break;\n                        }\n\n                        // Not a scheme\n                        if &s[i + 1..i + 3] != b"//" {\n                            break;\n                        }\n\n                        if i > MAX_SCHEME_LEN {\n                            return Err(ErrorKind::SchemeTooLong.into());\n                        }\n\n                        // Return scheme\n                        return Ok(Scheme2::Other(i));\n                    }\n                    // Invalid scheme character, abort\n                    0 => break,\n                    _ => {}\n                }\n            }\n        }\n\n        Ok(Scheme2::None)\n    }\n}', 'impl<T> From<Protocol> for Scheme2<T> {\n    fn from(src: Protocol) -> Self {\n        Scheme2::Standard(src)\n    }\n}', 'impl<T> Scheme2<T> {\n    pub(super) fn is_none(&self) -> bool {\n        matches!(*self, Scheme2::None)\n    }\n}'], 'version::Http': ['Clone', 'Copy', 'Eq', 'Hash', 'Ord', 'PartialEq', 'PartialOrd'], 'version::Version': ['Clone', 'Copy', 'Eq', 'Hash', 'Ord', 'PartialEq', 'PartialOrd', 'impl Default for Version {\n    #[inline]\n    fn default() -> Version {\n        Version::HTTP_11\n    }\n}', 'impl Version {\n    /// `HTTP/0.9`\n    pub const HTTP_09: Version = Version(Http::Http09);\n\n    /// `HTTP/1.0`\n    pub const HTTP_10: Version = Version(Http::Http10);\n\n    /// `HTTP/1.1`\n    pub const HTTP_11: Version = Version(Http::Http11);\n\n    /// `HTTP/2.0`\n    pub const HTTP_2: Version = Version(Http::H2);\n\n    /// `HTTP/3.0`\n    pub const HTTP_3: Version = Version(Http::H3);\n}', 'impl fmt::Debug for Version {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        use self::Http::*;\n\n        f.write_str(match self.0 {\n            Http09 => "HTTP/0.9",\n            Http10 => "HTTP/1.0",\n            Http11 => "HTTP/1.1",\n            H2 => "HTTP/2.0",\n            H3 => "HTTP/3.0",\n            __NonExhaustive => unreachable!(),\n        })\n    }\n}']}, 'single_path_import': {'error::Error': 'Error', 'error::Result': 'Result', 'extensions::Extensions': 'Extensions', 'header::map::Drain': 'header::Drain', 'header::map::Entry': 'header::Entry', 'header::map::GetAll': 'header::GetAll', 'header::map::HeaderMap': 'HeaderMap', 'header::map::IntoIter': 'header::IntoIter', 'header::map::Iter': 'header::Iter', 'header::map::IterMut': 'header::IterMut', 'header::map::Keys': 'header::Keys', 'header::map::MaxSizeReached': 'header::MaxSizeReached', 'header::map::OccupiedEntry': 'header::OccupiedEntry', 'header::map::VacantEntry': 'header::VacantEntry', 'header::map::ValueDrain': 'header::ValueDrain', 'header::map::ValueIter': 'header::ValueIter', 'header::map::ValueIterMut': 'header::ValueIterMut', 'header::map::Values': 'header::Values', 'header::map::ValuesMut': 'header::ValuesMut', 'header::map::as_header_name::AsHeaderName': 'header::AsHeaderName', 'header::map::into_header_name::IntoHeaderName': 'header::IntoHeaderName', 'header::name::ACCEPT': 'header::ACCEPT', 'header::name::ACCEPT_CHARSET': 'header::ACCEPT_CHARSET', 'header::name::ACCEPT_ENCODING': 'header::ACCEPT_ENCODING', 'header::name::ACCEPT_LANGUAGE': 'header::ACCEPT_LANGUAGE', 'header::name::ACCEPT_RANGES': 'header::ACCEPT_RANGES', 'header::name::ACCESS_CONTROL_ALLOW_CREDENTIALS': 'header::ACCESS_CONTROL_ALLOW_CREDENTIALS', 'header::name::ACCESS_CONTROL_ALLOW_HEADERS': 'header::ACCESS_CONTROL_ALLOW_HEADERS', 'header::name::ACCESS_CONTROL_ALLOW_METHODS': 'header::ACCESS_CONTROL_ALLOW_METHODS', 'header::name::ACCESS_CONTROL_ALLOW_ORIGIN': 'header::ACCESS_CONTROL_ALLOW_ORIGIN', 'header::name::ACCESS_CONTROL_EXPOSE_HEADERS': 'header::ACCESS_CONTROL_EXPOSE_HEADERS', 'header::name::ACCESS_CONTROL_MAX_AGE': 'header::ACCESS_CONTROL_MAX_AGE', 'header::name::ACCESS_CONTROL_REQUEST_HEADERS': 'header::ACCESS_CONTROL_REQUEST_HEADERS', 'header::name::ACCESS_CONTROL_REQUEST_METHOD': 'header::ACCESS_CONTROL_REQUEST_METHOD', 'header::name::AGE': 'header::AGE', 'header::name::ALLOW': 'header::ALLOW', 'header::name::ALT_SVC': 'header::ALT_SVC', 'header::name::AUTHORIZATION': 'header::AUTHORIZATION', 'header::name::CACHE_CONTROL': 'header::CACHE_CONTROL', 'header::name::CACHE_STATUS': 'header::CACHE_STATUS', 'header::name::CDN_CACHE_CONTROL': 'header::CDN_CACHE_CONTROL', 'header::name::CONNECTION': 'header::CONNECTION', 'header::name::CONTENT_DISPOSITION': 'header::CONTENT_DISPOSITION', 'header::name::CONTENT_ENCODING': 'header::CONTENT_ENCODING', 'header::name::CONTENT_LANGUAGE': 'header::CONTENT_LANGUAGE', 'header::name::CONTENT_LENGTH': 'header::CONTENT_LENGTH', 'header::name::CONTENT_LOCATION': 'header::CONTENT_LOCATION', 'header::name::CONTENT_RANGE': 'header::CONTENT_RANGE', 'header::name::CONTENT_SECURITY_POLICY': 'header::CONTENT_SECURITY_POLICY', 'header::name::CONTENT_SECURITY_POLICY_REPORT_ONLY': 'header::CONTENT_SECURITY_POLICY_REPORT_ONLY', 'header::name::CONTENT_TYPE': 'header::CONTENT_TYPE', 'header::name::COOKIE': 'header::COOKIE', 'header::name::DATE': 'header::DATE', 'header::name::DNT': 'header::DNT', 'header::name::ETAG': 'header::ETAG', 'header::name::EXPECT': 'header::EXPECT', 'header::name::EXPIRES': 'header::EXPIRES', 'header::name::FORWARDED': 'header::FORWARDED', 'header::name::FROM': 'header::FROM', 'header::name::HOST': 'header::HOST', 'header::name::HeaderName': 'HeaderName', 'header::name::IF_MATCH': 'header::IF_MATCH', 'header::name::IF_MODIFIED_SINCE': 'header::IF_MODIFIED_SINCE', 'header::name::IF_NONE_MATCH': 'header::IF_NONE_MATCH', 'header::name::IF_RANGE': 'header::IF_RANGE', 'header::name::IF_UNMODIFIED_SINCE': 'header::IF_UNMODIFIED_SINCE', 'header::name::InvalidHeaderName': 'header::InvalidHeaderName', 'header::name::LAST_MODIFIED': 'header::LAST_MODIFIED', 'header::name::LINK': 'header::LINK', 'header::name::LOCATION': 'header::LOCATION', 'header::name::MAX_FORWARDS': 'header::MAX_FORWARDS', 'header::name::ORIGIN': 'header::ORIGIN', 'header::name::PRAGMA': 'header::PRAGMA', 'header::name::PROXY_AUTHENTICATE': 'header::PROXY_AUTHENTICATE', 'header::name::PROXY_AUTHORIZATION': 'header::PROXY_AUTHORIZATION', 'header::name::PUBLIC_KEY_PINS': 'header::PUBLIC_KEY_PINS', 'header::name::PUBLIC_KEY_PINS_REPORT_ONLY': 'header::PUBLIC_KEY_PINS_REPORT_ONLY', 'header::name::RANGE': 'header::RANGE', 'header::name::REFERER': 'header::REFERER', 'header::name::REFERRER_POLICY': 'header::REFERRER_POLICY', 'header::name::REFRESH': 'header::REFRESH', 'header::name::RETRY_AFTER': 'header::RETRY_AFTER', 'header::name::SEC_WEBSOCKET_ACCEPT': 'header::SEC_WEBSOCKET_ACCEPT', 'header::name::SEC_WEBSOCKET_EXTENSIONS': 'header::SEC_WEBSOCKET_EXTENSIONS', 'header::name::SEC_WEBSOCKET_KEY': 'header::SEC_WEBSOCKET_KEY', 'header::name::SEC_WEBSOCKET_PROTOCOL': 'header::SEC_WEBSOCKET_PROTOCOL', 'header::name::SEC_WEBSOCKET_VERSION': 'header::SEC_WEBSOCKET_VERSION', 'header::name::SERVER': 'header::SERVER', 'header::name::SET_COOKIE': 'header::SET_COOKIE', 'header::name::STRICT_TRANSPORT_SECURITY': 'header::STRICT_TRANSPORT_SECURITY', 'header::name::TE': 'header::TE', 'header::name::TRAILER': 'header::TRAILER', 'header::name::TRANSFER_ENCODING': 'header::TRANSFER_ENCODING', 'header::name::UPGRADE': 'header::UPGRADE', 'header::name::UPGRADE_INSECURE_REQUESTS': 'header::UPGRADE_INSECURE_REQUESTS', 'header::name::USER_AGENT': 'header::USER_AGENT', 'header::name::VARY': 'header::VARY', 'header::name::VIA': 'header::VIA', 'header::name::WARNING': 'header::WARNING', 'header::name::WWW_AUTHENTICATE': 'header::WWW_AUTHENTICATE', 'header::name::X_CONTENT_TYPE_OPTIONS': 'header::X_CONTENT_TYPE_OPTIONS', 'header::name::X_DNS_PREFETCH_CONTROL': 'header::X_DNS_PREFETCH_CONTROL', 'header::name::X_FRAME_OPTIONS': 'header::X_FRAME_OPTIONS', 'header::name::X_XSS_PROTECTION': 'header::X_XSS_PROTECTION', 'header::value::HeaderValue': 'HeaderValue', 'header::value::InvalidHeaderValue': 'header::InvalidHeaderValue', 'header::value::ToStrError': 'header::ToStrError', 'method::Method': 'Method', 'request::Request': 'Request', 'response::Response': 'Response', 'status::StatusCode': 'StatusCode', 'uri::Uri': 'Uri', 'uri::authority::Authority': 'uri::Authority', 'uri::builder::Builder': 'uri::Builder', 'uri::path::PathAndQuery': 'uri::PathAndQuery', 'uri::port::Port': 'uri::Port', 'uri::scheme::Scheme': 'uri::Scheme', 'version::Version': 'Version'}, 'srcs': {"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": ["fn into_iter(self) -> Iter<'a, T>{\n        self.iter()\n    }", 'Real(LocalPath("src/header/map.rs"))'], "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str": ['fn as_str(&self) -> &str{\n            <HeaderName>::as_str(self)\n        }', 'Real(LocalPath("src/header/map.rs"))'], "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find": ['#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            map.find(*self)\n        }', 'Real(LocalPath("src/header/map.rs"))'], "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry": ["#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>{\n            Ok(map.try_entry2(self)?)\n        }", 'Real(LocalPath("src/header/map.rs"))'], "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_append": ['#[inline]\nfn try_append<T>(self, map: &mut HeaderMap<T>, val: T) -> Result<bool, MaxSizeReached>{\n            map.try_append2(self, val)\n        }', 'Real(LocalPath("src/header/map.rs"))'], "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry": ["#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, MaxSizeReached>{\n            map.try_entry2(self)\n        }", 'Real(LocalPath("src/header/map.rs"))'], "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert": ['#[inline]\nfn try_insert<T>(\n            self,\n            map: &mut HeaderMap<T>,\n            val: T,\n        ) -> Result<Option<T>, MaxSizeReached>{\n            map.try_insert2(self, val)\n        }', 'Real(LocalPath("src/header/map.rs"))'], "<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq": ['#[inline]\nfn eq(&self, other: &HeaderName) -> bool{\n        *other == *self\n    }', 'Real(LocalPath("src/header/name.rs"))'], "<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq": ['#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        **self == *other\n    }', 'Real(LocalPath("src/header/value.rs"))'], "<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp": ['#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        (**self).partial_cmp(other)\n    }', 'Real(LocalPath("src/header/value.rs"))'], "<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq": ['#[inline]\nfn eq(&self, other: &Method) -> bool{\n        *self == other\n    }', 'Real(LocalPath("src/method.rs"))'], "<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": ["fn into_iter(self) -> IterMut<'a, T>{\n        self.iter_mut()\n    }", 'Real(LocalPath("src/header/map.rs"))'], "<&'a std::string::String as header::map::as_header_name::Sealed>::as_str": ['fn as_str(&self) -> &str{\n            self\n        }', 'Real(LocalPath("src/header/map.rs"))'], "<&'a std::string::String as header::map::as_header_name::Sealed>::find": ['#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            Sealed::find(*self, map)\n        }', 'Real(LocalPath("src/header/map.rs"))'], "<&'a std::string::String as header::map::as_header_name::Sealed>::try_entry": ["#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>{\n            self.as_str().try_entry(map)\n        }", 'Real(LocalPath("src/header/map.rs"))'], "<&'a str as header::map::as_header_name::Sealed>::as_str": ['fn as_str(&self) -> &str{\n            self\n        }', 'Real(LocalPath("src/header/map.rs"))'], "<&'a str as header::map::as_header_name::Sealed>::find": ['#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            HdrName::from_bytes(self.as_bytes(), move |hdr| map.find(&hdr)).unwrap_or(None)\n        }', 'Real(LocalPath("src/header/map.rs"))'], "<&'a str as header::map::as_header_name::Sealed>::try_entry": ["#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>{\n            Ok(HdrName::from_bytes(self.as_bytes(), move |hdr| {\n                map.try_entry2(hdr)\n            })??)\n        }", 'Real(LocalPath("src/header/map.rs"))'], "<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": ["fn into_iter(self) -> ValueIter<'a, T>{\n        self.map.value_iter(self.index)\n    }", 'Real(LocalPath("src/header/map.rs"))'], "<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": ["fn into_iter(self) -> ValueIter<'a, T>{\n        self.iter()\n    }", 'Real(LocalPath("src/header/map.rs"))'], "<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": ["fn into_iter(self) -> ValueIterMut<'a, T>{\n        self.iter_mut()\n    }", 'Real(LocalPath("src/header/map.rs"))'], "<&'static str as header::map::into_header_name::Sealed>::try_append": ['#[inline]\nfn try_append<T>(self, map: &mut HeaderMap<T>, val: T) -> Result<bool, MaxSizeReached>{\n            HdrName::from_static(self, move |hdr| map.try_append2(hdr, val))\n        }', 'Real(LocalPath("src/header/map.rs"))'], "<&'static str as header::map::into_header_name::Sealed>::try_entry": ["#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, MaxSizeReached>{\n            HdrName::from_static(self, move |hdr| map.try_entry2(hdr))\n        }", 'Real(LocalPath("src/header/map.rs"))'], "<&'static str as header::map::into_header_name::Sealed>::try_insert": ['#[inline]\nfn try_insert<T>(\n            self,\n            map: &mut HeaderMap<T>,\n            val: T,\n        ) -> Result<Option<T>, MaxSizeReached>{\n            HdrName::from_static(self, move |hdr| map.try_insert2(hdr, val))\n        }', 'Real(LocalPath("src/header/map.rs"))'], '<T as extensions::AnyClone>::as_any': ['fn as_any(&self) -> &dyn Any{\n        self\n    }', 'Real(LocalPath("src/extensions.rs"))'], '<T as extensions::AnyClone>::as_any_mut': ['fn as_any_mut(&mut self) -> &mut dyn Any{\n        self\n    }', 'Real(LocalPath("src/extensions.rs"))'], '<T as extensions::AnyClone>::clone_box': ['fn clone_box(&self) -> Box<dyn AnyClone + Send + Sync>{\n        Box::new(self.clone())\n    }', 'Real(LocalPath("src/extensions.rs"))'], '<T as extensions::AnyClone>::into_any': ['fn into_any(self: Box<Self>) -> Box<dyn Any>{\n        self\n    }', 'Real(LocalPath("src/extensions.rs"))'], "<byte_str::ByteStr as std::convert::From<&'a str>>::from": ["#[inline]\nfn from(src: &'a str) -> ByteStr{\n        ByteStr {\n            // Invariant: src is a str so contains valid UTF-8.\n            bytes: Bytes::copy_from_slice(src.as_bytes()),\n        }\n    }", 'Real(LocalPath("src/byte_str.rs"))'], '<byte_str::ByteStr as std::convert::From<std::string::String>>::from': ['#[inline]\nfn from(src: String) -> ByteStr{\n        ByteStr {\n            // Invariant: src is a String so contains valid UTF-8.\n            bytes: Bytes::from(src),\n        }\n    }', 'Real(LocalPath("src/byte_str.rs"))'], '<byte_str::ByteStr as std::ops::Deref>::deref': ['#[inline]\nfn deref(&self) -> &str{\n        let b: &[u8] = self.bytes.as_ref();\n        // Safety: the invariant of `bytes` is that it contains valid UTF-8.\n        unsafe { str::from_utf8_unchecked(b) }\n    }', 'Real(LocalPath("src/byte_str.rs"))'], '<error::Error as std::convert::From<header::map::MaxSizeReached>>::from': ['fn from(err: MaxSizeReached) -> Error{\n        Error {\n            inner: ErrorKind::MaxSizeReached(err),\n        }\n    }', 'Real(LocalPath("src/error.rs"))'], '<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from': ['fn from(err: header::InvalidHeaderName) -> Error{\n        Error {\n            inner: ErrorKind::HeaderName(err),\n        }\n    }', 'Real(LocalPath("src/error.rs"))'], '<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from': ['fn from(err: header::InvalidHeaderValue) -> Error{\n        Error {\n            inner: ErrorKind::HeaderValue(err),\n        }\n    }', 'Real(LocalPath("src/error.rs"))'], '<error::Error as std::convert::From<method::InvalidMethod>>::from': ['fn from(err: method::InvalidMethod) -> Error{\n        Error {\n            inner: ErrorKind::Method(err),\n        }\n    }', 'Real(LocalPath("src/error.rs"))'], '<error::Error as std::convert::From<status::InvalidStatusCode>>::from': ['fn from(err: status::InvalidStatusCode) -> Error{\n        Error {\n            inner: ErrorKind::StatusCode(err),\n        }\n    }', 'Real(LocalPath("src/error.rs"))'], '<error::Error as std::convert::From<std::convert::Infallible>>::from': ['fn from(err: std::convert::Infallible) -> Error{\n        match err {}\n    }', 'Real(LocalPath("src/error.rs"))'], '<error::Error as std::convert::From<uri::InvalidUri>>::from': ['fn from(err: uri::InvalidUri) -> Error{\n        Error {\n            inner: ErrorKind::Uri(err),\n        }\n    }', 'Real(LocalPath("src/error.rs"))'], '<error::Error as std::convert::From<uri::InvalidUriParts>>::from': ['fn from(err: uri::InvalidUriParts) -> Error{\n        Error {\n            inner: ErrorKind::UriParts(err),\n        }\n    }', 'Real(LocalPath("src/error.rs"))'], '<error::Error as std::error::Error>::source': ["fn source(&self) -> Option<&(dyn error::Error + 'static)>{\n        self.get_ref().source()\n    }", 'Real(LocalPath("src/error.rs"))'], '<error::Error as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_tuple("http::Error")\n            // Skip the noise of the ErrorKind enum\n            .field(&self.get_ref())\n            .finish()\n    }', 'Real(LocalPath("src/error.rs"))'], '<error::Error as std::fmt::Display>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self.get_ref(), f)\n    }", 'Real(LocalPath("src/error.rs"))'], '<extensions::Extensions as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("Extensions").finish()\n    }', 'Real(LocalPath("src/extensions.rs"))'], '<extensions::IdHasher as std::hash::Hasher>::finish': ['#[inline]\nfn finish(&self) -> u64{\n        self.0\n    }', 'Real(LocalPath("src/extensions.rs"))'], '<extensions::IdHasher as std::hash::Hasher>::write': ['fn write(&mut self, _: &[u8]){\n        unreachable!("TypeId calls write_u64");\n    }', 'Real(LocalPath("src/extensions.rs"))'], '<extensions::IdHasher as std::hash::Hasher>::write_u64': ['#[inline]\nfn write_u64(&mut self, id: u64){\n        self.0 = id;\n    }', 'Real(LocalPath("src/extensions.rs"))'], "<header::map::Drain<'a, T> as std::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        if let Some(next) = self.next {\n            // Remove the extra value\n\n            let raw_links = RawLinks(self.entries);\n            let extra = unsafe { remove_extra_value(raw_links, &mut *self.extra_values, next) };\n\n            match extra.next {\n                Link::Extra(idx) => self.next = Some(idx),\n                Link::Entry(_) => self.next = None,\n            }\n\n            return Some((None, extra.value));\n        }\n\n        let idx = self.idx;\n\n        if idx == self.len {\n            return None;\n        }\n\n        self.idx += 1;\n\n        unsafe {\n            let entry = &(*self.entries)[idx];\n\n            // Read the header name\n            let key = ptr::read(&entry.key as *const _);\n            let value = ptr::read(&entry.value as *const _);\n            self.next = entry.links.map(|l| l.next);\n\n            Some((Some(key), value))\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint": ["fn size_hint(&self) -> (usize, Option<usize>){\n        // At least this many names... It's unknown if the user wants\n        // to count the extra_values on top.\n        //\n        // For instance, extending a new `HeaderMap` wouldn't need to\n        // reserve the upper-bound in `entries`, only the lower-bound.\n        let lower = self.len - self.idx;\n        let upper = unsafe { (*self.extra_values).len() } + lower;\n        (lower, Some(upper))\n    }", 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Drain<'a, T> as std::ops::Drop>::drop": ['fn drop(&mut self){\n        for _ in self {}\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq": ['fn eq(&self, other: &Self) -> bool{\n        self.iter().eq(other.iter())\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": ["fn into_iter(self) -> ValueIter<'a, T>{\n        self.map.value_iter(self.index)\n    }", 'Real(LocalPath("src/header/map.rs"))'], '<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq': ['fn eq(&self, other: &HeaderMap<T>) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.keys()\n            .all(|key| self.get_all(key) == other.get_all(key))\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V, S>>>::try_from": ["fn try_from(c: &'a HashMap<K, V, S>) -> Result<Self, Self::Error>{\n        c.iter()\n            .map(|(k, v)| -> crate::Result<(HeaderName, T)> {\n                let name = TryFrom::try_from(k).map_err(Into::into)?;\n                let value = TryFrom::try_from(v).map_err(Into::into)?;\n                Ok((name, value))\n            })\n            .collect()\n    }", 'Real(LocalPath("src/header/map.rs"))'], '<header::map::HeaderMap<T> as std::default::Default>::default': ['fn default() -> Self{\n        HeaderMap::try_with_capacity(0).expect("zero capacity should never fail")\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::HeaderMap<T> as std::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_map().entries(self.iter()).finish()\n    }", 'Real(LocalPath("src/header/map.rs"))'], '<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend': ['fn extend<I: IntoIterator<Item = (HeaderName, T)>>(&mut self, iter: I){\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let iter = iter.into_iter();\n\n        let reserve = if self.is_empty() {\n            iter.size_hint().0\n        } else {\n            (iter.size_hint().0 + 1) / 2\n        };\n\n        self.reserve(reserve);\n\n        for (k, v) in iter {\n            self.append(k, v);\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend': ['/// Extend a `HeaderMap` with the contents of another `HeaderMap`.\n///\n/// This function expects the yielded items to follow the same structure as\n/// `IntoIter`.\n///\n/// # Panics\n///\n/// This panics if the first yielded item does not have a `HeaderName`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(ACCEPT, "text/plain".parse().unwrap());\n/// map.insert(HOST, "hello.world".parse().unwrap());\n///\n/// let mut extra = HeaderMap::new();\n///\n/// extra.insert(HOST, "foo.bar".parse().unwrap());\n/// extra.insert(COOKIE, "hello".parse().unwrap());\n/// extra.append(COOKIE, "world".parse().unwrap());\n///\n/// map.extend(extra);\n///\n/// assert_eq!(map["host"], "foo.bar");\n/// assert_eq!(map["accept"], "text/plain");\n/// assert_eq!(map["cookie"], "hello");\n///\n/// let v = map.get_all("host");\n/// assert_eq!(1, v.iter().count());\n///\n/// let v = map.get_all("cookie");\n/// assert_eq!(2, v.iter().count());\n/// ```\nfn extend<I: IntoIterator<Item = (Option<HeaderName>, T)>>(&mut self, iter: I){\n        let mut iter = iter.into_iter();\n\n        // The structure of this is a bit weird, but it is mostly to make the\n        // borrow checker happy.\n        let (mut key, mut val) = match iter.next() {\n            Some((Some(key), val)) => (key, val),\n            Some((None, _)) => panic!("expected a header name, but got None"),\n            None => return,\n        };\n\n        \'outer: loop {\n            let mut entry = match self.try_entry2(key).expect("size overflows MAX_SIZE") {\n                Entry::Occupied(mut e) => {\n                    // Replace all previous values while maintaining a handle to\n                    // the entry.\n                    e.insert(val);\n                    e\n                }\n                Entry::Vacant(e) => e.insert_entry(val),\n            };\n\n            // As long as `HeaderName` is none, keep inserting the value into\n            // the current entry\n            loop {\n                match iter.next() {\n                    Some((Some(k), v)) => {\n                        key = k;\n                        val = v;\n                        continue \'outer;\n                    }\n                    Some((None, v)) => {\n                        entry.append(v);\n                    }\n                    None => {\n                        return;\n                    }\n                }\n            }\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter': ['fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (HeaderName, T)>,{\n        let mut map = HeaderMap::default();\n        map.extend(iter);\n        map\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter': ['/// Creates a consuming iterator, that is, one that moves keys and values\n/// out of the map in arbitrary order. The map cannot be used after calling\n/// this.\n///\n/// For each yielded item that has `None` provided for the `HeaderName`,\n/// then the associated header name is the same as that of the previously\n/// yielded item. The first yielded item will have `HeaderName` set.\n///\n/// # Examples\n///\n/// Basic usage.\n///\n/// ```\n/// # use http::header;\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n/// map.insert(header::CONTENT_LENGTH, "123".parse().unwrap());\n/// map.insert(header::CONTENT_TYPE, "json".parse().unwrap());\n///\n/// let mut iter = map.into_iter();\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), "123".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), "json".parse().unwrap())));\n/// assert!(iter.next().is_none());\n/// ```\n///\n/// Multiple values per key.\n///\n/// ```\n/// # use http::header;\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// map.append(header::CONTENT_LENGTH, "123".parse().unwrap());\n/// map.append(header::CONTENT_LENGTH, "456".parse().unwrap());\n///\n/// map.append(header::CONTENT_TYPE, "json".parse().unwrap());\n/// map.append(header::CONTENT_TYPE, "html".parse().unwrap());\n/// map.append(header::CONTENT_TYPE, "xml".parse().unwrap());\n///\n/// let mut iter = map.into_iter();\n///\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), "123".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, "456".parse().unwrap())));\n///\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), "json".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, "html".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, "xml".parse().unwrap())));\n/// assert!(iter.next().is_none());\n/// ```\nfn into_iter(self) -> IntoIter<T>{\n        IntoIter {\n            next: None,\n            entries: self.entries.into_iter(),\n            extra_values: self.extra_values,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::HeaderMap<T> as std::ops::Index<K>>::index': ['/// # Panics\n/// Using the index operator will cause a panic if the header you\'re querying isn\'t set.\n#[inline]\nfn index(&self, index: K) -> &T{\n        match self.get2(&index) {\n            Some(val) => val,\n            None => panic!("no entry found for key {:?}", index.as_str()),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::IntoIter<T> as std::iter::Iterator>::next': ['fn next(&mut self) -> Option<Self::Item>{\n        if let Some(next) = self.next {\n            self.next = match self.extra_values[next].next {\n                Link::Entry(_) => None,\n                Link::Extra(v) => Some(v),\n            };\n\n            let value = unsafe { ptr::read(&self.extra_values[next].value) };\n\n            return Some((None, value));\n        }\n\n        if let Some(bucket) = self.entries.next() {\n            self.next = bucket.links.map(|l| l.next);\n            let name = Some(bucket.key);\n            let value = bucket.value;\n\n            return Some((name, value));\n        }\n\n        None\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::IntoIter<T> as std::iter::Iterator>::size_hint': ['fn size_hint(&self) -> (usize, Option<usize>){\n        let (lower, _) = self.entries.size_hint();\n        // There could be more than just the entries upper, as there\n        // could be items in the `extra_values`. We could guess, saying\n        // `upper + extra_values.len()`, but that could overestimate by a lot.\n        (lower, None)\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::IntoIter<T> as std::ops::Drop>::drop': ['fn drop(&mut self){\n        // Ensure the iterator is consumed\n        for _ in self.by_ref() {}\n\n        // All the values have already been yielded out.\n        unsafe {\n            self.extra_values.set_len(0);\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Iter<'a, T> as std::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        if self.cursor.is_none() {\n            if (self.entry + 1) >= self.map.entries.len() {\n                return None;\n            }\n\n            self.entry += 1;\n            self.cursor = Some(Cursor::Head);\n        }\n\n        let entry = &self.map.entries[self.entry];\n\n        match self.cursor.unwrap() {\n            Head => {\n                self.cursor = entry.links.map(|l| Values(l.next));\n                Some((&entry.key, &entry.value))\n            }\n            Values(idx) => {\n                let extra = &self.map.extra_values[idx];\n\n                match extra.next {\n                    Link::Entry(_) => self.cursor = None,\n                    Link::Extra(i) => self.cursor = Some(Values(i)),\n                }\n\n                Some((&entry.key, &extra.value))\n            }\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint": ["fn size_hint(&self) -> (usize, Option<usize>){\n        let map = self.map;\n        debug_assert!(map.entries.len() >= self.entry);\n\n        let lower = map.entries.len() - self.entry;\n        // We could pessimistically guess at the upper bound, saying\n        // that its lower + map.extra_values.len(). That could be\n        // way over though, such as if we're near the end, and have\n        // already gone through several extra values...\n        (lower, None)\n    }", 'Real(LocalPath("src/header/map.rs"))'], "<header::map::IterMut<'a, T> as std::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        self.next_unsafe()\n            .map(|(key, ptr)| (key, unsafe { &mut *ptr }))\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint": ["fn size_hint(&self) -> (usize, Option<usize>){\n        let map = unsafe { &*self.map };\n        debug_assert!(map.entries.len() >= self.entry);\n\n        let lower = map.entries.len() - self.entry;\n        // We could pessimistically guess at the upper bound, saying\n        // that its lower + map.extra_values.len(). That could be\n        // way over though, such as if we're near the end, and have\n        // already gone through several extra values...\n        (lower, None)\n    }", 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Keys<'a, T> as std::iter::Iterator>::count": ['fn count(self) -> usize{\n        self.inner.count()\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Keys<'a, T> as std::iter::Iterator>::last": ['fn last(self) -> Option<Self::Item>{\n        self.inner.last().map(|b| &b.key)\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Keys<'a, T> as std::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|b| &b.key)\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Keys<'a, T> as std::iter::Iterator>::nth": ['fn nth(&mut self, n: usize) -> Option<Self::Item>{\n        self.inner.nth(n).map(|b| &b.key)\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint": ['fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::MaxSizeReached as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct("MaxSizeReached")\n            // skip _priv noise\n            .finish()\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::MaxSizeReached as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.write_str("max size reached")\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": ["fn into_iter(self) -> ValueIterMut<'a, T>{\n        self.map.value_iter_mut(self.index)\n    }", 'Real(LocalPath("src/header/map.rs"))'], '<header::map::RawLinks<T> as std::clone::Clone>::clone': ['fn clone(&self) -> RawLinks<T>{\n        *self\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::RawLinks<T> as std::ops::Index<usize>>::index': ['fn index(&self, idx: usize) -> &Self::Output{\n        unsafe { &(*self.0)[idx].links }\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut': ['fn index_mut(&mut self, idx: usize) -> &mut Self::Output{\n        unsafe { &mut (*self.0)[idx].links }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next": ['fn next(&mut self) -> Option<T>{\n        if self.first.is_some() {\n            self.first.take()\n        } else if let Some(ref mut extras) = self.next {\n            extras.next()\n        } else {\n            None\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint": ['fn size_hint(&self) -> (usize, Option<usize>){\n        match (&self.first, &self.next) {\n            // Exactly 1\n            (&Some(_), &None) => (1, Some(1)),\n            // 1 + extras\n            (&Some(_), Some(extras)) => {\n                let (l, u) = extras.size_hint();\n                (l + 1, u.map(|u| u + 1))\n            }\n            // Extras only\n            (&None, Some(extras)) => extras.size_hint(),\n            // No more\n            (&None, &None) => (0, Some(0)),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop": ['fn drop(&mut self){\n        for _ in self.by_ref() {}\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back": ['fn next_back(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&self.map.entries[self.index].value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::ValueIter<'a, T> as std::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        match self.front {\n            Some(Head) => {\n                let entry = &self.map.entries[self.index];\n\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint": ['fn size_hint(&self) -> (usize, Option<usize>){\n        match (self.front, self.back) {\n            // Exactly 1 value...\n            (Some(Cursor::Head), Some(Cursor::Head)) => (1, Some(1)),\n            // At least 1...\n            (Some(_), _) => (1, None),\n            // No more values...\n            (None, _) => (0, Some(0)),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back": ['fn next_back(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.front {\n            Some(Head) => {\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Values<'a, T> as std::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|(_, v)| v)\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::Values<'a, T> as std::iter::Iterator>::size_hint": ['fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|(_, v)| v)\n    }', 'Real(LocalPath("src/header/map.rs"))'], "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint": ['fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::as_header_name::TryEntryError as std::convert::From<header::map::MaxSizeReached>>::from': ['fn from(e: MaxSizeReached) -> TryEntryError{\n            TryEntryError::MaxSizeReached(e)\n        }', 'Real(LocalPath("src/header/map.rs"))'], '<header::map::as_header_name::TryEntryError as std::convert::From<header::name::InvalidHeaderName>>::from': ['fn from(e: InvalidHeaderName) -> TryEntryError{\n            TryEntryError::InvalidHeaderName(e)\n        }', 'Real(LocalPath("src/header/map.rs"))'], '<header::name::Custom as std::hash::Hash>::hash': ['#[inline]\nfn hash<H: Hasher>(&self, hasher: &mut H){\n        hasher.write(self.0.as_bytes())\n    }', 'Real(LocalPath("src/header/name.rs"))'], "<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from": ["fn from(hdr: StandardHeader) -> HdrName<'a>{\n        HdrName {\n            inner: Repr::Standard(hdr),\n        }\n    }", 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str': ['fn as_str(&self) -> &str{\n            <HeaderName>::as_str(self)\n        }', 'Real(LocalPath("src/header/map.rs"))'], '<header::name::HeaderName as header::map::as_header_name::Sealed>::find': ['#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            map.find(self)\n        }', 'Real(LocalPath("src/header/map.rs"))'], '<header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry': ["#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>{\n            Ok(map.try_entry2(self)?)\n        }", 'Real(LocalPath("src/header/map.rs"))'], '<header::name::HeaderName as header::map::into_header_name::Sealed>::try_append': ['#[inline]\nfn try_append<T>(self, map: &mut HeaderMap<T>, val: T) -> Result<bool, MaxSizeReached>{\n            map.try_append2(self, val)\n        }', 'Real(LocalPath("src/header/map.rs"))'], '<header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry': ["#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, MaxSizeReached>{\n            map.try_entry2(self)\n        }", 'Real(LocalPath("src/header/map.rs"))'], '<header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert': ['#[inline]\nfn try_insert<T>(\n            self,\n            map: &mut HeaderMap<T>,\n            val: T,\n        ) -> Result<Option<T>, MaxSizeReached>{\n            map.try_insert2(self, val)\n        }', 'Real(LocalPath("src/header/map.rs"))'], '<header::name::HeaderName as std::borrow::Borrow<str>>::borrow': ['fn borrow(&self) -> &str{\n        self.as_str()\n    }', 'Real(LocalPath("src/header/name.rs"))'], "<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq": ["#[inline]\nfn eq(&self, other: &&'a HeaderName) -> bool{\n        *self == **other\n    }", 'Real(LocalPath("src/header/name.rs"))'], "<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq": ["/// Performs a case-insensitive comparison of the string against the header\n/// name\n#[inline]\nfn eq(&self, other: &&'a str) -> bool{\n        *self == **other\n    }", 'Real(LocalPath("src/header/name.rs"))'], "<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq": ["#[inline]\nfn eq(&self, other: &HdrName<'a>) -> bool{\n        match self.inner {\n            Repr::Standard(a) => match other.inner {\n                Repr::Standard(b) => a == b,\n                _ => false,\n            },\n            Repr::Custom(Custom(ref a)) => match other.inner {\n                Repr::Custom(ref b) => {\n                    if b.lower {\n                        a.as_bytes() == b.buf\n                    } else {\n                        eq_ignore_ascii_case(a.as_bytes(), b.buf)\n                    }\n                }\n                _ => false,\n            },\n        }\n    }", 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as std::cmp::PartialEq<str>>::eq': ['/// Performs a case-insensitive comparison of the string against the header\n/// name\n///\n/// # Examples\n///\n/// ```\n/// use http::header::CONTENT_LENGTH;\n///\n/// assert_eq!(CONTENT_LENGTH, "content-length");\n/// assert_eq!(CONTENT_LENGTH, "Content-Length");\n/// assert_ne!(CONTENT_LENGTH, "content length");\n/// ```\n#[inline]\nfn eq(&self, other: &str) -> bool{\n        eq_ignore_ascii_case(self.as_ref(), other.as_bytes())\n    }', 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref': ['fn as_ref(&self) -> &[u8]{\n        self.as_str().as_bytes()\n    }', 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as std::convert::AsRef<str>>::as_ref': ['fn as_ref(&self) -> &str{\n        self.as_str()\n    }', 'Real(LocalPath("src/header/name.rs"))'], "<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from": ["fn from(src: &'a HeaderName) -> HeaderName{\n        src.clone()\n    }", 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as std::convert::From<header::name::Custom>>::from': ['fn from(src: Custom) -> HeaderName{\n        HeaderName {\n            inner: Repr::Custom(src),\n        }\n    }', 'Real(LocalPath("src/header/name.rs"))'], "<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from": ["fn from(src: HdrName<'a>) -> HeaderName{\n        match src.inner {\n            Repr::Standard(s) => HeaderName {\n                inner: Repr::Standard(s),\n            },\n            Repr::Custom(maybe_lower) => {\n                if maybe_lower.lower {\n                    let buf = Bytes::copy_from_slice(maybe_lower.buf);\n                    // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                    let byte_str = unsafe { ByteStr::from_utf8_unchecked(buf) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(byte_str)),\n                    }\n                } else {\n                    use bytes::BufMut;\n                    let mut dst = BytesMut::with_capacity(maybe_lower.buf.len());\n\n                    for b in maybe_lower.buf.iter() {\n                        // HEADER_CHARS maps each byte to a valid single-byte UTF-8\n                        // codepoint.\n                        dst.put_u8(HEADER_CHARS[*b as usize]);\n                    }\n\n                    // Safety: the loop above maps each byte of maybe_lower.buf to a\n                    // valid single-byte UTF-8 codepoint before copying it into dst.\n                    // dst (and hence dst.freeze()) is thus valid UTF-8.\n                    let buf = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(buf)),\n                    }\n                }\n            }\n        }\n    }", 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from': ['fn from(src: StandardHeader) -> HeaderName{\n        HeaderName {\n            inner: Repr::Standard(src),\n        }\n    }', 'Real(LocalPath("src/header/name.rs"))'], "<header::name::HeaderName as std::convert::TryFrom<&'a [u8]>>::try_from": ["#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        Self::from_bytes(s)\n    }", 'Real(LocalPath("src/header/name.rs"))'], "<header::name::HeaderName as std::convert::TryFrom<&'a std::string::String>>::try_from": ["#[inline]\nfn try_from(s: &'a String) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }", 'Real(LocalPath("src/header/name.rs"))'], "<header::name::HeaderName as std::convert::TryFrom<&'a str>>::try_from": ["#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }", 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as std::convert::TryFrom<std::string::String>>::try_from': ['#[inline]\nfn try_from(s: String) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }', 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['#[inline]\nfn try_from(vec: Vec<u8>) -> Result<Self, Self::Error>{\n        Self::from_bytes(&vec)\n    }', 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as std::fmt::Debug>::fmt': ["fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Debug::fmt(self.as_str(), fmt)\n    }", 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as std::fmt::Display>::fmt': ["fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self.as_str(), fmt)\n    }", 'Real(LocalPath("src/header/name.rs"))'], '<header::name::HeaderName as std::str::FromStr>::from_str': ['fn from_str(s: &str) -> Result<HeaderName, InvalidHeaderName>{\n        HeaderName::from_bytes(s.as_bytes()).map_err(|_| InvalidHeaderName { _priv: () })\n    }', 'Real(LocalPath("src/header/name.rs"))'], '<header::name::InvalidHeaderName as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct("InvalidHeaderName")\n            // skip _priv noise\n            .finish()\n    }', 'Real(LocalPath("src/header/name.rs"))'], '<header::name::InvalidHeaderName as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.write_str("invalid HTTP header name")\n    }', 'Real(LocalPath("src/header/name.rs"))'], "<header::name::MaybeLower<'a> as std::hash::Hash>::hash": ['#[inline]\nfn hash<H: Hasher>(&self, hasher: &mut H){\n        if self.lower {\n            hasher.write(self.buf);\n        } else {\n            for &b in self.buf {\n                hasher.write(&[HEADER_CHARS[b as usize]]);\n            }\n        }\n    }', 'Real(LocalPath("src/header/name.rs"))'], '<header::value::HeaderValue as std::cmp::Ord>::cmp': ['#[inline]\nfn cmp(&self, other: &Self) -> cmp::Ordering{\n        self.inner.cmp(&other.inner)\n    }', 'Real(LocalPath("src/header/value.rs"))'], "<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq": ["#[inline]\nfn eq(&self, other: &&'a T) -> bool{\n        *self == **other\n    }", 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq': ['#[inline]\nfn eq(&self, other: &[u8]) -> bool{\n        self.inner == other\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq': ['#[inline]\nfn eq(&self, other: &String) -> bool{\n        *self == other[..]\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq': ['#[inline]\nfn eq(&self, other: &str) -> bool{\n        self.inner == other.as_bytes()\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::cmp::PartialEq>::eq': ['#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        self.inner == other.inner\n    }', 'Real(LocalPath("src/header/value.rs"))'], "<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp": ["#[inline]\nfn partial_cmp(&self, other: &&'a T) -> Option<cmp::Ordering>{\n        self.partial_cmp(*other)\n    }", 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &[u8]) -> Option<cmp::Ordering>{\n        (*self.inner).partial_cmp(other)\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &String) -> Option<cmp::Ordering>{\n        self.inner.partial_cmp(other.as_bytes())\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &str) -> Option<cmp::Ordering>{\n        (*self.inner).partial_cmp(other.as_bytes())\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        Some(self.cmp(other))\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref': ['#[inline]\nfn as_ref(&self) -> &[u8]{\n        self.inner.as_ref()\n    }', 'Real(LocalPath("src/header/value.rs"))'], "<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from": ["#[inline]\nfn from(t: &'a HeaderValue) -> Self{\n        t.clone()\n    }", 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from': ['#[inline]\nfn from(h: HeaderName) -> HeaderValue{\n        HeaderValue {\n            inner: h.into_bytes(),\n            is_sensitive: false,\n        }\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::From<i16>>::from': ['fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::From<i32>>::from': ['fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::From<i64>>::from': ['fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::From<isize>>::from': ['fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::From<u16>>::from': ['fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::From<u32>>::from': ['fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::From<u64>>::from': ['fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::From<usize>>::from': ['fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }', 'Real(LocalPath("src/header/value.rs"))'], "<header::value::HeaderValue as std::convert::TryFrom<&'a [u8]>>::try_from": ["#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        HeaderValue::from_bytes(t)\n    }", 'Real(LocalPath("src/header/value.rs"))'], "<header::value::HeaderValue as std::convert::TryFrom<&'a std::string::String>>::try_from": ["#[inline]\nfn try_from(s: &'a String) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }", 'Real(LocalPath("src/header/value.rs"))'], "<header::value::HeaderValue as std::convert::TryFrom<&'a str>>::try_from": ["#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        t.parse()\n    }", 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::TryFrom<std::string::String>>::try_from': ['#[inline]\nfn try_from(t: String) -> Result<Self, Self::Error>{\n        HeaderValue::from_shared(t.into())\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['#[inline]\nfn try_from(vec: Vec<u8>) -> Result<Self, Self::Error>{\n        HeaderValue::from_shared(vec.into())\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        if self.is_sensitive {\n            f.write_str("Sensitive")\n        } else {\n            f.write_str("\\"")?;\n            let mut from = 0;\n            let bytes = self.as_bytes();\n            for (i, &b) in bytes.iter().enumerate() {\n                if !is_visible_ascii(b) || b == b\'"\' {\n                    if from != i {\n                        f.write_str(unsafe { str::from_utf8_unchecked(&bytes[from..i]) })?;\n                    }\n                    if b == b\'"\' {\n                        f.write_str("\\\\\\"")?;\n                    } else {\n                        write!(f, "\\\\x{:x}", b)?;\n                    }\n                    from = i + 1;\n                }\n            }\n\n            f.write_str(unsafe { str::from_utf8_unchecked(&bytes[from..]) })?;\n            f.write_str("\\"")\n        }\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::hash::Hash>::hash': ['fn hash<H: Hasher>(&self, state: &mut H){\n        self.inner.hash(state);\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::HeaderValue as std::str::FromStr>::from_str': ['#[inline]\nfn from_str(s: &str) -> Result<HeaderValue, Self::Err>{\n        HeaderValue::from_str(s)\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct("InvalidHeaderValue")\n            // skip _priv noise\n            .finish()\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::InvalidHeaderValue as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.write_str("failed to parse header value")\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<header::value::ToStrError as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.write_str("failed to convert header to a str")\n    }', 'Real(LocalPath("src/header/value.rs"))'], '<method::InvalidMethod as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct("InvalidMethod")\n            // skip _priv noise\n            .finish()\n    }', 'Real(LocalPath("src/method.rs"))'], '<method::InvalidMethod as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.write_str("invalid HTTP method")\n    }', 'Real(LocalPath("src/method.rs"))'], "<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq": ["#[inline]\nfn eq(&self, other: &&'a Method) -> bool{\n        self == *other\n    }", 'Real(LocalPath("src/method.rs"))'], "<method::Method as std::cmp::PartialEq<&'a str>>::eq": ["#[inline]\nfn eq(&self, other: &&'a str) -> bool{\n        self.as_ref() == *other\n    }", 'Real(LocalPath("src/method.rs"))'], '<method::Method as std::cmp::PartialEq<str>>::eq': ['#[inline]\nfn eq(&self, other: &str) -> bool{\n        self.as_ref() == other\n    }', 'Real(LocalPath("src/method.rs"))'], '<method::Method as std::convert::AsRef<str>>::as_ref': ['#[inline]\nfn as_ref(&self) -> &str{\n        self.as_str()\n    }', 'Real(LocalPath("src/method.rs"))'], "<method::Method as std::convert::From<&'a method::Method>>::from": ["#[inline]\nfn from(t: &'a Method) -> Self{\n        t.clone()\n    }", 'Real(LocalPath("src/method.rs"))'], "<method::Method as std::convert::TryFrom<&'a [u8]>>::try_from": ["#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        Method::from_bytes(t)\n    }", 'Real(LocalPath("src/method.rs"))'], "<method::Method as std::convert::TryFrom<&'a str>>::try_from": ["#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        TryFrom::try_from(t.as_bytes())\n    }", 'Real(LocalPath("src/method.rs"))'], '<method::Method as std::default::Default>::default': ['#[inline]\nfn default() -> Method{\n        Method::GET\n    }', 'Real(LocalPath("src/method.rs"))'], '<method::Method as std::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(self.as_ref())\n    }", 'Real(LocalPath("src/method.rs"))'], '<method::Method as std::fmt::Display>::fmt': ["fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt.write_str(self.as_ref())\n    }", 'Real(LocalPath("src/method.rs"))'], '<method::Method as std::str::FromStr>::from_str': ['#[inline]\nfn from_str(t: &str) -> Result<Self, Self::Err>{\n        TryFrom::try_from(t)\n    }', 'Real(LocalPath("src/method.rs"))'], '<request::Builder as std::default::Default>::default': ['#[inline]\nfn default() -> Builder{\n        Builder {\n            inner: Ok(Parts::new()),\n        }\n    }', 'Real(LocalPath("src/request.rs"))'], '<request::Parts as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("Parts")\n            .field("method", &self.method)\n            .field("uri", &self.uri)\n            .field("version", &self.version)\n            .field("headers", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }', 'Real(LocalPath("src/request.rs"))'], '<request::Request<T> as std::default::Default>::default': ['fn default() -> Request<T>{\n        Request::new(T::default())\n    }', 'Real(LocalPath("src/request.rs"))'], '<request::Request<T> as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("Request")\n            .field("method", self.method())\n            .field("uri", self.uri())\n            .field("version", &self.version())\n            .field("headers", self.headers())\n            // omits Extensions because not useful\n            .field("body", self.body())\n            .finish()\n    }', 'Real(LocalPath("src/request.rs"))'], '<response::Builder as std::default::Default>::default': ['#[inline]\nfn default() -> Builder{\n        Builder {\n            inner: Ok(Parts::new()),\n        }\n    }', 'Real(LocalPath("src/response.rs"))'], '<response::Parts as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("Parts")\n            .field("status", &self.status)\n            .field("version", &self.version)\n            .field("headers", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }', 'Real(LocalPath("src/response.rs"))'], '<response::Response<T> as std::default::Default>::default': ['#[inline]\nfn default() -> Response<T>{\n        Response::new(T::default())\n    }', 'Real(LocalPath("src/response.rs"))'], '<response::Response<T> as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("Response")\n            .field("status", &self.status())\n            .field("version", &self.version())\n            .field("headers", self.headers())\n            // omits Extensions because not useful\n            .field("body", self.body())\n            .finish()\n    }', 'Real(LocalPath("src/response.rs"))'], '<status::InvalidStatusCode as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct("InvalidStatusCode")\n            // skip _priv noise\n            .finish()\n    }', 'Real(LocalPath("src/status.rs"))'], '<status::InvalidStatusCode as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.write_str("invalid status code")\n    }', 'Real(LocalPath("src/status.rs"))'], '<status::StatusCode as std::cmp::PartialEq<u16>>::eq': ['#[inline]\nfn eq(&self, other: &u16) -> bool{\n        self.as_u16() == *other\n    }', 'Real(LocalPath("src/status.rs"))'], "<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from": ["#[inline]\nfn from(t: &'a StatusCode) -> Self{\n        t.to_owned()\n    }", 'Real(LocalPath("src/status.rs"))'], "<status::StatusCode as std::convert::TryFrom<&'a [u8]>>::try_from": ["#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        StatusCode::from_bytes(t)\n    }", 'Real(LocalPath("src/status.rs"))'], "<status::StatusCode as std::convert::TryFrom<&'a str>>::try_from": ["#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        t.parse()\n    }", 'Real(LocalPath("src/status.rs"))'], '<status::StatusCode as std::convert::TryFrom<u16>>::try_from': ['#[inline]\nfn try_from(t: u16) -> Result<Self, Self::Error>{\n        StatusCode::from_u16(t)\n    }', 'Real(LocalPath("src/status.rs"))'], '<status::StatusCode as std::default::Default>::default': ['#[inline]\nfn default() -> StatusCode{\n        StatusCode::OK\n    }', 'Real(LocalPath("src/status.rs"))'], '<status::StatusCode as std::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Debug::fmt(&self.0, f)\n    }", 'Real(LocalPath("src/status.rs"))'], '<status::StatusCode as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        write!(\n            f,\n            "{} {}",\n            u16::from(*self),\n            self.canonical_reason().unwrap_or("<unknown status code>")\n        )\n    }', 'Real(LocalPath("src/status.rs"))'], '<status::StatusCode as std::str::FromStr>::from_str': ['fn from_str(s: &str) -> Result<StatusCode, InvalidStatusCode>{\n        StatusCode::from_bytes(s.as_ref())\n    }', 'Real(LocalPath("src/status.rs"))'], '<std::string::String as header::map::as_header_name::Sealed>::as_str': ['fn as_str(&self) -> &str{\n            self\n        }', 'Real(LocalPath("src/header/map.rs"))'], '<std::string::String as header::map::as_header_name::Sealed>::find': ['#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            Sealed::find(&self.as_str(), map)\n        }', 'Real(LocalPath("src/header/map.rs"))'], '<std::string::String as header::map::as_header_name::Sealed>::try_entry': ["#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>{\n            self.as_str().try_entry(map)\n        }", 'Real(LocalPath("src/header/map.rs"))'], '<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from': ['fn from(src: ErrorKind) -> InvalidUri{\n        InvalidUri(src)\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::InvalidUri as std::fmt::Display>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        self.s().fmt(f)\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from': ['fn from(src: ErrorKind) -> InvalidUriParts{\n        InvalidUriParts(src.into())\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::InvalidUriParts as std::fmt::Display>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        self.0.fmt(f)\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Parts as std::convert::From<uri::Uri>>::from': ['fn from(src: Uri) -> Self{\n        let path_and_query = if src.has_path() {\n            Some(src.path_and_query)\n        } else {\n            None\n        };\n\n        let scheme = match src.scheme.inner {\n            Scheme2::None => None,\n            _ => Some(src.scheme),\n        };\n\n        let authority = if src.authority.data.is_empty() {\n            None\n        } else {\n            Some(src.authority)\n        };\n\n        Parts {\n            scheme,\n            authority,\n            path_and_query,\n            _priv: (),\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], "<uri::Uri as std::cmp::PartialEq<&'a str>>::eq": ["fn eq(&self, other: &&'a str) -> bool{\n        self == *other\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::cmp::PartialEq<str>>::eq': ['fn eq(&self, other: &str) -> bool{\n        let mut other = other.as_bytes();\n        let mut absolute = false;\n\n        if let Some(scheme) = self.scheme() {\n            let scheme = scheme.as_str().as_bytes();\n            absolute = true;\n\n            if other.len() < scheme.len() + 3 {\n                return false;\n            }\n\n            if !scheme.eq_ignore_ascii_case(&other[..scheme.len()]) {\n                return false;\n            }\n\n            other = &other[scheme.len()..];\n\n            if &other[..3] != b"://" {\n                return false;\n            }\n\n            other = &other[3..];\n        }\n\n        if let Some(auth) = self.authority() {\n            let len = auth.data.len();\n            absolute = true;\n\n            if other.len() < len {\n                return false;\n            }\n\n            if !auth.data.as_bytes().eq_ignore_ascii_case(&other[..len]) {\n                return false;\n            }\n\n            other = &other[len..];\n        }\n\n        let path = self.path();\n\n        if other.len() < path.len() || path.as_bytes() != &other[..path.len()] {\n            if absolute && path == "/" {\n                // PathAndQuery can be omitted, fall through\n            } else {\n                return false;\n            }\n        } else {\n            other = &other[path.len()..];\n        }\n\n        if let Some(query) = self.query() {\n            if other.is_empty() {\n                return query.is_empty();\n            }\n\n            if other[0] != b\'?\' {\n                return false;\n            }\n\n            other = &other[1..];\n\n            if other.len() < query.len() {\n                return false;\n            }\n\n            if query.as_bytes() != &other[..query.len()] {\n                return false;\n            }\n\n            other = &other[query.len()..];\n        }\n\n        other.is_empty() || other[0] == b\'#\'\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::cmp::PartialEq>::eq': ['fn eq(&self, other: &Uri) -> bool{\n        if self.scheme() != other.scheme() {\n            return false;\n        }\n\n        if self.authority() != other.authority() {\n            return false;\n        }\n\n        if self.path() != other.path() {\n            return false;\n        }\n\n        if self.query() != other.query() {\n            return false;\n        }\n\n        true\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::convert::From<uri::authority::Authority>>::from': ['fn from(authority: Authority) -> Self{\n        Self {\n            scheme: Scheme::empty(),\n            authority,\n            path_and_query: PathAndQuery::empty(),\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::convert::From<uri::path::PathAndQuery>>::from': ['fn from(path_and_query: PathAndQuery) -> Self{\n        Self {\n            scheme: Scheme::empty(),\n            authority: Authority::empty(),\n            path_and_query,\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], "<uri::Uri as std::convert::TryFrom<&'a [u8]>>::try_from": ["#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        Uri::from_shared(Bytes::copy_from_slice(t))\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], "<uri::Uri as std::convert::TryFrom<&'a std::string::String>>::try_from": ["#[inline]\nfn try_from(t: &'a String) -> Result<Self, Self::Error>{\n        t.parse()\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], "<uri::Uri as std::convert::TryFrom<&'a str>>::try_from": ["#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        t.parse()\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], "<uri::Uri as std::convert::TryFrom<&'a uri::Uri>>::try_from": ["#[inline]\nfn try_from(src: &'a Uri) -> Result<Self, Self::Error>{\n        Ok(src.clone())\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::convert::TryFrom<std::string::String>>::try_from': ['#[inline]\nfn try_from(t: String) -> Result<Self, Self::Error>{\n        Uri::from_shared(Bytes::from(t))\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['#[inline]\nfn try_from(vec: Vec<u8>) -> Result<Self, Self::Error>{\n        Uri::from_shared(Bytes::from(vec))\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::convert::TryFrom<uri::Parts>>::try_from': ['#[inline]\nfn try_from(src: Parts) -> Result<Self, Self::Error>{\n        Uri::from_parts(src)\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::default::Default>::default': ['#[inline]\nfn default() -> Uri{\n        Uri {\n            scheme: Scheme::empty(),\n            authority: Authority::empty(),\n            path_and_query: PathAndQuery::slash(),\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self, f)\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::fmt::Display>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        if let Some(scheme) = self.scheme() {\n            write!(f, "{}://", scheme)?;\n        }\n\n        if let Some(authority) = self.authority() {\n            write!(f, "{}", authority)?;\n        }\n\n        write!(f, "{}", self.path())?;\n\n        if let Some(query) = self.query() {\n            write!(f, "?{}", query)?;\n        }\n\n        Ok(())\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::hash::Hash>::hash': ["fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        if !self.scheme.inner.is_none() {\n            self.scheme.hash(state);\n            state.write_u8(0xff);\n        }\n\n        if let Some(auth) = self.authority() {\n            auth.hash(state);\n        }\n\n        Hash::hash_slice(self.path().as_bytes(), state);\n\n        if let Some(query) = self.query() {\n            b'?'.hash(state);\n            Hash::hash_slice(query.as_bytes(), state);\n        }\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], '<uri::Uri as std::str::FromStr>::from_str': ['#[inline]\nfn from_str(s: &str) -> Result<Uri, InvalidUri>{\n        Uri::try_from(s.as_bytes())\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], "<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq": ["fn eq(&self, other: &&'a str) -> bool{\n        self.data.eq_ignore_ascii_case(other)\n    }", 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq': ['fn eq(&self, other: &String) -> bool{\n        self.data.eq_ignore_ascii_case(other.as_str())\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::cmp::PartialEq<str>>::eq': ['fn eq(&self, other: &str) -> bool{\n        self.data.eq_ignore_ascii_case(other)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::cmp::PartialEq>::eq': ['fn eq(&self, other: &Authority) -> bool{\n        self.data.eq_ignore_ascii_case(&other.data)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], "<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp": ["fn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }", 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp': ['fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp': ['fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp': ['fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::convert::AsRef<str>>::as_ref': ['fn as_ref(&self) -> &str{\n        self.as_str()\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], "<uri::authority::Authority as std::convert::TryFrom<&'a [u8]>>::try_from": ["#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        // parse first, and only turn into Bytes if valid\n\n        // Preconditon on create_authority: copy_from_slice() copies all of\n        // bytes from the [u8] parameter into a new Bytes\n        create_authority(s, Bytes::copy_from_slice)\n    }", 'Real(LocalPath("src/uri/authority.rs"))'], "<uri::authority::Authority as std::convert::TryFrom<&'a str>>::try_from": ["#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        TryFrom::try_from(s.as_bytes())\n    }", 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::convert::TryFrom<std::string::String>>::try_from': ['#[inline]\nfn try_from(t: String) -> Result<Self, Self::Error>{\n        Authority::from_shared(t.into())\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['#[inline]\nfn try_from(vec: Vec<u8>) -> Result<Self, Self::Error>{\n        Authority::from_shared(vec.into())\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(self.as_str())\n    }", 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::fmt::Display>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(self.as_str())\n    }", 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::hash::Hash>::hash': ['fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        self.data.len().hash(state);\n        for &b in self.data.as_bytes() {\n            state.write_u8(b.to_ascii_lowercase());\n        }\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::authority::Authority as std::str::FromStr>::from_str': ['fn from_str(s: &str) -> Result<Self, InvalidUri>{\n        TryFrom::try_from(s)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], '<uri::builder::Builder as std::convert::From<uri::Uri>>::from': ['fn from(uri: Uri) -> Self{\n        Self {\n            parts: Ok(uri.into_parts()),\n        }\n    }', 'Real(LocalPath("src/uri/builder.rs"))'], '<uri::builder::Builder as std::default::Default>::default': ['#[inline]\nfn default() -> Builder{\n        Builder {\n            parts: Ok(Parts::default()),\n        }\n    }', 'Real(LocalPath("src/uri/builder.rs"))'], "<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq": ["#[inline]\nfn eq(&self, other: &&'a str) -> bool{\n        self.as_str() == *other\n    }", 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq': ['#[inline]\nfn eq(&self, other: &String) -> bool{\n        self.as_str() == other.as_str()\n    }', 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq': ['#[inline]\nfn eq(&self, other: &str) -> bool{\n        self.as_str() == other\n    }', 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::cmp::PartialEq>::eq': ['#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self.data == other.data\n    }', 'Real(LocalPath("src/uri/path.rs"))'], "<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp": ["#[inline]\nfn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(*other)\n    }", 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &String) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other.as_str())\n    }', 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &str) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other)\n    }', 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other.as_str())\n    }', 'Real(LocalPath("src/uri/path.rs"))'], "<uri::path::PathAndQuery as std::convert::TryFrom<&'a [u8]>>::try_from": ["#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        PathAndQuery::from_shared(Bytes::copy_from_slice(s))\n    }", 'Real(LocalPath("src/uri/path.rs"))'], "<uri::path::PathAndQuery as std::convert::TryFrom<&'a str>>::try_from": ["#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        TryFrom::try_from(s.as_bytes())\n    }", 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::convert::TryFrom<&std::string::String>>::try_from': ['#[inline]\nfn try_from(s: &String) -> Result<Self, Self::Error>{\n        TryFrom::try_from(s.as_bytes())\n    }', 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::convert::TryFrom<std::string::String>>::try_from': ['#[inline]\nfn try_from(s: String) -> Result<Self, Self::Error>{\n        PathAndQuery::from_shared(s.into())\n    }', 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['#[inline]\nfn try_from(vec: Vec<u8>) -> Result<Self, Self::Error>{\n        PathAndQuery::from_shared(vec.into())\n    }', 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self, f)\n    }", 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::fmt::Display>::fmt': ['fn fmt(&self, fmt: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        if !self.data.is_empty() {\n            match self.data.as_bytes()[0] {\n                b\'/\' | b\'*\' => write!(fmt, "{}", &self.data[..]),\n                _ => write!(fmt, "/{}", &self.data[..]),\n            }\n        } else {\n            write!(fmt, "/")\n        }\n    }', 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::hash::Hash>::hash': ['fn hash<H: hash::Hasher>(&self, state: &mut H){\n        self.data.hash(state);\n    }', 'Real(LocalPath("src/uri/path.rs"))'], '<uri::path::PathAndQuery as std::str::FromStr>::from_str': ['#[inline]\nfn from_str(s: &str) -> Result<Self, InvalidUri>{\n        TryFrom::try_from(s)\n    }', 'Real(LocalPath("src/uri/path.rs"))'], '<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq': ['fn eq(&self, other: &u16) -> bool{\n        self.port == *other\n    }', 'Real(LocalPath("src/uri/port.rs"))'], '<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq': ['fn eq(&self, other: &Port<U>) -> bool{\n        self.port == other.port\n    }', 'Real(LocalPath("src/uri/port.rs"))'], '<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref': ['fn as_ref(&self) -> &str{\n        self.as_str()\n    }', 'Real(LocalPath("src/uri/port.rs"))'], '<uri::port::Port<T> as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_tuple("Port").field(&self.port).finish()\n    }', 'Real(LocalPath("src/uri/port.rs"))'], '<uri::port::Port<T> as std::fmt::Display>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        // Use `u16::fmt` so that it respects any formatting flags that\n        // may have been set (like padding, align, etc).\n        fmt::Display::fmt(&self.port, f)\n    }", 'Real(LocalPath("src/uri/port.rs"))'], '<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq': ['fn eq(&self, other: &str) -> bool{\n        self.as_str().eq_ignore_ascii_case(other)\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], '<uri::scheme::Scheme as std::cmp::PartialEq>::eq': ['fn eq(&self, other: &Scheme) -> bool{\n        use self::Protocol::*;\n        use self::Scheme2::*;\n\n        match (&self.inner, &other.inner) {\n            (&Standard(Http), &Standard(Http)) => true,\n            (&Standard(Https), &Standard(Https)) => true,\n            (Other(a), Other(b)) => a.eq_ignore_ascii_case(b),\n            (&None, _) | (_, &None) => unreachable!(),\n            _ => false,\n        }\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], '<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref': ['#[inline]\nfn as_ref(&self) -> &str{\n        self.as_str()\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], '<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from': ['fn from(src: Scheme2) -> Self{\n        Scheme { inner: src }\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], "<uri::scheme::Scheme as std::convert::TryFrom<&'a [u8]>>::try_from": ["#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        use self::Scheme2::*;\n\n        match Scheme2::parse_exact(s)? {\n            None => Err(ErrorKind::InvalidScheme.into()),\n            Standard(p) => Ok(Standard(p).into()),\n            Other(_) => {\n                let bytes = Bytes::copy_from_slice(s);\n\n                // Safety: postcondition on parse_exact() means that s and\n                // hence bytes are valid UTF-8.\n                let string = unsafe { ByteStr::from_utf8_unchecked(bytes) };\n\n                Ok(Other(Box::new(string)).into())\n            }\n        }\n    }", 'Real(LocalPath("src/uri/scheme.rs"))'], "<uri::scheme::Scheme as std::convert::TryFrom<&'a str>>::try_from": ["#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        TryFrom::try_from(s.as_bytes())\n    }", 'Real(LocalPath("src/uri/scheme.rs"))'], '<uri::scheme::Scheme as std::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Debug::fmt(self.as_str(), f)\n    }", 'Real(LocalPath("src/uri/scheme.rs"))'], '<uri::scheme::Scheme as std::fmt::Display>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(self.as_str())\n    }", 'Real(LocalPath("src/uri/scheme.rs"))'], '<uri::scheme::Scheme as std::hash::Hash>::hash': ['fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        match self.inner {\n            Scheme2::None => (),\n            Scheme2::Standard(Protocol::Http) => state.write_u8(1),\n            Scheme2::Standard(Protocol::Https) => state.write_u8(2),\n            Scheme2::Other(ref other) => {\n                other.len().hash(state);\n                for &b in other.as_bytes() {\n                    state.write_u8(b.to_ascii_lowercase());\n                }\n            }\n        }\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], '<uri::scheme::Scheme as std::str::FromStr>::from_str': ['fn from_str(s: &str) -> Result<Self, Self::Err>{\n        TryFrom::try_from(s)\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], '<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from': ['fn from(src: Protocol) -> Self{\n        Scheme2::Standard(src)\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], '<version::Version as std::default::Default>::default': ['#[inline]\nfn default() -> Version{\n        Version::HTTP_11\n    }', 'Real(LocalPath("src/version.rs"))'], '<version::Version as std::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        use self::Http::*;\n\n        f.write_str(match self.0 {\n            Http09 => "HTTP/0.9",\n            Http10 => "HTTP/1.0",\n            Http11 => "HTTP/1.1",\n            H2 => "HTTP/2.0",\n            H3 => "HTTP/3.0",\n            __NonExhaustive => unreachable!(),\n        })\n    }', 'Real(LocalPath("src/version.rs"))'], 'byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from': ['fn from(src: ByteStr) -> Self{\n        src.bytes\n    }', 'Real(LocalPath("src/byte_str.rs"))'], 'byte_str::ByteStr': ['pub(crate) struct ByteStr {\n    // Invariant: bytes contains valid UTF-8\n    bytes: Bytes,\n}', 'Real(LocalPath("src/byte_str.rs"))'], 'byte_str::ByteStr::from_static': ["#[inline]\npub const fn from_static(val: &'static str) -> ByteStr{\n        ByteStr {\n            // Invariant: val is a str so contains valid UTF-8.\n            bytes: Bytes::from_static(val.as_bytes()),\n        }\n    }", 'Real(LocalPath("src/byte_str.rs"))'], 'byte_str::ByteStr::from_utf8': ['pub(crate) fn from_utf8(bytes: Bytes) -> Result<ByteStr, std::str::Utf8Error>{\n        str::from_utf8(&bytes)?;\n        // Invariant: just checked is utf8\n        Ok(ByteStr { bytes })\n    }', 'Real(LocalPath("src/byte_str.rs"))'], 'byte_str::ByteStr::from_utf8_unchecked': ['#[inline]\n/// ## Panics\n/// In a debug build this will panic if `bytes` is not valid UTF-8.\n///\n/// ## Safety\n/// `bytes` must contain valid UTF-8. In a release build it is undefined\n/// behavior to call this with `bytes` that is not valid UTF-8.\npub unsafe fn from_utf8_unchecked(bytes: Bytes) -> ByteStr{\n        if cfg!(debug_assertions) {\n            match str::from_utf8(&bytes) {\n                Ok(_) => (),\n                Err(err) => panic!(\n                    "ByteStr::from_utf8_unchecked() with invalid bytes; error = {}, bytes = {:?}",\n                    err, bytes\n                ),\n            }\n        }\n        // Invariant: assumed by the safety requirements of this function.\n        ByteStr { bytes }\n    }', 'Real(LocalPath("src/byte_str.rs"))'], 'byte_str::ByteStr::new': ['#[inline]\npub fn new() -> ByteStr{\n        ByteStr {\n            // Invariant: the empty slice is trivially valid UTF-8.\n            bytes: Bytes::new(),\n        }\n    }', 'Real(LocalPath("src/byte_str.rs"))'], 'error::Error': ['/// A generic "error" for HTTP connections\n///\n/// This error type is less specific than the error returned from other\n/// functions in this crate, but all other errors can be converted to this\n/// error. Consumers of this crate can typically consume and work with this form\n/// of error for conversions with the `?` operator.\npub struct Error {\n    inner: ErrorKind,\n}', 'Real(LocalPath("src/error.rs"))'], 'error::Error::get_ref': ["/// Return a reference to the lower level, inner error.\npub fn get_ref(&self) -> &(dyn error::Error + 'static){\n        use self::ErrorKind::*;\n\n        match self.inner {\n            StatusCode(ref e) => e,\n            Method(ref e) => e,\n            Uri(ref e) => e,\n            UriParts(ref e) => e,\n            HeaderName(ref e) => e,\n            HeaderValue(ref e) => e,\n            MaxSizeReached(ref e) => e,\n        }\n    }", 'Real(LocalPath("src/error.rs"))'], 'error::Error::is': ["/// Return true if the underlying error has the same type as T.\npub fn is<T: error::Error + 'static>(&self) -> bool{\n        self.get_ref().is::<T>()\n    }", 'Real(LocalPath("src/error.rs"))'], 'error::ErrorKind': ['enum ErrorKind {\n    StatusCode(status::InvalidStatusCode),\n    Method(method::InvalidMethod),\n    Uri(uri::InvalidUri),\n    UriParts(uri::InvalidUriParts),\n    HeaderName(header::InvalidHeaderName),\n    HeaderValue(header::InvalidHeaderValue),\n    MaxSizeReached(MaxSizeReached),\n}', 'Real(LocalPath("src/error.rs"))'], "extensions::<impl std::clone::Clone for std::boxed::Box<(dyn extensions::AnyClone + std::marker::Send + std::marker::Sync + 'static)>>::clone": ['fn clone(&self) -> Self{\n        (**self).clone_box()\n    }', 'Real(LocalPath("src/extensions.rs"))'], 'extensions::AnyClone': ['trait AnyClone: Any {\n    fn clone_box(&self) -> Box<dyn AnyClone + Send + Sync>;\n    fn as_any(&self) -> &dyn Any;\n    fn as_any_mut(&mut self) -> &mut dyn Any;\n    fn into_any(self: Box<Self>) -> Box<dyn Any>;\n}', 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions': ["/// A type map of protocol extensions.\n///\n/// `Extensions` can be used by `Request` and `Response` to store\n/// extra data derived from the underlying protocol.\npub struct Extensions {\n    // If extensions are never used, no need to carry around an empty HashMap.\n    // That's 3 words. Instead, this is only 1 word.\n    map: Option<Box<AnyMap>>,\n}", 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::clear': ['/// Clear the `Extensions` of all inserted extensions.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// ext.insert(5i32);\n/// ext.clear();\n///\n/// assert!(ext.get::<i32>().is_none());\n/// ```\n#[inline]\npub fn clear(&mut self){\n        if let Some(ref mut map) = self.map {\n            map.clear();\n        }\n    }', 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::extend': ['/// Extends `self` with another `Extensions`.\n///\n/// If an instance of a specific type exists in both, the one in `self` is overwritten with the\n/// one from `other`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext_a = Extensions::new();\n/// ext_a.insert(8u8);\n/// ext_a.insert(16u16);\n///\n/// let mut ext_b = Extensions::new();\n/// ext_b.insert(4u8);\n/// ext_b.insert("hello");\n///\n/// ext_a.extend(ext_b);\n/// assert_eq!(ext_a.len(), 3);\n/// assert_eq!(ext_a.get::<u8>(), Some(&4u8));\n/// assert_eq!(ext_a.get::<u16>(), Some(&16u16));\n/// assert_eq!(ext_a.get::<&\'static str>().copied(), Some("hello"));\n/// ```\npub fn extend(&mut self, other: Self){\n        if let Some(other) = other.map {\n            if let Some(map) = &mut self.map {\n                map.extend(*other);\n            } else {\n                self.map = Some(other);\n            }\n        }\n    }', 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::get': ["/// Get a reference to a type previously inserted on this `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// assert!(ext.get::<i32>().is_none());\n/// ext.insert(5i32);\n///\n/// assert_eq!(ext.get::<i32>(), Some(&5i32));\n/// ```\npub fn get<T: Send + Sync + 'static>(&self) -> Option<&T>{\n        self.map\n            .as_ref()\n            .and_then(|map| map.get(&TypeId::of::<T>()))\n            .and_then(|boxed| (**boxed).as_any().downcast_ref())\n    }", 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::get_mut': ['/// Get a mutable reference to a type previously inserted on this `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// ext.insert(String::from("Hello"));\n/// ext.get_mut::<String>().unwrap().push_str(" World");\n///\n/// assert_eq!(ext.get::<String>().unwrap(), "Hello World");\n/// ```\npub fn get_mut<T: Send + Sync + \'static>(&mut self) -> Option<&mut T>{\n        self.map\n            .as_mut()\n            .and_then(|map| map.get_mut(&TypeId::of::<T>()))\n            .and_then(|boxed| (**boxed).as_any_mut().downcast_mut())\n    }', 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::get_or_insert': ["/// Get a mutable reference to a type, inserting `value` if not already present on this\n/// `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// *ext.get_or_insert(1i32) += 2;\n///\n/// assert_eq!(*ext.get::<i32>().unwrap(), 3);\n/// ```\npub fn get_or_insert<T: Clone + Send + Sync + 'static>(&mut self, value: T) -> &mut T{\n        self.get_or_insert_with(|| value)\n    }", 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::get_or_insert_default': ["/// Get a mutable reference to a type, inserting the type's default value if not already present\n/// on this `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// *ext.get_or_insert_default::<i32>() += 2;\n///\n/// assert_eq!(*ext.get::<i32>().unwrap(), 2);\n/// ```\npub fn get_or_insert_default<T: Default + Clone + Send + Sync + 'static>(&mut self) -> &mut T{\n        self.get_or_insert_with(T::default)\n    }", 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::get_or_insert_with': ["/// Get a mutable reference to a type, inserting the value created by `f` if not already present\n/// on this `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// *ext.get_or_insert_with(|| 1i32) += 2;\n///\n/// assert_eq!(*ext.get::<i32>().unwrap(), 3);\n/// ```\npub fn get_or_insert_with<T: Clone + Send + Sync + 'static, F: FnOnce() -> T>(\n        &mut self,\n        f: F,\n    ) -> &mut T{\n        let out = self\n            .map\n            .get_or_insert_with(Box::default)\n            .entry(TypeId::of::<T>())\n            .or_insert_with(|| Box::new(f()));\n        (**out).as_any_mut().downcast_mut().unwrap()\n    }", 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::insert': ["/// Insert a type into this `Extensions`.\n///\n/// If a extension of this type already existed, it will\n/// be returned and replaced with the new one.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// assert!(ext.insert(5i32).is_none());\n/// assert!(ext.insert(4u8).is_none());\n/// assert_eq!(ext.insert(9i32), Some(5i32));\n/// ```\npub fn insert<T: Clone + Send + Sync + 'static>(&mut self, val: T) -> Option<T>{\n        self.map\n            .get_or_insert_with(Box::default)\n            .insert(TypeId::of::<T>(), Box::new(val))\n            .and_then(|boxed| boxed.into_any().downcast().ok().map(|boxed| *boxed))\n    }", 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::is_empty': ['/// Check whether the extension set is empty or not.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// assert!(ext.is_empty());\n/// ext.insert(5i32);\n/// assert!(!ext.is_empty());\n/// ```\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.map.as_ref().map_or(true, |map| map.is_empty())\n    }', 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::len': ['/// Get the number of extensions available.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// assert_eq!(ext.len(), 0);\n/// ext.insert(5i32);\n/// assert_eq!(ext.len(), 1);\n/// ```\n#[inline]\npub fn len(&self) -> usize{\n        self.map.as_ref().map_or(0, |map| map.len())\n    }', 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::new': ['/// Create an empty `Extensions`.\n#[inline]\npub fn new() -> Extensions{\n        Extensions { map: None }\n    }', 'Real(LocalPath("src/extensions.rs"))'], 'extensions::Extensions::remove': ["/// Remove a type from this `Extensions`.\n///\n/// If a extension of this type existed, it will be returned.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// ext.insert(5i32);\n/// assert_eq!(ext.remove::<i32>(), Some(5i32));\n/// assert!(ext.get::<i32>().is_none());\n/// ```\npub fn remove<T: Send + Sync + 'static>(&mut self) -> Option<T>{\n        self.map\n            .as_mut()\n            .and_then(|map| map.remove(&TypeId::of::<T>()))\n            .and_then(|boxed| boxed.into_any().downcast().ok().map(|boxed| *boxed))\n    }", 'Real(LocalPath("src/extensions.rs"))'], 'extensions::IdHasher': ['struct IdHasher(u64);', 'Real(LocalPath("src/extensions.rs"))'], 'header::map::Bucket': ['/// Stores the data associated with a `HeaderMap` entry. Only the first value is\n/// included in this struct. If a header name has more than one associated\n/// value, all extra values are stored in the `extra_values` vector. A doubly\n/// linked list of entries is maintained. The doubly linked list is used so that\n/// removing a value is constant time. This also has the nice property of\n/// enabling double ended iteration.\nstruct Bucket<T> {\n    hash: HashValue,\n    key: HeaderName,\n    value: T,\n    links: Option<Links>,\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Cursor': ['/// Tracks the value iterator state\nenum Cursor {\n    Head,\n    Values(usize),\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Danger': ['/// Tracks the header map danger level! This relates to the adaptive hashing\n/// algorithm. A HeaderMap starts in the "green" state, when a large number of\n/// collisions are detected, it transitions to the yellow state. At this point,\n/// the header map will either grow and switch back to the green state OR it\n/// will transition to the red state.\n///\n/// When in the red state, a safe hashing algorithm is used and all values in\n/// the header map have to be rehashed.\nenum Danger {\n    Green,\n    Yellow,\n    Red(RandomState),\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Danger::is_red': ['fn is_red(&self) -> bool{\n        matches!(*self, Danger::Red(_))\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Danger::is_yellow': ['fn is_yellow(&self) -> bool{\n        matches!(*self, Danger::Yellow)\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Danger::set_green': ['fn set_green(&mut self){\n        debug_assert!(self.is_yellow());\n        *self = Danger::Green;\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Danger::set_red': ['fn set_red(&mut self){\n        debug_assert!(self.is_yellow());\n        *self = Danger::Red(RandomState::new());\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Danger::set_yellow': ['fn set_yellow(&mut self){\n        if let Danger::Green = *self {\n            *self = Danger::Yellow;\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Drain': ["/// A drain iterator for `HeaderMap`.\npub struct Drain<'a, T> {\n    idx: usize,\n    len: usize,\n    entries: *mut [Bucket<T>],\n    // If None, pull from `entries`\n    next: Option<usize>,\n    extra_values: *mut Vec<ExtraValue<T>>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Entry': ["/// A view into a single location in a `HeaderMap`, which may be vacant or occupied.\npub enum Entry<'a, T: 'a> {\n    /// An occupied entry\n    Occupied(OccupiedEntry<'a, T>),\n\n    /// A vacant entry\n    Vacant(VacantEntry<'a, T>),\n}", 'Real(LocalPath("src/header/map.rs"))'], "header::map::Entry::<'a, T>::key": ['/// Returns a reference to the entry\'s key\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(map.entry("x-hello").key(), "x-hello");\n/// ```\npub fn key(&self) -> &HeaderName{\n        use self::Entry::*;\n\n        match *self {\n            Vacant(ref e) => e.key(),\n            Occupied(ref e) => e.key(),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::Entry::<'a, T>::or_insert": ['/// Ensures a value is in the entry by inserting the default if empty.\n///\n/// Returns a mutable reference to the **first** value in the entry.\n///\n/// # Panics\n///\n/// This method panics if capacity exceeds max `HeaderMap` capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map: HeaderMap<u32> = HeaderMap::default();\n///\n/// let headers = &[\n///     "content-length",\n///     "x-hello",\n///     "Content-Length",\n///     "x-world",\n/// ];\n///\n/// for &header in headers {\n///     let counter = map.entry(header)\n///         .or_insert(0);\n///     *counter += 1;\n/// }\n///\n/// assert_eq!(map["content-length"], 2);\n/// assert_eq!(map["x-hello"], 1);\n/// ```\npub fn or_insert(self, default: T) -> &\'a mut T{\n        self.or_try_insert(default)\n            .expect("size overflows MAX_SIZE")\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::Entry::<'a, T>::or_insert_with": ['/// Ensures a value is in the entry by inserting the result of the default\n/// function if empty.\n///\n/// The default function is not called if the entry exists in the map.\n/// Returns a mutable reference to the **first** value in the entry.\n///\n/// # Examples\n///\n/// Basic usage.\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// let res = map.entry("x-hello")\n///     .or_insert_with(|| "world".parse().unwrap());\n///\n/// assert_eq!(res, "world");\n/// ```\n///\n/// The default function is not called if the entry exists in the map.\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.try_insert(HOST, "world".parse().unwrap()).unwrap();\n///\n/// let res = map.try_entry("host")\n///     .unwrap()\n///     .or_try_insert_with(|| unreachable!())\n///     .unwrap();\n///\n///\n/// assert_eq!(res, "world");\n/// ```\npub fn or_insert_with<F: FnOnce() -> T>(self, default: F) -> &\'a mut T{\n        self.or_try_insert_with(default)\n            .expect("size overflows MAX_SIZE")\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::Entry::<'a, T>::or_try_insert": ['/// Ensures a value is in the entry by inserting the default if empty.\n///\n/// Returns a mutable reference to the **first** value in the entry.\n///\n/// # Errors\n///\n/// This function may return an error if `HeaderMap` exceeds max capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map: HeaderMap<u32> = HeaderMap::default();\n///\n/// let headers = &[\n///     "content-length",\n///     "x-hello",\n///     "Content-Length",\n///     "x-world",\n/// ];\n///\n/// for &header in headers {\n///     let counter = map.entry(header)\n///         .or_try_insert(0)\n///         .unwrap();\n///     *counter += 1;\n/// }\n///\n/// assert_eq!(map["content-length"], 2);\n/// assert_eq!(map["x-hello"], 1);\n/// ```\npub fn or_try_insert(self, default: T) -> Result<&\'a mut T, MaxSizeReached>{\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => Ok(e.into_mut()),\n            Vacant(e) => e.try_insert(default),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::Entry::<'a, T>::or_try_insert_with": ['/// Ensures a value is in the entry by inserting the result of the default\n/// function if empty.\n///\n/// The default function is not called if the entry exists in the map.\n/// Returns a mutable reference to the **first** value in the entry.\n///\n/// # Examples\n///\n/// Basic usage.\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// let res = map.entry("x-hello")\n///     .or_insert_with(|| "world".parse().unwrap());\n///\n/// assert_eq!(res, "world");\n/// ```\n///\n/// The default function is not called if the entry exists in the map.\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.try_insert(HOST, "world".parse().unwrap()).unwrap();\n///\n/// let res = map.try_entry("host")\n///     .unwrap()\n///     .or_try_insert_with(|| unreachable!())\n///     .unwrap();\n///\n///\n/// assert_eq!(res, "world");\n/// ```\npub fn or_try_insert_with<F: FnOnce() -> T>(\n        self,\n        default: F,\n    ) -> Result<&\'a mut T, MaxSizeReached>{\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => Ok(e.into_mut()),\n            Vacant(e) => e.try_insert(default()),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::ExtraValue': ['/// Node in doubly-linked list of header value entries\nstruct ExtraValue<T> {\n    value: T,\n    prev: Link,\n    next: Link,\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::GetAll': ["/// A view to all values stored in a single entry.\n///\n/// This struct is returned by `HeaderMap::get_all`.\npub struct GetAll<'a, T> {\n    map: &'a HeaderMap<T>,\n    index: Option<usize>,\n}", 'Real(LocalPath("src/header/map.rs"))'], "header::map::GetAll::<'a, T>::iter": ['/// Returns an iterator visiting all values associated with the entry.\n///\n/// Values are iterated in insertion order.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "hello.world".parse().unwrap());\n/// map.append(HOST, "hello.earth".parse().unwrap());\n///\n/// let values = map.get_all("host");\n/// let mut iter = values.iter();\n/// assert_eq!(&"hello.world", iter.next().unwrap());\n/// assert_eq!(&"hello.earth", iter.next().unwrap());\n/// assert!(iter.next().is_none());\n/// ```\npub fn iter(&self) -> ValueIter<\'a, T>{\n        // This creates a new GetAll struct so that the lifetime\n        // isn\'t bound to &self.\n        GetAll {\n            map: self.map,\n            index: self.index,\n        }\n        .into_iter()\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HashValue': ['/// Hash values are limited to u16 as well. While `fast_hash` and `Hasher`\n/// return `usize` hash codes, limiting the effective hash code to the lower 16\n/// bits is fine since we know that the `indices` vector will never grow beyond\n/// that size.\nstruct HashValue(u16);', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap': ['/// A set of HTTP headers\n///\n/// `HeaderMap` is a multimap of [`HeaderName`] to values.\n///\n/// [`HeaderName`]: struct.HeaderName.html\n///\n/// # Examples\n///\n/// Basic usage\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST, LOCATION};\n/// let mut headers = HeaderMap::new();\n///\n/// headers.insert(HOST, "example.com".parse().unwrap());\n/// headers.insert(CONTENT_LENGTH, "123".parse().unwrap());\n///\n/// assert!(headers.contains_key(HOST));\n/// assert!(!headers.contains_key(LOCATION));\n///\n/// assert_eq!(headers[HOST], "example.com");\n///\n/// headers.remove(HOST);\n///\n/// assert!(!headers.contains_key(HOST));\n/// ```\npub struct HeaderMap<T = HeaderValue> {\n    // Used to mask values to get an index\n    mask: Size,\n    indices: Box<[Pos]>,\n    entries: Vec<Bucket<T>>,\n    extra_values: Vec<ExtraValue<T>>,\n    danger: Danger,\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::append': ['/// Inserts a key-value pair into the map.\n///\n/// If the map did not previously have this key present, then `false` is\n/// returned.\n///\n/// If the map did have this key present, the new value is pushed to the end\n/// of the list of values currently associated with the key. The key is not\n/// updated, though; this matters for types that can be `==` without being\n/// identical.\n///\n/// # Panics\n///\n/// This method panics if capacity exceeds max `HeaderMap` capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.insert(HOST, "world".parse().unwrap()).is_none());\n/// assert!(!map.is_empty());\n///\n/// map.append(HOST, "earth".parse().unwrap());\n///\n/// let values = map.get_all("host");\n/// let mut i = values.iter();\n/// assert_eq!("world", *i.next().unwrap());\n/// assert_eq!("earth", *i.next().unwrap());\n/// ```\npub fn append<K>(&mut self, key: K, value: T) -> bool\n    where\n        K: IntoHeaderName,{\n        self.try_append(key, value)\n            .expect("size overflows MAX_SIZE")\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::capacity': ['/// Returns the number of headers the map can hold without reallocating.\n///\n/// This number is an approximation as certain usage patterns could cause\n/// additional allocations before the returned capacity is filled.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(0, map.capacity());\n///\n/// map.insert(HOST, "hello.world".parse().unwrap());\n/// assert_eq!(6, map.capacity());\n/// ```\npub fn capacity(&self) -> usize{\n        usable_capacity(self.indices.len())\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::clear': ['/// Clears the map, removing all key-value pairs. Keeps the allocated memory\n/// for reuse.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "hello.world".parse().unwrap());\n///\n/// map.clear();\n/// assert!(map.is_empty());\n/// assert!(map.capacity() > 0);\n/// ```\npub fn clear(&mut self){\n        self.entries.clear();\n        self.extra_values.clear();\n        self.danger = Danger::Green;\n\n        for e in self.indices.iter_mut() {\n            *e = Pos::none();\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::contains_key': ['/// Returns true if the map contains a value for the specified key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(!map.contains_key(HOST));\n///\n/// map.insert(HOST, "world".parse().unwrap());\n/// assert!(map.contains_key("host"));\n/// ```\npub fn contains_key<K>(&self, key: K) -> bool\n    where\n        K: AsHeaderName,{\n        key.find(self).is_some()\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::drain': ['/// Clears the map, returning all entries as an iterator.\n///\n/// The internal memory is kept for reuse.\n///\n/// For each yielded item that has `None` provided for the `HeaderName`,\n/// then the associated header name is the same as that of the previously\n/// yielded item. The first yielded item will have `HeaderName` set.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, "hello".parse().unwrap());\n/// map.append(HOST, "goodbye".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n///\n/// let mut drain = map.drain();\n///\n///\n/// assert_eq!(drain.next(), Some((Some(HOST), "hello".parse().unwrap())));\n/// assert_eq!(drain.next(), Some((None, "goodbye".parse().unwrap())));\n///\n/// assert_eq!(drain.next(), Some((Some(CONTENT_LENGTH), "123".parse().unwrap())));\n///\n/// assert_eq!(drain.next(), None);\n/// ```\npub fn drain(&mut self) -> Drain<\'_, T>{\n        for i in self.indices.iter_mut() {\n            *i = Pos::none();\n        }\n\n        // Memory safety\n        //\n        // When the Drain is first created, it shortens the length of\n        // the source vector to make sure no uninitialized or moved-from\n        // elements are accessible at all if the Drain\'s destructor never\n        // gets to run.\n\n        let entries = &mut self.entries[..] as *mut _;\n        let extra_values = &mut self.extra_values as *mut _;\n        let len = self.entries.len();\n        unsafe {\n            self.entries.set_len(0);\n        }\n\n        Drain {\n            idx: 0,\n            len,\n            entries,\n            extra_values,\n            next: None,\n            lt: PhantomData,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::entry': ['/// Gets the given key\'s corresponding entry in the map for in-place\n/// manipulation.\n///\n/// # Panics\n///\n/// This method panics if capacity exceeds max `HeaderMap` capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map: HeaderMap<u32> = HeaderMap::default();\n///\n/// let headers = &[\n///     "content-length",\n///     "x-hello",\n///     "Content-Length",\n///     "x-world",\n/// ];\n///\n/// for &header in headers {\n///     let counter = map.entry(header).or_insert(0);\n///     *counter += 1;\n/// }\n///\n/// assert_eq!(map["content-length"], 2);\n/// assert_eq!(map["x-hello"], 1);\n/// ```\npub fn entry<K>(&mut self, key: K) -> Entry<\'_, T>\n    where\n        K: IntoHeaderName,{\n        key.try_entry(self).expect("size overflows MAX_SIZE")\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::find': ['#[inline]\nfn find<K>(&self, key: &K) -> Option<(usize, usize)>\n    where\n        K: Hash + Into<HeaderName> + ?Sized,\n        HeaderName: PartialEq<K>,{\n        if self.entries.is_empty() {\n            return None;\n        }\n\n        let hash = hash_elem_using(&self.danger, key);\n        let mask = self.mask;\n        let mut probe = desired_pos(mask, hash);\n        let mut dist = 0;\n\n        probe_loop!(probe < self.indices.len(), {\n            if let Some((i, entry_hash)) = self.indices[probe].resolve() {\n                if dist > probe_distance(mask, entry_hash, probe) {\n                    // give up when probe distance is too long\n                    return None;\n                } else if entry_hash == hash && self.entries[i].key == *key {\n                    return Some((probe, i));\n                }\n            } else {\n                return None;\n            }\n\n            dist += 1;\n        });\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::get': ['/// Returns a reference to the value associated with the key.\n///\n/// If there are multiple values associated with the key, then the first one\n/// is returned. Use `get_all` to get all values associated with a given\n/// key. Returns `None` if there are no values associated with the key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.get("host").is_none());\n///\n/// map.insert(HOST, "hello".parse().unwrap());\n/// assert_eq!(map.get(HOST).unwrap(), &"hello");\n/// assert_eq!(map.get("host").unwrap(), &"hello");\n///\n/// map.append(HOST, "world".parse().unwrap());\n/// assert_eq!(map.get("host").unwrap(), &"hello");\n/// ```\npub fn get<K>(&self, key: K) -> Option<&T>\n    where\n        K: AsHeaderName,{\n        self.get2(&key)\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::get2': ['fn get2<K>(&self, key: &K) -> Option<&T>\n    where\n        K: AsHeaderName,{\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &self.entries[found];\n                Some(&entry.value)\n            }\n            None => None,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::get_all': ['/// Returns a view of all values associated with a key.\n///\n/// The returned view does not incur any allocations and allows iterating\n/// the values associated with the key.  See [`GetAll`] for more details.\n/// Returns `None` if there are no values associated with the key.\n///\n/// [`GetAll`]: struct.GetAll.html\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, "hello".parse().unwrap());\n/// map.append(HOST, "goodbye".parse().unwrap());\n///\n/// let view = map.get_all("host");\n///\n/// let mut iter = view.iter();\n/// assert_eq!(&"hello", iter.next().unwrap());\n/// assert_eq!(&"goodbye", iter.next().unwrap());\n/// assert!(iter.next().is_none());\n/// ```\npub fn get_all<K>(&self, key: K) -> GetAll<\'_, T>\n    where\n        K: AsHeaderName,{\n        GetAll {\n            map: self,\n            index: key.find(self).map(|(_, i)| i),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::get_mut': ['/// Returns a mutable reference to the value associated with the key.\n///\n/// If there are multiple values associated with the key, then the first one\n/// is returned. Use `entry` to get all values associated with a given\n/// key. Returns `None` if there are no values associated with the key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, "hello".to_string());\n/// map.get_mut("host").unwrap().push_str("-world");\n///\n/// assert_eq!(map.get(HOST).unwrap(), &"hello-world");\n/// ```\npub fn get_mut<K>(&mut self, key: K) -> Option<&mut T>\n    where\n        K: AsHeaderName,{\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &mut self.entries[found];\n                Some(&mut entry.value)\n            }\n            None => None,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::insert': ['/// Inserts a key-value pair into the map.\n///\n/// If the map did not previously have this key present, then `None` is\n/// returned.\n///\n/// If the map did have this key present, the new value is associated with\n/// the key and all previous values are removed. **Note** that only a single\n/// one of the previous values is returned. If there are multiple values\n/// that have been previously associated with the key, then the first one is\n/// returned. See `insert_mult` on `OccupiedEntry` for an API that returns\n/// all values.\n///\n/// The key is not updated, though; this matters for types that can be `==`\n/// without being identical.\n///\n/// # Panics\n///\n/// This method panics if capacity exceeds max `HeaderMap` capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.insert(HOST, "world".parse().unwrap()).is_none());\n/// assert!(!map.is_empty());\n///\n/// let mut prev = map.insert(HOST, "earth".parse().unwrap()).unwrap();\n/// assert_eq!("world", prev);\n/// ```\npub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n    where\n        K: IntoHeaderName,{\n        self.try_insert(key, val).expect("size overflows MAX_SIZE")\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::insert_occupied': ['/// Set an occupied bucket to the given value\n#[inline]\nfn insert_occupied(&mut self, index: usize, value: T) -> T{\n        if let Some(links) = self.entries[index].links {\n            self.remove_all_extra_values(links.next);\n        }\n\n        let entry = &mut self.entries[index];\n        mem::replace(&mut entry.value, value)\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::insert_occupied_mult': ["fn insert_occupied_mult(&mut self, index: usize, value: T) -> ValueDrain<'_, T>{\n        let old;\n        let links;\n\n        {\n            let entry = &mut self.entries[index];\n\n            old = mem::replace(&mut entry.value, value);\n            links = entry.links.take();\n        }\n\n        let raw_links = self.raw_links();\n        let extra_values = &mut self.extra_values;\n\n        let next =\n            links.map(|l| drain_all_extra_values(raw_links, extra_values, l.next).into_iter());\n\n        ValueDrain {\n            first: Some(old),\n            next,\n            lt: PhantomData,\n        }\n    }", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::is_empty': ['/// Returns true if the map contains no elements.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n///\n/// assert!(map.is_empty());\n///\n/// map.insert(HOST, "hello.world".parse().unwrap());\n///\n/// assert!(!map.is_empty());\n/// ```\npub fn is_empty(&self) -> bool{\n        self.entries.len() == 0\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::iter': ['/// An iterator visiting all key-value pairs.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version. Each key will be yielded once per associated\n/// value. So, if a key has 3 associated values, it will be yielded 3 times.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, "hello".parse().unwrap());\n/// map.append(HOST, "goodbye".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n///\n/// for (key, value) in map.iter() {\n///     println!("{:?}: {:?}", key, value);\n/// }\n/// ```\npub fn iter(&self) -> Iter<\'_, T>{\n        Iter {\n            map: self,\n            entry: 0,\n            cursor: self.entries.first().map(|_| Cursor::Head),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::iter_mut': ['/// An iterator visiting all key-value pairs, with mutable value references.\n///\n/// The iterator order is arbitrary, but consistent across platforms for the\n/// same crate version. Each key will be yielded once per associated value,\n/// so if a key has 3 associated values, it will be yielded 3 times.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::default();\n///\n/// map.insert(HOST, "hello".to_string());\n/// map.append(HOST, "goodbye".to_string());\n/// map.insert(CONTENT_LENGTH, "123".to_string());\n///\n/// for (key, value) in map.iter_mut() {\n///     value.push_str("-boop");\n/// }\n/// ```\npub fn iter_mut(&mut self) -> IterMut<\'_, T>{\n        IterMut {\n            map: self as *mut _,\n            entry: 0,\n            cursor: self.entries.first().map(|_| Cursor::Head),\n            lt: PhantomData,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::keys': ['/// An iterator visiting all keys.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version. Each key will be yielded only once even if it\n/// has multiple associated values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, "hello".parse().unwrap());\n/// map.append(HOST, "goodbye".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n///\n/// for key in map.keys() {\n///     println!("{:?}", key);\n/// }\n/// ```\npub fn keys(&self) -> Keys<\'_, T>{\n        Keys {\n            inner: self.entries.iter(),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::keys_len': ['/// Returns the number of keys stored in the map.\n///\n/// This number will be less than or equal to `len()` as each key may have\n/// more than one associated value.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{ACCEPT, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(0, map.keys_len());\n///\n/// map.insert(ACCEPT, "text/plain".parse().unwrap());\n/// map.insert(HOST, "localhost".parse().unwrap());\n///\n/// assert_eq!(2, map.keys_len());\n///\n/// map.insert(ACCEPT, "text/html".parse().unwrap());\n///\n/// assert_eq!(2, map.keys_len());\n/// ```\npub fn keys_len(&self) -> usize{\n        self.entries.len()\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::len': ['/// Returns the number of headers stored in the map.\n///\n/// This number represents the total number of **values** stored in the map.\n/// This number can be greater than or equal to the number of **keys**\n/// stored given that a single key may have more than one associated value.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{ACCEPT, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(0, map.len());\n///\n/// map.insert(ACCEPT, "text/plain".parse().unwrap());\n/// map.insert(HOST, "localhost".parse().unwrap());\n///\n/// assert_eq!(2, map.len());\n///\n/// map.append(ACCEPT, "text/html".parse().unwrap());\n///\n/// assert_eq!(3, map.len());\n/// ```\npub fn len(&self) -> usize{\n        self.entries.len() + self.extra_values.len()\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::raw_links': ['#[inline]\nfn raw_links(&mut self) -> RawLinks<T>{\n        RawLinks(&mut self.entries[..] as *mut _)\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::rebuild': ["fn rebuild(&mut self){\n        // Loop over all entries and re-insert them into the map\n        'outer: for (index, entry) in self.entries.iter_mut().enumerate() {\n            let hash = hash_elem_using(&self.danger, &entry.key);\n            let mut probe = desired_pos(self.mask, hash);\n            let mut dist = 0;\n\n            // Update the entry's hash code\n            entry.hash = hash;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    // if existing element probed less than us, swap\n                    let their_dist = probe_distance(self.mask, entry_hash, probe);\n\n                    if their_dist < dist {\n                        // Robinhood\n                        break;\n                    }\n                } else {\n                    // Vacant slot\n                    self.indices[probe] = Pos::new(index, hash);\n                    continue 'outer;\n                }\n\n                dist += 1;\n            });\n\n            do_insert_phase_two(&mut self.indices, probe, Pos::new(index, hash));\n        }\n    }", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::reinsert_entry_in_order': ['fn reinsert_entry_in_order(&mut self, pos: Pos){\n        if let Some((_, entry_hash)) = pos.resolve() {\n            // Find first empty bucket and insert there\n            let mut probe = desired_pos(self.mask, entry_hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if self.indices[probe].resolve().is_none() {\n                    // empty bucket, insert here\n                    self.indices[probe] = pos;\n                    return;\n                }\n            });\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::remove': ['/// Removes a key from the map, returning the value associated with the key.\n///\n/// Returns `None` if the map does not contain the key. If there are\n/// multiple values associated with the key, then the first one is returned.\n/// See `remove_entry_mult` on `OccupiedEntry` for an API that yields all\n/// values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "hello.world".parse().unwrap());\n///\n/// let prev = map.remove(HOST).unwrap();\n/// assert_eq!("hello.world", prev);\n///\n/// assert!(map.remove(HOST).is_none());\n/// ```\npub fn remove<K>(&mut self, key: K) -> Option<T>\n    where\n        K: AsHeaderName,{\n        match key.find(self) {\n            Some((probe, idx)) => {\n                if let Some(links) = self.entries[idx].links {\n                    self.remove_all_extra_values(links.next);\n                }\n\n                let entry = self.remove_found(probe, idx);\n\n                Some(entry.value)\n            }\n            None => None,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::remove_all_extra_values': ['fn remove_all_extra_values(&mut self, mut head: usize){\n        loop {\n            let extra = self.remove_extra_value(head);\n\n            if let Link::Extra(idx) = extra.next {\n                head = idx;\n            } else {\n                break;\n            }\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::remove_extra_value': ['/// Removes the `ExtraValue` at the given index.\n#[inline]\nfn remove_extra_value(&mut self, idx: usize) -> ExtraValue<T>{\n        let raw_links = self.raw_links();\n        remove_extra_value(raw_links, &mut self.extra_values, idx)\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::remove_found': ['/// Remove an entry from the map.\n///\n/// Warning: To avoid inconsistent state, extra values _must_ be removed\n/// for the `found` index (via `remove_all_extra_values` or similar)\n/// _before_ this method is called.\n#[inline]\nfn remove_found(&mut self, probe: usize, found: usize) -> Bucket<T>{\n        // index `probe` and entry `found` is to be removed\n        // use swap_remove, but then we need to update the index that points\n        // to the other entry that has to move\n        self.indices[probe] = Pos::none();\n        let entry = self.entries.swap_remove(found);\n\n        // correct index that points to the entry that had to swap places\n        if let Some(entry) = self.entries.get(found) {\n            // was not last element\n            // examine new element in `found` and find it in indices\n            let mut probe = desired_pos(self.mask, entry.hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((i, _)) = self.indices[probe].resolve() {\n                    if i >= self.entries.len() {\n                        // found it\n                        self.indices[probe] = Pos::new(found, entry.hash);\n                        break;\n                    }\n                }\n            });\n\n            // Update links\n            if let Some(links) = entry.links {\n                self.extra_values[links.next].prev = Link::Entry(found);\n                self.extra_values[links.tail].next = Link::Entry(found);\n            }\n        }\n\n        // backward shift deletion in self.indices\n        // after probe, shift all non-ideally placed indices backward\n        if !self.entries.is_empty() {\n            let mut last_probe = probe;\n            let mut probe = probe + 1;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    if probe_distance(self.mask, entry_hash, probe) > 0 {\n                        self.indices[last_probe] = self.indices[probe];\n                        self.indices[probe] = Pos::none();\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n\n                last_probe = probe;\n            });\n        }\n\n        entry\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::reserve': ['/// Reserves capacity for at least `additional` more headers to be inserted\n/// into the `HeaderMap`.\n///\n/// The header map may reserve more space to avoid frequent reallocations.\n/// Like with `with_capacity`, this will be a "best effort" to avoid\n/// allocations until `additional` more headers are inserted. Certain usage\n/// patterns could cause additional allocations before the number is\n/// reached.\n///\n/// # Panics\n///\n/// Panics if the new allocation size overflows `HeaderMap` `MAX_SIZE`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.reserve(10);\n/// # map.insert(HOST, "bar".parse().unwrap());\n/// ```\npub fn reserve(&mut self, additional: usize){\n        self.try_reserve(additional)\n            .expect("size overflows MAX_SIZE")\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_append': ['/// Inserts a key-value pair into the map.\n///\n/// If the map did not previously have this key present, then `false` is\n/// returned.\n///\n/// If the map did have this key present, the new value is pushed to the end\n/// of the list of values currently associated with the key. The key is not\n/// updated, though; this matters for types that can be `==` without being\n/// identical.\n///\n/// # Errors\n///\n/// This function may return an error if `HeaderMap` exceeds max capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.try_insert(HOST, "world".parse().unwrap()).unwrap().is_none());\n/// assert!(!map.is_empty());\n///\n/// map.try_append(HOST, "earth".parse().unwrap()).unwrap();\n///\n/// let values = map.get_all("host");\n/// let mut i = values.iter();\n/// assert_eq!("world", *i.next().unwrap());\n/// assert_eq!("earth", *i.next().unwrap());\n/// ```\npub fn try_append<K>(&mut self, key: K, value: T) -> Result<bool, MaxSizeReached>\n    where\n        K: IntoHeaderName,{\n        key.try_append(self, value)\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_append2': ['#[inline]\nfn try_append2<K>(&mut self, key: K, value: T) -> Result<bool, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,{\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            // Vacant\n            {\n                let _ = danger;\n                let index = self.entries.len();\n                self.try_insert_entry(hash, key.into(), value)?;\n                self.indices[probe] = Pos::new(index, hash);\n                false\n            },\n            // Occupied\n            {\n                append_value(pos, &mut self.entries[pos], &mut self.extra_values, value);\n                true\n            },\n            // Robinhood\n            {\n                self.try_insert_phase_two(key.into(), value, hash, probe, danger)?;\n\n                false\n            }\n        ))\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_entry': ["/// Gets the given key's corresponding entry in the map for in-place\n/// manipulation.\n///\n/// # Errors\n///\n/// This method differs from `entry` by allowing types that may not be\n/// valid `HeaderName`s to passed as the key (such as `String`). If they\n/// do not parse as a valid `HeaderName`, this returns an\n/// `InvalidHeaderName` error.\n///\n/// If reserving space goes over the maximum, this will also return an\n/// error. However, to prevent breaking changes to the return type, the\n/// error will still say `InvalidHeaderName`, unlike other `try_*` methods\n/// which return a `MaxSizeReached` error.\npub fn try_entry<K>(&mut self, key: K) -> Result<Entry<'_, T>, InvalidHeaderName>\n    where\n        K: AsHeaderName,{\n        key.try_entry(self).map_err(|err| match err {\n            as_header_name::TryEntryError::InvalidHeaderName(e) => e,\n            as_header_name::TryEntryError::MaxSizeReached(_e) => {\n                // Unfortunately, we cannot change the return type of this\n                // method, so the max size reached error needs to be converted\n                // into an InvalidHeaderName. Yay.\n                InvalidHeaderName::new()\n            }\n        })\n    }", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_entry2': ["fn try_entry2<K>(&mut self, key: K) -> Result<Entry<'_, T>, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,{\n        // Ensure that there is space in the map\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash,\n                key: key.into(),\n                probe,\n                danger,\n            }),\n            Entry::Occupied(OccupiedEntry {\n                map: self,\n                index: pos,\n                probe,\n            }),\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash,\n                key: key.into(),\n                probe,\n                danger,\n            })\n        ))\n    }", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_grow': ['#[inline]\nfn try_grow(&mut self, new_raw_cap: usize) -> Result<(), MaxSizeReached>{\n        if new_raw_cap > MAX_SIZE {\n            return Err(MaxSizeReached::new());\n        }\n\n        // find first ideally placed element -- start of cluster\n        let mut first_ideal = 0;\n\n        for (i, pos) in self.indices.iter().enumerate() {\n            if let Some((_, entry_hash)) = pos.resolve() {\n                if 0 == probe_distance(self.mask, entry_hash, i) {\n                    first_ideal = i;\n                    break;\n                }\n            }\n        }\n\n        // visit the entries in an order where we can simply reinsert them\n        // into self.indices without any bucket stealing.\n        let old_indices = mem::replace(\n            &mut self.indices,\n            vec![Pos::none(); new_raw_cap].into_boxed_slice(),\n        );\n        self.mask = new_raw_cap.wrapping_sub(1) as Size;\n\n        for &pos in &old_indices[first_ideal..] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        for &pos in &old_indices[..first_ideal] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        // Reserve additional entry slots\n        let more = self.capacity() - self.entries.len();\n        self.entries.reserve_exact(more);\n        Ok(())\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_insert': ['/// Inserts a key-value pair into the map.\n///\n/// If the map did not previously have this key present, then `None` is\n/// returned.\n///\n/// If the map did have this key present, the new value is associated with\n/// the key and all previous values are removed. **Note** that only a single\n/// one of the previous values is returned. If there are multiple values\n/// that have been previously associated with the key, then the first one is\n/// returned. See `insert_mult` on `OccupiedEntry` for an API that returns\n/// all values.\n///\n/// The key is not updated, though; this matters for types that can be `==`\n/// without being identical.\n///\n/// # Errors\n///\n/// This function may return an error if `HeaderMap` exceeds max capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.try_insert(HOST, "world".parse().unwrap()).unwrap().is_none());\n/// assert!(!map.is_empty());\n///\n/// let mut prev = map.try_insert(HOST, "earth".parse().unwrap()).unwrap().unwrap();\n/// assert_eq!("world", prev);\n/// ```\npub fn try_insert<K>(&mut self, key: K, val: T) -> Result<Option<T>, MaxSizeReached>\n    where\n        K: IntoHeaderName,{\n        key.try_insert(self, val)\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_insert2': ['#[inline]\nfn try_insert2<K>(&mut self, key: K, value: T) -> Result<Option<T>, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,{\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            // Vacant\n            {\n                let _ = danger; // Make lint happy\n                let index = self.entries.len();\n                self.try_insert_entry(hash, key.into(), value)?;\n                self.indices[probe] = Pos::new(index, hash);\n                None\n            },\n            // Occupied\n            Some(self.insert_occupied(pos, value)),\n            // Robinhood\n            {\n                self.try_insert_phase_two(key.into(), value, hash, probe, danger)?;\n                None\n            }\n        ))\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_insert_entry': ['#[inline]\nfn try_insert_entry(\n        &mut self,\n        hash: HashValue,\n        key: HeaderName,\n        value: T,\n    ) -> Result<(), MaxSizeReached>{\n        if self.entries.len() >= MAX_SIZE {\n            return Err(MaxSizeReached::new());\n        }\n\n        self.entries.push(Bucket {\n            hash,\n            key,\n            value,\n            links: None,\n        });\n\n        Ok(())\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_insert_phase_two': ['/// phase 2 is post-insert where we forward-shift `Pos` in the indices.\n#[inline]\nfn try_insert_phase_two(\n        &mut self,\n        key: HeaderName,\n        value: T,\n        hash: HashValue,\n        probe: usize,\n        danger: bool,\n    ) -> Result<usize, MaxSizeReached>{\n        // Push the value and get the index\n        let index = self.entries.len();\n        self.try_insert_entry(hash, key, value)?;\n\n        let num_displaced = do_insert_phase_two(&mut self.indices, probe, Pos::new(index, hash));\n\n        if danger || num_displaced >= DISPLACEMENT_THRESHOLD {\n            // Increase danger level\n            self.danger.set_yellow();\n        }\n\n        Ok(index)\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_reserve': ['/// Reserves capacity for at least `additional` more headers to be inserted\n/// into the `HeaderMap`.\n///\n/// The header map may reserve more space to avoid frequent reallocations.\n/// Like with `with_capacity`, this will be a "best effort" to avoid\n/// allocations until `additional` more headers are inserted. Certain usage\n/// patterns could cause additional allocations before the number is\n/// reached.\n///\n/// # Errors\n///\n/// This method differs from `reserve` by returning an error instead of\n/// panicking if the value is too large.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.try_reserve(10).unwrap();\n/// # map.try_insert(HOST, "bar".parse().unwrap()).unwrap();\n/// ```\npub fn try_reserve(&mut self, additional: usize) -> Result<(), MaxSizeReached>{\n        // TODO: This can\'t overflow if done properly... since the max # of\n        // elements is u16::MAX.\n        let cap = self\n            .entries\n            .len()\n            .checked_add(additional)\n            .ok_or_else(MaxSizeReached::new)?;\n\n        let raw_cap = to_raw_capacity(cap);\n\n        if raw_cap > self.indices.len() {\n            let raw_cap = raw_cap\n                .checked_next_power_of_two()\n                .ok_or_else(MaxSizeReached::new)?;\n            if raw_cap > MAX_SIZE {\n                return Err(MaxSizeReached::new());\n            }\n\n            if self.entries.is_empty() {\n                self.mask = raw_cap as Size - 1;\n                self.indices = vec![Pos::none(); raw_cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(raw_cap));\n            } else {\n                self.try_grow(raw_cap)?;\n            }\n        }\n\n        Ok(())\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_reserve_one': ['fn try_reserve_one(&mut self) -> Result<(), MaxSizeReached>{\n        let len = self.entries.len();\n\n        if self.danger.is_yellow() {\n            let load_factor = self.entries.len() as f32 / self.indices.len() as f32;\n\n            if load_factor >= LOAD_FACTOR_THRESHOLD {\n                // Transition back to green danger level\n                self.danger.set_green();\n\n                // Double the capacity\n                let new_cap = self.indices.len() * 2;\n\n                // Grow the capacity\n                self.try_grow(new_cap)?;\n            } else {\n                self.danger.set_red();\n\n                // Rebuild hash table\n                for index in self.indices.iter_mut() {\n                    *index = Pos::none();\n                }\n\n                self.rebuild();\n            }\n        } else if len == self.capacity() {\n            if len == 0 {\n                let new_raw_cap = 8;\n                self.mask = 8 - 1;\n                self.indices = vec![Pos::none(); new_raw_cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(new_raw_cap));\n            } else {\n                let raw_cap = self.indices.len();\n                self.try_grow(raw_cap << 1)?;\n            }\n        }\n\n        Ok(())\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::try_with_capacity': ['/// Create an empty `HeaderMap` with the specified capacity.\n///\n/// The returned map will allocate internal storage in order to hold about\n/// `capacity` elements without reallocating. However, this is a "best\n/// effort" as there are usage patterns that could cause additional\n/// allocations before `capacity` headers are stored in the map.\n///\n/// More capacity than requested may be allocated.\n///\n/// # Errors\n///\n/// This function may return an error if `HeaderMap` exceeds max capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let map: HeaderMap<u32> = HeaderMap::try_with_capacity(10).unwrap();\n///\n/// assert!(map.is_empty());\n/// assert_eq!(12, map.capacity());\n/// ```\npub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached>{\n        if capacity == 0 {\n            Ok(HeaderMap {\n                mask: 0,\n                indices: Box::new([]), // as a ZST, this doesn\'t actually allocate anything\n                entries: Vec::new(),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            })\n        } else {\n            let raw_cap = match to_raw_capacity(capacity).checked_next_power_of_two() {\n                Some(c) => c,\n                None => return Err(MaxSizeReached { _priv: () }),\n            };\n            if raw_cap > MAX_SIZE {\n                return Err(MaxSizeReached { _priv: () });\n            }\n            debug_assert!(raw_cap > 0);\n\n            Ok(HeaderMap {\n                mask: (raw_cap - 1) as Size,\n                indices: vec![Pos::none(); raw_cap].into_boxed_slice(),\n                entries: Vec::with_capacity(usable_capacity(raw_cap)),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            })\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::value_iter': ["fn value_iter(&self, idx: Option<usize>) -> ValueIter<'_, T>{\n        use self::Cursor::*;\n\n        if let Some(idx) = idx {\n            let back = {\n                let entry = &self.entries[idx];\n\n                entry.links.map(|l| Values(l.tail)).unwrap_or(Head)\n            };\n\n            ValueIter {\n                map: self,\n                index: idx,\n                front: Some(Head),\n                back: Some(back),\n            }\n        } else {\n            ValueIter {\n                map: self,\n                index: usize::MAX,\n                front: None,\n                back: None,\n            }\n        }\n    }", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::value_iter_mut': ["fn value_iter_mut(&mut self, idx: usize) -> ValueIterMut<'_, T>{\n        use self::Cursor::*;\n\n        let back = {\n            let entry = &self.entries[idx];\n\n            entry.links.map(|l| Values(l.tail)).unwrap_or(Head)\n        };\n\n        ValueIterMut {\n            map: self as *mut _,\n            index: idx,\n            front: Some(Head),\n            back: Some(back),\n            lt: PhantomData,\n        }\n    }", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::values': ['/// An iterator visiting all values.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, "hello".parse().unwrap());\n/// map.append(HOST, "goodbye".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, "123".parse().unwrap());\n///\n/// for value in map.values() {\n///     println!("{:?}", value);\n/// }\n/// ```\npub fn values(&self) -> Values<\'_, T>{\n        Values { inner: self.iter() }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::values_mut': ['/// An iterator visiting all values mutably.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::default();\n///\n/// map.insert(HOST, "hello".to_string());\n/// map.append(HOST, "goodbye".to_string());\n/// map.insert(CONTENT_LENGTH, "123".to_string());\n///\n/// for value in map.values_mut() {\n///     value.push_str("-boop");\n/// }\n/// ```\npub fn values_mut(&mut self) -> ValuesMut<\'_, T>{\n        ValuesMut {\n            inner: self.iter_mut(),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::<T>::with_capacity': ['/// Create an empty `HeaderMap` with the specified capacity.\n///\n/// The returned map will allocate internal storage in order to hold about\n/// `capacity` elements without reallocating. However, this is a "best\n/// effort" as there are usage patterns that could cause additional\n/// allocations before `capacity` headers are stored in the map.\n///\n/// More capacity than requested may be allocated.\n///\n/// # Panics\n///\n/// This method panics if capacity exceeds max `HeaderMap` capacity.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let map: HeaderMap<u32> = HeaderMap::with_capacity(10);\n///\n/// assert!(map.is_empty());\n/// assert_eq!(12, map.capacity());\n/// ```\npub fn with_capacity(capacity: usize) -> HeaderMap<T>{\n        Self::try_with_capacity(capacity).expect("size overflows MAX_SIZE")\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::HeaderMap::new': ['/// Create an empty `HeaderMap`.\n///\n/// The map will be created without any capacity. This function will not\n/// allocate.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let map = HeaderMap::new();\n///\n/// assert!(map.is_empty());\n/// assert_eq!(0, map.capacity());\n/// ```\npub fn new() -> Self{\n        HeaderMap::try_with_capacity(0).unwrap()\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::IntoIter': ['/// An owning iterator over the entries of a `HeaderMap`.\n///\n/// This struct is created by the `into_iter` method on `HeaderMap`.\npub struct IntoIter<T> {\n    // If None, pull from `entries`\n    next: Option<usize>,\n    entries: vec::IntoIter<Bucket<T>>,\n    extra_values: Vec<ExtraValue<T>>,\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Iter': ["/// `HeaderMap` entry iterator.\n///\n/// Yields `(&HeaderName, &value)` tuples. The same header name may be yielded\n/// more than once if it has more than one associated value.\npub struct Iter<'a, T> {\n    map: &'a HeaderMap<T>,\n    entry: usize,\n    cursor: Option<Cursor>,\n}", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::IterMut': ["/// `HeaderMap` mutable entry iterator\n///\n/// Yields `(&HeaderName, &mut value)` tuples. The same header name may be\n/// yielded more than once if it has more than one associated value.\npub struct IterMut<'a, T> {\n    map: *mut HeaderMap<T>,\n    entry: usize,\n    cursor: Option<Cursor>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}", 'Real(LocalPath("src/header/map.rs"))'], "header::map::IterMut::<'a, T>::next_unsafe": ["fn next_unsafe(&mut self) -> Option<(&'a HeaderName, *mut T)>{\n        use self::Cursor::*;\n\n        if self.cursor.is_none() {\n            if (self.entry + 1) >= unsafe { &*self.map }.entries.len() {\n                return None;\n            }\n\n            self.entry += 1;\n            self.cursor = Some(Cursor::Head);\n        }\n\n        let entry = unsafe { &mut (*self.map).entries[self.entry] };\n\n        match self.cursor.unwrap() {\n            Head => {\n                self.cursor = entry.links.map(|l| Values(l.next));\n                Some((&entry.key, &mut entry.value as *mut _))\n            }\n            Values(idx) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                match extra.next {\n                    Link::Entry(_) => self.cursor = None,\n                    Link::Extra(i) => self.cursor = Some(Values(i)),\n                }\n\n                Some((&entry.key, &mut extra.value as *mut _))\n            }\n        }\n    }", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Keys': ["/// An iterator over `HeaderMap` keys.\n///\n/// Each header name is yielded only once, even if it has more than one\n/// associated value.\npub struct Keys<'a, T> {\n    inner: ::std::slice::Iter<'a, Bucket<T>>,\n}", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Link': ['/// A header value node is either linked to another node in the `extra_values`\n/// list or it points to an entry in `entries`. The entry in `entries` is the\n/// start of the list and holds the associated header name.\nenum Link {\n    Entry(usize),\n    Extra(usize),\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Links': ['/// The head and tail of the value linked list.\nstruct Links {\n    next: usize,\n    tail: usize,\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::MaxSizeReached': ['/// Error returned when max capacity of `HeaderMap` is exceeded\npub struct MaxSizeReached {\n    _priv: (),\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::MaxSizeReached::new': ['fn new() -> Self{\n        MaxSizeReached { _priv: () }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::OccupiedEntry': ["/// A view into a single occupied location in a `HeaderMap`.\n///\n/// This struct is returned as part of the `Entry` enum.\npub struct OccupiedEntry<'a, T> {\n    map: &'a mut HeaderMap<T>,\n    probe: usize,\n    index: usize,\n}", 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::append": ['/// Insert the value into the entry.\n///\n/// The new value is appended to the end of the entry\'s value list. All\n/// previous values associated with the entry are retained.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "world".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry("host") {\n///     e.append("earth".parse().unwrap());\n/// }\n///\n/// let values = map.get_all("host");\n/// let mut i = values.iter();\n/// assert_eq!("world", *i.next().unwrap());\n/// assert_eq!("earth", *i.next().unwrap());\n/// ```\npub fn append(&mut self, value: T){\n        let idx = self.index;\n        let entry = &mut self.map.entries[idx];\n        append_value(idx, entry, &mut self.map.extra_values, value);\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::get": ['/// Get a reference to the first value in the entry.\n///\n/// Values are stored in insertion order.\n///\n/// # Panics\n///\n/// `get` panics if there are no values associated with the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "hello.world".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry("host") {\n///     assert_eq!(e.get(), &"hello.world");\n///\n///     e.append("hello.earth".parse().unwrap());\n///\n///     assert_eq!(e.get(), &"hello.world");\n/// }\n/// ```\npub fn get(&self) -> &T{\n        &self.map.entries[self.index].value\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::get_mut": ['/// Get a mutable reference to the first value in the entry.\n///\n/// Values are stored in insertion order.\n///\n/// # Panics\n///\n/// `get_mut` panics if there are no values associated with the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, "hello.world".to_string());\n///\n/// if let Entry::Occupied(mut e) = map.entry("host") {\n///     e.get_mut().push_str("-2");\n///     assert_eq!(e.get(), &"hello.world-2");\n/// }\n/// ```\npub fn get_mut(&mut self) -> &mut T{\n        &mut self.map.entries[self.index].value\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::insert": ['/// Sets the value of the entry.\n///\n/// All previous values associated with the entry are removed and the first\n/// one is returned. See `insert_mult` for an API that returns all values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "hello.world".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry("host") {\n///     let mut prev = e.insert("earth".parse().unwrap());\n///     assert_eq!("hello.world", prev);\n/// }\n///\n/// assert_eq!("earth", map["host"]);\n/// ```\npub fn insert(&mut self, value: T) -> T{\n        self.map.insert_occupied(self.index, value)\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::insert_mult": ['/// Sets the value of the entry.\n///\n/// This function does the same as `insert` except it returns an iterator\n/// that yields all values previously associated with the key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "world".parse().unwrap());\n/// map.append(HOST, "world2".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry("host") {\n///     let mut prev = e.insert_mult("earth".parse().unwrap());\n///     assert_eq!("world", prev.next().unwrap());\n///     assert_eq!("world2", prev.next().unwrap());\n///     assert!(prev.next().is_none());\n/// }\n///\n/// assert_eq!("earth", map["host"]);\n/// ```\npub fn insert_mult(&mut self, value: T) -> ValueDrain<\'_, T>{\n        self.map.insert_occupied_mult(self.index, value)\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::into_mut": ['/// Converts the `OccupiedEntry` into a mutable reference to the **first**\n/// value.\n///\n/// The lifetime of the returned reference is bound to the original map.\n///\n/// # Panics\n///\n/// `into_mut` panics if there are no values associated with the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, "hello.world".to_string());\n/// map.append(HOST, "hello.earth".to_string());\n///\n/// if let Entry::Occupied(e) = map.entry("host") {\n///     e.into_mut().push_str("-2");\n/// }\n///\n/// assert_eq!("hello.world-2", map["host"]);\n/// ```\npub fn into_mut(self) -> &\'a mut T{\n        &mut self.map.entries[self.index].value\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::iter": ['/// Returns an iterator visiting all values associated with the entry.\n///\n/// Values are iterated in insertion order.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "world".parse().unwrap());\n/// map.append(HOST, "earth".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry("host") {\n///     let mut iter = e.iter();\n///     assert_eq!(&"world", iter.next().unwrap());\n///     assert_eq!(&"earth", iter.next().unwrap());\n///     assert!(iter.next().is_none());\n/// }\n/// ```\npub fn iter(&self) -> ValueIter<\'_, T>{\n        self.map.value_iter(Some(self.index))\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::iter_mut": ['/// Returns an iterator mutably visiting all values associated with the\n/// entry.\n///\n/// Values are iterated in insertion order.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, "world".to_string());\n/// map.append(HOST, "earth".to_string());\n///\n/// if let Entry::Occupied(mut e) = map.entry("host") {\n///     for e in e.iter_mut() {\n///         e.push_str("-boop");\n///     }\n/// }\n///\n/// let mut values = map.get_all("host");\n/// let mut i = values.iter();\n/// assert_eq!(&"world-boop", i.next().unwrap());\n/// assert_eq!(&"earth-boop", i.next().unwrap());\n/// ```\npub fn iter_mut(&mut self) -> ValueIterMut<\'_, T>{\n        self.map.value_iter_mut(self.index)\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::key": ['/// Returns a reference to the entry\'s key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "world".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry("host") {\n///     assert_eq!("host", e.key());\n/// }\n/// ```\npub fn key(&self) -> &HeaderName{\n        &self.map.entries[self.index].key\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::remove": ['/// Remove the entry from the map.\n///\n/// All values associated with the entry are removed and the first one is\n/// returned. See `remove_entry_mult` for an API that returns all values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "world".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry("host") {\n///     let mut prev = e.remove();\n///     assert_eq!("world", prev);\n/// }\n///\n/// assert!(!map.contains_key("host"));\n/// ```\npub fn remove(self) -> T{\n        self.remove_entry().1\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::remove_entry": ['/// Remove the entry from the map.\n///\n/// The key and all values associated with the entry are removed and the\n/// first one is returned. See `remove_entry_mult` for an API that returns\n/// all values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, "world".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry("host") {\n///     let (key, mut prev) = e.remove_entry();\n///     assert_eq!("host", key.as_str());\n///     assert_eq!("world", prev);\n/// }\n///\n/// assert!(!map.contains_key("host"));\n/// ```\npub fn remove_entry(self) -> (HeaderName, T){\n        if let Some(links) = self.map.entries[self.index].links {\n            self.map.remove_all_extra_values(links.next);\n        }\n\n        let entry = self.map.remove_found(self.probe, self.index);\n\n        (entry.key, entry.value)\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::OccupiedEntry::<'a, T>::remove_entry_mult": ["/// Remove the entry from the map.\n///\n/// The key and all values associated with the entry are removed and\n/// returned.\npub fn remove_entry_mult(self) -> (HeaderName, ValueDrain<'a, T>){\n        let raw_links = self.map.raw_links();\n        let extra_values = &mut self.map.extra_values;\n\n        let next = self.map.entries[self.index]\n            .links\n            .map(|l| drain_all_extra_values(raw_links, extra_values, l.next).into_iter());\n\n        let entry = self.map.remove_found(self.probe, self.index);\n\n        let drain = ValueDrain {\n            first: Some(entry.value),\n            next,\n            lt: PhantomData,\n        };\n        (entry.key, drain)\n    }", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Pos': ['/// An entry in the hash table. This represents the full hash code for an entry\n/// as well as the position of the entry in the `entries` vector.\nstruct Pos {\n    // Index in the `entries` vec\n    index: Size,\n    // Full hash value for the entry.\n    hash: HashValue,\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Pos::is_none': ['#[inline]\nfn is_none(&self) -> bool{\n        self.index == !0\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Pos::is_some': ['#[inline]\nfn is_some(&self) -> bool{\n        !self.is_none()\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Pos::new': ['#[inline]\nfn new(index: usize, hash: HashValue) -> Self{\n        debug_assert!(index < MAX_SIZE);\n        Pos {\n            index: index as Size,\n            hash,\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Pos::none': ['#[inline]\nfn none() -> Self{\n        Pos {\n            index: !0,\n            hash: HashValue(0),\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Pos::resolve': ['#[inline]\nfn resolve(&self) -> Option<(usize, HashValue)>{\n        if self.is_some() {\n            Some((self.index as usize, self.hash))\n        } else {\n            None\n        }\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::RawLinks': ["/// Access to the `links` value in a slice of buckets.\n///\n/// It's important that no other field is accessed, since it may have been\n/// freed in a `Drain` iterator.\nstruct RawLinks<T>(*mut [Bucket<T>]);", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::VacantEntry': ["/// A view into a single empty location in a `HeaderMap`.\n///\n/// This struct is returned as part of the `Entry` enum.\npub struct VacantEntry<'a, T> {\n    map: &'a mut HeaderMap<T>,\n    key: HeaderName,\n    hash: HashValue,\n    probe: usize,\n    danger: bool,\n}", 'Real(LocalPath("src/header/map.rs"))'], "header::map::VacantEntry::<'a, T>::insert": ['/// Insert the value into the entry.\n///\n/// The value will be associated with this entry\'s key. A mutable reference\n/// to the inserted value will be returned.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry};\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.entry("x-hello") {\n///     v.insert("world".parse().unwrap());\n/// }\n///\n/// assert_eq!(map["x-hello"], "world");\n/// ```\npub fn insert(self, value: T) -> &\'a mut T{\n        self.try_insert(value).expect("size overflows MAX_SIZE")\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::VacantEntry::<'a, T>::insert_entry": ['/// Insert the value into the entry.\n///\n/// The value will be associated with this entry\'s key. The new\n/// `OccupiedEntry` is returned, allowing for further manipulation.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.try_entry("x-hello").unwrap() {\n///     let mut e = v.try_insert_entry("world".parse().unwrap()).unwrap();\n///     e.insert("world2".parse().unwrap());\n/// }\n///\n/// assert_eq!(map["x-hello"], "world2");\n/// ```\npub fn insert_entry(self, value: T) -> OccupiedEntry<\'a, T>{\n        self.try_insert_entry(value)\n            .expect("size overflows MAX_SIZE")\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::VacantEntry::<'a, T>::into_key": ['/// Take ownership of the key\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry};\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.entry("x-hello") {\n///     assert_eq!(v.into_key().as_str(), "x-hello");\n/// }\n/// ```\npub fn into_key(self) -> HeaderName{\n        self.key\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::VacantEntry::<'a, T>::key": ['/// Returns a reference to the entry\'s key\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(map.entry("x-hello").key().as_str(), "x-hello");\n/// ```\npub fn key(&self) -> &HeaderName{\n        &self.key\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::VacantEntry::<'a, T>::try_insert": ['/// Insert the value into the entry.\n///\n/// The value will be associated with this entry\'s key. A mutable reference\n/// to the inserted value will be returned.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry};\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.entry("x-hello") {\n///     v.insert("world".parse().unwrap());\n/// }\n///\n/// assert_eq!(map["x-hello"], "world");\n/// ```\npub fn try_insert(self, value: T) -> Result<&\'a mut T, MaxSizeReached>{\n        // Ensure that there is space in the map\n        let index =\n            self.map\n                .try_insert_phase_two(self.key, value, self.hash, self.probe, self.danger)?;\n\n        Ok(&mut self.map.entries[index].value)\n    }', 'Real(LocalPath("src/header/map.rs"))'], "header::map::VacantEntry::<'a, T>::try_insert_entry": ['/// Insert the value into the entry.\n///\n/// The value will be associated with this entry\'s key. The new\n/// `OccupiedEntry` is returned, allowing for further manipulation.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.try_entry("x-hello").unwrap() {\n///     let mut e = v.try_insert_entry("world".parse().unwrap()).unwrap();\n///     e.insert("world2".parse().unwrap());\n/// }\n///\n/// assert_eq!(map["x-hello"], "world2");\n/// ```\npub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<\'a, T>, MaxSizeReached>{\n        // Ensure that there is space in the map\n        let index =\n            self.map\n                .try_insert_phase_two(self.key, value, self.hash, self.probe, self.danger)?;\n\n        Ok(OccupiedEntry {\n            map: self.map,\n            index,\n            probe: self.probe,\n        })\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::ValueDrain': ["/// An drain iterator of all values associated with a single header name.\npub struct ValueDrain<'a, T> {\n    first: Option<T>,\n    next: Option<::std::vec::IntoIter<T>>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::ValueIter': ["/// An iterator of all values associated with a single header name.\npub struct ValueIter<'a, T> {\n    map: &'a HeaderMap<T>,\n    index: usize,\n    front: Option<Cursor>,\n    back: Option<Cursor>,\n}", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::ValueIterMut': ["/// A mutable iterator of all values associated with a single header name.\npub struct ValueIterMut<'a, T> {\n    map: *mut HeaderMap<T>,\n    index: usize,\n    front: Option<Cursor>,\n    back: Option<Cursor>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::Values': ["/// `HeaderMap` value iterator.\n///\n/// Each value contained in the `HeaderMap` will be yielded.\npub struct Values<'a, T> {\n    inner: Iter<'a, T>,\n}", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::ValuesMut': ["/// `HeaderMap` mutable value iterator\npub struct ValuesMut<'a, T> {\n    inner: IterMut<'a, T>,\n}", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::append_value': ['#[inline]\nfn append_value<T>(\n    entry_idx: usize,\n    entry: &mut Bucket<T>,\n    extra: &mut Vec<ExtraValue<T>>,\n    value: T,\n){\n    match entry.links {\n        Some(links) => {\n            let idx = extra.len();\n            extra.push(ExtraValue {\n                value,\n                prev: Link::Extra(links.tail),\n                next: Link::Entry(entry_idx),\n            });\n\n            extra[links.tail].next = Link::Extra(idx);\n\n            entry.links = Some(Links { tail: idx, ..links });\n        }\n        None => {\n            let idx = extra.len();\n            extra.push(ExtraValue {\n                value,\n                prev: Link::Entry(entry_idx),\n                next: Link::Entry(entry_idx),\n            });\n\n            entry.links = Some(Links {\n                next: idx,\n                tail: idx,\n            });\n        }\n    }\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::as_header_name::AsHeaderName': ['/// A marker trait used to identify values that can be used as search keys\n/// to a `HeaderMap`.\npub trait AsHeaderName: Sealed {}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::as_header_name::Sealed': ["pub trait Sealed {\n        #[doc(hidden)]\n        fn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>;\n\n        #[doc(hidden)]\n        fn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>;\n\n        #[doc(hidden)]\n        fn as_str(&self) -> &str;\n    }", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::as_header_name::TryEntryError': ['#[allow(missing_debug_implementations)]\npub enum TryEntryError {\n        InvalidHeaderName(InvalidHeaderName),\n        MaxSizeReached(MaxSizeReached),\n    }', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::desired_pos': ['#[inline]\nfn desired_pos(mask: Size, hash: HashValue) -> usize{\n    (hash.0 & mask) as usize\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::do_insert_phase_two': ['/// phase 2 is post-insert where we forward-shift `Pos` in the indices.\n///\n/// returns the number of displaced elements\n#[inline]\nfn do_insert_phase_two(indices: &mut [Pos], mut probe: usize, mut old_pos: Pos) -> usize{\n    let mut num_displaced = 0;\n\n    probe_loop!(probe < indices.len(), {\n        let pos = &mut indices[probe];\n\n        if pos.is_none() {\n            *pos = old_pos;\n            break;\n        } else {\n            num_displaced += 1;\n            old_pos = mem::replace(pos, old_pos);\n        }\n    });\n\n    num_displaced\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::drain_all_extra_values': ['fn drain_all_extra_values<T>(\n    raw_links: RawLinks<T>,\n    extra_values: &mut Vec<ExtraValue<T>>,\n    mut head: usize,\n) -> Vec<T>{\n    let mut vec = Vec::new();\n    loop {\n        let extra = remove_extra_value(raw_links, extra_values, head);\n        vec.push(extra.value);\n\n        if let Link::Extra(idx) = extra.next {\n            head = idx;\n        } else {\n            break;\n        }\n    }\n    vec\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::hash_elem_using': ['fn hash_elem_using<K>(danger: &Danger, k: &K) -> HashValue\nwhere\n    K: Hash + ?Sized,{\n    use fnv::FnvHasher;\n\n    const MASK: u64 = (MAX_SIZE as u64) - 1;\n\n    let hash = match *danger {\n        // Safe hash\n        Danger::Red(ref hasher) => {\n            let mut h = hasher.build_hasher();\n            k.hash(&mut h);\n            h.finish()\n        }\n        // Fast hash\n        _ => {\n            let mut h = FnvHasher::default();\n            k.hash(&mut h);\n            h.finish()\n        }\n    };\n\n    HashValue((hash & MASK) as u16)\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::into_header_name::IntoHeaderName': ['/// A marker trait used to identify values that can be used as insert keys\n/// to a `HeaderMap`.\npub trait IntoHeaderName: Sealed {}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::into_header_name::Sealed': ["pub trait Sealed {\n        #[doc(hidden)]\n        fn try_insert<T>(self, map: &mut HeaderMap<T>, val: T)\n            -> Result<Option<T>, MaxSizeReached>;\n\n        #[doc(hidden)]\n        fn try_append<T>(self, map: &mut HeaderMap<T>, val: T) -> Result<bool, MaxSizeReached>;\n\n        #[doc(hidden)]\n        fn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, MaxSizeReached>;\n    }", 'Real(LocalPath("src/header/map.rs"))'], 'header::map::probe_distance': ['/// The number of steps that `current` is forward of the desired position for hash\n#[inline]\nfn probe_distance(mask: Size, hash: HashValue, current: usize) -> usize{\n    current.wrapping_sub(desired_pos(mask, hash)) & mask as usize\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::remove_extra_value': ['/// Removes the `ExtraValue` at the given index.\n#[inline]\nfn remove_extra_value<T>(\n    mut raw_links: RawLinks<T>,\n    extra_values: &mut Vec<ExtraValue<T>>,\n    idx: usize,\n) -> ExtraValue<T>{\n    let prev;\n    let next;\n\n    {\n        debug_assert!(extra_values.len() > idx);\n        let extra = &extra_values[idx];\n        prev = extra.prev;\n        next = extra.next;\n    }\n\n    // First unlink the extra value\n    match (prev, next) {\n        (Link::Entry(prev), Link::Entry(next)) => {\n            debug_assert_eq!(prev, next);\n\n            raw_links[prev] = None;\n        }\n        (Link::Entry(prev), Link::Extra(next)) => {\n            debug_assert!(raw_links[prev].is_some());\n\n            raw_links[prev].as_mut().unwrap().next = next;\n\n            debug_assert!(extra_values.len() > next);\n            extra_values[next].prev = Link::Entry(prev);\n        }\n        (Link::Extra(prev), Link::Entry(next)) => {\n            debug_assert!(raw_links[next].is_some());\n\n            raw_links[next].as_mut().unwrap().tail = prev;\n\n            debug_assert!(extra_values.len() > prev);\n            extra_values[prev].next = Link::Entry(next);\n        }\n        (Link::Extra(prev), Link::Extra(next)) => {\n            debug_assert!(extra_values.len() > next);\n            debug_assert!(extra_values.len() > prev);\n\n            extra_values[prev].next = Link::Extra(next);\n            extra_values[next].prev = Link::Extra(prev);\n        }\n    }\n\n    // Remove the extra value\n    let mut extra = extra_values.swap_remove(idx);\n\n    // This is the index of the value that was moved (possibly `extra`)\n    let old_idx = extra_values.len();\n\n    // Update the links\n    if extra.prev == Link::Extra(old_idx) {\n        extra.prev = Link::Extra(idx);\n    }\n\n    if extra.next == Link::Extra(old_idx) {\n        extra.next = Link::Extra(idx);\n    }\n\n    // Check if another entry was displaced. If it was, then the links\n    // need to be fixed.\n    if idx != old_idx {\n        let next;\n        let prev;\n\n        {\n            debug_assert!(extra_values.len() > idx);\n            let moved = &extra_values[idx];\n            next = moved.next;\n            prev = moved.prev;\n        }\n\n        // An entry was moved, we have to the links\n        match prev {\n            Link::Entry(entry_idx) => {\n                // It is critical that we do not attempt to read the\n                // header name or value as that memory may have been\n                // "released" already.\n                debug_assert!(raw_links[entry_idx].is_some());\n\n                let links = raw_links[entry_idx].as_mut().unwrap();\n                links.next = idx;\n            }\n            Link::Extra(extra_idx) => {\n                debug_assert!(extra_values.len() > extra_idx);\n                extra_values[extra_idx].next = Link::Extra(idx);\n            }\n        }\n\n        match next {\n            Link::Entry(entry_idx) => {\n                debug_assert!(raw_links[entry_idx].is_some());\n\n                let links = raw_links[entry_idx].as_mut().unwrap();\n                links.tail = idx;\n            }\n            Link::Extra(extra_idx) => {\n                debug_assert!(extra_values.len() > extra_idx);\n                extra_values[extra_idx].prev = Link::Extra(idx);\n            }\n        }\n    }\n\n    debug_assert!({\n        for v in &*extra_values {\n            assert!(v.next != Link::Extra(old_idx));\n            assert!(v.prev != Link::Extra(old_idx));\n        }\n\n        true\n    });\n\n    extra\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::to_raw_capacity': ['#[inline]\nfn to_raw_capacity(n: usize) -> usize{\n    match n.checked_add(n / 3) {\n        Some(n) => n,\n        None => panic!(\n            "requested capacity {} too large: overflow while converting to raw capacity",\n            n\n        ),\n    }\n}', 'Real(LocalPath("src/header/map.rs"))'], 'header::map::usable_capacity': ['#[inline]\nfn usable_capacity(cap: usize) -> usize{\n    cap - cap / 4\n}', 'Real(LocalPath("src/header/map.rs"))'], "header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq": ['/// Performs a case-insensitive comparison of the string against the header\n/// name\n#[inline]\nfn eq(&self, other: &HeaderName) -> bool{\n        *other == *self\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq': ['/// Performs a case-insensitive comparison of the string against the header\n/// name\n///\n/// # Examples\n///\n/// ```\n/// use http::header::CONTENT_LENGTH;\n///\n/// assert_eq!(CONTENT_LENGTH, "content-length");\n/// assert_eq!(CONTENT_LENGTH, "Content-Length");\n/// assert_ne!(CONTENT_LENGTH, "content length");\n/// ```\n#[inline]\nfn eq(&self, other: &HeaderName) -> bool{\n        *other == *self\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from': ['#[inline]\nfn from(Custom(inner): Custom) -> Bytes{\n        Bytes::from(inner)\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from': ['fn from(repr: Repr<T>) -> Bytes{\n        match repr {\n            Repr::Standard(header) => Bytes::from_static(header.as_str().as_bytes()),\n            Repr::Custom(header) => header.into(),\n        }\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::Custom': ['struct Custom(ByteStr);', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::HdrName': ["pub struct HdrName<'a> {\n    inner: Repr<MaybeLower<'a>>,\n}", 'Real(LocalPath("src/header/name.rs"))'], "header::name::HdrName::<'a>::custom": ["fn custom(buf: &'a [u8], lower: bool) -> HdrName<'a>{\n        HdrName {\n            // Invariant (on MaybeLower): follows from the precondition\n            inner: Repr::Custom(MaybeLower { buf, lower }),\n        }\n    }", 'Real(LocalPath("src/header/name.rs"))'], "header::name::HdrName::<'a>::from_bytes": ["pub fn from_bytes<F, U>(hdr: &[u8], f: F) -> Result<U, InvalidHeaderName>\n    where\n        F: FnOnce(HdrName<'_>) -> U,{\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n        let hdr = parse_hdr(hdr, &mut buf, &HEADER_CHARS)?;\n        Ok(f(hdr))\n    }", 'Real(LocalPath("src/header/name.rs"))'], "header::name::HdrName::<'a>::from_static": ['pub fn from_static<F, U>(hdr: &\'static str, f: F) -> U\n    where\n        F: FnOnce(HdrName<\'_>) -> U,{\n        let mut buf = uninit_u8_array();\n        let hdr =\n            // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n            parse_hdr(hdr.as_bytes(), &mut buf, &HEADER_CHARS).expect("static str is invalid name");\n        f(hdr)\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::HeaderName': ['/// Represents an HTTP header field name\n///\n/// Header field names identify the header. Header sets may include multiple\n/// headers with the same name. The HTTP specification defines a number of\n/// standard headers, but HTTP messages may include non-standard header names as\n/// well as long as they adhere to the specification.\n///\n/// `HeaderName` is used as the [`HeaderMap`] key. Constants are available for\n/// all standard header names in the [`header`] module.\n///\n/// # Representation\n///\n/// `HeaderName` represents standard header names using an `enum`, as such they\n/// will not require an allocation for storage. All custom header names are\n/// lower cased upon conversion to a `HeaderName` value. This avoids the\n/// overhead of dynamically doing lower case conversion during the hash code\n/// computation and the comparison operation.\n///\n/// [`HeaderMap`]: struct.HeaderMap.html\n/// [`header`]: index.html\npub struct HeaderName {\n    inner: Repr<Custom>,\n}', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::HeaderName::as_str': ['/// Returns a `str` representation of the header.\n///\n/// The returned string will always be lower case.\n#[inline]\npub fn as_str(&self) -> &str{\n        match self.inner {\n            Repr::Standard(v) => v.as_str(),\n            Repr::Custom(ref v) => &v.0,\n        }\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::HeaderName::from_bytes': ['/// Converts a slice of bytes to an HTTP header name.\n///\n/// This function normalizes the input.\npub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName>{\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n        match parse_hdr(src, &mut buf, &HEADER_CHARS)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                use bytes::BufMut;\n                let mut dst = BytesMut::with_capacity(buf.len());\n\n                for b in buf.iter() {\n                    // HEADER_CHARS maps all bytes to valid single-byte UTF-8\n                    let b = HEADER_CHARS[*b as usize];\n\n                    if b == 0 {\n                        return Err(InvalidHeaderName::new());\n                    }\n\n                    dst.put_u8(b);\n                }\n\n                // Safety: the loop above maps all bytes in buf to valid single byte\n                // UTF-8 before copying them into dst. This means that dst (and hence\n                // dst.freeze()) is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                Ok(Custom(val).into())\n            }\n        }\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::HeaderName::from_lowercase': ['/// Converts a slice of bytes to an HTTP header name.\n///\n/// This function expects the input to only contain lowercase characters.\n/// This is useful when decoding HTTP/2.0 or HTTP/3.0 headers. Both\n/// require that all headers be represented in lower case.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n///\n/// // Parsing a lower case header\n/// let hdr = HeaderName::from_lowercase(b"content-length").unwrap();\n/// assert_eq!(CONTENT_LENGTH, hdr);\n///\n/// // Parsing a header that contains uppercase characters\n/// assert!(HeaderName::from_lowercase(b"Content-Length").is_err());\n/// ```\npub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName>{\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS_H2 is a valid table for parse_hdr()\n        match parse_hdr(src, &mut buf, &HEADER_CHARS_H2)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                for &b in buf.iter() {\n                    // HEADER_CHARS_H2 maps all bytes that are not valid single-byte\n                    // UTF-8 to 0 so this check returns an error for invalid UTF-8.\n                    if HEADER_CHARS_H2[b as usize] == 0 {\n                        return Err(InvalidHeaderName::new());\n                    }\n                }\n\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the loop above checks that each byte of buf (either\n                // version) is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n        }\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::HeaderName::from_static': ['/// Converts a static string to a HTTP header name.\n///\n/// This function requires the static string to only contain lowercase\n/// characters, numerals and symbols, as per the HTTP/2.0 specification\n/// and header names internal representation within this library.\n///\n/// # Panics\n///\n/// This function panics when the static string is a invalid header.\n///\n/// Until [Allow panicking in constants](https://github.com/rust-lang/rfcs/pull/2345)\n/// makes its way into stable, the panic message at compile-time is\n/// going to look cryptic, but should at least point at your header value:\n///\n/// ```text\n/// error: any use of this value will cause an error\n///     --> http/src/header/name.rs:1241:13\n///      |\n/// 1241 |             ([] as [u8; 0])[0]; // Invalid header name\n///      |             ^^^^^^^^^^^^^^^^^^\n///      |             |\n///      |             index out of bounds: the length is 0 but the index is 0\n///      |             inside `http::HeaderName::from_static` at http/src/header/name.rs:1241:13\n///      |             inside `INVALID_NAME` at src/main.rs:3:34\n///      |\n///     ::: src/main.rs:3:1\n///      |\n/// 3    | const INVALID_NAME: HeaderName = HeaderName::from_static("Capitalized");\n///      | ------------------------------------------------------------------------\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// // Parsing a standard header\n/// let hdr = HeaderName::from_static("content-length");\n/// assert_eq!(CONTENT_LENGTH, hdr);\n///\n/// // Parsing a custom header\n/// let CUSTOM_HEADER: &\'static str = "custom-header";\n///\n/// let a = HeaderName::from_lowercase(b"custom-header").unwrap();\n/// let b = HeaderName::from_static(CUSTOM_HEADER);\n/// assert_eq!(a, b);\n/// ```\n///\n/// ```should_panic\n/// # use http::header::*;\n/// #\n/// // Parsing a header that contains invalid symbols(s):\n/// HeaderName::from_static("content{}{}length"); // This line panics!\n///\n/// // Parsing a header that contains invalid uppercase characters.\n/// let a = HeaderName::from_static("foobar");\n/// let b = HeaderName::from_static("FOOBAR"); // This line panics!\n/// ```\n#[allow(unconditional_panic)]\npub const fn from_static(src: &\'static str) -> HeaderName{\n        let name_bytes = src.as_bytes();\n        if let Some(standard) = StandardHeader::from_bytes(name_bytes) {\n            return HeaderName {\n                inner: Repr::Standard(standard),\n            };\n        }\n\n        if name_bytes.is_empty() || name_bytes.len() > super::MAX_HEADER_NAME_LEN || {\n            let mut i = 0;\n            loop {\n                if i >= name_bytes.len() {\n                    break false;\n                } else if HEADER_CHARS_H2[name_bytes[i] as usize] == 0 {\n                    break true;\n                }\n                i += 1;\n            }\n        } {\n            // TODO: When msrv is bumped to larger than 1.57, this should be\n            // replaced with `panic!` macro.\n            // https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html#panic-in-const-contexts\n            //\n            // See the panics section of this method\'s document for details.\n            #[allow(clippy::no_effect, clippy::out_of_bounds_indexing)]\n            ([] as [u8; 0])[0]; // Invalid header name\n        }\n\n        HeaderName {\n            inner: Repr::Custom(Custom(ByteStr::from_static(src))),\n        }\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::HeaderName::into_bytes': ['pub(super) fn into_bytes(self) -> Bytes{\n        self.inner.into()\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::InvalidHeaderName': ['/// A possible error when converting a `HeaderName` from another type.\npub struct InvalidHeaderName {\n    _priv: (),\n}', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::InvalidHeaderName::new': ['pub(super) fn new() -> InvalidHeaderName{\n        InvalidHeaderName { _priv: () }\n    }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::MaybeLower': ["struct MaybeLower<'a> {\n    buf: &'a [u8],\n    lower: bool,\n}", 'Real(LocalPath("src/header/name.rs"))'], 'header::name::Repr': ['enum Repr<T> {\n    Standard(StandardHeader),\n    Custom(T),\n}', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::StandardHeader': ['enum StandardHeader {\n            $(\n                $konst,\n            )+\n        }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::StandardHeader::as_str': ["#[inline]\nfn as_str(&self) -> &'static str{\n                match *self {\n                    // Safety: test_parse_standard_headers ensures these &[u8]s are &str-safe.\n                    $(\n                    StandardHeader::$konst => unsafe { std::str::from_utf8_unchecked( $name_bytes ) },\n                    )+\n                }\n            }", 'Real(LocalPath("src/header/name.rs"))'], 'header::name::StandardHeader::from_bytes': ['const fn from_bytes(name_bytes: &[u8]) -> Option<StandardHeader>{\n                match name_bytes {\n                    $(\n                        $name_bytes => Some(StandardHeader::$konst),\n                    )+\n                    _ => None,\n                }\n            }', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::eq_ignore_ascii_case': ['#[inline]\nfn eq_ignore_ascii_case(lower: &[u8], s: &[u8]) -> bool{\n    if lower.len() != s.len() {\n        return false;\n    }\n\n    lower\n        .iter()\n        .zip(s)\n        .all(|(a, b)| *a == HEADER_CHARS[*b as usize])\n}', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::parse_hdr': ["fn parse_hdr<'a>(\n    data: &'a [u8],\n    b: &'a mut [MaybeUninit<u8>; SCRATCH_BUF_SIZE],\n    table: &[u8; 256],\n) -> Result<HdrName<'a>, InvalidHeaderName>{\n    match data.len() {\n        0 => Err(InvalidHeaderName::new()),\n        len @ 1..=SCRATCH_BUF_SIZE => {\n            // Read from data into the buffer - transforming using `table` as we go\n            data.iter()\n                .zip(b.iter_mut())\n                .for_each(|(index, out)| *out = MaybeUninit::new(table[*index as usize]));\n            // Safety: len bytes of b were just initialized.\n            let name: &'a [u8] = unsafe { slice_assume_init(&b[0..len]) };\n            match StandardHeader::from_bytes(name) {\n                Some(sh) => Ok(sh.into()),\n                None => {\n                    if name.contains(&0) {\n                        Err(InvalidHeaderName::new())\n                    } else {\n                        Ok(HdrName::custom(name, true))\n                    }\n                }\n            }\n        }\n        SCRATCH_BUF_OVERFLOW..=super::MAX_HEADER_NAME_LEN => Ok(HdrName::custom(data, false)),\n        _ => Err(InvalidHeaderName::new()),\n    }\n}", 'Real(LocalPath("src/header/name.rs"))'], 'header::name::slice_assume_init': ['unsafe fn slice_assume_init<T>(slice: &[MaybeUninit<T>]) -> &[T]{\n    &*(slice as *const [MaybeUninit<T>] as *const [T])\n}', 'Real(LocalPath("src/header/name.rs"))'], 'header::name::uninit_u8_array': ["fn uninit_u8_array() -> [MaybeUninit<u8>; SCRATCH_BUF_SIZE]{\n    let arr = MaybeUninit::<[MaybeUninit<u8>; SCRATCH_BUF_SIZE]>::uninit();\n    // Safety: assume_init() is claiming that an array of MaybeUninit<>\n    // has been initialized, but MaybeUninit<>'s do not require initialization.\n    unsafe { arr.assume_init() }\n}", 'Real(LocalPath("src/header/name.rs"))'], "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq": ['#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq': ['#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq': ['#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq': ['#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }', 'Real(LocalPath("src/header/value.rs"))'], "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp": ['#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.partial_cmp(other.as_bytes())\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue': ['/// Represents an HTTP header field value.\n///\n/// In practice, HTTP header field values are usually valid ASCII. However, the\n/// HTTP spec allows for a header value to contain opaque bytes as well. In this\n/// case, the header field value is not able to be represented as a string.\n///\n/// To handle this, the `HeaderValue` is useable as a type and can be compared\n/// with strings and implements `Debug`. A `to_str` fn is provided that returns\n/// an `Err` if the header value contains non visible ascii characters.\npub struct HeaderValue {\n    inner: Bytes,\n    is_sensitive: bool,\n}', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::as_bytes': ['/// Converts a `HeaderValue` to a byte slice.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static("hello");\n/// assert_eq!(val.as_bytes(), b"hello");\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &[u8]{\n        self.as_ref()\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::from_bytes': ['/// Attempt to convert a byte slice to a `HeaderValue`.\n///\n/// If the argument contains invalid header value bytes, an error is\n/// returned. Only byte values between 32 and 255 (inclusive) are permitted,\n/// excluding byte 127 (DEL).\n///\n/// This function is intended to be replaced in the future by a `TryFrom`\n/// implementation once the trait is stabilized in std.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_bytes(b"hello\\xfa").unwrap();\n/// assert_eq!(val, &b"hello\\xfa"[..]);\n/// ```\n///\n/// An invalid value\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_bytes(b"\\n");\n/// assert!(val.is_err());\n/// ```\n#[inline]\npub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue>{\n        HeaderValue::try_from_generic(src, Bytes::copy_from_slice)\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::from_maybe_shared': ["/// Attempt to convert a `Bytes` buffer to a `HeaderValue`.\n///\n/// This will try to prevent a copy if the type passed is the type used\n/// internally, and will copy the data if it is not.\npub fn from_maybe_shared<T>(src: T) -> Result<HeaderValue, InvalidHeaderValue>\n    where\n        T: AsRef<[u8]> + 'static,{\n        if_downcast_into!(T, Bytes, src, {\n            return HeaderValue::from_shared(src);\n        });\n\n        HeaderValue::from_bytes(src.as_ref())\n    }", 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::from_maybe_shared_unchecked': ['/// Convert a `Bytes` directly into a `HeaderValue` without validating.\n///\n/// This function does NOT validate that illegal bytes are not contained\n/// within the buffer.\n///\n/// ## Panics\n/// In a debug build this will panic if `src` is not valid UTF-8.\n///\n/// ## Safety\n/// `src` must contain valid UTF-8. In a release build it is undefined\n/// behaviour to call this with `src` that is not valid UTF-8.\npub unsafe fn from_maybe_shared_unchecked<T>(src: T) -> HeaderValue\n    where\n        T: AsRef<[u8]> + \'static,{\n        if cfg!(debug_assertions) {\n            match HeaderValue::from_maybe_shared(src) {\n                Ok(val) => val,\n                Err(_err) => {\n                    panic!("HeaderValue::from_maybe_shared_unchecked() with invalid bytes");\n                }\n            }\n        } else {\n            if_downcast_into!(T, Bytes, src, {\n                return HeaderValue {\n                    inner: src,\n                    is_sensitive: false,\n                };\n            });\n\n            let src = Bytes::copy_from_slice(src.as_ref());\n            HeaderValue {\n                inner: src,\n                is_sensitive: false,\n            }\n        }\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::from_name': ['/// Converts a HeaderName into a HeaderValue\n///\n/// Since every valid HeaderName is a valid HeaderValue this is done infallibly.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderValue, HeaderName};\n/// # use http::header::ACCEPT;\n/// let val = HeaderValue::from_name(ACCEPT);\n/// assert_eq!(val, HeaderValue::from_bytes(b"accept").unwrap());\n/// ```\n#[inline]\npub fn from_name(name: HeaderName) -> HeaderValue{\n        name.into()\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::from_shared': ['fn from_shared(src: Bytes) -> Result<HeaderValue, InvalidHeaderValue>{\n        HeaderValue::try_from_generic(src, std::convert::identity)\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::from_static': ['/// Convert a static string to a `HeaderValue`.\n///\n/// This function will not perform any copying, however the string is\n/// checked to ensure that no invalid characters are present. Only visible\n/// ASCII characters (32-127) are permitted.\n///\n/// # Panics\n///\n/// This function panics if the argument contains invalid header value\n/// characters.\n///\n/// Until [Allow panicking in constants](https://github.com/rust-lang/rfcs/pull/2345)\n/// makes its way into stable, the panic message at compile-time is\n/// going to look cryptic, but should at least point at your header value:\n///\n/// ```text\n/// error: any use of this value will cause an error\n///   --> http/src/header/value.rs:67:17\n///    |\n/// 67 |                 ([] as [u8; 0])[0]; // Invalid header value\n///    |                 ^^^^^^^^^^^^^^^^^^\n///    |                 |\n///    |                 index out of bounds: the length is 0 but the index is 0\n///    |                 inside `HeaderValue::from_static` at http/src/header/value.rs:67:17\n///    |                 inside `INVALID_HEADER` at src/main.rs:73:33\n///    |\n///   ::: src/main.rs:73:1\n///    |\n/// 73 | const INVALID_HEADER: HeaderValue = HeaderValue::from_static("some value");\n///    | ----------------------------------------------------------------------------\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static("hello");\n/// assert_eq!(val, "hello");\n/// ```\n#[inline]\n#[allow(unconditional_panic)]\npub const fn from_static(src: &\'static str) -> HeaderValue{\n        let bytes = src.as_bytes();\n        let mut i = 0;\n        while i < bytes.len() {\n            if !is_visible_ascii(bytes[i]) {\n                // TODO: When msrv is bumped to larger than 1.57, this should be\n                // replaced with `panic!` macro.\n                // https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html#panic-in-const-contexts\n                //\n                // See the panics section of this method\'s document for details.\n                #[allow(clippy::no_effect, clippy::out_of_bounds_indexing)]\n                ([] as [u8; 0])[0]; // Invalid header value\n            }\n            i += 1;\n        }\n\n        HeaderValue {\n            inner: Bytes::from_static(bytes),\n            is_sensitive: false,\n        }\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::from_str': ['/// Attempt to convert a string to a `HeaderValue`.\n///\n/// If the argument contains invalid header value characters, an error is\n/// returned. Only visible ASCII characters (32-127) are permitted. Use\n/// `from_bytes` to create a `HeaderValue` that includes opaque octets\n/// (128-255).\n///\n/// This function is intended to be replaced in the future by a `TryFrom`\n/// implementation once the trait is stabilized in std.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_str("hello").unwrap();\n/// assert_eq!(val, "hello");\n/// ```\n///\n/// An invalid value\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_str("\\n");\n/// assert!(val.is_err());\n/// ```\n#[inline]\n#[allow(clippy::should_implement_trait)]\npub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue>{\n        HeaderValue::try_from_generic(src, |s| Bytes::copy_from_slice(s.as_bytes()))\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::is_empty': ['/// Returns true if the `HeaderValue` has a length of zero bytes.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static("");\n/// assert!(val.is_empty());\n///\n/// let val = HeaderValue::from_static("hello");\n/// assert!(!val.is_empty());\n/// ```\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::is_sensitive': ['/// Returns `true` if the value represents sensitive data.\n///\n/// Sensitive data could represent passwords or other data that should not\n/// be stored on disk or in memory. By marking header values as sensitive,\n/// components using this crate can be instructed to treat them with special\n/// care for security reasons. For example, caches can avoid storing\n/// sensitive values, and HPACK encoders used by HTTP/2.0 implementations\n/// can choose not to compress them.\n///\n/// Additionally, sensitive values will be masked by the `Debug`\n/// implementation of `HeaderValue`.\n///\n/// Note that sensitivity is not factored into equality or ordering.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let mut val = HeaderValue::from_static("my secret");\n///\n/// val.set_sensitive(true);\n/// assert!(val.is_sensitive());\n///\n/// val.set_sensitive(false);\n/// assert!(!val.is_sensitive());\n/// ```\n#[inline]\npub fn is_sensitive(&self) -> bool{\n        self.is_sensitive\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::len': ['/// Returns the length of `self`.\n///\n/// This length is in bytes.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static("hello");\n/// assert_eq!(val.len(), 5);\n/// ```\n#[inline]\npub fn len(&self) -> usize{\n        self.as_ref().len()\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::set_sensitive': ['/// Mark that the header value represents sensitive information.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let mut val = HeaderValue::from_static("my secret");\n///\n/// val.set_sensitive(true);\n/// assert!(val.is_sensitive());\n///\n/// val.set_sensitive(false);\n/// assert!(!val.is_sensitive());\n/// ```\n#[inline]\npub fn set_sensitive(&mut self, val: bool){\n        self.is_sensitive = val;\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::to_str': ['/// Yields a `&str` slice if the `HeaderValue` only contains visible ASCII\n/// chars.\n///\n/// This function will perform a scan of the header value, checking all the\n/// characters.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static("hello");\n/// assert_eq!(val.to_str().unwrap(), "hello");\n/// ```\npub fn to_str(&self) -> Result<&str, ToStrError>{\n        let bytes = self.as_ref();\n\n        for &b in bytes {\n            if !is_visible_ascii(b) {\n                return Err(ToStrError { _priv: () });\n            }\n        }\n\n        unsafe { Ok(str::from_utf8_unchecked(bytes)) }\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::HeaderValue::try_from_generic': ['fn try_from_generic<T: AsRef<[u8]>, F: FnOnce(T) -> Bytes>(\n        src: T,\n        into: F,\n    ) -> Result<HeaderValue, InvalidHeaderValue>{\n        for &b in src.as_ref() {\n            if !is_valid(b) {\n                return Err(InvalidHeaderValue { _priv: () });\n            }\n        }\n        Ok(HeaderValue {\n            inner: into(src),\n            is_sensitive: false,\n        })\n    }', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::InvalidHeaderValue': ['/// A possible error when converting a `HeaderValue` from a string or byte\n/// slice.\npub struct InvalidHeaderValue {\n    _priv: (),\n}', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::ToStrError': ['/// A possible error when converting a `HeaderValue` to a string representation.\n///\n/// Header field values may contain opaque bytes, in which case it is not\n/// possible to represent the value as a string.\npub struct ToStrError {\n    _priv: (),\n}', 'Real(LocalPath("src/header/value.rs"))'], 'header::value::is_valid': ["#[inline]\nfn is_valid(b: u8) -> bool{\n    b >= 32 && b != 127 || b == b'\\t'\n}", 'Real(LocalPath("src/header/value.rs"))'], 'header::value::is_visible_ascii': ["const fn is_visible_ascii(b: u8) -> bool{\n    b >= 32 && b < 127 || b == b'\\t'\n}", 'Real(LocalPath("src/header/value.rs"))'], "method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq": ['#[inline]\nfn eq(&self, other: &Method) -> bool{\n        *self == other.as_ref()\n    }', 'Real(LocalPath("src/method.rs"))'], 'method::<impl std::cmp::PartialEq<method::Method> for str>::eq': ['#[inline]\nfn eq(&self, other: &Method) -> bool{\n        self == other.as_ref()\n    }', 'Real(LocalPath("src/method.rs"))'], 'method::Inner': ['enum Inner {\n    Options,\n    Get,\n    Post,\n    Put,\n    Delete,\n    Head,\n    Trace,\n    Connect,\n    Patch,\n    // If the extension is short enough, store it inline\n    ExtensionInline(InlineExtension),\n    // Otherwise, allocate it\n    ExtensionAllocated(AllocatedExtension),\n}', 'Real(LocalPath("src/method.rs"))'], 'method::InvalidMethod': ['/// A possible error value when converting `Method` from bytes.\npub struct InvalidMethod {\n    _priv: (),\n}', 'Real(LocalPath("src/method.rs"))'], 'method::InvalidMethod::new': ['fn new() -> InvalidMethod{\n        InvalidMethod { _priv: () }\n    }', 'Real(LocalPath("src/method.rs"))'], 'method::Method': ['/// The Request Method (VERB)\n///\n/// This type also contains constants for a number of common HTTP methods such\n/// as GET, POST, etc.\n///\n/// Currently includes 8 variants representing the 8 methods defined in\n/// [RFC 7230](https://tools.ietf.org/html/rfc7231#section-4.1), plus PATCH,\n/// and an Extension variant for all extensions.\n///\n/// # Examples\n///\n/// ```\n/// use http::Method;\n///\n/// assert_eq!(Method::GET, Method::from_bytes(b"GET").unwrap());\n/// assert!(Method::GET.is_idempotent());\n/// assert_eq!(Method::POST.as_str(), "POST");\n/// ```\npub struct Method(Inner);', 'Real(LocalPath("src/method.rs"))'], 'method::Method::as_str': ['/// Return a &str representation of the HTTP method\n#[inline]\npub fn as_str(&self) -> &str{\n        match self.0 {\n            Options => "OPTIONS",\n            Get => "GET",\n            Post => "POST",\n            Put => "PUT",\n            Delete => "DELETE",\n            Head => "HEAD",\n            Trace => "TRACE",\n            Connect => "CONNECT",\n            Patch => "PATCH",\n            ExtensionInline(ref inline) => inline.as_str(),\n            ExtensionAllocated(ref allocated) => allocated.as_str(),\n        }\n    }', 'Real(LocalPath("src/method.rs"))'], 'method::Method::extension_inline': ['fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod>{\n        let inline = InlineExtension::new(src)?;\n\n        Ok(Method(ExtensionInline(inline)))\n    }', 'Real(LocalPath("src/method.rs"))'], 'method::Method::from_bytes': ['/// Converts a slice of bytes to an HTTP method.\npub fn from_bytes(src: &[u8]) -> Result<Method, InvalidMethod>{\n        match src.len() {\n            0 => Err(InvalidMethod::new()),\n            3 => match src {\n                b"GET" => Ok(Method(Get)),\n                b"PUT" => Ok(Method(Put)),\n                _ => Method::extension_inline(src),\n            },\n            4 => match src {\n                b"POST" => Ok(Method(Post)),\n                b"HEAD" => Ok(Method(Head)),\n                _ => Method::extension_inline(src),\n            },\n            5 => match src {\n                b"PATCH" => Ok(Method(Patch)),\n                b"TRACE" => Ok(Method(Trace)),\n                _ => Method::extension_inline(src),\n            },\n            6 => match src {\n                b"DELETE" => Ok(Method(Delete)),\n                _ => Method::extension_inline(src),\n            },\n            7 => match src {\n                b"OPTIONS" => Ok(Method(Options)),\n                b"CONNECT" => Ok(Method(Connect)),\n                _ => Method::extension_inline(src),\n            },\n            _ => {\n                if src.len() <= InlineExtension::MAX {\n                    Method::extension_inline(src)\n                } else {\n                    let allocated = AllocatedExtension::new(src)?;\n\n                    Ok(Method(ExtensionAllocated(allocated)))\n                }\n            }\n        }\n    }', 'Real(LocalPath("src/method.rs"))'], 'method::Method::is_idempotent': ['/// Whether a method is considered "idempotent", meaning the request has\n/// the same result if executed multiple times.\n///\n/// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.2) for\n/// more words.\npub fn is_idempotent(&self) -> bool{\n        match self.0 {\n            Put | Delete => true,\n            _ => self.is_safe(),\n        }\n    }', 'Real(LocalPath("src/method.rs"))'], 'method::Method::is_safe': ['/// Whether a method is considered "safe", meaning the request is\n/// essentially read-only.\n///\n/// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.1)\n/// for more words.\npub fn is_safe(&self) -> bool{\n        matches!(self.0, Get | Head | Options | Trace)\n    }', 'Real(LocalPath("src/method.rs"))'], 'method::extension::AllocatedExtension': ['pub struct AllocatedExtension(Box<[u8]>);', 'Real(LocalPath("src/method.rs"))'], 'method::extension::AllocatedExtension::as_str': ['pub fn as_str(&self) -> &str{\n            // Safety: the invariant of AllocatedExtension ensures that self.0\n            // contains valid UTF-8.\n            unsafe { str::from_utf8_unchecked(&self.0) }\n        }', 'Real(LocalPath("src/method.rs"))'], 'method::extension::AllocatedExtension::new': ['pub fn new(src: &[u8]) -> Result<AllocatedExtension, InvalidMethod>{\n            let mut data: Vec<u8> = vec![0; src.len()];\n\n            write_checked(src, &mut data)?;\n\n            // Invariant: data is exactly src.len() long and write_checked\n            // ensures that the first src.len() bytes of data are valid UTF-8.\n            Ok(AllocatedExtension(data.into_boxed_slice()))\n        }', 'Real(LocalPath("src/method.rs"))'], 'method::extension::InlineExtension': ['pub struct InlineExtension([u8; InlineExtension::MAX], u8);', 'Real(LocalPath("src/method.rs"))'], 'method::extension::InlineExtension::as_str': ['pub fn as_str(&self) -> &str{\n            let InlineExtension(ref data, len) = self;\n            // Safety: the invariant of InlineExtension ensures that the first\n            // len bytes of data contain valid UTF-8.\n            unsafe { str::from_utf8_unchecked(&data[..*len as usize]) }\n        }', 'Real(LocalPath("src/method.rs"))'], 'method::extension::InlineExtension::new': ['pub fn new(src: &[u8]) -> Result<InlineExtension, InvalidMethod>{\n            let mut data: [u8; InlineExtension::MAX] = Default::default();\n\n            write_checked(src, &mut data)?;\n\n            // Invariant: write_checked ensures that the first src.len() bytes\n            // of data are valid UTF-8.\n            Ok(InlineExtension(data, src.len() as u8))\n        }', 'Real(LocalPath("src/method.rs"))'], 'method::extension::write_checked': ['fn write_checked(src: &[u8], dst: &mut [u8]) -> Result<(), InvalidMethod>{\n        for (i, &b) in src.iter().enumerate() {\n            let b = METHOD_CHARS[b as usize];\n\n            if b == 0 {\n                return Err(InvalidMethod::new());\n            }\n\n            dst[i] = b;\n        }\n\n        Ok(())\n    }', 'Real(LocalPath("src/method.rs"))'], 'request::Builder': ['/// An HTTP request builder\n///\n/// This type can be used to construct an instance or `Request`\n/// through a builder-like pattern.\npub struct Builder {\n    inner: Result<Parts>,\n}', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::and_then': ['fn and_then<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts>,{\n        Builder {\n            inner: self.inner.and_then(func),\n        }\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::body': ['/// "Consumes" this builder, using the provided `body` to return a\n/// constructed `Request`.\n///\n/// # Errors\n///\n/// This function may return an error if any previously configured argument\n/// failed to parse or get converted to the internal representation. For\n/// example if an invalid `head` was specified via `header("Foo",\n/// "Bar\\r\\n")` the error will be returned when this function is called\n/// rather than when `header` was called.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::builder()\n///     .body(())\n///     .unwrap();\n/// ```\npub fn body<T>(self, body: T) -> Result<Request<T>>{\n        self.inner.map(move |head| Request { head, body })\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::extension': ['/// Adds an extension to this builder\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .extension("My Extension")\n///     .body(())\n///     .unwrap();\n///\n/// assert_eq!(req.extensions().get::<&\'static str>(),\n///            Some(&"My Extension"));\n/// ```\npub fn extension<T>(self, extension: T) -> Builder\n    where\n        T: Clone + Any + Send + Sync + \'static,{\n        self.and_then(move |mut head| {\n            head.extensions.insert(extension);\n            Ok(head)\n        })\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::extensions_mut': ['/// Get a mutable reference to the extensions for this request builder.\n///\n/// If the builder has an error, this returns `None`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Request;\n/// let mut req = Request::builder().extension("My Extension");\n/// let mut extensions = req.extensions_mut().unwrap();\n/// assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n/// extensions.insert(5u32);\n/// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n/// ```\npub fn extensions_mut(&mut self) -> Option<&mut Extensions>{\n        self.inner.as_mut().ok().map(|h| &mut h.extensions)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::extensions_ref': ['/// Get a reference to the extensions for this request builder.\n///\n/// If the builder has an error, this returns `None`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Request;\n/// let req = Request::builder().extension("My Extension").extension(5u32);\n/// let extensions = req.extensions_ref().unwrap();\n/// assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n/// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n/// ```\npub fn extensions_ref(&self) -> Option<&Extensions>{\n        self.inner.as_ref().ok().map(|h| &h.extensions)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::header': ['/// Appends a header to this request builder.\n///\n/// This function will append the provided key/value as a header to the\n/// internal `HeaderMap` being constructed. Essentially this is equivalent\n/// to calling `HeaderMap::append`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n///\n/// let req = Request::builder()\n///     .header("Accept", "text/html")\n///     .header("X-Custom-Foo", "bar")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn header<K, V>(self, key: K, value: V) -> Builder\n    where\n        K: TryInto<HeaderName>,\n        <K as TryInto<HeaderName>>::Error: Into<crate::Error>,\n        V: TryInto<HeaderValue>,\n        <V as TryInto<HeaderValue>>::Error: Into<crate::Error>,{\n        self.and_then(move |mut head| {\n            let name = key.try_into().map_err(Into::into)?;\n            let value = value.try_into().map_err(Into::into)?;\n            head.headers.try_append(name, value)?;\n            Ok(head)\n        })\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::headers_mut': ['/// Get headers on this request builder.\n///\n/// When builder has error returns None.\n///\n/// # Example\n///\n/// ```\n/// # use http::{header::HeaderValue, Request};\n/// let mut req = Request::builder();\n/// {\n///   let headers = req.headers_mut().unwrap();\n///   headers.insert("Accept", HeaderValue::from_static("text/html"));\n///   headers.insert("X-Custom-Foo", HeaderValue::from_static("bar"));\n/// }\n/// let headers = req.headers_ref().unwrap();\n/// assert_eq!( headers["Accept"], "text/html" );\n/// assert_eq!( headers["X-Custom-Foo"], "bar" );\n/// ```\npub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>>{\n        self.inner.as_mut().ok().map(|h| &mut h.headers)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::headers_ref': ['/// Get header on this request builder.\n/// when builder has error returns None\n///\n/// # Example\n///\n/// ```\n/// # use http::Request;\n/// let req = Request::builder()\n///     .header("Accept", "text/html")\n///     .header("X-Custom-Foo", "bar");\n/// let headers = req.headers_ref().unwrap();\n/// assert_eq!( headers["Accept"], "text/html" );\n/// assert_eq!( headers["X-Custom-Foo"], "bar" );\n/// ```\npub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>>{\n        self.inner.as_ref().ok().map(|h| &h.headers)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::method': ['/// Set the HTTP method for this request.\n///\n/// By default this is `GET`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .method("POST")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn method<T>(self, method: T) -> Builder\n    where\n        T: TryInto<Method>,\n        <T as TryInto<Method>>::Error: Into<crate::Error>,{\n        self.and_then(move |mut head| {\n            let method = method.try_into().map_err(Into::into)?;\n            head.method = method;\n            Ok(head)\n        })\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::method_ref': ['/// Get the HTTP Method for this request.\n///\n/// By default this is `GET`. If builder has error, returns None.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let mut req = Request::builder();\n/// assert_eq!(req.method_ref(),Some(&Method::GET));\n///\n/// req = req.method("POST");\n/// assert_eq!(req.method_ref(),Some(&Method::POST));\n/// ```\npub fn method_ref(&self) -> Option<&Method>{\n        self.inner.as_ref().ok().map(|h| &h.method)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::new': ['/// Creates a new default instance of `Builder` to construct a `Request`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = request::Builder::new()\n///     .method("POST")\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn new() -> Builder{\n        Builder::default()\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::uri': ['/// Set the URI for this request.\n///\n/// By default this is `/`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .uri("https://www.rust-lang.org/")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn uri<T>(self, uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        self.and_then(move |mut head| {\n            head.uri = uri.try_into().map_err(Into::into)?;\n            Ok(head)\n        })\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::uri_ref': ['/// Get the URI for this request\n///\n/// By default this is `/`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let mut req = Request::builder();\n/// assert_eq!(req.uri_ref().unwrap(), "/" );\n///\n/// req = req.uri("https://www.rust-lang.org/");\n/// assert_eq!(req.uri_ref().unwrap(), "https://www.rust-lang.org/" );\n/// ```\npub fn uri_ref(&self) -> Option<&Uri>{\n        self.inner.as_ref().ok().map(|h| &h.uri)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::version': ['/// Set the HTTP version for this request.\n///\n/// By default this is HTTP/1.1\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .version(Version::HTTP_2)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn version(self, version: Version) -> Builder{\n        self.and_then(move |mut head| {\n            head.version = version;\n            Ok(head)\n        })\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Builder::version_ref': ['/// Get the HTTP version for this request\n///\n/// By default this is HTTP/1.1.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let mut req = Request::builder();\n/// assert_eq!(req.version_ref().unwrap(), &Version::HTTP_11 );\n///\n/// req = req.version(Version::HTTP_2);\n/// assert_eq!(req.version_ref().unwrap(), &Version::HTTP_2 );\n/// ```\npub fn version_ref(&self) -> Option<&Version>{\n        self.inner.as_ref().ok().map(|h| &h.version)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Parts': ["/// Component parts of an HTTP `Request`\n///\n/// The HTTP request head consists of a method, uri, version, and a set of\n/// header fields.\npub struct Parts {\n    /// The request's method\n    pub method: Method,\n\n    /// The request's URI\n    pub uri: Uri,\n\n    /// The request's version\n    pub version: Version,\n\n    /// The request's headers\n    pub headers: HeaderMap<HeaderValue>,\n\n    /// The request's extensions\n    pub extensions: Extensions,\n\n    _priv: (),\n}", 'Real(LocalPath("src/request.rs"))'], 'request::Parts::new': ['/// Creates a new default instance of `Parts`\nfn new() -> Parts{\n        Parts {\n            method: Method::default(),\n            uri: Uri::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request': ['/// Represents an HTTP request.\n///\n/// An HTTP request consists of a head and a potentially optional body. The body\n/// component is generic, enabling arbitrary types to represent the HTTP body.\n/// For example, the body could be `Vec<u8>`, a `Stream` of byte chunks, or a\n/// value that has been deserialized.\n///\n/// # Examples\n///\n/// Creating a `Request` to send\n///\n/// ```no_run\n/// use http::{Request, Response};\n///\n/// let mut request = Request::builder()\n///     .uri("https://www.rust-lang.org/")\n///     .header("User-Agent", "my-awesome-agent/1.0");\n///\n/// if needs_awesome_header() {\n///     request = request.header("Awesome", "yes");\n/// }\n///\n/// let response = send(request.body(()).unwrap());\n///\n/// # fn needs_awesome_header() -> bool {\n/// #     true\n/// # }\n/// #\n/// fn send(req: Request<()>) -> Response<()> {\n///     // ...\n/// # panic!()\n/// }\n/// ```\n///\n/// Inspecting a request to see what was sent.\n///\n/// ```\n/// use http::{Request, Response, StatusCode};\n///\n/// fn respond_to(req: Request<()>) -> http::Result<Response<()>> {\n///     if req.uri() != "/awesome-url" {\n///         return Response::builder()\n///             .status(StatusCode::NOT_FOUND)\n///             .body(())\n///     }\n///\n///     let has_awesome_header = req.headers().contains_key("Awesome");\n///     let body = req.body();\n///\n///     // ...\n/// # panic!()\n/// }\n/// ```\n///\n/// Deserialize a request of bytes via json:\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Request;\n/// use serde::de;\n///\n/// fn deserialize<T>(req: Request<Vec<u8>>) -> serde_json::Result<Request<T>>\n///     where for<\'de> T: de::Deserialize<\'de>,\n/// {\n///     let (parts, body) = req.into_parts();\n///     let body = serde_json::from_slice(&body)?;\n///     Ok(Request::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\n///\n/// Or alternatively, serialize the body of a request to json\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Request;\n/// use serde::ser;\n///\n/// fn serialize<T>(req: Request<T>) -> serde_json::Result<Request<Vec<u8>>>\n///     where T: ser::Serialize,\n/// {\n///     let (parts, body) = req.into_parts();\n///     let body = serde_json::to_vec(&body)?;\n///     Ok(Request::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\npub struct Request<T> {\n    head: Parts,\n    body: T,\n}', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<()>::builder': ['/// Creates a new builder-style object to manufacture a `Request`\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::builder()\n///     .method("GET")\n///     .uri("https://www.rust-lang.org/")\n///     .header("X-Custom-Foo", "Bar")\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn builder() -> Builder{\n        Builder::new()\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<()>::connect': ['/// Creates a new `Builder` initialized with a CONNECT method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::connect("https://www.rust-lang.org/")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn connect<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::CONNECT).uri(uri)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<()>::delete': ['/// Creates a new `Builder` initialized with a DELETE method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::delete("https://www.rust-lang.org/")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn delete<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::DELETE).uri(uri)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<()>::get': ['/// Creates a new `Builder` initialized with a GET method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::get("https://www.rust-lang.org/")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn get<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::GET).uri(uri)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<()>::head': ['/// Creates a new `Builder` initialized with a HEAD method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::head("https://www.rust-lang.org/")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn head<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::HEAD).uri(uri)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<()>::options': ['/// Creates a new `Builder` initialized with an OPTIONS method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::options("https://www.rust-lang.org/")\n///     .body(())\n///     .unwrap();\n/// # assert_eq!(*request.method(), Method::OPTIONS);\n/// ```\npub fn options<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::OPTIONS).uri(uri)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<()>::patch': ['/// Creates a new `Builder` initialized with a PATCH method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::patch("https://www.rust-lang.org/")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn patch<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::PATCH).uri(uri)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<()>::post': ['/// Creates a new `Builder` initialized with a POST method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::post("https://www.rust-lang.org/")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn post<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::POST).uri(uri)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<()>::put': ['/// Creates a new `Builder` initialized with a PUT method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::put("https://www.rust-lang.org/")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn put<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::PUT).uri(uri)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<()>::trace': ['/// Creates a new `Builder` initialized with a TRACE method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::trace("https://www.rust-lang.org/")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn trace<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::TRACE).uri(uri)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::body': ['/// Returns a reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<String> = Request::default();\n/// assert!(request.body().is_empty());\n/// ```\n#[inline]\npub fn body(&self) -> &T{\n        &self.body\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::body_mut': ['/// Returns a mutable reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<String> = Request::default();\n/// request.body_mut().push_str("hello world");\n/// assert!(!request.body().is_empty());\n/// ```\n#[inline]\npub fn body_mut(&mut self) -> &mut T{\n        &mut self.body\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::extensions': ['/// Returns a reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert!(request.extensions().get::<i32>().is_none());\n/// ```\n#[inline]\npub fn extensions(&self) -> &Extensions{\n        &self.head.extensions\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::extensions_mut': ['/// Returns a mutable reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut request: Request<()> = Request::default();\n/// request.extensions_mut().insert("hello");\n/// assert_eq!(request.extensions().get(), Some(&"hello"));\n/// ```\n#[inline]\npub fn extensions_mut(&mut self) -> &mut Extensions{\n        &mut self.head.extensions\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::from_parts': ['/// Creates a new `Request` with the given components parts and body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::new("hello world");\n/// let (mut parts, body) = request.into_parts();\n/// parts.method = Method::POST;\n///\n/// let request = Request::from_parts(parts, body);\n/// ```\n#[inline]\npub fn from_parts(parts: Parts, body: T) -> Request<T>{\n        Request { head: parts, body }\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::headers': ['/// Returns a reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert!(request.headers().is_empty());\n/// ```\n#[inline]\npub fn headers(&self) -> &HeaderMap<HeaderValue>{\n        &self.head.headers\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::headers_mut': ['/// Returns a mutable reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut request: Request<()> = Request::default();\n/// request.headers_mut().insert(HOST, HeaderValue::from_static("world"));\n/// assert!(!request.headers().is_empty());\n/// ```\n#[inline]\npub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue>{\n        &mut self.head.headers\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::into_body': ['/// Consumes the request, returning just the body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::Request;\n/// let request = Request::new(10);\n/// let body = request.into_body();\n/// assert_eq!(body, 10);\n/// ```\n#[inline]\npub fn into_body(self) -> T{\n        self.body\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::into_parts': ['/// Consumes the request returning the head and body parts.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::new(());\n/// let (parts, body) = request.into_parts();\n/// assert_eq!(parts.method, Method::GET);\n/// ```\n#[inline]\npub fn into_parts(self) -> (Parts, T){\n        (self.head, self.body)\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::map': ['/// Consumes the request returning a new request with body mapped to the\n/// return type of the passed in function.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::builder().body("some string").unwrap();\n/// let mapped_request: Request<&[u8]> = request.map(|b| {\n///   assert_eq!(b, "some string");\n///   b.as_bytes()\n/// });\n/// assert_eq!(mapped_request.body(), &"some string".as_bytes());\n/// ```\n#[inline]\npub fn map<F, U>(self, f: F) -> Request<U>\n    where\n        F: FnOnce(T) -> U,{\n        Request {\n            body: f(self.body),\n            head: self.head,\n        }\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::method': ['/// Returns a reference to the associated HTTP method.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert_eq!(*request.method(), Method::GET);\n/// ```\n#[inline]\npub fn method(&self) -> &Method{\n        &self.head.method\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::method_mut': ['/// Returns a mutable reference to the associated HTTP method.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<()> = Request::default();\n/// *request.method_mut() = Method::PUT;\n/// assert_eq!(*request.method(), Method::PUT);\n/// ```\n#[inline]\npub fn method_mut(&mut self) -> &mut Method{\n        &mut self.head.method\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::new': ['/// Creates a new blank `Request` with the body\n///\n/// The component parts of this request will be set to their default, e.g.\n/// the GET method, no headers, etc.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::new("hello world");\n///\n/// assert_eq!(*request.method(), Method::GET);\n/// assert_eq!(*request.body(), "hello world");\n/// ```\n#[inline]\npub fn new(body: T) -> Request<T>{\n        Request {\n            head: Parts::new(),\n            body,\n        }\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::uri': ['/// Returns a reference to the associated URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert_eq!(*request.uri(), *"/");\n/// ```\n#[inline]\npub fn uri(&self) -> &Uri{\n        &self.head.uri\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::uri_mut': ['/// Returns a mutable reference to the associated URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<()> = Request::default();\n/// *request.uri_mut() = "/hello".parse().unwrap();\n/// assert_eq!(*request.uri(), *"/hello");\n/// ```\n#[inline]\npub fn uri_mut(&mut self) -> &mut Uri{\n        &mut self.head.uri\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::version': ['/// Returns the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert_eq!(request.version(), Version::HTTP_11);\n/// ```\n#[inline]\npub fn version(&self) -> Version{\n        self.head.version\n    }', 'Real(LocalPath("src/request.rs"))'], 'request::Request::<T>::version_mut': ['/// Returns a mutable reference to the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<()> = Request::default();\n/// *request.version_mut() = Version::HTTP_2;\n/// assert_eq!(request.version(), Version::HTTP_2);\n/// ```\n#[inline]\npub fn version_mut(&mut self) -> &mut Version{\n        &mut self.head.version\n    }', 'Real(LocalPath("src/request.rs"))'], 'response::Builder': ['/// An HTTP response builder\n///\n/// This type can be used to construct an instance of `Response` through a\n/// builder-like pattern.\npub struct Builder {\n    inner: Result<Parts>,\n}', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::and_then': ['fn and_then<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts>,{\n        Builder {\n            inner: self.inner.and_then(func),\n        }\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::body': ['/// "Consumes" this builder, using the provided `body` to return a\n/// constructed `Response`.\n///\n/// # Errors\n///\n/// This function may return an error if any previously configured argument\n/// failed to parse or get converted to the internal representation. For\n/// example if an invalid `head` was specified via `header("Foo",\n/// "Bar\\r\\n")` the error will be returned when this function is called\n/// rather than when `header` was called.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .body(())\n///     .unwrap();\n/// ```\npub fn body<T>(self, body: T) -> Result<Response<T>>{\n        self.inner.map(move |head| Response { head, body })\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::extension': ['/// Adds an extension to this builder\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .extension("My Extension")\n///     .body(())\n///     .unwrap();\n///\n/// assert_eq!(response.extensions().get::<&\'static str>(),\n///            Some(&"My Extension"));\n/// ```\npub fn extension<T>(self, extension: T) -> Builder\n    where\n        T: Clone + Any + Send + Sync + \'static,{\n        self.and_then(move |mut head| {\n            head.extensions.insert(extension);\n            Ok(head)\n        })\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::extensions_mut': ['/// Get a mutable reference to the extensions for this response builder.\n///\n/// If the builder has an error, this returns `None`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Response;\n/// let mut res = Response::builder().extension("My Extension");\n/// let mut extensions = res.extensions_mut().unwrap();\n/// assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n/// extensions.insert(5u32);\n/// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n/// ```\npub fn extensions_mut(&mut self) -> Option<&mut Extensions>{\n        self.inner.as_mut().ok().map(|h| &mut h.extensions)\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::extensions_ref': ['/// Get a reference to the extensions for this response builder.\n///\n/// If the builder has an error, this returns `None`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Response;\n/// let res = Response::builder().extension("My Extension").extension(5u32);\n/// let extensions = res.extensions_ref().unwrap();\n/// assert_eq!(extensions.get::<&\'static str>(), Some(&"My Extension"));\n/// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n/// ```\npub fn extensions_ref(&self) -> Option<&Extensions>{\n        self.inner.as_ref().ok().map(|h| &h.extensions)\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::header': ['/// Appends a header to this response builder.\n///\n/// This function will append the provided key/value as a header to the\n/// internal `HeaderMap` being constructed. Essentially this is equivalent\n/// to calling `HeaderMap::append`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n///\n/// let response = Response::builder()\n///     .header("Content-Type", "text/html")\n///     .header("X-Custom-Foo", "bar")\n///     .header("content-length", 0)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn header<K, V>(self, key: K, value: V) -> Builder\n    where\n        K: TryInto<HeaderName>,\n        <K as TryInto<HeaderName>>::Error: Into<crate::Error>,\n        V: TryInto<HeaderValue>,\n        <V as TryInto<HeaderValue>>::Error: Into<crate::Error>,{\n        self.and_then(move |mut head| {\n            let name = key.try_into().map_err(Into::into)?;\n            let value = value.try_into().map_err(Into::into)?;\n            head.headers.try_append(name, value)?;\n            Ok(head)\n        })\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::headers_mut': ['/// Get header on this response builder.\n/// when builder has error returns None\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n/// # use http::response::Builder;\n/// let mut res = Response::builder();\n/// {\n///   let headers = res.headers_mut().unwrap();\n///   headers.insert("Accept", HeaderValue::from_static("text/html"));\n///   headers.insert("X-Custom-Foo", HeaderValue::from_static("bar"));\n/// }\n/// let headers = res.headers_ref().unwrap();\n/// assert_eq!( headers["Accept"], "text/html" );\n/// assert_eq!( headers["X-Custom-Foo"], "bar" );\n/// ```\npub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>>{\n        self.inner.as_mut().ok().map(|h| &mut h.headers)\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::headers_ref': ['/// Get header on this response builder.\n///\n/// When builder has error returns None.\n///\n/// # Example\n///\n/// ```\n/// # use http::Response;\n/// # use http::header::HeaderValue;\n/// let res = Response::builder()\n///     .header("Accept", "text/html")\n///     .header("X-Custom-Foo", "bar");\n/// let headers = res.headers_ref().unwrap();\n/// assert_eq!( headers["Accept"], "text/html" );\n/// assert_eq!( headers["X-Custom-Foo"], "bar" );\n/// ```\npub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>>{\n        self.inner.as_ref().ok().map(|h| &h.headers)\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::new': ['/// Creates a new default instance of `Builder` to construct either a\n/// `Head` or a `Response`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = response::Builder::new()\n///     .status(200)\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn new() -> Builder{\n        Builder::default()\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::status': ['/// Set the HTTP status for this response.\n///\n/// By default this is `200`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .status(200)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn status<T>(self, status: T) -> Builder\n    where\n        T: TryInto<StatusCode>,\n        <T as TryInto<StatusCode>>::Error: Into<crate::Error>,{\n        self.and_then(move |mut head| {\n            head.status = status.try_into().map_err(Into::into)?;\n            Ok(head)\n        })\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Builder::version': ['/// Set the HTTP version for this response.\n///\n/// By default this is HTTP/1.1\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .version(Version::HTTP_2)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn version(self, version: Version) -> Builder{\n        self.and_then(move |mut head| {\n            head.version = version;\n            Ok(head)\n        })\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Parts': ["/// Component parts of an HTTP `Response`\n///\n/// The HTTP response head consists of a status, version, and a set of\n/// header fields.\npub struct Parts {\n    /// The response's status\n    pub status: StatusCode,\n\n    /// The response's version\n    pub version: Version,\n\n    /// The response's headers\n    pub headers: HeaderMap<HeaderValue>,\n\n    /// The response's extensions\n    pub extensions: Extensions,\n\n    _priv: (),\n}", 'Real(LocalPath("src/response.rs"))'], 'response::Parts::new': ['/// Creates a new default instance of `Parts`\nfn new() -> Parts{\n        Parts {\n            status: StatusCode::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response': ['/// Represents an HTTP response\n///\n/// An HTTP response consists of a head and a potentially optional body. The body\n/// component is generic, enabling arbitrary types to represent the HTTP body.\n/// For example, the body could be `Vec<u8>`, a `Stream` of byte chunks, or a\n/// value that has been deserialized.\n///\n/// Typically you\'ll work with responses on the client side as the result of\n/// sending a `Request` and on the server you\'ll be generating a `Response` to\n/// send back to the client.\n///\n/// # Examples\n///\n/// Creating a `Response` to return\n///\n/// ```\n/// use http::{Request, Response, StatusCode};\n///\n/// fn respond_to(req: Request<()>) -> http::Result<Response<()>> {\n///     let mut builder = Response::builder()\n///         .header("Foo", "Bar")\n///         .status(StatusCode::OK);\n///\n///     if req.headers().contains_key("Another-Header") {\n///         builder = builder.header("Another-Header", "Ack");\n///     }\n///\n///     builder.body(())\n/// }\n/// ```\n///\n/// A simple 404 handler\n///\n/// ```\n/// use http::{Request, Response, StatusCode};\n///\n/// fn not_found(_req: Request<()>) -> http::Result<Response<()>> {\n///     Response::builder()\n///         .status(StatusCode::NOT_FOUND)\n///         .body(())\n/// }\n/// ```\n///\n/// Or otherwise inspecting the result of a request:\n///\n/// ```no_run\n/// use http::{Request, Response};\n///\n/// fn get(url: &str) -> http::Result<Response<()>> {\n///     // ...\n/// # panic!()\n/// }\n///\n/// let response = get("https://www.rust-lang.org/").unwrap();\n///\n/// if !response.status().is_success() {\n///     panic!("failed to get a successful response status!");\n/// }\n///\n/// if let Some(date) = response.headers().get("Date") {\n///     // we\'ve got a `Date` header!\n/// }\n///\n/// let body = response.body();\n/// // ...\n/// ```\n///\n/// Deserialize a response of bytes via json:\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Response;\n/// use serde::de;\n///\n/// fn deserialize<T>(res: Response<Vec<u8>>) -> serde_json::Result<Response<T>>\n///     where for<\'de> T: de::Deserialize<\'de>,\n/// {\n///     let (parts, body) = res.into_parts();\n///     let body = serde_json::from_slice(&body)?;\n///     Ok(Response::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\n///\n/// Or alternatively, serialize the body of a response to json\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Response;\n/// use serde::ser;\n///\n/// fn serialize<T>(res: Response<T>) -> serde_json::Result<Response<Vec<u8>>>\n///     where T: ser::Serialize,\n/// {\n///     let (parts, body) = res.into_parts();\n///     let body = serde_json::to_vec(&body)?;\n///     Ok(Response::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\npub struct Response<T> {\n    head: Parts,\n    body: T,\n}', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<()>::builder': ['/// Creates a new builder-style object to manufacture a `Response`\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Response`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::builder()\n///     .status(200)\n///     .header("X-Custom-Foo", "Bar")\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn builder() -> Builder{\n        Builder::new()\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::body': ['/// Returns a reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<String> = Response::default();\n/// assert!(response.body().is_empty());\n/// ```\n#[inline]\npub fn body(&self) -> &T{\n        &self.body\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::body_mut': ['/// Returns a mutable reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut response: Response<String> = Response::default();\n/// response.body_mut().push_str("hello world");\n/// assert!(!response.body().is_empty());\n/// ```\n#[inline]\npub fn body_mut(&mut self) -> &mut T{\n        &mut self.body\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::extensions': ['/// Returns a reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert!(response.extensions().get::<i32>().is_none());\n/// ```\n#[inline]\npub fn extensions(&self) -> &Extensions{\n        &self.head.extensions\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::extensions_mut': ['/// Returns a mutable reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut response: Response<()> = Response::default();\n/// response.extensions_mut().insert("hello");\n/// assert_eq!(response.extensions().get(), Some(&"hello"));\n/// ```\n#[inline]\npub fn extensions_mut(&mut self) -> &mut Extensions{\n        &mut self.head.extensions\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::from_parts': ['/// Creates a new `Response` with the given head and body\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::new("hello world");\n/// let (mut parts, body) = response.into_parts();\n///\n/// parts.status = StatusCode::BAD_REQUEST;\n/// let response = Response::from_parts(parts, body);\n///\n/// assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n/// assert_eq!(*response.body(), "hello world");\n/// ```\n#[inline]\npub fn from_parts(parts: Parts, body: T) -> Response<T>{\n        Response { head: parts, body }\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::headers': ['/// Returns a reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert!(response.headers().is_empty());\n/// ```\n#[inline]\npub fn headers(&self) -> &HeaderMap<HeaderValue>{\n        &self.head.headers\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::headers_mut': ['/// Returns a mutable reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut response: Response<()> = Response::default();\n/// response.headers_mut().insert(HOST, HeaderValue::from_static("world"));\n/// assert!(!response.headers().is_empty());\n/// ```\n#[inline]\npub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue>{\n        &mut self.head.headers\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::into_body': ['/// Consumes the response, returning just the body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::Response;\n/// let response = Response::new(10);\n/// let body = response.into_body();\n/// assert_eq!(body, 10);\n/// ```\n#[inline]\npub fn into_body(self) -> T{\n        self.body\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::into_parts': ['/// Consumes the response returning the head and body parts.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// let (parts, body) = response.into_parts();\n/// assert_eq!(parts.status, StatusCode::OK);\n/// ```\n#[inline]\npub fn into_parts(self) -> (Parts, T){\n        (self.head, self.body)\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::map': ['/// Consumes the response returning a new response with body mapped to the\n/// return type of the passed in function.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::builder().body("some string").unwrap();\n/// let mapped_response: Response<&[u8]> = response.map(|b| {\n///   assert_eq!(b, "some string");\n///   b.as_bytes()\n/// });\n/// assert_eq!(mapped_response.body(), &"some string".as_bytes());\n/// ```\n#[inline]\npub fn map<F, U>(self, f: F) -> Response<U>\n    where\n        F: FnOnce(T) -> U,{\n        Response {\n            body: f(self.body),\n            head: self.head,\n        }\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::new': ['/// Creates a new blank `Response` with the body\n///\n/// The component parts of this response will be set to their default, e.g.\n/// the ok status, no headers, etc.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::new("hello world");\n///\n/// assert_eq!(response.status(), StatusCode::OK);\n/// assert_eq!(*response.body(), "hello world");\n/// ```\n#[inline]\npub fn new(body: T) -> Response<T>{\n        Response {\n            head: Parts::new(),\n            body,\n        }\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::status': ['/// Returns the `StatusCode`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert_eq!(response.status(), StatusCode::OK);\n/// ```\n#[inline]\npub fn status(&self) -> StatusCode{\n        self.head.status\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::status_mut': ['/// Returns a mutable reference to the associated `StatusCode`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut response: Response<()> = Response::default();\n/// *response.status_mut() = StatusCode::CREATED;\n/// assert_eq!(response.status(), StatusCode::CREATED);\n/// ```\n#[inline]\npub fn status_mut(&mut self) -> &mut StatusCode{\n        &mut self.head.status\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::version': ['/// Returns a reference to the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert_eq!(response.version(), Version::HTTP_11);\n/// ```\n#[inline]\npub fn version(&self) -> Version{\n        self.head.version\n    }', 'Real(LocalPath("src/response.rs"))'], 'response::Response::<T>::version_mut': ['/// Returns a mutable reference to the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut response: Response<()> = Response::default();\n/// *response.version_mut() = Version::HTTP_2;\n/// assert_eq!(response.version(), Version::HTTP_2);\n/// ```\n#[inline]\npub fn version_mut(&mut self) -> &mut Version{\n        &mut self.head.version\n    }', 'Real(LocalPath("src/response.rs"))'], 'status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq': ['#[inline]\nfn eq(&self, other: &StatusCode) -> bool{\n        *self == other.as_u16()\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::<impl std::convert::From<status::StatusCode> for u16>::from': ['#[inline]\nfn from(status: StatusCode) -> u16{\n        status.0.get()\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::InvalidStatusCode': ['/// A possible error value when converting a `StatusCode` from a `u16` or `&str`.\n///\n/// This error indicates that the supplied input was not a valid number, was less\n/// than 100, or was greater than 999.\npub struct InvalidStatusCode {\n    _priv: (),\n}', 'Real(LocalPath("src/status.rs"))'], 'status::InvalidStatusCode::new': ['fn new() -> InvalidStatusCode{\n        InvalidStatusCode { _priv: () }\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode': ['/// An HTTP status code (`status-code` in RFC 9110 et al.).\n///\n/// Constants are provided for known status codes, including those in the IANA\n/// [HTTP Status Code Registry](\n/// https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml).\n///\n/// Status code values in the range 100-999 (inclusive) are supported by this\n/// type. Values in the range 100-599 are semantically classified by the most\n/// significant digit. See [`StatusCode::is_success`], etc. Values above 599\n/// are unclassified but allowed for legacy compatibility, though their use is\n/// discouraged. Applications may interpret such values as protocol errors.\n///\n/// # Examples\n///\n/// ```\n/// use http::StatusCode;\n///\n/// assert_eq!(StatusCode::from_u16(200).unwrap(), StatusCode::OK);\n/// assert_eq!(StatusCode::NOT_FOUND.as_u16(), 404);\n/// assert!(StatusCode::OK.is_success());\n/// ```\npub struct StatusCode(NonZeroU16);', 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode::as_str': ['/// Returns a &str representation of the `StatusCode`\n///\n/// The return value only includes a numerical representation of the\n/// status code. The canonical reason is not included.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.as_str(), "200");\n/// ```\n#[inline]\npub fn as_str(&self) -> &str{\n        let offset = (self.0.get() - 100) as usize;\n        let offset = offset * 3;\n\n        // Invariant: self has checked range [100, 999] and CODE_DIGITS is\n        // ASCII-only, of length 900 * 3 = 2700 bytes\n\n        #[cfg(debug_assertions)]\n        {\n            &CODE_DIGITS[offset..offset + 3]\n        }\n\n        #[cfg(not(debug_assertions))]\n        unsafe {\n            CODE_DIGITS.get_unchecked(offset..offset + 3)\n        }\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode::as_u16': ["/// Returns the `u16` corresponding to this `StatusCode`.\n///\n/// # Note\n///\n/// This is the same as the `From<StatusCode>` implementation, but\n/// included as an inherent method because that implementation doesn't\n/// appear in rustdocs, as well as a way to force the type instead of\n/// relying on inference.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.as_u16(), 200);\n/// ```\n#[inline]\npub const fn as_u16(&self) -> u16{\n        self.0.get()\n    }", 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode::canonical_reason': ['/// Get the standardised `reason-phrase` for this status code.\n///\n/// This is mostly here for servers writing responses, but could potentially have application\n/// at other times.\n///\n/// The reason phrase is defined as being exclusively for human readers. You should avoid\n/// deriving any meaning from it at all costs.\n///\n/// Bear in mind also that in HTTP/2.0 and HTTP/3.0 the reason phrase is abolished from\n/// transmission, and so this canonical reason phrase really is the only reason phrase youll\n/// find.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.canonical_reason(), Some("OK"));\n/// ```\npub fn canonical_reason(&self) -> Option<&\'static str>{\n        canonical_reason(self.0.get())\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode::from_bytes': ["/// Converts a `&[u8]` to a status code.\npub fn from_bytes(src: &[u8]) -> Result<StatusCode, InvalidStatusCode>{\n        if src.len() != 3 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let a = src[0].wrapping_sub(b'0') as u16;\n        let b = src[1].wrapping_sub(b'0') as u16;\n        let c = src[2].wrapping_sub(b'0') as u16;\n\n        if a == 0 || a > 9 || b > 9 || c > 9 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let status = (a * 100) + (b * 10) + c;\n        NonZeroU16::new(status)\n            .map(StatusCode)\n            .ok_or_else(InvalidStatusCode::new)\n    }", 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode::from_u16': ['/// Converts a u16 to a status code.\n///\n/// The function validates the correctness of the supplied u16. It must be\n/// greater or equal to 100 and less than 1000.\n///\n/// # Example\n///\n/// ```\n/// use http::StatusCode;\n///\n/// let ok = StatusCode::from_u16(200).unwrap();\n/// assert_eq!(ok, StatusCode::OK);\n///\n/// let err = StatusCode::from_u16(99);\n/// assert!(err.is_err());\n/// ```\n#[inline]\npub fn from_u16(src: u16) -> Result<StatusCode, InvalidStatusCode>{\n        if !(100..1000).contains(&src) {\n            return Err(InvalidStatusCode::new());\n        }\n\n        NonZeroU16::new(src)\n            .map(StatusCode)\n            .ok_or_else(InvalidStatusCode::new)\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode::is_client_error': ['/// Check if status is within 400-499.\n#[inline]\npub fn is_client_error(&self) -> bool{\n        (400..500).contains(&self.0.get())\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode::is_informational': ['/// Check if status is within 100-199.\n#[inline]\npub fn is_informational(&self) -> bool{\n        (100..200).contains(&self.0.get())\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode::is_redirection': ['/// Check if status is within 300-399.\n#[inline]\npub fn is_redirection(&self) -> bool{\n        (300..400).contains(&self.0.get())\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode::is_server_error': ['/// Check if status is within 500-599.\n#[inline]\npub fn is_server_error(&self) -> bool{\n        (500..600).contains(&self.0.get())\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::StatusCode::is_success': ['/// Check if status is within 200-299.\n#[inline]\npub fn is_success(&self) -> bool{\n        (200..300).contains(&self.0.get())\n    }', 'Real(LocalPath("src/status.rs"))'], 'status::canonical_reason': ["fn canonical_reason(num: u16) -> Option<&'static str>{\n            match num {\n                $(\n                $num => Some($phrase),\n                )+\n                _ => None\n            }\n        }", 'Real(LocalPath("src/status.rs"))'], "uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq": ['fn eq(&self, uri: &Uri) -> bool{\n        uri == *self\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq': ['fn eq(&self, uri: &Uri) -> bool{\n        uri == self\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::ErrorKind': ['enum ErrorKind {\n    InvalidUriChar,\n    InvalidScheme,\n    InvalidAuthority,\n    InvalidPort,\n    InvalidFormat,\n    SchemeMissing,\n    AuthorityMissing,\n    PathAndQueryMissing,\n    TooLong,\n    Empty,\n    SchemeTooLong,\n}', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::InvalidUri': ['/// An error resulting from a failed attempt to construct a URI.\npub struct InvalidUri(ErrorKind);', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::InvalidUri::s': ['fn s(&self) -> &str{\n        match self.0 {\n            ErrorKind::InvalidUriChar => "invalid uri character",\n            ErrorKind::InvalidScheme => "invalid scheme",\n            ErrorKind::InvalidAuthority => "invalid authority",\n            ErrorKind::InvalidPort => "invalid port",\n            ErrorKind::InvalidFormat => "invalid format",\n            ErrorKind::SchemeMissing => "scheme missing",\n            ErrorKind::AuthorityMissing => "authority missing",\n            ErrorKind::PathAndQueryMissing => "path missing",\n            ErrorKind::TooLong => "uri too long",\n            ErrorKind::Empty => "empty string",\n            ErrorKind::SchemeTooLong => "scheme too long",\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::InvalidUriParts': ['/// An error resulting from a failed attempt to construct a URI.\npub struct InvalidUriParts(InvalidUri);', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Parts': ['/// The various parts of a URI.\n///\n/// This struct is used to provide to and retrieve from a URI.\npub struct Parts {\n    /// The scheme component of a URI\n    pub scheme: Option<Scheme>,\n\n    /// The authority component of a URI\n    pub authority: Option<Authority>,\n\n    /// The origin-form component of a URI\n    pub path_and_query: Option<PathAndQuery>,\n\n    /// Allow extending in the future\n    _priv: (),\n}', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri': ['/// The URI component of a request.\n///\n/// For HTTP 1, this is included as part of the request line. From Section 5.3,\n/// Request Target:\n///\n/// > Once an inbound connection is obtained, the client sends an HTTP\n/// > request message (Section 3) with a request-target derived from the\n/// > target URI.  There are four distinct formats for the request-target,\n/// > depending on both the method being requested and whether the request\n/// > is to a proxy.\n/// >\n/// > ```notrust\n/// > request-target = origin-form\n/// >                / absolute-form\n/// >                / authority-form\n/// >                / asterisk-form\n/// > ```\n///\n/// The URI is structured as follows:\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n/// |-|   |-------------------------------||--------| |-------------------| |-----|\n///  |                  |                       |               |              |\n/// scheme          authority                 path            query         fragment\n/// ```\n///\n/// For HTTP 2.0, the URI is encoded using pseudoheaders.\n///\n/// # Examples\n///\n/// ```\n/// use http::Uri;\n///\n/// let uri = "/foo/bar?baz".parse::<Uri>().unwrap();\n/// assert_eq!(uri.path(), "/foo/bar");\n/// assert_eq!(uri.query(), Some("baz"));\n/// assert_eq!(uri.host(), None);\n///\n/// let uri = "https://www.rust-lang.org/install.html".parse::<Uri>().unwrap();\n/// assert_eq!(uri.scheme_str(), Some("https"));\n/// assert_eq!(uri.host(), Some("www.rust-lang.org"));\n/// assert_eq!(uri.path(), "/install.html");\n/// ```\npub struct Uri {\n    scheme: Scheme,\n    authority: Authority,\n    path_and_query: PathAndQuery,\n}', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::authority': ['/// Get the authority of this `Uri`.\n///\n/// The authority is a hierarchical element for naming authority such that\n/// the remainder of the URI is delegated to that authority. For HTTP, the\n/// authority consists of the host and port. The host portion of the\n/// authority is **case-insensitive**.\n///\n/// The authority also includes a `username:password` component, however\n/// the use of this is deprecated and should be avoided.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///       |-------------------------------|\n///                     |\n///                 authority\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n///\n/// assert_eq!(uri.authority().map(|a| a.as_str()), Some("example.org:80"));\n/// ```\n///\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "/hello/world".parse().unwrap();\n///\n/// assert!(uri.authority().is_none());\n/// ```\n#[inline]\npub fn authority(&self) -> Option<&Authority>{\n        if self.authority.data.is_empty() {\n            None\n        } else {\n            Some(&self.authority)\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::builder': ['/// Creates a new builder-style object to manufacture a `Uri`.\n///\n/// This method returns an instance of `Builder` which can be usd to\n/// create a `Uri`.\n///\n/// # Examples\n///\n/// ```\n/// use http::Uri;\n///\n/// let uri = Uri::builder()\n///     .scheme("https")\n///     .authority("hyper.rs")\n///     .path_and_query("/")\n///     .build()\n///     .unwrap();\n/// ```\npub fn builder() -> Builder{\n        Builder::new()\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::from_maybe_shared': ["/// Attempt to convert a `Bytes` buffer to a `Uri`.\n///\n/// This will try to prevent a copy if the type passed is the type used\n/// internally, and will copy the data if it is not.\npub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + 'static,{\n        if_downcast_into!(T, Bytes, src, {\n            return Uri::from_shared(src);\n        });\n\n        Uri::try_from(src.as_ref())\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::from_parts': ['/// Attempt to convert a `Parts` into a `Uri`.\n///\n/// # Examples\n///\n/// Relative URI\n///\n/// ```\n/// # use http::uri::*;\n/// let mut parts = Parts::default();\n/// parts.path_and_query = Some("/foo".parse().unwrap());\n///\n/// let uri = Uri::from_parts(parts).unwrap();\n///\n/// assert_eq!(uri.path(), "/foo");\n///\n/// assert!(uri.scheme().is_none());\n/// assert!(uri.authority().is_none());\n/// ```\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::uri::*;\n/// let mut parts = Parts::default();\n/// parts.scheme = Some("http".parse().unwrap());\n/// parts.authority = Some("foo.com".parse().unwrap());\n/// parts.path_and_query = Some("/foo".parse().unwrap());\n///\n/// let uri = Uri::from_parts(parts).unwrap();\n///\n/// assert_eq!(uri.scheme().unwrap().as_str(), "http");\n/// assert_eq!(uri.authority().unwrap(), "foo.com");\n/// assert_eq!(uri.path(), "/foo");\n/// ```\npub fn from_parts(src: Parts) -> Result<Uri, InvalidUriParts>{\n        if src.scheme.is_some() {\n            if src.authority.is_none() {\n                return Err(ErrorKind::AuthorityMissing.into());\n            }\n\n            if src.path_and_query.is_none() {\n                return Err(ErrorKind::PathAndQueryMissing.into());\n            }\n        } else if src.authority.is_some() && src.path_and_query.is_some() {\n            return Err(ErrorKind::SchemeMissing.into());\n        }\n\n        let scheme = match src.scheme {\n            Some(scheme) => scheme,\n            None => Scheme {\n                inner: Scheme2::None,\n            },\n        };\n\n        let authority = match src.authority {\n            Some(authority) => authority,\n            None => Authority::empty(),\n        };\n\n        let path_and_query = match src.path_and_query {\n            Some(path_and_query) => path_and_query,\n            None => PathAndQuery::empty(),\n        };\n\n        Ok(Uri {\n            scheme,\n            authority,\n            path_and_query,\n        })\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::from_shared': ["fn from_shared(s: Bytes) -> Result<Uri, InvalidUri>{\n        use self::ErrorKind::*;\n\n        if s.len() > MAX_LEN {\n            return Err(TooLong.into());\n        }\n\n        match s.len() {\n            0 => {\n                return Err(Empty.into());\n            }\n            1 => match s[0] {\n                b'/' => {\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority: Authority::empty(),\n                        path_and_query: PathAndQuery::slash(),\n                    });\n                }\n                b'*' => {\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority: Authority::empty(),\n                        path_and_query: PathAndQuery::star(),\n                    });\n                }\n                _ => {\n                    let authority = Authority::from_shared(s)?;\n\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority,\n                        path_and_query: PathAndQuery::empty(),\n                    });\n                }\n            },\n            _ => {}\n        }\n\n        if s[0] == b'/' {\n            return Ok(Uri {\n                scheme: Scheme::empty(),\n                authority: Authority::empty(),\n                path_and_query: PathAndQuery::from_shared(s)?,\n            });\n        }\n\n        parse_full(s)\n    }", 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::from_static': ['/// Convert a `Uri` from a static string.\n///\n/// This function will not perform any copying, however the string is\n/// checked to ensure that it is valid.\n///\n/// # Panics\n///\n/// This function panics if the argument is an invalid URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::Uri;\n/// let uri = Uri::from_static("http://example.com/foo");\n///\n/// assert_eq!(uri.host().unwrap(), "example.com");\n/// assert_eq!(uri.path(), "/foo");\n/// ```\npub fn from_static(src: &\'static str) -> Self{\n        let s = Bytes::from_static(src.as_bytes());\n        match Uri::from_shared(s) {\n            Ok(uri) => uri,\n            Err(e) => panic!("static str is not valid URI: {}", e),\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::has_path': ['fn has_path(&self) -> bool{\n        !self.path_and_query.data.is_empty() || !self.scheme.inner.is_none()\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::host': ['/// Get the host of this `Uri`.\n///\n/// The host subcomponent of authority is identified by an IP literal\n/// encapsulated within square brackets, an IPv4 address in dotted- decimal\n/// form, or a registered name.  The host subcomponent is **case-insensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                         |---------|\n///                              |\n///                             host\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n///\n/// assert_eq!(uri.host(), Some("example.org"));\n/// ```\n///\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "/hello/world".parse().unwrap();\n///\n/// assert!(uri.host().is_none());\n/// ```\n#[inline]\npub fn host(&self) -> Option<&str>{\n        self.authority().map(|a| a.host())\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::into_parts': ['/// Convert a `Uri` into `Parts`.\n///\n/// # Note\n///\n/// This is just an inherent method providing the same functionality as\n/// `let parts: Parts = uri.into()`\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let uri: Uri = "/foo".parse().unwrap();\n///\n/// let parts = uri.into_parts();\n///\n/// assert_eq!(parts.path_and_query.unwrap(), "/foo");\n///\n/// assert!(parts.scheme.is_none());\n/// assert!(parts.authority.is_none());\n/// ```\n#[inline]\npub fn into_parts(self) -> Parts{\n        self.into()\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::path': ['/// Get the path of this `Uri`.\n///\n/// Both relative and absolute URIs contain a path component, though it\n/// might be the empty string. The path component is **case sensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                        |--------|\n///                                             |\n///                                           path\n/// ```\n///\n/// If the URI is `*` then the path component is equal to `*`.\n///\n/// # Examples\n///\n/// A relative URI\n///\n/// ```\n/// # use http::Uri;\n///\n/// let uri: Uri = "/hello/world".parse().unwrap();\n///\n/// assert_eq!(uri.path(), "/hello/world");\n/// ```\n///\n/// An absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n///\n/// assert_eq!(uri.path(), "/hello/world");\n/// ```\n#[inline]\npub fn path(&self) -> &str{\n        if self.has_path() {\n            self.path_and_query.path()\n        } else {\n            ""\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::path_and_query': ['/// Returns the path & query components of the Uri\n#[inline]\npub fn path_and_query(&self) -> Option<&PathAndQuery>{\n        if !self.scheme.inner.is_none() || self.authority.data.is_empty() {\n            Some(&self.path_and_query)\n        } else {\n            None\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::port': ['/// Get the port part of this `Uri`.\n///\n/// The port subcomponent of authority is designated by an optional port\n/// number following the host and delimited from it by a single colon (":")\n/// character. It can be turned into a decimal port number with the `as_u16`\n/// method or as a `str` with the `as_str` method.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                     |-|\n///                                      |\n///                                     port\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI with port\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n///\n/// let port = uri.port().unwrap();\n/// assert_eq!(port.as_u16(), 80);\n/// ```\n///\n/// Absolute URI without port\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n///\n/// assert!(uri.port().is_none());\n/// ```\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "/hello/world".parse().unwrap();\n///\n/// assert!(uri.port().is_none());\n/// ```\npub fn port(&self) -> Option<Port<&str>>{\n        self.authority().and_then(|a| a.port())\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::port_u16': ['/// Get the port of this `Uri` as a `u16`.\n///\n///\n/// # Example\n///\n/// ```\n/// # use http::{Uri, uri::Port};\n/// let uri: Uri = "http://example.org:80/hello/world".parse().unwrap();\n///\n/// assert_eq!(uri.port_u16(), Some(80));\n/// ```\npub fn port_u16(&self) -> Option<u16>{\n        self.port().map(|p| p.as_u16())\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::query': ['/// Get the query string of this `Uri`, starting after the `?`.\n///\n/// The query component contains non-hierarchical data that, along with data\n/// in the path component, serves to identify a resource within the scope of\n/// the URI\'s scheme and naming authority (if any). The query component is\n/// indicated by the first question mark ("?") character and terminated by a\n/// number sign ("#") character or by the end of the URI.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                                   |-------------------|\n///                                                             |\n///                                                           query\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "http://example.org/hello/world?key=value".parse().unwrap();\n///\n/// assert_eq!(uri.query(), Some("key=value"));\n/// ```\n///\n/// Relative URI with a query string component\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "/hello/world?key=value&foo=bar".parse().unwrap();\n///\n/// assert_eq!(uri.query(), Some("key=value&foo=bar"));\n/// ```\n///\n/// Relative URI without a query string component\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "/hello/world".parse().unwrap();\n///\n/// assert!(uri.query().is_none());\n/// ```\n#[inline]\npub fn query(&self) -> Option<&str>{\n        self.path_and_query.query()\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::scheme': ['/// Get the scheme of this `Uri`.\n///\n/// The URI scheme refers to a specification for assigning identifiers\n/// within that scheme. Only absolute URIs contain a scheme component, but\n/// not all absolute URIs will contain a scheme component.  Although scheme\n/// names are case-insensitive, the canonical form is lowercase.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n/// |-|\n///  |\n/// scheme\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// use http::uri::{Scheme, Uri};\n///\n/// let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n///\n/// assert_eq!(uri.scheme(), Some(&Scheme::HTTP));\n/// ```\n///\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "/hello/world".parse().unwrap();\n///\n/// assert!(uri.scheme().is_none());\n/// ```\n#[inline]\npub fn scheme(&self) -> Option<&Scheme>{\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(&self.scheme)\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], 'uri::Uri::scheme_str': ['/// Get the scheme of this `Uri` as a `&str`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = "http://example.org/hello/world".parse().unwrap();\n///\n/// assert_eq!(uri.scheme_str(), Some("http"));\n/// ```\n#[inline]\npub fn scheme_str(&self) -> Option<&str>{\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(self.scheme.as_str())\n        }\n    }', 'Real(LocalPath("src/uri/mod.rs"))'], "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq": ['fn eq(&self, other: &Authority) -> bool{\n        self.eq_ignore_ascii_case(other.as_str())\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq': ['fn eq(&self, other: &Authority) -> bool{\n        self.as_str().eq_ignore_ascii_case(other.as_str())\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq': ['fn eq(&self, other: &Authority) -> bool{\n        self.eq_ignore_ascii_case(other.as_str())\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp": ['fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp': ['fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp': ['fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority': ['/// Represents the authority component of a URI.\npub struct Authority {\n    pub(super) data: ByteStr,\n}', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority::as_str': ['/// Return a str representation of the authority\n#[inline]\npub fn as_str(&self) -> &str{\n        &self.data[..]\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority::empty': ['pub(super) fn empty() -> Self{\n        Authority {\n            data: ByteStr::new(),\n        }\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority::from_maybe_shared': ["/// Attempt to convert a `Bytes` buffer to a `Authority`.\n///\n/// This will try to prevent a copy if the type passed is the type used\n/// internally, and will copy the data if it is not.\npub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + 'static,{\n        if_downcast_into!(T, Bytes, src, {\n            return Authority::from_shared(src);\n        });\n\n        Authority::try_from(src.as_ref())\n    }", 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority::from_shared': ['pub(super) fn from_shared(s: Bytes) -> Result<Self, InvalidUri>{\n        // Precondition on create_authority: trivially satisfied by the\n        // identity closure\n        create_authority(s, |s| s)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority::from_static': ['/// Attempt to convert an `Authority` from a static string.\n///\n/// This function will not perform any copying, and the string will be\n/// checked if it is empty or contains an invalid character.\n///\n/// # Panics\n///\n/// This function panics if the argument contains invalid characters or\n/// is empty.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority = Authority::from_static("example.com");\n/// assert_eq!(authority.host(), "example.com");\n/// ```\npub fn from_static(src: &\'static str) -> Self{\n        Authority::from_shared(Bytes::from_static(src.as_bytes()))\n            .expect("static str is not valid authority")\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority::host': ['/// Get the host of this `Authority`.\n///\n/// The host subcomponent of authority is identified by an IP literal\n/// encapsulated within square brackets, an IPv4 address in dotted- decimal\n/// form, or a registered name.  The host subcomponent is **case-insensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                         |---------|\n///                              |\n///                             host\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let authority: Authority = "example.org:80".parse().unwrap();\n///\n/// assert_eq!(authority.host(), "example.org");\n/// ```\n#[inline]\npub fn host(&self) -> &str{\n        host(self.as_str())\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority::parse': ["pub(super) fn parse(s: &[u8]) -> Result<usize, InvalidUri>{\n        let mut colon_cnt = 0u32;\n        let mut start_bracket = false;\n        let mut end_bracket = false;\n        let mut has_percent = false;\n        let mut end = s.len();\n        let mut at_sign_pos = None;\n        const MAX_COLONS: u32 = 8; // e.g., [FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:80\n\n        // Among other things, this loop checks that every byte in s up to the\n        // first '/', '?', or '#' is a valid URI character (or in some contexts,\n        // a '%'). This means that each such byte is a valid single-byte UTF-8\n        // code point.\n        for (i, &b) in s.iter().enumerate() {\n            match URI_CHARS[b as usize] {\n                b'/' | b'?' | b'#' => {\n                    end = i;\n                    break;\n                }\n                b':' => {\n                    if colon_cnt >= MAX_COLONS {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    colon_cnt += 1;\n                }\n                b'[' => {\n                    if has_percent || start_bracket {\n                        // Something other than the userinfo has a `%`, so reject it.\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    start_bracket = true;\n                }\n                b']' => {\n                    if (!start_bracket) || end_bracket {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    end_bracket = true;\n\n                    // Those were part of an IPv6 hostname, so forget them...\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                b'@' => {\n                    at_sign_pos = Some(i);\n\n                    // Those weren't a port colon, but part of the\n                    // userinfo, so it needs to be forgotten.\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                0 if b == b'%' => {\n                    // Per https://tools.ietf.org/html/rfc3986#section-3.2.1 and\n                    // https://url.spec.whatwg.org/#authority-state\n                    // the userinfo can have a percent-encoded username and password,\n                    // so record that a `%` was found. If this turns out to be\n                    // part of the userinfo, this flag will be cleared.\n                    // Also per https://tools.ietf.org/html/rfc6874, percent-encoding can\n                    // be used to indicate a zone identifier.\n                    // If the flag hasn't been cleared at the end, that means this\n                    // was part of the hostname (and not part of an IPv6 address), and\n                    // will fail with an error.\n                    has_percent = true;\n                }\n                0 => {\n                    return Err(ErrorKind::InvalidUriChar.into());\n                }\n                _ => {}\n            }\n        }\n\n        if start_bracket ^ end_bracket {\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if colon_cnt > 1 {\n            // Things like 'localhost:8080:3030' are rejected.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if end > 0 && at_sign_pos == Some(end - 1) {\n            // If there's nothing after an `@`, this is bonkers.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if has_percent {\n            // Something after the userinfo has a `%`, so reject it.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        Ok(end)\n    }", 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority::parse_non_empty': ['fn parse_non_empty(s: &[u8]) -> Result<usize, InvalidUri>{\n        if s.is_empty() {\n            return Err(ErrorKind::Empty.into());\n        }\n        Authority::parse(s)\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority::port': ['/// Get the port part of this `Authority`.\n///\n/// The port subcomponent of authority is designated by an optional port\n/// number following the host and delimited from it by a single colon (":")\n/// character. It can be turned into a decimal port number with the `as_u16`\n/// method or as a `str` with the `as_str` method.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                     |-|\n///                                      |\n///                                     port\n/// ```\n///\n/// # Examples\n///\n/// Authority with port\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = "example.org:80".parse().unwrap();\n///\n/// let port = authority.port().unwrap();\n/// assert_eq!(port.as_u16(), 80);\n/// assert_eq!(port.as_str(), "80");\n/// ```\n///\n/// Authority without port\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = "example.org".parse().unwrap();\n///\n/// assert!(authority.port().is_none());\n/// ```\npub fn port(&self) -> Option<Port<&str>>{\n        let bytes = self.as_str();\n        bytes\n            .rfind(\':\')\n            .and_then(|i| Port::from_str(&bytes[i + 1..]).ok())\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::Authority::port_u16': ['/// Get the port of this `Authority` as a `u16`.\n///\n/// # Example\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = "example.org:80".parse().unwrap();\n///\n/// assert_eq!(authority.port_u16(), Some(80));\n/// ```\npub fn port_u16(&self) -> Option<u16>{\n        self.port().map(|p| p.as_u16())\n    }', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::create_authority': ['fn create_authority<B, F>(b: B, f: F) -> Result<Authority, InvalidUri>\nwhere\n    B: AsRef<[u8]>,\n    F: FnOnce(B) -> Bytes,{\n    let s = b.as_ref();\n    let authority_end = Authority::parse_non_empty(s)?;\n\n    if authority_end != s.len() {\n        return Err(ErrorKind::InvalidUriChar.into());\n    }\n\n    let bytes = f(b);\n\n    Ok(Authority {\n        // Safety: the postcondition on parse_non_empty() and the check against\n        // s.len() ensure that b is valid UTF-8. The precondition on f ensures\n        // that this is carried through to bytes.\n        data: unsafe { ByteStr::from_utf8_unchecked(bytes) },\n    })\n}', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::authority::host': ['fn host(auth: &str) -> &str{\n    let host_port = auth\n        .rsplit(\'@\')\n        .next()\n        .expect("split always has at least 1 item");\n\n    if host_port.as_bytes()[0] == b\'[\' {\n        let i = host_port\n            .find(\']\')\n            .expect("parsing should validate brackets");\n        // ..= ranges aren\'t available in 1.20, our minimum Rust version...\n        &host_port[0..i + 1]\n    } else {\n        host_port\n            .split(\':\')\n            .next()\n            .expect("split always has at least 1 item")\n    }\n}', 'Real(LocalPath("src/uri/authority.rs"))'], 'uri::builder::Builder': ['/// A builder for `Uri`s.\n///\n/// This type can be used to construct an instance of `Uri`\n/// through a builder pattern.\npub struct Builder {\n    parts: Result<Parts, crate::Error>,\n}', 'Real(LocalPath("src/uri/builder.rs"))'], 'uri::builder::Builder::authority': ['/// Set the `Authority` for this URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = uri::Builder::new()\n///     .authority("tokio.rs")\n///     .build()\n///     .unwrap();\n/// ```\npub fn authority<T>(self, auth: T) -> Self\n    where\n        T: TryInto<Authority>,\n        <T as TryInto<Authority>>::Error: Into<crate::Error>,{\n        self.map(move |mut parts| {\n            let auth = auth.try_into().map_err(Into::into)?;\n            parts.authority = Some(auth);\n            Ok(parts)\n        })\n    }', 'Real(LocalPath("src/uri/builder.rs"))'], 'uri::builder::Builder::build': ['/// Consumes this builder, and tries to construct a valid `Uri` from\n/// the configured pieces.\n///\n/// # Errors\n///\n/// This function may return an error if any previously configured argument\n/// failed to parse or get converted to the internal representation. For\n/// example if an invalid `scheme` was specified via `scheme("!@#%/^")`\n/// the error will be returned when this function is called rather than\n/// when `scheme` was called.\n///\n/// Additionally, the various forms of URI require certain combinations of\n/// parts to be set to be valid. If the parts don\'t fit into any of the\n/// valid forms of URI, a new error is returned.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = Uri::builder()\n///     .build()\n///     .unwrap();\n/// ```\npub fn build(self) -> Result<Uri, crate::Error>{\n        let parts = self.parts?;\n        Uri::from_parts(parts).map_err(Into::into)\n    }', 'Real(LocalPath("src/uri/builder.rs"))'], 'uri::builder::Builder::map': ['fn map<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts, crate::Error>,{\n        Builder {\n            parts: self.parts.and_then(func),\n        }\n    }', 'Real(LocalPath("src/uri/builder.rs"))'], 'uri::builder::Builder::new': ['/// Creates a new default instance of `Builder` to construct a `Uri`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = uri::Builder::new()\n///     .scheme("https")\n///     .authority("hyper.rs")\n///     .path_and_query("/")\n///     .build()\n///     .unwrap();\n/// ```\n#[inline]\npub fn new() -> Builder{\n        Builder::default()\n    }', 'Real(LocalPath("src/uri/builder.rs"))'], 'uri::builder::Builder::path_and_query': ['/// Set the `PathAndQuery` for this URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = uri::Builder::new()\n///     .path_and_query("/hello?foo=bar")\n///     .build()\n///     .unwrap();\n/// ```\npub fn path_and_query<T>(self, p_and_q: T) -> Self\n    where\n        T: TryInto<PathAndQuery>,\n        <T as TryInto<PathAndQuery>>::Error: Into<crate::Error>,{\n        self.map(move |mut parts| {\n            let p_and_q = p_and_q.try_into().map_err(Into::into)?;\n            parts.path_and_query = Some(p_and_q);\n            Ok(parts)\n        })\n    }', 'Real(LocalPath("src/uri/builder.rs"))'], 'uri::builder::Builder::scheme': ['/// Set the `Scheme` for this URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let mut builder = uri::Builder::new();\n/// builder.scheme("https");\n/// ```\npub fn scheme<T>(self, scheme: T) -> Self\n    where\n        T: TryInto<Scheme>,\n        <T as TryInto<Scheme>>::Error: Into<crate::Error>,{\n        self.map(move |mut parts| {\n            let scheme = scheme.try_into().map_err(Into::into)?;\n            parts.scheme = Some(scheme);\n            Ok(parts)\n        })\n    }', 'Real(LocalPath("src/uri/builder.rs"))'], 'uri::parse_full': ['fn parse_full(mut s: Bytes) -> Result<Uri, InvalidUri>{\n    // Parse the scheme\n    let scheme = match Scheme2::parse(&s[..])? {\n        Scheme2::None => Scheme2::None,\n        Scheme2::Standard(p) => {\n            // TODO: use truncate\n            let _ = s.split_to(p.len() + 3);\n            Scheme2::Standard(p)\n        }\n        Scheme2::Other(n) => {\n            // Grab the protocol\n            let mut scheme = s.split_to(n + 3);\n\n            // Strip ://, TODO: truncate\n            let _ = scheme.split_off(n);\n\n            // Allocate the ByteStr\n            let val = unsafe { ByteStr::from_utf8_unchecked(scheme) };\n\n            Scheme2::Other(Box::new(val))\n        }\n    };\n\n    // Find the end of the authority. The scheme will already have been\n    // extracted.\n    let authority_end = Authority::parse(&s[..])?;\n\n    if scheme.is_none() {\n        if authority_end != s.len() {\n            return Err(ErrorKind::InvalidFormat.into());\n        }\n\n        let authority = Authority {\n            data: unsafe { ByteStr::from_utf8_unchecked(s) },\n        };\n\n        return Ok(Uri {\n            scheme: scheme.into(),\n            authority,\n            path_and_query: PathAndQuery::empty(),\n        });\n    }\n\n    // Authority is required when absolute\n    if authority_end == 0 {\n        return Err(ErrorKind::InvalidFormat.into());\n    }\n\n    let authority = s.split_to(authority_end);\n    let authority = Authority {\n        data: unsafe { ByteStr::from_utf8_unchecked(authority) },\n    };\n\n    Ok(Uri {\n        scheme: scheme.into(),\n        authority,\n        path_and_query: PathAndQuery::from_shared(s)?,\n    })\n}', 'Real(LocalPath("src/uri/mod.rs"))'], "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq": ['#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self == &other.as_str()\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq': ['#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self.as_str() == other.as_str()\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq': ['#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self == other.as_str()\n    }', 'Real(LocalPath("src/uri/path.rs"))'], "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp": ['#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.partial_cmp(&other.as_str())\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other.as_str())\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp': ['#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.partial_cmp(other.as_str())\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::PathAndQuery': ['/// Represents the path component of a URI\npub struct PathAndQuery {\n    pub(super) data: ByteStr,\n    pub(super) query: u16,\n}', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::PathAndQuery::as_str': ['/// Returns the path and query as a string component.\n///\n/// # Examples\n///\n/// With a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = "/hello/world?key=value&foo=bar".parse().unwrap();\n///\n/// assert_eq!(path_and_query.as_str(), "/hello/world?key=value&foo=bar");\n/// ```\n///\n/// Without a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = "/hello/world".parse().unwrap();\n///\n/// assert_eq!(path_and_query.as_str(), "/hello/world");\n/// ```\n#[inline]\npub fn as_str(&self) -> &str{\n        let ret = &self.data[..];\n        if ret.is_empty() {\n            return "/";\n        }\n        ret\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::PathAndQuery::empty': ['pub(super) fn empty() -> Self{\n        PathAndQuery {\n            data: ByteStr::new(),\n            query: NONE,\n        }\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::PathAndQuery::from_maybe_shared': ["/// Attempt to convert a `Bytes` buffer to a `PathAndQuery`.\n///\n/// This will try to prevent a copy if the type passed is the type used\n/// internally, and will copy the data if it is not.\npub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + 'static,{\n        if_downcast_into!(T, Bytes, src, {\n            return PathAndQuery::from_shared(src);\n        });\n\n        PathAndQuery::try_from(src.as_ref())\n    }", 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::PathAndQuery::from_shared': ['pub(super) fn from_shared(mut src: Bytes) -> Result<Self, InvalidUri>{\n        let mut query = NONE;\n        let mut fragment = None;\n\n        let mut is_maybe_not_utf8 = false;\n\n        // block for iterator borrow\n        {\n            let mut iter = src.as_ref().iter().enumerate();\n\n            // path ...\n            for (i, &b) in &mut iter {\n                // See https://url.spec.whatwg.org/#path-state\n                match b {\n                    b\'?\' => {\n                        debug_assert_eq!(query, NONE);\n                        query = i as u16;\n                        break;\n                    }\n                    b\'#\' => {\n                        fragment = Some(i);\n                        break;\n                    }\n\n                    // This is the range of bytes that don\'t need to be\n                    // percent-encoded in the path. If it should have been\n                    // percent-encoded, then error.\n                    #[rustfmt::skip]\n                    0x21 |\n                    0x24..=0x3B |\n                    0x3D |\n                    0x40..=0x5F |\n                    0x61..=0x7A |\n                    0x7C |\n                    0x7E => {}\n\n                    // potentially utf8, might not, should check\n                    0x7F..=0xFF => {\n                        is_maybe_not_utf8 = true;\n                    }\n\n                    // These are code points that are supposed to be\n                    // percent-encoded in the path but there are clients\n                    // out there sending them as is and httparse accepts\n                    // to parse those requests, so they are allowed here\n                    // for parity.\n                    //\n                    // For reference, those are code points that are used\n                    // to send requests with JSON directly embedded in\n                    // the URI path. Yes, those things happen for real.\n                    #[rustfmt::skip]\n                    b\'"\' |\n                    b\'{\' | b\'}\' => {}\n\n                    _ => return Err(ErrorKind::InvalidUriChar.into()),\n                }\n            }\n\n            // query ...\n            if query != NONE {\n                for (i, &b) in iter {\n                    match b {\n                        // While queries *should* be percent-encoded, most\n                        // bytes are actually allowed...\n                        // See https://url.spec.whatwg.org/#query-state\n                        //\n                        // Allowed: 0x21 / 0x24 - 0x3B / 0x3D / 0x3F - 0x7E\n                        #[rustfmt::skip]\n                        0x21 |\n                        0x24..=0x3B |\n                        0x3D |\n                        0x3F..=0x7E => {}\n\n                        0x7F..=0xFF => {\n                            is_maybe_not_utf8 = true;\n                        }\n\n                        b\'#\' => {\n                            fragment = Some(i);\n                            break;\n                        }\n\n                        _ => return Err(ErrorKind::InvalidUriChar.into()),\n                    }\n                }\n            }\n        }\n\n        if let Some(i) = fragment {\n            src.truncate(i);\n        }\n\n        let data = if is_maybe_not_utf8 {\n            ByteStr::from_utf8(src).map_err(|_| ErrorKind::InvalidUriChar)?\n        } else {\n            unsafe { ByteStr::from_utf8_unchecked(src) }\n        };\n\n        Ok(PathAndQuery { data, query })\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::PathAndQuery::from_static': ['/// Convert a `PathAndQuery` from a static string.\n///\n/// This function will not perform any copying, however the string is\n/// checked to ensure that it is valid.\n///\n/// # Panics\n///\n/// This function panics if the argument is an invalid path and query.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let v = PathAndQuery::from_static("/hello?world");\n///\n/// assert_eq!(v.path(), "/hello");\n/// assert_eq!(v.query(), Some("world"));\n/// ```\n#[inline]\npub fn from_static(src: &\'static str) -> Self{\n        let src = Bytes::from_static(src.as_bytes());\n\n        PathAndQuery::from_shared(src).unwrap()\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::PathAndQuery::path': ['/// Returns the path component\n///\n/// The path component is **case sensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                        |--------|\n///                                             |\n///                                           path\n/// ```\n///\n/// If the URI is `*` then the path component is equal to `*`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n///\n/// let path_and_query: PathAndQuery = "/hello/world".parse().unwrap();\n///\n/// assert_eq!(path_and_query.path(), "/hello/world");\n/// ```\n#[inline]\npub fn path(&self) -> &str{\n        let ret = if self.query == NONE {\n            &self.data[..]\n        } else {\n            &self.data[..self.query as usize]\n        };\n\n        if ret.is_empty() {\n            return "/";\n        }\n\n        ret\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::PathAndQuery::query': ['/// Returns the query string component\n///\n/// The query component contains non-hierarchical data that, along with data\n/// in the path component, serves to identify a resource within the scope of\n/// the URI\'s scheme and naming authority (if any). The query component is\n/// indicated by the first question mark ("?") character and terminated by a\n/// number sign ("#") character or by the end of the URI.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                                   |-------------------|\n///                                                             |\n///                                                           query\n/// ```\n///\n/// # Examples\n///\n/// With a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = "/hello/world?key=value&foo=bar".parse().unwrap();\n///\n/// assert_eq!(path_and_query.query(), Some("key=value&foo=bar"));\n/// ```\n///\n/// Without a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = "/hello/world".parse().unwrap();\n///\n/// assert!(path_and_query.query().is_none());\n/// ```\n#[inline]\npub fn query(&self) -> Option<&str>{\n        if self.query == NONE {\n            None\n        } else {\n            let i = self.query + 1;\n            Some(&self.data[i as usize..])\n        }\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::PathAndQuery::slash': ['pub(super) fn slash() -> Self{\n        PathAndQuery {\n            data: ByteStr::from_static("/"),\n            query: NONE,\n        }\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::path::PathAndQuery::star': ['pub(super) fn star() -> Self{\n        PathAndQuery {\n            data: ByteStr::from_static("*"),\n            query: NONE,\n        }\n    }', 'Real(LocalPath("src/uri/path.rs"))'], 'uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq': ['fn eq(&self, other: &Port<T>) -> bool{\n        other.port == *self\n    }', 'Real(LocalPath("src/uri/port.rs"))'], 'uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from': ['fn from(port: Port<T>) -> Self{\n        port.as_u16()\n    }', 'Real(LocalPath("src/uri/port.rs"))'], 'uri::port::Port': ['/// The port component of a URI.\npub struct Port<T> {\n    port: u16,\n    repr: T,\n}', 'Real(LocalPath("src/uri/port.rs"))'], 'uri::port::Port::<T>::as_str': ['/// Returns the port number as a `str`.\n///\n/// # Examples\n///\n/// Port as `str`.\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = "example.org:80".parse().unwrap();\n///\n/// let port = authority.port().unwrap();\n/// assert_eq!(port.as_str(), "80");\n/// ```\npub fn as_str(&self) -> &str{\n        self.repr.as_ref()\n    }', 'Real(LocalPath("src/uri/port.rs"))'], 'uri::port::Port::<T>::as_u16': ['/// Returns the port number as a `u16`.\n///\n/// # Examples\n///\n/// Port as `u16`.\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = "example.org:80".parse().unwrap();\n///\n/// let port = authority.port().unwrap();\n/// assert_eq!(port.as_u16(), 80);\n/// ```\npub const fn as_u16(&self) -> u16{\n        self.port\n    }', 'Real(LocalPath("src/uri/port.rs"))'], 'uri::port::Port::<T>::from_str': ['/// Converts a `str` to a port number.\n///\n/// The supplied `str` must be a valid u16.\npub(crate) fn from_str(bytes: T) -> Result<Self, InvalidUri>{\n        bytes\n            .as_ref()\n            .parse::<u16>()\n            .map(|port| Port { port, repr: bytes })\n            .map_err(|_| ErrorKind::InvalidPort.into())\n    }', 'Real(LocalPath("src/uri/port.rs"))'], 'uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq': ['fn eq(&self, other: &Scheme) -> bool{\n        other == self\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], 'uri::scheme::Protocol': ['pub(super) enum Protocol {\n    Http,\n    Https,\n}', 'Real(LocalPath("src/uri/scheme.rs"))'], 'uri::scheme::Protocol::len': ['pub(super) fn len(&self) -> usize{\n        match *self {\n            Protocol::Http => 4,\n            Protocol::Https => 5,\n        }\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], 'uri::scheme::Scheme': ['/// Represents the scheme component of a URI\npub struct Scheme {\n    pub(super) inner: Scheme2,\n}', 'Real(LocalPath("src/uri/scheme.rs"))'], 'uri::scheme::Scheme2': ['pub(super) enum Scheme2<T = Box<ByteStr>> {\n    None,\n    Standard(Protocol),\n    Other(T),\n}', 'Real(LocalPath("src/uri/scheme.rs"))'], 'uri::scheme::Scheme2::<T>::is_none': ['pub(super) fn is_none(&self) -> bool{\n        matches!(*self, Scheme2::None)\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], 'uri::scheme::Scheme2::<usize>::parse': ['pub(super) fn parse(s: &[u8]) -> Result<Scheme2<usize>, InvalidUri>{\n        if s.len() >= 7 {\n            // Check for HTTP\n            if s[..7].eq_ignore_ascii_case(b"http://") {\n                // Prefix will be striped\n                return Ok(Protocol::Http.into());\n            }\n        }\n\n        if s.len() >= 8 {\n            // Check for HTTPs\n            if s[..8].eq_ignore_ascii_case(b"https://") {\n                return Ok(Protocol::Https.into());\n            }\n        }\n\n        if s.len() > 3 {\n            for i in 0..s.len() {\n                let b = s[i];\n\n                match SCHEME_CHARS[b as usize] {\n                    b\':\' => {\n                        // Not enough data remaining\n                        if s.len() < i + 3 {\n                            break;\n                        }\n\n                        // Not a scheme\n                        if &s[i + 1..i + 3] != b"//" {\n                            break;\n                        }\n\n                        if i > MAX_SCHEME_LEN {\n                            return Err(ErrorKind::SchemeTooLong.into());\n                        }\n\n                        // Return scheme\n                        return Ok(Scheme2::Other(i));\n                    }\n                    // Invalid scheme character, abort\n                    0 => break,\n                    _ => {}\n                }\n            }\n        }\n\n        Ok(Scheme2::None)\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], 'uri::scheme::Scheme2::<usize>::parse_exact': ['fn parse_exact(s: &[u8]) -> Result<Scheme2<()>, InvalidUri>{\n        match s {\n            b"http" => Ok(Protocol::Http.into()),\n            b"https" => Ok(Protocol::Https.into()),\n            _ => {\n                if s.len() > MAX_SCHEME_LEN {\n                    return Err(ErrorKind::SchemeTooLong.into());\n                }\n\n                // check that each byte in s is a SCHEME_CHARS which implies\n                // that it is a valid single byte UTF-8 code point.\n                for &b in s {\n                    match SCHEME_CHARS[b as usize] {\n                        b\':\' => {\n                            // Don\'t want :// here\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        0 => {\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        _ => {}\n                    }\n                }\n\n                Ok(Scheme2::Other(()))\n            }\n        }\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], 'uri::scheme::Scheme::as_str': ['/// Return a str representation of the scheme\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let scheme: Scheme = "http".parse().unwrap();\n/// assert_eq!(scheme.as_str(), "http");\n/// ```\n#[inline]\npub fn as_str(&self) -> &str{\n        use self::Protocol::*;\n        use self::Scheme2::*;\n\n        match self.inner {\n            Standard(Http) => "http",\n            Standard(Https) => "https",\n            Other(ref v) => &v[..],\n            None => unreachable!(),\n        }\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], 'uri::scheme::Scheme::empty': ['pub(super) fn empty() -> Self{\n        Scheme {\n            inner: Scheme2::None,\n        }\n    }', 'Real(LocalPath("src/uri/scheme.rs"))'], 'version::Http': ['enum Http {\n    Http09,\n    Http10,\n    Http11,\n    H2,\n    H3,\n    __NonExhaustive,\n}', 'Real(LocalPath("src/version.rs"))'], 'version::Version': ['/// Represents a version of the HTTP spec.\npub struct Version(Http);', 'Real(LocalPath("src/version.rs"))']}, 'struct_constructor': {'&\'^0.Named(DefId(0:2929 ~ http[472d]::header::map::{impl#35}::key::\'_), "\'_") header::name::HeaderName': ['key'], '&\'^0.Named(DefId(0:2930 ~ http[472d]::header::map::{impl#36}::key::\'_), "\'_") header::name::HeaderName': ['key'], '&\'^0.Named(DefId(0:2942 ~ http[472d]::header::map::{impl#52}::key::\'_), "\'_") header::name::HeaderName': ['key'], '&\'^0.Named(DefId(0:2954 ~ http[472d]::header::map::{impl#63}::index::\'_), "\'_") Alias(Projection, AliasTy { args: [header::map::RawLinks<T/#0>, usize], def_id: DefId(2:40133 ~ core[a245]::ops::index::Index::Output) })': ['index'], '&\'^0.Named(DefId(0:2955 ~ http[472d]::header::map::{impl#64}::index_mut::\'_), "\'_") mut Alias(Projection, AliasTy { args: [header::map::RawLinks<T/#0>, usize], def_id: DefId(2:40133 ~ core[a245]::ops::index::Index::Output) })': ['index_mut'], '&\'^0.Named(DefId(0:2987 ~ http[472d]::header::map::as_header_name::Sealed::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:2991 ~ http[472d]::header::map::as_header_name::{impl#2}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:2995 ~ http[472d]::header::map::as_header_name::{impl#4}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:2999 ~ http[472d]::header::map::as_header_name::{impl#6}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3003 ~ http[472d]::header::map::as_header_name::{impl#8}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3007 ~ http[472d]::header::map::as_header_name::{impl#10}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3012 ~ http[472d]::header::name::{impl#1}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3014 ~ http[472d]::header::name::{impl#3}::as_ref::\'_), "\'_") str': ['as_ref'], '&\'^0.Named(DefId(0:3015 ~ http[472d]::header::name::{impl#4}::as_ref::\'_), "\'_") [u8]': ['as_ref'], '&\'^0.Named(DefId(0:3016 ~ http[472d]::header::name::{impl#5}::borrow::\'_), "\'_") str': ['borrow'], '&\'^0.Named(DefId(0:3054 ~ http[472d]::header::name::slice_assume_init::\'_), "\'_") [T/#0]': ['slice_assume_init'], '&\'^0.Named(DefId(0:3057 ~ http[472d]::header::value::{impl#0}::to_str::\'_), "\'_") str': ['to_str'], '&\'^0.Named(DefId(0:3060 ~ http[472d]::header::value::{impl#0}::as_bytes::\'_), "\'_") [u8]': ['as_bytes'], '&\'^0.Named(DefId(0:3063 ~ http[472d]::header::value::{impl#1}::as_ref::\'_), "\'_") [u8]': ['as_ref'], '&\'^0.Named(DefId(0:3125 ~ http[472d]::method::{impl#0}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3126 ~ http[472d]::method::{impl#1}::as_ref::\'_), "\'_") str': ['as_ref'], '&\'^0.Named(DefId(0:3153 ~ http[472d]::method::extension::{impl#0}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3155 ~ http[472d]::method::extension::{impl#1}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3158 ~ http[472d]::request::{impl#1}::method::\'_), "\'_") method::Method': ['method'], '&\'^0.Named(DefId(0:3159 ~ http[472d]::request::{impl#1}::method_mut::\'_), "\'_") mut method::Method': ['method_mut'], '&\'^0.Named(DefId(0:3160 ~ http[472d]::request::{impl#1}::uri::\'_), "\'_") uri::Uri': ['uri'], '&\'^0.Named(DefId(0:3161 ~ http[472d]::request::{impl#1}::uri_mut::\'_), "\'_") mut uri::Uri': ['uri_mut'], '&\'^0.Named(DefId(0:3163 ~ http[472d]::request::{impl#1}::version_mut::\'_), "\'_") mut version::Version': ['version_mut'], '&\'^0.Named(DefId(0:3166 ~ http[472d]::request::{impl#1}::extensions::\'_), "\'_") extensions::Extensions': ['extensions'], '&\'^0.Named(DefId(0:3167 ~ http[472d]::request::{impl#1}::extensions_mut::\'_), "\'_") mut extensions::Extensions': ['extensions_mut'], '&\'^0.Named(DefId(0:3176 ~ http[472d]::request::{impl#6}::method_ref::\'_), "\'_") method::Method': ['method_ref'], '&\'^0.Named(DefId(0:3177 ~ http[472d]::request::{impl#6}::uri_ref::\'_), "\'_") uri::Uri': ['uri_ref'], '&\'^0.Named(DefId(0:3178 ~ http[472d]::request::{impl#6}::version_ref::\'_), "\'_") version::Version': ['version_ref'], '&\'^0.Named(DefId(0:3181 ~ http[472d]::request::{impl#6}::extensions_ref::\'_), "\'_") extensions::Extensions': ['extensions_ref'], '&\'^0.Named(DefId(0:3182 ~ http[472d]::request::{impl#6}::extensions_mut::\'_), "\'_") mut extensions::Extensions': ['extensions_mut'], '&\'^0.Named(DefId(0:3184 ~ http[472d]::response::{impl#1}::status_mut::\'_), "\'_") mut status::StatusCode': ['status_mut'], '&\'^0.Named(DefId(0:3186 ~ http[472d]::response::{impl#1}::version_mut::\'_), "\'_") mut version::Version': ['version_mut'], '&\'^0.Named(DefId(0:3189 ~ http[472d]::response::{impl#1}::extensions::\'_), "\'_") extensions::Extensions': ['extensions'], '&\'^0.Named(DefId(0:3190 ~ http[472d]::response::{impl#1}::extensions_mut::\'_), "\'_") mut extensions::Extensions': ['extensions_mut'], '&\'^0.Named(DefId(0:3201 ~ http[472d]::response::{impl#6}::extensions_ref::\'_), "\'_") extensions::Extensions': ['extensions_ref'], '&\'^0.Named(DefId(0:3202 ~ http[472d]::response::{impl#6}::extensions_mut::\'_), "\'_") mut extensions::Extensions': ['extensions_mut'], '&\'^0.Named(DefId(0:3205 ~ http[472d]::status::{impl#0}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3231 ~ http[472d]::uri::authority::{impl#0}::host::\'_), "\'_") str': ['host'], '&\'^0.Named(DefId(0:3234 ~ http[472d]::uri::authority::{impl#0}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3235 ~ http[472d]::uri::authority::{impl#1}::as_ref::\'_), "\'_") str': ['as_ref'], '&\'^0.Named(DefId(0:3274 ~ http[472d]::uri::path::{impl#0}::path::\'_), "\'_") str': ['path'], '&\'^0.Named(DefId(0:3275 ~ http[472d]::uri::path::{impl#0}::query::\'_), "\'_") str': ['query'], '&\'^0.Named(DefId(0:3276 ~ http[472d]::uri::path::{impl#0}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3317 ~ http[472d]::uri::port::{impl#1}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3324 ~ http[472d]::uri::port::{impl#5}::as_ref::\'_), "\'_") str': ['as_ref'], '&\'^0.Named(DefId(0:3331 ~ http[472d]::uri::scheme::{impl#0}::as_str::\'_), "\'_") str': ['as_str'], '&\'^0.Named(DefId(0:3339 ~ http[472d]::uri::scheme::{impl#6}::as_ref::\'_), "\'_") str': ['as_ref'], '&\'^0.Named(DefId(0:3352 ~ http[472d]::uri::{impl#0}::path_and_query::\'_), "\'_") uri::path::PathAndQuery': ['path_and_query'], '&\'^0.Named(DefId(0:3353 ~ http[472d]::uri::{impl#0}::path::\'_), "\'_") str': ['path'], '&\'^0.Named(DefId(0:3354 ~ http[472d]::uri::{impl#0}::scheme::\'_), "\'_") uri::scheme::Scheme': ['scheme'], '&\'^0.Named(DefId(0:3355 ~ http[472d]::uri::{impl#0}::scheme_str::\'_), "\'_") str': ['scheme_str'], '&\'^0.Named(DefId(0:3356 ~ http[472d]::uri::{impl#0}::authority::\'_), "\'_") uri::authority::Authority': ['authority'], '&\'^0.Named(DefId(0:3357 ~ http[472d]::uri::{impl#0}::host::\'_), "\'_") str': ['host'], '&\'^0.Named(DefId(0:3360 ~ http[472d]::uri::{impl#0}::query::\'_), "\'_") str': ['query'], '&\'^0.Named(DefId(0:3379 ~ http[472d]::uri::{impl#23}::s::\'_), "\'_") str': ['s'], '&\'^0.Named(DefId(0:3391 ~ http[472d]::byte_str::{impl#1}::deref::\'_), "\'_") str': ['deref'], '&\'^0.Named(DefId(0:3399 ~ http[472d]::error::{impl#2}::get_ref::\'_), "\'_") dyn [Binder { value: Trait(std::error::Error), bound_vars: [] }] + \'static': ['get_ref'], '&\'^0.Named(DefId(0:3400 ~ http[472d]::error::{impl#3}::source::\'_), "\'_") dyn [Binder { value: Trait(std::error::Error), bound_vars: [] }] + \'static': ['source'], '&\'^0.Named(DefId(0:3420 ~ http[472d]::extensions::AnyClone::as_any::\'_), "\'_") dyn [Binder { value: Trait(std::any::Any), bound_vars: [] }] + \'static': ['as_any'], '&\'^0.Named(DefId(0:3421 ~ http[472d]::extensions::AnyClone::as_any_mut::\'_), "\'_") mut dyn [Binder { value: Trait(std::any::Any), bound_vars: [] }] + \'static': ['as_any_mut'], '&\'^0.Named(DefId(0:3423 ~ http[472d]::extensions::{impl#3}::as_any::\'_), "\'_") dyn [Binder { value: Trait(std::any::Any), bound_vars: [] }] + \'static': ['as_any'], '&\'^0.Named(DefId(0:3424 ~ http[472d]::extensions::{impl#3}::as_any_mut::\'_), "\'_") mut dyn [Binder { value: Trait(std::any::Any), bound_vars: [] }] + \'static': ['as_any_mut'], "&'static str": ['as_str', 'canonical_reason'], "(&'a/#0 header::name::HeaderName, *mut T/#1)": ['next_unsafe'], '(header::name::HeaderName, T/#1)': ['remove_entry'], "(header::name::HeaderName, header::map::ValueDrain<'a/#0, T/#1>)": ['remove_entry_mult'], '(request::Parts, T/#0)': ['into_parts'], '(response::Parts, T/#0)': ['into_parts'], '(usize, header::map::HashValue)': ['resolve'], '(usize, std::option::Option<usize>)': ['size_hint'], '(usize, usize)': ['find'], "Alias(Projection, AliasTy { args: [header::map::Drain<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": ['next'], 'Alias(Projection, AliasTy { args: [header::map::IntoIter<T/#0>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })': ['next'], "Alias(Projection, AliasTy { args: [header::map::Iter<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": ['next'], "Alias(Projection, AliasTy { args: [header::map::IterMut<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": ['next'], "Alias(Projection, AliasTy { args: [header::map::Keys<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": ['last', 'next', 'nth'], "Alias(Projection, AliasTy { args: [header::map::ValueIter<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": ['next', 'next_back'], "Alias(Projection, AliasTy { args: [header::map::ValueIterMut<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": ['next', 'next_back'], "Alias(Projection, AliasTy { args: [header::map::Values<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": ['next'], "Alias(Projection, AliasTy { args: [header::map::ValuesMut<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": ['next'], '[std::mem::MaybeUninit<u8>; UnevaluatedConst { def: DefId(0:3053 ~ http[472d]::header::name::uninit_u8_array::{constant#1}), args: [] }]': ['uninit_u8_array'], 'bool': ['append', 'contains_key', 'eq', 'eq_ignore_ascii_case', 'has_path', 'is', 'is_client_error', 'is_empty', 'is_idempotent', 'is_informational', 'is_none', 'is_red', 'is_redirection', 'is_safe', 'is_sensitive', 'is_server_error', 'is_some', 'is_success', 'is_valid', 'is_visible_ascii', 'is_yellow', 'try_append', 'try_append2'], 'byte_str::ByteStr': ['clone', 'from', 'from_static', 'from_utf8', 'from_utf8_unchecked', 'new'], 'bytes::Bytes': ['from', 'into_bytes'], 'error::Error': ['from'], 'extensions::Extensions': ['clone', 'default', 'new'], 'extensions::IdHasher': ['default'], 'header::map::Bucket': ['clone', 'remove_found'], 'header::map::Cursor': ['clone'], 'header::map::Danger': ['clone'], 'header::map::Drain': ['drain'], 'header::map::Entry': ['entry', 'try_entry', 'try_entry2'], 'header::map::ExtraValue': ['clone', 'remove_extra_value'], 'header::map::GetAll': ['get_all'], 'header::map::HashValue': ['clone', 'hash_elem_using'], 'header::map::HeaderMap': ['clone', 'default', 'from_iter', 'new', 'try_from', 'try_with_capacity', 'with_capacity'], 'header::map::IntoIter': ['into_iter'], 'header::map::Iter': ['into_iter', 'iter'], 'header::map::IterMut': ['into_iter', 'iter_mut'], 'header::map::Keys': ['keys'], 'header::map::Link': ['clone'], 'header::map::Links': ['clone'], 'header::map::MaxSizeReached': ['new'], 'header::map::OccupiedEntry': ['insert_entry', 'try_insert_entry'], 'header::map::Pos': ['clone', 'new', 'none'], 'header::map::RawLinks': ['clone', 'raw_links'], 'header::map::ValueDrain': ['insert_mult', 'insert_occupied_mult'], 'header::map::ValueIter': ['into_iter', 'iter', 'value_iter'], 'header::map::ValueIterMut': ['into_iter', 'iter_mut', 'value_iter_mut'], 'header::map::Values': ['values'], 'header::map::ValuesMut': ['values_mut'], 'header::map::as_header_name::TryEntryError': ['from'], 'header::name::Custom': ['clone'], 'header::name::HdrName': ['custom', 'from', 'parse_hdr'], 'header::name::HeaderName': ['clone', 'from', 'from_bytes', 'from_lowercase', 'from_static', 'from_str', 'into_key', 'try_from'], 'header::name::InvalidHeaderName': ['new'], 'header::name::MaybeLower': ['clone'], 'header::name::Repr': ['clone'], 'header::name::StandardHeader': ['clone', 'from_bytes'], 'header::value::HeaderValue': ['clone', 'from', 'from_bytes', 'from_maybe_shared', 'from_maybe_shared_unchecked', 'from_name', 'from_shared', 'from_static', 'from_str', 'try_from', 'try_from_generic'], 'method::Inner': ['clone'], 'method::InvalidMethod': ['new'], 'method::Method': ['clone', 'default', 'extension_inline', 'from', 'from_bytes', 'from_str', 'try_from'], 'method::extension::AllocatedExtension': ['clone', 'new'], 'method::extension::InlineExtension': ['clone', 'new'], 'request::Builder': ['builder', 'connect', 'default', 'delete', 'get', 'head', 'new', 'options', 'patch', 'post', 'put', 'trace'], 'request::Parts': ['clone', 'new'], 'request::Request': ['body', 'clone', 'default', 'from_parts', 'new'], 'response::Builder': ['builder', 'default', 'new'], 'response::Parts': ['clone', 'new'], 'response::Response': ['body', 'clone', 'default', 'from_parts', 'new'], 'status::InvalidStatusCode': ['new'], 'status::StatusCode': ['clone', 'default', 'from', 'from_bytes', 'from_str', 'from_u16', 'status', 'try_from'], 'std::boxed::Box': ['clone', 'clone_box'], 'std::cmp::Ordering': ['cmp', 'partial_cmp'], 'std::vec::Vec': ['drain_all_extra_values'], 'u16': ['as_u16', 'from', 'port_u16'], 'u64': ['finish'], 'uri::InvalidUri': ['from'], 'uri::InvalidUriParts': ['from'], 'uri::Parts': ['default', 'from', 'into_parts'], 'uri::Uri': ['build', 'clone', 'default', 'from', 'from_maybe_shared', 'from_parts', 'from_shared', 'from_static', 'from_str', 'parse_full', 'try_from'], 'uri::authority::Authority': ['clone', 'create_authority', 'empty', 'from_maybe_shared', 'from_shared', 'from_static', 'from_str', 'try_from'], 'uri::builder::Builder': ['builder', 'default', 'from', 'new'], 'uri::path::PathAndQuery': ['clone', 'empty', 'from_maybe_shared', 'from_shared', 'from_static', 'from_str', 'slash', 'star', 'try_from'], 'uri::port::Port': ['from_str', 'port'], 'uri::scheme::Protocol': ['clone'], 'uri::scheme::Scheme': ['clone', 'empty', 'from', 'from_str', 'try_from'], 'uri::scheme::Scheme2': ['clone', 'from', 'parse', 'parse_exact'], 'usize': ['capacity', 'count', 'desired_pos', 'keys_len', 'len', 'parse', 'parse_non_empty'], 'version::Http': ['clone'], 'version::Version': ['clone', 'default', 'version']}, 'struct_to_trait': {'<T as extensions::AnyClone>::T': ['extensions::AnyClone'], 'byte_str::ByteStr': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::Ord', 'std::cmp::PartialEq', 'std::cmp::PartialOrd', 'std::convert::From', 'std::fmt::Debug', 'std::hash::Hash', 'std::marker::StructuralPartialEq', 'std::ops::Deref'], 'bytes::Bytes': ['std::convert::From'], 'error::Error': ['std::convert::From', 'std::error::Error', 'std::fmt::Debug', 'std::fmt::Display'], 'extensions::Extensions': ['std::clone::Clone', 'std::default::Default', 'std::fmt::Debug'], 'extensions::IdHasher': ['std::default::Default', 'std::hash::Hasher'], 'header::map::Bucket': ['std::clone::Clone', 'std::fmt::Debug'], 'header::map::Cursor': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::marker::Copy', 'std::marker::StructuralPartialEq'], 'header::map::Danger': ['std::clone::Clone'], 'header::map::Drain': ['std::fmt::Debug', 'std::iter::FusedIterator', 'std::iter::Iterator', 'std::marker::Send', 'std::marker::Sync', 'std::ops::Drop'], 'header::map::Entry': ['std::fmt::Debug'], 'header::map::ExtraValue': ['std::clone::Clone', 'std::fmt::Debug'], 'header::map::GetAll': ['std::cmp::PartialEq', 'std::fmt::Debug', 'std::iter::IntoIterator'], 'header::map::HashValue': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::marker::Copy', 'std::marker::StructuralPartialEq'], 'header::map::HeaderMap': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::TryFrom', 'std::default::Default', 'std::fmt::Debug', 'std::iter::Extend', 'std::iter::FromIterator', 'std::iter::IntoIterator', 'std::ops::Index'], 'header::map::IntoIter': ['std::fmt::Debug', 'std::iter::FusedIterator', 'std::iter::Iterator', 'std::ops::Drop'], 'header::map::Iter': ['std::fmt::Debug', 'std::iter::FusedIterator', 'std::iter::Iterator', 'std::marker::Send', 'std::marker::Sync'], 'header::map::IterMut': ['std::fmt::Debug', 'std::iter::FusedIterator', 'std::iter::Iterator', 'std::marker::Send', 'std::marker::Sync'], 'header::map::Keys': ['std::fmt::Debug', 'std::iter::ExactSizeIterator', 'std::iter::FusedIterator', 'std::iter::Iterator'], 'header::map::Link': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::marker::Copy', 'std::marker::StructuralPartialEq'], 'header::map::Links': ['std::clone::Clone', 'std::fmt::Debug', 'std::marker::Copy'], 'header::map::MaxSizeReached': ['std::error::Error', 'std::fmt::Debug', 'std::fmt::Display'], 'header::map::OccupiedEntry': ['std::fmt::Debug', 'std::iter::IntoIterator'], 'header::map::Pos': ['std::clone::Clone', 'std::marker::Copy'], 'header::map::RawLinks': ['std::clone::Clone', 'std::fmt::Debug', 'std::marker::Copy', 'std::ops::Index', 'std::ops::IndexMut'], 'header::map::VacantEntry': ['std::fmt::Debug'], 'header::map::ValueDrain': ['std::fmt::Debug', 'std::iter::FusedIterator', 'std::iter::Iterator', 'std::marker::Send', 'std::marker::Sync', 'std::ops::Drop'], 'header::map::ValueIter': ['std::fmt::Debug', 'std::iter::DoubleEndedIterator', 'std::iter::FusedIterator', 'std::iter::Iterator'], 'header::map::ValueIterMut': ['std::fmt::Debug', 'std::iter::DoubleEndedIterator', 'std::iter::FusedIterator', 'std::iter::Iterator', 'std::marker::Send', 'std::marker::Sync'], 'header::map::Values': ['std::fmt::Debug', 'std::iter::FusedIterator', 'std::iter::Iterator'], 'header::map::ValuesMut': ['std::fmt::Debug', 'std::iter::FusedIterator', 'std::iter::Iterator'], 'header::map::as_header_name::TryEntryError': ['std::convert::From'], 'header::name::Custom': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::hash::Hash', 'std::marker::StructuralPartialEq'], 'header::name::HdrName': ['std::convert::From', 'std::fmt::Debug', 'std::hash::Hash'], 'header::name::HeaderName': ['header::map::as_header_name::AsHeaderName', 'header::map::as_header_name::Sealed', 'header::map::into_header_name::IntoHeaderName', 'header::map::into_header_name::Sealed', 'std::borrow::Borrow', 'std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::AsRef', 'std::convert::From', 'std::convert::TryFrom', 'std::fmt::Debug', 'std::fmt::Display', 'std::hash::Hash', 'std::marker::StructuralPartialEq', 'std::str::FromStr'], 'header::name::InvalidHeaderName': ['std::error::Error', 'std::fmt::Debug', 'std::fmt::Display'], 'header::name::MaybeLower': ['std::clone::Clone', 'std::fmt::Debug', 'std::hash::Hash'], 'header::name::Repr': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::hash::Hash', 'std::marker::StructuralPartialEq'], 'header::name::StandardHeader': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::hash::Hash', 'std::marker::Copy', 'std::marker::StructuralPartialEq'], 'header::value::HeaderValue': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::Ord', 'std::cmp::PartialEq', 'std::cmp::PartialOrd', 'std::convert::AsRef', 'std::convert::From', 'std::convert::TryFrom', 'std::fmt::Debug', 'std::hash::Hash', 'std::str::FromStr'], 'header::value::InvalidHeaderValue': ['std::error::Error', 'std::fmt::Debug', 'std::fmt::Display'], 'header::value::ToStrError': ['std::error::Error', 'std::fmt::Debug', 'std::fmt::Display'], 'method::Inner': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::hash::Hash', 'std::marker::StructuralPartialEq'], 'method::InvalidMethod': ['std::error::Error', 'std::fmt::Debug', 'std::fmt::Display'], 'method::Method': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::AsRef', 'std::convert::From', 'std::convert::TryFrom', 'std::default::Default', 'std::fmt::Debug', 'std::fmt::Display', 'std::hash::Hash', 'std::marker::StructuralPartialEq', 'std::str::FromStr'], 'method::extension::AllocatedExtension': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::hash::Hash', 'std::marker::StructuralPartialEq'], 'method::extension::InlineExtension': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::hash::Hash', 'std::marker::StructuralPartialEq'], 'request::Builder': ['std::default::Default', 'std::fmt::Debug'], 'request::Parts': ['std::clone::Clone', 'std::fmt::Debug'], 'request::Request': ['std::clone::Clone', 'std::default::Default', 'std::fmt::Debug'], 'response::Builder': ['std::default::Default', 'std::fmt::Debug'], 'response::Parts': ['std::clone::Clone', 'std::fmt::Debug'], 'response::Response': ['std::clone::Clone', 'std::default::Default', 'std::fmt::Debug'], 'status::InvalidStatusCode': ['std::error::Error', 'std::fmt::Debug', 'std::fmt::Display'], 'status::StatusCode': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::Ord', 'std::cmp::PartialEq', 'std::cmp::PartialOrd', 'std::convert::From', 'std::convert::TryFrom', 'std::default::Default', 'std::fmt::Debug', 'std::fmt::Display', 'std::hash::Hash', 'std::marker::Copy', 'std::marker::StructuralPartialEq', 'std::str::FromStr'], 'std::boxed::Box': ['std::clone::Clone'], 'std::string::String': ['header::map::as_header_name::AsHeaderName', 'header::map::as_header_name::Sealed', 'std::cmp::PartialEq', 'std::cmp::PartialOrd'], 'uri::ErrorKind': ['std::cmp::Eq', 'std::cmp::PartialEq', 'std::fmt::Debug', 'std::marker::StructuralPartialEq'], 'uri::InvalidUri': ['std::convert::From', 'std::error::Error', 'std::fmt::Debug', 'std::fmt::Display'], 'uri::InvalidUriParts': ['std::convert::From', 'std::error::Error', 'std::fmt::Debug', 'std::fmt::Display'], 'uri::Parts': ['std::convert::From', 'std::default::Default', 'std::fmt::Debug'], 'uri::Uri': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::From', 'std::convert::TryFrom', 'std::default::Default', 'std::fmt::Debug', 'std::fmt::Display', 'std::hash::Hash', 'std::str::FromStr'], 'uri::authority::Authority': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::cmp::PartialOrd', 'std::convert::AsRef', 'std::convert::TryFrom', 'std::fmt::Debug', 'std::fmt::Display', 'std::hash::Hash', 'std::str::FromStr'], 'uri::builder::Builder': ['std::convert::From', 'std::default::Default', 'std::fmt::Debug'], 'uri::path::PathAndQuery': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::cmp::PartialOrd', 'std::convert::TryFrom', 'std::fmt::Debug', 'std::fmt::Display', 'std::hash::Hash', 'std::str::FromStr'], 'uri::port::Port': ['std::cmp::PartialEq', 'std::convert::AsRef', 'std::fmt::Debug', 'std::fmt::Display'], 'uri::scheme::Protocol': ['std::clone::Clone', 'std::fmt::Debug', 'std::marker::Copy'], 'uri::scheme::Scheme': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::PartialEq', 'std::convert::AsRef', 'std::convert::From', 'std::convert::TryFrom', 'std::fmt::Debug', 'std::fmt::Display', 'std::hash::Hash', 'std::str::FromStr'], 'uri::scheme::Scheme2': ['std::clone::Clone', 'std::convert::From', 'std::fmt::Debug'], 'version::Http': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::Ord', 'std::cmp::PartialEq', 'std::cmp::PartialOrd', 'std::hash::Hash', 'std::marker::Copy', 'std::marker::StructuralPartialEq'], 'version::Version': ['std::clone::Clone', 'std::cmp::Eq', 'std::cmp::Ord', 'std::cmp::PartialEq', 'std::cmp::PartialOrd', 'std::default::Default', 'std::fmt::Debug', 'std::hash::Hash', 'std::marker::Copy', 'std::marker::StructuralPartialEq']}, 'targets': {"<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::IntoIterator'], "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str": ['as_str', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find": ['find', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry": ['try_entry', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_append": ['try_append', 'Real(LocalPath("src/header/map.rs"))', 'header::map::into_header_name::Sealed'], "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry": ['try_entry', 'Real(LocalPath("src/header/map.rs"))', 'header::map::into_header_name::Sealed'], "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert": ['try_insert', 'Real(LocalPath("src/header/map.rs"))', 'header::map::into_header_name::Sealed'], "<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq": ['eq', 'Real(LocalPath("src/header/name.rs"))', 'std::cmp::PartialEq'], "<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq": ['eq', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialEq'], "<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp": ['partial_cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialOrd'], "<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq": ['eq', 'Real(LocalPath("src/method.rs"))', 'std::cmp::PartialEq'], "<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::IntoIterator'], "<&'a std::string::String as header::map::as_header_name::Sealed>::as_str": ['as_str', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], "<&'a std::string::String as header::map::as_header_name::Sealed>::find": ['find', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], "<&'a std::string::String as header::map::as_header_name::Sealed>::try_entry": ['try_entry', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], "<&'a str as header::map::as_header_name::Sealed>::as_str": ['as_str', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], "<&'a str as header::map::as_header_name::Sealed>::find": ['find', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], "<&'a str as header::map::as_header_name::Sealed>::try_entry": ['try_entry', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], "<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::IntoIterator'], "<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::IntoIterator'], "<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::IntoIterator'], "<&'static str as header::map::into_header_name::Sealed>::try_append": ['try_append', 'Real(LocalPath("src/header/map.rs"))', 'header::map::into_header_name::Sealed'], "<&'static str as header::map::into_header_name::Sealed>::try_entry": ['try_entry', 'Real(LocalPath("src/header/map.rs"))', 'header::map::into_header_name::Sealed'], "<&'static str as header::map::into_header_name::Sealed>::try_insert": ['try_insert', 'Real(LocalPath("src/header/map.rs"))', 'header::map::into_header_name::Sealed'], '<T as extensions::AnyClone>::as_any': ['as_any', 'Real(LocalPath("src/extensions.rs"))', 'extensions::AnyClone'], '<T as extensions::AnyClone>::as_any_mut': ['as_any_mut', 'Real(LocalPath("src/extensions.rs"))', 'extensions::AnyClone'], '<T as extensions::AnyClone>::clone_box': ['clone_box', 'Real(LocalPath("src/extensions.rs"))', 'extensions::AnyClone'], '<T as extensions::AnyClone>::into_any': ['into_any', 'Real(LocalPath("src/extensions.rs"))', 'extensions::AnyClone'], "<byte_str::ByteStr as std::convert::From<&'a str>>::from": ['from', 'Real(LocalPath("src/byte_str.rs"))', 'std::convert::From'], '<byte_str::ByteStr as std::convert::From<std::string::String>>::from': ['from', 'Real(LocalPath("src/byte_str.rs"))', 'std::convert::From'], '<byte_str::ByteStr as std::ops::Deref>::deref': ['deref', 'Real(LocalPath("src/byte_str.rs"))', 'std::ops::Deref'], '<error::Error as std::convert::From<header::map::MaxSizeReached>>::from': ['from', 'Real(LocalPath("src/error.rs"))', 'std::convert::From'], '<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from': ['from', 'Real(LocalPath("src/error.rs"))', 'std::convert::From'], '<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from': ['from', 'Real(LocalPath("src/error.rs"))', 'std::convert::From'], '<error::Error as std::convert::From<method::InvalidMethod>>::from': ['from', 'Real(LocalPath("src/error.rs"))', 'std::convert::From'], '<error::Error as std::convert::From<status::InvalidStatusCode>>::from': ['from', 'Real(LocalPath("src/error.rs"))', 'std::convert::From'], '<error::Error as std::convert::From<std::convert::Infallible>>::from': ['from', 'Real(LocalPath("src/error.rs"))', 'std::convert::From'], '<error::Error as std::convert::From<uri::InvalidUri>>::from': ['from', 'Real(LocalPath("src/error.rs"))', 'std::convert::From'], '<error::Error as std::convert::From<uri::InvalidUriParts>>::from': ['from', 'Real(LocalPath("src/error.rs"))', 'std::convert::From'], '<error::Error as std::error::Error>::source': ['source', 'Real(LocalPath("src/error.rs"))', 'std::error::Error'], '<error::Error as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/error.rs"))', 'std::fmt::Debug'], '<error::Error as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/error.rs"))', 'std::fmt::Display'], '<extensions::Extensions as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/extensions.rs"))', 'std::fmt::Debug'], '<extensions::IdHasher as std::hash::Hasher>::finish': ['finish', 'Real(LocalPath("src/extensions.rs"))', 'std::hash::Hasher'], '<extensions::IdHasher as std::hash::Hasher>::write': ['write', 'Real(LocalPath("src/extensions.rs"))', 'std::hash::Hasher'], '<extensions::IdHasher as std::hash::Hasher>::write_u64': ['write_u64', 'Real(LocalPath("src/extensions.rs"))', 'std::hash::Hasher'], "<header::map::Drain<'a, T> as std::iter::Iterator>::next": ['next', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::Drain<'a, T> as std::ops::Drop>::drop": ['drop', 'Real(LocalPath("src/header/map.rs"))', 'std::ops::Drop'], "<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq": ['eq', 'Real(LocalPath("src/header/map.rs"))', 'std::cmp::PartialEq'], "<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::IntoIterator'], '<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("src/header/map.rs"))', 'std::cmp::PartialEq'], "<header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V, S>>>::try_from": ['try_from', 'Real(LocalPath("src/header/map.rs"))', 'std::convert::TryFrom'], '<header::map::HeaderMap<T> as std::default::Default>::default': ['default', 'Real(LocalPath("src/header/map.rs"))', 'std::default::Default'], '<header::map::HeaderMap<T> as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/header/map.rs"))', 'std::fmt::Debug'], '<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend': ['extend', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Extend'], '<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend': ['extend', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Extend'], '<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter': ['from_iter', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::FromIterator'], '<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter': ['into_iter', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::IntoIterator'], '<header::map::HeaderMap<T> as std::ops::Index<K>>::index': ['index', 'Real(LocalPath("src/header/map.rs"))', 'std::ops::Index'], '<header::map::IntoIter<T> as std::iter::Iterator>::next': ['next', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], '<header::map::IntoIter<T> as std::iter::Iterator>::size_hint': ['size_hint', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], '<header::map::IntoIter<T> as std::ops::Drop>::drop': ['drop', 'Real(LocalPath("src/header/map.rs"))', 'std::ops::Drop'], "<header::map::Iter<'a, T> as std::iter::Iterator>::next": ['next', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::IterMut<'a, T> as std::iter::Iterator>::next": ['next', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::Keys<'a, T> as std::iter::Iterator>::count": ['count', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::Keys<'a, T> as std::iter::Iterator>::last": ['last', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::Keys<'a, T> as std::iter::Iterator>::next": ['next', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::Keys<'a, T> as std::iter::Iterator>::nth": ['nth', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], '<header::map::MaxSizeReached as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/header/map.rs"))', 'std::fmt::Debug'], '<header::map::MaxSizeReached as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/header/map.rs"))', 'std::fmt::Display'], "<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::IntoIterator'], '<header::map::RawLinks<T> as std::clone::Clone>::clone': ['clone', 'Real(LocalPath("src/header/map.rs"))', 'std::clone::Clone'], '<header::map::RawLinks<T> as std::ops::Index<usize>>::index': ['index', 'Real(LocalPath("src/header/map.rs"))', 'std::ops::Index'], '<header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut': ['index_mut', 'Real(LocalPath("src/header/map.rs"))', 'std::ops::IndexMut'], "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next": ['next', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop": ['drop', 'Real(LocalPath("src/header/map.rs"))', 'std::ops::Drop'], "<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back": ['next_back', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::DoubleEndedIterator'], "<header::map::ValueIter<'a, T> as std::iter::Iterator>::next": ['next', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back": ['next_back', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::DoubleEndedIterator'], "<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next": ['next', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::Values<'a, T> as std::iter::Iterator>::next": ['next', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::Values<'a, T> as std::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next": ['next', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/header/map.rs"))', 'std::iter::Iterator'], '<header::map::as_header_name::TryEntryError as std::convert::From<header::map::MaxSizeReached>>::from': ['from', 'Real(LocalPath("src/header/map.rs"))', 'std::convert::From'], '<header::map::as_header_name::TryEntryError as std::convert::From<header::name::InvalidHeaderName>>::from': ['from', 'Real(LocalPath("src/header/map.rs"))', 'std::convert::From'], '<header::name::Custom as std::hash::Hash>::hash': ['hash', 'Real(LocalPath("src/header/name.rs"))', 'std::hash::Hash'], "<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from": ['from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::From'], '<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str': ['as_str', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], '<header::name::HeaderName as header::map::as_header_name::Sealed>::find': ['find', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], '<header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry': ['try_entry', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], '<header::name::HeaderName as header::map::into_header_name::Sealed>::try_append': ['try_append', 'Real(LocalPath("src/header/map.rs"))', 'header::map::into_header_name::Sealed'], '<header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry': ['try_entry', 'Real(LocalPath("src/header/map.rs"))', 'header::map::into_header_name::Sealed'], '<header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert': ['try_insert', 'Real(LocalPath("src/header/map.rs"))', 'header::map::into_header_name::Sealed'], '<header::name::HeaderName as std::borrow::Borrow<str>>::borrow': ['borrow', 'Real(LocalPath("src/header/name.rs"))', 'std::borrow::Borrow'], "<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq": ['eq', 'Real(LocalPath("src/header/name.rs"))', 'std::cmp::PartialEq'], "<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq": ['eq', 'Real(LocalPath("src/header/name.rs"))', 'std::cmp::PartialEq'], "<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq": ['eq', 'Real(LocalPath("src/header/name.rs"))', 'std::cmp::PartialEq'], '<header::name::HeaderName as std::cmp::PartialEq<str>>::eq': ['eq', 'Real(LocalPath("src/header/name.rs"))', 'std::cmp::PartialEq'], '<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref': ['as_ref', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::AsRef'], '<header::name::HeaderName as std::convert::AsRef<str>>::as_ref': ['as_ref', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::AsRef'], "<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from": ['from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::From'], '<header::name::HeaderName as std::convert::From<header::name::Custom>>::from': ['from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::From'], "<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from": ['from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::From'], '<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from': ['from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::From'], "<header::name::HeaderName as std::convert::TryFrom<&'a [u8]>>::try_from": ['try_from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::TryFrom'], "<header::name::HeaderName as std::convert::TryFrom<&'a std::string::String>>::try_from": ['try_from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::TryFrom'], "<header::name::HeaderName as std::convert::TryFrom<&'a str>>::try_from": ['try_from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::TryFrom'], '<header::name::HeaderName as std::convert::TryFrom<std::string::String>>::try_from': ['try_from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::TryFrom'], '<header::name::HeaderName as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['try_from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::TryFrom'], '<header::name::HeaderName as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/header/name.rs"))', 'std::fmt::Debug'], '<header::name::HeaderName as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/header/name.rs"))', 'std::fmt::Display'], '<header::name::HeaderName as std::str::FromStr>::from_str': ['from_str', 'Real(LocalPath("src/header/name.rs"))', 'std::str::FromStr'], '<header::name::InvalidHeaderName as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/header/name.rs"))', 'std::fmt::Debug'], '<header::name::InvalidHeaderName as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/header/name.rs"))', 'std::fmt::Display'], "<header::name::MaybeLower<'a> as std::hash::Hash>::hash": ['hash', 'Real(LocalPath("src/header/name.rs"))', 'std::hash::Hash'], '<header::value::HeaderValue as std::cmp::Ord>::cmp': ['cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::Ord'], "<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq": ['eq', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialEq'], '<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq': ['eq', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialEq'], '<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq': ['eq', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialEq'], '<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq': ['eq', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialEq'], '<header::value::HeaderValue as std::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialEq'], "<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp": ['partial_cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialOrd'], '<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialOrd'], '<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialOrd'], '<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialOrd'], '<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialOrd'], '<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref': ['as_ref', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::AsRef'], "<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from": ['from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::From'], '<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from': ['from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::From'], '<header::value::HeaderValue as std::convert::From<i16>>::from': ['from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::From'], '<header::value::HeaderValue as std::convert::From<i32>>::from': ['from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::From'], '<header::value::HeaderValue as std::convert::From<i64>>::from': ['from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::From'], '<header::value::HeaderValue as std::convert::From<isize>>::from': ['from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::From'], '<header::value::HeaderValue as std::convert::From<u16>>::from': ['from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::From'], '<header::value::HeaderValue as std::convert::From<u32>>::from': ['from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::From'], '<header::value::HeaderValue as std::convert::From<u64>>::from': ['from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::From'], '<header::value::HeaderValue as std::convert::From<usize>>::from': ['from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::From'], "<header::value::HeaderValue as std::convert::TryFrom<&'a [u8]>>::try_from": ['try_from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::TryFrom'], "<header::value::HeaderValue as std::convert::TryFrom<&'a std::string::String>>::try_from": ['try_from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::TryFrom'], "<header::value::HeaderValue as std::convert::TryFrom<&'a str>>::try_from": ['try_from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::TryFrom'], '<header::value::HeaderValue as std::convert::TryFrom<std::string::String>>::try_from': ['try_from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::TryFrom'], '<header::value::HeaderValue as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['try_from', 'Real(LocalPath("src/header/value.rs"))', 'std::convert::TryFrom'], '<header::value::HeaderValue as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/header/value.rs"))', 'std::fmt::Debug'], '<header::value::HeaderValue as std::hash::Hash>::hash': ['hash', 'Real(LocalPath("src/header/value.rs"))', 'std::hash::Hash'], '<header::value::HeaderValue as std::str::FromStr>::from_str': ['from_str', 'Real(LocalPath("src/header/value.rs"))', 'std::str::FromStr'], '<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/header/value.rs"))', 'std::fmt::Debug'], '<header::value::InvalidHeaderValue as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/header/value.rs"))', 'std::fmt::Display'], '<header::value::ToStrError as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/header/value.rs"))', 'std::fmt::Display'], '<method::InvalidMethod as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/method.rs"))', 'std::fmt::Debug'], '<method::InvalidMethod as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/method.rs"))', 'std::fmt::Display'], "<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq": ['eq', 'Real(LocalPath("src/method.rs"))', 'std::cmp::PartialEq'], "<method::Method as std::cmp::PartialEq<&'a str>>::eq": ['eq', 'Real(LocalPath("src/method.rs"))', 'std::cmp::PartialEq'], '<method::Method as std::cmp::PartialEq<str>>::eq': ['eq', 'Real(LocalPath("src/method.rs"))', 'std::cmp::PartialEq'], '<method::Method as std::convert::AsRef<str>>::as_ref': ['as_ref', 'Real(LocalPath("src/method.rs"))', 'std::convert::AsRef'], "<method::Method as std::convert::From<&'a method::Method>>::from": ['from', 'Real(LocalPath("src/method.rs"))', 'std::convert::From'], "<method::Method as std::convert::TryFrom<&'a [u8]>>::try_from": ['try_from', 'Real(LocalPath("src/method.rs"))', 'std::convert::TryFrom'], "<method::Method as std::convert::TryFrom<&'a str>>::try_from": ['try_from', 'Real(LocalPath("src/method.rs"))', 'std::convert::TryFrom'], '<method::Method as std::default::Default>::default': ['default', 'Real(LocalPath("src/method.rs"))', 'std::default::Default'], '<method::Method as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/method.rs"))', 'std::fmt::Debug'], '<method::Method as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/method.rs"))', 'std::fmt::Display'], '<method::Method as std::str::FromStr>::from_str': ['from_str', 'Real(LocalPath("src/method.rs"))', 'std::str::FromStr'], '<request::Builder as std::default::Default>::default': ['default', 'Real(LocalPath("src/request.rs"))', 'std::default::Default'], '<request::Parts as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/request.rs"))', 'std::fmt::Debug'], '<request::Request<T> as std::default::Default>::default': ['default', 'Real(LocalPath("src/request.rs"))', 'std::default::Default'], '<request::Request<T> as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/request.rs"))', 'std::fmt::Debug'], '<response::Builder as std::default::Default>::default': ['default', 'Real(LocalPath("src/response.rs"))', 'std::default::Default'], '<response::Parts as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/response.rs"))', 'std::fmt::Debug'], '<response::Response<T> as std::default::Default>::default': ['default', 'Real(LocalPath("src/response.rs"))', 'std::default::Default'], '<response::Response<T> as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/response.rs"))', 'std::fmt::Debug'], '<status::InvalidStatusCode as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/status.rs"))', 'std::fmt::Debug'], '<status::InvalidStatusCode as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/status.rs"))', 'std::fmt::Display'], '<status::StatusCode as std::cmp::PartialEq<u16>>::eq': ['eq', 'Real(LocalPath("src/status.rs"))', 'std::cmp::PartialEq'], "<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from": ['from', 'Real(LocalPath("src/status.rs"))', 'std::convert::From'], "<status::StatusCode as std::convert::TryFrom<&'a [u8]>>::try_from": ['try_from', 'Real(LocalPath("src/status.rs"))', 'std::convert::TryFrom'], "<status::StatusCode as std::convert::TryFrom<&'a str>>::try_from": ['try_from', 'Real(LocalPath("src/status.rs"))', 'std::convert::TryFrom'], '<status::StatusCode as std::convert::TryFrom<u16>>::try_from': ['try_from', 'Real(LocalPath("src/status.rs"))', 'std::convert::TryFrom'], '<status::StatusCode as std::default::Default>::default': ['default', 'Real(LocalPath("src/status.rs"))', 'std::default::Default'], '<status::StatusCode as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/status.rs"))', 'std::fmt::Debug'], '<status::StatusCode as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/status.rs"))', 'std::fmt::Display'], '<status::StatusCode as std::str::FromStr>::from_str': ['from_str', 'Real(LocalPath("src/status.rs"))', 'std::str::FromStr'], '<std::string::String as header::map::as_header_name::Sealed>::as_str': ['as_str', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], '<std::string::String as header::map::as_header_name::Sealed>::find': ['find', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], '<std::string::String as header::map::as_header_name::Sealed>::try_entry': ['try_entry', 'Real(LocalPath("src/header/map.rs"))', 'header::map::as_header_name::Sealed'], '<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from': ['from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::From'], '<uri::InvalidUri as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/uri/mod.rs"))', 'std::fmt::Display'], '<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from': ['from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::From'], '<uri::InvalidUriParts as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/uri/mod.rs"))', 'std::fmt::Display'], '<uri::Parts as std::convert::From<uri::Uri>>::from': ['from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::From'], "<uri::Uri as std::cmp::PartialEq<&'a str>>::eq": ['eq', 'Real(LocalPath("src/uri/mod.rs"))', 'std::cmp::PartialEq'], '<uri::Uri as std::cmp::PartialEq<str>>::eq': ['eq', 'Real(LocalPath("src/uri/mod.rs"))', 'std::cmp::PartialEq'], '<uri::Uri as std::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("src/uri/mod.rs"))', 'std::cmp::PartialEq'], '<uri::Uri as std::convert::From<uri::authority::Authority>>::from': ['from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::From'], '<uri::Uri as std::convert::From<uri::path::PathAndQuery>>::from': ['from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::From'], "<uri::Uri as std::convert::TryFrom<&'a [u8]>>::try_from": ['try_from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::TryFrom'], "<uri::Uri as std::convert::TryFrom<&'a std::string::String>>::try_from": ['try_from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::TryFrom'], "<uri::Uri as std::convert::TryFrom<&'a str>>::try_from": ['try_from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::TryFrom'], "<uri::Uri as std::convert::TryFrom<&'a uri::Uri>>::try_from": ['try_from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::TryFrom'], '<uri::Uri as std::convert::TryFrom<std::string::String>>::try_from': ['try_from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::TryFrom'], '<uri::Uri as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['try_from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::TryFrom'], '<uri::Uri as std::convert::TryFrom<uri::Parts>>::try_from': ['try_from', 'Real(LocalPath("src/uri/mod.rs"))', 'std::convert::TryFrom'], '<uri::Uri as std::default::Default>::default': ['default', 'Real(LocalPath("src/uri/mod.rs"))', 'std::default::Default'], '<uri::Uri as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/uri/mod.rs"))', 'std::fmt::Debug'], '<uri::Uri as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/uri/mod.rs"))', 'std::fmt::Display'], '<uri::Uri as std::hash::Hash>::hash': ['hash', 'Real(LocalPath("src/uri/mod.rs"))', 'std::hash::Hash'], '<uri::Uri as std::str::FromStr>::from_str': ['from_str', 'Real(LocalPath("src/uri/mod.rs"))', 'std::str::FromStr'], "<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq": ['eq', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialEq'], '<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq': ['eq', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialEq'], '<uri::authority::Authority as std::cmp::PartialEq<str>>::eq': ['eq', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialEq'], '<uri::authority::Authority as std::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialEq'], "<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp": ['partial_cmp', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialOrd'], '<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialOrd'], '<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialOrd'], '<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialOrd'], '<uri::authority::Authority as std::convert::AsRef<str>>::as_ref': ['as_ref', 'Real(LocalPath("src/uri/authority.rs"))', 'std::convert::AsRef'], "<uri::authority::Authority as std::convert::TryFrom<&'a [u8]>>::try_from": ['try_from', 'Real(LocalPath("src/uri/authority.rs"))', 'std::convert::TryFrom'], "<uri::authority::Authority as std::convert::TryFrom<&'a str>>::try_from": ['try_from', 'Real(LocalPath("src/uri/authority.rs"))', 'std::convert::TryFrom'], '<uri::authority::Authority as std::convert::TryFrom<std::string::String>>::try_from': ['try_from', 'Real(LocalPath("src/uri/authority.rs"))', 'std::convert::TryFrom'], '<uri::authority::Authority as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['try_from', 'Real(LocalPath("src/uri/authority.rs"))', 'std::convert::TryFrom'], '<uri::authority::Authority as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/uri/authority.rs"))', 'std::fmt::Debug'], '<uri::authority::Authority as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/uri/authority.rs"))', 'std::fmt::Display'], '<uri::authority::Authority as std::hash::Hash>::hash': ['hash', 'Real(LocalPath("src/uri/authority.rs"))', 'std::hash::Hash'], '<uri::authority::Authority as std::str::FromStr>::from_str': ['from_str', 'Real(LocalPath("src/uri/authority.rs"))', 'std::str::FromStr'], '<uri::builder::Builder as std::convert::From<uri::Uri>>::from': ['from', 'Real(LocalPath("src/uri/builder.rs"))', 'std::convert::From'], '<uri::builder::Builder as std::default::Default>::default': ['default', 'Real(LocalPath("src/uri/builder.rs"))', 'std::default::Default'], "<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq": ['eq', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialEq'], '<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq': ['eq', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialEq'], '<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq': ['eq', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialEq'], '<uri::path::PathAndQuery as std::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialEq'], "<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp": ['partial_cmp', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialOrd'], '<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialOrd'], '<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialOrd'], '<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialOrd'], "<uri::path::PathAndQuery as std::convert::TryFrom<&'a [u8]>>::try_from": ['try_from', 'Real(LocalPath("src/uri/path.rs"))', 'std::convert::TryFrom'], "<uri::path::PathAndQuery as std::convert::TryFrom<&'a str>>::try_from": ['try_from', 'Real(LocalPath("src/uri/path.rs"))', 'std::convert::TryFrom'], '<uri::path::PathAndQuery as std::convert::TryFrom<&std::string::String>>::try_from': ['try_from', 'Real(LocalPath("src/uri/path.rs"))', 'std::convert::TryFrom'], '<uri::path::PathAndQuery as std::convert::TryFrom<std::string::String>>::try_from': ['try_from', 'Real(LocalPath("src/uri/path.rs"))', 'std::convert::TryFrom'], '<uri::path::PathAndQuery as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from': ['try_from', 'Real(LocalPath("src/uri/path.rs"))', 'std::convert::TryFrom'], '<uri::path::PathAndQuery as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/uri/path.rs"))', 'std::fmt::Debug'], '<uri::path::PathAndQuery as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/uri/path.rs"))', 'std::fmt::Display'], '<uri::path::PathAndQuery as std::hash::Hash>::hash': ['hash', 'Real(LocalPath("src/uri/path.rs"))', 'std::hash::Hash'], '<uri::path::PathAndQuery as std::str::FromStr>::from_str': ['from_str', 'Real(LocalPath("src/uri/path.rs"))', 'std::str::FromStr'], '<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq': ['eq', 'Real(LocalPath("src/uri/port.rs"))', 'std::cmp::PartialEq'], '<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq': ['eq', 'Real(LocalPath("src/uri/port.rs"))', 'std::cmp::PartialEq'], '<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref': ['as_ref', 'Real(LocalPath("src/uri/port.rs"))', 'std::convert::AsRef'], '<uri::port::Port<T> as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/uri/port.rs"))', 'std::fmt::Debug'], '<uri::port::Port<T> as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/uri/port.rs"))', 'std::fmt::Display'], '<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq': ['eq', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::cmp::PartialEq'], '<uri::scheme::Scheme as std::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::cmp::PartialEq'], '<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref': ['as_ref', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::convert::AsRef'], '<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from': ['from', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::convert::From'], "<uri::scheme::Scheme as std::convert::TryFrom<&'a [u8]>>::try_from": ['try_from', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::convert::TryFrom'], "<uri::scheme::Scheme as std::convert::TryFrom<&'a str>>::try_from": ['try_from', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::convert::TryFrom'], '<uri::scheme::Scheme as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::fmt::Debug'], '<uri::scheme::Scheme as std::fmt::Display>::fmt': ['fmt', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::fmt::Display'], '<uri::scheme::Scheme as std::hash::Hash>::hash': ['hash', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::hash::Hash'], '<uri::scheme::Scheme as std::str::FromStr>::from_str': ['from_str', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::str::FromStr'], '<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from': ['from', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::convert::From'], '<version::Version as std::default::Default>::default': ['default', 'Real(LocalPath("src/version.rs"))', 'std::default::Default'], '<version::Version as std::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/version.rs"))', 'std::fmt::Debug'], 'byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from': ['from', 'Real(LocalPath("src/byte_str.rs"))', 'std::convert::From'], 'byte_str::ByteStr::from_static': ['from_static', 'Real(LocalPath("src/byte_str.rs"))', ''], 'byte_str::ByteStr::from_utf8': ['from_utf8', 'Real(LocalPath("src/byte_str.rs"))', ''], 'byte_str::ByteStr::from_utf8_unchecked': ['from_utf8_unchecked', 'Real(LocalPath("src/byte_str.rs"))', ''], 'byte_str::ByteStr::new': ['new', 'Real(LocalPath("src/byte_str.rs"))', ''], 'error::Error::get_ref': ['get_ref', 'Real(LocalPath("src/error.rs"))', ''], 'error::Error::is': ['is', 'Real(LocalPath("src/error.rs"))', ''], "extensions::<impl std::clone::Clone for std::boxed::Box<(dyn extensions::AnyClone + std::marker::Send + std::marker::Sync + 'static)>>::clone": ['clone', 'Real(LocalPath("src/extensions.rs"))', 'std::clone::Clone'], 'extensions::Extensions::clear': ['clear', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::extend': ['extend', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::get': ['get', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::get_mut': ['get_mut', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::get_or_insert': ['get_or_insert', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::get_or_insert_default': ['get_or_insert_default', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::get_or_insert_with': ['get_or_insert_with', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::insert': ['insert', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::is_empty': ['is_empty', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::len': ['len', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::new': ['new', 'Real(LocalPath("src/extensions.rs"))', ''], 'extensions::Extensions::remove': ['remove', 'Real(LocalPath("src/extensions.rs"))', ''], 'header::map::Danger::is_red': ['is_red', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::Danger::is_yellow': ['is_yellow', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::Danger::set_green': ['set_green', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::Danger::set_red': ['set_red', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::Danger::set_yellow': ['set_yellow', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::Entry::<'a, T>::key": ['key', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::Entry::<'a, T>::or_insert": ['or_insert', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::Entry::<'a, T>::or_insert_with": ['or_insert_with', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::Entry::<'a, T>::or_try_insert": ['or_try_insert', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::Entry::<'a, T>::or_try_insert_with": ['or_try_insert_with', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::GetAll::<'a, T>::iter": ['iter', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::append': ['append', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::capacity': ['capacity', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::clear': ['clear', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::contains_key': ['contains_key', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::drain': ['drain', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::entry': ['entry', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::find': ['find', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::get': ['get', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::get2': ['get2', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::get_all': ['get_all', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::get_mut': ['get_mut', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::insert': ['insert', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::insert_occupied': ['insert_occupied', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::insert_occupied_mult': ['insert_occupied_mult', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::is_empty': ['is_empty', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::iter': ['iter', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::iter_mut': ['iter_mut', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::keys': ['keys', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::keys_len': ['keys_len', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::len': ['len', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::raw_links': ['raw_links', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::rebuild': ['rebuild', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::reinsert_entry_in_order': ['reinsert_entry_in_order', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::remove': ['remove', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::remove_all_extra_values': ['remove_all_extra_values', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::remove_extra_value': ['remove_extra_value', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::remove_found': ['remove_found', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::reserve': ['reserve', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_append': ['try_append', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_append2': ['try_append2', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_entry': ['try_entry', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_entry2': ['try_entry2', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_grow': ['try_grow', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_insert': ['try_insert', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_insert2': ['try_insert2', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_insert_entry': ['try_insert_entry', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_insert_phase_two': ['try_insert_phase_two', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_reserve': ['try_reserve', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_reserve_one': ['try_reserve_one', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::try_with_capacity': ['try_with_capacity', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::value_iter': ['value_iter', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::value_iter_mut': ['value_iter_mut', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::values': ['values', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::values_mut': ['values_mut', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::<T>::with_capacity': ['with_capacity', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::HeaderMap::new': ['new', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::IterMut::<'a, T>::next_unsafe": ['next_unsafe', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::MaxSizeReached::new': ['new', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::append": ['append', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::get": ['get', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::get_mut": ['get_mut', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::insert": ['insert', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::insert_mult": ['insert_mult', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::into_mut": ['into_mut', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::iter": ['iter', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::iter_mut": ['iter_mut', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::key": ['key', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::remove": ['remove', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::remove_entry": ['remove_entry', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::OccupiedEntry::<'a, T>::remove_entry_mult": ['remove_entry_mult', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::Pos::is_none': ['is_none', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::Pos::is_some': ['is_some', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::Pos::new': ['new', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::Pos::none': ['none', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::Pos::resolve': ['resolve', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::VacantEntry::<'a, T>::insert": ['insert', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::VacantEntry::<'a, T>::insert_entry": ['insert_entry', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::VacantEntry::<'a, T>::into_key": ['into_key', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::VacantEntry::<'a, T>::key": ['key', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::VacantEntry::<'a, T>::try_insert": ['try_insert', 'Real(LocalPath("src/header/map.rs"))', ''], "header::map::VacantEntry::<'a, T>::try_insert_entry": ['try_insert_entry', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::append_value': ['append_value', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::desired_pos': ['desired_pos', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::do_insert_phase_two': ['do_insert_phase_two', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::drain_all_extra_values': ['drain_all_extra_values', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::hash_elem_using': ['hash_elem_using', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::probe_distance': ['probe_distance', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::remove_extra_value': ['remove_extra_value', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::to_raw_capacity': ['to_raw_capacity', 'Real(LocalPath("src/header/map.rs"))', ''], 'header::map::usable_capacity': ['usable_capacity', 'Real(LocalPath("src/header/map.rs"))', ''], "header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq": ['eq', 'Real(LocalPath("src/header/name.rs"))', 'std::cmp::PartialEq'], 'header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq': ['eq', 'Real(LocalPath("src/header/name.rs"))', 'std::cmp::PartialEq'], 'header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from': ['from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::From'], 'header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from': ['from', 'Real(LocalPath("src/header/name.rs"))', 'std::convert::From'], "header::name::HdrName::<'a>::custom": ['custom', 'Real(LocalPath("src/header/name.rs"))', ''], "header::name::HdrName::<'a>::from_bytes": ['from_bytes', 'Real(LocalPath("src/header/name.rs"))', ''], "header::name::HdrName::<'a>::from_static": ['from_static', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::HeaderName::as_str': ['as_str', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::HeaderName::from_bytes': ['from_bytes', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::HeaderName::from_lowercase': ['from_lowercase', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::HeaderName::from_static': ['from_static', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::HeaderName::into_bytes': ['into_bytes', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::InvalidHeaderName::new': ['new', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::StandardHeader::as_str': ['as_str', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::StandardHeader::from_bytes': ['from_bytes', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::eq_ignore_ascii_case': ['eq_ignore_ascii_case', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::parse_hdr': ['parse_hdr', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::slice_assume_init': ['slice_assume_init', 'Real(LocalPath("src/header/name.rs"))', ''], 'header::name::uninit_u8_array': ['uninit_u8_array', 'Real(LocalPath("src/header/name.rs"))', ''], "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq": ['eq', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialEq'], 'header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq': ['eq', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialEq'], 'header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq': ['eq', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialEq'], 'header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq': ['eq', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialEq'], "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp": ['partial_cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialOrd'], 'header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialOrd'], 'header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialOrd'], 'header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/header/value.rs"))', 'std::cmp::PartialOrd'], 'header::value::HeaderValue::as_bytes': ['as_bytes', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::from_bytes': ['from_bytes', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::from_maybe_shared': ['from_maybe_shared', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::from_maybe_shared_unchecked': ['from_maybe_shared_unchecked', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::from_name': ['from_name', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::from_shared': ['from_shared', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::from_static': ['from_static', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::from_str': ['from_str', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::is_empty': ['is_empty', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::is_sensitive': ['is_sensitive', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::len': ['len', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::set_sensitive': ['set_sensitive', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::to_str': ['to_str', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::HeaderValue::try_from_generic': ['try_from_generic', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::is_valid': ['is_valid', 'Real(LocalPath("src/header/value.rs"))', ''], 'header::value::is_visible_ascii': ['is_visible_ascii', 'Real(LocalPath("src/header/value.rs"))', ''], "method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq": ['eq', 'Real(LocalPath("src/method.rs"))', 'std::cmp::PartialEq'], 'method::<impl std::cmp::PartialEq<method::Method> for str>::eq': ['eq', 'Real(LocalPath("src/method.rs"))', 'std::cmp::PartialEq'], 'method::InvalidMethod::new': ['new', 'Real(LocalPath("src/method.rs"))', ''], 'method::Method::as_str': ['as_str', 'Real(LocalPath("src/method.rs"))', ''], 'method::Method::extension_inline': ['extension_inline', 'Real(LocalPath("src/method.rs"))', ''], 'method::Method::from_bytes': ['from_bytes', 'Real(LocalPath("src/method.rs"))', ''], 'method::Method::is_idempotent': ['is_idempotent', 'Real(LocalPath("src/method.rs"))', ''], 'method::Method::is_safe': ['is_safe', 'Real(LocalPath("src/method.rs"))', ''], 'method::extension::AllocatedExtension::as_str': ['as_str', 'Real(LocalPath("src/method.rs"))', ''], 'method::extension::AllocatedExtension::new': ['new', 'Real(LocalPath("src/method.rs"))', ''], 'method::extension::InlineExtension::as_str': ['as_str', 'Real(LocalPath("src/method.rs"))', ''], 'method::extension::InlineExtension::new': ['new', 'Real(LocalPath("src/method.rs"))', ''], 'method::extension::write_checked': ['write_checked', 'Real(LocalPath("src/method.rs"))', ''], 'request::Builder::and_then': ['and_then', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::body': ['body', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::extension': ['extension', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::extensions_mut': ['extensions_mut', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::extensions_ref': ['extensions_ref', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::header': ['header', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::headers_mut': ['headers_mut', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::headers_ref': ['headers_ref', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::method': ['method', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::method_ref': ['method_ref', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::new': ['new', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::uri': ['uri', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::uri_ref': ['uri_ref', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::version': ['version', 'Real(LocalPath("src/request.rs"))', ''], 'request::Builder::version_ref': ['version_ref', 'Real(LocalPath("src/request.rs"))', ''], 'request::Parts::new': ['new', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<()>::builder': ['builder', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<()>::connect': ['connect', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<()>::delete': ['delete', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<()>::get': ['get', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<()>::head': ['head', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<()>::options': ['options', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<()>::patch': ['patch', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<()>::post': ['post', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<()>::put': ['put', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<()>::trace': ['trace', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::body': ['body', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::body_mut': ['body_mut', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::extensions': ['extensions', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::extensions_mut': ['extensions_mut', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::from_parts': ['from_parts', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::headers': ['headers', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::headers_mut': ['headers_mut', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::into_body': ['into_body', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::into_parts': ['into_parts', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::map': ['map', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::method': ['method', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::method_mut': ['method_mut', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::new': ['new', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::uri': ['uri', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::uri_mut': ['uri_mut', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::version': ['version', 'Real(LocalPath("src/request.rs"))', ''], 'request::Request::<T>::version_mut': ['version_mut', 'Real(LocalPath("src/request.rs"))', ''], 'response::Builder::and_then': ['and_then', 'Real(LocalPath("src/response.rs"))', ''], 'response::Builder::body': ['body', 'Real(LocalPath("src/response.rs"))', ''], 'response::Builder::extension': ['extension', 'Real(LocalPath("src/response.rs"))', ''], 'response::Builder::extensions_mut': ['extensions_mut', 'Real(LocalPath("src/response.rs"))', ''], 'response::Builder::extensions_ref': ['extensions_ref', 'Real(LocalPath("src/response.rs"))', ''], 'response::Builder::header': ['header', 'Real(LocalPath("src/response.rs"))', ''], 'response::Builder::headers_mut': ['headers_mut', 'Real(LocalPath("src/response.rs"))', ''], 'response::Builder::headers_ref': ['headers_ref', 'Real(LocalPath("src/response.rs"))', ''], 'response::Builder::new': ['new', 'Real(LocalPath("src/response.rs"))', ''], 'response::Builder::status': ['status', 'Real(LocalPath("src/response.rs"))', ''], 'response::Builder::version': ['version', 'Real(LocalPath("src/response.rs"))', ''], 'response::Parts::new': ['new', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<()>::builder': ['builder', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::body': ['body', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::body_mut': ['body_mut', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::extensions': ['extensions', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::extensions_mut': ['extensions_mut', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::from_parts': ['from_parts', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::headers': ['headers', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::headers_mut': ['headers_mut', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::into_body': ['into_body', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::into_parts': ['into_parts', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::map': ['map', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::new': ['new', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::status': ['status', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::status_mut': ['status_mut', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::version': ['version', 'Real(LocalPath("src/response.rs"))', ''], 'response::Response::<T>::version_mut': ['version_mut', 'Real(LocalPath("src/response.rs"))', ''], 'status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq': ['eq', 'Real(LocalPath("src/status.rs"))', 'std::cmp::PartialEq'], 'status::<impl std::convert::From<status::StatusCode> for u16>::from': ['from', 'Real(LocalPath("src/status.rs"))', 'std::convert::From'], 'status::InvalidStatusCode::new': ['new', 'Real(LocalPath("src/status.rs"))', ''], 'status::StatusCode::as_str': ['as_str', 'Real(LocalPath("src/status.rs"))', ''], 'status::StatusCode::as_u16': ['as_u16', 'Real(LocalPath("src/status.rs"))', ''], 'status::StatusCode::canonical_reason': ['canonical_reason', 'Real(LocalPath("src/status.rs"))', ''], 'status::StatusCode::from_bytes': ['from_bytes', 'Real(LocalPath("src/status.rs"))', ''], 'status::StatusCode::from_u16': ['from_u16', 'Real(LocalPath("src/status.rs"))', ''], 'status::StatusCode::is_client_error': ['is_client_error', 'Real(LocalPath("src/status.rs"))', ''], 'status::StatusCode::is_informational': ['is_informational', 'Real(LocalPath("src/status.rs"))', ''], 'status::StatusCode::is_redirection': ['is_redirection', 'Real(LocalPath("src/status.rs"))', ''], 'status::StatusCode::is_server_error': ['is_server_error', 'Real(LocalPath("src/status.rs"))', ''], 'status::StatusCode::is_success': ['is_success', 'Real(LocalPath("src/status.rs"))', ''], 'status::canonical_reason': ['canonical_reason', 'Real(LocalPath("src/status.rs"))', ''], "uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq": ['eq', 'Real(LocalPath("src/uri/mod.rs"))', 'std::cmp::PartialEq'], 'uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq': ['eq', 'Real(LocalPath("src/uri/mod.rs"))', 'std::cmp::PartialEq'], 'uri::InvalidUri::s': ['s', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::authority': ['authority', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::builder': ['builder', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::from_maybe_shared': ['from_maybe_shared', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::from_parts': ['from_parts', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::from_shared': ['from_shared', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::from_static': ['from_static', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::has_path': ['has_path', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::host': ['host', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::into_parts': ['into_parts', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::path': ['path', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::path_and_query': ['path_and_query', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::port': ['port', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::port_u16': ['port_u16', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::query': ['query', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::scheme': ['scheme', 'Real(LocalPath("src/uri/mod.rs"))', ''], 'uri::Uri::scheme_str': ['scheme_str', 'Real(LocalPath("src/uri/mod.rs"))', ''], "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq": ['eq', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialEq'], 'uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq': ['eq', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialEq'], 'uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq': ['eq', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialEq'], "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp": ['partial_cmp', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialOrd'], 'uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialOrd'], 'uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/uri/authority.rs"))', 'std::cmp::PartialOrd'], 'uri::authority::Authority::as_str': ['as_str', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::Authority::empty': ['empty', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::Authority::from_maybe_shared': ['from_maybe_shared', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::Authority::from_shared': ['from_shared', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::Authority::from_static': ['from_static', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::Authority::host': ['host', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::Authority::parse': ['parse', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::Authority::parse_non_empty': ['parse_non_empty', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::Authority::port': ['port', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::Authority::port_u16': ['port_u16', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::create_authority': ['create_authority', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::authority::host': ['host', 'Real(LocalPath("src/uri/authority.rs"))', ''], 'uri::builder::Builder::authority': ['authority', 'Real(LocalPath("src/uri/builder.rs"))', ''], 'uri::builder::Builder::build': ['build', 'Real(LocalPath("src/uri/builder.rs"))', ''], 'uri::builder::Builder::map': ['map', 'Real(LocalPath("src/uri/builder.rs"))', ''], 'uri::builder::Builder::new': ['new', 'Real(LocalPath("src/uri/builder.rs"))', ''], 'uri::builder::Builder::path_and_query': ['path_and_query', 'Real(LocalPath("src/uri/builder.rs"))', ''], 'uri::builder::Builder::scheme': ['scheme', 'Real(LocalPath("src/uri/builder.rs"))', ''], 'uri::parse_full': ['parse_full', 'Real(LocalPath("src/uri/mod.rs"))', ''], "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq": ['eq', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialEq'], 'uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq': ['eq', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialEq'], 'uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq': ['eq', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialEq'], "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp": ['partial_cmp', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialOrd'], 'uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialOrd'], 'uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp': ['partial_cmp', 'Real(LocalPath("src/uri/path.rs"))', 'std::cmp::PartialOrd'], 'uri::path::PathAndQuery::as_str': ['as_str', 'Real(LocalPath("src/uri/path.rs"))', ''], 'uri::path::PathAndQuery::empty': ['empty', 'Real(LocalPath("src/uri/path.rs"))', ''], 'uri::path::PathAndQuery::from_maybe_shared': ['from_maybe_shared', 'Real(LocalPath("src/uri/path.rs"))', ''], 'uri::path::PathAndQuery::from_shared': ['from_shared', 'Real(LocalPath("src/uri/path.rs"))', ''], 'uri::path::PathAndQuery::from_static': ['from_static', 'Real(LocalPath("src/uri/path.rs"))', ''], 'uri::path::PathAndQuery::path': ['path', 'Real(LocalPath("src/uri/path.rs"))', ''], 'uri::path::PathAndQuery::query': ['query', 'Real(LocalPath("src/uri/path.rs"))', ''], 'uri::path::PathAndQuery::slash': ['slash', 'Real(LocalPath("src/uri/path.rs"))', ''], 'uri::path::PathAndQuery::star': ['star', 'Real(LocalPath("src/uri/path.rs"))', ''], 'uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq': ['eq', 'Real(LocalPath("src/uri/port.rs"))', 'std::cmp::PartialEq'], 'uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from': ['from', 'Real(LocalPath("src/uri/port.rs"))', 'std::convert::From'], 'uri::port::Port::<T>::as_str': ['as_str', 'Real(LocalPath("src/uri/port.rs"))', ''], 'uri::port::Port::<T>::as_u16': ['as_u16', 'Real(LocalPath("src/uri/port.rs"))', ''], 'uri::port::Port::<T>::from_str': ['from_str', 'Real(LocalPath("src/uri/port.rs"))', ''], 'uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq': ['eq', 'Real(LocalPath("src/uri/scheme.rs"))', 'std::cmp::PartialEq'], 'uri::scheme::Protocol::len': ['len', 'Real(LocalPath("src/uri/scheme.rs"))', ''], 'uri::scheme::Scheme2::<T>::is_none': ['is_none', 'Real(LocalPath("src/uri/scheme.rs"))', ''], 'uri::scheme::Scheme2::<usize>::parse': ['parse', 'Real(LocalPath("src/uri/scheme.rs"))', ''], 'uri::scheme::Scheme2::<usize>::parse_exact': ['parse_exact', 'Real(LocalPath("src/uri/scheme.rs"))', ''], 'uri::scheme::Scheme::as_str': ['as_str', 'Real(LocalPath("src/uri/scheme.rs"))', ''], 'uri::scheme::Scheme::empty': ['empty', 'Real(LocalPath("src/uri/scheme.rs"))', '']}, 'trait_to_struct': {'extensions::AnyClone': ['<T as extensions::AnyClone>::T'], 'header::map::as_header_name::AsHeaderName': ['header::name::HeaderName', 'std::string::String'], 'header::map::as_header_name::Sealed': ['header::name::HeaderName', 'std::string::String'], 'header::map::into_header_name::IntoHeaderName': ['header::name::HeaderName'], 'header::map::into_header_name::Sealed': ['header::name::HeaderName'], 'std::borrow::Borrow': ['header::name::HeaderName'], 'std::clone::Clone': ['byte_str::ByteStr', 'extensions::Extensions', 'header::map::Bucket', 'header::map::Cursor', 'header::map::Danger', 'header::map::ExtraValue', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::Link', 'header::map::Links', 'header::map::Pos', 'header::map::RawLinks', 'header::name::Custom', 'header::name::HeaderName', 'header::name::MaybeLower', 'header::name::Repr', 'header::name::StandardHeader', 'header::value::HeaderValue', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'request::Parts', 'request::Request', 'response::Parts', 'response::Response', 'status::StatusCode', 'std::boxed::Box', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Http', 'version::Version'], 'std::cmp::Eq': ['byte_str::ByteStr', 'header::map::Cursor', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::Link', 'header::name::Custom', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'header::value::HeaderValue', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'status::StatusCode', 'uri::ErrorKind', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Scheme', 'version::Http', 'version::Version'], 'std::cmp::Ord': ['byte_str::ByteStr', 'header::value::HeaderValue', 'status::StatusCode', 'version::Http', 'version::Version'], 'std::cmp::PartialEq': ['byte_str::ByteStr', 'header::map::Cursor', 'header::map::GetAll', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::Link', 'header::name::Custom', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'header::value::HeaderValue', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'status::StatusCode', 'std::string::String', 'uri::ErrorKind', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::port::Port', 'uri::scheme::Scheme', 'version::Http', 'version::Version'], 'std::cmp::PartialOrd': ['byte_str::ByteStr', 'header::value::HeaderValue', 'status::StatusCode', 'std::string::String', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'version::Http', 'version::Version'], 'std::convert::AsRef': ['header::name::HeaderName', 'header::value::HeaderValue', 'method::Method', 'uri::authority::Authority', 'uri::port::Port', 'uri::scheme::Scheme'], 'std::convert::From': ['byte_str::ByteStr', 'bytes::Bytes', 'error::Error', 'header::map::as_header_name::TryEntryError', 'header::name::HdrName', 'header::name::HeaderName', 'header::value::HeaderValue', 'method::Method', 'status::StatusCode', 'uri::InvalidUri', 'uri::InvalidUriParts', 'uri::Parts', 'uri::Uri', 'uri::builder::Builder', 'uri::scheme::Scheme', 'uri::scheme::Scheme2'], 'std::convert::TryFrom': ['header::map::HeaderMap', 'header::name::HeaderName', 'header::value::HeaderValue', 'method::Method', 'status::StatusCode', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Scheme'], 'std::default::Default': ['extensions::Extensions', 'extensions::IdHasher', 'header::map::HeaderMap', 'method::Method', 'request::Builder', 'request::Request', 'response::Builder', 'response::Response', 'status::StatusCode', 'uri::Parts', 'uri::Uri', 'uri::builder::Builder', 'version::Version'], 'std::error::Error': ['error::Error', 'header::map::MaxSizeReached', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'header::value::ToStrError', 'method::InvalidMethod', 'status::InvalidStatusCode', 'uri::InvalidUri', 'uri::InvalidUriParts'], 'std::fmt::Debug': ['byte_str::ByteStr', 'error::Error', 'extensions::Extensions', 'header::map::Bucket', 'header::map::Cursor', 'header::map::Drain', 'header::map::Entry', 'header::map::ExtraValue', 'header::map::GetAll', 'header::map::HashValue', 'header::map::HeaderMap', 'header::map::IntoIter', 'header::map::Iter', 'header::map::IterMut', 'header::map::Keys', 'header::map::Link', 'header::map::Links', 'header::map::MaxSizeReached', 'header::map::OccupiedEntry', 'header::map::RawLinks', 'header::map::VacantEntry', 'header::map::ValueDrain', 'header::map::ValueIter', 'header::map::ValueIterMut', 'header::map::Values', 'header::map::ValuesMut', 'header::name::Custom', 'header::name::HdrName', 'header::name::HeaderName', 'header::name::InvalidHeaderName', 'header::name::MaybeLower', 'header::name::Repr', 'header::name::StandardHeader', 'header::value::HeaderValue', 'header::value::InvalidHeaderValue', 'header::value::ToStrError', 'method::InvalidMethod', 'method::Method', 'request::Builder', 'request::Parts', 'request::Request', 'response::Builder', 'response::Parts', 'response::Response', 'status::InvalidStatusCode', 'status::StatusCode', 'uri::ErrorKind', 'uri::InvalidUri', 'uri::InvalidUriParts', 'uri::Parts', 'uri::Uri', 'uri::authority::Authority', 'uri::builder::Builder', 'uri::path::PathAndQuery', 'uri::port::Port', 'uri::scheme::Protocol', 'uri::scheme::Scheme', 'uri::scheme::Scheme2', 'version::Version'], 'std::fmt::Display': ['error::Error', 'header::map::MaxSizeReached', 'header::name::HeaderName', 'header::name::InvalidHeaderName', 'header::value::InvalidHeaderValue', 'header::value::ToStrError', 'method::InvalidMethod', 'method::Method', 'status::InvalidStatusCode', 'status::StatusCode', 'uri::InvalidUri', 'uri::InvalidUriParts', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::port::Port', 'uri::scheme::Scheme'], 'std::hash::Hash': ['byte_str::ByteStr', 'header::name::Custom', 'header::name::HdrName', 'header::name::HeaderName', 'header::name::MaybeLower', 'header::name::Repr', 'header::name::StandardHeader', 'header::value::HeaderValue', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'status::StatusCode', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Scheme', 'version::Http', 'version::Version'], 'std::hash::Hasher': ['extensions::IdHasher'], 'std::iter::DoubleEndedIterator': ['header::map::ValueIter', 'header::map::ValueIterMut'], 'std::iter::ExactSizeIterator': ['header::map::Keys'], 'std::iter::Extend': ['header::map::HeaderMap'], 'std::iter::FromIterator': ['header::map::HeaderMap'], 'std::iter::FusedIterator': ['header::map::Drain', 'header::map::IntoIter', 'header::map::Iter', 'header::map::IterMut', 'header::map::Keys', 'header::map::ValueDrain', 'header::map::ValueIter', 'header::map::ValueIterMut', 'header::map::Values', 'header::map::ValuesMut'], 'std::iter::IntoIterator': ['header::map::GetAll', 'header::map::HeaderMap', 'header::map::OccupiedEntry'], 'std::iter::Iterator': ['header::map::Drain', 'header::map::IntoIter', 'header::map::Iter', 'header::map::IterMut', 'header::map::Keys', 'header::map::ValueDrain', 'header::map::ValueIter', 'header::map::ValueIterMut', 'header::map::Values', 'header::map::ValuesMut'], 'std::marker::Copy': ['header::map::Cursor', 'header::map::HashValue', 'header::map::Link', 'header::map::Links', 'header::map::Pos', 'header::map::RawLinks', 'header::name::StandardHeader', 'status::StatusCode', 'uri::scheme::Protocol', 'version::Http', 'version::Version'], 'std::marker::Send': ['header::map::Drain', 'header::map::Iter', 'header::map::IterMut', 'header::map::ValueDrain', 'header::map::ValueIterMut'], 'std::marker::StructuralPartialEq': ['byte_str::ByteStr', 'header::map::Cursor', 'header::map::HashValue', 'header::map::Link', 'header::name::Custom', 'header::name::HeaderName', 'header::name::Repr', 'header::name::StandardHeader', 'method::Inner', 'method::Method', 'method::extension::AllocatedExtension', 'method::extension::InlineExtension', 'status::StatusCode', 'uri::ErrorKind', 'version::Http', 'version::Version'], 'std::marker::Sync': ['header::map::Drain', 'header::map::Iter', 'header::map::IterMut', 'header::map::ValueDrain', 'header::map::ValueIterMut'], 'std::ops::Deref': ['byte_str::ByteStr'], 'std::ops::Drop': ['header::map::Drain', 'header::map::IntoIter', 'header::map::ValueDrain'], 'std::ops::Index': ['header::map::HeaderMap', 'header::map::RawLinks'], 'std::ops::IndexMut': ['header::map::RawLinks'], 'std::str::FromStr': ['header::name::HeaderName', 'header::value::HeaderValue', 'method::Method', 'status::StatusCode', 'uri::Uri', 'uri::authority::Authority', 'uri::path::PathAndQuery', 'uri::scheme::Scheme']}, 'type_to_def_path': {'byte_str::ByteStr': 'byte_str::ByteStr', 'error::Error': 'error::Error', 'error::ErrorKind': 'error::ErrorKind', 'extensions::Extensions': 'extensions::Extensions', 'extensions::IdHasher': 'extensions::IdHasher', 'header::map::Bucket<T>': 'header::map::Bucket', 'header::map::Cursor': 'header::map::Cursor', 'header::map::Danger': 'header::map::Danger', "header::map::Drain<'a, T>": 'header::map::Drain', "header::map::Entry<'a, T>": 'header::map::Entry', 'header::map::ExtraValue<T>': 'header::map::ExtraValue', "header::map::GetAll<'a, T>": 'header::map::GetAll', 'header::map::HashValue': 'header::map::HashValue', 'header::map::HeaderMap<T>': 'header::map::HeaderMap', 'header::map::IntoIter<T>': 'header::map::IntoIter', "header::map::Iter<'a, T>": 'header::map::Iter', "header::map::IterMut<'a, T>": 'header::map::IterMut', "header::map::Keys<'a, T>": 'header::map::Keys', 'header::map::Link': 'header::map::Link', 'header::map::Links': 'header::map::Links', 'header::map::MaxSizeReached': 'header::map::MaxSizeReached', "header::map::OccupiedEntry<'a, T>": 'header::map::OccupiedEntry', 'header::map::Pos': 'header::map::Pos', 'header::map::RawLinks<T>': 'header::map::RawLinks', "header::map::VacantEntry<'a, T>": 'header::map::VacantEntry', "header::map::ValueDrain<'a, T>": 'header::map::ValueDrain', "header::map::ValueIter<'a, T>": 'header::map::ValueIter', "header::map::ValueIterMut<'a, T>": 'header::map::ValueIterMut', "header::map::Values<'a, T>": 'header::map::Values', "header::map::ValuesMut<'a, T>": 'header::map::ValuesMut', 'header::map::as_header_name::TryEntryError': 'header::map::as_header_name::TryEntryError', 'header::name::Custom': 'header::name::Custom', "header::name::HdrName<'a>": 'header::name::HdrName', 'header::name::HeaderName': 'header::name::HeaderName', 'header::name::InvalidHeaderName': 'header::name::InvalidHeaderName', "header::name::MaybeLower<'a>": 'header::name::MaybeLower', 'header::name::Repr<T>': 'header::name::Repr', 'header::name::StandardHeader': 'header::name::StandardHeader', 'header::value::HeaderValue': 'header::value::HeaderValue', 'header::value::InvalidHeaderValue': 'header::value::InvalidHeaderValue', 'header::value::ToStrError': 'header::value::ToStrError', 'method::Inner': 'method::Inner', 'method::InvalidMethod': 'method::InvalidMethod', 'method::Method': 'method::Method', 'method::extension::AllocatedExtension': 'method::extension::AllocatedExtension', 'method::extension::InlineExtension': 'method::extension::InlineExtension', 'request::Builder': 'request::Builder', 'request::Parts': 'request::Parts', 'request::Request<T>': 'request::Request', 'response::Builder': 'response::Builder', 'response::Parts': 'response::Parts', 'response::Response<T>': 'response::Response', 'status::InvalidStatusCode': 'status::InvalidStatusCode', 'status::StatusCode': 'status::StatusCode', 'uri::ErrorKind': 'uri::ErrorKind', 'uri::InvalidUri': 'uri::InvalidUri', 'uri::InvalidUriParts': 'uri::InvalidUriParts', 'uri::Parts': 'uri::Parts', 'uri::Uri': 'uri::Uri', 'uri::authority::Authority': 'uri::authority::Authority', 'uri::builder::Builder': 'uri::builder::Builder', 'uri::path::PathAndQuery': 'uri::path::PathAndQuery', 'uri::port::Port<T>': 'uri::port::Port', 'uri::scheme::Protocol': 'uri::scheme::Protocol', 'uri::scheme::Scheme': 'uri::scheme::Scheme', 'uri::scheme::Scheme2<T>': 'uri::scheme::Scheme2', 'version::Http': 'version::Http', 'version::Version': 'version::Version'}}, 'http', 'http') finished, time: 4641.086447675014s
