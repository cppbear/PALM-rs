ChatCompletion(id='chatcmpl-BclZP8sYjJ7J7En2fthhlXb1STFEE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_count_onig() {\n        let args = Args {\n            arg_pattern: "test".to_string(),\n            arg_file: "mock_file".to_string(),\n            cmd_onig: true,\n            cmd_pcre1: false,\n            cmd_pcre2: false,\n            cmd_re2: false,\n            cmd_rust: false,\n            cmd_rust_bytes: false,\n            cmd_tcl: false,\n        };\n        let haystack = "this is a test test string";\n        let result = args.count(haystack);\n        assert_eq!(result, /* expected count for onig */);\n    }\n    \n    #[test]\n    fn test_count_pcre1() {\n        let args = Args {\n            arg_pattern: "test".to_string(),\n            arg_file: "mock_file".to_string(),\n            cmd_onig: false,\n            cmd_pcre1: true,\n            cmd_pcre2: false,\n            cmd_re2: false,\n            cmd_rust: false,\n            cmd_rust_bytes: false,\n            cmd_tcl: false,\n        };\n        let haystack = "this is a test test string";\n        let result = args.count(haystack);\n        assert_eq!(result, /* expected count for pcre1 */);\n    }\n    \n    #[test]\n    fn test_count_pcre2() {\n        let args = Args {\n            arg_pattern: "test".to_string(),\n            arg_file: "mock_file".to_string(),\n            cmd_onig: false,\n            cmd_pcre1: false,\n            cmd_pcre2: true,\n            cmd_re2: false,\n            cmd_rust: false,\n            cmd_rust_bytes: false,\n            cmd_tcl: false,\n        };\n        let haystack = "this is a test test string";\n        let result = args.count(haystack);\n        assert_eq!(result, /* expected count for pcre2 */);\n    }\n    \n    #[test]\n    fn test_count_re2() {\n        let args = Args {\n            arg_pattern: "test".to_string(),\n            arg_file: "mock_file".to_string(),\n            cmd_onig: false,\n            cmd_pcre1: false,\n            cmd_pcre2: false,\n            cmd_re2: true,\n            cmd_rust: false,\n            cmd_rust_bytes: false,\n            cmd_tcl: false,\n        };\n        let haystack = "this is a test test string";\n        let result = args.count(haystack);\n        assert_eq!(result, /* expected count for re2 */);\n    }\n    \n    #[test]\n    fn test_count_rust() {\n        let args = Args {\n            arg_pattern: "test".to_string(),\n            arg_file: "mock_file".to_string(),\n            cmd_onig: false,\n            cmd_pcre1: false,\n            cmd_pcre2: false,\n            cmd_re2: false,\n            cmd_rust: true,\n            cmd_rust_bytes: false,\n            cmd_tcl: false,\n        };\n        let haystack = "this is a test test string";\n        let result = args.count(haystack);\n        assert_eq!(result, /* expected count for rust */);\n    }\n    \n    #[test]\n    fn test_count_rust_bytes() {\n        let args = Args {\n            arg_pattern: "test".to_string(),\n            arg_file: "mock_file".to_string(),\n            cmd_onig: false,\n            cmd_pcre1: false,\n            cmd_pcre2: false,\n            cmd_re2: false,\n            cmd_rust: false,\n            cmd_rust_bytes: true,\n            cmd_tcl: false,\n        };\n        let haystack = "this is a test test string";\n        let result = args.count(haystack);\n        assert_eq!(result, /* expected count for rust_bytes */);\n    }\n    \n    #[test]\n    fn test_count_tcl() {\n        let args = Args {\n            arg_pattern: "test".to_string(),\n            arg_file: "mock_file".to_string(),\n            cmd_onig: false,\n            cmd_pcre1: false,\n            cmd_pcre2: false,\n            cmd_re2: false,\n            cmd_rust: false,\n            cmd_rust_bytes: false,\n            cmd_tcl: true,\n        };\n        let haystack = "this is a test test string";\n        let result = args.count(haystack);\n        assert_eq!(result, /* expected count for tcl */);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579023, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=951, prompt_tokens=589, total_tokens=1540, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZimTXS5FI0cN7NEr8o9DruzHnA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[cfg(feature = "your_feature")] // replace with the actual feature\n    fn test_count_onig() {\n        let pattern = "test";\n        let haystack = "this is a test string to test the pattern test";\n        let expected_count = 3; // expected number of matches\n\n        let result = count_onig(pattern, haystack);\n        assert_eq!(result, expected_count);\n    }\n\n    #[test]\n    #[cfg(not(feature = "your_feature"))] // replace with the actual feature\n    fn test_count_onig_disabled() {\n        let pattern = "test";\n        let haystack = "this is a test string to test the pattern test";\n\n        let result = std::panic::catch_unwind(|| {\n            count_onig(pattern, haystack);\n        });\n\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579042, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=193, prompt_tokens=185, total_tokens=378, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZnN3nQYY07ThjVU5kV7O22dCrY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic(expected = "Support not enabled. Re-compile with \'--features")]\n    fn test_count_pcre1_panic() {\n        let pattern = "test";\n        let haystack = "this is a test string";\n        count_pcre1(pattern, haystack);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579047, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=81, prompt_tokens=187, total_tokens=268, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZqXDgmbBoWgs2uMABfkxlh5K6F', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic(expected = "Support not enabled. Re-compile with \'--features")]\n    fn test_count_pcre2_not_enabled() {\n        count_pcre2("pattern", "haystack");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579050, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=64, prompt_tokens=187, total_tokens=251, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZupYJsKj3uPlLRSTlzsXOz3hes', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[cfg(feature = "your_feature_here")] // Replace with the actual feature name\n    fn test_count_re2() {\n        let pat = "your_pattern_here"; // Replace with a valid pattern\n        let haystack = "your_haystack_here"; // Replace with a valid haystack\n        let result = count_re2(pat, haystack);\n        // Add assertions based on expected results\n        assert_eq!(result, expected_count); // Replace with the expected count\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579054, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=122, prompt_tokens=185, total_tokens=307, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZxTKnvaqdQvmjhSAKUIte9a7nc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic(expected = "Support not enabled. Re-compile with \'--features")]\n    fn test_count_rust_panics_when_feature_disabled() {\n        let result = count_rust("pattern", "haystack");\n        // If the function does not panic, the test will fail.\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579057, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=82, prompt_tokens=185, total_tokens=267, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcla1zseiRMM55Mll9EiMK20naAQ6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic(expected = "Support not enabled. Re-compile with \'--features")]\n    fn test_count_rust_bytes_not_enabled() {\n        // Arrange\n        let pattern = "test";\n        let haystack = "This is a test string.";\n\n        // Act\n        let _result = count_rust_bytes(pattern, haystack);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579061, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=93, prompt_tokens=187, total_tokens=280, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcla6e7Da4M6sUgXb3QEFJPHP1KED', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[cfg(feature = "your_feature_name")] // replace with actual feature\n    fn test_count_tcl() {\n        let pattern = "test";\n        let haystack = "this is a test string with test in it";\n        let result = count_tcl(pattern, haystack);\n        assert_eq!(result, 2); // Replace 2 with expected count\n    }\n\n    #[test]\n    #[should_panic(expected = "Support not enabled.")]\n    fn test_count_tcl_without_feature() {\n        let pattern = "test";\n        let haystack = "this is a test string";\n        count_tcl(pattern, haystack);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579066, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=154, prompt_tokens=185, total_tokens=339, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaERjV7G2lnWWHiE5xRTokrMmox', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs::File;\n    use std::io::Write;\n    use std::os::unix::io::AsRawFd;\n    use memmap::Mmap;\n    use std::str;\n\n    #[test]\n    fn test_main() {\n        let test_string = "sample haystack for regex testing";\n        let test_file_path = "test_file.txt";\n        \n        // Create a test file with content\n        let mut file = File::create(test_file_path).unwrap();\n        writeln!(file, "{}", test_string).unwrap();\n        \n        // Mock the args to simulate command line input\n        let args = Args {\n            arg_file: test_file_path.to_string(),\n            // Mock other fields as necessary\n        };\n\n        // Use std::panic to handle potential panics\n        let result = std::panic::catch_unwind(|| {\n            let mmap = unsafe { Mmap::map(&File::open(&args.arg_file).unwrap()).unwrap() };\n            let haystack = unsafe { str::from_utf8_unchecked(&mmap) };\n\n            // Assuming count is a method to count occurrences of a pattern\n            let count = args.count(&haystack);\n            assert_eq!(count, 1); // Adjust the expected count as necessary\n        });\n\n        // Clean up the test file\n        std::fs::remove_file(test_file_path).unwrap();\n        \n        assert!(result.is_ok(), "main function panicked");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579074, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=317, prompt_tokens=216, total_tokens=533, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
({'dependencies': {'<Args as std::fmt::Debug>::fmt': ['Args', 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result', 'std::string::String'], "<_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Field as _::_serde::Deserialize<'de>>::deserialize": ['_::_serde::Deserializer', 'std::marker::Sized', 'std::result::Result'], "<_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor as _::_serde::de::Visitor<'de>>::expecting": ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor", 'std::fmt::Formatter', 'std::marker::Sized', 'std::result::Result'], "<_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor as _::_serde::de::Visitor<'de>>::visit_bytes": ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor", '_::_serde::de::Error', 'std::marker::Sized', 'std::result::Result'], "<_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor as _::_serde::de::Visitor<'de>>::visit_str": ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor", '_::_serde::de::Error', 'std::marker::Sized', 'std::result::Result'], "<_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor as _::_serde::de::Visitor<'de>>::visit_u64": ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor", '_::_serde::de::Error', 'std::marker::Sized', 'std::result::Result'], "<_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor<'de> as _::_serde::de::Visitor<'de>>::expecting": ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor", 'std::fmt::Formatter', 'std::marker::PhantomData', 'std::marker::Sized', 'std::result::Result'], "<_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor<'de> as _::_serde::de::Visitor<'de>>::visit_map": ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor", '_::_serde::de::MapAccess', 'std::marker::PhantomData', 'std::marker::Sized', 'std::result::Result'], "<_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor<'de> as _::_serde::de::Visitor<'de>>::visit_seq": ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor", '_::_serde::de::SeqAccess', 'std::marker::PhantomData', 'std::marker::Sized', 'std::result::Result'], 'Args': ['Args', 'std::string::String'], 'Args::count': ['Args', 'std::string::String'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize": ['_::_serde::Deserializer', 'std::marker::Sized', 'std::result::Result'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Field": ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Field"], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor": ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor"], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor": ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor", 'std::marker::PhantomData'], 'count_onig': [], 'count_pcre1': [], 'count_pcre2': [], 'count_re2': [], 'count_rust': [], 'count_rust_bytes': [], 'count_tcl': [], 'main': []}, 'glob_path_import': {}, 'self_to_fn': {'Args': ['Debug', 'impl Args {\n    fn count(&self, haystack: &str) -> usize {\n        let pat = &self.arg_pattern;\n        if self.cmd_onig {\n            count_onig(pat, haystack)\n        } else if self.cmd_pcre1 {\n            count_pcre1(pat, haystack)\n        } else if self.cmd_pcre2 {\n            count_pcre2(pat, haystack)\n        } else if self.cmd_re2 {\n            count_re2(pat, haystack)\n        } else if self.cmd_rust {\n            count_rust(pat, haystack)\n        } else if self.cmd_rust_bytes {\n            count_rust_bytes(pat, haystack)\n        } else if self.cmd_tcl {\n            count_tcl(pat, haystack)\n        } else {\n            panic!("unreachable")\n        }\n    }\n}', 'serde::Deserialize'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Field": ['serde::Deserialize'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor": ['serde::Deserialize'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor": ['serde::Deserialize']}, 'single_path_import': {}, 'srcs': {'Args': ['struct Args {\n    arg_pattern: String,\n    arg_file: String,\n    cmd_onig: bool,\n    cmd_pcre1: bool,\n    cmd_pcre2: bool,\n    cmd_re2: bool,\n    cmd_rust: bool,\n    cmd_rust_bytes: bool,\n    cmd_tcl: bool,\n}', 'Real(LocalPath("bench/src/main.rs"))'], 'Args::count': ['fn count(&self, haystack: &str) -> usize{\n        let pat = &self.arg_pattern;\n        if self.cmd_onig {\n            count_onig(pat, haystack)\n        } else if self.cmd_pcre1 {\n            count_pcre1(pat, haystack)\n        } else if self.cmd_pcre2 {\n            count_pcre2(pat, haystack)\n        } else if self.cmd_re2 {\n            count_re2(pat, haystack)\n        } else if self.cmd_rust {\n            count_rust(pat, haystack)\n        } else if self.cmd_rust_bytes {\n            count_rust_bytes(pat, haystack)\n        } else if self.cmd_tcl {\n            count_tcl(pat, haystack)\n        } else {\n            panic!("unreachable")\n        }\n    }', 'Real(LocalPath("bench/src/main.rs"))'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Field": ['serde::Deserialize\nserde::Deserialize\nserde::Deserialize', 'Real(LocalPath("bench/src/main.rs"))'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor": ['serde::Deserialize\nserde::Deserialize', 'Real(LocalPath("bench/src/main.rs"))'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor": ['serde::Deserialize\nserde::Deserialize', 'Real(LocalPath("bench/src/main.rs"))'], 'count_onig': ['#[cfg(not(feature = $feature))]\nfn $name(_pat: &str, _haystack: &str) -> usize{\n            panic!(\n                "Support not enabled. Re-compile with \'--features {}\' \\\n                 to enable.",\n                $feature\n            )\n        }', 'Real(LocalPath("bench/src/main.rs"))'], 'count_pcre1': ['#[cfg(not(feature = $feature))]\nfn $name(_pat: &str, _haystack: &str) -> usize{\n            panic!(\n                "Support not enabled. Re-compile with \'--features {}\' \\\n                 to enable.",\n                $feature\n            )\n        }', 'Real(LocalPath("bench/src/main.rs"))'], 'count_pcre2': ['#[cfg(not(feature = $feature))]\nfn $name(_pat: &str, _haystack: &str) -> usize{\n            panic!(\n                "Support not enabled. Re-compile with \'--features {}\' \\\n                 to enable.",\n                $feature\n            )\n        }', 'Real(LocalPath("bench/src/main.rs"))'], 'count_re2': ['#[cfg(not(feature = $feature))]\nfn $name(_pat: &str, _haystack: &str) -> usize{\n            panic!(\n                "Support not enabled. Re-compile with \'--features {}\' \\\n                 to enable.",\n                $feature\n            )\n        }', 'Real(LocalPath("bench/src/main.rs"))'], 'count_rust': ['#[cfg(not(feature = $feature))]\nfn $name(_pat: &str, _haystack: &str) -> usize{\n            panic!(\n                "Support not enabled. Re-compile with \'--features {}\' \\\n                 to enable.",\n                $feature\n            )\n        }', 'Real(LocalPath("bench/src/main.rs"))'], 'count_rust_bytes': ['#[cfg(not(feature = $feature))]\nfn $name(_pat: &str, _haystack: &str) -> usize{\n            panic!(\n                "Support not enabled. Re-compile with \'--features {}\' \\\n                 to enable.",\n                $feature\n            )\n        }', 'Real(LocalPath("bench/src/main.rs"))'], 'count_tcl': ['#[cfg(not(feature = $feature))]\nfn $name(_pat: &str, _haystack: &str) -> usize{\n            panic!(\n                "Support not enabled. Re-compile with \'--features {}\' \\\n                 to enable.",\n                $feature\n            )\n        }', 'Real(LocalPath("bench/src/main.rs"))'], 'main': ['fn main(){\n    let args: Args = Docopt::new(USAGE)\n        .and_then(|d| d.deserialize())\n        .unwrap_or_else(|e| e.exit());\n\n    let mmap =\n        unsafe { Mmap::map(&File::open(&args.arg_file).unwrap()).unwrap() };\n    let haystack = unsafe { str::from_utf8_unchecked(&mmap) };\n\n    println!("{}", args.count(&haystack));\n}', 'Real(LocalPath("bench/src/main.rs"))']}, 'struct_constructor': {"Alias(Projection, AliasTy { args: [_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor, 'de/#0], def_id: DefId(25:1547 ~ serde[0f17]::de::Visitor::Value) })": ['visit_bytes', 'visit_str', 'visit_u64'], "Alias(Projection, AliasTy { args: [_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor<'de/#0>, 'de/#0], def_id: DefId(25:1547 ~ serde[0f17]::de::Visitor::Value) })": ['visit_map', 'visit_seq'], 'Args': ['deserialize'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Field": ['deserialize'], 'usize': ['count', 'count_onig', 'count_pcre1', 'count_pcre2', 'count_re2', 'count_rust', 'count_rust_bytes', 'count_tcl']}, 'struct_to_trait': {'Args': ['_::_serde::Deserialize', 'std::fmt::Debug'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Field": ['_::_serde::Deserialize'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor": ['_::_serde::de::Visitor'], "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor": ['_::_serde::de::Visitor']}, 'targets': {'Args::count': ['count', 'Real(LocalPath("bench/src/main.rs"))', ''], 'count_onig': ['count_onig', 'Real(LocalPath("bench/src/main.rs"))', ''], 'count_pcre1': ['count_pcre1', 'Real(LocalPath("bench/src/main.rs"))', ''], 'count_pcre2': ['count_pcre2', 'Real(LocalPath("bench/src/main.rs"))', ''], 'count_re2': ['count_re2', 'Real(LocalPath("bench/src/main.rs"))', ''], 'count_rust': ['count_rust', 'Real(LocalPath("bench/src/main.rs"))', ''], 'count_rust_bytes': ['count_rust_bytes', 'Real(LocalPath("bench/src/main.rs"))', ''], 'count_tcl': ['count_tcl', 'Real(LocalPath("bench/src/main.rs"))', ''], 'main': ['main', 'Real(LocalPath("bench/src/main.rs"))', '']}, 'trait_to_struct': {'_::_serde::Deserialize': ['Args', "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Field"], '_::_serde::de::Visitor': ["_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor", "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor"], 'std::fmt::Debug': ['Args']}, 'type_to_def_path': {'Args': 'Args', "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Field": "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Field", "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor": "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__FieldVisitor", "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor<'de>": "_::<impl _::_serde::Deserialize<'de> for Args>::deserialize::__Visitor"}}, 'regex', 'regex-benchmark') finished, time: 61.37448415195104s
