{"<&'a map::slice::Slice<K, V> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_into_iter() {\n        let entries = [\n            Bucket {\n                hash: HashValue(1),\n                key: \"key1\",\n                value: \"value1\",\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: \"key2\",\n                value: \"value2\",\n            },\n        ];\n        let slice = Slice { entries };\n\n        let mut iter = slice.into_iter();\n        assert_eq!(iter.next().unwrap().key_ref(), &\"key1\");\n        assert_eq!(iter.next().unwrap().key_ref(), &\"key2\");\n        assert!(iter.next().is_none());\n    }\n}\n```", "<&'a mut map::slice::Slice<K, V> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_into_iter() {\n        // Preparing a Slice with 2 entries\n        let entries = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n            Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n        ];\n        let mut slice = Slice { entries };\n\n        // Using into_iter\n        let mut iter = slice.iter_mut();\n\n        // Check that we can iterate over the entries\n        assert_eq!(iter.next().map(|b| b.key_ref()), Some(&\"key1\"));\n        assert_eq!(iter.next().map(|b| b.key_ref()), Some(&\"key2\"));\n        assert_eq!(iter.next(), None); // No more entries\n    }\n}\n```", "<&'a set::slice::Slice<T> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_into_iter() {\n        let buckets = vec![\n            Bucket {\n                hash: HashValue(1),\n                key: \"key1\",\n                value: \"value1\",\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: \"key2\",\n                value: \"value2\",\n            },\n        ];\n\n        let slice = Slice { entries: buckets };\n\n        let mut iterator = slice.iter();\n        assert_eq!(iterator.next().unwrap().key_ref(), &\"key1\");\n        assert_eq!(iterator.next().unwrap().key_ref(), &\"key2\");\n        assert!(iterator.next().is_none());\n    }\n}\n```", "<&map::slice::Slice<K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_slice_default() {\n        let default_slice: &Slice<i32, i32> = Slice::new();\n        assert_eq!(default_slice.len(), 0);\n        assert!(default_slice.is_empty());\n    }\n}\n```", "<&mut map::slice::Slice<K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust depending on where your imports are\n    use crate::map::slice::Slice; // Adjust the path to your crate\n\n    #[test]\n    fn test_slice_default() {\n        let slice: Slice<i32, String> = Slice::default();\n        assert_eq!(slice.len(), 0);\n        assert!(slice.is_empty());\n    }\n}\n```", "<&set::IndexSet<T, S1> as core::ops::BitAnd<&set::IndexSet<T, S2>>>::bitand": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_bitand_intersection() {\n        let set1: IndexSet<u32> = vec![1, 2, 3].into_iter().collect();\n        let set2: IndexSet<u32> = vec![3, 4, 5].into_iter().collect();\n        let result: IndexSet<u32> = set1.bitand(&set2);\n        let expected: IndexSet<u32> = vec![3].into_iter().collect();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_bitand_empty_intersection() {\n        let set1: IndexSet<u32> = vec![1, 2, 3].into_iter().collect();\n        let set2: IndexSet<u32> = vec![4, 5, 6].into_iter().collect();\n        let result: IndexSet<u32> = set1.bitand(&set2);\n        let expected: IndexSet<u32> = IndexSet::new();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_bitand_self_intersection() {\n        let set: IndexSet<u32> = vec![1, 2, 3].into_iter().collect();\n        let result: IndexSet<u32> = set.bitand(&set);\n        let expected: IndexSet<u32> = vec![1, 2, 3].into_iter().collect();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_bitand_with_empty_set() {\n        let set1: IndexSet<u32> = vec![1, 2, 3].into_iter().collect();\n        let set2: IndexSet<u32> = IndexSet::new();\n        let result: IndexSet<u32> = set1.bitand(&set2);\n        let expected: IndexSet<u32> = IndexSet::new();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_bitand_with_different_types() {\n        let set1: IndexSet<char> = vec!['a', 'b', 'c'].into_iter().collect();\n        let set2: IndexSet<char> = vec!['b', 'c', 'd'].into_iter().collect();\n        let result: IndexSet<char> = set1.bitand(&set2);\n        let expected: IndexSet<char> = vec!['b', 'c'].into_iter().collect();\n        assert_eq!(result, expected);\n    }\n}\n```", "<&set::IndexSet<T, S1> as core::ops::BitOr<&set::IndexSet<T, S2>>>::bitor": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_bitor() {\n        let mut set1: IndexSet<i32> = IndexSet::new();\n        set1.insert(1);\n        set1.insert(2);\n        set1.insert(3);\n        \n        let mut set2: IndexSet<i32> = IndexSet::new();\n        set2.insert(3);\n        set2.insert(4);\n        set2.insert(5);\n        \n        let result = set1.bitor(&set2);\n        \n        // Check that the result is the union of the two sets\n        let expected: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3, 4, 5]);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_bitor_empty() {\n        let set1: IndexSet<i32> = IndexSet::new();\n        let set2: IndexSet<i32> = IndexSet::new();\n        \n        let result = set1.bitor(&set2);\n        \n        // Check that the result is an empty set\n        let expected: IndexSet<i32> = IndexSet::new();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_bitor_disjoint() {\n        let mut set1: IndexSet<i32> = IndexSet::new();\n        set1.insert(1);\n        set1.insert(2);\n        \n        let mut set2: IndexSet<i32> = IndexSet::new();\n        set2.insert(3);\n        set2.insert(4);\n        \n        let result = set1.bitor(&set2);\n        \n        // Check that the result is the union of the two sets\n        let expected: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3, 4]);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_bitor_with_duplicates() {\n        let mut set1: IndexSet<i32> = IndexSet::new();\n        set1.insert(1);\n        set1.insert(2);\n        set1.insert(3);\n        \n        let mut set2: IndexSet<i32> = IndexSet::new();\n        set2.insert(3);\n        set2.insert(2);  // Duplicate\n        set2.insert(4);\n        \n        let result = set1.bitor(&set2);\n        \n        // Check that the result is the union of the two sets\n        let expected: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3, 4]);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_bitor_order() {\n        let mut set1: IndexSet<i32> = IndexSet::new();\n        set1.insert(1);\n        set1.insert(3);\n        \n        let mut set2: IndexSet<i32> = IndexSet::new();\n        set2.insert(2);\n        set2.insert(3);  // Overlap\n        \n        let result = set1.bitor(&set2);\n        \n        // Check that the order is preserved\n        let expected: IndexSet<i32> = IndexSet::from_iter(vec![1, 3, 2]);\n        assert_eq!(result, expected);\n    }\n}\n```", "<&set::IndexSet<T, S1> as core::ops::BitXor<&set::IndexSet<T, S2>>>::bitxor": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_bitxor_sym_diff() {\n        let set1: IndexSet<u32> = (1..=5).collect();\n        let set2: IndexSet<u32> = (4..=8).collect();\n\n        let result = set1.bitxor(&set2);\n\n        let expected: IndexSet<u32> = (1..=3).chain(5..=8).collect();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_bitxor_disjoint_sets() {\n        let set1: IndexSet<char> = vec!['a', 'b', 'c'].into_iter().collect();\n        let set2: IndexSet<char> = vec!['d', 'e', 'f'].into_iter().collect();\n\n        let result = set1.bitxor(&set2);\n\n        let expected: IndexSet<char> = vec!['a', 'b', 'c', 'd', 'e', 'f'].into_iter().collect();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_bitxor_empty_set() {\n        let set1: IndexSet<i32> = IndexSet::new();\n        let set2: IndexSet<i32> = (1..=5).collect();\n\n        let result = set1.bitxor(&set2);\n        assert_eq!(result, set2);\n    }\n\n    #[test]\n    fn test_bitxor_identical_sets() {\n        let set1: IndexSet<i32> = (1..=5).collect();\n        let result = set1.bitxor(&set1);\n        assert_eq!(result, IndexSet::new());\n    }\n\n    #[test]\n    fn test_bitxor_order_preservation() {\n        let set1: IndexSet<char> = vec!['a', 'b', 'c'].into_iter().collect();\n        let set2: IndexSet<char> = vec!['c', 'd', 'e'].into_iter().collect();\n\n        let result = set1.bitxor(&set2);\n        let expected: IndexSet<char> = vec!['a', 'b', 'd', 'e'].into_iter().collect();\n        assert_eq!(result, expected);\n    }\n}\n```", "<&set::IndexSet<T, S1> as core::ops::Sub<&set::IndexSet<T, S2>>>::sub": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_sub() {\n        let set1: IndexSet<i32> = vec![1, 2, 3].into_iter().collect();\n        let set2: IndexSet<i32> = vec![2, 3, 4].into_iter().collect();\n        \n        let result = set1.sub(&set2);\n        \n        let expected: IndexSet<i32> = vec![1].into_iter().collect();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_sub_empty() {\n        let set1: IndexSet<i32> = vec![1, 2, 3].into_iter().collect();\n        let set2: IndexSet<i32> = IndexSet::new();\n        \n        let result = set1.sub(&set2);\n        \n        let expected = set1.clone();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_sub_no_difference() {\n        let set1: IndexSet<i32> = vec![2, 3, 4].into_iter().collect();\n        let set2: IndexSet<i32> = vec![2, 3, 4].into_iter().collect();\n        \n        let result = set1.sub(&set2);\n        \n        let expected: IndexSet<i32> = IndexSet::new();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_sub_some_difference() {\n        let set1: IndexSet<i32> = vec![1, 2, 3, 4].into_iter().collect();\n        let set2: IndexSet<i32> = vec![2, 4].into_iter().collect();\n        \n        let result = set1.sub(&set2);\n        \n        let expected: IndexSet<i32> = vec![1, 3].into_iter().collect();\n        assert_eq!(result, expected);\n    }\n}\n```", "<&set::slice::Slice<T> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n\n    #[test]\n    fn test_default() {\n        let slice: &Slice<u32> = Slice::default();\n        assert!(slice.is_empty());\n        assert_eq!(slice.len(), 0);\n    }\n}\n```", "<Bucket<K, V> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::HashValue;\n\n    #[test]\n    fn test_bucket_clone() {\n        let hash_value = HashValue(42);\n        let key = \"key\".to_string();\n        let value = \"value\".to_string();\n        let original_bucket = Bucket {\n            hash: hash_value,\n            key: key.clone(),\n            value: value.clone(),\n        };\n\n        let cloned_bucket = original_bucket.clone();\n\n        assert_eq!(cloned_bucket.hash, original_bucket.hash);\n        assert_eq!(cloned_bucket.key, original_bucket.key);\n        assert_eq!(cloned_bucket.value, original_bucket.value);\n        assert!(std::ptr::eq(&cloned_bucket.key, &original_bucket.key) == false);\n        assert!(std::ptr::eq(&cloned_bucket.value, &original_bucket.value) == false);\n    }\n}\n```", "<Bucket<K, V> as core::clone::Clone>::clone_from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[derive(Clone, Debug, PartialEq)]\n    struct TestKey(u32);\n\n    #[derive(Clone, Debug, PartialEq)]\n    struct TestValue(u32);\n\n    #[test]\n    fn test_clone_from() {\n        let mut bucket1 = Bucket {\n            hash: HashValue(1),\n            key: TestKey(10),\n            value: TestValue(20),\n        };\n\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: TestKey(30),\n            value: TestValue(40),\n        };\n\n        bucket1.clone_from(&bucket2);\n\n        assert_eq!(bucket1.hash, bucket2.hash);\n        assert_eq!(bucket1.key, bucket2.key);\n        assert_eq!(bucket1.value, bucket2.value);\n    }\n\n    #[test]\n    fn test_clone_from_same_object() {\n        let mut bucket = Bucket {\n            hash: HashValue(1),\n            key: TestKey(10),\n            value: TestValue(20),\n        };\n\n        bucket.clone_from(&bucket);\n\n        assert_eq!(bucket.hash, HashValue(1));\n        assert_eq!(bucket.key, TestKey(10));\n        assert_eq!(bucket.value, TestValue(20));\n    }\n}\n```", "<map::IndexMap<K, V, S> as Entries>::as_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_as_entries() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let entries = map.as_entries();\n        \n        assert_eq!(entries.len(), 3);\n        assert_eq!(entries[0].key, 1);\n        assert_eq!(entries[0].value, \"a\");\n        assert_eq!(entries[1].key, 2);\n        assert_eq!(entries[1].value, \"b\");\n        assert_eq!(entries[2].key, 3);\n        assert_eq!(entries[2].value, \"c\");\n    }\n\n    #[test]\n    fn test_as_entries_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let entries = map.as_entries();\n\n        assert!(entries.is_empty());\n    }\n\n    #[test]\n    fn test_as_entries_after_insertion() {\n        let mut map = IndexMap::new();\n        map.insert(5, \"e\");\n        map.insert(6, \"f\");\n\n        let entries = map.as_entries();\n        \n        assert_eq!(entries.len(), 2);\n        assert_eq!(entries[0].key, 5);\n        assert_eq!(entries[0].value, \"e\");\n        assert_eq!(entries[1].key, 6);\n        assert_eq!(entries[1].value, \"f\");\n    }\n\n    #[test]\n    fn test_as_entries_after_removal() {\n        let mut map = IndexMap::new();\n        map.insert(3, \"c\");\n        map.insert(4, \"d\");\n        map.remove(&3);\n\n        let entries = map.as_entries();\n        \n        assert_eq!(entries.len(), 1);\n        assert_eq!(entries[0].key, 4);\n        assert_eq!(entries[0].value, \"d\");\n    }\n}\n```", "<map::IndexMap<K, V, S> as Entries>::as_entries_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::IndexMap;\n\n    #[test]\n    fn test_as_entries_mut() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let entries_mut = map.as_entries_mut();\n\n        assert_eq!(entries_mut.len(), 2);\n        assert_eq!(entries_mut[0].key, \"key1\");\n        assert_eq!(entries_mut[0].value, \"value1\");\n\n        entries_mut[0].value = \"new_value1\";\n        assert_eq!(map[\"key1\"], \"new_value1\");\n    }\n\n    #[test]\n    fn test_as_entries_mut_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let entries_mut = map.as_entries_mut();\n        assert!(entries_mut.is_empty());\n    }\n}\n```", "<map::IndexMap<K, V, S> as Entries>::into_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_entries() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let entries = map.into_entries();\n        \n        assert_eq!(entries.len(), 3);\n        assert!(entries.iter().any(|entry| entry.key == 1 && entry.value == \"a\");\n        assert!(entries.iter().any(|entry| entry.key == 2 && entry.value == \"b\");\n        assert!(entries.iter().any(|entry| entry.key == 3 && entry.value == \"c\");\n    }\n\n    #[test]\n    fn test_into_entries_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let entries = map.into_entries();\n        \n        assert!(entries.is_empty());\n    }\n\n    #[test]\n    fn test_into_entries_order() {\n        let mut map = IndexMap::new();\n        map.insert(3, \"c\");\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let entries = map.into_entries();\n        \n        assert_eq!(entries[0].key, 3);\n        assert_eq!(entries[1].key, 1);\n        assert_eq!(entries[2].key, 2);\n    }\n}\n```", "<map::IndexMap<K, V, S> as Entries>::with_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_with_entries() {\n        let mut map: IndexMap<char, usize> = IndexMap::new();\n        map.insert('a', 1);\n        map.insert('b', 2);\n        map.insert('c', 3);\n\n        map.with_entries(|entries| {\n            for entry in entries {\n                entry.value += 10; // Increment each value by 10\n            }\n        });\n\n        assert_eq!(map.get(&'a'), Some(&11));\n        assert_eq!(map.get(&'b'), Some(&12));\n        assert_eq!(map.get(&'c'), Some(&13));\n    }\n\n    #[test]\n    fn test_with_entries_empty() {\n        let mut empty_map: IndexMap<char, usize> = IndexMap::new();\n        empty_map.with_entries(|entries| {\n            assert!(entries.is_empty()); // Ensure entries are empty\n        });\n    }\n}\n```", "<map::IndexMap<K, V, S> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_indexmap_clone() {\n        let mut original: IndexMap<i32, &str> = IndexMap::new();\n        original.insert(1, \"one\");\n        original.insert(2, \"two\");\n        original.insert(3, \"three\");\n\n        let cloned = original.clone();\n\n        assert_eq!(original.len(), cloned.len());\n        assert_eq!(original.get(&1), cloned.get(&1));\n        assert_eq!(original.get(&2), cloned.get(&2));\n        assert_eq!(original.get(&3), cloned.get(&3));\n        assert!(std::ptr::eq(original.as_slice().as_ptr(), cloned.as_slice().as_ptr()) == false); // Ensure they are different instances\n    }\n\n    #[test]\n    fn test_indexmap_clone_empty() {\n        let original: IndexMap<i32, &str> = IndexMap::new();\n\n        let cloned = original.clone();\n\n        assert_eq!(original.len(), cloned.len());\n        assert!(original.is_empty());\n        assert!(cloned.is_empty());\n    }\n}\n```", "<map::IndexMap<K, V, S> as core::clone::Clone>::clone_from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_clone_from() {\n        let mut map1: IndexMap<i32, &str> = IndexMap::new();\n        map1.insert(1, \"a\");\n        map1.insert(2, \"b\");\n\n        let mut map2: IndexMap<i32, &str> = IndexMap::new();\n        map2.insert(1, \"x\");\n        map2.insert(3, \"c\");\n\n        map1.clone_from(&map2);\n\n        assert_eq!(map1.get(&1), Some(&\"x\")); // check if map1 has the cloned value from map2\n        assert_eq!(map1.get(&2), Some(&\"b\")); // check if map1 retains its own value\n        assert_eq!(map1.get(&3), Some(&\"c\")); // check if map1 has the new value from map2\n        assert_eq!(map1.len(), 3); // check the length of map1\n    }\n\n    #[test]\n    fn test_clone_from_empty() {\n        let mut map1: IndexMap<i32, &str> = IndexMap::new();\n        let map2: IndexMap<i32, &str> = IndexMap::new();\n\n        map1.clone_from(&map2);\n\n        assert!(map1.is_empty()); // map1 should still be empty\n    }\n\n    #[test]\n    fn test_clone_from_with_capacity() {\n        let mut map1: IndexMap<i32, &str> = IndexMap::with_capacity(2);\n        map1.insert(1, \"a\");\n\n        let mut map2: IndexMap<i32, &str> = IndexMap::with_capacity(2);\n        map2.insert(2, \"b\");\n        map2.insert(3, \"c\");\n\n        map1.clone_from(&map2);\n\n        assert_eq!(map1.get(&2), Some(&\"b\")); // check for value from map2\n        assert_eq!(map1.get(&3), Some(&\"c\")); // check for another value from map2\n        assert_eq!(map1.len(), 2); // map1 should have new length from map2\n    }\n}\n```", "<map::IndexMap<K, V, S> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_default() {\n        // Test for default() when K and V are of type i32\n        let map: IndexMap<i32, i32, RandomState> = IndexMap::default();\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n\n        // Test for default() when K and V are of type String\n        let map: IndexMap<String, String, RandomState> = IndexMap::default();\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n\n        // Test for default() with custom hasher\n        #[derive(Default)]\n        struct CustomHasher;\n\n        impl BuildHasher for CustomHasher {\n            type Hasher = std::collections::hash_map::DefaultHasher;\n\n            fn build_hasher(&self) -> Self::Hasher {\n                std::collections::hash_map::DefaultHasher::new()\n            }\n        }\n\n        let map: IndexMap<i32, i32, CustomHasher> = IndexMap::default();\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n    }\n}\n```", "<map::IndexMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_extend_with_tuples() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let additional: Vec<(&i32, &&str)> = vec![(&3, &\"three\"), (&4, &\"four\")];\n        map.extend(additional.iter());\n\n        assert_eq!(map.len(), 4);\n        assert_eq!(map[&1], \"one\");\n        assert_eq!(map[&2], \"two\");\n        assert_eq!(map[&3], \"three\");\n        assert_eq!(map[&4], \"four\");\n    }\n\n    #[test]\n    fn test_extend_with_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n\n        let additional: Vec<(&i32, &&str)> = vec![];\n        map.extend(additional.iter());\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map[&1], \"one\");\n    }\n\n    #[test]\n    fn test_extend_with_existing_keys() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let additional: Vec<(&i32, &&str)> = vec![(&1, &\"updated_one\"), (&3, &\"three\")];\n        map.extend(additional.iter());\n\n        assert_eq!(map.len(), 3);\n        assert_eq!(map[&1], \"updated_one\");\n        assert_eq!(map[&2], \"two\");\n        assert_eq!(map[&3], \"three\");\n    }\n}\n```", "<map::IndexMap<K, V, S> as core::iter::Extend<(K, V)>>::extend": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_extend_inserts_new_items() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.extend(vec![(1, \"one\"), (2, \"two\"), (3, \"three\")]);\n        \n        assert_eq!(map.len(), 3);\n        assert_eq!(map[&1], \"one\");\n        assert_eq!(map[&2], \"two\");\n        assert_eq!(map[&3], \"three\");\n    }\n\n    #[test]\n    fn test_extend_updates_existing_items() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.extend(vec![(1, \"one\"), (2, \"two\")]);\n        \n        map.extend(vec![(1, \"uno\"), (3, \"three\")]);\n\n        assert_eq!(map.len(), 3);\n        assert_eq!(map[&1], \"uno\");\n        assert_eq!(map[&2], \"two\");\n        assert_eq!(map[&3], \"three\");\n    }\n\n    #[test]\n    fn test_extend_empty_iterable() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.extend(vec![]);\n\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_extend_with_multiple_updates() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.extend(vec![(1, \"one\"), (2, \"two\")]);\n        \n        map.extend(vec![(1, \"uno\"), (2, \"dos\")]);\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(map[&1], \"uno\");\n        assert_eq!(map[&2], \"dos\");\n    }\n\n    #[test]\n    fn test_extend_preserves_order() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.extend(vec![(2, \"two\"), (1, \"one\")]);\n        map.extend(vec![(3, \"three\"), (2, \"dos\")]);\n\n        assert_eq!(map.len(), 3);\n        assert_eq!(map[&2], \"dos\");\n        assert_eq!(map[&1], \"one\");\n        assert_eq!(map[&3], \"three\");\n    }\n}\n```", "<map::IndexMap<K, V, S> as core::iter::FromIterator<(K, V)>>::from_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_from_iter_with_empty_iterator() {\n        let map: IndexMap<i32, &str> = IndexMap::from_iter(vec![]);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_from_iter_with_single_pair() {\n        let map: IndexMap<i32, &str> = IndexMap::from_iter(vec![(1, \"one\")]);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map[&1], \"one\");\n    }\n\n    #[test]\n    fn test_from_iter_with_multiple_pairs() {\n        let map: IndexMap<i32, &str> = IndexMap::from_iter(vec![(1, \"one\"), (2, \"two\"), (3, \"three\")]);\n        assert_eq!(map.len(), 3);\n        assert_eq!(map[&1], \"one\");\n        assert_eq!(map[&2], \"two\");\n        assert_eq!(map[&3], \"three\");\n    }\n\n    #[test]\n    fn test_from_iter_with_duplicate_keys() {\n        let map: IndexMap<i32, &str> = IndexMap::from_iter(vec![(1, \"one\"), (1, \"uno\")]);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map[&1], \"uno\");\n    }\n\n    #[test]\n    fn test_from_iter_with_various_types() {\n        let map: IndexMap<String, i32> = IndexMap::from_iter(vec![\n            (String::from(\"a\"), 1),\n            (String::from(\"b\"), 2),\n            (String::from(\"c\"), 3),\n        ]);\n        assert_eq!(map.len(), 3);\n        assert_eq!(map[\"a\"], 1);\n        assert_eq!(map[\"b\"], 2);\n        assert_eq!(map[\"c\"], 3);\n    }\n}\n```", "<map::IndexMap<K, V, S> as core::ops::Index<&Q>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_valid_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        assert_eq!(map[&1], \"one\");\n        assert_eq!(map[&2], \"two\");\n        assert_eq!(map[&3], \"three\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"no entry found for key\")]\n    fn test_index_key_not_present() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let _ = map[&1]; // Should panic\n    }\n\n    #[test]\n    fn test_index_multiple_insertions() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        for i in 1..=5 {\n            map.insert(i, i * 10);\n        }\n\n        assert_eq!(map[&1], 10);\n        assert_eq!(map[&2], 20);\n        assert_eq!(map[&3], 30);\n        assert_eq!(map[&4], 40);\n        assert_eq!(map[&5], 50);\n    }\n\n    #[test]\n    #[should_panic(expected = \"no entry found for key\")]\n    fn test_index_with_non_existing_key() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        assert_eq!(map[&1], 10);\n        let _ = map[&3]; // Should panic\n    }\n}\n```", "<map::IndexMap<K, V, S> as core::ops::Index<usize>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_within_bounds() {\n        let mut map: IndexMap<usize, char> = IndexMap::new();\n        map.insert(0, 'a');\n        map.insert(1, 'b');\n        map.insert(2, 'c');\n\n        assert_eq!(map.index(0), &'a');\n        assert_eq!(map.index(1), &'b');\n        assert_eq!(map.index(2), &'c');\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\n    fn test_index_out_of_bounds() {\n        let mut map: IndexMap<usize, char> = IndexMap::new();\n        map.insert(0, 'a');\n        map.insert(1, 'b');\n        map.insert(2, 'c');\n\n        // This should panic\n        let _ = map.index(3);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 0 but the index is 0\")]\n    fn test_index_empty() {\n        let map: IndexMap<usize, char> = IndexMap::new();\n\n        // This should panic\n        let _ = map.index(0);\n    }\n}\n```", "<map::IndexMap<K, V, S> as core::ops::IndexMut<&Q>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    #[should_panic(expected = \"no entry found for key\")]\n    fn test_index_mut_panics_on_missing_key() {\n        let mut map: IndexMap<usize, usize> = IndexMap::new();\n        let _ = map.index_mut(&1); // Should panic since key `1` does not exist\n    }\n\n    #[test]\n    fn test_index_mut_update_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.index_mut(&1);\n        *map.index_mut(&1) = 20; // Update value for key `1`\n\n        assert_eq!(map.get(&1), Some(&20));\n    }\n\n    #[test]\n    fn test_index_mut_insert_and_update() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        \n        // Insert a value for the existing key\n        {\n            let value = map.index_mut(&1);\n            *value += 5; // Update the value, should become 15\n        }\n        \n        assert_eq!(map.get(&1), Some(&15));\n        \n        // Insert a new key and check values\n        map.insert(2, 20);\n        assert_eq!(map.index_mut(&2), &mut 20);\n        *map.index_mut(&2) += 5; // Update the value for new key\n        assert_eq!(map.get(&2), Some(&25));\n    }\n}\n```", "<map::IndexMap<K, V, S> as core::ops::IndexMut<usize>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 0 but the index is 0\")]\n    fn test_index_mut_out_of_bounds() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        // This should panic because there are no elements in the map.\n        let _ = map.index_mut(0);\n    }\n\n    #[test]\n    fn test_index_mut() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        // Valid index\n        assert_eq!(*map.index_mut(0), 10);\n        assert_eq!(*map.index_mut(1), 20);\n        \n        // Modify the value at index 0\n        *map.index_mut(0) = 15;\n        assert_eq!(*map.index_mut(0), 15);\n        assert_eq!(map.len(), 2);\n        \n        // Ensure the map holds the correct values\n        assert_eq!(map.get(&1), Some(&15));\n        assert_eq!(map.get(&2), Some(&20));\n    }\n\n    #[test]\n    fn test_index_mut_multiple_inserts() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        \n        // Valid indices\n        assert_eq!(*map.index_mut(0), 10);\n        assert_eq!(*map.index_mut(1), 20);\n        assert_eq!(*map.index_mut(2), 30);\n        \n        // Modify values\n        *map.index_mut(1) = 25;\n        assert_eq!(*map.index_mut(1), 25);\n        assert_eq!(map.len(), 3);\n    }\n}\n```", "<map::IndexMap<K, V, S> as map::core::raw_entry_v1::RawEntryApiV1<K, V, S>>::raw_entry_mut_v1": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_raw_entry_mut_v1() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        // Get a mutable raw entry builder\n        let raw_entry = map.raw_entry_mut_v1();\n\n        // Insert a new entry\n        raw_entry.insert(3, \"three\");\n\n        // Check if the entry was added\n        assert_eq!(map.get(&3), Some(&\"three\"));\n\n        // Update existing entry\n        let mut entry = raw_entry.entry(&1).or_insert(\"updated\");\n        *entry = \"one_updated\";\n\n        // Check if the entry was updated\n        assert_eq!(map.get(&1), Some(&\"one_updated\"));\n    }\n\n    #[test]\n    fn test_raw_entry_mut_v1_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        let raw_entry = map.raw_entry_mut_v1();\n\n        // Insert a new entry to the empty map\n        raw_entry.insert(4, \"four\");\n\n        // Check if the entry was added\n        assert_eq!(map.get(&4), Some(&\"four\"));\n    }\n\n    #[test]\n    fn test_raw_entry_mut_v1_replacing() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        // Get a mutable raw entry builder\n        let raw_entry = map.raw_entry_mut_v1();\n\n        // Insert an entry that replaces the existing entry\n        raw_entry.insert(2, \"two_updated\");\n\n        // Check if the entry was updated\n        assert_eq!(map.get(&2), Some(&\"two_updated\"));\n    }\n}\n```", "<map::IndexMap<K, V, S> as map::core::raw_entry_v1::RawEntryApiV1<K, V, S>>::raw_entry_v1": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_raw_entry_v1() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        // Test raw_entry_v1 builder\n        let builder = map.raw_entry_v1();\n\n        // Ensure the builder is initialized correctly.\n        assert_eq!(builder.map.len(), 2);\n        assert_eq!(builder.map.get(&1), Some(&\"one\"));\n        assert_eq!(builder.map.get(&2), Some(&\"two\"));\n        \n        // Insert a new entry using the raw_entry_v1 method.\n        builder.insert(3, \"three\");\n        \n        // Verify the new entry is present.\n        assert_eq!(map.get(&3), Some(&\"three\"));\n        assert_eq!(map.len(), 3);\n    }\n}\n```", "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::get_full_mut2": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_full_mut2_existing_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let result = map.get_full_mut2(&1);\n        assert!(result.is_some());\n        let (index, key, value) = result.unwrap();\n        assert_eq!(index, 0);\n        assert_eq!(*key, 1);\n        assert_eq!(*value, \"one\");\n\n        *value = \"uno\"; // test mutability\n        assert_eq!(map.get_full_mut2(&1).unwrap().1, &mut \"uno\");\n    }\n\n    #[test]\n    fn test_get_full_mut2_non_existing_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n\n        let result = map.get_full_mut2(&2);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_full_mut2_multiple_entries() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let result = map.get_full_mut2(&2);\n        assert!(result.is_some());\n        let (index, key, value) = result.unwrap();\n        assert_eq!(index, 1);\n        assert_eq!(*key, 2);\n        assert_eq!(*value, \"two\");\n\n        *value = \"dos\"; // test mutability\n        assert_eq!(map.get_full_mut2(&2).unwrap().1, &mut \"dos\");\n    }\n\n    #[test]\n    fn test_get_full_mut2_empty_map() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        let result = map.get_full_mut2(&1);\n        assert!(result.is_none());\n    }\n}\n```", "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::get_index_mut2": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_index_mut2() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        // Test getting mutable references\n        if let Some((key, value)) = map.get_index_mut2(1) {\n            assert_eq!(*key, \"b\");\n            assert_eq!(*value, 2);\n\n            // Modify value\n            *value += 10;\n        }\n\n        // Check if the value was modified in the map\n        assert_eq!(map[\"b\"], 12);\n\n        // Test getting mutable references for out of bounds\n        assert_eq!(map.get_index_mut2(3), None);\n    }\n\n    #[test]\n    fn test_get_index_mut2_empty_map() {\n        let mut map: IndexMap<String, i32> = IndexMap::new();\n        assert_eq!(map.get_index_mut2(0), None);\n    }\n}\n```", "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::iter_mut2": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_iter_mut2() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, String::from(\"one\"));\n        map.insert(2, String::from(\"two\"));\n        map.insert(3, String::from(\"three\"));\n\n        let mut iter = map.iter_mut2();\n        assert_eq!(iter.next(), Some((&1, &mut String::from(\"one\"))));\n        assert_eq!(iter.next(), Some((&2, &mut String::from(\"two\"))));\n        assert_eq!(iter.next(), Some((&3, &mut String::from(\"three\"))));\n        assert_eq!(iter.next(), None);  // No more elements\n    }\n\n    #[test]\n    fn test_iter_mut2_modify() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, String::from(\"one\"));\n        map.insert(2, String::from(\"two\"));\n\n        {\n            let mut iter = map.iter_mut2();\n            if let Some((_, value)) = iter.next() {\n                *value = String::from(\"ONE\");\n            }\n        }\n\n        assert_eq!(map.get(&1), Some(&String::from(\"ONE\")));\n        assert_eq!(map.get(&2), Some(&String::from(\"two\")));\n    }\n\n    #[test]\n    fn test_iter_mut2_empty() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        let iter = map.iter_mut2();\n        assert_eq!(iter.next(), None);  // No elements\n    }\n\n    #[test]\n    fn test_iter_mut2_insert_during_iteration() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, String::from(\"one\"));\n        map.insert(2, String::from(\"two\"));\n\n        {\n            let mut iter = map.iter_mut2();\n            assert_eq!(iter.next(), Some((&1, &mut String::from(\"one\"))));\n            map.insert(3, String::from(\"three\"));\n            assert_eq!(iter.next(), Some((&2, &mut String::from(\"two\"))));\n            assert_eq!(iter.next(), Some((&3, &mut String::from(\"three\"))));\n        }\n\n        assert_eq!(map.len(), 3);\n    }\n}\n```", "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::retain2": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_retain2() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n\n        map.retain2(|_key, value| {\n            *value > 1 // retain only entries with value > 1\n        });\n\n        assert_eq!(map.len(), 2);\n        assert!(map.contains_key(\"key2\"));\n        assert!(map.contains_key(\"key3\"));\n        assert!(!map.contains_key(\"key1\"));\n    }\n\n    #[test]\n    fn test_retain2_no_entries() {\n        let mut map = IndexMap::new();\n\n        map.retain2(|_key, _value| true);\n\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_retain2_all_entries() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n\n        map.retain2(|_key, _value| true); // retain all\n\n        assert_eq!(map.len(), 2);\n    }\n}\n```", "<map::IndexMap<K, V1, S1> as core::cmp::PartialEq<map::IndexMap<K, V2, S2>>>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_eq_equal_maps() {\n        let mut map1: IndexMap<i32, &str> = IndexMap::new();\n        map1.insert(1, \"a\");\n        map1.insert(2, \"b\");\n\n        let mut map2: IndexMap<i32, &str> = IndexMap::new();\n        map2.insert(1, \"a\");\n        map2.insert(2, \"b\");\n\n        assert!(map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_maps_different_lengths() {\n        let mut map1: IndexMap<i32, &str> = IndexMap::new();\n        map1.insert(1, \"a\");\n\n        let mut map2: IndexMap<i32, &str> = IndexMap::new();\n        map2.insert(1, \"a\");\n        map2.insert(2, \"b\");\n\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_maps_different_values() {\n        let mut map1: IndexMap<i32, &str> = IndexMap::new();\n        map1.insert(1, \"a\");\n        map1.insert(2, \"b\");\n\n        let mut map2: IndexMap<i32, &str> = IndexMap::new();\n        map2.insert(1, \"a\");\n        map2.insert(2, \"c\");\n\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_maps_different_keys() {\n        let mut map1: IndexMap<i32, &str> = IndexMap::new();\n        map1.insert(1, \"a\");\n        map1.insert(2, \"b\");\n\n        let mut map2: IndexMap<i32, &str> = IndexMap::new();\n        map2.insert(3, \"a\");\n        map2.insert(4, \"b\");\n\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_maps_equal_order() {\n        let mut map1: IndexMap<i32, &str> = IndexMap::new();\n        map1.insert(1, \"a\");\n        map1.insert(2, \"b\");\n\n        let mut map2: IndexMap<i32, &str> = IndexMap::new();\n        map2.insert(1, \"a\");\n        map2.insert(2, \"b\");\n\n        assert!(map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_maps_different_order() {\n        let mut map1: IndexMap<i32, &str> = IndexMap::new();\n        map1.insert(1, \"a\");\n        map1.insert(2, \"b\");\n\n        let mut map2: IndexMap<i32, &str> = IndexMap::new();\n        map2.insert(2, \"b\");\n        map2.insert(1, \"a\");\n\n        assert!(map1.eq(&map2));\n    }\n}\n```", "<map::IndexMap<K, V> as core::convert::From<[(K, V); N]>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_from_array() {\n        // Test with a simple array\n        let arr = [(1, 2), (3, 4)];\n        let map: IndexMap<_, _> = IndexMap::from(arr);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map[&1], 2);\n        assert_eq!(map[&3], 4);\n        \n        // Test with different types\n        let arr_string = [(String::from(\"a\"), String::from(\"alpha\")), \n                          (String::from(\"b\"), String::from(\"beta\"))];\n        let map_string: IndexMap<_, _> = IndexMap::from(arr_string);\n        assert_eq!(map_string.len(), 2);\n        assert_eq!(map_string[&String::from(\"a\")], String::from(\"alpha\"));\n        assert_eq!(map_string[&String::from(\"b\")], String::from(\"beta\"));\n    }\n\n    #[test]\n    fn test_equality_with_into() {\n        let arr: [(i32, i32); 2] = [(1, 2), (3, 4)];\n        let map1 = IndexMap::from(arr);\n        let map2: IndexMap<_, _> = arr.into();\n        assert_eq!(map1, map2);\n    }\n\n    #[test]\n    fn test_empty_array() {\n        let arr: [(i32, i32); 0] = [];\n        let map: IndexMap<_, _> = IndexMap::from(arr);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_invalid_key_type() {\n        let arr = [(1, 2)];\n        let _: IndexMap<String, i32> = IndexMap::from(arr); // Should panic at compile-time or runtime\n    }\n}\n```", "<map::core::IndexMapCore<K, V> as Entries>::as_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_as_entries() {\n        let mut map = IndexMapCore::new();\n        map.push_entry(0, \"key1\", \"value1\");\n        map.push_entry(1, \"key2\", \"value2\");\n        \n        let entries = map.as_entries();\n        \n        assert_eq!(entries.len(), 2);\n        assert_eq!(entries[0].key, \"key1\");\n        assert_eq!(entries[0].value, \"value1\");\n        assert_eq!(entries[1].key, \"key2\");\n        assert_eq!(entries[1].value, \"value2\");\n    }\n\n    #[test]\n    fn test_as_entries_empty() {\n        let map: IndexMapCore<&str, &str> = IndexMapCore::new();\n        let entries = map.as_entries();\n        \n        assert!(entries.is_empty());\n    }\n}\n```", "<map::core::IndexMapCore<K, V> as Entries>::as_entries_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::Entries; // adjust the import path according to your crate structure\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::Hasher;\n\n    #[test]\n    fn test_as_entries_mut() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        let hasher = DefaultHasher::new();\n        \n        // Insert some entries\n        map.insert_full(HashValue::new(hasher.finish()), 1, 10);\n        map.insert_full(HashValue::new(hasher.finish()), 2, 20);\n        map.insert_full(HashValue::new(hasher.finish()), 3, 30);\n        \n        // Get mutable references to entries\n        let entries_mut = map.as_entries_mut();\n        \n        // Modify entries\n        entries_mut[0].value = 100;\n        entries_mut[1].value = 200;\n        entries_mut[2].value = 300;\n        \n        // Assert the modifications\n        assert_eq!(entries_mut[0].value, 100);\n        assert_eq!(entries_mut[1].value, 200);\n        assert_eq!(entries_mut[2].value, 300);\n    }\n\n    #[test]\n    fn test_as_entries_mut_empty() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        \n        // Get mutable references to entries in an empty map\n        let entries_mut = map.as_entries_mut();\n        \n        // Assert that it's an empty slice\n        assert_eq!(entries_mut.len(), 0);\n    }\n}\n```", "<map::core::IndexMapCore<K, V> as Entries>::into_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_into_entries() {\n        let mut map = IndexMapCore::new();\n        map.entries.push(Bucket { hash: HashValue::default(), key: 1, value: \"one\" });\n        map.entries.push(Bucket { hash: HashValue::default(), key: 2, value: \"two\" });\n\n        let entries = map.into_entries();\n        assert_eq!(entries.len(), 2);\n        assert_eq!(entries[0].key, 1);\n        assert_eq!(entries[0].value, \"one\");\n        assert_eq!(entries[1].key, 2);\n        assert_eq!(entries[1].value, \"two\");\n    }\n\n    #[test]\n    fn test_into_entries_empty() {\n        let map: IndexMapCore<u32, &str> = IndexMapCore::new();\n        let entries = map.into_entries();\n        assert!(entries.is_empty());\n    }\n}\n```", "<map::core::IndexMapCore<K, V> as Entries>::with_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    #[test]\n    fn test_with_entries() {\n        let mut map = IndexMapCore::new();\n        map.push_entry(DefaultHasher::new().finish(), \"key1\", \"value1\");\n        map.push_entry(DefaultHasher::new().finish(), \"key2\", \"value2\");\n\n        // Modify entries using `with_entries`\n        map.with_entries(|entries| {\n            for entry in entries {\n                entry.value = \"modified_value\";\n            }\n        });\n\n        // Validate that the values have been modified\n        assert_eq!(map.entries[0].value, \"modified_value\");\n        assert_eq!(map.entries[1].value, \"modified_value\");\n    }\n}\n```", "<map::core::IndexMapCore<K, V> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_clone_empty() {\n        let original: IndexMapCore<i32, i32> = IndexMapCore::new();\n        let cloned = original.clone();\n        assert_eq!(original.len(), cloned.len());\n        assert!(cloned.entries.is_empty());\n    }\n\n    #[test]\n    fn test_clone_non_empty() {\n        let mut original = IndexMapCore::new();\n        original.insert(1, 10);\n        original.insert(2, 20);\n        original.insert(3, 30);\n        \n        let cloned = original.clone();\n        assert_eq!(original.len(), cloned.len());\n        assert_eq!(original.entries, cloned.entries);\n    }\n\n    #[test]\n    fn test_clone_with_diff_capacity() {\n        let mut original = IndexMapCore::with_capacity(5);\n        original.insert(1, 10);\n        original.insert(2, 20);\n        \n        let cloned = original.clone();\n        assert_eq!(original.len(), cloned.len());\n        assert_eq!(original.entries, cloned.entries);\n        assert!(cloned.capacity() >= original.capacity());\n    }\n\n    #[test]\n    fn test_clone_after_modification() {\n        let mut original = IndexMapCore::new();\n        original.insert(1, 10);\n        original.insert(2, 20);\n\n        let cloned = original.clone();\n        original.insert(3, 30);\n        \n        assert_eq!(original.len(), 3);\n        assert_eq!(cloned.len(), 2);\n        assert!(cloned.entries.iter().all(|&e| e.key != 3));\n    }\n}\n```", "<map::core::IndexMapCore<K, V> as core::clone::Clone>::clone_from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_clone_from() {\n        let mut map1: IndexMapCore<i32, i32> = IndexMapCore::new();\n        let mut map2: IndexMapCore<i32, i32> = IndexMapCore::new();\n\n        map1.insert_full(hash_value(1), 1, 10);\n        map1.insert_full(hash_value(2), 2, 20);\n        map2.insert_full(hash_value(3), 3, 30);\n        map2.insert_full(hash_value(4), 4, 40);\n\n        map1.clone_from(&map2);\n\n        assert_eq!(map1.len(), map2.len());\n        assert_eq!(map1.entries, map2.entries);\n    }\n\n    #[test]\n    fn test_clone_from_resizing() {\n        let mut map1: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(2);\n        let mut map2: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(4);\n\n        map1.insert_full(hash_value(1), 1, 10);\n        map2.insert_full(hash_value(2), 2, 20);\n        map2.insert_full(hash_value(3), 3, 30);\n        map2.insert_full(hash_value(4), 4, 40);\n\n        map1.clone_from(&map2);\n\n        assert_eq!(map1.len(), map2.len());\n        assert_eq!(map1.entries, map2.entries);\n        assert!(map1.capacity() >= map2.len());\n    }\n\n    #[test]\n    fn test_clone_from_empty() {\n        let mut map1: IndexMapCore<i32, i32> = IndexMapCore::new();\n        let map2: IndexMapCore<i32, i32> = IndexMapCore::new();\n\n        map1.clone_from(&map2);\n\n        assert_eq!(map1.len(), 0);\n    }\n}\n```", "<map::core::entry::Entry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::Entry;\n    use crate::map::core::entry::OccupiedEntry;\n    use crate::map::core::entry::VacantEntry;\n    use crate::map::mutable::MutableEntryKey;\n    use crate::Indices;\n    use crate::Entries;\n    use crate::HashValue;\n    \n    #[test]\n    fn test_key_mut_occupied() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let hash_value = HashValue(1);\n        let key = \"test_key\";\n        let value = \"test_value\";\n        \n        let mut vacant_entry = VacantEntry {\n            map: RefMut::new(&mut indices, &mut entries),\n            hash: hash_value,\n            key,\n        };\n        \n        let occupied_entry: OccupiedEntry<_, _, _> = vacant_entry.insert_entry(value);\n        \n        let mut entry = Entry::Occupied(occupied_entry);\n        let key_mut = entry.key_mut();\n        \n        assert_eq!(*key_mut, \"test_key\");\n        \n        *key_mut = \"new_key\";\n        \n        assert_eq!(*entry.key_mut(), \"new_key\");\n    }\n\n    #[test]\n    fn test_key_mut_vacant() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let hash_value = HashValue(1);\n        let key = \"test_key\";\n        \n        let vacant_entry = VacantEntry {\n            map: RefMut::new(&mut indices, &mut entries),\n            hash: hash_value,\n            key,\n        };\n        \n        let mut entry = Entry::Vacant(vacant_entry);\n        let key_mut = entry.key_mut();\n        \n        assert_eq!(*key_mut, \"test_key\");\n        \n        *key_mut = \"new_key\";\n        \n        assert_eq!(*entry.key_mut(), \"new_key\");\n    }\n}\n```", "<map::core::entry::IndexedEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_key_mut() {\n        let mut map: IndexMap<String, i32> = IndexMap::new();\n        map.insert(\"a\".to_string(), 1);\n\n        let index = 0;\n        let mut entry = IndexedEntry::new(&mut map, index);\n\n        // Get mutable reference to the key\n        let key_mut = entry.key_mut();\n        assert_eq!(key_mut, &mut \"a\".to_string());\n\n        // Modify the key\n        *key_mut = \"b\".to_string();\n\n        // Check if the key has been modified\n        assert_eq!(map.get_key_value(\"b\").unwrap().1, &1);\n        assert!(map.get_key_value(\"a\").is_none());\n    }\n}\n```", "<map::core::entry::IndexedEntry<'a, K, V> as core::convert::From<map::core::entry::OccupiedEntry<'a, K, V>>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_indexed_entry_from_occupied_entry() {\n        let mut entries = vec![(1, \"a\"), (2, \"b\")];\n        let mut indices = vec![0, 1];\n        let mut occupied_entry = OccupiedEntry::new(&mut entries, indices[0]);\n        \n        let indexed_entry: IndexedEntry<_, _> = IndexedEntry::from(occupied_entry);\n\n        assert_eq!(indexed_entry.index, 0);\n        assert_eq!(indexed_entry.key(), &1);\n        assert_eq!(indexed_entry.get(), &\"a\");\n    }\n    \n    #[test]\n    fn test_indexed_entry_from_multiple() {\n        let mut entries = vec![(1, \"a\"), (2, \"b\"), (3, \"c\")];\n        let mut indices = vec![0, 1, 2];\n        let mut occupied_entry = OccupiedEntry::new(&mut entries, indices[1]);\n        \n        let indexed_entry: IndexedEntry<_, _> = IndexedEntry::from(occupied_entry);\n\n        assert_eq!(indexed_entry.index, 1);\n        assert_eq!(indexed_entry.key(), &2);\n        assert_eq!(indexed_entry.get(), &\"b\");\n    }\n}\n```", "<map::core::entry::OccupiedEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_key_mut() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        // Get the occupied entry\n        let mut entry = map.entry(2).or_insert(20);\n\n        // Get mutable reference to the key and modify it\n        let key_mut = entry.key_mut();\n        *key_mut = 4;\n\n        // Assert the key has been changed in the map\n        assert_eq!(map.get(&4), Some(&20));\n        assert_eq!(map.get(&2), None);\n    }\n}\n```", "<map::core::entry::OccupiedEntry<'a, K, V> as core::convert::From<map::core::entry::IndexedEntry<'a, K, V>>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::entry::{OccupiedEntry, IndexedEntry};\n    use map::core::RefMut;\n\n    #[test]\n    fn test_from_indexed_entry() {\n        // Setup a mock map and entries\n        let mut entries = Entries::new(); // Assume Entries::new() initializes an empty Entries\n        let mut indices = Indices::new(); // Assume Indices::new() initializes an empty Indices\n        let mut map = IndexMapCore::new(); // Assume IndexMapCore::new() initializes a new map\n        let occupied_entry_key = ...; // Key for the occupied entry\n        let occupied_entry_value = ...; // Value for the occupied entry\n        \n        // Insert a key-value pair into the map\n        let occupied_entry = {\n            let mut occupied = OccupiedEntry::new(&mut entries, ...); // Assume an appropriate entry insertion\n            occupied.insert(occupied_entry_value)\n        };\n\n        // Create IndexedEntry from OccupiedEntry\n        let indexed_entry: IndexedEntry<_, _> = IndexedEntry::from(occupied_entry);\n        \n        // Create OccupiedEntry from IndexedEntry\n        let occupied_entry_from_indexed: OccupiedEntry<_, _> = OccupiedEntry::from(indexed_entry);\n\n        // Validate the properties of the converted occupied entry\n        assert_eq!(occupied_entry_from_indexed.index(), occupied_entry.index());\n        assert_eq!(occupied_entry_from_indexed.get(), occupied_entry.get());\n        assert_eq!(occupied_entry_from_indexed.key(), occupied_entry.key());\n    }\n}\n```", "<map::core::entry::VacantEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_key_mut() {\n        let mut map: HashMap<HashValue, i32> = HashMap::new();\n        let hash = HashValue(1);\n        let key = HashValue(10);\n        let value = 20;\n\n        // Insert a value to create a vacant entry\n        map.insert(hash, value);\n\n        // Create a VacantEntry\n        let mut entry = VacantEntry {\n            map: RefMut::new(&mut map, &mut vec![]), // ref to empty entries\n            hash,\n            key,\n        };\n\n        // Get mutable key reference\n        let key_mut = entry.key_mut();\n        \n        // Ensure mutable reference to key\n        *key_mut = HashValue(15);\n\n        // Verify that the key has indeed been modified\n        assert_eq!(*key_mut, HashValue(15));\n        assert_eq!(entry.key(), &HashValue(15));\n    }\n}\n```", "<map::iter::Drain<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_back() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        map.insert(\"key3\", \"value3\");\n\n        let mut drain = map.drain();\n        assert_eq!(drain.next_back(), Some((\"key3\", \"value3\")));\n        assert_eq!(drain.next_back(), Some((\"key2\", \"value2\")));\n        assert_eq!(drain.next_back(), Some((\"key1\", \"value1\")));\n        assert_eq!(drain.next_back(), None);\n    }\n\n    #[test]\n    fn test_drain_empty() {\n        let mut map: IndexMap<&str, &str> = IndexMap::new();\n        let mut drain = map.drain();\n        assert_eq!(drain.next_back(), None);\n    }\n}\n```", "<map::iter::Drain<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import the necessary items\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_back() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut drain = map.drain();\n        \n        assert_eq!(drain.nth_back(0), Some((\"c\", 3)));\n        assert_eq!(drain.nth_back(1), Some((\"b\", 2)));\n        assert_eq!(drain.nth_back(2), Some((\"a\", 1)));\n        assert_eq!(drain.nth_back(3), None);\n    }\n}\n```", "<map::iter::Drain<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_drain_len() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let mut drain = map.drain();\n        assert_eq!(drain.len(), 3);\n\n        let _ = drain.next();\n        assert_eq!(drain.len(), 2);\n\n        let _ = drain.next();\n        assert_eq!(drain.len(), 1);\n\n        let _ = drain.next();\n        assert_eq!(drain.len(), 0);\n    }\n}\n```", "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_from_drain() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let drain = map.drain(..);\n        let collected: IndexMap<i32, &str> = drain.collect();\n\n        let mut expected = IndexMap::new();\n        expected.insert(1, \"one\");\n        expected.insert(2, \"two\");\n        expected.insert(3, \"three\");\n\n        assert_eq!(collected, expected);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_collect_empty_drain() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        let drain = map.drain(..);\n        let collected: IndexMap<i32, &str> = drain.collect();\n\n        assert!(collected.is_empty());\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_collect_partial_drain() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let drain = map.drain(1..3);\n        let collected: IndexMap<i32, &str> = drain.collect();\n\n        let mut expected = IndexMap::new();\n        expected.insert(2, \"two\");\n        expected.insert(3, \"three\");\n\n        assert_eq!(collected, expected);\n        assert_eq!(map.len(), 1);\n        assert!(map.contains_key(&1));\n    }\n}\n```", "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_count() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        \n        let drain = map.drain();\n        let count = drain.count();\n        \n        assert_eq!(count, 2);\n    }\n\n    #[test]\n    fn test_count_empty() {\n        let map: IndexMap<&str, &str> = IndexMap::new();\n        \n        let drain = map.drain();\n        let count = drain.count();\n        \n        assert_eq!(count, 0);\n    }\n}\n```", "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        \n        let mut drain = map.drain();\n        \n        assert_eq!(drain.last(), Some((3, 30)));\n        assert_eq!(drain.last(), None); // after taking last element, further last should be None\n    }\n\n    #[test]\n    fn test_last_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let mut drain = map.drain();\n        \n        assert_eq!(drain.last(), None); // should return None on empty drain\n    }\n\n    #[test]\n    fn test_last_multiple_calls() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        let mut drain = map.drain();\n        \n        assert_eq!(drain.last(), Some((2, 20)));\n        assert_eq!(drain.last(), Some((1, 10))); // still elements available\n        assert_eq!(drain.last(), None); // once all are drained, further calls should return None\n    }\n}\n```", "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::{IndexMap, indexmap};\n\n    #[test]\n    fn test_drain_next() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let mut drain = map.drain();\n        \n        assert_eq!(drain.next(), Some((\"key1\", \"value1\")));\n        assert_eq!(drain.next(), Some((\"key2\", \"value2\")));\n        assert_eq!(drain.next(), None);\n    }\n\n    #[test]\n    fn test_drain_next_empty() {\n        let mut map: IndexMap<&str, &str> = IndexMap::new();\n        let mut drain = map.drain();\n\n        assert_eq!(drain.next(), None);\n    }\n}\n```", "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut drain = map.drain();\n\n        // Test nth for various indices\n        assert_eq!(drain.nth(0), Some((\"a\", 1)));\n        assert_eq!(drain.nth(1), Some((\"b\", 2)));\n        assert_eq!(drain.nth(2), Some((\"c\", 3)));\n        assert_eq!(drain.nth(3), None);\n    }\n}\n```", "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let drain = map.drain();\n        assert_eq!(drain.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        let drain = map.drain();\n        assert_eq!(drain.size_hint(), (2, Some(2)));\n    }\n\n    #[test]\n    fn test_size_hint_after_partial_drain() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        let mut drain = map.drain();\n        assert_eq!(drain.size_hint(), (2, Some(2)));\n        drain.next(); // Drain one element\n        assert_eq!(drain.size_hint(), (1, Some(1)));\n    }\n\n    #[test]\n    fn test_size_hint_after_drain_all() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        let mut drain = map.drain();\n        drain.next(); // Drain the only element\n        assert_eq!(drain.size_hint(), (0, Some(0)));\n    }\n}\n```", "<map::iter::IntoIter<K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_into_iter_default() {\n        let default_iter: IntoIter<i32, String> = Default::default();\n        assert_eq!(default_iter.len(), 0);\n    }\n}\n```", "<map::iter::IntoIter<K, V> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_back() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut iter = map.clone().into_iter();\n        assert_eq!(iter.next_back(), Some((\"c\", 3)));\n        assert_eq!(iter.next_back(), Some((\"b\", 2)));\n        assert_eq!(iter.next_back(), Some((\"a\", 1)));\n        assert_eq!(iter.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_empty() {\n        let mut iter: IntoIter<&str, i32> = IntoIter::default();\n        assert_eq!(iter.next_back(), None);\n    }\n}\n```", "<map::iter::IntoIter<K, V> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_back() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        let mut iter = map.into_iter();\n\n        assert_eq!(iter.nth_back(0), Some((\"c\", 3)));\n        assert_eq!(iter.nth_back(1), Some((\"b\", 2)));\n        assert_eq!(iter.nth_back(2), Some((\"a\", 1)));\n        assert_eq!(iter.nth_back(3), None);\n    }\n\n    #[test]\n    fn test_nth_back_on_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let mut iter = map.into_iter();\n\n        assert_eq!(iter.nth_back(0), None);\n    }\n\n    #[test]\n    fn test_nth_back_with_multiple_calls() {\n        let mut map = IndexMap::new();\n        map.insert(\"one\", 1);\n        map.insert(\"two\", 2);\n        map.insert(\"three\", 3);\n        let mut iter = map.into_iter();\n\n        assert_eq!(iter.nth_back(0), Some((\"three\", 3)));\n        assert_eq!(iter.nth_back(0), Some((\"two\", 2)));\n        assert_eq!(iter.nth_back(0), Some((\"one\", 1)));\n        assert_eq!(iter.nth_back(1), None); // No more elements\n    }\n}\n```", "<map::iter::IntoIter<K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_len() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        let into_iter = map.clone().into_iter();\n        assert_eq!(into_iter.len(), 2);\n\n        let empty_iter: IntoIter<i32, i32> = IntoIter::default();\n        assert_eq!(empty_iter.len(), 0);\n    }\n}\n```", "<map::iter::IntoIter<K, V> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_into_indexmap() {\n        let pairs = vec![(1, \"one\"), (2, \"two\"), (3, \"three\")];\n        let index_map: IndexMap<_, _> = pairs.into_iter().collect();\n        \n        assert_eq!(index_map.len(), 3);\n        assert_eq!(index_map.get(&1), Some(&\"one\"));\n        assert_eq!(index_map.get(&2), Some(&\"two\"));\n        assert_eq!(index_map.get(&3), Some(&\"three\"));\n    }\n\n    #[test]\n    fn test_collect_into_empty_indexmap() {\n        let pairs: Vec<(i32, &str)> = vec![];\n        let index_map: IndexMap<_, _> = pairs.into_iter().collect();\n        \n        assert_eq!(index_map.len(), 0);\n    }\n\n    #[test]\n    fn test_collect_with_duplicates() {\n        let pairs = vec![(1, \"one\"), (2, \"two\"), (1, \"uno\")]; // duplicate key 1\n        let index_map: IndexMap<_, _> = pairs.into_iter().collect();\n        \n        assert_eq!(index_map.len(), 2);\n        assert_eq!(index_map.get(&1), Some(&\"uno\")); // last value should prevail\n    }\n\n    #[test]\n    fn test_collect_empty() {\n        let pairs: Vec<(i32, &str)> = vec![];\n        let index_map: IndexMap<_, _> = pairs.into_iter().collect();\n        \n        assert_eq!(index_map.len(), 0);\n        assert!(index_map.is_empty());\n    }\n\n    #[test]\n    fn test_collect_order() {\n        let pairs = vec![(3, \"three\"), (1, \"one\"), (2, \"two\")];\n        let index_map: IndexMap<_, _> = pairs.into_iter().collect();\n        \n        assert_eq!(index_map.keys().collect::<Vec<_>>(), vec![3, 1, 2]);\n    }\n}\n```", "<map::iter::IntoIter<K, V> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_iter_count() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        map.insert(\"key3\", \"value3\");\n\n        let into_iter = map.clone().into_iter();\n        let count = into_iter.count();\n        \n        assert_eq!(count, 3);\n    }\n\n    #[test]\n    fn test_into_iter_count_empty() {\n        let map: IndexMap<String, String> = IndexMap::new();\n        \n        let into_iter = map.into_iter();\n        let count = into_iter.count();\n        \n        assert_eq!(count, 0);\n    }\n}\n```", "<map::iter::IntoIter<K, V> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let iter = map.into_iter();\n        let last_entry = iter.last();\n\n        assert_eq!(last_entry, Some((\"c\", 3)));\n    }\n\n    #[test]\n    fn test_last_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let iter = map.into_iter();\n        let last_entry = iter.last();\n\n        assert_eq!(last_entry, None);\n    }\n}\n```", "<map::iter::IntoIter<K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let mut iter = map.clone().into_iter();\n        \n        // Test first call to next\n        assert_eq!(iter.next(), Some((\"key1\", \"value1\")));\n        \n        // Test second call to next\n        assert_eq!(iter.next(), Some((\"key2\", \"value2\")));\n        \n        // Test that next returns None after exhausting the iterator\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let mut map = IndexMap::new();\n        let mut iter = map.into_iter();\n        \n        // Test that next on an empty iterator returns None\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "<map::iter::IntoIter<K, V> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut iter = map.clone().into_iter();\n        \n        assert_eq!(iter.nth(0), Some((\"a\", 1)));\n        assert_eq!(iter.nth(1), Some((\"b\", 2)));\n        assert_eq!(iter.nth(0), Some((\"c\", 3)));\n        assert_eq!(iter.nth(2), None);\n    }\n\n    #[test]\n    fn test_nth_empty() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        let mut iter = map.into_iter();\n        \n        assert_eq!(iter.nth(0), None);\n    }\n\n    #[test]\n    fn test_nth_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(\"x\", 10);\n        \n        let mut iter = map.into_iter();\n        \n        assert_eq!(iter.nth(1), None);\n    }\n}\n```", "<map::iter::IntoIter<K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        let iter = map.clone().into_iter(); // Create an iterator from the map\n\n        let hint = iter.size_hint();\n        assert_eq!(hint, (2, Some(2))); // there are 2 elements, size hint should return (2, Some(2))\n    }\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let iter = map.into_iter(); // Create an iterator from the empty map\n\n        let hint = iter.size_hint();\n        assert_eq!(hint, (0, Some(0))); // should return (0, Some(0)) for an empty iterator\n    }\n}\n```", "<map::iter::IntoKeys<K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::IntoKeys;\n\n    #[test]\n    fn test_into_keys_default() {\n        let default_keys: IntoKeys<i32, i32> = IntoKeys::default();\n        assert_eq!(default_keys.len(), 0);  // Check that the default iterator has length 0\n    }\n}\n```", "<map::iter::IntoKeys<K, V> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming this is in the same module as the definition\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_back() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut keys = map.clone().into_keys();\n\n        assert_eq!(keys.next_back(), Some(3));\n        assert_eq!(keys.next_back(), Some(2));\n        assert_eq!(keys.next_back(), Some(1));\n        assert_eq!(keys.next_back(), None);\n    }\n}\n```", "<map::iter::IntoKeys<K, V> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_back() {\n        let mut index_map: IndexMap<i32, String> = IndexMap::new();\n        index_map.insert(1, \"one\".to_string());\n        index_map.insert(2, \"two\".to_string());\n        index_map.insert(3, \"three\".to_string());\n        \n        let mut into_keys = index_map.into_keys();\n\n        assert_eq!(into_keys.nth_back(0), Some(3));\n        assert_eq!(into_keys.nth_back(1), Some(2));\n        assert_eq!(into_keys.nth_back(2), Some(1));\n        assert_eq!(into_keys.nth_back(3), None);\n    }\n}\n```", "<map::iter::IntoKeys<K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_len() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        \n        let into_keys = map.clone().into_keys();\n        assert_eq!(into_keys.len(), 2);\n        \n        let empty_keys: IntoKeys<_, _> = IntoKeys::default();\n        assert_eq!(empty_keys.len(), 0);\n    }\n}\n```", "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_from_keys() {\n        let map: IndexMap<i32, &str> = IndexMap::from([(1, \"one\"), (2, \"two\"), (3, \"three\")]);\n        let keys: Vec<_> = map.into_keys().collect();\n        assert_eq!(keys, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_collect_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let keys: Vec<_> = map.into_keys().collect();\n        assert!(keys.is_empty());\n    }\n\n    #[test]\n    fn test_collect_with_duplicates() {\n        let map: IndexMap<i32, &str> = IndexMap::from([(1, \"one\"), (2, \"two\"), (1, \"three\")]);\n        let keys: Vec<_> = map.into_keys().collect();\n        assert_eq!(keys, vec![1, 2]);\n    }\n\n    #[test]\n    fn test_collect_preserves_order() {\n        let map: IndexMap<char, i32> = IndexMap::from([( 'a', 1), ('b', 2), ('c', 3)]);\n        let keys: Vec<_> = map.into_keys().collect();\n        assert_eq!(keys, vec!['a', 'b', 'c']);\n    }\n}\n```", "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_count() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        let keys = map.into_keys();\n        assert_eq!(keys.count(), 2);\n    }\n\n    #[test]\n    fn test_count_empty() {\n        let map: IndexMap<String, i32> = IndexMap::new();\n        let keys = map.into_keys();\n        assert_eq!(keys.count(), 0);\n    }\n\n    #[test]\n    fn test_count_with_multiple_keys() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n        let keys = map.into_keys();\n        assert_eq!(keys.count(), 3);\n    }\n}\n```", "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last_with_elements() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        let keys: Vec<_> = map.clone().into_keys().collect();\n        let last_key = keys.into_iter().last();\n        assert_eq!(last_key, Some(\"key2\"));\n    }\n\n    #[test]\n    fn test_last_with_empty() {\n        let map: IndexMap<String, String> = IndexMap::new();\n        let last_key: Option<String> = map.into_keys().last();\n        assert_eq!(last_key, None);\n    }\n}\n```", "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_keys_next() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut keys = map.clone().into_keys();\n\n        assert_eq!(keys.next(), Some(1));\n        assert_eq!(keys.next(), Some(2));\n        assert_eq!(keys.next(), Some(3));\n        assert_eq!(keys.next(), None);\n    }\n\n    #[test]\n    fn test_into_keys_next_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let mut keys = map.into_keys();\n\n        assert_eq!(keys.next(), None);\n    }\n\n    #[test]\n    fn test_into_keys_next_default() {\n        let mut keys: IntoKeys<i32, &str> = IntoKeys::default();\n        \n        assert_eq!(keys.next(), None);\n    }\n}\n```", "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Make sure to bring the necessary items into scope\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        \n        let mut keys_iter = map.into_keys();\n        \n        // Test accessing 0th index\n        assert_eq!(keys_iter.nth(0), Some(1));\n        \n        // Test accessing 1st index\n        assert_eq!(keys_iter.nth(0), Some(2));\n        \n        // Test accessing 2nd index\n        assert_eq!(keys_iter.nth(0), Some(3));\n        \n        // Test accessing out of bounds\n        assert_eq!(keys_iter.nth(0), None);\n    }\n}\n```", "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let keys: map::iter::IntoKeys<i32, i32> = map.into_keys();\n        let (lower, upper) = keys.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, None);\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let keys: map::iter::IntoKeys<i32, i32> = map.into_keys();\n        let (lower, upper) = keys.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n\n    #[test]\n    fn test_size_hint_after_consuming_some() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let mut keys: map::iter::IntoKeys<i32, i32> = map.into_keys();\n        keys.next(); // Consume one key\n        let (lower, upper) = keys.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n    }\n}\n```", "<map::iter::IntoValues<K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::map::iter::IntoValues;\n\n    #[test]\n    fn test_into_values_default() {\n        let default_values: IntoValues<i32, String> = IntoValues::default();\n        assert_eq!(default_values.len(), 0);\n    }\n}\n```", "<map::iter::IntoValues<K, V> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use indexmap::map::iter::IntoValues;\n\n    #[test]\n    fn test_next_back() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let mut values_iter: IntoValues<i32, &str> = map.into_values();\n        \n        assert_eq!(values_iter.next_back(), Some(\"three\"));\n        assert_eq!(values_iter.next_back(), Some(\"two\"));\n        assert_eq!(values_iter.next_back(), Some(\"one\"));\n        assert_eq!(values_iter.next_back(), None);\n    }\n}\n```", "<map::iter::IntoValues<K, V> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_back() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut values = map.into_values();\n        \n        assert_eq!(values.nth_back(0), Some(\"c\"));\n        assert_eq!(values.nth_back(1), Some(\"b\"));\n        assert_eq!(values.nth_back(2), Some(\"a\"));\n        assert_eq!(values.nth_back(3), None);\n    }\n}\n```", "<map::iter::IntoValues<K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_len() {\n        let mut index_map = IndexMap::new();\n        index_map.insert(\"one\", 1);\n        index_map.insert(\"two\", 2);\n        index_map.insert(\"three\", 3);\n        \n        let into_values = IntoValues::new(index_map.into_values().collect::<Vec<_>>());\n        \n        assert_eq!(into_values.len(), 3);\n        \n        // Test with an empty IndexMap\n        let empty_into_values: IntoValues<&str, i32> = IntoValues::default();\n        assert_eq!(empty_into_values.len(), 0);\n    }\n}\n```", "<map::iter::IntoValues<K, V> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_from_indexmap_into_vec() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let collected: Vec<(i32, &str)> = map.into_values().collect();\n        let expected: Vec<(i32, &str)> = vec![(1, \"one\"), (2, \"two\"), (3, \"three\")];\n        \n        assert_eq!(collected.len(), expected.len());\n        for (k, v) in expected {\n            assert!(collected.contains(&(k, v)));\n        }\n    }\n\n    #[test]\n    fn test_collect_empty_indexmap() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let collected: Vec<(i32, &str)> = map.into_values().collect();\n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_collect_from_indexmap_into_another_indexmap() {\n        let mut map1 = IndexMap::new();\n        map1.insert(1, \"one\");\n        map1.insert(2, \"two\");\n\n        let collected: IndexMap<i32, &str> = map1.into_values().collect();\n        \n        assert_eq!(collected.len(), 2);\n        assert_eq!(collected[&1], \"one\");\n        assert_eq!(collected[&2], \"two\");\n    }\n}\n```", "<map::iter::IntoValues<K, V> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_count() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let values = map.clone().into_values();\n        assert_eq!(values.count(), 3);\n\n        let empty_map: IndexMap<i32, &str> = IndexMap::new();\n        let empty_values = empty_map.into_values();\n        assert_eq!(empty_values.count(), 0);\n    }\n}\n```", "<map::iter::IntoValues<K, V> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last_with_values() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let values = map.into_values();\n        let last_value = values.last();\n        \n        assert_eq!(last_value, Some(3));\n    }\n\n    #[test]\n    fn test_last_on_empty() {\n        let map: IndexMap<String, i32> = IndexMap::new();\n        \n        let values = map.into_values();\n        let last_value = values.last();\n        \n        assert_eq!(last_value, None);\n    }\n\n    #[test]\n    fn test_last_with_one_value() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 42);\n\n        let values = map.into_values();\n        let last_value = values.last();\n        \n        assert_eq!(last_value, Some(42));\n    }\n}\n```", "<map::iter::IntoValues<K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next() {\n        let mut index_map = IndexMap::new();\n        index_map.insert(\"key1\", \"value1\");\n        index_map.insert(\"key2\", \"value2\");\n        let mut into_values = IntoValues::new(index_map.into_iter().map(|(_, v)| v).collect());\n\n        assert_eq!(into_values.next(), Some(\"value1\"));\n        assert_eq!(into_values.next(), Some(\"value2\"));\n        assert_eq!(into_values.next(), None);\n    }\n}\n```", "<map::iter::IntoValues<K, V> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n\n        let values_iter = map.clone().into_values();\n\n        assert_eq!(values_iter.clone().nth(0), Some(1));\n        assert_eq!(values_iter.clone().nth(1), Some(2));\n        assert_eq!(values_iter.clone().nth(2), Some(3));\n        assert_eq!(values_iter.clone().nth(3), None);\n    }\n\n    #[test]\n    fn test_nth_empty() {\n        let map: IndexMap<&str, i32> = IndexMap::new();\n        let values_iter = map.into_values();\n\n        assert_eq!(values_iter.nth(0), None);\n    }\n}\n```", "<map::iter::IntoValues<K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: IndexMap<u32, u32> = IndexMap::new();\n        let into_values = map.into_values();\n        assert_eq!(into_values.size_hint(), (0, None));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut map: IndexMap<u32, u32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let into_values = map.into_values();\n        assert_eq!(into_values.size_hint(), (2, Some(2)));\n    }\n}\n```", "<map::iter::Iter<'_, K, V> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap; // Assuming Bucket and required types are implemented\n    use indexmap::IndexMap; // Import necessary indexmap types\n\n    #[test]\n    fn test_iter_clone() {\n        // Create an IndexMap and an iterator from it\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        \n        let iter = map.iter();\n        \n        // Clone the iterator\n        let cloned_iter = iter.clone();\n        \n        // Check that the cloned iterator has the same length as the original\n        assert_eq!(iter.len(), cloned_iter.len());\n\n        // Check that both iterators produce the same items\n        for (key, value) in iter {\n            assert_eq!(cloned_iter.next(), Some((&key, &value)));\n        }\n    }\n}\n```", "<map::iter::Iter<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::Iter;\n\n    #[test]\n    fn test_iter_default() {\n        let default_iter: Iter<i32, i32> = Iter::default();\n        assert_eq!(default_iter.len(), 0);\n    }\n}\n```", "<map::iter::Iter<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_back() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        map.insert(\"key3\", \"value3\");\n\n        let mut iter = map.iter();\n        \n        // Call next_back and check the value\n        assert_eq!(iter.next_back(), Some((&\"key3\", &\"value3\")));\n        assert_eq!(iter.next_back(), Some((&\"key2\", &\"value2\")));\n        assert_eq!(iter.next_back(), Some((&\"key1\", &\"value1\")));\n        assert_eq!(iter.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_on_empty() {\n        let mut map: IndexMap<&str, &str> = IndexMap::new();\n        let mut iter = map.iter();\n\n        // Calling next_back on an empty iterator\n        assert_eq!(iter.next_back(), None);\n    }\n}\n```", "<map::iter::Iter<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_back() {\n        let mut map: IndexMap<usize, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let mut iter = map.iter();\n        assert_eq!(iter.nth_back(0), Some((&3, &\"three\")));\n        assert_eq!(iter.nth_back(1), Some((&2, &\"two\")));\n        assert_eq!(iter.nth_back(2), Some((&1, &\"one\")));\n        assert_eq!(iter.nth_back(3), None);\n    }\n\n    #[test]\n    fn test_nth_back_empty() {\n        let mut map: IndexMap<usize, &str> = IndexMap::new();\n        let mut iter = map.iter();\n        assert_eq!(iter.nth_back(0), None);\n    }\n\n    #[test]\n    fn test_nth_back_single_element() {\n        let mut map: IndexMap<usize, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n\n        let mut iter = map.iter();\n        assert_eq!(iter.nth_back(0), Some((&1, &\"one\")));\n        assert_eq!(iter.nth_back(1), None);\n    }\n}\n```", "<map::iter::Iter<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap; // Adjust the import based on the actual path of the `IndexMap`\n\n    #[test]\n    fn test_len() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        let iter = map.iter();\n        assert_eq!(iter.len(), 2);\n\n        // Testing with an empty map\n        let empty_iter = IndexMap::<i32, i32>::new().iter();\n        assert_eq!(empty_iter.len(), 0);\n    }\n}\n```", "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_indexmap() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        // Collect into a new IndexMap from existing map's iterator.\n        let collected: IndexMap<i32, &str> = map.iter().collect();\n\n        assert_eq!(collected.len(), 3);\n        assert_eq!(collected[&1], \"one\");\n        assert_eq!(collected[&2], \"two\");\n        assert_eq!(collected[&3], \"three\");\n    }\n\n    #[test]\n    fn test_collect_empty_indexmap() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n\n        // Collect into a new IndexMap from an empty map's iterator.\n        let collected: IndexMap<i32, &str> = map.iter().collect();\n\n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_collect_from_iterator() {\n        let initial_data = vec![(1, \"one\"), (2, \"two\"), (3, \"three\")];\n        let collected: IndexMap<i32, &str> = initial_data.into_iter().collect();\n\n        assert_eq!(collected.len(), 3);\n        assert_eq!(collected[&1], \"one\");\n        assert_eq!(collected[&2], \"two\");\n        assert_eq!(collected[&3], \"three\");\n    }\n}\n```", "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::indexmap::IndexMap;\n\n    #[test]\n    fn test_count_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let iter = map.iter();\n        assert_eq!(iter.count(), 0);\n    }\n\n    #[test]\n    fn test_count_single() {\n        let mut map = IndexMap::new();\n        map.insert(1, 2);\n        let iter = map.iter();\n        assert_eq!(iter.count(), 1);\n    }\n\n    #[test]\n    fn test_count_multiple() {\n        let mut map = IndexMap::new();\n        map.insert(1, 2);\n        map.insert(3, 4);\n        map.insert(5, 6);\n        let iter = map.iter();\n        assert_eq!(iter.count(), 3);\n    }\n\n    #[test]\n    fn test_count_after_consuming() {\n        let mut map = IndexMap::new();\n        map.insert(1, 2);\n        map.insert(3, 4);\n        let mut iter = map.iter();\n        assert_eq!(iter.next(), Some((&1, &2)));\n        assert_eq!(iter.count(), 1);\n    }\n}\n```", "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n        \n        let mut iter = map.iter();\n        \n        assert_eq!(iter.last(), Some((&\"key3\", &3)));\n        assert_eq!(iter.last(), None); // Ensure that last doesn't change after being called\n    }\n\n    #[test]\n    fn test_last_empty() {\n        let map: IndexMap<&str, i32> = IndexMap::new();\n        let mut iter = map.iter();\n        \n        assert_eq!(iter.last(), None);\n    }\n}\n```", "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let mut iter = map.iter();\n\n        assert_eq!(iter.next(), Some((&\"key1\", &\"value1\")));\n        assert_eq!(iter.next(), Some((&\"key2\", &\"value2\")));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let map: IndexMap<&str, &str> = IndexMap::new();\n        let mut iter = map.iter();\n\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut iter = map.iter();\n        \n        assert_eq!(iter.nth(0), Some((&\"a\", &1)));\n        assert_eq!(iter.nth(1), Some((&\"b\", &2)));\n        assert_eq!(iter.nth(1), Some((&\"c\", &3)));\n        assert_eq!(iter.nth(1), None);\n    }\n\n    #[test]\n    fn test_nth_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        let mut iter = map.iter();\n        \n        assert_eq!(iter.nth(10), None);\n    }\n\n    #[test]\n    fn test_nth_multiple_calls() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        let mut iter = map.iter();\n        \n        assert_eq!(iter.nth(0), Some((&\"a\", &1)));\n        assert_eq!(iter.nth(0), Some((&\"b\", &2)));\n        assert_eq!(iter.nth(0), None);\n    }\n}\n```", "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let iter = map.iter();\n        let hint = iter.size_hint();\n        assert_eq!(hint, (0, Some(0))); // Empty map should return (0, Some(0))\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let iter = map.iter();\n        let hint = iter.size_hint();\n        assert_eq!(hint, (2, Some(2))); // Map with two entries should return (2, Some(2))\n    }\n\n    #[test]\n    fn test_size_hint_after_iteration() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let mut iter = map.iter();\n        let hint_before = iter.size_hint();\n        iter.next(); // Consume one item\n        let hint_after = iter.size_hint();\n        assert_eq!(hint_before, (2, Some(2))); // Before consuming\n        assert_eq!(hint_after, (1, Some(1))); // After consuming one item\n    }\n}\n```", "<map::iter::IterMut2<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::map::iter::IterMut2;\n\n    #[test]\n    fn test_default_iter_mut2() {\n        let iter: IterMut2<i32, i32> = IterMut2::default();\n        assert_eq!(iter.len(), 0);\n    }\n}\n```", "<map::iter::IterMut2<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_back() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        \n        let mut iter = map.iter_mut2();\n        \n        assert_eq!(iter.next_back(), Some((&mut 3, &mut 30)));\n        assert_eq!(iter.next_back(), Some((&mut 2, &mut 20)));\n        assert_eq!(iter.next_back(), Some((&mut 1, &mut 10)));\n        assert_eq!(iter.next_back(), None);\n    }\n}\n```", "<map::iter::IterMut2<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_back() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        \n        let mut iter = map.iter_mut2();\n\n        assert_eq!(iter.nth_back(0), Some((&mut 3, &mut \"three\")));\n        assert_eq!(iter.nth_back(1), Some((&mut 2, &mut \"two\")));\n        assert_eq!(iter.nth_back(2), Some((&mut 1, &mut \"one\")));\n        assert_eq!(iter.nth_back(3), None);\n    }\n}\n```", "<map::iter::IterMut2<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::IterMut2;\n    use crate::map::Bucket;\n\n    #[test]\n    fn test_len() {\n        let mut buckets: [Bucket<i32, i32>; 3] = [\n            Bucket::new(i32, i32),  // Replace with appropriate Bucket initialization\n            Bucket::new(i32, i32),  // Replace with appropriate Bucket initialization\n            Bucket::new(i32, i32),  // Replace with appropriate Bucket initialization\n        ];\n\n        let iter = IterMut2::new(&mut buckets);\n\n        assert_eq!(iter.len(), 3);  // Test the length of the iterator\n    }\n\n    #[test]\n    fn test_len_empty() {\n        let mut buckets: [Bucket<i32, i32>; 0] = [];  // empty array\n\n        let iter = IterMut2::new(&mut buckets);\n\n        assert_eq!(iter.len(), 0);  // Test the length of the empty iterator\n    }\n}\n```", "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn collect_from_empty_iterator() {\n        let iter: Vec<(i32, &str)> = vec![];\n        let map: IndexMap<i32, &str> = iter.into_iter().collect();\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn collect_from_iterator() {\n        let iter = vec![(1, \"one\"), (2, \"two\"), (3, \"three\")];\n        let map: IndexMap<i32, &str> = iter.into_iter().collect();\n        assert_eq!(map.len(), 3);\n        assert_eq!(map[&1], \"one\");\n        assert_eq!(map[&2], \"two\");\n        assert_eq!(map[&3], \"three\");\n    }\n\n    #[test]\n    fn collect_with_duplicate_keys() {\n        let iter = vec![(1, \"one\"), (2, \"two\"), (1, \"uno\")];\n        let map: IndexMap<i32, &str> = iter.into_iter().collect();\n        assert_eq!(map.len(), 2);\n        assert_eq!(map[&1], \"uno\");  // The last value should prevail\n        assert_eq!(map[&2], \"two\");\n    }\n}\n```", "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_count() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut iter = map.iter_mut();\n        let count = iter.count();\n        assert_eq!(count, 3);\n    }\n\n    #[test]\n    fn test_count_empty() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        let mut iter = map.iter_mut();\n        let count = iter.count();\n        assert_eq!(count, 0);\n    }\n}\n```", "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_iter_mut2_last() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let mut iter = map.iter_mut2();\n        let last_item = iter.last();\n\n        assert_eq!(last_item, Some((&mut 3, &mut \"c\")));\n        assert_eq!(iter.len(), 2);  // Ensure the iterator length decreases\n    }\n\n    #[test]\n    fn test_iter_mut2_last_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        \n        let mut iter = map.iter_mut2();\n        let last_item = iter.last();\n\n        assert_eq!(last_item, None);  // Should be None for empty iterator\n    }\n}\n```", "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::{IndexMap, Bucket};\n\n    #[test]\n    fn test_iter_mut2_next() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let mut iter = map.iter_mut2();\n\n        // Test the first call to next\n        let item = iter.next();\n        assert!(item.is_some());\n        let (key, value) = item.unwrap();\n        assert_eq!(*key, 1);\n        assert_eq!(*value, 10);\n\n        // Test the second call to next\n        let item = iter.next();\n        assert!(item.is_some());\n        let (key, value) = item.unwrap();\n        assert_eq!(*key, 2);\n        assert_eq!(*value, 20);\n\n        // Test the third call to next\n        let item = iter.next();\n        assert!(item.is_some());\n        let (key, value) = item.unwrap();\n        assert_eq!(*key, 3);\n        assert_eq!(*value, 30);\n\n        // Test that there are no more items\n        let item = iter.next();\n        assert!(item.is_none());\n    }\n}\n```", "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut iter = map.iter_mut().iter_mut2();\n        \n        // Test nth(0)\n        let first = iter.nth(0);\n        assert_eq!(first, Some((&mut \"a\", &mut 1)));\n        \n        // Test nth(1)\n        let second = iter.nth(1);\n        assert_eq!(second, Some((&mut \"b\", &mut 2)));\n        \n        // Test nth(2)\n        let third = iter.nth(2);\n        assert_eq!(third, Some((&mut \"c\", &mut 3)));\n        \n        // Test nth(3) (out of bounds)\n        let none = iter.nth(3);\n        assert_eq!(none, None);\n    }\n}\n```", "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        let mut iter = map.iter_mut2();\n        let (lower, upper) = iter.size_hint();\n        \n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n        \n        iter.next(); // Consume one element\n        let (lower_after) = iter.size_hint();\n        \n        assert_eq!(lower_after.0, 1);\n        assert_eq!(lower_after.1, Some(1));\n        \n        iter.next(); // Consume last element\n        let (lower_empty) = iter.size_hint();\n        \n        assert_eq!(lower_empty.0, 0);\n        assert_eq!(lower_empty.1, Some(0));\n    }\n}\n```", "<map::iter::IterMut<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::IterMut;\n\n    #[test]\n    fn test_iter_mut_default() {\n        let default_iter: IterMut<i32, i32> = Default::default();\n        assert_eq!(default_iter.len(), 0);\n    }\n}\n```", "<map::iter::IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_back() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let mut iter = map.iter_mut();\n        \n        // Call next_back and check the last element\n        assert_eq!(iter.next_back(), Some((&3, &mut 30)));\n        // Call next_back and check the second last element\n        assert_eq!(iter.next_back(), Some((&2, &mut 20)));\n        // Call next_back and check the first element\n        assert_eq!(iter.next_back(), Some((&1, &mut 10)));\n        // Call next_back and check that there are no more elements\n        assert_eq!(iter.next_back(), None);\n    }\n}\n```", "<map::iter::IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_back() {\n        // Create an IndexMap\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        // Create an IterMut of the map\n        let mut iter = map.iter_mut();\n        \n        // Test nth_back with different values of n\n        assert_eq!(iter.nth_back(0), Some((&\"c\", &mut 3)));\n        assert_eq!(iter.nth_back(1), Some((&\"b\", &mut 2)));\n        assert_eq!(iter.nth_back(2), Some((&\"a\", &mut 1)));\n        assert_eq!(iter.nth_back(3), None); // Out of bounds\n    }\n}\n```", "<map::iter::IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_iter_mut_len() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let mut iter_mut = map.iter_mut();\n        assert_eq!(iter_mut.len(), 3);\n\n        let _ = iter_mut.next();\n        assert_eq!(iter_mut.len(), 2);\n\n        let _ = iter_mut.next();\n        assert_eq!(iter_mut.len(), 1);\n\n        let _ = iter_mut.next();\n        assert_eq!(iter_mut.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_mut_len_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let iter_mut = map.iter_mut();\n        assert_eq!(iter_mut.len(), 0);\n    }\n}\n```", "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_from_iterator() {\n        let mut map = IndexMap::new();\n        let items = vec![(1, \"one\"), (2, \"two\"), (3, \"three\")];\n        \n        let collected: IndexMap<_, _> = items.iter().map(|&(k, v)| (k, v)).collect();\n        \n        map.extend(collected);\n        \n        assert_eq!(map.len(), 3);\n        assert_eq!(map[&1], \"one\");\n        assert_eq!(map[&2], \"two\");\n        assert_eq!(map[&3], \"three\");\n    }\n\n    #[test]\n    fn test_collect_empty() {\n        let items: Vec<(i32, &str)> = Vec::new();\n        let collected: IndexMap<_, _> = items.into_iter().collect();\n        \n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_collect_duplicates() {\n        let items = vec![(1, \"one\"), (1, \"uno\"), (2, \"two\")];\n        let collected: IndexMap<_, _> = items.into_iter().collect();\n        \n        assert_eq!(collected.len(), 2);\n        assert_eq!(collected[&1], \"uno\"); // last one should prevail\n    }\n}\n```", "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_count() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut iter_mut = map.iter_mut();\n        \n        assert_eq!(iter_mut.count(), 3);\n        \n        let mut empty_iter = IndexMap::<&str, i32>::new().iter_mut();\n        \n        assert_eq!(empty_iter.count(), 0);\n    }\n}\n```", "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_iter_mut_last() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut iter = map.iter_mut();\n        assert_eq!(iter.last(), Some((&\"c\", &mut 3)));\n\n        // Verify that last() leaves the iterator in a state that allows further iteration\n        assert_eq!(iter.next(), Some((&\"a\", &mut 1)));\n        assert_eq!(iter.next(), Some((&\"b\", &mut 2)));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_mut_last_empty() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        let mut iter = map.iter_mut();\n        assert_eq!(iter.last(), None);\n    }\n}\n```", "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n\n        let mut iter = map.iter_mut();\n\n        // Check the first item\n        if let Some((key, value)) = iter.next() {\n            assert_eq!(*key, \"key1\");\n            *value += 1; // Mutate the value\n        } else {\n            panic!(\"Expected a value, but got None\");\n        }\n\n        // Check the second item\n        if let Some((key, value)) = iter.next() {\n            assert_eq!(*key, \"key2\");\n            *value += 2; // Mutate the value\n        } else {\n            panic!(\"Expected a value, but got None\");\n        }\n\n        // Check that the iterator is exhausted\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        let mut iter = map.iter_mut();\n\n        // Check that the iterator is None for an empty map\n        assert!(iter.next().is_none());\n    }\n}\n```", "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_iter_mut_nth() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n\n        let mut iter = map.iter_mut();\n        \n        let first = iter.nth(0);\n        let second = iter.nth(0);\n        let third = iter.nth(0);\n        let none = iter.nth(0);\n\n        assert_eq!(first, Some((&\"key1\", &mut 1)));\n        assert_eq!(second, Some((&\"key2\", &mut 2)));\n        assert_eq!(third, Some((&\"key3\", &mut 3)));\n        assert_eq!(none, None);\n    }\n}\n```", "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        let mut iter = map.iter_mut();\n        \n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n        \n        iter.next(); // consume one element\n        \n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n        \n        iter.next(); // consume the last element\n        \n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```", "<map::iter::Keys<'_, K, V> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::{IndexMap, indexmap};\n    \n    #[test]\n    fn test_clone_keys() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        \n        let keys = map.keys();\n        let cloned_keys = keys.clone();\n        \n        assert_eq!(keys.len(), cloned_keys.len());\n        for (key, cloned_key) in keys.zip(cloned_keys) {\n            assert_eq!(key, cloned_key);\n        }\n    }\n}\n```", "<map::iter::Keys<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_keys_default() {\n        // Create a default instance of Keys\n        let keys: Keys<u32, u32> = Keys::default();\n        \n        // Since it is default, it should be an empty iterator\n        assert_eq!(keys.len(), 0);\n\n        // The iterator should be fused, and thus should return None on calling next after exhaustion\n        let mut it = keys.clone();\n        assert!(it.next().is_none());\n    }\n}\n```", "<map::iter::Keys<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_back() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut keys = map.keys();\n        assert_eq!(keys.next_back(), Some(&\"c\"));\n        assert_eq!(keys.next_back(), Some(&\"b\"));\n        assert_eq!(keys.next_back(), Some(&\"a\"));\n        assert_eq!(keys.next_back(), None);\n    }\n}\n```", "<map::iter::Keys<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_back() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let keys = map.keys();\n\n        assert_eq!(keys.clone().nth_back(0), Some(&\"c\"));\n        assert_eq!(keys.clone().nth_back(1), Some(&\"b\"));\n        assert_eq!(keys.clone().nth_back(2), Some(&\"a\"));\n        assert_eq!(keys.clone().nth_back(3), None);\n    }\n}\n```", "<map::iter::Keys<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_keys_len() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        let keys = map.keys();\n\n        assert_eq!(keys.len(), 2);\n\n        map.insert(\"c\", 3);\n        let keys = map.keys();\n\n        assert_eq!(keys.len(), 3);\n\n        map.remove(\"a\");\n        let keys = map.keys();\n\n        assert_eq!(keys.len(), 2);\n\n        let empty_map: IndexMap<&str, i32> = IndexMap::new();\n        let empty_keys = empty_map.keys();\n        assert_eq!(empty_keys.len(), 0);\n    }\n}\n```", "<map::iter::Keys<'_, K, V> as core::ops::Index<usize>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index() {\n        let mut map: IndexMap<u32, u32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let keys = map.keys();\n\n        assert_eq!(keys[0], &1);\n        assert_eq!(keys[1], &2);\n        assert_eq!(keys[2], &3);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_out_of_bounds() {\n        let mut map: IndexMap<u32, u32> = IndexMap::new();\n        map.insert(1, 10);\n        let keys = map.keys();\n\n        // This should panic since there is only one key\n        let _ = keys[1];\n    }\n}\n```", "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_keys() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"value1\");\n        map.insert(2, \"value2\");\n        map.insert(3, \"value3\");\n\n        let keys: Vec<_> = map.keys().collect();\n        assert_eq!(keys, vec![&1, &2, &3]);\n    }\n\n    #[test]\n    fn test_collect_entries() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"value1\");\n        map.insert(2, \"value2\");\n\n        let entries: Vec<_> = map.iter().collect();\n        assert_eq!(entries, vec![(&1, &\"value1\"), (&2, &\"value2\")]);\n    }\n\n    #[test]\n    fn test_collect_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let entries: Vec<_> = map.iter().collect();\n        assert!(entries.is_empty());\n    }\n\n    #[test]\n    fn test_collect_after_insert() {\n        let mut map = IndexMap::new();\n        map.insert(4, \"value4\");\n        map.insert(5, \"value5\");\n\n        let entries: Vec<_> = map.iter().collect();\n        assert_eq!(entries, vec![(&4, &\"value4\"), (&5, &\"value5\")]);\n    }\n\n    #[test]\n    fn test_collect_with_updates() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"value1\");\n        map.insert(2, \"value2\");\n        map.insert(1, \"new_value1\");\n\n        let entries: Vec<_> = map.iter().collect();\n        assert_eq!(entries, vec![(&1, &\"new_value1\"), (&2, &\"value2\")]);\n    }\n\n    #[test]\n    fn test_collect_with_removal() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"value1\");\n        map.insert(2, \"value2\");\n        map.remove(&1);\n\n        let keys: Vec<_> = map.keys().collect();\n        assert_eq!(keys, vec![&2]);\n    }\n}\n```", "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn count_empty_keys() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let keys = map.keys();\n        assert_eq!(keys.count(), 0);\n    }\n\n    #[test]\n    fn count_non_empty_keys() {\n        let mut map = IndexMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        let keys = map.keys();\n        assert_eq!(keys.count(), 2);\n    }\n\n    #[test]\n    fn count_keys_with_duplicate_insertions() {\n        let mut map = IndexMap::new();\n        map.insert(1, 100);\n        map.insert(1, 200); // updates the value, does not create a new key\n        let keys = map.keys();\n        assert_eq!(keys.count(), 1);\n    }\n\n    #[test]\n    fn count_keys_after_removal() {\n        let mut map = IndexMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        map.remove(&1);\n        let keys = map.keys();\n        assert_eq!(keys.count(), 1);\n    }\n}\n```", "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last_with_elements() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        let keys: Vec<_> = map.keys().collect();\n        let last_key = keys.last();\n        assert_eq!(last_key, Some(&\"c\"));\n    }\n\n    #[test]\n    fn test_last_empty() {\n        let map: IndexMap<String, i32> = IndexMap::new();\n        let keys: Vec<_> = map.keys().collect();\n        let last_key = keys.last();\n        assert_eq!(last_key, None);\n    }\n\n    #[test]\n    fn test_last_after_removing() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.remove(\"a\");\n        let keys: Vec<_> = map.keys().collect();\n        let last_key = keys.last();\n        assert_eq!(last_key, Some(&\"b\"));\n    }\n}\n```", "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Ensure to import the necessary items from the scope\n    use indexmap::IndexMap; // Import IndexMap from the indexmap crate\n\n    #[test]\n    fn test_keys_next() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n\n        let keys = map.keys();\n        let mut keys_iter = keys.clone(); // Clone to avoid consuming the iterator\n\n        assert_eq!(keys_iter.next(), Some(&\"key1\"));\n        assert_eq!(keys_iter.next(), Some(&\"key2\"));\n        assert_eq!(keys_iter.next(), Some(&\"key3\"));\n        assert_eq!(keys_iter.next(), None); // Should return None after iterating through all keys\n    }\n\n    #[test]\n    fn test_keys_next_empty() {\n        let map: IndexMap<&str, i32> = IndexMap::new();\n        let keys_iter = map.keys();\n\n        let mut empty_keys_iter = keys_iter.clone(); // Clone to avoid consuming the iterator\n\n        assert_eq!(empty_keys_iter.next(), None); // Should return None since the map is empty\n    }\n}\n```", "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let keys = map.keys();\n        assert_eq!(keys.nth(0), Some(&\"a\"));\n        assert_eq!(keys.nth(1), Some(&\"b\"));\n        assert_eq!(keys.nth(2), Some(&\"c\"));\n        assert_eq!(keys.nth(3), None);\n    }\n\n    #[test]\n    fn test_nth_after_exceeding() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        \n        let mut keys = map.keys();\n        keys.nth(0); // Move to first element\n        assert_eq!(keys.nth(1), None); // Should return None after exceeding the number of keys\n    }\n\n    #[test]\n    fn test_nth_empty() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        \n        let keys = map.keys();\n        assert_eq!(keys.nth(0), None); // No keys in the map\n    }\n}\n```", "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let keys = map.keys();\n        assert_eq!(keys.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let keys = map.keys();\n        assert_eq!(keys.size_hint(), (2, Some(2)));\n    }\n\n    #[test]\n    fn test_size_hint_after_removal() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.remove(&1);\n        let keys = map.keys();\n        assert_eq!(keys.size_hint(), (1, Some(1)));\n    }\n}\n```", "<map::iter::Splice<'_, I, K, V, S> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_back() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut splice = map.splice(1..3, vec![(4, \"d\"), (5, \"e\")]);\n        \n        assert_eq!(splice.next_back(), Some((3, \"c\")));\n        assert_eq!(splice.next_back(), Some((2, \"b\")));\n        assert_eq!(splice.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        let mut splice = map.splice(0..0, vec![]);\n\n        assert_eq!(splice.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_single_item() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n\n        let mut splice = map.splice(0..1, vec![(2, \"b\")]);\n        \n        assert_eq!(splice.next_back(), Some((1, \"a\")));\n        assert_eq!(splice.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_multiple_items() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        map.insert(4, \"d\");\n        \n        let mut splice = map.splice(0..2, vec![(5, \"e\"), (6, \"f\")]);\n        \n        assert_eq!(splice.next_back(), Some((2, \"b\")));\n        assert_eq!(splice.next_back(), Some((1, \"a\")));\n        assert_eq!(splice.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_with_replacement() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        let mut splice = map.splice(0..2, vec![(3, \"c\"), (4, \"d\")]);\n\n        assert_eq!(splice.next_back(), Some((2, \"b\")));\n        assert_eq!(splice.next_back(), Some((1, \"a\")));\n        assert_eq!(splice.next_back(), None);\n        \n        let entries: Vec<_> = map.iter().collect();\n        assert_eq!(entries, vec![(&3, &\"c\"), (&4, &\"d\")]);\n    }\n}\n```", "<map::iter::Splice<'_, I, K, V, S> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_len() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        assert_eq!(map.len(), 0);\n\n        map.insert(1, 10);\n        assert_eq!(map.len(), 1);\n\n        map.insert(2, 20);\n        assert_eq!(map.len(), 2);\n\n        map.remove(&1);\n        assert_eq!(map.len(), 1);\n        \n        map.clear();\n        assert_eq!(map.len(), 0);\n    }\n}\n```", "<map::iter::Splice<'_, I, K, V, S> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_on_splice() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        \n        let mut splice = map.splice(1..2, vec![(4, 40), (5, 50)]);\n        assert_eq!(splice.next(), Some((2, 20)));\n        assert_eq!(splice.next(), Some((3, 30)));\n        assert_eq!(splice.next(), None);\n        \n        assert!(map.contains_key(&1));\n        assert!(map.contains_key(&4));\n        assert!(map.contains_key(&5));\n        assert!(!map.contains_key(&2));\n        assert!(!map.contains_key(&3));\n    }\n\n    #[test]\n    fn test_next_empty_splice() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let mut splice = map.splice(0..0, vec![]);\n        assert_eq!(splice.next(), None);\n    }\n\n    #[test]\n    fn test_next_on_splice_with_empty_replace() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        let mut splice = map.splice(0..1, vec![]);\n        assert_eq!(splice.next(), Some((1, 10)));\n        assert_eq!(splice.next(), None);\n        \n        assert!(!map.contains_key(&1));\n        assert!(map.contains_key(&2));\n    }\n}\n```", "<map::iter::Splice<'_, I, K, V, S> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let iter = map.iter().splice(0..0, vec![]); // Creating a Splice iterator with an empty map\n        assert_eq!(iter.size_hint(), (0, Some(0))); // Expect (0, Some(0)) for an empty map\n    }\n\n    #[test]\n    fn test_size_hint_single() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        let iter = map.iter().splice(0..1, vec![(2, 20)]); // Splice to replace\n        assert_eq!(iter.size_hint(), (1, Some(1))); // Expect (1, Some(1)) since we insert one item\n    }\n\n    #[test]\n    fn test_size_hint_multiple() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        let iter = map.iter().splice(1..3, vec![(4, 40), (5, 50)]); // Splice for 2 ranges\n        assert_eq!(iter.size_hint(), (2, Some(2))); // Expect (2, Some(2)) since we replace 2 items\n    }\n\n    #[test]\n    fn test_size_hint_no_replacements() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        let iter = map.iter().splice(0..1, vec![]); // Splice with no replacements\n        assert_eq!(iter.size_hint(), (1, Some(0))); // Expect (1, Some(0)) because we are still iterating one item\n    }\n}\n```", "<map::iter::Splice<'_, I, K, V, S> as core::ops::Drop>::drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_splice_drop() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        {\n            let repl = vec![(4, \"d\"), (5, \"e\")];\n            let mut splice = map.splice(1..2, repl);\n\n            assert_eq!(splice.collect::<Vec<_>>(), vec![(2, \"b\")]);\n        }\n\n        // After dropping splice, the changes should be reflected in the map\n        assert_eq!(map.get(&1), Some(&\"a\"));\n        assert_eq!(map.get(&4), Some(&\"d\"));\n        assert_eq!(map.get(&5), Some(&\"e\"));\n        assert_eq!(map.get(&3), Some(&\"c\"));\n    }\n\n    #[test]\n    fn test_drop_with_no_elements() {\n        let mut map = IndexMap::new();\n\n        {\n            let repl = vec![(10, \"x\")];\n            let splice = map.splice(0..0, repl);\n            drop(splice);\n            // Nothing should be in the map\n        }\n\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_drop_with_replacing_keys() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        {\n            let repl = vec![(1, \"x\"), (3, \"c\")];\n            let mut splice = map.splice(0..1, repl);\n\n            assert_eq!(splice.collect::<Vec<_>>(), vec![(1, \"a\")]);\n        }\n\n        // After dropping splice, check the map\n        assert_eq!(map.get(&1), Some(&\"x\"));\n        assert_eq!(map.get(&2), Some(&\"b\"));\n        assert_eq!(map.get(&3), Some(&\"c\"));\n    }\n}\n```", "<map::iter::Values<'_, K, V> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_clone_values() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let values = map.values();\n        let cloned_values = values.clone();\n\n        assert_eq!(values.len(), cloned_values.len());\n        assert_eq!(values.collect::<Vec<_>>(), cloned_values.collect::<Vec<_>>());\n    }\n}\n```", "<map::iter::Values<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap; // Assuming you're using the indexmap crate\n\n    #[test]\n    fn test_values_default() {\n        let values: Values<_, _> = Values::default();\n        assert_eq!(values.len(), 0);\n    }\n}\n```", "<map::iter::Values<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_back() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut values = map.values();\n\n        assert_eq!(values.next_back(), Some(&3));\n        assert_eq!(values.next_back(), Some(&2));\n        assert_eq!(values.next_back(), Some(&1));\n        assert_eq!(values.next_back(), None);\n    }\n}\n```", "<map::iter::Values<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_back() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let values = map.values();\n\n        assert_eq!(values.clone().nth_back(0), Some(&3));\n        assert_eq!(values.clone().nth_back(1), Some(&2));\n        assert_eq!(values.clone().nth_back(2), Some(&1));\n        assert_eq!(values.clone().nth_back(3), None);\n    }\n}\n```", "<map::iter::Values<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_values_len() {\n        let mut index_map = IndexMap::new();\n        index_map.insert(\"a\", 1);\n        index_map.insert(\"b\", 2);\n        index_map.insert(\"c\", 3);\n\n        let values = index_map.values();\n        assert_eq!(values.len(), 3);\n\n        index_map.remove(\"b\");\n        let values = index_map.values();\n        assert_eq!(values.len(), 2);\n\n        index_map.clear();\n        let values = index_map.values();\n        assert_eq!(values.len(), 0);\n    }\n}\n```", "<map::iter::Values<'a, K, V> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_from_values() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let values: Vec<_> = map.values().collect();\n        assert_eq!(values, vec![\"one\", \"two\", \"three\"]);\n    }\n\n    #[test]\n    fn test_collect_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let values: Vec<_> = map.values().collect();\n        assert_eq!(values, Vec::<&str>::new());\n    }\n\n    #[test]\n    fn test_collect_single() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n\n        let values: Vec<_> = map.values().collect();\n        assert_eq!(values, vec![\"one\"]);\n    }\n}\n```", "<map::iter::Values<'a, K, V> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_count() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let values_iter = map.values();\n        assert_eq!(values_iter.count(), 3);\n    }\n\n    #[test]\n    fn test_count_empty() {\n        let map: IndexMap<&str, i32> = IndexMap::new();\n        let values_iter = map.values();\n        assert_eq!(values_iter.count(), 0);\n    }\n    \n    #[test]\n    fn test_count_after_cloning() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        \n        let values_iter = map.values();\n        let cloned_iter = values_iter.clone();\n        assert_eq!(values_iter.count(), cloned_iter.count());\n    }\n}\n```", "<map::iter::Values<'a, K, V> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last() {\n        let mut map = IndexMap::new();\n        map.insert(\"one\", 1);\n        map.insert(\"two\", 2);\n        map.insert(\"three\", 3);\n\n        // Create a Values iterator\n        let values_iter = map.values();\n        \n        // Test the `last` method\n        assert_eq!(values_iter.clone().last(), Some(&3));\n        assert_eq!(values_iter.last(), Some(&3));\n    }\n\n    #[test]\n    fn test_last_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        \n        // Create a Values iterator\n        let values_iter = map.values();\n\n        // Test the `last` method on an empty iterator\n        assert_eq!(values_iter.last(), None);\n    }\n}\n```", "<map::iter::Values<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        let values = map.values();\n\n        let mut value_iter = values.clone();\n        assert_eq!(value_iter.next(), Some(&1));\n        assert_eq!(value_iter.next(), Some(&2));\n        assert_eq!(value_iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let map: IndexMap<String, i32> = IndexMap::new();\n        let values = map.values();\n        let mut value_iter = values.clone();\n        \n        assert_eq!(value_iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_after_clone() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        let values = map.values();\n\n        let mut value_iter = values.clone();\n        let first_value = value_iter.next().unwrap();\n        assert_eq!(first_value, &1);\n\n        let mut value_iter_clone = value_iter.clone();\n        let second_value = value_iter_clone.next().unwrap();\n        assert_eq!(second_value, &2);\n    }\n}\n```", "<map::iter::Values<'a, K, V> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_valid() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let values = map.values();\n        assert_eq!(values.clone().nth(0), Some(&1));\n        assert_eq!(values.clone().nth(1), Some(&2));\n        assert_eq!(values.clone().nth(2), Some(&3));\n    }\n\n    #[test]\n    fn test_nth_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        \n        let values = map.values();\n        assert_eq!(values.clone().nth(3), None);\n    }\n\n    #[test]\n    fn test_nth_on_empty() {\n        let map: IndexMap<&str, i32> = IndexMap::new();\n        let values = map.values();\n        assert_eq!(values.clone().nth(0), None);\n    }\n}\n```", "<map::iter::Values<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        let values = map.values();\n\n        // Testing size_hint with 2 elements\n        let (lower, upper) = values.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n\n        // Testing size_hint with an empty IndexMap\n        let empty_values = IndexMap::<&str, i32>::new().values();\n        let (lower_empty, upper_empty) = empty_values.size_hint();\n        assert_eq!(lower_empty, 0);\n        assert_eq!(upper_empty, Some(0));\n    }\n}\n```", "<map::iter::ValuesMut<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_values_mut_default() {\n        let default_values_mut: ValuesMut<i32, i32> = ValuesMut::default();\n        assert_eq!(default_values_mut.len(), 0);\n    }\n}\n```", "<map::iter::ValuesMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_back() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n\n        let mut values = map.values_mut();\n\n        assert_eq!(values.next_back(), Some(&mut 3));\n        assert_eq!(values.next_back(), Some(&mut 2));\n        assert_eq!(values.next_back(), Some(&mut 1));\n        assert_eq!(values.next_back(), None);\n    }\n}\n```", "<map::iter::ValuesMut<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth_back() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let mut values = map.values_mut();\n        assert_eq!(values.nth_back(0), Some(&mut \"three\"));\n        assert_eq!(values.nth_back(1), Some(&mut \"two\"));\n        assert_eq!(values.nth_back(2), Some(&mut \"one\"));\n        assert_eq!(values.nth_back(3), None);\n    }\n}\n```", "<map::iter::ValuesMut<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust import path if necessary\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_len() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut values_mut = map.values_mut();\n        assert_eq!(values_mut.len(), 3);\n        \n        // Modify one value and check the length again\n        if let Some(value) = values_mut.next() {\n            *value = 10;\n        }\n        assert_eq!(values_mut.len(), 2);\n        \n        // Exhaust iterator\n        let _ = values_mut.next();\n        let _ = values_mut.next();\n        assert_eq!(values_mut.len(), 0);\n    }\n}\n```", "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_into_index_map() {\n        let mut index_map = IndexMap::new();\n        let vec = vec![('a', 1), ('b', 2), ('c', 3)];\n\n        // Collecting values into IndexMap from an iterator\n        index_map.extend(vec.iter().map(|&(k, v)| (k, v)));\n\n        assert_eq!(index_map.len(), 3);\n        assert_eq!(index_map[&'a'], 1);\n        assert_eq!(index_map[&'b'], 2);\n        assert_eq!(index_map[&'c'], 3);\n    }\n\n    #[test]\n    fn test_collect_empty() {\n        let index_map: IndexMap<char, i32> = IndexMap::new();\n        let results: IndexMap<char, i32> = vec![]\n            .into_iter()\n            .collect();\n\n        assert!(results.is_empty());\n    }\n\n    #[test]\n    fn test_collect_duplicates() {\n        let mut index_map = IndexMap::new();\n        let vec = vec![('a', 1), ('a', 2), ('b', 3)];\n\n        index_map.extend(vec.iter().map(|&(k, v)| (k, v)));\n\n        // Last value for 'a' should prevail\n        assert_eq!(index_map[&'a'], 2);\n        assert_eq!(index_map[&'b'], 3);\n        assert_eq!(index_map.len(), 2);\n    }\n}\n```", "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn count_test() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut values_mut = map.values_mut();\n        assert_eq!(values_mut.count(), 3);\n        \n        // Remove one entry\n        map.remove(\"b\");\n\n        // Re-fetch values_mut after the removal\n        let mut values_mut = map.values_mut();\n        assert_eq!(values_mut.count(), 2);\n    }\n}\n```", "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let mut values_mut = map.values_mut();\n        assert_eq!(values_mut.last(), Some(&mut 30));\n\n        // Test after consuming last element\n        assert_eq!(values_mut.next_back(), Some(&mut 30));\n        assert_eq!(values_mut.last(), Some(&mut 20));\n\n        // Test after consuming all elements\n        values_mut.next_back(); // remove 20\n        values_mut.next_back(); // remove 10\n        assert_eq!(values_mut.last(), None);\n    }\n}\n```", "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        \n        let mut values_iter = map.values_mut();\n        \n        // Test that next returns Some mutable references\n        assert_eq!(*values_iter.next().unwrap(), 10);\n        assert_eq!(*values_iter.next().unwrap(), 20);\n        assert_eq!(*values_iter.next().unwrap(), 30);\n        \n        // Test that next returns None after all values have been iterated\n        assert!(values_iter.next().is_none());\n    }\n    \n    #[test]\n    fn test_next_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let mut values_iter = map.values_mut();\n        \n        // Test that next returns None for an empty map\n        assert!(values_iter.next().is_none());\n    }\n}\n```", "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_nth() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n        map.insert(2, \"two\".to_string());\n        map.insert(3, \"three\".to_string());\n\n        let mut values_mut = map.values_mut();\n        \n        // Test nth for existing indexes\n        assert_eq!(values_mut.nth(0), Some(&mut \"one\".to_string()));\n        assert_eq!(values_mut.nth(1), Some(&mut \"two\".to_string()));\n        assert_eq!(values_mut.nth(0), Some(&mut \"three\".to_string()));\n        \n        // Test nth for out of bounds\n        assert_eq!(values_mut.nth(1), None);\n    }\n}\n```", "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let values_mut = map.values_mut();\n        assert_eq!(values_mut.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let values_mut = map.values_mut();\n        assert_eq!(values_mut.size_hint(), (2, Some(2)));\n    }\n\n    #[test]\n    fn test_size_hint_after_mutation() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        {\n            let mut values_mut = map.values_mut();\n            assert_eq!(values_mut.size_hint(), (2, Some(2)));\n            let value = values_mut.next().unwrap();\n            *value += 5;\n        }\n        let values_mut = map.values_mut();\n        assert_eq!(values_mut.size_hint(), (2, Some(2)));\n    }\n\n    #[test]\n    fn test_size_hint_iterate_empty_after_mutation() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let mut values_mut = map.values_mut();\n        assert_eq!(values_mut.size_hint(), (0, Some(0)));\n        values_mut.next();\n        assert_eq!(values_mut.size_hint(), (0, Some(0)));\n    }\n}\n```", "<map::slice::Slice<K, V> as core::cmp::Ord>::cmp": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cmp::Ordering;\n\n    #[derive(Clone, Debug, PartialEq, Eq, Ord)]\n    struct TestKey(usize);\n\n    #[derive(Clone, Debug, PartialEq, Eq, Ord)]\n    struct TestValue(usize);\n\n    #[test]\n    fn test_cmp_equal() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: TestKey(1),\n            value: TestValue(1),\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: TestKey(1),\n            value: TestValue(1),\n        };\n        let slice1 = Slice { entries: [&bucket1, &bucket2] };\n        let slice2 = Slice { entries: [&bucket1, &bucket2] };\n        \n        assert_eq!(slice1.cmp(&slice2), Ordering::Equal);\n    }\n\n    #[test]\n    fn test_cmp_less_than() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: TestKey(1),\n            value: TestValue(1),\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: TestKey(2),\n            value: TestValue(2),\n        };\n        let slice1 = Slice { entries: [&bucket1] };\n        let slice2 = Slice { entries: [&bucket2] };\n        \n        assert_eq!(slice1.cmp(&slice2), Ordering::Less);\n    }\n\n    #[test]\n    fn test_cmp_greater_than() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: TestKey(2),\n            value: TestValue(2),\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: TestKey(1),\n            value: TestValue(1),\n        };\n        let slice1 = Slice { entries: [&bucket1] };\n        let slice2 = Slice { entries: [&bucket2] };\n        \n        assert_eq!(slice1.cmp(&slice2), Ordering::Greater);\n    }\n\n    #[test]\n    fn test_cmp_different_lengths() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: TestKey(1),\n            value: TestValue(1),\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: TestKey(2),\n            value: TestValue(2),\n        };\n        let slice1 = Slice { entries: [&bucket1] };\n        let slice2 = Slice { entries: [&bucket1, &bucket2] };\n        \n        assert_eq!(slice1.cmp(&slice2), Ordering::Less);\n    }\n}\n```", "<map::slice::Slice<K, V> as core::cmp::PartialEq<[(K2, V2); N]>>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashSet;\n\n    #[test]\n    fn test_slice_eq() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let slice = Slice { entries: [bucket1, bucket2] };\n\n        let other: [(&str, &str); 2] = [(\"key1\", \"value1\"), (\"key2\", \"value2\")];\n\n        assert!(slice.eq(&other));\n    }\n\n    #[test]\n    fn test_slice_eq_different_order() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let slice = Slice { entries: [bucket1, bucket2] };\n\n        let other: [(&str, &str); 2] = [(\"key2\", \"value2\"), (\"key1\", \"value1\")];\n\n        assert!(!slice.eq(&other));\n    }\n\n    #[test]\n    fn test_slice_eq_empty() {\n        let slice: Slice<&str, &str> = Slice { entries: [] };\n\n        let other: [(&str, &str); 0] = [];\n\n        assert!(slice.eq(&other));\n    }\n\n    #[test]\n    fn test_slice_eq_different_length() {\n        let bucket = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let slice = Slice { entries: [bucket] };\n\n        let other: [(&str, &str); 2] = [(\"key1\", \"value1\"), (\"key2\", \"value2\")];\n\n        assert!(!slice.eq(&other));\n    }\n}\n```", "<map::slice::Slice<K, V> as core::cmp::PartialEq<[(K2, V2)]>>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::{Slice, Bucket};\n    \n    #[test]\n    fn test_slice_eq() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let slice = Slice {\n            entries: [bucket1, bucket2],\n        };\n        \n        let other: [(&str, &str); 2] = [(\"key1\", \"value1\"), (\"key2\", \"value2\")];\n        assert!(slice.eq(&other));\n        \n        let other_diff: [(&str, &str); 2] = [(\"key1\", \"value1\"), (\"key2\", \"different_value\")];\n        assert!(!slice.eq(&other_diff));\n        \n        let other_diff_key: [(&str, &str); 2] = [(\"different_key\", \"value1\"), (\"key2\", \"value2\")];\n        assert!(!slice.eq(&other_diff_key));\n        \n        let empty_slice: [(&str, &str); 0] = [];\n        assert!(!slice.eq(&empty_slice));\n    }\n}\n```", "<map::slice::Slice<K, V> as core::cmp::PartialEq<map::slice::Slice<K2, V2>>>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::{Slice, Bucket};\n\n    #[derive(Clone, Debug, PartialEq)]\n    struct Key(i32);\n    \n    #[derive(Clone, Debug, PartialEq)]\n    struct Value(i32);\n\n    #[test]\n    fn test_eq_identical_slices() {\n        let entries1 = [\n            Bucket { hash: HashValue(1), key: Key(1), value: Value(1) },\n            Bucket { hash: HashValue(2), key: Key(2), value: Value(2) },\n        ];\n        let entries2 = [\n            Bucket { hash: HashValue(1), key: Key(1), value: Value(1) },\n            Bucket { hash: HashValue(2), key: Key(2), value: Value(2) },\n        ];\n        \n        let slice1 = Slice { entries: entries1 };\n        let slice2 = Slice { entries: entries2 };\n        \n        assert!(slice1.eq(&slice2));\n    }\n\n    #[test]\n    fn test_eq_different_slices() {\n        let entries1 = [\n            Bucket { hash: HashValue(1), key: Key(1), value: Value(1) },\n            Bucket { hash: HashValue(2), key: Key(2), value: Value(2) },\n        ];\n        let entries2 = [\n            Bucket { hash: HashValue(1), key: Key(1), value: Value(3) },\n            Bucket { hash: HashValue(2), key: Key(2), value: Value(2) },\n        ];\n        \n        let slice1 = Slice { entries: entries1 };\n        let slice2 = Slice { entries: entries2 };\n        \n        assert!(!slice1.eq(&slice2));\n    }\n\n    #[test]\n    fn test_eq_different_length_slices() {\n        let entries1 = [\n            Bucket { hash: HashValue(1), key: Key(1), value: Value(1) },\n        ];\n        let entries2 = [\n            Bucket { hash: HashValue(1), key: Key(1), value: Value(1) },\n            Bucket { hash: HashValue(2), key: Key(2), value: Value(2) },\n        ];\n        \n        let slice1 = Slice { entries: entries1 };\n        let slice2 = Slice { entries: entries2 };\n        \n        assert!(!slice1.eq(&slice2));\n    }\n}\n```", "<map::slice::Slice<K, V> as core::cmp::PartialOrd>::partial_cmp": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_partial_cmp_equal() {\n        let bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let bucket2 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let slice1 = Slice { entries: [bucket1] };\n        let slice2 = Slice { entries: [bucket2] };\n        assert_eq!(slice1.partial_cmp(&slice2), Some(Ordering::Equal));\n    }\n\n    #[test]\n    fn test_partial_cmp_less() {\n        let bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let bucket2 = Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" };\n        let slice1 = Slice { entries: [bucket1] };\n        let slice2 = Slice { entries: [bucket2] };\n        assert_eq!(slice1.partial_cmp(&slice2), Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_greater() {\n        let bucket1 = Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" };\n        let bucket2 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let slice1 = Slice { entries: [bucket1] };\n        let slice2 = Slice { entries: [bucket2] };\n        assert_eq!(slice1.partial_cmp(&slice2), Some(Ordering::Greater));\n    }\n\n    #[test]\n    fn test_partial_cmp_different_lengths() {\n        let bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let bucket2 = Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" };\n        let slice1 = Slice { entries: [bucket1] };\n        let slice2 = Slice { entries: [bucket2, bucket2] };\n        assert_eq!(slice1.partial_cmp(&slice2), Some(Ordering::Less));\n    }\n\n    #[test]\n    fn test_partial_cmp_empty() {\n        let bucket = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let slice1 = Slice { entries: [bucket] };\n        let slice2 = Slice { entries: [] };\n        assert_eq!(slice1.partial_cmp(&slice2), Some(Ordering::Greater));\n        assert_eq!(slice2.partial_cmp(&slice1), Some(Ordering::Less));\n    }\n}\n```", "<map::slice::Slice<K, V> as core::hash::Hash>::hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::hash::Hasher;\n    use std::collections::hash_map::DefaultHasher;\n\n    #[test]\n    fn test_hash_empty_slice() {\n        let slice: Slice<i32, i32> = Slice { entries: [] };\n        let mut hasher = DefaultHasher::new();\n        slice.hash(&mut hasher);\n        let hash_result = hasher.finish();\n        assert_eq!(hash_result, 0); // Hash of empty slice should be 0\n    }\n\n    #[test]\n    fn test_hash_single_entry() {\n        let bucket = Bucket {\n            hash: HashValue(1),\n            key: 42,\n            value: 100,\n        };\n        let slice = Slice {\n            entries: [bucket],\n        };\n        let mut hasher = DefaultHasher::new();\n        slice.hash(&mut hasher);\n        let hash_result = hasher.finish();\n        assert!(hash_result != 0); // Hash of non-empty slice should not be 0\n    }\n\n    #[test]\n    fn test_hash_multiple_entries() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 1,\n            value: 10,\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: 2,\n            value: 20,\n        };\n        let slice = Slice {\n            entries: [bucket1, bucket2],\n        };\n        let mut hasher = DefaultHasher::new();\n        slice.hash(&mut hasher);\n        let hash_result = hasher.finish();\n        assert!(hash_result != 0); // Hash of non-empty slice should not be 0\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::Range;\n\n    #[test]\n    fn test_slice_index() {\n        // Define sample data\n        let buckets = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        \n        // Create a Slice from the sample data\n        let slice = Slice { entries: buckets };\n\n        // Test a valid index range\n        let result: &Slice<_, _> = &slice[(1..3)];\n        assert_eq!(result.len(), 2);\n        assert_eq!(result.entries[0].value_ref(), &\"two\");\n        assert_eq!(result.entries[1].value_ref(), &\"three\");\n\n        // Test invalid range (out of bounds)\n        // Assuming that the Slice would panic on invalid access\n        let panic_result = std::panic::catch_unwind(|| {\n            let _ = &slice[(3..5)];\n        });\n        assert!(panic_result.is_err());\n    }\n\n    #[test]\n    fn test_slice_index_empty() {\n        // Create an empty Slice\n        let empty_slice: Slice<i32, &str> = Slice { entries: [] };\n\n        // Test indexing on an empty Slice, should panic or return a Slice with 0 length\n        let result: &Slice<_, _> = &empty_slice[(0..0)];\n        assert_eq!(result.len(), 0);\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::Index<core::ops::Range<usize>>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::Range;\n\n    #[test]\n    fn test_index_slice() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n            Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            Bucket { hash: HashValue(3), key: \"key3\", value: \"value3\" },\n        ];\n        let slice = Slice { entries: buckets };\n\n        let result: &Slice<_, _> = &slice[1..3];\n        let expected_buckets = [\n            Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            Bucket { hash: HashValue(3), key: \"key3\", value: \"value3\" },\n        ];\n        let expected_slice = Slice { entries: expected_buckets };\n\n        assert_eq!(result, &expected_slice);\n    }\n\n    #[test]\n    fn test_index_slice_empty() {\n        let buckets: [Bucket<_, _>; 0] = [];\n        let slice = Slice { entries: buckets };\n\n        let result: &Slice<_, _> = &slice[0..0];\n        let expected_slice = Slice { entries: [] };\n\n        assert_eq!(result, &expected_slice);\n    }\n\n    #[test]\n    fn test_index_slice_out_of_bounds() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n        ];\n        let slice = Slice { entries: buckets };\n\n        let result = std::panic::catch_unwind(|| {\n            let _ = &slice[0..2];\n        });\n\n        assert!(result.is_err());\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeFrom<usize>>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::RangeFrom;\n\n    #[test]\n    fn test_index() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let entries = [bucket1, bucket2];\n        \n        let slice = Slice { entries };\n\n        let result: &Slice<_, _> = &slice.index(RangeFrom::new(0));\n        assert_eq!(result.len(), 2);\n        assert_eq!(result.get_index(0), Some((&\"key1\", &\"value1\")));\n        assert_eq!(result.get_index(1), Some((&\"key2\", &\"value2\")));\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_out_of_bounds() {\n        let bucket = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let entries = [bucket];\n        let slice = Slice { entries };\n\n        let _result: &Slice<_, _> = &slice.index(RangeFrom::new(1)); // This should panic\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeFull>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::RangeFull;\n\n    #[test]\n    fn test_index() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let slice = Slice {\n            entries: [bucket1, bucket2],\n        };\n        \n        let result: &Slice<&str, &str> = &slice.index(RangeFull);\n        \n        assert_eq!(result.entries.len(), 2);\n        assert_eq!(result.entries[0].key_ref(), &\"key1\");\n        assert_eq!(result.entries[1].key_ref(), &\"key2\");\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeInclusive<usize>>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::RangeInclusive;\n\n    #[test]\n    fn test_index() {\n        // Create sample buckets\n        let entries = [\n            Bucket {\n                hash: HashValue(1),\n                key: \"key1\",\n                value: \"value1\",\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: \"key2\",\n                value: \"value2\",\n            },\n            Bucket {\n                hash: HashValue(3),\n                key: \"key3\",\n                value: \"value3\",\n            },\n        ];\n\n        // Create a Slice\n        let slice = Slice { entries };\n\n        // Test a typical index operation\n        let result: &Slice<_, _> = slice.index(1..=2);\n        assert_eq!(result.len(), 2);\n        assert_eq!(result.entries[0].key_ref(), &\"key2\");\n        assert_eq!(result.entries[1].key_ref(), &\"key3\");\n\n        // Test accessing a single element\n        let single_result: &str = slice.index(0);\n        assert_eq!(single_result, &\"value1\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_out_of_bounds() {\n        let entries = [\n            Bucket {\n                hash: HashValue(1),\n                key: \"key1\",\n                value: \"value1\",\n            },\n        ];\n\n        let slice = Slice { entries };\n\n        // This should panic as we are accessing out of bounds\n        let _ = slice.index(1..=2);\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeTo<usize>>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_index() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let entries = [bucket1, bucket2];\n        \n        let slice = Slice { entries };\n        \n        let result: &Slice<_, _> = &slice.index(0..2);\n        \n        assert_eq!(result.entries.len(), 2);\n        assert_eq!(result.entries[0].key_ref(), &\"key1\");\n        assert_eq!(result.entries[1].key_ref(), &\"key2\");\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeToInclusive<usize>>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::RangeToInclusive;\n\n    #[test]\n    fn test_index() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let buckets = [bucket1, bucket2];\n        \n        let slice = Slice { entries: buckets };\n        \n        let result: &Slice<_, _> = &slice[RangeToInclusive::new(1)];\n        \n        assert_eq!(result.len(), 1);\n        assert_eq!(result.entries[0].key_ref(), &\"key2\");\n        assert_eq!(result.entries[0].value_ref(), &\"value2\");\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::Index<usize>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_index() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n            Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            Bucket { hash: HashValue(3), key: \"key3\", value: \"value3\" },\n        ];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.index(0), &\"value1\");\n        assert_eq!(slice.index(1), &\"value2\");\n        assert_eq!(slice.index(2), &\"value3\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_out_of_bounds() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n        ];\n        let slice = Slice { entries };\n\n        // This should panic because there is only one element\n        let _ = slice.index(1);\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::IndexMut<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::Range;\n    \n    #[test]\n    fn test_index_mut() {\n        let mut entries = [\n            Bucket { hash: HashValue(1), key: \"a\", value: 1 },\n            Bucket { hash: HashValue(2), key: \"b\", value: 2 },\n            Bucket { hash: HashValue(3), key: \"c\", value: 3 },\n        ];\n        \n        let mut slice = Slice { entries };\n\n        // Mutate the value at index 1\n        {\n            let slice_mut = slice.index_mut(Range { start: 1, end: 2 });\n            slice_mut.entries[0].value_mut() = 20;\n        }\n\n        // Check if the value is updated\n        assert_eq!(slice.entries[1].value, 20);\n    }\n\n    #[test]\n    fn test_index_mut_out_of_bounds() {\n        let mut entries = [\n            Bucket { hash: HashValue(1), key: \"a\", value: 1 },\n            Bucket { hash: HashValue(2), key: \"b\", value: 2 },\n        ];\n        \n        let mut slice = Slice { entries };\n\n        // Attempting to mutate an out-of-bounds index should panic\n        let result = std::panic::catch_unwind(|| {\n            slice.index_mut(Range { start: 2, end: 3 });\n        });\n\n        assert!(result.is_err());\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::Range<usize>>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_index_mut() {\n        let mut bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let mut bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let mut slice = Slice {\n            entries: [bucket1, bucket2],\n        };\n\n        // Ensure the length is correct before mutation\n        assert_eq!(slice.len(), 2);\n        \n        // Mutate the values through index_mut\n        let slice_mut = slice.index_mut(0..2);\n        slice_mut.entries[0].value_mut() = \"new_value1\";\n        slice_mut.entries[1].value_mut() = \"new_value2\";\n\n        // Verify the mutation\n        assert_eq!(slice.entries[0].value_ref(), &\"new_value1\");\n        assert_eq!(slice.entries[1].value_ref(), &\"new_value2\");\n    }\n\n    #[test]\n    fn test_index_mut_empty() {\n        let mut slice: Slice<&str, &str> = Slice { entries: [] };\n        \n        // Create a mutable slice\n        let slice_mut = slice.index_mut(0..0);\n        \n        // Verify the slice's length after the mutation\n        assert_eq!(slice.len(), 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_mut_panic_out_of_bounds() {\n        let mut bucket = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let mut slice = Slice {\n            entries: [bucket],\n        };\n        \n        // This should panic because the index is out of bounds\n        let _ = slice.index_mut(1..2);\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeFrom<usize>>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{Bucket, Slice, HashValue};\n\n    #[test]\n    fn test_index_mut() {\n        let mut buckets = [\n            Bucket { hash: HashValue(1), key: 'a', value: 1 },\n            Bucket { hash: HashValue(2), key: 'b', value: 2 },\n            Bucket { hash: HashValue(3), key: 'c', value: 3 },\n        ];\n        let mut slice = Slice { entries: buckets };\n\n        // Modify the value in the slice\n        {\n            let slice_mut = slice.index_mut(1..3); // Range from index 1 to 2 (inclusive)\n            slice_mut.entries[0].value_mut() = 22; // Modify second bucket's value\n            slice_mut.entries[1].value_mut() = 33; // Modify third bucket's value\n        }\n\n        // Validate the changes\n        assert_eq!(slice.entries[1].value, 22);\n        assert_eq!(slice.entries[2].value, 33);\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeFull>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_index_mut() {\n        let mut bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: 10,\n        };\n        let mut bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: 20,\n        };\n        let mut slice = Slice { entries: [bucket1, bucket2] };\n\n        // Mutate the value of the second bucket\n        let slice_mut = slice.index_mut(1..2);\n        slice_mut.entries[0].value_mut() = 30;\n\n        // Check if the value has been updated correctly\n        assert_eq!(slice.entries[1].value_ref(), &30);\n    }\n\n    #[test]\n    fn test_index_mut_out_of_bounds() {\n        let mut bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: 10,\n        };\n        let mut slice = Slice { entries: [bucket1] };\n\n        // Attempt to mutate out of bounds\n        let result = std::panic::catch_unwind(|| {\n            slice.index_mut(1..2);\n        });\n\n        assert!(result.is_err()); // This should panic due to out-of-bounds access\n    }\n\n    #[test]\n    fn test_index_mut_empty_slice() {\n        let mut slice: Slice<&str, i32> = Slice { entries: [] };\n\n        // Mutate on an empty slice\n        let slice_mut = slice.index_mut(0..0);\n        assert!(slice_mut.entries.is_empty()); // Should remain empty\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeInclusive<usize>>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::RangeInclusive;\n\n    #[test]\n    fn test_index_mut() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: 1, value: \"a\" },\n                Bucket { hash: HashValue(2), key: 2, value: \"b\" },\n                Bucket { hash: HashValue(3), key: 3, value: \"c\" },\n            ],\n        };\n\n        let range: RangeInclusive<usize> = 0..=1;\n        let slice_mut = slice.index_mut(range);\n        \n        // Check if the slice_mut points to the correct entries\n        assert_eq!(slice_mut.len(), 2);\n\n        // Modify the slice\n        slice_mut.entries[0].value_mut() = \"modified_a\";\n        slice_mut.entries[1].value_mut() = \"modified_b\";\n\n        // Validate that the changes are reflected in the original slice\n        assert_eq!(slice.entries[0].value, \"modified_a\");\n        assert_eq!(slice.entries[1].value, \"modified_b\");\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeTo<usize>>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::RangeTo;\n\n    #[test]\n    fn test_index_mut() {\n        let mut entries: [Bucket<&str, i32>; 3] = [\n            Bucket { hash: HashValue(1), key: \"a\", value: 1 },\n            Bucket { hash: HashValue(2), key: \"b\", value: 2 },\n            Bucket { hash: HashValue(3), key: \"c\", value: 3 },\n        ];\n        let mut slice = Slice { entries };\n\n        // Modify values using index_mut\n        let slice_mut = slice.index_mut(RangeTo::new(2));\n        slice_mut.entries[0].value_mut() = 10;\n        slice_mut.entries[1].value_mut() = 20;\n\n        // Check if the values were updated correctly\n        assert_eq!(slice.entries[0].value, 10);\n        assert_eq!(slice.entries[1].value, 20);\n        assert_eq!(slice.entries[2].value, 3);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_mut_panic_out_of_bounds() {\n        let mut entries: [Bucket<&str, i32>; 2] = [\n            Bucket { hash: HashValue(1), key: \"a\", value: 1 },\n            Bucket { hash: HashValue(2), key: \"b\", value: 2 },\n        ];\n        let mut slice = Slice { entries };\n\n        // Attempting to mutably index out of bounds should panic\n        let _ = slice.index_mut(RangeTo::new(3));\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeToInclusive<usize>>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::RangeToInclusive;\n\n    #[test]\n    fn test_index_mut() {\n        // Setup\n        let mut bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: 10 };\n        let mut bucket2 = Bucket { hash: HashValue(2), key: \"key2\", value: 20 };\n        let mut entries = [bucket1, bucket2];\n        let mut slice = Slice { entries };\n\n        // Test mutable access via index_mut\n        {\n            let slice_mut: &mut Slice<&str, i32> = slice.index_mut(0..=1);\n            slice_mut.entries[0].value_mut() = 15;\n\n            assert_eq!(slice.entries[0].value, 15);\n            assert_eq!(slice.entries[1].value, 20);\n        }\n\n        // Test if we can modify second bucket value\n        {\n            let slice_mut: &mut Slice<&str, i32> = slice.index_mut(1..=1);\n            slice_mut.entries[0].value_mut() = 25;\n\n            assert_eq!(slice.entries[0].value, 15);\n            assert_eq!(slice.entries[1].value, 25);\n        }\n\n        // Test out of bounds access\n        let result = std::panic::catch_unwind(|| {\n            slice.index_mut(2..=2);\n        });\n        assert!(result.is_err());\n    }\n}\n```", "<map::slice::Slice<K, V> as core::ops::IndexMut<usize>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_index_mut() {\n        // Create a Slice with some entries\n        let mut entries: [Bucket<&str, i32>; 3] = [\n            Bucket { hash: HashValue(1), key: \"a\", value: 1 },\n            Bucket { hash: HashValue(2), key: \"b\", value: 2 },\n            Bucket { hash: HashValue(3), key: \"c\", value: 3 },\n        ];\n\n        let mut slice = Slice { entries };\n\n        // Modify an entry\n        let value = slice.index_mut(1);\n        *value += 10;\n\n        // Check the slice was modified correctly\n        assert_eq!(slice.index(1), &12);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_mut_out_of_bounds() {\n        let entries: [Bucket<&str, i32>; 2] = [\n            Bucket { hash: HashValue(1), key: \"a\", value: 1 },\n            Bucket { hash: HashValue(2), key: \"b\", value: 2 },\n        ];\n\n        let mut slice = Slice { entries };\n\n        // Attempt to modify an out-of-bounds index\n        let _value = slice.index_mut(2);\n    }\n}\n```", "<set::IndexSet<T, S1> as core::cmp::PartialEq<set::IndexSet<T, S2>>>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_eq_with_equal_sets() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        set_a.insert(1);\n        set_a.insert(2);\n        \n        let mut set_b: IndexSet<i32> = IndexSet::new();\n        set_b.insert(2);\n        set_b.insert(1);\n\n        assert!(set_a.eq(&set_b));\n    }\n\n    #[test]\n    fn test_eq_with_unequal_sets() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        set_a.insert(1);\n        set_a.insert(2);\n        \n        let mut set_b: IndexSet<i32> = IndexSet::new();\n        set_b.insert(1);\n\n        assert!(!set_a.eq(&set_b));\n    }\n\n    #[test]\n    fn test_eq_with_different_sizes() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        set_a.insert(1);\n        \n        let mut set_b: IndexSet<i32> = IndexSet::new();\n        set_b.insert(1);\n        set_b.insert(2);\n\n        assert!(!set_a.eq(&set_b));\n    }\n\n    #[test]\n    fn test_eq_with_empty_sets() {\n        let set_a: IndexSet<i32> = IndexSet::new();\n        let set_b: IndexSet<i32> = IndexSet::new();\n\n        assert!(set_a.eq(&set_b));\n    }\n\n    #[test]\n    fn test_eq_with_different_types() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        set_a.insert(1);\n        let mut set_b: IndexSet<String> = IndexSet::new();\n        set_b.insert(\"1\".to_string()); \n\n        assert!(!set_a.eq(&set_b));\n    }\n}\n```", "<set::IndexSet<T, S> as Entries>::as_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_as_entries() {\n        let mut index_map: IndexMap<i32, &str> = IndexMap::new();\n        index_map.insert(1, \"one\");\n        index_map.insert(2, \"two\");\n        index_map.insert(3, \"three\");\n\n        let index_set: IndexSet<i32> = index_map.clone().into_iter().collect();\n        let entries = index_set.as_entries();\n\n        assert_eq!(entries.len(), 3);\n        assert_eq!(entries[0].key, 1);\n        assert_eq!(entries[0].value, \"one\");\n        assert_eq!(entries[1].key, 2);\n        assert_eq!(entries[1].value, \"two\");\n        assert_eq!(entries[2].key, 3);\n        assert_eq!(entries[2].value, \"three\");\n    }\n}\n```", "<set::IndexSet<T, S> as Entries>::as_entries_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_as_entries_mut() {\n        let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n        \n        let entries = index_set.as_entries_mut();\n        entries[0].value = 10; // changing value should be possible\n        entries[1].value = 20; // changing value should be possible\n        entries[2].value = 30; // changing value should be possible\n        \n        // Verify changes\n        assert_eq!(index_set.get(&10), Some(&10));\n        assert_eq!(index_set.get(&20), Some(&20));\n        assert_eq!(index_set.get(&30), Some(&30));\n    }\n\n    #[test]\n    fn test_as_entries_mut_empty() {\n        let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();\n        \n        // Calling as_entries_mut on an empty IndexSet should not panic\n        let entries = index_set.as_entries_mut();\n        assert!(entries.is_empty()); // Ensure entries are empty\n    }\n\n    #[test]\n    fn test_as_entries_mut_insert() {\n        let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n\n        {\n            let entries = index_set.as_entries_mut();\n            entries.push(Bucket::new(3, 0)); // Insert new entry through mutable access\n        }\n\n        assert_eq!(index_set.len(), 3);\n        assert!(index_set.contains(&3)); // Ensure the new entry is in the index set\n    }\n}\n```", "<set::IndexSet<T, S> as Entries>::into_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_into_entries() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let entries = set.clone().into_entries();\n        assert_eq!(entries.len(), 3);\n        assert!(entries.contains(&indexmap::map::Bucket::new(1)));\n        assert!(entries.contains(&indexmap::map::Bucket::new(2)));\n        assert!(entries.contains(&indexmap::map::Bucket::new(3)));\n    }\n\n    #[test]\n    fn test_into_entries_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        let entries: Vec<indexmap::map::Bucket<i32, ()>> = set.into_entries();\n        assert!(entries.is_empty());\n    }\n\n    #[test]\n    fn test_into_entries_order() {\n        let mut set = IndexSet::new();\n        set.insert(3);\n        set.insert(1);\n        set.insert(2);\n\n        let entries = set.into_entries();\n        assert_eq!(entries[0].key, 3);\n        assert_eq!(entries[1].key, 1);\n        assert_eq!(entries[2].key, 2);\n    }\n}\n```", "<set::IndexSet<T, S> as Entries>::with_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_with_entries_empty_map() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.with_entries(|entries| {\n            assert!(entries.is_empty());\n        });\n    }\n\n    #[test]\n    fn test_with_entries_single_entry() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.with_entries(|entries| {\n            assert_eq!(entries.len(), 1);\n            assert_eq!(entries[0].key, 1);\n        });\n    }\n\n    #[test]\n    fn test_with_entries_multiple_entries() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n        index_set.with_entries(|entries| {\n            assert_eq!(entries.len(), 3);\n            assert_eq!(entries[0].key, 1);\n            assert_eq!(entries[1].key, 2);\n            assert_eq!(entries[2].key, 3);\n        });\n    }\n\n    #[test]\n    fn test_with_entries_modify_entries() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.with_entries(|entries| {\n            entries[0].value += 1; // assuming the entries have a mutable value\n        });\n        assert_eq!(index_set.get(&1), Some(&2)); // assuming entries have a value to increment\n    }\n\n    #[test]\n    fn test_with_entries_empty_fn() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.with_entries(|entries| {\n            entries.clear(); // testing that entries can be mutated\n        });\n        assert!(index_set.is_empty());\n    }\n}\n```", "<set::IndexSet<T, S> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_clone() {\n        let mut original = IndexMap::new();\n        original.insert(1, \"one\");\n        original.insert(2, \"two\");\n\n        let cloned = original.clone();\n\n        assert_eq!(original.len(), cloned.len());\n        assert_eq!(cloned.get(&1), Some(&\"one\"));\n        assert_eq!(cloned.get(&2), Some(&\"two\"));\n        assert!(cloned != original); // Ensure cloning gives a separate instance\n    }\n\n    #[test]\n    fn test_clone_empty() {\n        let original: IndexMap<i32, &str> = IndexMap::new();\n        let cloned = original.clone();\n        \n        assert_eq!(original.len(), cloned.len());\n        assert_eq!(cloned.len(), 0);\n    }\n\n    #[test]\n    fn test_clone_with_different_values() {\n        let mut original = IndexMap::new();\n        original.insert(1, \"one\");\n        original.insert(2, \"two\");\n\n        let cloned = original.clone();\n        original.insert(3, \"three\");\n\n        assert_eq!(original.len(), 3);\n        assert_eq!(cloned.len(), 2);\n        assert_eq!(cloned.get(&3), None);\n    }\n\n    #[test]\n    fn test_clone_trait_implementation() {\n        let mut original = IndexMap::new();\n        original.insert(1, \"one\");\n        original.insert(2, \"two\");\n\n        let cloned: IndexMap<i32, &str> = original.clone();\n        \n        assert_eq!(original, cloned);\n    }\n}\n```", "<set::IndexSet<T, S> as core::clone::Clone>::clone_from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import everything from the parent module\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_clone_from() {\n        let mut map_a = IndexMap::new();\n        map_a.insert(1, \"one\");\n        map_a.insert(2, \"two\");\n\n        let mut map_b = IndexMap::new();\n        map_b.insert(3, \"three\");\n        map_b.insert(4, \"four\");\n\n        // Test clone_from\n        map_a.clone_from(&map_b);\n\n        // Verify that map_a now includes entries from map_b\n        assert_eq!(map_a.len(), 2);\n        assert_eq!(map_a.get(&3), Some(&\"three\"));\n        assert_eq!(map_a.get(&4), Some(&\"four\"));\n    }\n\n    #[test]\n    fn test_clone_from_with_partial_data() {\n        let mut map_a = IndexMap::new();\n        map_a.insert(1, \"one\");\n\n        let mut map_b = IndexMap::new();\n        map_b.insert(2, \"two\");\n\n        // Test clone_from\n        map_a.clone_from(&map_b);\n\n        // Verify that map_a now includes entries from map_b\n        assert_eq!(map_a.len(), 1);\n        assert_eq!(map_a.get(&2), Some(&\"two\"));\n    }\n\n    #[test]\n    fn test_clone_from_empty() {\n        let mut map_a = IndexMap::new();\n\n        let mut map_b = IndexMap::new();\n        map_b.insert(1, \"one\");\n\n        // Test clone_from\n        map_a.clone_from(&map_b);\n\n        // Verify map_a is now empty as it should not retain previous state\n        assert_eq!(map_a.len(), 0);\n        assert_eq!(map_b.len(), 1);\n    }\n\n    #[test]\n    fn test_clone_from_no_overlap() {\n        let mut map_a = IndexMap::new();\n        map_a.insert(1, \"one\");\n\n        let mut map_b = IndexMap::new();\n        map_b.insert(2, \"two\");\n\n        // Test clone_from\n        map_a.clone_from(&map_b);\n\n        // Verify that map_a does not retain the first entry\n        assert_eq!(map_a.len(), 1);\n        assert_eq!(map_a.get(&2), Some(&\"two\"));\n    }\n\n    #[test]\n    fn test_clone_from_identical_maps() {\n        let mut map_a = IndexMap::new();\n        map_a.insert(1, \"one\");\n\n        let mut map_b = map_a.clone();\n\n        // Test clone_from\n        map_a.clone_from(&map_b);\n\n        // Verify that map_a is unchanged\n        assert_eq!(map_a.len(), 1);\n        assert_eq!(map_a.get(&1), Some(&\"one\"));\n    }\n}\n```", "<set::IndexSet<T, S> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_index_set_default() {\n        let set: IndexSet<u32> = IndexSet::default();\n\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_index_set_default_multiple_creations() {\n        let set1: IndexSet<u32> = IndexSet::default();\n        let set2: IndexSet<u32> = IndexSet::default();\n\n        assert!(set1.is_empty());\n        assert!(set2.is_empty());\n        assert_eq!(set1.len(), 0);\n        assert_eq!(set2.len(), 0);\n    }\n}\n```", "<set::IndexSet<T, S> as core::iter::Extend<&'a T>>::extend": "```rust\n#[cfg(test)]\nmod tests {\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_extend_with_iter() {\n        let mut index_set = IndexMap::new();\n        let new_entries = vec![(\"key1\", \"value1\"), (\"key2\", \"value2\")];\n\n        index_set.extend(new_entries.iter().map(|&(k, v)| (k, v)));\n\n        assert_eq!(index_set.len(), 2);\n        assert_eq!(index_set.get(\"key1\"), Some(&\"value1\"));\n        assert_eq!(index_set.get(\"key2\"), Some(&\"value2\"));\n    }\n\n    #[test]\n    fn test_extend_with_empty_iter() {\n        let mut index_set = IndexMap::new();\n        let new_entries: Vec<(&str, &str)> = vec![];\n\n        index_set.extend(new_entries.iter().map(|&(k, v)| (k, v)));\n\n        assert_eq!(index_set.len(), 0);\n    }\n\n    #[test]\n    fn test_extend_with_duplicate_keys() {\n        let mut index_set = IndexMap::new();\n        index_set.insert(\"key1\", \"value1\");\n        let new_entries = vec![(\"key1\", \"new_value1\"), (\"key2\", \"value2\")];\n\n        index_set.extend(new_entries.iter().map(|&(k, v)| (k, v)));\n\n        assert_eq!(index_set.len(), 2);\n        assert_eq!(index_set.get(\"key1\"), Some(&\"new_value1\"));\n        assert_eq!(index_set.get(\"key2\"), Some(&\"value2\"));\n    }\n}\n```", "<set::IndexSet<T, S> as core::iter::Extend<T>>::extend": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_extend_with_slice() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.extend([1, 2, 3]);\n\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert_eq!(set.len(), 3);\n    }\n\n    #[test]\n    fn test_extend_with_vec() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        let vec = vec![4, 5, 6];\n        set.extend(vec);\n\n        assert!(set.contains(&4));\n        assert!(set.contains(&5));\n        assert!(set.contains(&6));\n        assert_eq!(set.len(), 3);\n    }\n\n    #[test]\n    fn test_extend_with_iter() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        let iter = (7..10).into_iter();\n        set.extend(iter);\n\n        assert!(set.contains(&7));\n        assert!(set.contains(&8));\n        assert!(set.contains(&9));\n        assert_eq!(set.len(), 3);\n    }\n\n    #[test]\n    fn test_extend_with_duplicates() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.extend([1, 2, 3]);\n        set.extend([2, 3, 4]);\n\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert!(set.contains(&4));\n        assert_eq!(set.len(), 4);\n    }\n\n    #[test]\n    fn test_extend_with_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.extend(Vec::<i32>::new());\n\n        assert!(set.is_empty());\n    }\n}\n```", "<set::IndexSet<T, S> as core::iter::FromIterator<T>>::from_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_from_iter_empty() {\n        let set: IndexSet<i32> = IndexSet::from_iter(vec![]);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_from_iter_single() {\n        let set: IndexSet<i32> = IndexSet::from_iter(vec![1]);\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n    }\n\n    #[test]\n    fn test_from_iter_multiple() {\n        let set: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3, 4]);\n        assert_eq!(set.len(), 4);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert!(set.contains(&4));\n    }\n\n    #[test]\n    fn test_from_iter_duplicates() {\n        let set: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 2, 3]);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n    }\n\n    #[test]\n    fn test_from_iter_with_mixed_elements() {\n        let set: IndexSet<&str> = IndexSet::from_iter(vec![\"a\", \"b\", \"c\", \"a\", \"b\"]);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(\"a\"));\n        assert!(set.contains(\"b\"));\n        assert!(set.contains(\"c\"));\n    }\n}\n```", "<set::IndexSet<T, S> as core::ops::Index<usize>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_index_valid() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n\n        assert_eq!(*index_set.index(0), 1);\n        assert_eq!(*index_set.index(1), 2);\n        assert_eq!(*index_set.index(2), 3);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\n    fn test_index_out_of_bounds() {\n        let index_set: IndexSet<i32> = IndexSet::new();\n        index_set.index(0);  // This is out of bounds\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 0 but the index is 0\")]\n    fn test_index_empty() {\n        let index_set: IndexSet<i32> = IndexSet::new();\n        index_set.index(0);  // This is out of bounds\n    }\n\n    #[test]\n    fn test_index_boundary_conditions() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(10);\n        assert_eq!(*index_set.index(0), 10);\n        assert_eq!(index_set.len(), 1);\n    }\n}\n```", "<set::IndexSet<T, S> as set::mutable::MutableValues>::get_full_mut2": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_full_mut2_found() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n        \n        let result = index_set.get_full_mut2(&2);\n        assert!(result.is_some());\n        let (index, value) = result.unwrap();\n        assert_eq!(index, 1);\n        assert_eq!(*value, 2);\n    }\n\n    #[test]\n    fn test_get_full_mut2_not_found() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        \n        let result = index_set.get_full_mut2(&3);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_full_mut2_modify() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        \n        {\n            let result = index_set.get_full_mut2(&1);\n            assert!(result.is_some());\n            let (_, value) = result.unwrap();\n            *value *= 2;\n        }\n\n        // Verify modification\n        assert_eq!(index_set.get(&1), Some(&2));\n    }\n}\n```", "<set::IndexSet<T, S> as set::mutable::MutableValues>::get_index_mut2": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_get_index_mut2_valid_index() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n        \n        let index = 1;\n        let value_mut = index_set.get_index_mut2(index);\n        assert!(value_mut.is_some());\n        assert_eq!(*value_mut.unwrap(), 2);\n        \n        // Modify value\n        *value_mut.unwrap() = 20;\n        assert_eq!(index_set.get_index_mut(1), Some((&2, &mut 2)));\n    }\n\n    #[test]\n    fn test_get_index_mut2_invalid_index() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n        \n        let index = 3; // Out of bounds\n        let value_mut = index_set.get_index_mut2(index);\n        assert!(value_mut.is_none());\n    }\n\n    #[test]\n    fn test_get_index_mut2_empty_set() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        \n        let index = 0; // Out of bounds\n        let value_mut = index_set.get_index_mut2(index);\n        assert!(value_mut.is_none());\n    }\n}\n```", "<set::IndexSet<T, S> as set::mutable::MutableValues>::retain2": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_retain2() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n        \n        index_set.retain2(|value| {\n            // Retain only even numbers\n            *value % 2 == 0\n        });\n\n        let retained: Vec<i32> = index_set.iter().copied().collect();\n        assert_eq!(retained, vec![2]);\n    }\n\n    #[test]\n    fn test_retain2_no_elements() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        \n        index_set.retain2(|_value| {\n            // Nothing to retain, as the index set is empty\n            true\n        });\n\n        let retained: Vec<i32> = index_set.iter().copied().collect();\n        assert!(retained.is_empty());\n    }\n\n    #[test]\n    fn test_retain2_all_elements() {\n        let mut index_set: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3, 4]);\n        \n        index_set.retain2(|_value| {\n            // Retain all, return true for all\n            true\n        });\n\n        let retained: Vec<i32> = index_set.iter().copied().collect();\n        assert_eq!(retained, vec![1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn test_retain2_no_elements_retained() {\n        let mut index_set: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3]);\n        \n        index_set.retain2(|value| {\n            // Retain no elements\n            *value > 3\n        });\n\n        let retained: Vec<i32> = index_set.iter().copied().collect();\n        assert!(retained.is_empty());\n    }\n}\n```", "<set::IndexSet<T> as core::convert::From<[T; N]>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_index_set_from_array() {\n        let set_from_array: IndexSet<i32> = IndexSet::from([1, 2, 3, 4]);\n        let set_from_slice: IndexSet<i32> = [1, 2, 3, 4].into();\n        \n        assert_eq!(set_from_array, set_from_slice);\n    }\n\n    #[test]\n    fn test_index_set_from_array_empty() {\n        let set_from_array: IndexSet<i32> = IndexSet::from([]);\n        let set_from_slice: IndexSet<i32> = [].into();\n        \n        assert_eq!(set_from_array, set_from_slice);\n    }\n\n    #[test]\n    fn test_index_set_from_array_repeats() {\n        let set_from_array: IndexSet<i32> = IndexSet::from([1, 1, 2, 2, 3]);\n        let set_from_slice: IndexSet<i32> = [1, 1, 2, 2, 3].into();\n        \n        assert_eq!(set_from_array, set_from_slice);\n        assert_eq!(set_from_array.len(), 3);\n    }\n}\n```", "<set::iter::Difference<'_, T, S> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_clone() {\n        // Create an IndexMap with some data\n        let mut original = IndexMap::new();\n        original.insert(\"key1\", \"value1\");\n        original.insert(\"key2\", \"value2\");\n\n        // Clone the original map\n        let cloned = original.clone();\n\n        // Assert that the clone contains the same data\n        assert_eq!(original.len(), cloned.len());\n        assert_eq!(original.get(\"key1\"), cloned.get(\"key1\"));\n        assert_eq!(original.get(\"key2\"), cloned.get(\"key2\"));\n\n        // Ensure that the original and clone are different instances\n        assert!(!std::ptr::eq(&original, &cloned));\n    }\n}\n```", "<set::iter::Difference<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_next_back_simple() {\n        let mut set = IndexSet::from([1, 2, 3, 4]);\n        let other_set = IndexSet::from([2, 4]);\n        let mut difference_iter = set.difference(&other_set);\n\n        assert_eq!(difference_iter.next_back(), Some(&1));\n        assert_eq!(difference_iter.next_back(), Some(&3));\n        assert_eq!(difference_iter.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        let other_set: IndexSet<i32> = IndexSet::new();\n        let mut difference_iter = set.difference(&other_set);\n\n        assert_eq!(difference_iter.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_no_difference() {\n        let set = IndexSet::from([1, 2, 3, 4]);\n        let other_set = IndexSet::from([1, 2, 3, 4]);\n        let mut difference_iter = set.difference(&other_set);\n\n        assert_eq!(difference_iter.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_with_multiple_elements() {\n        let mut set = IndexSet::from([1, 2, 3, 4, 5]);\n        let other_set = IndexSet::from([3, 4, 5]);\n        let mut difference_iter = set.difference(&other_set);\n\n        assert_eq!(difference_iter.next_back(), Some(&1));\n        assert_eq!(difference_iter.next_back(), Some(&2));\n        assert_eq!(difference_iter.next_back(), None);\n    }\n}\n```", "<set::iter::Difference<'a, T, S> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_difference_next() {\n        let mut map_a = IndexMap::new();\n        let mut map_b = IndexMap::new();\n        \n        map_a.insert(1, 'a');\n        map_a.insert(2, 'b');\n        map_a.insert(3, 'c');\n        \n        map_b.insert(2, 'b');\n        map_b.insert(3, 'c');\n        map_b.insert(4, 'd');\n\n        let iter_a = map_a.iter();\n        let iter_b = map_b.iter();\n        let difference = Difference::new(iter_a, iter_b);\n        \n        let mut diffs = Vec::new();\n        let mut iterator = difference;\n\n        while let Some(item) = iterator.next() {\n            diffs.push(item);\n        }\n\n        assert_eq!(diffs, vec![(&1, &'a')]);\n    }\n\n    #[test]\n    fn test_difference_next_with_empty() {\n        let map_a = IndexMap::new();\n        let map_b = IndexMap::new();\n        \n        let iter_a = map_a.iter();\n        let iter_b = map_b.iter();\n        let difference = Difference::new(iter_a, iter_b);\n        \n        let mut iterator = difference;\n        \n        assert!(iterator.next().is_none());\n    }\n\n    #[test]\n    fn test_difference_next_with_no_difference() {\n        let mut map_a = IndexMap::new();\n        let mut map_b = IndexMap::new();\n        \n        map_a.insert(1, 'a');\n        map_a.insert(2, 'b');\n        \n        map_b.insert(1, 'a');\n        map_b.insert(2, 'b');\n\n        let iter_a = map_a.iter();\n        let iter_b = map_b.iter();\n        let difference = Difference::new(iter_a, iter_b);\n        \n        let mut iterator = difference;\n        \n        assert!(iterator.next().is_none());\n    }\n\n    #[test]\n    fn test_difference_next_with_multiple_differences() {\n        let mut map_a = IndexMap::new();\n        let mut map_b = IndexMap::new();\n        \n        map_a.insert(1, 'a');\n        map_a.insert(2, 'b');\n        map_a.insert(3, 'c');\n        map_a.insert(4, 'd');\n        \n        map_b.insert(2, 'b');\n        map_b.insert(3, 'c');\n\n        let iter_a = map_a.iter();\n        let iter_b = map_b.iter();\n        let difference = Difference::new(iter_a, iter_b);\n        \n        let diffs: Vec<_> = difference.collect();\n        \n        assert_eq!(diffs, vec![(&1, &'a'), (&4, &'d')]);\n    }\n}\n```", "<set::iter::Difference<'a, T, S> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let iter = map.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let iter = map.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n\n    #[test]\n    fn test_size_hint_with_capacity() {\n        let mut map: IndexMap<i32, i32> = IndexMap::with_capacity(10);\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let iter = map.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n\n    #[test]\n    fn test_size_hint_after_removal() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.remove(&1);\n        let iter = map.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n    }\n}\n```", "<set::iter::Drain<'_, T> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_next_back() {\n        let mut set = IndexSet::new();\n        set.insert(\"apple\");\n        set.insert(\"banana\");\n        set.insert(\"cherry\");\n\n        let mut drain = set.drain();\n\n        assert_eq!(drain.next_back(), Some(\"cherry\"));\n        assert_eq!(drain.next_back(), Some(\"banana\"));\n        assert_eq!(drain.next_back(), Some(\"apple\"));\n        assert_eq!(drain.next_back(), None);\n    }\n}\n```", "<set::iter::Drain<'_, T> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_nth_back() {\n        let mut index_set = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n\n        let mut drain = index_set.drain();\n\n        assert_eq!(drain.nth_back(0), Some(3)); // n = 0, should return last item\n        assert_eq!(drain.nth_back(1), Some(2)); // n = 1, should return second last item\n        assert_eq!(drain.nth_back(2), Some(1)); // n = 2, should return first item\n        assert_eq!(drain.nth_back(3), None);    // n = 3, should return None\n    }\n}\n```", "<set::iter::Drain<'_, T> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_drain_len() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let mut drain = set.drain();\n        assert_eq!(drain.len(), 3);\n\n        drain.next(); // Remove one element\n        assert_eq!(drain.len(), 2);\n\n        drain.next(); // Remove another element\n        assert_eq!(drain.len(), 1);\n\n        drain.next(); // Remove last element\n        assert_eq!(drain.len(), 0);\n    }\n}\n```", "<set::iter::Drain<'_, T> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_with_indexmap() {\n        // Create an IndexMap\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        // Collect into a Vec\n        let collected: Vec<_> = map.iter().collect();\n        assert_eq!(collected.len(), 3);\n        assert_eq!(collected[0], (&\"a\", &1));\n        assert_eq!(collected[1], (&\"b\", &2));\n        assert_eq!(collected[2], (&\"c\", &3));\n    }\n\n    #[test]\n    fn test_collect_empty() {\n        // Create an empty IndexMap\n        let map: IndexMap<&str, i32> = IndexMap::new();\n        \n        // Collect into a Vec\n        let collected: Vec<_> = map.iter().collect();\n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_collect_from_empty_drain() {\n        // Create an empty IndexMap\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        \n        // Drain and collect into a Vec\n        let drained: Vec<_> = map.drain(..).collect();\n        assert!(drained.is_empty());\n    }\n\n    #[test]\n    fn test_collect_with_drain() {\n        // Create an IndexMap\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        // Drain and collect\n        let drained: Vec<_> = map.drain(..).collect();\n        assert_eq!(drained.len(), 3);\n        assert!(map.is_empty());\n    }\n}\n```", "<set::iter::Drain<'_, T> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_drain_count() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        let drain_iter = set.drain();\n        let count = drain_iter.count();\n        \n        assert_eq!(count, 3);\n    }\n\n    #[test]\n    fn test_drain_count_empty_set() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        \n        let drain_iter = set.drain();\n        let count = drain_iter.count();\n        \n        assert_eq!(count, 0);\n    }\n}\n```", "<set::iter::Drain<'_, T> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_last() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        let drain = set.drain();\n        \n        let last_item = drain.last();\n        \n        assert_eq!(last_item, Some(3));\n    }\n\n    #[test]\n    fn test_last_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        \n        let drain = set.drain();\n        \n        let last_item = drain.last();\n        \n        assert_eq!(last_item, None);\n    }\n}\n```", "<set::iter::Drain<'_, T> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::{IndexSet, Bucket};\n\n    #[test]\n    fn test_next() {\n        let mut index_set = IndexSet::new();\n        index_set.insert(\"a\");\n        index_set.insert(\"b\");\n        \n        let mut drain = index_set.drain();\n        \n        assert_eq!(drain.next(), Some(\"a\"));\n        assert_eq!(drain.next(), Some(\"b\"));\n        assert_eq!(drain.next(), None);\n    }\n\n    #[test]\n    fn test_next_on_empty() {\n        let mut index_set: IndexSet<&str> = IndexSet::new();\n        let mut drain = index_set.drain();\n\n        assert_eq!(drain.next(), None);\n    }\n}\n```", "<set::iter::Drain<'_, T> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_nth() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        let mut drain = set.drain();\n        \n        assert_eq!(drain.nth(0), Some(1));\n        assert_eq!(drain.nth(0), Some(2));\n        assert_eq!(drain.nth(0), Some(3));\n        assert_eq!(drain.nth(0), None);\n    }\n\n    #[test]\n    fn test_nth_out_of_bounds() {\n        let mut set = IndexSet::new();\n        set.insert(10);\n        set.insert(20);\n\n        let mut drain = set.drain();\n\n        assert_eq!(drain.nth(2), None);\n    }\n\n    #[test]\n    fn test_nth_multiple_calls() {\n        let mut set = IndexSet::new();\n        set.insert(5);\n        set.insert(15);\n        set.insert(25);\n\n        let mut drain = set.drain();\n\n        assert_eq!(drain.nth(1), Some(15));\n        assert_eq!(drain.nth(0), Some(5));\n        assert_eq!(drain.nth(0), Some(25));\n        assert_eq!(drain.nth(0), None);\n    }\n}\n```", "<set::iter::Drain<'_, T> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_size_hint() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        let mut drain = set.drain();\n        \n        assert_eq!(drain.size_hint(), (3, Some(3))); // size_hint should return (len, Some(len))\n        \n        let _ = drain.next(); // consume one item\n        \n        assert_eq!(drain.size_hint(), (2, Some(2))); // after consuming one, should return (2, Some(2))\n        \n        let _ = drain.next(); // consume another item\n        \n        assert_eq!(drain.size_hint(), (1, Some(1))); // now it should return (1, Some(1))\n        \n        let _ = drain.next(); // consume the last item\n        \n        assert_eq!(drain.size_hint(), (0, Some(0))); // after consuming all, it should return (0, Some(0))\n    }\n}\n```", "<set::iter::Intersection<'_, T, S> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[derive(Clone)]\n    struct MyStruct {\n        value: i32,\n    }\n\n    #[test]\n    fn test_intersection_clone() {\n        // Creating an example IndexMap\n        let mut map: IndexMap<i32, MyStruct> = IndexMap::new();\n        map.insert(1, MyStruct { value: 10 });\n        map.insert(2, MyStruct { value: 20 });\n\n        // Cloning the map\n        let cloned_map = map.clone();\n\n        // Testing the cloned map for integrity\n        assert_eq!(map.len(), cloned_map.len());\n        assert_eq!(map[&1].value, cloned_map[&1].value);\n        assert_eq!(map[&2].value, cloned_map[&2].value);\n    }\n\n    #[test]\n    fn test_intersection_clone_empty() {\n        // Creating an empty IndexMap\n        let map: IndexMap<i32, MyStruct> = IndexMap::new();\n\n        // Cloning the empty map\n        let cloned_map = map.clone();\n\n        // Testing the cloned empty map\n        assert_eq!(map.len(), cloned_map.len());\n    }\n}\n```", "<set::iter::Intersection<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_next_back() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        let mut set_b: IndexSet<i32> = IndexSet::new();\n        \n        set_a.insert(1);\n        set_a.insert(2);\n        set_a.insert(3);\n        \n        set_b.insert(2);\n        set_b.insert(3);\n        set_b.insert(4);\n\n        let mut intersection = set_a.intersection(&set_b);\n        \n        assert_eq!(intersection.next_back(), Some(3));\n        assert_eq!(intersection.next_back(), Some(2));\n        assert_eq!(intersection.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_no_overlap() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        let mut set_b: IndexSet<i32> = IndexSet::new();\n        \n        set_a.insert(1);\n        set_a.insert(2);\n        \n        set_b.insert(3);\n        set_b.insert(4);\n\n        let mut intersection = set_a.intersection(&set_b);\n        \n        assert_eq!(intersection.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_partially_overlapping() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        let mut set_b: IndexSet<i32> = IndexSet::new();\n        \n        set_a.insert(1);\n        set_a.insert(3);\n        set_a.insert(5);\n        \n        set_b.insert(2);\n        set_b.insert(3);\n        set_b.insert(4);\n\n        let mut intersection = set_a.intersection(&set_b);\n        \n        assert_eq!(intersection.next_back(), Some(3));\n        assert_eq!(intersection.next_back(), None);\n    }\n}\n```", "<set::iter::Intersection<'a, T, S> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_intersection() {\n        let mut map1 = IndexMap::new();\n        map1.insert(1, \"a\");\n        map1.insert(2, \"b\");\n        map1.insert(3, \"c\");\n\n        let mut map2 = IndexMap::new();\n        map2.insert(2, \"b\");\n        map2.insert(3, \"d\");\n        map2.insert(4, \"e\");\n\n        let intersection = {\n            let iter1 = map1.keys();\n            let iter2 = map2.keys();\n            Intersection::new(iter1, iter2)\n        };\n\n        let mut results: Vec<_> = intersection.collect();\n        results.sort(); // Ensure results are sorted for comparison\n\n        assert_eq!(results, vec![&2, &3]);\n    }\n\n    #[test]\n    fn test_next_intersection_no_common() {\n        let mut map1 = IndexMap::new();\n        map1.insert(1, \"a\");\n        map1.insert(2, \"b\");\n\n        let mut map2 = IndexMap::new();\n        map2.insert(3, \"c\");\n        map2.insert(4, \"d\");\n\n        let intersection = {\n            let iter1 = map1.keys();\n            let iter2 = map2.keys();\n            Intersection::new(iter1, iter2)\n        };\n\n        let results: Vec<_> = intersection.collect();\n        assert!(results.is_empty());\n    }\n}\n```", "<set::iter::Intersection<'a, T, S> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        let set: IndexSet<i32> = map.keys().collect();\n        let intersection = set.intersection(&set);\n        let hint = intersection.size_hint();\n        \n        assert_eq!(hint, (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let map: IndexMap<i32, i32> = [(1, 10), (2, 20), (3, 30)].iter().cloned().collect();\n        let set: IndexSet<i32> = map.keys().collect();\n        let intersection = set.intersection(&set);\n        let hint = intersection.size_hint();\n        \n        assert_eq!(hint, (0, Some(3)));\n    }\n\n    #[test]\n    fn test_size_hint_with_some_elements() {\n        let map1: IndexMap<i32, i32> = [(1, 10), (2, 20)].iter().cloned().collect();\n        let map2: IndexMap<i32, i32> = [(2, 20), (3, 30)].iter().cloned().collect();\n        let set1: IndexSet<i32> = map1.keys().collect();\n        let set2: IndexSet<i32> = map2.keys().collect();\n        let intersection = set1.intersection(&set2);\n        let hint = intersection.size_hint();\n        \n        assert_eq!(hint, (0, Some(1)));\n    }\n}\n```", "<set::iter::IntoIter<T> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n    use crate::set::iter::IntoIter;\n\n    #[test]\n    fn test_into_iter_default() {\n        let iter: IntoIter<i32> = IntoIter::default();\n        assert_eq!(iter.len(), 0);\n    }\n}\n```", "<set::iter::IntoIter<T> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_next_back() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n        \n        let mut iter = index_set.clone().into_iter();\n        \n        assert_eq!(iter.next_back(), Some(3));\n        assert_eq!(iter.next_back(), Some(2));\n        assert_eq!(iter.next_back(), Some(1));\n        assert_eq!(iter.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_empty() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        let mut iter = index_set.clone().into_iter();\n        \n        assert_eq!(iter.next_back(), None);\n    }\n}\n```", "<set::iter::IntoIter<T> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::IntoIter;\n    use crate::Bucket;\n\n    #[test]\n    fn test_nth_back() {\n        let bucket1 = Bucket::new(\"a\");\n        let bucket2 = Bucket::new(\"b\");\n        let bucket3 = Bucket::new(\"c\");\n        \n        let mut iter = IntoIter::new(vec![bucket1, bucket2, bucket3]);\n        \n        assert_eq!(iter.nth_back(0), Some(\"c\"));\n        assert_eq!(iter.nth_back(1), Some(\"b\"));\n        assert_eq!(iter.nth_back(2), Some(\"a\"));\n        assert_eq!(iter.nth_back(3), None);\n    }\n\n    #[test]\n    fn test_nth_back_empty() {\n        let mut iter: IntoIter<i32> = IntoIter::default();\n        assert_eq!(iter.nth_back(0), None);\n    }\n}\n```", "<set::iter::IntoIter<T> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::iter::IntoIter;\n    use crate::Bucket;\n\n    #[test]\n    fn test_len_empty_iterator() {\n        let iter: IntoIter<i32> = IntoIter::default();\n        assert_eq!(iter.len(), 0);\n    }\n\n    #[test]\n    fn test_len_non_empty_iterator() {\n        let buckets = vec![Bucket::new(1), Bucket::new(2), Bucket::new(3)];\n        let iter = IntoIter::new(buckets);\n        assert_eq!(iter.len(), 3);\n    }\n\n    #[test]\n    fn test_len_after_consuming() {\n        let buckets = vec![Bucket::new(1), Bucket::new(2)];\n        let mut iter = IntoIter::new(buckets);\n        let _ = iter.next(); // consume one element\n        assert_eq!(iter.len(), 1);\n    }\n\n    #[test]\n    fn test_len_after_complete_consumption() {\n        let buckets = vec![Bucket::new(1)];\n        let mut iter = IntoIter::new(buckets);\n        let _ = iter.next(); // consume the only element\n        assert_eq!(iter.len(), 0);\n    }\n}\n```", "<set::iter::IntoIter<T> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn collect_into_indexmap() {\n        let map: IndexMap<u32, u32> = vec![(1, 2), (3, 4)].into_iter().collect();\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&2));\n        assert_eq!(map.get(&3), Some(&4));\n    }\n\n    #[test]\n    fn collect_empty_into_indexmap() {\n        let map: IndexMap<u32, u32> = Vec::<(u32, u32)>::new().into_iter().collect();\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn collect_from_empty_iterator() {\n        let map: IndexMap<u32, u32> = std::iter::empty::<(u32, u32)>().collect();\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn collect_from_iterator_with_duplicates() {\n        let map: IndexMap<u32, u32> = vec![(1, 2), (1, 3), (2, 4)].into_iter().collect();\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&3)); // The last value for key 1 should be stored\n        assert_eq!(map.get(&2), Some(&4));\n    }\n\n    #[test]\n    fn collect_with_multiple_pulls() {\n        let data = vec![(1, 2), (3, 4), (5, 6)];\n        let map: IndexMap<u32, u32> = data.iter().cloned().collect();\n        assert_eq!(map.len(), 3);\n        assert_eq!(map.get(&1), Some(&2));\n        assert_eq!(map.get(&3), Some(&4));\n        assert_eq!(map.get(&5), Some(&6));\n    }\n}\n```", "<set::iter::IntoIter<T> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_count() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let into_iter = set.clone().into_iter();\n        assert_eq!(into_iter.count(), 3);\n\n        let empty_iter: IndexSet<i32> = IndexSet::new();\n        let into_iter_empty = empty_iter.into_iter();\n        assert_eq!(into_iter_empty.count(), 0);\n\n        let single_item_set: IndexSet<i32> = IndexSet::from([42]);\n        let single_item_iter = single_item_set.into_iter();\n        assert_eq!(single_item_iter.count(), 1);\n    }\n}\n```", "<set::iter::IntoIter<T> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_last() {\n        let mut index_set = IndexSet::new();\n        index_set.insert(\"a\");\n        index_set.insert(\"b\");\n        index_set.insert(\"c\");\n\n        let mut iter = index_set.clone().into_iter();\n        assert_eq!(iter.last(), Some(\"c\"));\n        assert_eq!(iter.last(), None); // Should return None as the iterator is exhausted.\n\n        let empty_iter: IndexSet<&str> = IndexSet::new();\n        let mut empty = empty_iter.into_iter();\n        assert_eq!(empty.last(), None); // Last on an empty iterator should return None.\n    }\n}\n```", "<set::iter::IntoIter<T> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_next() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let mut iter = set.into_iter();\n        \n        assert_eq!(iter.next(), Some(1));\n        assert_eq!(iter.next(), Some(2));\n        assert_eq!(iter.next(), Some(3));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        let mut iter = set.into_iter();\n\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_after_consuming() {\n        let mut set = IndexSet::new();\n        set.insert(10);\n        set.insert(20);\n        let mut iter = set.into_iter();\n\n        assert_eq!(iter.next(), Some(10));\n        assert_eq!(iter.next(), Some(20));\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None); // Ensure we still get None after consuming\n    }\n}\n```", "<set::iter::IntoIter<T> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_nth() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        let mut iter = set.into_iter();\n        \n        assert_eq!(iter.nth(0), Some(1));\n        assert_eq!(iter.nth(1), Some(3));\n        assert_eq!(iter.nth(0), None);\n    }\n\n    #[test]\n    fn test_nth_out_of_bounds() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(10);\n        set.insert(20);\n        set.insert(30);\n        \n        let mut iter = set.into_iter();\n        \n        assert_eq!(iter.nth(5), None);\n    }\n}\n```", "<set::iter::IntoIter<T> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Ensure you have the necessary imports\n    use crate::indexmap::set::iter::IntoIter;\n    use crate::indexmap::Bucket;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let iter: IntoIter<i32> = IntoIter::default();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let buckets = vec![Bucket::new(1), Bucket::new(2), Bucket::new(3)];\n        let iter: IntoIter<i32> = IntoIter::new(buckets);\n\n        assert_eq!(iter.size_hint(), (3, Some(3)));\n    }\n\n    #[test]\n    fn test_size_hint_after_consuming() {\n        let buckets = vec![Bucket::new(1), Bucket::new(2)];\n        let mut iter: IntoIter<i32> = IntoIter::new(buckets);\n\n        iter.next(); // Consume one element\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n    }\n}\n```", "<set::iter::Iter<'_, T> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_iter_clone() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let iter = set.iter();\n        let cloned_iter = iter.clone();\n\n        assert_eq!(iter.as_slice(), cloned_iter.as_slice());\n        assert!(iter.next().is_some());\n        assert!(cloned_iter.next().is_some());\n    }\n}\n```", "<set::iter::Iter<'_, T> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::iter::Iter;\n\n    #[test]\n    fn test_iter_default() {\n        let iter: Iter<i32> = Iter::default();\n        assert_eq!(iter.len(), 0);\n    }\n}\n```", "<set::iter::Iter<'_, T> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_next_back() {\n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        set.insert(\"b\");\n        set.insert(\"c\");\n        \n        let mut iter = set.iter();\n\n        assert_eq!(iter.next_back(), Some(&\"c\"));\n        assert_eq!(iter.next_back(), Some(&\"b\"));\n        assert_eq!(iter.next_back(), Some(&\"a\"));\n        assert_eq!(iter.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_on_empty() {\n        let mut set: IndexSet<&str> = IndexSet::new();\n        let mut iter = set.iter();\n\n        assert_eq!(iter.next_back(), None);\n    }\n}\n```", "<set::iter::Iter<'_, T> as core::iter::DoubleEndedIterator>::nth_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_nth_back() {\n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        set.insert(\"b\");\n        set.insert(\"c\");\n\n        let mut iter = set.iter();\n        \n        assert_eq!(iter.nth_back(0), Some(&\"c\"));\n        assert_eq!(iter.nth_back(1), Some(&\"b\"));\n        assert_eq!(iter.nth_back(2), Some(&\"a\"));\n        assert_eq!(iter.nth_back(3), None);\n    }\n\n    #[test]\n    fn test_nth_back_empty() {\n        let mut set: IndexSet<&str> = IndexSet::new();\n        let mut iter = set.iter();\n        \n        assert_eq!(iter.nth_back(0), None);\n    }\n\n    #[test]\n    fn test_nth_back_single_element() {\n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        \n        let mut iter = set.iter();\n        \n        assert_eq!(iter.nth_back(0), Some(&\"a\"));\n        assert_eq!(iter.nth_back(1), None);\n    }\n}\n```", "<set::iter::Iter<'_, T> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_len() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        let iter = set.iter();\n        assert_eq!(iter.len(), 3);\n        \n        set.remove(&2);\n        let iter = set.iter();\n        assert_eq!(iter.len(), 2);\n        \n        set.clear();\n        let iter = set.iter();\n        assert_eq!(iter.len(), 0);\n    }\n}\n```", "<set::iter::Iter<'a, T> as core::iter::Iterator>::collect": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_collect_from_iter() {\n        let input: Vec<(i32, &str)> = vec![(1, \"one\"), (2, \"two\"), (3, \"three\")];\n        let collected: IndexMap<i32, &str> = input.into_iter().collect();\n\n        assert_eq!(collected.len(), 3);\n        assert_eq!(collected[&1], \"one\");\n        assert_eq!(collected[&2], \"two\");\n        assert_eq!(collected[&3], \"three\");\n    }\n\n    #[test]\n    fn test_collect_empty() {\n        let input: Vec<(i32, &str)> = vec![];\n        let collected: IndexMap<i32, &str> = input.into_iter().collect();\n\n        assert_eq!(collected.len(), 0);\n    }\n\n    #[test]\n    fn test_collect_duplicates() {\n        let input: Vec<(i32, &str)> = vec![(1, \"one\"), (1, \"uno\"), (2, \"two\")];\n        let collected: IndexMap<i32, &str> = input.into_iter().collect();\n\n        assert_eq!(collected.len(), 2);\n        assert_eq!(collected[&1], \"uno\"); // The last value for key `1` should prevail\n        assert_eq!(collected[&2], \"two\");\n    }\n}\n```", "<set::iter::Iter<'a, T> as core::iter::Iterator>::count": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_count() {\n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        set.insert(\"b\");\n        set.insert(\"c\");\n\n        let iter = set.iter();\n        assert_eq!(iter.count(), 3);\n    }\n\n    #[test]\n    fn test_count_empty() {\n        let set: IndexSet<&str> = IndexSet::new();\n        let iter = set.iter();\n        assert_eq!(iter.count(), 0);\n    }\n\n    #[test]\n    fn test_count_with_duplicates() {\n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        set.insert(\"b\");\n        set.insert(\"a\"); // IndexSet does not allow duplicates\n\n        let iter = set.iter();\n        assert_eq!(iter.count(), 2); // Only \"a\" and \"b\" are unique\n    }\n}\n```", "<set::iter::Iter<'a, T> as core::iter::Iterator>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_last() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        let iter = set.iter();\n        assert_eq!(iter.clone().last(), Some(&3));\n    }\n\n    #[test]\n    fn test_last_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        let iter = set.iter();\n        assert_eq!(iter.clone().last(), None);\n    }\n\n    #[test]\n    fn test_last_single_element() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        \n        let iter = set.iter();\n        assert_eq!(iter.clone().last(), Some(&1));\n    }\n}\n```", "<set::iter::Iter<'a, T> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_next() {\n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        set.insert(\"b\");\n        set.insert(\"c\");\n\n        let mut iter = set.iter();\n        \n        assert_eq!(iter.next(), Some(&\"a\"));\n        assert_eq!(iter.next(), Some(&\"b\"));\n        assert_eq!(iter.next(), Some(&\"c\"));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let set: IndexSet<&str> = IndexSet::new();\n        let mut iter = set.iter();\n        \n        assert_eq!(iter.next(), None);\n    }\n}\n```", "<set::iter::Iter<'a, T> as core::iter::Iterator>::nth": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_nth() {\n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        set.insert(\"b\");\n        set.insert(\"c\");\n        \n        let mut iter = set.iter();\n        \n        assert_eq!(iter.nth(0), Some(&\"a\"));\n        assert_eq!(iter.nth(0), Some(&\"b\"));\n        assert_eq!(iter.nth(1), Some(&\"c\"));\n        assert_eq!(iter.nth(1), None);\n    }\n\n    #[test]\n    fn test_nth_out_of_bounds() {\n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        \n        let mut iter = set.iter();\n        \n        assert_eq!(iter.nth(1), None);\n    }\n\n    #[test]\n    fn test_nth_multiple_calls() {\n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        set.insert(\"b\");\n        set.insert(\"c\");\n        \n        let mut iter = set.iter();\n        \n        assert_eq!(iter.nth(0), Some(&\"a\"));\n        assert_eq!(iter.nth(1), Some(&\"b\"));\n        assert_eq!(iter.nth(1), None);\n    }\n}\n```", "<set::iter::Iter<'a, T> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        let iter = set.iter();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_single_element() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        let iter = set.iter();\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n    }\n\n    #[test]\n    fn test_size_hint_multiple_elements() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let iter = set.iter();\n        assert_eq!(iter.size_hint(), (3, Some(3)));\n    }\n\n    #[test]\n    fn test_size_hint_after_consuming_elements() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        let mut iter = set.iter();\n        let _ = iter.next(); // consume one element\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n    }\n\n    #[test]\n    fn test_size_hint_with_empty_after_iter() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        let mut iter = set.iter();\n        let _ = iter.next(); // consume one element\n        let _ = iter.next(); // consume the second element\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n}\n```", "<set::iter::Splice<'_, I, T, S> as core::iter::DoubleEndedIterator>::next_back": "```rust\nuse indexmap::IndexMap;\nuse indexmap::set::iter::Splice;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_next_back() {\n        let mut index_map: IndexMap<i32, i32> = IndexMap::new();\n        index_map.insert(1, 10);\n        index_map.insert(2, 20);\n        index_map.insert(3, 30);\n        \n        let mut splice_iter = index_map.splice(1..3, vec![(4, 40), (5, 50)]);\n        \n        assert_eq!(splice_iter.next_back().map(|(k, _)| k), Some(2));\n        assert_eq!(splice_iter.next_back().map(|(k, _)| k), Some(1));\n        assert_eq!(splice_iter.next_back(), None);\n    }\n\n    #[test]\n    fn test_next_back_empty() {\n        let mut index_map: IndexMap<i32, i32> = IndexMap::new();\n        let mut splice_iter = index_map.splice(0..0, vec![]);\n        \n        assert_eq!(splice_iter.next_back(), None);\n    }\n}\n```", "<set::iter::Splice<'_, I, T, S> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_splice_len() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        let splice_iter = map.splice(1..2, vec![(4, \"d\"), (5, \"e\")]);\n\n        // Check the length of the splice\n        assert_eq!(splice_iter.len(), 1);  // only one entry (\"b\") should be removed\n    }\n\n    #[test]\n    fn test_splice_len_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let splice_iter = map.splice(0..0, vec![(1, \"one\")]);\n\n        // Check the length of the splice\n        assert_eq!(splice_iter.len(), 0);  // nothing was removed\n    }\n\n    #[test]\n    fn test_splice_len_full() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        let splice_iter = map.splice(0..3, vec![(4, \"d\")]);\n\n        // Check the length of the splice\n        assert_eq!(splice_iter.len(), 3);  // all elements should be removed\n    }\n}\n```", "<set::iter::Splice<'_, I, T, S> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_next_returns_some() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let mut splice_iter = map.splice(1..2, vec![(3, \"c\")]);\n\n        assert_eq!(splice_iter.next(), Some(2));\n        assert_eq!(splice_iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_on_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        let mut splice_iter = map.splice(0..0, vec![]);\n\n        assert_eq!(splice_iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_after_splicing() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut splice_iter = map.splice(1..2, vec![(4, \"d\")]);\n\n        assert_eq!(splice_iter.next(), Some(2));\n        assert_eq!(splice_iter.next(), None);\n        assert_eq!(map.get(&1), Some(&\"a\"));\n        assert_eq!(map.get(&3), Some(&\"c\"));\n        assert_eq!(map.get(&4), Some(&\"d\"));\n    }\n}\n```", "<set::iter::Splice<'_, I, T, S> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        let splice = map.splice(0..1, vec![(3, 30)].into_iter());\n\n        assert_eq!(splice.size_hint(), (1, Some(1)));\n\n        let splice_empty: Vec<(i32, i32)> = Vec::new();\n        let splice_empty_iter = map.splice(0..0, splice_empty.into_iter());\n\n        assert_eq!(splice_empty_iter.size_hint(), (0, Some(0)));\n    }\n}\n```", "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::hash::BuildHasherDefault;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_symmetric_difference_clone() {\n        let set1: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::from([1, 2, 3]);\n        let set2: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::from([3, 4, 5]);\n        \n        let symmetric_diff = SymmetricDifference::new(&set1, &set2);\n        let cloned_diff = symmetric_diff.clone();\n\n        // Verify that the cloned iterator has the same elements\n        let original: Vec<_> = symmetric_diff.collect();\n        let cloned: Vec<_> = cloned_diff.collect();\n        assert_eq!(original, cloned);\n\n        // Ensure that cloning does not alter the original\n        assert_eq!(symmetric_diff.collect::<Vec<_>>(), original);\n    }\n}\n```", "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_next_back() {\n        let set1: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![1, 2, 3]);\n        let set2: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![2, 3, 4]);\n        \n        let symmetric_diff = SymmetricDifference::new(&set1, &set2);\n        let mut iter = symmetric_diff;\n\n        assert_eq!(iter.next_back(), Some(&4)); // Expect 4 from set2\n        assert_eq!(iter.next_back(), Some(&1)); // Expect 1 from set1\n        assert_eq!(iter.next_back(), None);      // No more elements\n    }\n}\n```", "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::iter::DoubleEndedIterator>::rfold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_rfold() {\n        let set1: IndexSet<i32, RandomState> = [1, 2, 3].iter().cloned().collect();\n        let set2: IndexSet<i32, RandomState> = [2, 3, 4].iter().cloned().collect();\n        let symmetric_diff = SymmetricDifference::new(&set1, &set2);\n        \n        let result = symmetric_diff.rfold(0, |acc, &x| acc + x);\n        \n        assert_eq!(result, 5); // 1 + 4 = 5\n    }\n}\n```", "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_fold_symmetric_difference() {\n        let set1: IndexSet<u32, RandomState> = IndexSet::from([1, 2, 3].to_vec());\n        let set2: IndexSet<u32, RandomState> = IndexSet::from([3, 4, 5].to_vec());\n\n        let symmetric_diff = SymmetricDifference::new(&set1, &set2);\n\n        let result = symmetric_diff.fold(0, |acc, &item| acc + item);\n\n        assert_eq!(result, 1 + 2 + 4 + 5);\n    }\n\n    #[test]\n    fn test_fold_with_initial_value() {\n        let set1: IndexSet<u32, RandomState> = IndexSet::from([1, 3].to_vec());\n        let set2: IndexSet<u32, RandomState> = IndexSet::from([2, 3].to_vec());\n\n        let symmetric_diff = SymmetricDifference::new(&set1, &set2);\n\n        let result = symmetric_diff.fold(10, |acc, &item| acc + item);\n\n        assert_eq!(result, 10 + 1 + 2);\n    }\n\n    #[test]\n    fn test_fold_empty_symmetric_difference() {\n        let set1: IndexSet<u32, RandomState> = IndexSet::from([1, 2, 3].to_vec());\n        let set2: IndexSet<u32, RandomState> = IndexSet::from([1, 2, 3].to_vec());\n\n        let symmetric_diff = SymmetricDifference::new(&set1, &set2);\n\n        let result = symmetric_diff.fold(0, |acc, &item| acc + item);\n\n        assert_eq!(result, 0);\n    }\n}\n```", "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::hash::BuildHasherDefault;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_symmetric_difference_next() {\n        let hasher = BuildHasherDefault::<RandomState>::default();\n        let set1: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::from([1, 2, 3]);\n        let set2: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::from([3, 4, 5]);\n\n        let mut symmetric_diff = SymmetricDifference::new(&set1, &set2);\n        \n        assert_eq!(symmetric_diff.next(), Some(&1));\n        assert_eq!(symmetric_diff.next(), Some(&2));\n        assert_eq!(symmetric_diff.next(), Some(&4));\n        assert_eq!(symmetric_diff.next(), Some(&5));\n        assert_eq!(symmetric_diff.next(), None);\n    }\n}\n```", "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_size_hint() {\n        let set1: IndexSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set2: IndexSet<i32> = [2, 3, 4].iter().cloned().collect();\n\n        let symmetric_diff = SymmetricDifference::new(&set1, &set2);\n        let (lower, upper) = symmetric_diff.size_hint();\n\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2)); // Since 1 and 4 are the symmetric difference\n    }\n\n    #[test]\n    fn test_size_hint_empty() {\n        let set1: IndexSet<i32> = [].iter().cloned().collect();\n        let set2: IndexSet<i32> = [].iter().cloned().collect();\n\n        let symmetric_diff = SymmetricDifference::new(&set1, &set2);\n        let (lower, upper) = symmetric_diff.size_hint();\n\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0)); // No elements in symmetric difference\n    }\n\n    #[test]\n    fn test_size_hint_one_element_different() {\n        let set1: IndexSet<i32> = [1].iter().cloned().collect();\n        let set2: IndexSet<i32> = [2].iter().cloned().collect();\n\n        let symmetric_diff = SymmetricDifference::new(&set1, &set2);\n        let (lower, upper) = symmetric_diff.size_hint();\n\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2)); // 1 and 2 are both in symmetric difference\n    }\n\n    #[test]\n    fn test_size_hint_multiple_elements() {\n        let set1: IndexSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set2: IndexSet<i32> = [3, 4, 5].iter().cloned().collect();\n\n        let symmetric_diff = SymmetricDifference::new(&set1, &set2);\n        let (lower, upper) = symmetric_diff.size_hint();\n\n        assert_eq!(lower, 4);\n        assert_eq!(upper, Some(4)); // 1, 2, 4, and 5 are in symmetric difference\n    }\n}\n```", "<set::iter::Union<'_, T, S> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_clone_union() {\n        let set1: IndexSet<i32, RandomState> = IndexSet::from(vec![1, 2, 3]);\n        let set2: IndexSet<i32, RandomState> = IndexSet::from(vec![3, 4, 5]);\n\n        let union = Union::new(&set1, &set2);\n        let cloned_union = union.clone();\n\n        assert_eq!(union.size_hint(), cloned_union.size_hint());\n        assert_eq!(union.collect::<IndexSet<_>>(), cloned_union.collect::<IndexSet<_>>());\n    }\n}\n```", "<set::iter::Union<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_builder::RandomState;\n    use std::hash::Hash;\n\n    #[test]\n    fn test_next_back() {\n        let set1: IndexSet<i32, RandomState> = vec![1, 2, 3].into_iter().collect();\n        let set2: IndexSet<i32, RandomState> = vec![3, 4, 5].into_iter().collect();\n        let union_iter = Union::new(&set1, &set2);\n\n        let mut union_iter = union_iter;\n\n        assert_eq!(union_iter.next_back(), Some(&5));\n        assert_eq!(union_iter.next_back(), Some(&4));\n        assert_eq!(union_iter.next_back(), Some(&3));\n        assert_eq!(union_iter.next_back(), Some(&2));\n        assert_eq!(union_iter.next_back(), Some(&1));\n        assert_eq!(union_iter.next_back(), None);\n    }\n}\n```", "<set::iter::Union<'_, T, S> as core::iter::DoubleEndedIterator>::rfold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_rfold() {\n        let set1: IndexSet<i32, RandomState> = [1, 2, 3].iter().cloned().collect();\n        let set2: IndexSet<i32, RandomState> = [3, 4, 5].iter().cloned().collect();\n        let union = Union::new(&set1, &set2);\n\n        let result = union.rfold(0, |acc, &x| acc + x);\n\n        assert_eq!(result, 15); // 1 + 2 + 3 + 4 + 5 = 15\n    }\n}\n```", "<set::iter::Union<'a, T, S> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::hash::BuildHasherDefault;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_fold() {\n        let set1: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::from_iter(vec![1, 2, 3]);\n        let set2: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::from_iter(vec![2, 3, 4]);\n        let union = Union::new(&set1, &set2);\n\n        let result = union.fold(0, |acc, &x| acc + x);\n        assert_eq!(result, 10); // 1 + 2 + 3 + 4 = 10\n    }\n\n    #[test]\n    fn test_fold_empty() {\n        let set1: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::new();\n        let set2: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::new();\n        let union = Union::new(&set1, &set2);\n\n        let result = union.fold(5, |acc, &x| acc + x);\n        assert_eq!(result, 5); // No elements to add, so result should be the initial value\n    }\n}\n```", "<set::iter::Union<'a, T, S> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_union_next() {\n        let set1: IndexSet<i32, RandomState> = vec![1, 2, 3].into_iter().collect();\n        let set2: IndexSet<i32, RandomState> = vec![2, 3, 4].into_iter().collect();\n        let union_iter = Union::new(&set1, &set2);\n\n        let result: Vec<_> = union_iter.collect();\n        let expected: Vec<_> = vec![&1, &2, &3, &4]; // Expected union result\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_union_next_empty() {\n        let set1: IndexSet<i32, RandomState> = IndexSet::new();\n        let set2: IndexSet<i32, RandomState> = IndexSet::new();\n        let union_iter = Union::new(&set1, &set2);\n\n        let result: Vec<_> = union_iter.collect();\n        let expected: Vec<_> = vec![]; // Expected union result for empty sets\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_union_next_with_one_empty_set() {\n        let set1: IndexSet<i32, RandomState> = vec![1, 2].into_iter().collect();\n        let set2: IndexSet<i32, RandomState> = IndexSet::new();\n        let union_iter = Union::new(&set1, &set2);\n\n        let result: Vec<_> = union_iter.collect();\n        let expected: Vec<_> = vec![&1, &2]; // Expected union result\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_union_next_with_duplicates() {\n        let set1: IndexSet<i32, RandomState> = vec![1, 2].into_iter().collect();\n        let set2: IndexSet<i32, RandomState> = vec![2, 3].into_iter().collect();\n        let union_iter = Union::new(&set1, &set2);\n\n        let result: Vec<_> = union_iter.collect();\n        let expected: Vec<_> = vec![&1, &2, &3]; // Expected union result, no duplicates\n        assert_eq!(result, expected);\n    }\n}\n```", "<set::iter::Union<'a, T, S> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::hash::BuildHasherDefault;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_size_hint() {\n        let set1: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::from([1, 2, 3]);\n        let set2: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::from([3, 4, 5]);\n        let union = Union::new(&set1, &set2);\n        \n        let (lower, upper) = union.size_hint();\n        assert_eq!(lower, 5);\n        assert_eq!(upper, Some(5));\n    }\n\n    #[test]\n    fn test_size_hint_empty() {\n        let set1: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::new();\n        let set2: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::new();\n        let union = Union::new(&set1, &set2);\n        \n        let (lower, upper) = union.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```", "<set::iter::UnitValue<I> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::set::iter::UnitValue;\n\n    #[test]\n    fn test_next_some() {\n        let vec = vec![1, 2, 3];\n        let iter = UnitValue(vec.iter());\n        let mut unit_value_iter = iter;\n\n        assert_eq!(unit_value_iter.next(), Some((&1, ())));\n        assert_eq!(unit_value_iter.next(), Some((&2, ())));\n        assert_eq!(unit_value_iter.next(), Some((&3, ())));\n    }\n\n    #[test]\n    fn test_next_none() {\n        let vec: Vec<i32> = vec![];\n        let iter = UnitValue(vec.iter());\n        let mut unit_value_iter = iter;\n\n        assert_eq!(unit_value_iter.next(), None);\n    }\n}\n```", "<set::slice::Slice<T> as core::cmp::Ord>::cmp": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::cmp::Ordering;\n\n    #[test]\n    fn test_cmp_equal() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 1,\n            value: \"a\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(1),\n            key: 1,\n            value: \"b\",\n        };\n        let slice1 = Slice { entries: [bucket1] };\n        let slice2 = Slice { entries: [bucket2] };\n        assert_eq!(slice1.cmp(&slice2), Ordering::Equal);\n    }\n\n    #[test]\n    fn test_cmp_less_than() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 1,\n            value: \"a\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: 2,\n            value: \"b\",\n        };\n        let slice1 = Slice { entries: [bucket1] };\n        let slice2 = Slice { entries: [bucket2] };\n        assert!(slice1.cmp(&slice2) == Ordering::Less);\n    }\n\n    #[test]\n    fn test_cmp_greater_than() {\n        let bucket1 = Bucket {\n            hash: HashValue(2),\n            key: 2,\n            value: \"b\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(1),\n            key: 1,\n            value: \"a\",\n        };\n        let slice1 = Slice { entries: [bucket1] };\n        let slice2 = Slice { entries: [bucket2] };\n        assert!(slice1.cmp(&slice2) == Ordering::Greater);\n    }\n\n    #[test]\n    fn test_cmp_empty_slices() {\n        let slice1 = Slice { entries: [] };\n        let slice2 = Slice { entries: [] };\n        assert_eq!(slice1.cmp(&slice2), Ordering::Equal);\n    }\n\n    #[test]\n    fn test_cmp_empty_vs_non_empty() {\n        let bucket = Bucket {\n            hash: HashValue(1),\n            key: 1,\n            value: \"a\",\n        };\n        let slice1 = Slice { entries: [] };\n        let slice2 = Slice { entries: [bucket] };\n        assert!(slice1.cmp(&slice2) == Ordering::Less);\n        assert!(slice2.cmp(&slice1) == Ordering::Greater);\n    }\n}\n```", "<set::slice::Slice<T> as core::cmp::PartialEq<[U; N]>>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::cmp::PartialEq;\n\n    #[test]\n    fn test_eq_with_equal_arrays() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 42,\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: 42,\n            value: \"value2\",\n        };\n        let slice = Slice {\n            entries: [bucket1, bucket2],\n        };\n        let array: [i32; 2] = [42, 42];\n\n        assert!(slice.eq(&array));\n    }\n\n    #[test]\n    fn test_eq_with_different_arrays() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 42,\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: 43,\n            value: \"value2\",\n        };\n        let slice = Slice {\n            entries: [bucket1, bucket2],\n        };\n        let array: [i32; 2] = [42, 44];\n\n        assert!(!slice.eq(&array));\n    }\n\n    #[test]\n    fn test_eq_with_different_lengths() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 42,\n            value: \"value1\",\n        };\n        let slice = Slice {\n            entries: [bucket1],\n        };\n        let array: [i32; 2] = [42, 42];\n\n        assert!(!slice.eq(&array));\n    }\n\n    #[test]\n    fn test_eq_with_empty_slice_and_array() {\n        let slice = Slice {\n            entries: [],\n        };\n        let array: [i32; 0] = [];\n\n        assert!(slice.eq(&array));\n    }\n}\n```", "<set::slice::Slice<T> as core::cmp::PartialEq<[U]>>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n\n    #[test]\n    fn test_eq() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n\n        let slice1 = Slice {\n            entries: [bucket1],\n        };\n\n        let slice2 = Slice {\n            entries: [bucket1],\n        };\n\n        let slice3 = Slice {\n            entries: [bucket2],\n        };\n        \n        // Test equality\n        assert!(slice1.eq(&[\"key1\"]));\n        assert!(slice1.eq(&[\"key1\"]));\n        assert!(!slice1.eq(&[\"key2\"]));\n        assert!(!slice1.eq(&[\"key1\", \"key2\"]));\n        assert!(!slice1.eq(&[]));\n        assert!(slice2.eq(&[\"key1\"]));\n        assert!(!slice3.eq(&[\"key1\"]));\n    }\n}\n```", "<set::slice::Slice<T> as core::cmp::PartialEq<set::slice::Slice<U>>>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::{Bucket, Slice};\n    \n    #[derive(Clone, Copy, Debug, PartialEq)]\n    struct TestKey(usize);\n    \n    #[derive(Clone, Debug, PartialEq)]\n    struct TestValue(String);\n    \n    #[test]\n    fn test_slice_eq() {\n        let bucket_a1 = Bucket { hash: HashValue(1), key: TestKey(1), value: TestValue(\"A\".to_string()) };\n        let bucket_a2 = Bucket { hash: HashValue(2), key: TestKey(2), value: TestValue(\"B\".to_string()) };\n        let bucket_b1 = Bucket { hash: HashValue(1), key: TestKey(1), value: TestValue(\"A\".to_string()) };\n        let bucket_b2 = Bucket { hash: HashValue(2), key: TestKey(2), value: TestValue(\"B\".to_string()) };\n        \n        let slice_a = Slice { entries: [bucket_a1, bucket_a2] };\n        let slice_b = Slice { entries: [bucket_b1, bucket_b2] };\n\n        assert!(slice_a.eq(&slice_b));\n\n        let bucket_c = Bucket { hash: HashValue(3), key: TestKey(3), value: TestValue(\"C\".to_string()) };\n        let slice_c = Slice { entries: [bucket_b1, bucket_c] };\n\n        assert!(!slice_a.eq(&slice_c));\n    }\n}\n```", "<set::slice::Slice<T> as core::cmp::PartialOrd>::partial_cmp": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::cmp::Ordering;\n\n    #[test]\n    fn test_partial_cmp() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 42,\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: 42,\n            value: \"value2\",\n        };\n        let slice1 = Slice {\n            entries: [bucket1, bucket2],\n        };\n        let slice2 = Slice {\n            entries: [bucket1.clone(), bucket2.clone()],\n        };\n        let slice3 = Slice {\n            entries: [bucket2.clone(), bucket1.clone()],\n        };\n\n        // Test equality\n        assert_eq!(slice1.partial_cmp(&slice2), Some(Ordering::Equal));\n        \n        // Test less than\n        assert!(slice1.partial_cmp(&slice3).unwrap() == Ordering::Less);\n        \n        // Test greater than\n        assert!(slice3.partial_cmp(&slice1).unwrap() == Ordering::Greater);\n        \n        // Test with empty Slice\n        let empty_slice = Slice::new();\n        assert_eq!(slice1.partial_cmp(&empty_slice), Some(Ordering::Greater));\n        assert_eq!(empty_slice.partial_cmp(&slice1), Some(Ordering::Less));\n    }\n}\n```", "<set::slice::Slice<T> as core::hash::Hash>::hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::Hasher;\n    use std::collections::hash_map::DefaultHasher;\n\n    #[test]\n    fn test_hash_empty_slice() {\n        let slice: Slice<i32> = Slice { entries: [] };\n        let mut hasher = DefaultHasher::new();\n        slice.hash(&mut hasher);\n        let hash_result = hasher.finish();\n        assert_eq!(hash_result, 0); // Expecting 0 hash for empty slice\n    }\n\n    #[test]\n    fn test_hash_single_element() {\n        let bucket = Bucket {\n            hash: HashValue(123),\n            key: 42,\n            value: \"value\",\n        };\n        let slice = Slice { entries: [bucket] };\n        let mut hasher = DefaultHasher::new();\n        slice.hash(&mut hasher);\n        let hash_result = hasher.finish();\n        assert!(hash_result != 0); // Expecting a non-zero hash for non-empty slice\n    }\n\n    #[test]\n    fn test_hash_multiple_elements() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 10,\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: 20,\n            value: \"value2\",\n        };\n        let slice = Slice { entries: [bucket1, bucket2] };\n        let mut hasher = DefaultHasher::new();\n        slice.hash(&mut hasher);\n        let hash_result = hasher.finish();\n        assert!(hash_result != 0); // Expecting a non-zero hash for multiple elements\n    }\n\n    #[test]\n    fn test_hash_determinism() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 30,\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: 40,\n            value: \"value2\",\n        };\n        let slice1 = Slice { entries: [bucket1, bucket2] };\n        let slice2 = Slice { entries: [bucket1, bucket2] };\n\n        let mut hasher1 = DefaultHasher::new();\n        slice1.hash(&mut hasher1);\n        let hash_result1 = hasher1.finish();\n\n        let mut hasher2 = DefaultHasher::new();\n        slice2.hash(&mut hasher2);\n        let hash_result2 = hasher2.finish();\n\n        assert_eq!(hash_result1, hash_result2); // Expecting the same hash for identical slices\n    }\n}\n```", "<set::slice::Slice<T> as core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::{Bound, Range};\n\n    #[test]\n    fn test_index() {\n        // Prepare test data\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let entries = [bucket1, bucket2];\n\n        let slice = Slice { entries };\n\n        // Define the range to test\n        let range: Range<usize> = 0..2;\n\n        // Call the index function\n        let result = slice.index(range);\n\n        // Check that the result is as expected\n        assert_eq!(result.len(), 2);\n        assert_eq!(result.entries[0].key, \"key1\");\n        assert_eq!(result.entries[1].key, \"key2\");\n    }\n\n    #[test]\n    fn test_index_empty() {\n        let entries: [Bucket<&str>; 0] = [];\n        let slice = Slice { entries };\n\n        let range: Range<usize> = 0..0;\n\n        // Call the index function\n        let result = slice.index(range);\n\n        // Check that the result is as expected\n        assert_eq!(result.len(), 0);\n    }\n}\n```", "<set::slice::Slice<T> as core::ops::Index<core::ops::Range<usize>>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::Range;\n\n    #[derive(Clone, Copy, Debug, PartialEq)]\n    struct TestKey(i32);\n    \n    #[derive(Clone, Copy, Debug)]\n    struct TestValue(i32);\n\n    #[test]\n    fn test_index_slice() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: TestKey(1), value: TestValue(10) },\n            Bucket { hash: HashValue(2), key: TestKey(2), value: TestValue(20) },\n            Bucket { hash: HashValue(3), key: TestKey(3), value: TestValue(30) },\n        ];\n\n        let slice = Slice { entries: buckets };\n\n        // Test indexing with a range\n        let sub_slice: &Slice<TestKey> = &slice[1..3];\n        \n        assert_eq!(sub_slice.len(), 2);\n        assert_eq!(sub_slice.entries[0].key, TestKey(2));\n        assert_eq!(sub_slice.entries[1].key, TestKey(3));\n    }\n}\n```", "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeFrom<usize>>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::RangeFrom;\n\n    #[test]\n    fn test_index() {\n        let buckets = [\n            Bucket {\n                hash: HashValue(1),\n                key: \"a\",\n                value: 1,\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: \"b\",\n                value: 2,\n            },\n            Bucket {\n                hash: HashValue(3),\n                key: \"c\",\n                value: 3,\n            },\n        ];\n\n        let slice = Slice { entries: buckets };\n\n        let result: &Slice<&str> = slice.index(RangeFrom { start: 1 });\n        \n        assert_eq!(result.len(), 2);\n        assert_eq!(result.entries[0].key, \"b\");\n        assert_eq!(result.entries[1].key, \"c\");\n    }\n}\n```", "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeFull>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::RangeFull;\n\n    #[test]\n    fn test_slice_index() {\n        // Arrange\n        let buckets = [\n            Bucket { hash: HashValue(1), key: 1, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"b\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"c\" },\n        ];\n\n        let slice = Slice { entries: buckets };\n\n        // Act\n        let result: &Slice<_> = &slice[RangeFull];\n\n        // Assert\n        assert_eq!(result.len(), slice.len());\n        assert_eq!(result.get_index(0), Some(&1));\n        assert_eq!(result.get_index(1), Some(&2));\n        assert_eq!(result.get_index(2), Some(&3));\n        assert!(result.is_empty() == false);\n    }\n}\n```", "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeInclusive<usize>>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n\n    #[test]\n    fn test_index_range_inclusive() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: 10, value: \"value1\" },\n            Bucket { hash: HashValue(2), key: 20, value: \"value2\" },\n            Bucket { hash: HashValue(3), key: 30, value: \"value3\" },\n        ];\n        let slice = Slice::from_slice(&buckets);\n\n        // Test valid range\n        let result: &Slice<usize> = slice.index(0..=1);\n        assert_eq!(result.len(), 2);\n        assert_eq!(result[0], 10);\n        assert_eq!(result[1], 20);\n\n        // Test full range\n        let result: &Slice<usize> = slice.index(0..=2);\n        assert_eq!(result.len(), 3);\n        assert_eq!(result[0], 10);\n        assert_eq!(result[1], 20);\n        assert_eq!(result[2], 30);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_out_of_bounds() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: 10, value: \"value1\" },\n        ];\n        let slice = Slice::from_slice(&buckets);\n        \n        // This should panic as the range is out of bounds\n        let _ = slice.index(0..=1);\n    }\n}\n```", "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeTo<usize>>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::RangeTo;\n\n    #[test]\n    fn test_index() {\n        let buckets = vec![\n            Bucket { hash: HashValue(1), key: 10, value: \"A\" },\n            Bucket { hash: HashValue(2), key: 20, value: \"B\" },\n            Bucket { hash: HashValue(3), key: 30, value: \"C\" },\n        ];\n        let slice = Slice { entries: buckets };\n\n        let result: &Slice<_> = &slice.index(..2);\n        assert_eq!(result.len(), 2);\n        assert_eq!(result.entries[0].key, 10);\n        assert_eq!(result.entries[1].key, 20);\n    }\n    \n    #[test]\n    fn test_index_empty_slice() {\n        let buckets: Vec<Bucket<i32>> = vec![];\n        let slice = Slice { entries: buckets };\n\n        let result: &Slice<_> = &slice.index(..0);\n        assert_eq!(result.len(), 0);\n    }\n    \n    #[test]\n    fn test_index_full_range() {\n        let buckets = vec![\n            Bucket { hash: HashValue(1), key: 10, value: \"A\" },\n            Bucket { hash: HashValue(2), key: 20, value: \"B\" },\n            Bucket { hash: HashValue(3), key: 30, value: \"C\" },\n        ];\n        let slice = Slice { entries: buckets };\n\n        let result: &Slice<_> = &slice.index(..3);\n        assert_eq!(result.len(), 3);\n        assert_eq!(result.entries[0].key, 10);\n        assert_eq!(result.entries[1].key, 20);\n        assert_eq!(result.entries[2].key, 30);\n    }\n}\n```", "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeToInclusive<usize>>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::RangeToInclusive;\n\n    #[test]\n    fn test_index() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 10, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 20, value: \"b\" },\n            Bucket { hash: HashValue(3), key: 30, value: \"c\" },\n        ];\n        \n        let slice = Slice { entries };\n\n        let result: &Slice<usize> = slice.index(0..=1);\n        \n        assert_eq!(result.len(), 2);\n        assert_eq!(result.entries[0].key, 10);\n        assert_eq!(result.entries[1].key, 20);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_out_of_bounds() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 10, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 20, value: \"b\" },\n        ];\n        \n        let slice = Slice { entries };\n\n        let _result: &Slice<usize> = slice.index(0..=3); // This should panic\n    }\n}\n```", "<set::slice::Slice<T> as core::ops::Index<usize>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt::Debug;\n\n    #[derive(Clone, Copy, Debug, PartialEq)]\n    struct TestKey(usize);\n    #[derive(Clone, Copy, Debug)]\n    struct TestValue(i32);\n\n    #[test]\n    fn test_index() {\n        let buckets = [\n            Bucket {\n                hash: HashValue(1),\n                key: TestKey(0),\n                value: TestValue(10),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: TestKey(1),\n                value: TestValue(20),\n            },\n        ];\n\n        let slice = Slice { entries: buckets };\n\n        assert_eq!(slice.index(0), &TestKey(0));\n        assert_eq!(slice.index(1), &TestKey(1));\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_out_of_bounds() {\n        let buckets = [\n            Bucket {\n                hash: HashValue(1),\n                key: TestKey(0),\n                value: TestValue(10),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: TestKey(1),\n                value: TestValue(20),\n            },\n        ];\n\n        let slice = Slice { entries: buckets };\n\n        let _ = slice.index(2); // This should panic\n    }\n}\n```", "Bucket::<K, V>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[derive(Clone, Debug, PartialEq)]\n    struct TestKey(usize);\n    \n    #[derive(Clone, Debug)]\n    struct TestValue(String);\n    \n    #[test]\n    fn test_key() {\n        let key = TestKey(1);\n        let value = TestValue(\"value\".to_string());\n        let hash_value = HashValue(42);\n        let bucket = Bucket { hash: hash_value, key, value };\n\n        // Call the key method\n        let result_key = bucket.key();\n\n        // Assert the result\n        assert_eq!(result_key, TestKey(1));\n    }\n}\n```", "Bucket::<K, V>::key_ref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_key_ref() {\n        let key = \"test_key\";\n        let value = \"test_value\";\n        let hash_value = HashValue(42);\n        let bucket = Bucket {\n            hash: hash_value,\n            key,\n            value,\n        };\n\n        assert_eq!(bucket.key_ref(), &key);\n    }\n\n    #[test]\n    fn test_key_ref_with_different_data_types() {\n        let key = 5;\n        let value = 3.14;\n        let hash_value = HashValue(24);\n        let bucket = Bucket {\n            hash: hash_value,\n            key,\n            value,\n        };\n\n        assert_eq!(bucket.key_ref(), &key);\n    }\n}\n```", "Bucket::<K, V>::key_value": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_key_value() {\n        let key = \"test_key\";\n        let value = \"test_value\";\n        let hash_value = HashValue(42);\n        let bucket = Bucket { hash: hash_value, key, value };\n\n        let (returned_key, returned_value) = bucket.key_value();\n\n        assert_eq!(returned_key, \"test_key\");\n        assert_eq!(returned_value, \"test_value\");\n    }\n}\n```", "Bucket::<K, V>::muts": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_muts() {\n        let mut bucket = Bucket {\n            hash: HashValue(42),\n            key: \"test_key\",\n            value: \"test_value\",\n        };\n\n        let (key_mut, value_mut) = bucket.muts();\n\n        *key_mut = \"new_key\";\n        *value_mut = \"new_value\";\n\n        assert_eq!(bucket.key_ref(), &\"new_key\");\n        assert_eq!(bucket.value_ref(), &\"new_value\");\n    }\n}\n```", "Bucket::<K, V>::ref_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_ref_mut() {\n        let mut bucket = Bucket {\n            hash: HashValue(10),\n            key: \"test_key\",\n            value: 42,\n        };\n\n        let (key_ref, value_mut) = bucket.ref_mut();\n        assert_eq!(key_ref, &\"test_key\");\n        *value_mut += 1;\n        assert_eq!(bucket.value_ref(), &43);\n    }\n}\n```", "Bucket::<K, V>::refs": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_refs() {\n        let key = 42;\n        let value = \"value\";\n        let bucket = Bucket {\n            hash: HashValue(1),\n            key,\n            value,\n        };\n\n        let (ref_key, ref_value) = bucket.refs();\n\n        assert_eq!(ref_key, &key);\n        assert_eq!(ref_value, &value);\n    }\n}\n```", "Bucket::<K, V>::value": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::HashValue;\n\n    #[test]\n    fn test_bucket_value() {\n        let key = \"test_key\";\n        let value = \"test_value\";\n        let hash_value = HashValue(42);\n        let bucket = Bucket {\n            hash: hash_value,\n            key,\n            value,\n        };\n\n        assert_eq!(bucket.value(), \"test_value\");\n    }\n}\n```", "Bucket::<K, V>::value_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_value_mut() {\n        // Arrange\n        let mut bucket = Bucket {\n            hash: HashValue(1),\n            key: \"key\",\n            value: 10,\n        };\n\n        // Act\n        let value_mut = bucket.value_mut();\n        *value_mut = 20; // Mutate the value\n\n        // Assert\n        assert_eq!(*bucket.value_ref(), 20);\n    }\n}\n```", "Bucket::<K, V>::value_ref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_value_ref() {\n        // Arrange\n        let key = \"test_key\";\n        let value = \"test_value\";\n        let bucket = Bucket {\n            hash: HashValue(123),\n            key,\n            value,\n        };\n\n        // Act\n        let result = bucket.value_ref();\n\n        // Assert\n        assert_eq!(result, &\"test_value\");\n    }\n}\n```", "HashValue::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_hashvalue_get() {\n        let hash_value = HashValue(42);\n        assert_eq!(hash_value.get(), 42);\n    }\n\n    #[test]\n    fn test_hashvalue_get_zero() {\n        let hash_value = HashValue(0);\n        assert_eq!(hash_value.get(), 0);\n    }\n\n    #[test]\n    fn test_hashvalue_get_large_value() {\n        let hash_value = HashValue(usize::MAX);\n        assert_eq!(hash_value.get(), usize::MAX as u64);\n    }\n}\n```", "TryReserveError::from_alloc": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::collections::TryReserveError as AllocTryReserveError;\n\n    #[test]\n    fn test_from_alloc() {\n        // Create a Mock Alloc error for testing\n        let alloc_error = AllocTryReserveError::from_capacity_overflow();\n        let try_reserve_error = TryReserveError::from_alloc(alloc_error);\n\n        // Check if the error kind is correctly set to Std\n        match try_reserve_error.kind {\n            TryReserveErrorKind::Std(_) => {}\n            _ => panic!(\"Expected TryReserveErrorKind::Std variant\"),\n        }\n    }\n}\n```", "TryReserveError::from_hashbrown": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::TryReserveError as HashbrownError;\n    use alloc::alloc::Layout;\n\n    #[test]\n    fn test_from_hashbrown_capacity_overflow() {\n        let error = HashbrownError::CapacityOverflow;\n        let result = TryReserveError::from_hashbrown(error);\n        match result.kind {\n            TryReserveErrorKind::CapacityOverflow => (),\n            _ => panic!(\"Expected CapacityOverflow error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_hashbrown_alloc_error() {\n        let layout = Layout::from_size_align(1, 1).unwrap();\n        let error = HashbrownError::AllocError { layout };\n        let result = TryReserveError::from_hashbrown(error);\n        match result.kind {\n            TryReserveErrorKind::AllocError { layout: result_layout } => {\n                assert_eq!(layout, result_layout);\n            },\n            _ => panic!(\"Expected AllocError error kind\"),\n        }\n    }\n}\n```", "map::IndexMap::<K, V, S>::append": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_append_unique_keys() {\n        let mut a = IndexMap::from([(1, \"one\"), (2, \"two\")]);\n        let mut b = IndexMap::from([(3, \"three\"), (4, \"four\")]);\n        a.append(&mut b);\n        \n        assert_eq!(a.len(), 4);\n        assert_eq!(b.len(), 0);\n        assert_eq!(a.get(&1), Some(&\"one\"));\n        assert_eq!(a.get(&2), Some(&\"two\"));\n        assert_eq!(a.get(&3), Some(&\"three\"));\n        assert_eq!(a.get(&4), Some(&\"four\"));\n    }\n\n    #[test]\n    fn test_append_with_existing_keys() {\n        let mut a = IndexMap::from([(1, \"one\"), (2, \"two\")]);\n        let mut b = IndexMap::from([(1, \"uno\"), (3, \"three\")]);\n        let old_capacity = b.capacity();\n\n        a.append(&mut b);\n\n        assert_eq!(a.len(), 3);\n        assert_eq!(b.len(), 0);\n        assert_eq!(b.capacity(), old_capacity);\n        assert_eq!(a.get(&1), Some(&\"uno\")); // \"one\" should be overwritten\n        assert_eq!(a.get(&2), Some(&\"two\"));\n        assert_eq!(a.get(&3), Some(&\"three\"));\n    }\n\n    #[test]\n    fn test_append_empty_map() {\n        let mut a = IndexMap::from([(1, \"one\")]);\n        let mut b = IndexMap::new();\n\n        a.append(&mut b);\n\n        assert_eq!(a.len(), 1);\n        assert_eq!(b.len(), 0);\n        assert_eq!(a.get(&1), Some(&\"one\"));\n    }\n\n    #[test]\n    fn test_append_last_key_overwritten() {\n        let mut a = IndexMap::from([(1, \"one\"), (2, \"two\")]);\n        let mut b = IndexMap::from([(2, \"two_new\"), (3, \"three\")]);\n\n        a.append(&mut b);\n\n        assert_eq!(a.len(), 3);\n        assert_eq!(a.get(&2), Some(&\"two_new\")); // Overwritten\n        assert_eq!(a.get(&3), Some(&\"three\"));\n    }\n}\n```", "map::IndexMap::<K, V, S>::as_mut_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_as_mut_slice() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let slice = map.as_mut_slice();\n        assert_eq!(slice.len(), 3);\n        assert_eq!(slice[0].key, 1);\n        assert_eq!(slice[0].value, 10);\n        assert_eq!(slice[1].key, 2);\n        assert_eq!(slice[1].value, 20);\n        assert_eq!(slice[2].key, 3);\n        assert_eq!(slice[2].value, 30);\n\n        // Modify the value of the second entry\n        slice[1].value_mut().assign(99);\n        assert_eq!(map[&2], 99);\n    }\n\n    #[test]\n    fn test_as_mut_slice_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let slice = map.as_mut_slice();\n        assert_eq!(slice.len(), 0);\n    }\n\n    #[test]\n    fn test_as_mut_slice_after_insert() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        let slice = map.as_mut_slice();\n        assert_eq!(slice.len(), 2);\n    }\n}\n```", "map::IndexMap::<K, V, S>::as_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap; // Adjust the import as necessary\n    use std::hash::BuildHasherDefault;\n\n    #[test]\n    fn test_as_slice() {\n        // Create a new IndexMap instance with default hasher\n        let mut map: IndexMap<i32, &str, BuildHasherDefault<rustc_hash::FxHasher>> = IndexMap::new();\n        \n        // Insert key-value pairs\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        // Get a slice of the map\n        let slice = map.as_slice();\n        \n        // Check the length of the slice\n        assert_eq!(slice.len(), 3);\n\n        // Check the key-value pairs\n        assert_eq!(slice[0].key, 1);\n        assert_eq!(slice[0].value, \"one\");\n        assert_eq!(slice[1].key, 2);\n        assert_eq!(slice[1].value, \"two\");\n        assert_eq!(slice[2].key, 3);\n        assert_eq!(slice[2].value, \"three\");\n    }\n\n    #[test]\n    fn test_as_slice_empty() {\n        // Create a new empty IndexMap\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        \n        // Get a slice of the empty map\n        let slice = map.as_slice();\n        \n        // Check the length of the slice\n        assert_eq!(slice.len(), 0);\n    }\n\n    #[test]\n    fn test_as_slice_after_insertion() {\n        // Create a new IndexMap instance\n        let mut map: IndexMap<char, &str> = IndexMap::new();\n        \n        // Insert key-value pairs\n        map.insert('a', \"alpha\");\n        map.insert('b', \"bravo\");\n        map.insert('c', \"charlie\");\n\n        // Get a slice of the map\n        let slice = map.as_slice();\n        \n        // Check the length of the slice\n        assert_eq!(slice.len(), 3);\n\n        // Check the key-value pairs\n        assert_eq!(slice[0].key, 'a');\n        assert_eq!(slice[0].value, \"alpha\");\n        assert_eq!(slice[1].key, 'b');\n        assert_eq!(slice[1].value, \"bravo\");\n        assert_eq!(slice[2].key, 'c');\n        assert_eq!(slice[2].value, \"charlie\");\n    }\n}\n```", "map::IndexMap::<K, V, S>::binary_search_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_binary_search_by_found() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let result = map.binary_search_by(|key, _| {\n            if *key < &2 {\n                Ordering::Less\n            } else if *key > &2 {\n                Ordering::Greater\n            } else {\n                Ordering::Equal\n            }\n        });\n\n        assert_eq!(result, Ok(1)); // 2 is found at index 1\n    }\n\n    #[test]\n    fn test_binary_search_by_not_found() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(3, \"three\");\n\n        let result = map.binary_search_by(|key, _| {\n            if *key < &2 {\n                Ordering::Less\n            } else {\n                Ordering::Greater\n            }\n        });\n\n        assert_eq!(result, Err(1)); // should be inserted at index 1\n    }\n\n    #[test]\n    fn test_binary_search_by_edge_case() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let result = map.binary_search_by(|key, _| {\n            if *key < &1 {\n                Ordering::Less\n            } else {\n                Ordering::Greater\n            }\n        });\n\n        assert_eq!(result, Err(0)); // should be inserted at index 0\n    }\n\n    #[test]\n    fn test_binary_search_by_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let result = map.binary_search_by(|key, _| Ordering::Greater);\n        assert_eq!(result, Err(0)); // should be inserted at index 0\n    }\n}\n```", "map::IndexMap::<K, V, S>::binary_search_by_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_binary_search_by_key_found() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(3, \"b\");\n        map.insert(5, \"c\");\n\n        let result = map.binary_search_by_key(&3, |k, _| k.cmp(&3));\n        assert_eq!(result, Ok(1));\n    }\n\n    #[test]\n    fn test_binary_search_by_key_not_found() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(3, \"b\");\n        map.insert(5, \"c\");\n\n        let result = map.binary_search_by_key(&4, |k, _| k.cmp(&4));\n        assert_eq!(result, Err(2));\n    }\n\n    #[test]\n    fn test_binary_search_by_key_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let result = map.binary_search_by_key(&1, |k, _| k.cmp(&1));\n        assert_eq!(result, Err(0));\n    }\n\n    #[test]\n    fn test_binary_search_by_key_multiple() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(1, \"b\");\n        map.insert(3, \"c\");\n        map.insert(5, \"d\");\n\n        let result = map.binary_search_by_key(&1, |k, _| k.cmp(&1));\n        assert_eq!(result, Ok(1));  // The first occurrence after 1\n    }\n\n    #[test]\n    fn test_binary_search_by_key_with_value() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let result = map.binary_search_by_key(&\"b\", |_, v| v.cmp(&\"b\"));\n        assert_eq!(result, Ok(1));  // Matching the value\n    }\n}\n```", "map::IndexMap::<K, V, S>::binary_search_keys": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_binary_search_keys_found() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(3, \"b\");\n        map.insert(5, \"c\");\n\n        assert_eq!(map.binary_search_keys(&3), Ok(1));\n        assert_eq!(map.binary_search_keys(&1), Ok(0));\n        assert_eq!(map.binary_search_keys(&5), Ok(2));\n    }\n\n    #[test]\n    fn test_binary_search_keys_not_found() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(3, \"b\");\n        map.insert(5, \"c\");\n\n        assert_eq!(map.binary_search_keys(&2), Err(1)); // Should suggest index 1 for insertion\n        assert_eq!(map.binary_search_keys(&4), Err(2)); // Should suggest index 2 for insertion\n        assert_eq!(map.binary_search_keys(&6), Err(3)); // Should suggest index 3 for insertion\n    }\n\n    #[test]\n    fn test_binary_search_keys_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n\n        assert_eq!(map.binary_search_keys(&1), Err(0)); // Should suggest index 0 for insertion\n    }\n\n    #[test]\n    fn test_binary_search_keys_duplicates() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(1, \"b\");\n\n        assert_eq!(map.binary_search_keys(&1), Ok(0)); // Duplicate keys, should still find\n    }\n}\n```", "map::IndexMap::<K, V, S>::capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_capacity_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_non_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        assert!(map.capacity() >= 2);\n    }\n\n    #[test]\n    fn test_capacity_after_clear() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.clear();\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_after_insertion() {\n        let mut map: IndexMap<i32, i32> = IndexMap::with_capacity(10);\n        assert_eq!(map.capacity(), 10);\n        map.insert(1, 10);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_capacity_reserve() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.reserve(10);\n        assert!(map.capacity() >= 10);\n    }\n}\n```", "map::IndexMap::<K, V, S>::clear": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_clear() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        assert_eq!(map.len(), 3);\n        map.clear();\n        assert_eq!(map.len(), 0);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_clear_preserves_capacity() {\n        let mut map: IndexMap<i32, &str> = IndexMap::with_capacity(10);\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let capacity_before = map.capacity();\n        map.clear();\n        assert_eq!(map.capacity(), capacity_before);\n    }\n\n    #[test]\n    fn test_clear_on_empty_map() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        assert_eq!(map.len(), 0);\n        map.clear();\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_clear_after_inserts() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.clear();\n        assert!(map.get(&1).is_none());\n        assert!(map.get(&2).is_none());\n    }\n}\n```", "map::IndexMap::<K, V, S>::contains_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::BuildHasherDefault;\n    use std::collections::hash_map::DefaultHasher;\n\n    type IndexMap<K, V> = map::IndexMap<K, V, BuildHasherDefault<DefaultHasher>>;\n\n    #[test]\n    fn test_contains_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        assert!(map.contains_key(&1));\n        assert!(map.contains_key(&2));\n        assert!(!map.contains_key(&3));\n    }\n\n    #[test]\n    fn test_contains_key_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        assert!(!map.contains_key(&1));\n        assert!(!map.contains_key(&0));\n    }\n\n    #[test]\n    fn test_contains_key_with_different_reference() {\n        let mut map: IndexMap<String, i32> = IndexMap::new();\n        map.insert(\"key\".to_string(), 10);\n        assert!(map.contains_key(\"key\"));\n        assert!(!map.contains_key(\"invalid_key\"));\n    }\n\n    #[test]\n    fn test_contains_key_with_custom_type() {\n        #[derive(Hash, PartialEq, Eq)]\n        struct CustomKey {\n            id: i32,\n        }\n\n        let mut map: IndexMap<CustomKey, &str> = IndexMap::new();\n        map.insert(CustomKey { id: 1 }, \"first\");\n        map.insert(CustomKey { id: 2 }, \"second\");\n\n        assert!(map.contains_key(&CustomKey { id: 1 }));\n        assert!(!map.contains_key(&CustomKey { id: 3 }));\n    }\n}\n```", "map::IndexMap::<K, V, S>::drain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_drain() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let drained: Vec<_> = map.drain(1..3).collect();\n        \n        assert_eq!(drained, vec![(2, \"b\"), (3, \"c\")]);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&1), Some(&\"a\"));\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_drain_panic_start_gt_end() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        // This should panic\n        let _: Vec<_> = map.drain(2..1).collect();\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_drain_panic_end_gt_len() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n\n        // This should panic\n        let _: Vec<_> = map.drain(0..2).collect();\n    }\n\n    #[test]\n    fn test_drain_entire_map() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let drained: Vec<_> = map.drain(..).collect();\n        \n        assert_eq!(drained, vec![(1, \"a\"), (2, \"b\")]);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_drain_with_empty_map() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n\n        let drained: Vec<_> = map.drain(..).collect();\n        \n        assert!(drained.is_empty());\n        assert!(map.is_empty());\n    }\n}\n```", "map::IndexMap::<K, V, S>::entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_entry_vacant_insertion() {\n        let mut map = IndexMap::new();\n        {\n            let entry = map.entry(1);\n            match entry {\n                Entry::Vacant(vacant) => {\n                    vacant.insert(\"value1\");\n                }\n                _ => panic!(\"Expected Vacant Entry\"),\n            }\n        }\n        assert_eq!(map.get(&1), Some(&\"value1\"));\n    }\n\n    #[test]\n    fn test_entry_occupied_replacement() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"value1\");\n        {\n            let entry = map.entry(1);\n            match entry {\n                Entry::Occupied(occupied) => {\n                    assert_eq!(occupied.get(), &\"value1\");\n                    occupied.insert(\"value2\");\n                }\n                _ => panic!(\"Expected Occupied Entry\"),\n            }\n        }\n        assert_eq!(map.get(&1), Some(&\"value2\"));\n    }\n\n    #[test]\n    fn test_entry_nonexistent() {\n        let mut map = IndexMap::new();\n        {\n            let entry = map.entry(2);\n            match entry {\n                Entry::Vacant(vacant) => {\n                    vacant.insert(\"value3\");\n                }\n                _ => panic!(\"Expected Vacant Entry\"),\n            }\n        }\n        assert_eq!(map.get(&2), Some(&\"value3\"));\n        \n        // Now let's access a non-existent entry\n        let entry = map.entry(3);\n        match entry {\n            Entry::Vacant(vacant) => {\n                vacant.insert(\"value4\");\n            }\n            _ => panic!(\"Expected Vacant Entry\"),\n        }\n        assert_eq!(map.get(&3), Some(&\"value4\"));\n    }\n    \n    #[test]\n    fn test_entry_replacing_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(3, \"value1\");\n        {\n            let entry = map.entry(3);\n            match entry {\n                Entry::Occupied(occupied) => {\n                    assert_eq!(occupied.get(), &\"value1\");\n                    occupied.insert(\"value2\");\n                }\n                _ => panic!(\"Expected Occupied Entry\"),\n            }\n        }\n        assert_eq!(map.get(&3), Some(&\"value2\"));\n    }\n}\n```", "map::IndexMap::<K, V, S>::first": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_first_with_elements() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        \n        let first = map.first();\n        assert_eq!(first, Some((&1, &\"one\")));\n    }\n\n    #[test]\n    fn test_first_with_single_element() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        \n        let first = map.first();\n        assert_eq!(first, Some((&1, &\"one\")));\n    }\n\n    #[test]\n    fn test_first_with_empty_map() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        \n        let first = map.first();\n        assert_eq!(first, None);\n    }\n}\n```", "map::IndexMap::<K, V, S>::first_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_first_entry_non_empty() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        assert!(map.first_entry().is_some());\n        let entry = map.first_entry().unwrap();\n        assert_eq!(entry.key(), &1);\n        assert_eq!(entry.get(), &\"a\");\n    }\n\n    #[test]\n    fn test_first_entry_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        assert!(map.first_entry().is_none());\n    }\n\n    #[test]\n    fn test_first_entry_multiple_insertions() {\n        let mut map = IndexMap::new();\n        map.insert(3, \"c\");\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        assert!(map.first_entry().is_some());\n        let entry = map.first_entry().unwrap();\n        assert_eq!(entry.key(), &3);\n        assert_eq!(entry.get(), &\"c\");\n    }\n\n    #[test]\n    fn test_first_entry_with_mutation() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        let entry = map.first_entry().unwrap();\n        entry.insert(\"c\");\n        assert_eq!(map.get(&1), Some(&\"c\"));\n    }\n}\n```", "map::IndexMap::<K, V, S>::first_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_first_mut_when_empty() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        assert_eq!(map.first_mut(), None);\n    }\n\n    #[test]\n    fn test_first_mut_with_one_element() {\n        let mut map = IndexMap::new();\n        map.insert(1, String::from(\"value1\"));\n\n        let first = map.first_mut();\n        assert!(first.is_some());\n\n        if let Some((key, value)) = first {\n            assert_eq!(*key, 1);\n            assert_eq!(*value, \"value1\");\n            *value = String::from(\"new_value1\");\n        }\n\n        assert_eq!(map[&1], \"new_value1\");\n    }\n\n    #[test]\n    fn test_first_mut_with_multiple_elements() {\n        let mut map = IndexMap::new();\n        map.insert(1, String::from(\"value1\"));\n        map.insert(2, String::from(\"value2\"));\n\n        let first = map.first_mut();\n        assert!(first.is_some());\n\n        if let Some((key, value)) = first {\n            assert_eq!(*key, 1);\n            assert_eq!(*value, \"value1\");\n            *value = String::from(\"new_value1\");\n        }\n\n        assert_eq!(map[&1], \"new_value1\");\n        assert_eq!(map[&2], \"value2\");\n    }\n\n    #[test]\n    fn test_first_mut_with_mutation() {\n        let mut map = IndexMap::new();\n        map.insert(10, String::from(\"value10\"));\n        map.insert(20, String::from(\"value20\"));\n\n        if let Some((key, value)) = map.first_mut() {\n            assert_eq!(*key, 10);\n            assert_eq!(*value, \"value10\");\n\n            *value = String::from(\"updated_value10\");\n        }\n\n        assert_eq!(map[&10], \"updated_value10\");\n        assert_eq!(map[&20], \"value20\");\n    }\n}\n```", "map::IndexMap::<K, V, S>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_existing_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let value = map.get(&2);\n        assert_eq!(value, Some(&\"two\"));\n    }\n\n    #[test]\n    fn test_get_non_existing_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let value = map.get(&3);\n        assert_eq!(value, None);\n    }\n\n    #[test]\n    fn test_get_empty_map() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let value = map.get(&1);\n        assert_eq!(value, None);\n    }\n\n    #[test]\n    fn test_get_after_insertion() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        map.insert(2, \"two updated\");\n        let value = map.get(&2);\n        assert_eq!(value, Some(&\"two updated\"));\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_disjoint_indices_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_disjoint_indices_mut() {\n        let mut map = IndexMap::from([(1, 'a'), (3, 'b'), (2, 'c')]);\n        let result = map.get_disjoint_indices_mut([2, 0]);\n        assert!(result.is_ok());\n        let values = result.unwrap();\n        assert_eq!(values[0], (&2, &mut 'c'));\n        assert_eq!(values[1], (&1, &mut 'a'));\n    }\n\n    #[test]\n    fn test_get_disjoint_indices_mut_invalid_index() {\n        let mut map = IndexMap::from([(1, 'a'), (3, 'b'), (2, 'c')]);\n        let result = map.get_disjoint_indices_mut([2, 3]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_get_disjoint_indices_mut_duplicate_indices() {\n        let mut map = IndexMap::from([(1, 'a'), (3, 'b'), (2, 'c')]);\n        let result = std::panic::catch_unwind(|| {\n            map.get_disjoint_indices_mut([2, 2]);\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_get_disjoint_indices_mut_empty_map() {\n        let mut map: IndexMap<i32, char> = IndexMap::new();\n        let result = map.get_disjoint_indices_mut([0]);\n        assert!(result.is_err());\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_disjoint_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_disjoint_mut_unique_keys() {\n        let mut map = IndexMap::from([(1, 'a'), (3, 'b'), (2, 'c')]);\n        let result = map.get_disjoint_mut([&2, &1]);\n        assert_eq!(result, [Some(&mut 'c'), Some(&mut 'a')]);\n    }\n\n    #[test]\n    #[should_panic(expected = \"duplicate keys found\")]\n    fn test_get_disjoint_mut_duplicate_keys() {\n        let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);\n        let _ = map.get_disjoint_mut([&1, &1]);\n    }\n\n    #[test]\n    fn test_get_disjoint_mut_non_existent_key() {\n        let mut map = IndexMap::from([(1, 'a'), (2, 'b')]);\n        let result = map.get_disjoint_mut([&3, &1]);\n        assert_eq!(result, [None, Some(&mut 'a')]);\n    }\n\n    #[test]\n    fn test_get_disjoint_mut_empty_map() {\n        let mut map: IndexMap<i32, char> = IndexMap::new();\n        let result = map.get_disjoint_mut([&1]);\n        assert_eq!(result, [None]);\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_full_existing_key() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"one\", 1);\n        map.insert(\"two\", 2);\n        map.insert(\"three\", 3);\n\n        assert_eq!(map.get_full(\"two\"), Some((1, &\"two\", &2)));\n    }\n\n    #[test]\n    fn test_get_full_non_existing_key() {\n        let map: IndexMap<&str, i32> = IndexMap::new();\n\n        assert_eq!(map.get_full(\"non_existing\"), None);\n    }\n\n    #[test]\n    fn test_get_full_empty_map() {\n        let map: IndexMap<&str, i32> = IndexMap::new();\n\n        assert_eq!(map.get_full(\"any_key\"), None);\n    }\n\n    #[test]\n    fn test_get_full_with_repeated_insertion() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"key\", 1);\n        map.insert(\"key\", 2);\n\n        assert_eq!(map.get_full(\"key\"), Some((0, &\"key\", &2)));\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_full_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_full_mut_existing_key() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        \n        let key = \"a\";\n        if let Some((index, key_ref, value_ref)) = map.get_full_mut(key) {\n            assert_eq!(index, 0);\n            assert_eq!(key_ref, &\"a\");\n            *value_ref += 1; // Modify value through mutable reference\n            assert_eq!(map[\"a\"], 2); // Value should change\n        } else {\n            panic!(\"Expected key to exist\");\n        }\n    }\n\n    #[test]\n    fn test_get_full_mut_non_existing_key() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        \n        let key = \"b\";\n        let result = map.get_full_mut(key);\n        assert!(result.is_none(), \"Expected None for non-existing key\");\n    }\n\n    #[test]\n    fn test_get_full_mut_multiple_keys() {\n        let mut map: IndexMap<u32, i32> = IndexMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        \n        let key = 1;\n        if let Some((index, key_ref, value_ref)) = map.get_full_mut(&key) {\n            assert_eq!(index, 0);\n            assert_eq!(key_ref, &1);\n            *value_ref += 50; // Modify value through mutable reference\n            assert_eq!(map[&1], 150); // Value should change\n        } else {\n            panic!(\"Expected key to exist\");\n        }\n\n        let key = 2;\n        if let Some((index, key_ref, value_ref)) = map.get_full_mut(&key) {\n            assert_eq!(index, 1);\n            assert_eq!(key_ref, &2);\n            *value_ref += 100; // Modify value through mutable reference\n            assert_eq!(map[&2], 300); // Value should change\n        } else {\n            panic!(\"Expected key to exist\");\n        }\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_index": "```rust\n#[cfg(test)]\nmod tests {\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_index() {\n        let mut map = IndexMap::new();\n        map.insert('a', 1);\n        map.insert('b', 2);\n        map.insert('c', 3);\n\n        assert_eq!(map.get_index(0), Some((&'a', &1)));\n        assert_eq!(map.get_index(1), Some((&'b', &2)));\n        assert_eq!(map.get_index(2), Some((&'c', &3)));\n        assert_eq!(map.get_index(3), None);\n    }\n\n    #[test]\n    fn test_get_index_empty() {\n        let map: IndexMap<char, i32> = IndexMap::new();\n        assert_eq!(map.get_index(0), None);\n    }\n\n    #[test]\n    fn test_get_index_with_large_data() {\n        let mut map = IndexMap::new();\n        for i in 0..1000 {\n            map.insert(i, i * 2);\n        }\n\n        for i in 0..1000 {\n            assert_eq!(map.get_index(i), Some((&i, &(i * 2))));\n        }\n\n        assert_eq!(map.get_index(1000), None);\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_index_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_index_entry_valid_index() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        let entry = map.get_index_entry(1);\n        assert!(entry.is_some());\n        assert_eq!(entry.unwrap().key(), &\"key2\");\n        assert_eq!(entry.unwrap().value(), &\"value2\");\n    }\n\n    #[test]\n    fn test_get_index_entry_invalid_index() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        let entry = map.get_index_entry(2); // index 2 is out of bounds\n        assert!(entry.is_none());\n    }\n\n    #[test]\n    fn test_get_index_entry_empty_map() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let entry = map.get_index_entry(0); // map is empty\n        assert!(entry.is_none());\n    }\n\n    #[test]\n    fn test_get_index_entry_at_zero() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        let entry = map.get_index_entry(0);\n        assert!(entry.is_some());\n        assert_eq!(entry.unwrap().key(), &\"key1\");\n        assert_eq!(entry.unwrap().value(), &\"value1\");\n    }\n\n    #[test]\n    fn test_get_index_entry_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        let entry = map.get_index_entry(5); // index 5 is out of bounds\n        assert!(entry.is_none());\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_index_mut() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n        map.insert(2, \"two\".to_string());\n        map.insert(3, \"three\".to_string());\n\n        // Valid index\n        if let Some((key, value)) = map.get_index_mut(1) {\n            assert_eq!(*key, 2);\n            assert_eq!(*value, \"two\");\n            *value = \"updated\".to_string();\n        }\n\n        // Check updated value\n        assert_eq!(map.get(&2), Some(&\"updated\".to_string()));\n\n        // Invalid index\n        assert_eq!(map.get_index_mut(3), None);\n    }\n\n    #[test]\n    fn test_get_index_mut_empty() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        // Should return None when the map is empty\n        assert_eq!(map.get_index_mut(0), None);\n    }\n\n    #[test]\n    fn test_get_index_mut_out_of_bounds() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n\n        // Index 1 is out of bounds\n        assert_eq!(map.get_index_mut(1), None);\n    }\n\n    #[test]\n    fn test_get_index_mut_after_insert() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n        map.insert(2, \"two\".to_string());\n\n        // Valid index after adding two elements\n        if let Some((key, value)) = map.get_index_mut(0) {\n            assert_eq!(*key, 1);\n            assert_eq!(*value, \"one\");\n            *value = \"updated_one\".to_string();\n        }\n\n        // Valid index for second element\n        if let Some((key, value)) = map.get_index_mut(1) {\n            assert_eq!(*key, 2);\n            assert_eq!(*value, \"two\");\n        }\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_index_of": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_index_of_empty_map() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        assert_eq!(map.get_index_of(&1), None);\n    }\n\n    #[test]\n    fn test_get_index_of_single_entry() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        assert_eq!(map.get_index_of(&1), Some(0));\n        assert_eq!(map.get_index_of(&2), None);\n    }\n\n    #[test]\n    fn test_get_index_of_multiple_entries() {\n        let mut map = IndexMap::new();\n        map.insert(2, 20);\n        map.insert(1, 10);\n        map.insert(3, 30);\n        assert_eq!(map.get_index_of(&1), Some(1));\n        assert_eq!(map.get_index_of(&2), Some(0));\n        assert_eq!(map.get_index_of(&3), Some(2));\n        assert_eq!(map.get_index_of(&4), None);\n    }\n\n    #[test]\n    fn test_get_index_of_nonexistent_entry() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        assert_eq!(map.get_index_of(&3), None);\n        assert_eq!(map.get_index_of(&2), Some(1));\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_key_value": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_key_value_present() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"key1\", 10);\n        map.insert(\"key2\", 20);\n        \n        let result = map.get_key_value(&\"key1\");\n        assert_eq!(result, Some((&\"key1\", &10)));\n    }\n\n    #[test]\n    fn test_get_key_value_absent() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"key1\", 10);\n        \n        let result = map.get_key_value(&\"key2\");\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_key_value_empty_map() {\n        let map: IndexMap<&str, i32> = IndexMap::new();\n        \n        let result = map.get_key_value(&\"key1\");\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_key_value_multiple_insertions() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"key1\", 10);\n        map.insert(\"key1\", 20); // updating the value for \"key1\"\n        \n        let result = map.get_key_value(&\"key1\");\n        assert_eq!(result, Some((&\"key1\", &20)));\n    }\n\n    #[test]\n    fn test_get_key_value_with_non_existing_key() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"key1\", 10);\n        map.insert(\"key2\", 20);\n        \n        let result = map.get_key_value(&\"key3\"); // key3 does not exist\n        assert_eq!(result, None);\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_mut_existing_key() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        {\n            let value = map.get_mut(&1);\n            assert_eq!(value, Some(&mut 10));\n            *value.unwrap() = 15; // Mutate the value\n        }\n        \n        assert_eq!(map.get(&1), Some(&15));\n    }\n\n    #[test]\n    fn test_get_mut_non_existing_key() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n\n        let value = map.get_mut(&2);\n        assert_eq!(value, None);\n    }\n\n    #[test]\n    fn test_get_mut_after_insert() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        {\n            let value = map.get_mut(&2);\n            assert_eq!(value, Some(&mut 20));\n            *value.unwrap() = 25; // Mutate the value\n        }\n        \n        assert_eq!(map.get(&2), Some(&25));\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_range": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_range_valid_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let range = 0..2;\n        let result = map.get_range(range).unwrap();\n        let expected: Vec<_> = vec![(&1, &\"a\"), (&2, &\"b\")];\n        \n        assert_eq!(result, &Slice::from_slice(&expected));\n    }\n\n    #[test]\n    fn test_get_range_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let range = 0..1;\n        \n        let result = map.get_range(range);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_range_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let range = 2..4; // Out of bounds\n        let result = map.get_range(range);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_range_single_element() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n\n        let range = 0..1;\n        let result = map.get_range(range).unwrap();\n        let expected: Vec<_> = vec![(&1, &\"a\")];\n        \n        assert_eq!(result, &Slice::from_slice(&expected));\n    }\n\n    #[test]\n    fn test_get_range_full_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let range = 0..3; // Full range\n        let result = map.get_range(range).unwrap();\n        let expected: Vec<_> = vec![(&1, &\"a\"), (&2, &\"b\"), (&3, &\"c\")];\n        \n        assert_eq!(result, &Slice::from_slice(&expected));\n    }\n}\n```", "map::IndexMap::<K, V, S>::get_range_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_range_mut_valid_range() {\n        let mut map = IndexMap::new();\n        map.insert(0, \"a\");\n        map.insert(1, \"b\");\n        map.insert(2, \"c\");\n\n        let range = 0..2; // Valid range\n        let slice = map.get_range_mut(range);\n        assert!(slice.is_some());\n        \n        let slice = slice.unwrap();\n        assert_eq!(slice.len(), 2);\n        \n        // Modify the contents and ensure it reflects in the original map\n        slice[0] = \"x\";\n        assert_eq!(map.get(&0), Some(&\"x\"));\n    }\n\n    #[test]\n    fn test_get_range_mut_invalid_range() {\n        let mut map = IndexMap::new();\n        map.insert(0, \"a\");\n        map.insert(1, \"b\");\n\n        let range = 2..4; // Invalid range\n        let slice = map.get_range_mut(range);\n        assert!(slice.is_none());\n    }\n\n    #[test]\n    fn test_get_range_mut_empty_map() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        \n        let range = 0..1; // Valid range for empty map\n        let slice = map.get_range_mut(range);\n        assert!(slice.is_none());\n    }\n\n    #[test]\n    fn test_get_range_mut_full_range() {\n        let mut map = IndexMap::new();\n        map.insert(0, \"a\");\n        map.insert(1, \"b\");\n        map.insert(2, \"c\");\n\n        let range = 0..map.len(); // Valid full range\n        let slice = map.get_range_mut(range);\n        assert!(slice.is_some());\n        \n        let slice = slice.unwrap();\n        assert_eq!(slice.len(), 3);\n    }\n}\n```", "map::IndexMap::<K, V, S>::hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_hash_with_existing_key() {\n        let mut map: IndexMap<i32, &str, RandomState> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let hash_value = map.hash(&1);\n        assert_eq!(hash_value.get(), 1); // Adjust based on RandomState implementation\n    }\n\n    #[test]\n    fn test_hash_with_non_existing_key() {\n        let map: IndexMap<i32, &str, RandomState> = IndexMap::new();\n        let hash_value = map.hash(&42);\n        assert_eq!(hash_value.get(), 42); // Adjust based on RandomState implementation\n    }\n\n    #[test]\n    fn test_hash_with_different_key() {\n        let mut map: IndexMap<String, &str, RandomState> = IndexMap::new();\n        map.insert(\"key1\".to_string(), \"value1\");\n\n        let hash_value = map.hash(&\"key1\".to_string());\n        assert_eq!(hash_value.get(), \"key1\".hash() as usize); // Adjust based on RandomState implementation\n    }\n\n    #[test]\n    fn test_hash_struct_key() {\n        #[derive(Hash, PartialEq, Eq)]\n        struct Key {\n            id: i32,\n        }\n\n        let mut map: IndexMap<Key, &str, RandomState> = IndexMap::new();\n        map.insert(Key { id: 1 }, \"value1\");\n\n        let hash_value = map.hash(&Key { id: 1 });\n        assert_eq!(hash_value.get(), 1); // Adjust based on RandomState implementation\n    }\n}\n```", "map::IndexMap::<K, V, S>::hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_hasher() {\n        // Create an IndexMap with a specific hasher\n        let hasher = RandomState::new();\n        let mut map: IndexMap<i32, i32, RandomState> = IndexMap::with_hasher(hasher);\n\n        // Verify that the hasher is the same as the one used to create the map\n        assert_eq!(map.hasher(), &map.hash_builder);\n    }\n}\n```", "map::IndexMap::<K, V, S>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_insert_new_key() {\n        let mut map = IndexMap::new();\n        let result = map.insert(\"key1\", \"value1\");\n        assert_eq!(result, None);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(\"key1\"), Some(&\"value1\"));\n    }\n\n    #[test]\n    fn test_insert_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        let result = map.insert(\"key1\", \"value2\");\n        assert_eq!(result, Some(\"value1\"));\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(\"key1\"), Some(&\"value2\"));\n    }\n\n    #[test]\n    fn test_insert_multiple_keys() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(\"key1\"), Some(&\"value1\"));\n        assert_eq!(map.get(\"key2\"), Some(&\"value2\"));\n    }\n\n    #[test]\n    fn test_insert_order() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        map.insert(\"key3\", \"value3\");\n        \n        let keys: Vec<_> = map.keys().collect();\n        assert_eq!(keys, vec![\"key1\", \"key2\", \"key3\"]);\n    }\n\n    #[test]\n    fn test_insert_return_value() {\n        let mut map = IndexMap::new();\n        let result = map.insert(\"key1\", \"value1\");\n        assert_eq!(result, None);\n        \n        let result = map.insert(\"key1\", \"value2\");\n        assert_eq!(result, Some(\"value1\"));\n    }\n}\n```", "map::IndexMap::<K, V, S>::insert_before": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_insert_before_new_key() {\n        let mut map: IndexMap<char, ()> = IndexMap::new();\n        assert_eq!(map.insert_before(0, '*', ()), (0, None));\n        assert_eq!(map.get_index_of(&'*'), Some(0));\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_insert_before_existing_key() {\n        let mut map: IndexMap<char, ()> = IndexMap::new();\n        map.insert('a', ());\n        map.insert('b', ());\n        assert_eq!(map.insert_before(1, 'a', ()), (0, Some(())));\n        assert_eq!(map.get_index_of(&'a'), Some(0)); // 'a' should be at index 0\n        assert_eq!(map.get_index_of(&'b'), Some(1)); // 'b' should be at index 1\n    }\n\n    #[test]\n    fn test_insert_before_shift_existing_key() {\n        let mut map: IndexMap<char, ()> = IndexMap::new();\n        map.insert('a', ());\n        map.insert('b', ());\n        assert_eq!(map.insert_before(1, 'b', ()), (1, Some(())));\n        assert_eq!(map.get_index_of(&'b'), Some(1)); // 'b' moves to index 1\n        assert_eq!(map.get_index_of(&'a'), Some(0)); // 'a' stays at index 0\n    }\n\n    #[test]\n    fn test_insert_before_out_of_bounds() {\n        let mut map: IndexMap<char, ()> = IndexMap::new();\n        map.insert('a', ());\n        let result = std::panic::catch_unwind(|| {\n            map.insert_before(2, 'b', ());\n        });\n        assert!(result.is_err()); // should panic\n    }\n\n    #[test]\n    fn test_insert_before_at_end() {\n        let mut map: IndexMap<char, ()> = IndexMap::new();\n        map.insert('a', ());\n        map.insert('b', ());\n        assert_eq!(map.insert_before(2, '*', ()), (2, None));\n        assert_eq!(map.get_index_of(&'*'), Some(2)); // '*' at the end\n        assert_eq!(map.len(), 3);\n    }\n}\n```", "map::IndexMap::<K, V, S>::insert_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_insert_full_new_key() {\n        let mut map = IndexMap::new();\n        let (index, old_value) = map.insert_full(\"key1\", 10);\n        assert_eq!(index, 0);\n        assert_eq!(old_value, None);\n        assert_eq!(map.get(\"key1\"), Some(&10));\n    }\n\n    #[test]\n    fn test_insert_full_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 10);\n        let (index, old_value) = map.insert_full(\"key1\", 20);\n        assert_eq!(index, 0);\n        assert_eq!(old_value, Some(10));\n        assert_eq!(map.get(\"key1\"), Some(&20));\n    }\n\n    #[test]\n    fn test_insert_full_multiple_keys() {\n        let mut map = IndexMap::new();\n        let (index1, old_value1) = map.insert_full(\"key1\", 10);\n        let (index2, old_value2) = map.insert_full(\"key2\", 20);\n        assert_eq!(index1, 0);\n        assert_eq!(old_value1, None);\n        assert_eq!(index2, 1);\n        assert_eq!(old_value2, None);\n        assert_eq!(map.get(\"key1\"), Some(&10));\n        assert_eq!(map.get(\"key2\"), Some(&20));\n    }\n\n    #[test]\n    fn test_insert_full_ordering() {\n        let mut map = IndexMap::new();\n        map.insert_full(\"key1\", 10);\n        map.insert_full(\"key2\", 20);\n        let (index, old_value) = map.insert_full(\"key1\", 30);\n        assert_eq!(index, 0);\n        assert_eq!(old_value, Some(10));\n        assert_eq!(map.get(\"key1\"), Some(&30));\n        assert_eq!(map.get(\"key2\"), Some(&20));\n    }\n}\n```", "map::IndexMap::<K, V, S>::insert_sorted": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn insert_sorted_inserts_at_correct_position() {\n        let mut map = IndexMap::new();\n        map.insert_sorted('b', 1);\n        map.insert_sorted('a', 2);\n        map.insert_sorted('c', 3);\n\n        assert_eq!(map.keys().collect::<Vec<_>>(), &['a', 'b', 'c']);\n    }\n\n    #[test]\n    fn insert_sorted_updates_existing_value() {\n        let mut map = IndexMap::new();\n        map.insert_sorted('b', 1);\n        map.insert_sorted('a', 2);\n        let (index, old_value) = map.insert_sorted('b', 3);\n\n        assert_eq!(index, 1);\n        assert_eq!(old_value, Some(1));\n        assert_eq!(map['b'], 3);\n    }\n\n    #[test]\n    fn insert_sorted_handles_unsorted() {\n        let mut map = IndexMap::new();\n        map.insert('b', 1);\n        map.insert('a', 2);\n        map.insert('c', 3);\n\n        let (index, old_value) = map.insert_sorted('b', 4);\n\n        assert_eq!(index, 1);\n        assert_eq!(old_value, Some(1));\n        assert_eq!(map['b'], 4);\n        \n        let (index, old_value) = map.insert_sorted('d', 5);\n        assert_eq!(index, 3);\n        assert_eq!(old_value, None);\n        assert_eq!(map.keys().collect::<Vec<_>>(), &['b', 'a', 'c', 'd']);\n    }\n\n    #[test]\n    fn insert_sorted_empty_map() {\n        let mut map = IndexMap::new();\n        let (index, old_value) = map.insert_sorted('a', 1);\n\n        assert_eq!(index, 0);\n        assert_eq!(old_value, None);\n        assert_eq!(map.keys().collect::<Vec<_>>(), &['a']);\n    }\n\n    #[test]\n    fn insert_sorted_duplicate() {\n        let mut map = IndexMap::new();\n        map.insert_sorted('a', 1);\n        map.insert_sorted('b', 2);\n        \n        let (index, old_value) = map.insert_sorted('a', 3);\n        assert_eq!(index, 0);\n        assert_eq!(old_value, Some(1));\n        assert_eq!(map['a'], 3);\n    }\n}\n```", "map::IndexMap::<K, V, S>::into_boxed_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_boxed_slice() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let boxed_slice = map.into_boxed_slice();\n\n        assert_eq!(boxed_slice.len(), 3);\n        assert_eq!(&boxed_slice[0], &(1, \"one\"));\n        assert_eq!(&boxed_slice[1], &(2, \"two\"));\n        assert_eq!(&boxed_slice[2], &(3, \"three\"));\n    }\n\n    #[test]\n    fn test_into_boxed_slice_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n\n        let boxed_slice = map.into_boxed_slice();\n\n        assert_eq!(boxed_slice.len(), 0);\n    }\n\n    #[test]\n    fn test_into_boxed_slice_after_clear() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.clear();\n\n        let boxed_slice = map.into_boxed_slice();\n\n        assert_eq!(boxed_slice.len(), 0);\n    }\n}\n```", "map::IndexMap::<K, V, S>::into_keys": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_keys() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let keys: Vec<_> = map.into_keys().collect();\n        assert_eq!(keys, vec![\"a\", \"b\", \"c\"]);\n    }\n\n    #[test]\n    fn test_into_keys_empty() {\n        let map: IndexMap<String, i32> = IndexMap::new();\n        let keys: Vec<_> = map.into_keys().collect();\n        assert!(keys.is_empty());\n    }\n\n    #[test]\n    fn test_into_keys_after_move() {\n        let mut map = IndexMap::new();\n        map.insert(\"x\", 10);\n        map.insert(\"y\", 20);\n\n        let keys1: Vec<_> = map.into_keys().collect();\n        assert_eq!(keys1, vec![\"x\", \"y\"]);\n\n        // map is moved, verify it can't be used anymore\n        let keys2: Vec<_> = map.into_keys().collect();\n        assert_eq!(keys2, vec![]);\n    }\n}\n```", "map::IndexMap::<K, V, S>::into_values": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_values() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n        map.insert(2, \"two\".to_string());\n        map.insert(3, \"three\".to_string());\n\n        let values: Vec<String> = map.into_values().collect();\n        assert_eq!(values, vec![\"one\".to_string(), \"two\".to_string(), \"three\".to_string()]);\n    }\n\n    #[test]\n    fn test_empty_into_values() {\n        let map: IndexMap<i32, String> = IndexMap::new();\n        let values: Vec<String> = map.into_values().collect();\n        assert!(values.is_empty());\n    }\n\n    #[test]\n    fn test_into_values_with_duplicate_keys() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n        map.insert(1, \"two\".to_string());\n\n        let values: Vec<String> = map.into_values().collect();\n        assert_eq!(values.len(), 2);\n        assert!(values.contains(&\"one\".to_string()));\n        assert!(values.contains(&\"two\".to_string()));\n    }\n}\n```", "map::IndexMap::<K, V, S>::is_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import the necessary items from the outer module\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_is_empty() {\n        // Test with an empty map\n        let empty_map: IndexMap<i32, &str> = IndexMap::new();\n        assert!(empty_map.is_empty());\n\n        // Test with a map that has items\n        let mut map_with_items = IndexMap::new();\n        map_with_items.insert(1, \"one\");\n        assert!(!map_with_items.is_empty());\n\n        // Test after removing the only item\n        map_with_items.remove(&1);\n        assert!(map_with_items.is_empty());\n\n        // Test with a map that is initialized with a capacity\n        let mut initialized_map: IndexMap<i32, &str> = IndexMap::with_capacity(10);\n        assert!(initialized_map.is_empty());\n        initialized_map.insert(2, \"two\");\n        assert!(!initialized_map.is_empty());\n    }\n}\n```", "map::IndexMap::<K, V, S>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_iter_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let mut iter = map.iter();\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_single() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        let mut iter = map.iter();\n        assert_eq!(iter.next(), Some((&1, &\"one\")));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_multiple() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        \n        let mut iter = map.iter();\n        \n        assert_eq!(iter.next(), Some((&1, &\"one\")));\n        assert_eq!(iter.next(), Some((&2, &\"two\")));\n        assert_eq!(iter.next(), Some((&3, &\"three\")));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_order() {\n        let mut map = IndexMap::new();\n        map.insert(2, \"two\");\n        map.insert(1, \"one\");\n        map.insert(3, \"three\");\n        \n        let mut iter = map.iter();\n        \n        assert_eq!(iter.next(), Some((&2, &\"two\")));\n        assert_eq!(iter.next(), Some((&1, &\"one\")));\n        assert_eq!(iter.next(), Some((&3, &\"three\")));\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "map::IndexMap::<K, V, S>::iter_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn iter_mut_test() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        // Get a mutable iterator\n        let mut iter = map.iter_mut();\n\n        // Collect mutable references to values\n        let first_mut = iter.next().unwrap();\n        let second_mut = iter.next().unwrap();\n\n        // Assert initial values\n        assert_eq!(*first_mut, (&1, &mut 10));\n        assert_eq!(*second_mut, (&2, &mut 20));\n\n        // Modify values through mutable references\n        *first_mut.1 += 5;\n        *second_mut.1 += 5;\n\n        // Assert that values have been modified\n        assert_eq!(map[&1], 15);\n        assert_eq!(map[&2], 25);\n    }\n\n    #[test]\n    fn iter_mut_empty_test() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let mut iter = map.iter_mut();\n\n        // Assert that iterator returns None\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn iter_mut_after_modification_test() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        // Get a mutable iterator\n        let mut iter = map.iter_mut();\n\n        // Modify the first value\n        if let Some((_, val)) = iter.next() {\n            *val += 10;\n        }\n\n        // Collect remaining values\n        let second_val = iter.next().unwrap();\n        \n        // Assert values\n        assert_eq!(map[&1], 20);\n        assert_eq!(second_val, (&2, &mut 20));\n    }\n}\n```", "map::IndexMap::<K, V, S>::keys": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn keys_test() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let keys: Vec<_> = map.keys().collect();\n        assert_eq!(keys, vec![\"a\", \"b\", \"c\"]);\n    }\n\n    #[test]\n    fn keys_empty_test() {\n        let map: IndexMap<String, i32> = IndexMap::new();\n        let keys: Vec<_> = map.keys().collect();\n        assert_eq!(keys, Vec::<&String>::new());\n    }\n\n    #[test]\n    fn keys_after_removal_test() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.remove(\"a\");\n        \n        let keys: Vec<_> = map.keys().collect();\n        assert_eq!(keys, vec![\"b\"]);\n    }\n\n    #[test]\n    fn keys_after_multiple_inserts_test() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        map.insert(\"b\", 4);  // Update the value of key 'b'\n        \n        let keys: Vec<_> = map.keys().collect();\n        assert_eq!(keys, vec![\"a\", \"b\", \"c\"]);\n    }\n}\n```", "map::IndexMap::<K, V, S>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last_on_empty_map() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        assert_eq!(map.last(), None);\n    }\n\n    #[test]\n    fn test_last_on_single_element_map() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        assert_eq!(map.last(), Some((&1, &\"one\")));\n    }\n\n    #[test]\n    fn test_last_on_multiple_elements() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        assert_eq!(map.last(), Some((&3, &\"three\")));\n    }\n\n    #[test]\n    fn test_last_after_removal() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        map.remove(&3);\n        assert_eq!(map.last(), Some((&2, &\"two\")));\n    }\n\n    #[test]\n    fn test_last_after_multiple_removals() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        map.remove(&2);\n        map.remove(&3);\n        assert_eq!(map.last(), Some((&1, &\"one\")));\n    }\n}\n```", "map::IndexMap::<K, V, S>::last_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last_entry() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let last_entry = map.last_entry();\n        assert!(last_entry.is_some());\n        let last_entry = last_entry.unwrap();\n        assert_eq!(last_entry.key, &2);\n        assert_eq!(last_entry.get(), &\"two\");\n\n        map.insert(3, \"three\");\n        let last_entry = map.last_entry();\n        assert!(last_entry.is_some());\n        let last_entry = last_entry.unwrap();\n        assert_eq!(last_entry.key, &3);\n        assert_eq!(last_entry.get(), &\"three\");\n\n        map.pop(); // remove last entry\n        let last_entry = map.last_entry();\n        assert!(last_entry.is_some());\n        let last_entry = last_entry.unwrap();\n        assert_eq!(last_entry.key, &2);\n        assert_eq!(last_entry.get(), &\"two\");\n    }\n\n    #[test]\n    fn test_last_entry_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        let last_entry = map.last_entry();\n        assert!(last_entry.is_none());\n    }\n}\n```", "map::IndexMap::<K, V, S>::last_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last_mut() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let (key, value_mut) = map.last_mut().expect(\"Expected some value\");\n        assert_eq!(key, &3);\n        *value_mut = \"updated\";\n\n        assert_eq!(map.get(&3), Some(&\"updated\"));\n    }\n\n    #[test]\n    fn test_last_mut_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        assert!(map.last_mut().is_none());\n    }\n\n    #[test]\n    fn test_last_mut_single_entry() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n\n        let (key, value_mut) = map.last_mut().expect(\"Expected some value\");\n        assert_eq!(key, &1);\n        *value_mut = \"updated\";\n\n        assert_eq!(map.get(&1), Some(&\"updated\"));\n    }\n}\n```", "map::IndexMap::<K, V, S>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_len_empty() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_len_after_insert() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        assert_eq!(map.len(), 2);\n    }\n\n    #[test]\n    fn test_len_after_remove() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.remove(&1);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_len_after_clear() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.clear();\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_len_after_multiple_operations() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        map.remove(&2);\n        map.insert(4, 40);\n        assert_eq!(map.len(), 3);\n    }\n}\n```", "map::IndexMap::<K, V, S>::move_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_move_index() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        // Moving index 0 to index 2\n        map.move_index(0, 2);\n        assert_eq!(map.get_index(0), Some((&2, &\"b\")));\n        assert_eq!(map.get_index(1), Some((&3, &\"c\")));\n        assert_eq!(map.get_index(2), Some((&1, &\"a\")));\n        \n        // Moving index 2 to index 0\n        map.move_index(2, 0);\n        assert_eq!(map.get_index(0), Some((&1, &\"a\")));\n        assert_eq!(map.get_index(1), Some((&3, &\"c\")));\n        assert_eq!(map.get_index(2), Some((&2, &\"b\")));\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_move_index_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        // This should panic as `to` index is out of bounds\n        map.move_index(0, 2);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_move_index_out_of_bounds_negative() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        // This should panic as `from` index is out of bounds\n        map.move_index(2, 0);\n    }\n}\n```", "map::IndexMap::<K, V, S>::partition_point": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_partition_point() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        map.insert(4, \"d\");\n        \n        let partition_index = map.partition_point(|k, _| *k < 3);\n\n        assert_eq!(partition_index, 2); // index 2 is where the first element >= 3 is\n    }\n\n    #[test]\n    fn test_partition_point_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let partition_index = map.partition_point(|k, _| *k < 3);\n        \n        assert_eq!(partition_index, 0); // empty map\n    }\n\n    #[test]\n    fn test_partition_point_single() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        \n        let partition_index = map.partition_point(|k, _| *k < 1);\n        \n        assert_eq!(partition_index, 0); // the only element is >= 1\n    }\n\n    #[test]\n    fn test_partition_point_boundary() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let partition_index = map.partition_point(|k, _| *k <= 2);\n        \n        assert_eq!(partition_index, 2); // index 2 is the first element > 2\n    }\n}\n```", "map::IndexMap::<K, V, S>::pop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_pop() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let popped = map.pop();\n        assert_eq!(popped, Some((3, \"c\")));\n        assert_eq!(map.len(), 2);\n        \n        let popped_again = map.pop();\n        assert_eq!(popped_again, Some((2, \"b\")));\n        assert_eq!(map.len(), 1);\n        \n        let last_popped = map.pop();\n        assert_eq!(last_popped, Some((1, \"a\")));\n        assert_eq!(map.len(), 0);\n        \n        let none_popped = map.pop();\n        assert_eq!(none_popped, None);\n    }\n\n    #[test]\n    fn test_pop_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        let popped = map.pop();\n        assert_eq!(popped, None);\n    }\n\n    #[test]\n    fn test_pop_order_preservation() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        \n        map.pop();\n        assert_eq!(map.get(&1), Some(&\"a\"));\n        assert_eq!(map.get(&2), None);\n    }\n}\n```", "map::IndexMap::<K, V, S>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_remove_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let removed_value = map.remove(&2);\n        assert_eq!(removed_value, Some(\"b\"));\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&2).is_none());\n    }\n\n    #[test]\n    fn test_remove_non_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n\n        let removed_value = map.remove(&2);\n        assert_eq!(removed_value, None);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&1), Some(&\"a\"));\n    }\n\n    #[test]\n    fn test_remove_key_preserves_other_keys() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let removed_value = map.remove(&1);\n        assert_eq!(removed_value, Some(\"a\"));\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&2), Some(&\"b\"));\n        assert_eq!(map.get(&3), Some(&\"c\"));\n    }\n\n    #[test]\n    fn test_remove_multiple_keys() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        map.insert(4, \"d\");\n\n        let removed_value = map.remove(&3);\n        assert_eq!(removed_value, Some(\"c\"));\n        assert_eq!(map.len(), 3);\n        assert!(map.get(&3).is_none());\n        assert_eq!(map.get(&1), Some(&\"a\"));\n        assert_eq!(map.get(&2), Some(&\"b\"));\n        assert_eq!(map.get(&4), Some(&\"d\"));\n    }\n\n    #[test]\n    fn test_remove_key_ordering() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let removed_value = map.remove(&1);\n        assert_eq!(removed_value, Some(\"a\"));\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&2), Some(&\"b\"));\n        assert_eq!(map.get(&3), Some(&\"c\"));\n    }\n}\n```", "map::IndexMap::<K, V, S>::remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust the import paths according to your module structure\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_remove_entry_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        \n        let removed_entry = map.remove_entry(&1);\n        \n        assert_eq!(removed_entry, Some((1, \"a\")));\n        assert_eq!(map.len(), 1);\n        assert!(map.get(&1).is_none());\n        assert_eq!(map.get(&2), Some(&\"b\"));\n    }\n\n    #[test]\n    fn test_remove_entry_non_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        \n        let removed_entry = map.remove_entry(&2);\n        \n        assert_eq!(removed_entry, None);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_remove_entry_multiple_items() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let removed_entry = map.remove_entry(&2);\n        \n        assert_eq!(removed_entry, Some((2, \"b\")));\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&2).is_none());\n        assert_eq!(map.get(&1), Some(&\"a\"));\n        assert_eq!(map.get(&3), Some(&\"c\"));\n    }\n\n    #[test]\n    fn test_remove_entry_with_deprecation() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"value\");\n\n        let removed_entry = map.remove_entry(&1);\n        \n        assert_eq!(removed_entry, Some((1, \"value\")));\n        assert_eq!(map.len(), 0);\n        assert!(map.get(&1).is_none());\n        \n        // Check that the method is deprecated.\n        #[cfg(feature = \"test_deprecation\")]\n        #[allow(deprecated)]\n        {\n            let removed_entry_deprecated = map.remove_entry(&1);\n            assert_eq!(removed_entry_deprecated, None);\n        }\n    }\n}\n```", "map::IndexMap::<K, V, S>::reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_reserve() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n\n        assert_eq!(map.capacity(), 0);\n\n        map.reserve(5);\n        assert!(map.capacity() >= 5);\n\n        map.reserve(10);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_reserve_with_existing_entries() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        assert!(map.capacity() >= 2);\n        \n        map.reserve(5);\n        assert!(map.capacity() >= 7); // Should have capacity for at least existing entries + 5\n    }\n\n    #[test]\n    fn test_reserve_zero() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.reserve(0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_reserve_exact() {\n        let mut map: IndexMap<i32, i32> = IndexMap::with_capacity(0);\n        assert_eq!(map.capacity(), 0);\n\n        map.reserve_exact(3);\n        assert!(map.capacity() >= 3);\n\n        map.reserve_exact(5);\n        assert!(map.capacity() >= 5);\n    }\n}\n```", "map::IndexMap::<K, V, S>::reserve_exact": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_reserve_exact() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.reserve_exact(5);\n        assert!(map.capacity() >= 5);\n        assert_eq!(map.len(), 0);\n        \n        // Inserting elements to check if we can still add\n        map.insert(1, 10);\n        map.insert(2, 20);\n        assert_eq!(map.len(), 2);\n        assert!(map.capacity() >= 5);\n        \n        // Reserve more\n        map.reserve_exact(5);\n        assert!(map.capacity() >= 10);\n        \n        // Insert more to check behavior\n        map.insert(3, 30);\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn test_reserve_exact_no_overallocate() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.reserve_exact(0);\n        assert_eq!(map.capacity(), 0);\n        \n        // Even with 0, we shouldn't drop to a negative capacity\n        map.reserve_exact(5);\n        assert!(map.capacity() >= 5);\n        \n        map.insert(1, 10);\n        assert_eq!(map.len(), 1);\n    }\n    \n    #[test]\n    fn test_reserve_exact_large_input() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.reserve_exact(100);\n        assert!(map.capacity() >= 100);\n        \n        for i in 0..100 {\n            map.insert(i, i * 2);\n        }\n        \n        assert_eq!(map.len(), 100);\n        assert!(map.capacity() >= 100);\n    }\n}\n```", "map::IndexMap::<K, V, S>::retain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_retain() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        map.insert(4, 40);\n        \n        map.retain(|&k, &mut v| {\n            if k % 2 == 0 {\n                v += 1; // Increment the value for even keys\n                true\n            } else {\n                false // Remove odd keys\n            }\n        });\n\n        assert_eq!(map.len(), 2); // Should only have keys 2 and 4\n        assert_eq!(map.get(&2), Some(&21)); // 20 incremented to 21\n        assert_eq!(map.get(&4), Some(&41)); // 40 incremented to 41\n        assert_eq!(map.get(&1), None); // Key 1 should be gone\n        assert_eq!(map.get(&3), None); // Key 3 should be gone\n    }\n\n    #[test]\n    fn test_retain_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.retain(|_, _| true); // Should not panic\n        assert_eq!(map.len(), 0); // Still empty\n    }\n\n    #[test]\n    fn test_retain_no_elements() {\n        let mut map = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.retain(|_, _| false); // Remove all elements\n        \n        assert_eq!(map.len(), 0); // Should be empty\n    }\n}\n```", "map::IndexMap::<K, V, S>::reverse": "```rust\n#[cfg(test)]\nmod tests {\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_reverse() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        \n        let expected_order = vec![(1, \"one\"), (2, \"two\"), (3, \"three\")];\n        assert_eq!(map.iter().collect::<Vec<_>>(), expected_order);\n\n        map.reverse();\n\n        let expected_reversed_order = vec![(3, \"three\"), (2, \"two\"), (1, \"one\")];\n        assert_eq!(map.iter().collect::<Vec<_>>(), expected_reversed_order);\n    }\n\n    #[test]\n    fn test_reverse_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.reverse();\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_reverse_single_element() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        \n        let expected_order = vec![(1, \"one\")];\n        assert_eq!(map.iter().collect::<Vec<_>>(), expected_order);\n\n        map.reverse();\n\n        assert_eq!(map.iter().collect::<Vec<_>>(), expected_order);\n    }\n\n    #[test]\n    fn test_reverse_large_map() {\n        let mut map = IndexMap::new();\n        for i in 0..100 {\n            map.insert(i, i.to_string());\n        }\n\n        let expected_order: Vec<(usize, String)> = (0..100).map(|i| (i, i.to_string())).collect();\n        assert_eq!(map.iter().collect::<Vec<_>>(), expected_order);\n\n        map.reverse();\n\n        let expected_reversed_order: Vec<(usize, String)> = (0..100).rev().map(|i| (i, i.to_string())).collect();\n        assert_eq!(map.iter().collect::<Vec<_>>(), expected_reversed_order);\n    }\n}\n```", "map::IndexMap::<K, V, S>::shift_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_insert_new_key() {\n        let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n        assert_eq!(map.shift_insert(10, '*', ()), None);\n        assert_eq!(map.get_index_of(&'*'), Some(10));\n        assert_eq!(map.len(), 27);\n    }\n\n    #[test]\n    fn test_shift_insert_move_existing_key() {\n        let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n        assert_eq!(map.shift_insert(10, 'a', ()), Some(()));\n        assert_eq!(map.get_index_of(&'a'), Some(10));\n        assert_eq!(map.get_index_of(&'b'), Some(11));\n    }\n\n    #[test]\n    fn test_shift_insert_move_down_existing_key() {\n        let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n        assert_eq!(map.shift_insert(9, 'z', ()), Some(()));\n        assert_eq!(map.get_index_of(&'z'), Some(9));\n        assert_eq!(map.get_index_of(&'*'), Some(10));\n    }\n\n    #[test]\n    fn test_shift_insert_invalid_move() {\n        let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n        let result = std::panic::catch_unwind(|| {\n            map.shift_insert(map.len(), 'a', ());\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_shift_insert_insert_at_end() {\n        let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n        assert_eq!(map.shift_insert(map.len(), '+', ()), None);\n        assert_eq!(map.get_index_of(&'+'), Some(26));\n        assert_eq!(map.len(), 28);\n    }\n}\n```", "map::IndexMap::<K, V, S>::shift_remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        assert_eq!(map.shift_remove(&\"b\"), Some(2));\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&\"a\"), Some(&1));\n        assert_eq!(map.get(&\"c\"), Some(&3));\n    }\n\n    #[test]\n    fn test_shift_remove_non_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        \n        assert_eq!(map.shift_remove(&\"c\"), None);\n        assert_eq!(map.len(), 2);\n    }\n\n    #[test]\n    fn test_shift_remove_preserves_order() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        map.shift_remove(&\"b\");\n\n        assert_eq!(map.get(&\"a\"), Some(&1));\n        assert_eq!(map.get(&\"c\"), Some(&3));\n        assert_eq!(map.get::<&str>(&\"b\"), None);\n    }\n\n    #[test]\n    fn test_shift_remove_from_empty_map() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        \n        assert_eq!(map.shift_remove(&\"a\"), None);\n    }\n}\n```", "map::IndexMap::<K, V, S>::shift_remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust the import to cover the necessary modules.\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_entry() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        // Test removing an existing key\n        assert_eq!(map.shift_remove_entry(&\"b\"), Some((\"b\", 2)));\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&\"b\").is_none());\n        \n        // Ensure the order is preserved\n        assert_eq!(map.get(&\"a\"), Some(&1));\n        assert_eq!(map.get(&\"c\"), Some(&3));\n\n        // Test removing a non-existing key\n        assert_eq!(map.shift_remove_entry(&\"d\"), None);\n        \n        // Test removing the last remaining entry\n        assert_eq!(map.shift_remove_entry(&\"a\"), Some((\"a\", 1)));\n        assert_eq!(map.len(), 1);\n        \n        // Final map state\n        assert_eq!(map.get(&\"c\"), Some(&3));\n        assert_eq!(map.shift_remove_entry(&\"c\"), Some((\"c\", 3)));\n        assert_eq!(map.len(), 0);\n    }\n}\n```", "map::IndexMap::<K, V, S>::shift_remove_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_full_existing_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let result = map.shift_remove_full(&2);\n        assert_eq!(result, Some((1, 2, \"two\"))); // Index 1, key 2, value \"two\"\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&2).is_none()); // Key 2 should be removed\n    }\n\n    #[test]\n    fn test_shift_remove_full_non_existing_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let result = map.shift_remove_full(&3);\n        assert_eq!(result, None); // Key 3 does not exist\n        assert_eq!(map.len(), 2);\n    }\n\n    #[test]\n    fn test_shift_remove_full_last_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n\n        let result = map.shift_remove_full(&1);\n        assert_eq!(result, Some((0, 1, \"one\"))); // Index 0, key 1, value \"one\"\n        assert!(map.is_empty()); // Map should be empty\n    }\n\n    #[test]\n    fn test_shift_remove_full_empty_map() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        let result = map.shift_remove_full(&1);\n        assert_eq!(result, None); // Removal from an empty map should return None\n    }\n\n    #[test]\n    fn test_shift_remove_full_multiple_elements() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        \n        let result = map.shift_remove_full(&1);\n        assert_eq!(result, Some((0, 1, \"one\"))); // After removal, key 1 was at index 0\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&1).is_none()); // Key 1 should be removed\n        assert_eq!(map.get(&2), Some(&\"two\")); // Key 2 should still be present\n        assert_eq!(map.get(&3), Some(&\"three\")); // Key 3 should still be present\n    }\n}\n```", "map::IndexMap::<K, V, S>::shift_remove_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_index() {\n        let mut map: IndexMap<i32, char> = IndexMap::new();\n        map.insert(1, 'a');\n        map.insert(2, 'b');\n        map.insert(3, 'c');\n\n        // Remove element at index 1\n        let removed = map.shift_remove_index(1);\n        assert_eq!(removed, Some((2, 'b'))); // Check the removed element\n        assert_eq!(map.len(), 2); // Check the length after removal\n        assert_eq!(map.get_index(0), Some((&1, &'a'))); // Ensure remaining elements stay in order\n        assert_eq!(map.get_index(1), Some((&3, &'c'))); // Ensure remaining elements stay in order\n\n        // Remove element at index 0\n        let removed = map.shift_remove_index(0);\n        assert_eq!(removed, Some((1, 'a'))); // Check the removed element\n        assert_eq!(map.len(), 1); // Check the length after removal\n        assert_eq!(map.get_index(0), Some((&3, &'c'))); // Ensure remaining elements stay in order\n\n        // Remove the last element\n        let removed = map.shift_remove_index(0);\n        assert_eq!(removed, Some((3, 'c'))); // Check the removed element\n        assert_eq!(map.len(), 0); // Check the length after removal\n\n        // Trying to remove from empty map\n        let removed = map.shift_remove_index(0);\n        assert_eq!(removed, None); // Check no element is removed\n    }\n\n    #[test]\n    fn test_shift_remove_index_out_of_bounds() {\n        let mut map: IndexMap<i32, char> = IndexMap::new();\n        map.insert(1, 'a');\n        map.insert(2, 'b');\n\n        // Trying to remove at out of bounds index\n        std::panic::catch_unwind(|| {\n            map.shift_remove_index(2);\n        }).unwrap_err(); // Ensure it panics as index is out of bounds\n    }\n}\n```", "map::IndexMap::<K, V, S>::shrink_to": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shrink_to() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        // The current capacity would be higher than 2\n        let initial_capacity = map.capacity();\n        map.shrink_to(2);\n        \n        // Capacity should be at least 2\n        assert!(map.capacity() >= 2);\n        // The length should be unchanged\n        assert_eq!(map.len(), 3);\n        \n        // Shrink to 0 should reduce capacity to 0\n        map.shrink_to(0);\n        assert_eq!(map.capacity(), 0);\n        \n        // After shrinking to 0, we should still have the same length\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        // The capacity should be higher than the current elements\n        let initial_capacity = map.capacity();\n        assert!(initial_capacity > 2);\n        \n        // Shrink to fit should match the capacity to the number of elements\n        map.shrink_to_fit();\n        assert_eq!(map.len(), 2);\n        assert!(map.capacity() >= 2);\n    }\n\n    #[test]\n    fn test_shrink_to_min_capacity() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        // Initially, the capacity should be at least 2\n        let initial_capacity = map.capacity();\n        map.shrink_to(1);\n        \n        // Capacity should be at least 1\n        assert!(map.capacity() >= 1);\n        assert_eq!(map.len(), 2);\n        \n        // Shrink to a capacity of 3 should not reduce the capacity\n        map.shrink_to(3);\n        assert!(map.capacity() >= initial_capacity);\n    }\n}\n```", "map::IndexMap::<K, V, S>::shrink_to_fit": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        // Ensure the capacity is greater than the length\n        let initial_capacity = map.capacity();\n        assert!(initial_capacity > map.len());\n\n        map.shrink_to_fit();\n        \n        // After shrink_to_fit, capacity should be equal to length\n        assert_eq!(map.capacity(), map.len());\n\n        // Now test the insertion after shrink to ensure it works\n        map.insert(4, \"d\");\n        assert_eq!(map.len(), 4);\n        assert_eq!(map[&4], \"d\");\n    }\n\n    #[test]\n    fn test_shrink_to_fit_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n\n        // Shrink to fit on an empty map should not change the capacity\n        let initial_capacity = map.capacity();\n        map.shrink_to_fit();\n        assert_eq!(map.capacity(), initial_capacity);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_after_clear() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        // Clear and then shrink to fit\n        map.clear();\n        map.shrink_to_fit();\n\n        // Ensure capacity is 0\n        assert_eq!(map.capacity(), 0);\n        assert_eq!(map.len(), 0);\n    }\n}\n```", "map::IndexMap::<K, V, S>::sort_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_sort_by_keys() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(3, 0);\n        map.insert(1, 1);\n        map.insert(2, 2);\n\n        map.sort_by(|k1, v1, k2, v2| k1.cmp(k2));\n        \n        let keys: Vec<_> = map.keys().collect();\n        let values: Vec<_> = map.values().collect();\n\n        assert_eq!(keys, vec![1, 2, 3]);\n        assert_eq!(values, vec![1, 2, 0]);\n    }\n\n    #[test]\n    fn test_sort_by_values() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 3);\n        map.insert(2, 2);\n        map.insert(3, 1);\n\n        map.sort_by(|k1, v1, k2, v2| v1.cmp(v2));\n\n        let keys: Vec<_> = map.keys().collect();\n        let values: Vec<_> = map.values().collect();\n\n        assert_eq!(keys, vec![3, 2, 1]);\n        assert_eq!(values, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_sort_by_keys_and_values() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 1);\n        map.insert(2, 3);\n        map.insert(3, 2);\n\n        map.sort_by(|k1, v1, k2, v2| v1.cmp(v2).then(k1.cmp(k2)));\n\n        let keys: Vec<_> = map.keys().collect();\n        let values: Vec<_> = map.values().collect();\n\n        assert_eq!(keys, vec![1, 3, 2]);\n        assert_eq!(values, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_sort_empty() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.sort_by(|_, _, _, _| std::cmp::Ordering::Greater);\n        \n        assert!(map.is_empty());\n    }\n}\n```", "map::IndexMap::<K, V, S>::sort_by_cached_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_sort_by_cached_key() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"three\", 3);\n        map.insert(\"one\", 1);\n        map.insert(\"two\", 2);\n\n        // Sort the map by length of keys\n        map.sort_by_cached_key(|key, _| key.len());\n\n        let entries: Vec<_> = map.into_iter().collect();\n        assert_eq!(entries, vec![(\"one\", 1), (\"two\", 2), (\"three\", 3)]);\n    }\n\n    #[test]\n    fn test_sort_by_cached_key_stability() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"beta\", 2);\n        map.insert(\"alpha\", 1);\n        map.insert(\"beta2\", 3);\n\n        // Sort the map by keys\n        map.sort_by_cached_key(|key, _| key);\n\n        let entries: Vec<_> = map.into_iter().collect();\n        assert_eq!(entries, vec![(\"alpha\", 1), (\"beta\", 2), (\"beta2\", 3)]);\n    }\n\n    #[test]\n    fn test_sort_by_cached_key_empty() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        \n        // Sort the empty map\n        map.sort_by_cached_key(|key, _| key.len());\n\n        let entries: Vec<_> = map.into_iter().collect();\n        assert!(entries.is_empty());\n    }\n}\n```", "map::IndexMap::<K, V, S>::sort_keys": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_sort_keys() {\n        let mut map = IndexMap::new();\n        map.insert(3, \"c\");\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        \n        map.sort_keys();\n        \n        let expected: IndexMap<_, _> = vec![(1, \"a\"), (2, \"b\"), (3, \"c\")].into_iter().collect();\n        assert_eq!(map, expected);\n    }\n\n    #[test]\n    fn test_sort_keys_with_equal() {\n        let mut map = IndexMap::new();\n        map.insert(2, \"b\");\n        map.insert(1, \"a\");\n        map.insert(2, \"c\"); // Same key, different value\n        \n        map.sort_keys();\n        \n        let expected: IndexMap<_, _> = vec![(1, \"a\"), (2, \"c\")].into_iter().collect();\n        assert_eq!(map, expected);\n    }\n\n    #[test]\n    fn test_sort_keys_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        \n        map.sort_keys();\n        \n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_sort_keys_single_entry() {\n        let mut map = IndexMap::new();\n        map.insert(2, \"b\");\n        \n        map.sort_keys();\n        \n        let expected: IndexMap<_, _> = vec![(2, \"b\")].into_iter().collect();\n        assert_eq!(map, expected);\n    }\n}\n```", "map::IndexMap::<K, V, S>::sort_unstable_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_sort_unstable_by() {\n        let mut map = IndexMap::new();\n        map.insert(3, 'c');\n        map.insert(1, 'a');\n        map.insert(2, 'b');\n        \n        // Sorting by key\n        map.sort_unstable_by(|k1, v1, k2, v2| k1.cmp(k2));\n        \n        let sorted_keys: Vec<_> = map.keys().collect();\n        let sorted_values: Vec<_> = map.values().collect();\n        \n        assert_eq!(sorted_keys, vec![1, 2, 3]);\n        assert_eq!(sorted_values, vec!['a', 'b', 'c']);\n        \n        // Sorting by value\n        map.sort_unstable_by(|k1, v1, k2, v2| v1.cmp(v2));\n        \n        let sorted_keys_by_value: Vec<_> = map.keys().collect();\n        let sorted_values_by_value: Vec<_> = map.values().collect();\n        \n        assert_eq!(sorted_values_by_value, vec!['a', 'b', 'c']);\n        assert_eq!(sorted_keys_by_value, vec![1, 2, 3]);\n    }\n    \n    #[test]\n    fn test_sort_unstable_by_with_equal_keys() {\n        let mut map = IndexMap::new();\n        map.insert(1, 'a');\n        map.insert(1, 'b');\n        map.insert(2, 'c');\n        \n        // Sorting by keys, should not preserve order of equal keys\n        map.sort_unstable_by(|k1, v1, k2, v2| k1.cmp(k2));\n        \n        let sorted_keys: Vec<_> = map.keys().collect();\n        let sorted_values: Vec<_> = map.values().collect();\n        \n        assert_eq!(sorted_keys, vec![1, 1, 2]);\n        assert!(sorted_values.iter().any(|&v| v == 'a' || v == 'b'));\n    }\n}\n```", "map::IndexMap::<K, V, S>::sort_unstable_keys": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_sort_unstable_keys() {\n        let mut map = IndexMap::new();\n        map.insert(2, \"b\");\n        map.insert(1, \"a\");\n        map.insert(3, \"c\");\n\n        // Before sorting\n        let keys_before: Vec<_> = map.keys().cloned().collect();\n        assert_eq!(keys_before, vec![2, 1, 3]);\n\n        // Sort the keys\n        map.sort_unstable_keys();\n\n        // After sorting\n        let keys_after: Vec<_> = map.keys().cloned().collect();\n        assert_eq!(keys_after, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_sort_unstable_keys_with_duplicates() {\n        let mut map = IndexMap::new();\n        map.insert(2, \"b\");\n        map.insert(1, \"a\");\n        map.insert(2, \"c\"); // Duplicate key\n\n        // Before sorting\n        let keys_before: Vec<_> = map.keys().cloned().collect();\n        assert_eq!(keys_before, vec![2, 1, 2]);\n\n        // Sort the keys\n        map.sort_unstable_keys();\n\n        // After sorting, duplicates may change order\n        let keys_after: Vec<_> = map.keys().cloned().collect();\n        assert_eq!(keys_after, vec![1, 2, 2]);\n    }\n\n    #[test]\n    fn test_sort_unstable_keys_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.sort_unstable_keys(); // Should work without panic\n        assert!(map.is_empty());\n    }\n}\n```", "map::IndexMap::<K, V, S>::sorted_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_sorted_by() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 3);\n        map.insert(\"b\", 1);\n        map.insert(\"c\", 2);\n        \n        let sorted: Vec<_> = map.sorted_by(|_, &v1, _, &v2| {\n            v1.cmp(&v2)\n        }).collect();\n\n        assert_eq!(sorted, vec![(\"b\", 1), (\"c\", 2), (\"a\", 3)]);\n    }\n\n    #[test]\n    fn test_sorted_by_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 2);\n        map.insert(\"b\", 1);\n        map.insert(\"c\", 3);\n        \n        let sorted: Vec<_> = map.sorted_by(|&k1, _, &k2, _| {\n            k1.cmp(&k2)\n        }).collect();\n\n        assert_eq!(sorted, vec![(\"a\", 2), (\"b\", 1), (\"c\", 3)]);\n    }\n\n    #[test]\n    fn test_sorted_by_key_value() {\n        let mut map = IndexMap::new();\n        map.insert(\"banana\", 3);\n        map.insert(\"apple\", 1);\n        map.insert(\"cherry\", 2);\n        \n        let sorted: Vec<_> = map.sorted_by(|k1, v1, k2, v2| {\n            k1.cmp(k2).then_with(|| v1.cmp(v2))\n        }).collect();\n\n        assert_eq!(sorted, vec![(\"apple\", 1), (\"banana\", 3), (\"cherry\", 2)]);\n    }\n}\n```", "map::IndexMap::<K, V, S>::sorted_unstable_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_sorted_unstable_by() {\n        let mut map = IndexMap::new();\n        map.insert(3, 'c');\n        map.insert(1, 'a');\n        map.insert(2, 'b');\n        map.insert(4, 'd');\n\n        let sorted: Vec<(usize, char)> = map\n            .sorted_unstable_by(|k1, v1, k2, v2| {\n                if v1 < v2 {\n                    Ordering::Less\n                } else if v1 > v2 {\n                    Ordering::Greater\n                } else {\n                    k1.cmp(k2)\n                }\n            })\n            .collect();\n\n        let expected: Vec<(usize, char)> = vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')];\n        assert_eq!(sorted, expected);\n    }\n\n    #[test]\n    fn test_sorted_unstable_by_with_equal_values() {\n        let mut map = IndexMap::new();\n        map.insert(3, 'a');\n        map.insert(1, 'b');\n        map.insert(2, 'a');\n        map.insert(4, 'b');\n\n        let sorted: Vec<(usize, char)> = map\n            .sorted_unstable_by(|k1, v1, k2, v2| {\n                if v1 < v2 {\n                    Ordering::Less\n                } else if v1 > v2 {\n                    Ordering::Greater\n                } else {\n                    k1.cmp(k2)\n                }\n            })\n            .collect();\n\n        let expected: Vec<(usize, char)> = vec![(3, 'a'), (2, 'a'), (1, 'b'), (4, 'b')];\n        assert_eq!(sorted, expected);\n    }\n\n    #[test]\n    fn test_sorted_unstable_by_empty() {\n        let map: IndexMap<i32, char> = IndexMap::new();\n        let sorted: Vec<(i32, char)> = map.sorted_unstable_by(|_, _, _, _| Ordering::Equal).collect();\n        assert!(sorted.is_empty());\n    }\n}\n```", "map::IndexMap::<K, V, S>::splice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_splice_replace_with_new_elements() {\n        let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);\n        let new = [(5, 'E'), (6, 'F')];\n        let removed: Vec<_> = map.splice(2..4, new).collect();\n\n        assert_eq!(removed, vec![(2, 'b'), (3, 'c')]);\n        let expected_map: Vec<(usize, char)> = vec![(0, '_'), (1, 'a'), (5, 'E'), (6, 'F'), (4, 'd')];\n        assert!(map.into_iter().eq(expected_map));\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_splice_out_of_bounds() {\n        let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);\n        let _removed: Vec<_> = map.splice(2..5, vec![(3, 'c')]).collect();\n    }\n\n    #[test]\n    fn test_splice_with_overlapping_keys() {\n        let mut map = IndexMap::from([(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D')]);\n        let new = [(1, 'X'), (3, 'Y'), (4, 'Z')];\n        let removed: Vec<_> = map.splice(1..3, new).collect();\n\n        assert_eq!(removed, vec![(1, 'B'), (2, 'C')]);\n        let expected_map: Vec<(usize, char)> = vec![(0, 'A'), (1, 'X'), (3, 'Y'), (4, 'Z')];\n        assert!(map.into_iter().eq(expected_map));\n    }\n\n    #[test]\n    fn test_splice_with_no_replacement() {\n        let mut map = IndexMap::from([(0, 'A'), (1, 'B')]);\n        let new = [(2, 'C'), (3, 'D')];\n        let removed: Vec<_> = map.splice(1..1, new).collect();\n\n        assert!(removed.is_empty());\n        let expected_map: Vec<(usize, char)> = vec![(0, 'A'), (2, 'C'), (3, 'D'), (1, 'B')];\n        assert!(map.into_iter().eq(expected_map));\n    }\n}\n```", "map::IndexMap::<K, V, S>::split_off": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_split_off() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        map.insert(\"key3\", \"value3\");\n\n        let split_index = 1; // we want to split at index 1\n        let right_map = map.split_off(split_index);\n\n        // Original map should contain entries [(\"key1\", \"value1\")]\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(\"key1\"), Some(&\"value1\"));\n        assert_eq!(map.get(\"key2\"), None);\n        \n        // Right map should contain entries [(\"key2\", \"value2\"), (\"key3\", \"value3\")]\n        assert_eq!(right_map.len(), 2);\n        assert_eq!(right_map.get(\"key2\"), Some(&\"value2\"));\n        assert_eq!(right_map.get(\"key3\"), Some(&\"value3\"));\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_split_off_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.split_off(2); // This should panic as there is no index 2\n    }\n\n    #[test]\n    fn test_split_off_with_empty_map() {\n        let mut map: IndexMap<&str, &str> = IndexMap::new();\n        let right_map = map.split_off(0);\n        \n        assert!(map.is_empty()); // original map should be empty\n        assert!(right_map.is_empty()); // right map should also be empty\n    }\n\n    #[test]\n    fn test_split_off_with_single_entry() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n\n        let right_map = map.split_off(0); // split at index 0\n\n        assert!(map.is_empty()); // original map should be empty\n        assert_eq!(right_map.len(), 1); // right map should have the single entry\n        assert_eq!(right_map.get(\"key1\"), Some(&\"value1\"));\n    }\n}\n```", "map::IndexMap::<K, V, S>::swap_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_indices() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        assert_eq!(map.get_index(0), Some((&\"a\", &1)));\n        assert_eq!(map.get_index(1), Some((&\"b\", &2)));\n        assert_eq!(map.get_index(2), Some((&\"c\", &3)));\n\n        map.swap_indices(0, 2);\n\n        assert_eq!(map.get_index(0), Some((&\"c\", &3)));\n        assert_eq!(map.get_index(1), Some((&\"b\", &2)));\n        assert_eq!(map.get_index(2), Some((&\"a\", &1)));\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\n    fn test_swap_indices_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(\"x\", 1);\n        map.insert(\"y\", 2);\n        map.insert(\"z\", 3);\n\n        map.swap_indices(1, 3); // Should panic\n    }\n\n    #[test]\n    fn test_swap_indices_same_index() {\n        let mut map = IndexMap::new();\n        map.insert(\"x\", 1);\n        map.insert(\"y\", 2);\n        map.insert(\"z\", 3);\n\n        map.swap_indices(1, 1); // No panic expected\n        assert_eq!(map.get_index(1), Some((&\"y\", &2)));\n    }\n}\n```", "map::IndexMap::<K, V, S>::swap_remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_remove_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        // Test that swapping removes the key \"b\" and returns its value\n        assert_eq!(map.swap_remove(\"b\"), Some(2));\n        assert_eq!(map.len(), 2);\n        assert!(map.get(\"b\").is_none());\n    }\n\n    #[test]\n    fn test_swap_remove_nonexistent_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n\n        // Test that swapping a non-existent key returns None\n        assert_eq!(map.swap_remove(\"c\"), None);\n        assert_eq!(map.len(), 2);\n    }\n\n    #[test]\n    fn test_swap_remove_last_element() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n\n        // Test removing the last element\n        assert_eq!(map.swap_remove(\"a\"), Some(1));\n        assert_eq!(map.len(), 0);\n        assert!(map.get(\"a\").is_none());\n    }\n\n    #[test]\n    fn test_swap_remove_preserves_other_elements() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        // Remove \"b\" and check that \"a\" and \"c\" remain\n        map.swap_remove(\"b\");\n        assert_eq!(map.get(\"a\"), Some(&1));\n        assert_eq!(map.get(\"c\"), Some(&3));\n    }\n\n    #[test]\n    fn test_swap_remove_maintains_size_after_removal() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        map.swap_remove(\"b\");\n        assert_eq!(map.len(), 2);\n    }\n}\n```", "map::IndexMap::<K, V, S>::swap_remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_remove_entry_existing_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let removed_entry = map.swap_remove_entry(&2);\n        assert_eq!(removed_entry, Some((2, \"b\")));\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&2).is_none());\n    }\n\n    #[test]\n    fn test_swap_remove_entry_non_existing_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let removed_entry = map.swap_remove_entry(&3);\n        assert_eq!(removed_entry, None);\n        assert_eq!(map.len(), 2);\n    }\n\n    #[test]\n    fn test_swap_remove_entry_multiple_keys() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        map.insert(4, \"d\");\n\n        let removed_entry = map.swap_remove_entry(&3);\n        assert_eq!(removed_entry, Some((3, \"c\")));\n        assert_eq!(map.len(), 3);\n        assert!(map.get(&3).is_none());\n    }\n\n    #[test]\n    fn test_swap_remove_entry_first_last_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let removed_first = map.swap_remove_entry(&1);\n        assert_eq!(removed_first, Some((1, \"a\")));\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&1).is_none());\n\n        let removed_last = map.swap_remove_entry(&3);\n        assert_eq!(removed_last, Some((3, \"c\")));\n        assert_eq!(map.len(), 1);\n        assert!(map.get(&3).is_none());\n    }\n\n    #[test]\n    fn test_swap_remove_entry_empty_map() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n\n        let removed_entry = map.swap_remove_entry(&1);\n        assert_eq!(removed_entry, None);\n        assert_eq!(map.len(), 0);\n    }\n}\n```", "map::IndexMap::<K, V, S>::swap_remove_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_remove_full_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let result = map.swap_remove_full(\"key1\");\n        assert_eq!(result, Some((0, \"key1\", \"value1\"))); // Should return index 0, \"key1\", \"value1\"\n        assert_eq!(map.len(), 1); // Size should reduce\n        assert_eq!(map.get(\"key1\"), None); // \"key1\" should not exist\n        assert_eq!(map.get(\"key2\"), Some(&\"value2\")); // \"key2\" should still exist\n    }\n\n    #[test]\n    fn test_swap_remove_full_non_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n\n        let result = map.swap_remove_full(\"key2\"); // \"key2\" does not exist\n        assert_eq!(result, None); // Should return None\n        assert_eq!(map.len(), 1); // Size should remain the same\n    }\n\n    #[test]\n    fn test_swap_remove_full_last_element() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n\n        let result = map.swap_remove_full(\"key1\");\n        assert_eq!(result, Some((0, \"key1\", \"value1\"))); // Should return index 0, \"key1\", \"value1\"\n        assert_eq!(map.len(), 0); // Should be empty now\n    }\n\n    #[test]\n    fn test_swap_remove_full_multiple_elements() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        map.insert(\"key3\", \"value3\");\n\n        let result = map.swap_remove_full(\"key2\");\n        assert_eq!(result, Some((1, \"key2\", \"value2\"))); // Should return index 1, \"key2\", \"value2\"\n        assert_eq!(map.len(), 2); // Size should reduce\n        assert_eq!(map.get(\"key1\"), Some(&\"value1\")); // \"key1\" should still exist\n        assert_eq!(map.get(\"key2\"), None); // \"key2\" should not exist\n        assert_eq!(map.get(\"key3\"), Some(&\"value3\")); // \"key3\" should still exist\n    }\n}\n```", "map::IndexMap::<K, V, S>::swap_remove_index": "```rust\nuse indexmap::IndexMap;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_swap_remove_index() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        assert_eq!(map.swap_remove_index(1), Some((2, \"b\")));\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get_index(1), Some((&3, &\"c\")));\n\n        assert_eq!(map.swap_remove_index(0), Some((1, \"a\")));\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get_index(0), Some((&3, &\"c\")));\n\n        assert_eq!(map.swap_remove_index(0), Some((3, \"c\")));\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.swap_remove_index(0), None);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_swap_remove_index_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.swap_remove_index(1); // This should panic\n    }\n\n    #[test]\n    fn test_swap_remove_index_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        assert_eq!(map.swap_remove_index(0), None);\n    }\n}\n```", "map::IndexMap::<K, V, S>::truncate": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_truncate() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        // Truncate to 2 elements\n        map.truncate(2);\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&3).is_none());\n\n        // Truncate to more than current length\n        map.truncate(5);\n        assert_eq!(map.len(), 2);\n        \n        // Truncate to exact length\n        map.truncate(2);\n        assert_eq!(map.len(), 2);\n        \n        // Truncate to 0\n        map.truncate(0);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_truncate_no_effect_when_len_greater() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        // Truncate with length greater than current\n        map.truncate(3);\n        assert_eq!(map.len(), 2);\n    }\n}\n```", "map::IndexMap::<K, V, S>::try_reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_try_reserve() {\n        let mut map = IndexMap::new();\n        \n        // Initially, it should be empty and have a capacity of 0\n        assert!(map.capacity() == 0);\n        \n        // Try to reserve capacity for 5 more key-value pairs\n        let result = map.try_reserve(5);\n        assert!(result.is_ok());\n        assert!(map.capacity() >= 5); // Capacity should be at least 5 now\n\n        // Reserve 0 should be a no-op\n        let result_zero = map.try_reserve(0);\n        assert!(result_zero.is_ok());\n        assert!(map.capacity() >= 5); // Capacity should remain the same\n\n        // Try reserving a very large capacity\n        let result_large = map.try_reserve(1_000_000);\n        assert!(result_large.is_ok());\n    }\n\n    #[test]\n    fn test_try_reserve_failure() {\n        let mut map = IndexMap::new();\n        let result = map.try_reserve(usize::MAX);\n        // Since the capacity exceeded the maximum, this should end up returning an error.\n        assert!(result.is_err());\n    }\n}\n```", "map::IndexMap::<K, V, S>::try_reserve_exact": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_try_reserve_exact_success() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        let result = map.try_reserve_exact(2);\n        assert!(result.is_ok());\n        assert!(map.capacity() >= 4); // Ensure capacity is enough for 2 more\n    }\n\n    #[test]\n    fn test_try_reserve_exact_fail() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        // Assuming enough capacity for 3 elements\n        let result = map.try_reserve_exact(3);\n        assert!(result.is_ok());\n        assert!(map.capacity() >= 3);\n    }\n\n    #[test]\n    fn test_try_reserve_exact_no_overallocate() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.try_reserve_exact(2).unwrap(); // Reserve with no elements\n        assert_eq!(map.capacity(), 2);\n        \n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.try_reserve_exact(0).unwrap(); // Reserve with zero\n        assert_eq!(map.capacity(), 2); // Ensure capacity is unchanged\n    }\n\n    #[test]\n    fn test_try_reserve_exact_with_existing_elements() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let result = map.try_reserve_exact(2);\n        assert!(result.is_ok());\n        assert!(map.capacity() >= 5); // Ensure capacity can accommodate\n    }\n}\n```", "map::IndexMap::<K, V, S>::values": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_values() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let values: Vec<_> = map.values().cloned().collect();\n        assert_eq!(values, vec![\"one\", \"two\", \"three\"]);\n    }\n\n    #[test]\n    fn test_values_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let values: Vec<_> = map.values().cloned().collect();\n        assert!(values.is_empty());\n    }\n\n    #[test]\n    fn test_values_after_removal() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        map.remove(&2);\n\n        let values: Vec<_> = map.values().cloned().collect();\n        assert_eq!(values, vec![\"one\", \"three\"]);\n    }\n}\n```", "map::IndexMap::<K, V, S>::values_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_values_mut() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n        map.insert(2, \"two\".to_string());\n        map.insert(3, \"three\".to_string());\n\n        let mut values_iter = map.values_mut();\n        assert_eq!(values_iter.next(), Some(&mut \"one\".to_string()));\n        assert_eq!(values_iter.next(), Some(&mut \"two\".to_string()));\n        \n        // Modifying values through mutable references\n        if let Some(value) = values_iter.next() {\n            *value = \"changed\".to_string();\n        }\n        \n        assert_eq!(map.get(&2), Some(&\"two\".to_string()));\n        assert_eq!(map.get(&3), Some(&\"changed\".to_string()));\n    }\n\n    #[test]\n    fn test_values_mut_empty() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        let mut values_iter = map.values_mut();\n        assert_eq!(values_iter.next(), None);\n    }\n}\n```", "map::IndexMap::<K, V, S>::with_capacity_and_hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_with_capacity_and_hasher_zero_capacity() {\n        let map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(0, RandomState::new());\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_non_zero_capacity() {\n        let capacity = 10;\n        let hash_builder = RandomState::new();\n        let map: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(capacity, hash_builder);\n\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_multiple_creation() {\n        let capacity = 5;\n        let hash_builder = RandomState::new();\n        let map1: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(capacity, hash_builder.clone());\n        let map2: IndexMap<i32, i32, RandomState> = IndexMap::with_capacity_and_hasher(capacity, hash_builder);\n\n        assert!(map1.is_empty());\n        assert!(map2.is_empty());\n        assert_eq!(map1.capacity(), capacity);\n        assert_eq!(map2.capacity(), capacity);\n    }\n}\n```", "map::IndexMap::<K, V, S>::with_hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_with_hasher() {\n        let hasher: RandomState = RandomState::new();\n        let map: IndexMap<i32, &str, RandomState> = IndexMap::with_hasher(hasher);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_with_hasher_non_empty() {\n        let hasher: RandomState = RandomState::new();\n        let mut map: IndexMap<i32, &str, RandomState> = IndexMap::with_hasher(hasher);\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&\"one\"));\n        assert_eq!(map.get(&2), Some(&\"two\"));\n    }\n}\n```", "map::IndexMap::<K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_indexmap_new() {\n        let map: IndexMap<i32, i32> = IndexMap::new();\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n}\n```", "map::IndexMap::<K, V>::with_capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_with_capacity() {\n        // Test with zero capacity\n        let map_zero: IndexMap<i32, i32> = IndexMap::with_capacity(0);\n        assert_eq!(map_zero.len(), 0);\n        assert_eq!(map_zero.capacity(), 0);\n\n        // Test with a positive capacity\n        let capacity = 10;\n        let map_ten: IndexMap<i32, i32> = IndexMap::with_capacity(capacity);\n        assert_eq!(map_ten.len(), 0);\n        assert!(map_ten.capacity() >= capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_multiple() {\n        // Create a map with different capacities\n        let map_one: IndexMap<i32, i32> = IndexMap::with_capacity(1);\n        assert_eq!(map_one.capacity(), 1);\n\n        let map_five: IndexMap<i32, i32> = IndexMap::with_capacity(5);\n        assert_eq!(map_five.capacity(), 5);\n\n        let map_fifty: IndexMap<i32, i32> = IndexMap::with_capacity(50);\n        assert_eq!(map_fifty.capacity(), 50);\n    }\n\n    #[test]\n    fn test_with_capacity_growth() {\n        let mut map = IndexMap::with_capacity(1);\n        map.insert(1, 10);\n        \n        // This will trigger a reallocation\n        map.insert(2, 20);\n        assert!(map.capacity() > 1);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map[&1], 10);\n        assert_eq!(map[&2], 20);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::append_unchecked": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_append_unchecked() {\n        let mut map1: IndexMapCore<i32, i32> = IndexMapCore::new();\n        let mut map2: IndexMapCore<i32, i32> = IndexMapCore::new();\n\n        // Inserting some values in map1\n        map1.insert_full(1.hash(), 1, 100);\n        map1.insert_full(2.hash(), 2, 200);\n\n        // Inserting some values in map2\n        map2.insert_full(3.hash(), 3, 300);\n        map2.insert_full(4.hash(), 4, 400);\n\n        // Append map2 to map1\n        map1.append_unchecked(&mut map2);\n\n        // Check the length of map1 now\n        assert_eq!(map1.len(), 4);\n        // Check values\n        assert_eq!(map1.entries.len(), 4);\n        assert_eq!(map1.entries[2].key, 3);\n        assert_eq!(map1.entries[3].key, 4);\n        // Check that map2 is now empty\n        assert_eq!(map2.len(), 0);\n    }\n\n    #[test]\n    fn test_append_unchecked_capacity() {\n        let mut map1: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(2);\n        let mut map2: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(2);\n\n        // Inserting values in map1\n        map1.insert_full(1.hash(), 1, 100);\n        map1.insert_full(2.hash(), 2, 200);\n\n        // Inserting values in map2\n        map2.insert_full(3.hash(), 3, 300);\n        map2.insert_full(4.hash(), 4, 400);\n\n        // Append map2 to map1\n        map1.append_unchecked(&mut map2);\n\n        // Ensure that map1's capacity is sufficient\n        assert!(map1.capacity() >= 4);\n        // Ensure that map2 is cleared\n        assert_eq!(map2.len(), 0);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::borrow_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming tests exist in the same module. Adjust import as needed.\n\n    #[test]\n    fn test_borrow_mut() {\n        // Create a new IndexMapCore\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n\n        // Populate the map with some initial values\n        map.push_entry(HashValue::new(0), 1, \"one\".to_string());\n        map.push_entry(HashValue::new(1), 2, \"two\".to_string());\n\n        // Call the borrow_mut method\n        let mut ref_mut = map.borrow_mut();\n\n        // Verify the state of the indices and entries\n        assert_eq!(ref_mut.indices.len(), 2);\n        assert_eq!(ref_mut.entries.len(), 2);\n\n        // Test reserve_entries method through borrow_mut\n        ref_mut.reserve_entries(1);\n        assert!(ref_mut.entries.capacity() > 2); // Ensure the capacity has increased\n\n        // Test inserting a unique entry\n        ref_mut.insert_unique(HashValue::new(2), 3, \"three\".to_string());\n        assert_eq!(ref_mut.entries.len(), 3);\n        assert_eq!(ref_mut.entries[2].key, 3);\n        assert_eq!(ref_mut.entries[2].value, \"three\".to_string());\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_capacity_empty() {\n        let map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_with_capacity() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);\n        assert_eq!(map.capacity(), 10);\n    }\n\n    #[test]\n    fn test_capacity_increase() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: 0, key: 1, value: 2 });\n        assert!(map.capacity() >= 1);\n    }\n\n    #[test]\n    fn test_capacity_with_indices() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(5);\n        map.indices.reserve(5);\n        assert_eq!(map.capacity(), 5);\n    }\n\n    #[test]\n    fn test_capacity_equal() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(10);\n        map.entries.push(Bucket { hash: 0, key: 1, value: 2 });\n        map.indices.reserve(10);\n        assert_eq!(map.capacity(), 10);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::clear": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_clear() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.insert_full(HashValue::new(1), 1, 10);\n        map.insert_full(HashValue::new(2), 2, 20);\n        assert_eq!(map.len(), 2);\n        map.clear();\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::drain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_drain_valid_range() {\n        let mut map: IndexMapCore<i32, &str> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: 0, key: 0, value: \"a\" });\n        map.entries.push(Bucket { hash: 1, key: 1, value: \"b\" });\n        map.entries.push(Bucket { hash: 2, key: 2, value: \"c\" });\n\n        let drained: Vec<_> = map.drain(1..3).collect();\n        assert_eq!(drained.len(), 2);\n        assert_eq!(drained[0].key, 1);\n        assert_eq!(drained[1].key, 2);\n        assert_eq!(map.entries.len(), 1);\n        assert_eq!(map.entries[0].key, 0);\n    }\n\n    #[test]\n    fn test_drain_empty_range() {\n        let mut map: IndexMapCore<i32, &str> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: 0, key: 0, value: \"a\" });\n        \n        let drained: Vec<_> = map.drain(0..0).collect();\n        assert_eq!(drained.len(), 0);\n        assert_eq!(map.entries.len(), 1);\n    }\n\n    #[test]\n    fn test_drain_full_range() {\n        let mut map: IndexMapCore<i32, &str> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: 0, key: 0, value: \"a\" });\n        map.entries.push(Bucket { hash: 1, key: 1, value: \"b\" });\n\n        let drained: Vec<_> = map.drain(0..2).collect();\n        assert_eq!(drained.len(), 2);\n        assert_eq!(map.entries.len(), 0);\n    }\n\n    #[test]\n    fn test_drain_out_of_bounds() {\n        let mut map: IndexMapCore<i32, &str> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: 0, key: 0, value: \"a\" });\n\n        let drained: Vec<_> = map.drain(0..3).collect(); // Out of bounds\n        assert_eq!(drained.len(), 1);\n        assert_eq!(map.entries.len(), 0);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::erase_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_erase_indices() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: HashValue::new(1), key: 1, value: 10 });\n        map.entries.push(Bucket { hash: HashValue::new(2), key: 2, value: 20 });\n        map.entries.push(Bucket { hash: HashValue::new(3), key: 3, value: 30 });\n        map.indices.push(0);\n        map.indices.push(1);\n        map.indices.push(2);\n\n        // Erase from index 1 to 2\n        map.erase_indices(1, 2);\n\n        // Assert remaining entries\n        assert_eq!(map.entries.len(), 3);\n        assert_eq!(map.indices.len(), 2);\n        assert_eq!(map.entries[0].key, 1);\n        assert_eq!(map.entries[0].value, 10);\n        assert_eq!(map.entries[1].key, 3);\n        assert_eq!(map.entries[1].value, 30);\n        assert_eq!(map.indices[0], 0);\n        assert_eq!(map.indices[1], 1);\n    }\n\n    #[test]\n    fn test_erase_indices_no_op() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: HashValue::new(1), key: 1, value: 10 });\n        map.indices.push(0);\n\n        // Erase with no elements (start == end)\n        map.erase_indices(0, 0);\n\n        // Assert entries remain unchanged\n        assert_eq!(map.entries.len(), 1);\n        assert_eq!(map.indices.len(), 1);\n    }\n\n    #[test]\n    fn test_erase_indices_full() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: HashValue::new(1), key: 1, value: 10 });\n        map.entries.push(Bucket { hash: HashValue::new(2), key: 2, value: 20 });\n        map.entries.push(Bucket { hash: HashValue::new(3), key: 3, value: 30 });\n        map.indices.extend(0..3);\n\n        // Erase all entries\n        map.erase_indices(0, 3);\n\n        // Assert no entries remain\n        assert_eq!(map.entries.len(), 3);\n        assert_eq!(map.indices.len(), 0);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::get_index_of": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    #[derive(Debug, Clone, PartialEq, Eq)]\n    struct TestKey(String);\n\n    impl Hash for TestKey {\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            self.0.hash(state);\n        }\n    }\n\n    #[derive(Debug, Clone, PartialEq)]\n    struct TestValue(i32);\n\n    #[test]\n    fn test_get_index_of_existing_key() {\n        let mut index_map: IndexMapCore<TestKey, TestValue> = IndexMapCore::new();\n        let key = TestKey(\"test\".to_string());\n        let value = TestValue(42);\n        let hash = HashValue(123);\n\n        index_map.entries.push(Bucket { hash, key: key.clone(), value });\n        let result = index_map.get_index_of(hash, &key);\n\n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_get_index_of_non_existing_key() {\n        let index_map: IndexMapCore<TestKey, TestValue> = IndexMapCore::new();\n        let key = TestKey(\"non_existing\".to_string());\n        let hash = HashValue(123);\n\n        let result = index_map.get_index_of(hash, &key);\n\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_index_of_with_different_key() {\n        let mut index_map: IndexMapCore<TestKey, TestValue> = IndexMapCore::new();\n        let key1 = TestKey(\"key1\".to_string());\n        let value1 = TestValue(1);\n        let key2 = TestKey(\"key2\".to_string());\n        let value2 = TestValue(2);\n        let hash1 = HashValue(123);\n        let hash2 = HashValue(234);\n\n        index_map.entries.push(Bucket { hash: hash1, key: key1.clone(), value: value1 });\n        index_map.entries.push(Bucket { hash: hash2, key: key2.clone(), value: value2 });\n\n        let result = index_map.get_index_of(hash1, &key2);\n\n        assert_eq!(result, None);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::insert_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{HashValue, IndexMapCore};\n\n    #[test]\n    fn test_insert_new_entry() {\n        let mut index_map: IndexMapCore<String, i32> = IndexMapCore::new();\n        let hash = HashValue(1);\n        \n        let (index, existing_value) = index_map.insert_full(hash, \"key1\".to_string(), 42);\n        \n        assert_eq!(index, 0);\n        assert!(existing_value.is_none());\n        assert_eq!(index_map.entries.len(), 1);\n        assert_eq!(index_map.entries[0].key, \"key1\");\n        assert_eq!(index_map.entries[0].value, 42);\n    }\n\n    #[test]\n    fn test_insert_existing_entry() {\n        let mut index_map: IndexMapCore<String, i32> = IndexMapCore::new();\n        let hash = HashValue(1);\n        \n        index_map.insert_full(hash, \"key1\".to_string(), 42);\n        let (index, existing_value) = index_map.insert_full(hash, \"key1\".to_string(), 100);\n        \n        assert_eq!(index, 0);\n        assert_eq!(existing_value, Some(42));\n        assert_eq!(index_map.entries.len(), 1);\n        assert_eq!(index_map.entries[0].value, 100);\n    }\n\n    #[test]\n    fn test_insert_multiple_entries() {\n        let mut index_map: IndexMapCore<String, i32> = IndexMapCore::new();\n        \n        let (index1, existing_value1) = index_map.insert_full(HashValue(1), \"key1\".to_string(), 42);\n        let (index2, existing_value2) = index_map.insert_full(HashValue(2), \"key2\".to_string(), 100);\n        \n        assert_eq!(index1, 0);\n        assert!(existing_value1.is_none());\n        assert_eq!(index2, 1);\n        assert!(existing_value2.is_none());\n        assert_eq!(index_map.entries.len(), 2);\n        assert_eq!(index_map.entries[0].key, \"key1\");\n        assert_eq!(index_map.entries[0].value, 42);\n        assert_eq!(index_map.entries[1].key, \"key2\");\n        assert_eq!(index_map.entries[1].value, 100);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_len_empty() {\n        let map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_len_with_entries() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.insert_full(0, 1, 10);\n        map.insert_full(1, 2, 20);\n        assert_eq!(map.len(), 2);\n    }\n\n    #[test]\n    fn test_len_after_clear() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.insert_full(0, 1, 10);\n        map.insert_full(1, 2, 20);\n        map.clear();\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_len_after_remove() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.insert_full(0, 1, 10);\n        map.insert_full(1, 2, 20);\n        map.pop();\n        assert_eq!(map.len(), 1);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::move_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::IndexMapCore;\n\n    #[test]\n    fn test_move_index() {\n        let mut map: IndexMapCore<i32, &str> = IndexMapCore::new();\n        map.push_entry(HashValue::from(1), 1, \"one\");\n        map.push_entry(HashValue::from(2), 2, \"two\");\n        map.push_entry(HashValue::from(3), 3, \"three\");\n        \n        // Initial order should be: [1, 2, 3]\n      assert_eq!(map.entries, vec![\n            Bucket { hash: HashValue::from(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue::from(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue::from(3), key: 3, value: \"three\" }\n        ]);\n\n        map.move_index(0, 2);\n        \n        // After moving index 0 (1) to index 2, order should be: [2, 3, 1]\n        assert_eq!(map.entries, vec![\n            Bucket { hash: HashValue::from(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue::from(3), key: 3, value: \"three\" },\n            Bucket { hash: HashValue::from(1), key: 1, value: \"one\" }\n        ]);\n\n        map.move_index(1, 0);\n        \n        // After moving index 1 (3) to index 0, order should be: [3, 2, 1]\n        assert_eq!(map.entries, vec![\n            Bucket { hash: HashValue::from(3), key: 3, value: \"three\" },\n            Bucket { hash: HashValue::from(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue::from(1), key: 1, value: \"one\" }\n        ]);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_move_index_out_of_bounds() {\n        let mut map: IndexMapCore<i32, &str> = IndexMapCore::new();\n        map.push_entry(HashValue::from(1), 1, \"one\");\n        \n        // Moving out of bounds should panic\n        map.move_index(0, 1);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_index_map_core_new() {\n        let index_map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        \n        // Assert that indices are initialized correctly\n        assert_eq!(index_map.indices.len(), 0);\n        // Assert that entries are initialized correctly\n        assert_eq!(index_map.entries.len(), 0);\n        // Assert that capacity is initialized to 0\n        assert_eq!(index_map.capacity(), 0);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::pop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_pop_empty() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        assert_eq!(map.pop(), None);\n    }\n\n    #[test]\n    fn test_pop_single_element() {\n        let mut map = IndexMapCore::new();\n        map.push_entry(1, 1, 10); // Assuming a method to push an entry\n        assert_eq!(map.pop(), Some((1, 10)));\n        assert_eq!(map.pop(), None);\n    }\n\n    #[test]\n    fn test_pop_multiple_elements() {\n        let mut map = IndexMapCore::with_capacity(2);\n        map.push_entry(1, 1, 10);\n        map.push_entry(2, 2, 20);\n        \n        assert_eq!(map.pop(), Some((2, 20)));\n        assert_eq!(map.pop(), Some((1, 10)));\n        assert_eq!(map.pop(), None);\n    }\n\n    #[test]\n    fn test_pop_updates_indices() {\n        let mut map = IndexMapCore::with_capacity(2);\n        map.push_entry(1, 1, 10);\n        map.push_entry(2, 2, 20);\n        \n        let (key, value) = map.pop().unwrap();\n        assert_eq!(key, 2);\n        assert_eq!(value, 20);\n        assert_eq!(map.len(), 1); // Should be 1 after pop\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::push_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_push_entry() {\n        let mut map: IndexMapCore<String, i32> = IndexMapCore::new();\n        let hash = HashValue(1); // Example hash value\n\n        // Push an entry\n        map.push_entry(hash, String::from(\"key1\"), 42);\n\n        // Verify the entry has been added\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.entries.len(), 1);\n        assert_eq!(map.entries[0].key, \"key1\");\n        assert_eq!(map.entries[0].value, 42);\n        assert_eq!(map.entries[0].hash, hash);\n\n        // Push another entry\n        map.push_entry(HashValue(2), String::from(\"key2\"), 100);\n\n        // Verify the second entry has been added\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.entries.len(), 2);\n        assert_eq!(map.entries[1].key, \"key2\");\n        assert_eq!(map.entries[1].value, 100);\n        assert_eq!(map.entries[1].hash, HashValue(2));\n    }\n\n    #[test]\n    fn test_push_entry_reserve_capacity() {\n        let mut map: IndexMapCore<String, i32> = IndexMapCore::with_capacity(1);\n        let hash = HashValue(1);\n\n        // Push the first entry\n        map.push_entry(hash, String::from(\"key1\"), 42);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.entries.len(), 1);\n\n        // Push another entry to trigger capacity reservation\n        map.push_entry(HashValue(2), String::from(\"key2\"), 100);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.entries.len(), 2);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::rebuild_hash_table": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_rebuild_hash_table() {\n        let mut map: IndexMapCore<i32, &'static str> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: 1, key: 1, value: \"one\" });\n        map.entries.push(Bucket { hash: 2, key: 2, value: \"two\" });\n        map.rebuild_hash_table();\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.entries.len(), 2);\n        assert_eq!(map.indices.len(), 2);\n    }\n\n    #[test]\n    fn test_rebuild_hash_table_empty() {\n        let mut map: IndexMapCore<i32, &'static str> = IndexMapCore::new();\n        map.rebuild_hash_table();\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.entries.len(), 0);\n        assert_eq!(map.indices.len(), 0);\n    }\n\n    #[test]\n    fn test_rebuild_hash_table_after_clear() {\n        let mut map: IndexMapCore<i32, &'static str> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: 1, key: 1, value: \"one\" });\n        map.entries.push(Bucket { hash: 2, key: 2, value: \"two\" });\n        map.clear();\n        map.rebuild_hash_table();\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.entries.len(), 0);\n        assert_eq!(map.indices.len(), 0);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::replace_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_replace_full_insert_new_key() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        let hash = HashValue(1);\n        let key = 10;\n        let value = \"value1\".to_string();\n\n        let (index, old_entry) = map.replace_full(hash, key, value);\n\n        assert_eq!(index, 0);\n        assert!(old_entry.is_none());\n        assert_eq!(map.entries.len(), 1);\n        assert_eq!(map.entries[0].key, key);\n        assert_eq!(map.entries[0].value, \"value1\");\n    }\n\n    #[test]\n    fn test_replace_full_replace_existing_key() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        let hash = HashValue(1);\n        let key = 10;\n        let value1 = \"value1\".to_string();\n        let value2 = \"value2\".to_string();\n\n        map.replace_full(hash, key, value1.clone());\n        let (index, old_entry) = map.replace_full(hash, key, value2.clone());\n\n        assert_eq!(index, 0);\n        assert!(old_entry.is_some());\n        assert_eq!(old_entry.unwrap(), (key, value1));\n        assert_eq!(map.entries.len(), 1);\n        assert_eq!(map.entries[0].key, key);\n        assert_eq!(map.entries[0].value, \"value2\");\n    }\n\n    #[test]\n    fn test_replace_full_insert_different_key() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        let hash1 = HashValue(1);\n        let hash2 = HashValue(2);\n        let key1 = 10;\n        let key2 = 20;\n        let value1 = \"value1\".to_string();\n        let value2 = \"value2\".to_string();\n\n        map.replace_full(hash1, key1, value1.clone());\n        let (index, old_entry) = map.replace_full(hash2, key2, value2.clone());\n\n        assert_eq!(index, 1);\n        assert!(old_entry.is_none());\n        assert_eq!(map.entries.len(), 2);\n        assert_eq!(map.entries[0].key, key1);\n        assert_eq!(map.entries[0].value, \"value1\");\n        assert_eq!(map.entries[1].key, key2);\n        assert_eq!(map.entries[1].value, \"value2\");\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_reserve() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n\n        // Initial state: capacity should be 0\n        assert_eq!(map.capacity(), 0);\n\n        // Reserve capacity for 5 additional elements\n        map.reserve(5);\n\n        // After reserving, capacity should be greater than or equal to 5\n        assert!(map.capacity() >= 5);\n\n        // Reserve capacity for 10 additional elements\n        map.reserve(10);\n\n        // After reserving again, capacity should still be greater than or equal to 15\n        assert!(map.capacity() >= 15);\n\n        // Check length after reserving, should still be 0\n        assert_eq!(map.len(), 0);\n\n        // Reserve should not change capacity if the additional reserve is zero\n        map.reserve(0);\n        assert_eq!(map.capacity(), map.capacity());\n    }\n\n    #[test]\n    fn test_reserve_increases_entries_capacity() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::with_capacity(5);\n        assert_eq!(map.capacity(), 5);\n        \n        // Reserve might increase the entries capacity\n        map.reserve(10);\n        assert!(map.capacity() >= 15);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::reserve_exact": "```rust\n#[cfg(test)]\nmod tests {\n    use super::IndexMapCore;\n\n    #[test]\n    fn test_reserve_exact() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        \n        // Initially, the capacity should be 0.\n        assert_eq!(map.capacity(), 0);\n        \n        // Reserve capacity for 5 elements.\n        map.reserve_exact(5);\n        assert!(map.capacity() >= 5);\n        \n        // Reserve for 3 more elements.\n        map.reserve_exact(3);\n        assert!(map.capacity() >= 8);\n        \n        // Reserve for 0 elements should not change capacity.\n        let current_capacity = map.capacity();\n        map.reserve_exact(0);\n        assert_eq!(map.capacity(), current_capacity);\n        \n        // Reserve more elements beyond current capacity.\n        let more_capacity = 10;\n        map.reserve_exact(more_capacity);\n        assert!(map.capacity() >= current_capacity + more_capacity);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::retain_in_order": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hashbrown::HashMap;\n\n    #[test]\n    fn test_retain_in_order() {\n        let mut map = IndexMapCore::new();\n        map.insert_full(1.hash(), \"a\".to_string(), 1);\n        map.insert_full(2.hash(), \"b\".to_string(), 2);\n        map.insert_full(3.hash(), \"c\".to_string(), 3);\n        \n        map.retain_in_order(|k, v| {\n            if k == \"b\" {\n                *v = 20;  // Modify value for key \"b\"\n                true      // Keep \"b\"\n            } else {\n                false     // Remove \"a\" and \"c\"\n            }\n        });\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.entries.len(), 1);\n        assert_eq!(map.entries[0].key, \"b\");\n        assert_eq!(map.entries[0].value, 20);\n    }\n\n    #[test]\n    fn test_retain_no_items() {\n        let mut map = IndexMapCore::new();\n        map.insert_full(1.hash(), \"a\".to_string(), 1);\n        \n        map.retain_in_order(|_k, _v| false);\n\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.entries.len(), 0);\n    }\n\n    #[test]\n    fn test_retain_all_items() {\n        let mut map = IndexMapCore::new();\n        map.insert_full(1.hash(), \"a\".to_string(), 1);\n        map.insert_full(2.hash(), \"b\".to_string(), 2);\n\n        map.retain_in_order(|_k, _v| true);\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.entries.len(), 2);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::reverse": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::IndexMapCore;\n\n    #[test]\n    fn test_reverse() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: 0, key: 1, value: 10 });\n        map.entries.push(Bucket { hash: 1, key: 2, value: 20 });\n        map.entries.push(Bucket { hash: 2, key: 3, value: 30 });\n        map.indices.push(0);\n        map.indices.push(1);\n        map.indices.push(2);\n        \n        map.reverse();\n        \n        assert_eq!(map.entries.len(), 3);\n        assert_eq!(map.entries[0].key, 3);\n        assert_eq!(map.entries[1].key, 2);\n        assert_eq!(map.entries[2].key, 1);\n        assert_eq!(map.indices[0], 2);\n        assert_eq!(map.indices[1], 1);\n        assert_eq!(map.indices[2], 0);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::shift_remove_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_shift_remove_full() {\n        let mut map: IndexMapCore<&str, i32> = IndexMapCore::new();\n        let key1 = \"key1\";\n        let key2 = \"key2\";\n        let key3 = \"key3\";\n        \n        // Insert entries\n        let hash1 = HashValue(1);\n        let hash2 = HashValue(2);\n        let hash3 = HashValue(3);\n        \n        map.push_entry(hash1, key1, 10);\n        map.push_entry(hash2, key2, 20);\n        map.push_entry(hash3, key3, 30);\n        \n        // Check the map length\n        assert_eq!(map.len(), 3);\n        \n        // Shift remove key2\n        let result = map.shift_remove_full(hash2, &key2);\n        assert_eq!(result, Some((1, \"key2\", 20))); // Index of removed key, key and value\n        \n        // Check the map length after removal\n        assert_eq!(map.len(), 2);\n        \n        // Verify remaining entries\n        assert_eq!(map.shift_remove_full(hash1, &key1), Some((0, \"key1\", 10)));\n        assert_eq!(map.shift_remove_full(hash3, &key3), Some((0, \"key3\", 30)));\n        \n        // Ensure the map is empty\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_shift_remove_full_non_existent() {\n        let mut map: IndexMapCore<&str, i32> = IndexMapCore::new();\n        let key = \"key\";\n\n        // Insert an entry\n        let hash = HashValue(1);\n        map.push_entry(hash, key, 42);\n\n        // Try to remove a non-existent key\n        let result = map.shift_remove_full(HashValue(2), &\"non_existent_key\");\n        assert_eq!(result, None); // Should return None\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::shift_remove_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust this import according to your module structure\n    use std::collections::hash_map::DefaultHasher;\n\n    #[test]\n    fn test_shift_remove_index() {\n        // Setup\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        \n        // Insert some entries\n        let hash1 = DefaultHasher::new().write(&1.to_ne_bytes()).finish();\n        let hash2 = DefaultHasher::new().write(&2.to_ne_bytes()).finish();\n        let hash3 = DefaultHasher::new().write(&3.to_ne_bytes()).finish();\n\n        map.insert_full(HashValue::from(hash1), 1, \"one\".to_string());\n        map.insert_full(HashValue::from(hash2), 2, \"two\".to_string());\n        map.insert_full(HashValue::from(hash3), 3, \"three\".to_string());\n\n        // Initial state\n        assert_eq!(map.len(), 3);\n        assert_eq!(map.entries.len(), 3);\n\n        // Test removing index 1\n        let removed_entry = map.shift_remove_index(1);\n        assert_eq!(removed_entry, Some((2, \"two\".to_string())));\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.entries.len(), 2);\n\n        // Ensure remaining entries are correct\n        let remaining_entry1 = map.shift_remove_index(0);\n        assert_eq!(remaining_entry1, Some((1, \"one\".to_string())));\n        let remaining_entry2 = map.shift_remove_index(0);\n        assert_eq!(remaining_entry2, Some((3, \"three\".to_string())));\n        \n        // Test removing from empty\n        let removed_from_empty = map.shift_remove_index(0);\n        assert_eq!(removed_from_empty, None);\n    }\n\n    #[test]\n    fn test_shift_remove_index_out_of_bounds() {\n        // Setup\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        map.insert_full(HashValue::from(0), 1, \"one\".to_string());\n\n        // Test invalid index\n        let removed_entry = map.shift_remove_index(1); // index out of bounds\n        assert_eq!(removed_entry, None);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::shrink_to": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_shrink_to() {\n        let mut map = IndexMapCore::<i32, i32>::with_capacity(10);\n        \n        // Insert some values\n        for i in 0..5 {\n            map.push_entry(0, i, i);\n        }\n        \n        // Ensure capacity is 10\n        assert_eq!(map.capacity(), 10);\n        \n        // Shrink to 5\n        map.shrink_to(5);\n        \n        // Check the capacity is now 5\n        assert_eq!(map.capacity(), 5);\n        \n        // Insert more values\n        for i in 5..10 {\n            map.push_entry(0, i, i);\n        }\n        \n        // Ensure capacity is still sufficient for 10\n        assert!(map.capacity() >= 10);\n        \n        // Shrink to 0\n        map.shrink_to(0);\n        \n        // Check the capacity is now 0\n        assert_eq!(map.capacity(), 0);\n    }\n    \n    #[test]\n    fn test_shrink_to_below_min_capacity() {\n        let mut map = IndexMapCore::<i32, i32>::with_capacity(5);\n        \n        // Insert some values\n        for i in 0..3 {\n            map.push_entry(0, i, i);\n        }\n        \n        // Shrink to 10, which should not change the capacity\n        map.shrink_to(10);\n        \n        // Check that capacity is still 5\n        assert_eq!(map.capacity(), 5);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::split_off": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_split_off() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.insert_full(1, 10);\n        map.insert_full(2, 20);\n        map.insert_full(3, 30);\n\n        let split_map = map.split_off(2);\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(split_map.len(), 1);\n        assert_eq!(map.entries.len(), 2);\n        assert_eq!(split_map.entries.len(), 1);\n        assert_eq!(map.entries[0].key, 1);\n        assert_eq!(map.entries[1].key, 2);\n        assert_eq!(split_map.entries[0].key, 3);\n\n        let result = std::panic::catch_unwind(|| {\n            map.split_off(3);\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_split_off_empty() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        let split_map = map.split_off(0);\n\n        assert_eq!(map.len(), 0);\n        assert_eq!(split_map.len(), 0);\n    }\n\n    #[test]\n    fn test_split_off_full() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.insert_full(1, 10);\n        map.insert_full(2, 20);\n        map.insert_full(3, 30);\n\n        let split_map = map.split_off(3);\n\n        assert_eq!(map.len(), 3);\n        assert_eq!(split_map.len(), 0);\n        assert_eq!(map.entries.len(), 3);\n    }\n\n    #[test]\n    fn test_split_off_at_index_zero() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.insert_full(1, 10);\n        map.insert_full(2, 20);\n\n        let split_map = map.split_off(0);\n\n        assert_eq!(map.len(), 0);\n        assert_eq!(split_map.len(), 2);\n        assert_eq!(split_map.entries[0].key, 1);\n        assert_eq!(split_map.entries[1].key, 2);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::split_splice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n    \n    #[test]\n    fn test_split_splice() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        map.push_entry(1, 1, \"one\".to_string());\n        map.push_entry(2, 2, \"two\".to_string());\n        map.push_entry(3, 3, \"three\".to_string());\n        \n        let (spliced, drained_iter) = map.split_splice(1..3);\n        \n        let drained: Vec<_> = drained_iter.collect();\n        \n        assert_eq!(drained.len(), 2);\n        assert_eq!(drained[0].key, 1);\n        assert_eq!(drained[1].key, 2);\n        \n        assert_eq!(spliced.len(), 1);\n        assert_eq!(spliced.entries.len(), 1);\n        assert_eq!(spliced.entries[0].key, 3);\n    }\n    \n    #[test]\n    fn test_split_splice_empty() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        let (spliced, drained_iter) = map.split_splice(0..0);\n        \n        let drained: Vec<_> = drained_iter.collect();\n        \n        assert!(drained.is_empty());\n        assert!(spliced.entries.is_empty());\n    }\n    \n    #[test]\n    fn test_split_splice_full() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        map.push_entry(1, 1, \"one\".to_string());\n        map.push_entry(2, 2, \"two\".to_string());\n        map.push_entry(3, 3, \"three\".to_string());\n        \n        let (spliced, drained_iter) = map.split_splice(0..3);\n        \n        let drained: Vec<_> = drained_iter.collect();\n        \n        assert_eq!(drained.len(), 3);\n        assert_eq!(drained[0].key, 1);\n        assert_eq!(drained[1].key, 2);\n        assert_eq!(drained[2].key, 3);\n        \n        assert!(spliced.entries.is_empty());\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::swap_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_swap_indices() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: 0, key: 1, value: 10 });\n        map.entries.push(Bucket { hash: 1, key: 2, value: 20 });\n        map.entries.push(Bucket { hash: 2, key: 3, value: 30 });\n\n        // Before swap\n        assert_eq!(map.entries[0].key, 1);\n        assert_eq!(map.entries[1].key, 2);\n        assert_eq!(map.entries[2].key, 3);\n\n        map.swap_indices(0, 2);\n\n        // After swap\n        assert_eq!(map.entries[0].key, 3);\n        assert_eq!(map.entries[1].key, 2);\n        assert_eq!(map.entries[2].key, 1);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_swap_indices_out_of_bounds() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        map.entries.push(Bucket { hash: 0, key: 1, value: 10 });\n        map.entries.push(Bucket { hash: 1, key: 2, value: 20 });\n\n        // This should panic as the index 2 is out of bounds\n        map.swap_indices(0, 2);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::swap_remove_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n    struct TestKey(usize);\n\n    #[derive(Debug, Clone)]\n    struct TestValue(usize);\n\n    #[test]\n    fn test_swap_remove_full_existing_entry() {\n        let mut map: IndexMapCore<TestKey, TestValue> = IndexMapCore::new();\n        let key = TestKey(1);\n        let hash_value = HashValue(1);\n        map.insert_full(hash_value, key.clone(), TestValue(10));\n\n        let result = map.swap_remove_full(hash_value, &key);\n        assert_eq!(result, Some((0, key, TestValue(10))));\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_swap_remove_full_non_existing_entry() {\n        let mut map: IndexMapCore<TestKey, TestValue> = IndexMapCore::new();\n        let key = TestKey(1);\n        let hash_value = HashValue(1);\n\n        let result = map.swap_remove_full(hash_value, &key);\n        assert_eq!(result, None);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_swap_remove_full_multiple_entries() {\n        let mut map: IndexMapCore<TestKey, TestValue> = IndexMapCore::new();\n        let key1 = TestKey(1);\n        let key2 = TestKey(2);\n        let key3 = TestKey(3);\n        map.insert_full(HashValue(1), key1.clone(), TestValue(10));\n        map.insert_full(HashValue(2), key2.clone(), TestValue(20));\n        map.insert_full(HashValue(3), key3.clone(), TestValue(30));\n\n        let result = map.swap_remove_full(HashValue(2), &key2);\n        assert_eq!(result, Some((1, key2, TestValue(20))));\n        assert_eq!(map.len(), 2);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::swap_remove_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_swap_remove_index() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        map.push_entry(get_hash(&1), 1, \"one\".to_string());\n        map.push_entry(get_hash(&2), 2, \"two\".to_string());\n        map.push_entry(get_hash(&3), 3, \"three\".to_string());\n        \n        assert_eq!(map.swap_remove_index(1), Some((2, \"two\".to_string())));\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.swap_remove_index(0), Some((1, \"one\".to_string())));\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.swap_remove_index(0), Some((3, \"three\".to_string())));\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.swap_remove_index(0), None);\n    }\n\n    #[test]\n    fn test_swap_remove_index_out_of_bounds() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        map.push_entry(get_hash(&1), 1, \"one\".to_string());\n\n        assert_eq!(map.swap_remove_index(1), None); // Index out of bounds\n        assert_eq!(map.swap_remove_index(2), None); // Index out of bounds\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::truncate": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_truncate() {\n        let mut map: IndexMapCore<String, i32> = IndexMapCore::new();\n        map.insert_full(0, \"a\".to_string(), 1);\n        map.insert_full(0, \"b\".to_string(), 2);\n        map.insert_full(0, \"c\".to_string(), 3);\n\n        assert_eq!(map.len(), 3);\n        map.truncate(2);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.entries.len(), 2);\n\n        map.truncate(2);\n        assert_eq!(map.len(), 2);\n\n        map.truncate(1);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.entries.len(), 1);\n\n        map.truncate(0);\n        assert_eq!(map.len(), 0);\n        assert!(map.entries.is_empty());\n    }\n\n    #[test]\n    fn test_truncate_no_change() {\n        let mut map: IndexMapCore<String, i32> = IndexMapCore::new();\n        map.insert_full(0, \"a\".to_string(), 1);\n        map.insert_full(0, \"b\".to_string(), 2);\n\n        assert_eq!(map.len(), 2);\n        map.truncate(2);\n        assert_eq!(map.len(), 2);\n    }\n\n    #[test]\n    fn test_truncate_with_empty_map() {\n        let mut map: IndexMapCore<String, i32> = IndexMapCore::new();\n        assert_eq!(map.len(), 0);\n        \n        map.truncate(1);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_truncate_beyond_capacity() {\n        let mut map: IndexMapCore<String, i32> = IndexMapCore::new();\n        map.insert_full(0, \"a\".to_string(), 1);\n\n        assert_eq!(map.len(), 1);\n        map.truncate(3);\n        assert_eq!(map.len(), 1);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::try_reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n    use crate::TryReserveError;\n\n    #[test]\n    fn test_try_reserve_success() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        assert_eq!(map.try_reserve(5), Ok(()));\n        assert!(map.capacity() >= 5);\n    }\n\n    #[test]\n    fn test_try_reserve_exceeds_capacity() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(2);\n        assert_eq!(map.try_reserve(3), Ok(()));\n        assert!(map.capacity() >= 3);\n    }\n\n    #[test]\n    fn test_try_reserve_no_growth() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(5);\n        map.try_reserve(2).unwrap();\n        let initial_capacity = map.capacity();\n        assert_eq!(map.try_reserve(1), Ok(()));\n        assert_eq!(map.capacity(), initial_capacity);\n    }\n\n    #[test]\n    fn test_try_reserve_error() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(0);\n        let result = map.try_reserve(IndexMapCore::<i32, i32>::MAX_ENTRIES_CAPACITY + 1);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().kind(), TryReserveError::CapacityOverflow);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::try_reserve_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n    use crate::TryReserveError;\n\n    #[test]\n    fn test_try_reserve_entries_success() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(5);\n        map.entries.push(Bucket { hash: HashValue::from(0), key: 1, value: 10 });\n        let result = map.try_reserve_entries(3);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_reserve_entries_exceeding_capacity() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(2);\n        map.entries.push(Bucket { hash: HashValue::from(0), key: 1, value: 10 });\n        map.entries.push(Bucket { hash: HashValue::from(1), key: 2, value: 20 });\n        let result = map.try_reserve_entries(3);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_reserve_entries_exact_success() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(5);\n        map.entries.push(Bucket { hash: HashValue::from(0), key: 1, value: 10 });\n        map.entries.push(Bucket { hash: HashValue::from(1), key: 2, value: 20 });\n        let result = map.try_reserve_entries(2);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_reserve_entries_no_op() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(5);\n        let result = map.try_reserve_entries(0);\n        assert!(result.is_ok());\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::try_reserve_exact": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n    use alloc::vec::Vec;\n\n    #[test]\n    fn test_try_reserve_exact_success() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        assert!(map.try_reserve_exact(5).is_ok());\n        assert_eq!(map.capacity(), 5);\n    }\n\n    #[test]\n    fn test_try_reserve_exact_exceed_capacity() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(2);\n        assert!(map.try_reserve_exact(3).is_err());\n    }\n\n    #[test]\n    fn test_try_reserve_exact_zero() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::new();\n        assert!(map.try_reserve_exact(0).is_ok());\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_try_reserve_exact_with_existing_entries() {\n        let mut map: IndexMapCore<i32, i32> = IndexMapCore::with_capacity(3);\n        map.entries.push(Bucket { hash: 0, key: 1, value: 10 });\n        assert!(map.try_reserve_exact(2).is_ok());\n        assert_eq!(map.capacity(), 3);\n    }\n}\n```", "map::core::IndexMapCore::<K, V>::with_capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_with_capacity() {\n        let capacity = 10;\n        let index_map = IndexMapCore::<i32, i32>::with_capacity(capacity);\n\n        assert_eq!(index_map.len(), 0);\n        assert!(index_map.capacity() >= capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let index_map = IndexMapCore::<i32, i32>::with_capacity(0);\n\n        assert_eq!(index_map.len(), 0);\n        assert!(index_map.capacity() >= 0);\n    }\n\n    #[test]\n    fn test_with_capacity_large() {\n        let capacity = IndexMapCore::<i32, i32>::MAX_ENTRIES_CAPACITY;\n        let index_map = IndexMapCore::<i32, i32>::with_capacity(capacity);\n\n        assert_eq!(index_map.len(), 0);\n        assert!(index_map.capacity() >= capacity);\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::decrement_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{Indices, Bucket, Entries, HashValue};\n\n    #[test]\n    fn test_decrement_indices() {\n        let mut indices = Indices::new();\n        let mut entries = Vec::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        // Insert some entries\n        let hash1 = HashValue::new(1);\n        let hash2 = HashValue::new(2);\n        let hash3 = HashValue::new(3);\n\n        ref_mut.insert_unique(hash1, \"key1\", \"value1\");\n        ref_mut.insert_unique(hash2, \"key2\", \"value2\");\n        ref_mut.insert_unique(hash3, \"key3\", \"value3\");\n\n        // Before decrementing indices\n        assert_eq!(ref_mut.indices.len(), 3);\n\n        // Decrement indices from 1 to 3\n        ref_mut.decrement_indices(1, 3);\n\n        // Verify indices after decrement\n        assert_eq!(ref_mut.indices[0], 0);\n        assert_eq!(ref_mut.indices[1], 1);\n        // Hash for entry 2 should become 0\n        assert_eq!(ref_mut.indices[2], 2);\n        \n        // Verify entries remain unchanged\n        assert_eq!(ref_mut.entries[0].key, \"key1\");\n        assert_eq!(ref_mut.entries[1].key, \"key2\");\n        assert_eq!(ref_mut.entries[2].key, \"key3\");\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::increment_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::{RefMut, Entries, Indices, Bucket};\n\n    #[test]\n    fn test_increment_indices_full_sweep() {\n        let mut indices = vec![0, 1, 2, 3, 4];\n        let mut entries = vec![Bucket { hash: 0, key: \"a\", value: 1 },\n                               Bucket { hash: 1, key: \"b\", value: 2 },\n                               Bucket { hash: 2, key: \"c\", value: 3 },\n                               Bucket { hash: 3, key: \"d\", value: 4 },\n                               Bucket { hash: 4, key: \"e\", value: 5 }];\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        ref_mut.increment_indices(1, 3);\n        assert_eq!(ref_mut.indices, &[0, 2, 3, 4, 4]); // Indices should be incremented\n    }\n\n    #[test]\n    fn test_increment_indices_find_each_entry() {\n        let mut indices = vec![0, 1, 4];\n        let mut entries = vec![Bucket { hash: 0, key: \"a\", value: 1 },\n                               Bucket { hash: 1, key: \"b\", value: 2 },\n                               Bucket { hash: 2, key: \"c\", value: 3 },\n                               Bucket { hash: 3, key: \"d\", value: 4 }];\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        ref_mut.increment_indices(1, 3);\n        assert_eq!(ref_mut.indices, &[0, 2, 4]); // Only indices 1 and 2 should be incremented\n    }\n\n    #[test]\n    fn test_increment_indices_with_empty_range() {\n        let mut indices = vec![0];\n        let mut entries = vec![Bucket { hash: 0, key: \"a\", value: 1 }];\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        ref_mut.increment_indices(1, 1);\n        assert_eq!(ref_mut.indices, &[0]); // Indices should remain unchanged\n    }\n\n    #[test]\n    fn test_increment_indices_out_of_bounds() {\n        let mut indices = vec![0, 1, 2];\n        let mut entries = vec![Bucket { hash: 0, key: \"a\", value: 1 },\n                               Bucket { hash: 1, key: \"b\", value: 2 }];\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        ref_mut.increment_indices(2, 3);\n        assert_eq!(ref_mut.indices, &[0, 1, 3]); // Only index 2 should be incremented\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::insert_unique": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::{RefMut, OccupiedEntry, HashValue};\n    use crate::map::core::entry::OccupiedEntry as CoreOccupiedEntry;\n\n    #[test]\n    fn test_insert_unique() {\n        let mut indices = Indices::new(); // Make sure your Indices struct is properly defined\n        let mut entries = Entries::<String, String>::new(); // Make sure your Entries struct is properly defined\n        let ref_mut = RefMut::new(&mut indices, &mut entries);\n        \n        let hash_value = HashValue(42);\n        let key = \"test_key\".to_string();\n        let value = \"test_value\".to_string();\n\n        let occupied_entry: OccupiedEntry<String, String> = ref_mut.insert_unique(hash_value, key.clone(), value.clone());\n        \n        assert_eq!(occupied_entry.key(), &key);\n        assert_eq!(occupied_entry.get(), &value);\n        assert_eq!(occupied_entry.index(), 0); // Make sure this index is what you expect\n\n        // Ensure that the entry can be retrieved from entries\n        assert_eq!(entries.get(0).unwrap().key, key);\n        assert_eq!(entries.get(0).unwrap().value, value);\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::move_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::{RefMut, Indices, Entries, Bucket};\n    use crate::hash::HashValue;\n\n    #[test]\n    fn test_move_index() {\n        // Setup the test data\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        \n        // Create a RefMut instance\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        // Insert test entries\n        ref_mut.insert_unique(HashValue::from(1), \"a\", 10);\n        ref_mut.insert_unique(HashValue::from(2), \"b\", 20);\n        ref_mut.insert_unique(HashValue::from(3), \"c\", 30);\n        \n        // Test moving an entry\n        ref_mut.move_index(0, 2);\n\n        // Verify the entries after moving\n        assert_eq!(ref_mut.entries[0].key, \"b\");\n        assert_eq!(ref_mut.entries[1].key, \"c\");\n        assert_eq!(ref_mut.entries[2].key, \"a\");\n        \n        // Test moving in the opposite direction\n        ref_mut.move_index(2, 0);\n        \n        // Verify the entries after moving back\n        assert_eq!(ref_mut.entries[0].key, \"a\");\n        assert_eq!(ref_mut.entries[1].key, \"b\");\n        assert_eq!(ref_mut.entries[2].key, \"c\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_move_index_out_of_bounds() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        ref_mut.insert_unique(HashValue::from(1), \"a\", 10);\n        ref_mut.insert_unique(HashValue::from(2), \"b\", 20);\n\n        // Trying to move an index out of bounds should panic\n        ref_mut.move_index(0, 3);\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::{RefMut, Entries, Indices};\n\n    #[test]\n    fn test_refmut_new() {\n        let mut indices = Indices::new(); // Assuming Indices has a new() method to initialize\n        let mut entries = Entries::new(); // Assuming Entries has a new() method to initialize\n        let ref_mut = RefMut::new(&mut indices, &mut entries);\n        assert_eq!(ref_mut.indices, &mut indices);\n        assert_eq!(ref_mut.entries, &mut entries);\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::reserve_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::{RefMut, Indices, Entries, Bucket};\n\n    #[test]\n    fn test_reserve_entries() {\n        let mut indices = Indices::new(); // assuming you have a way to create an Indices instance\n        let mut entries = Entries::new(); // assuming you have a way to create an Entries instance\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        let initial_capacity = entries.capacity();\n        let additional_entries = 10;\n\n        ref_mut.reserve_entries(additional_entries);\n\n        // Verify that the entries capacity has increased appropriately\n        assert!(entries.capacity() >= initial_capacity + additional_entries);\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::shift_insert_unique": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::{RefMut, HashValue, Bucket};\n    \n    #[test]\n    fn test_shift_insert_unique() {\n        // Setup\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n        \n        // Test inserting at index 0\n        let key1 = \"key1\";\n        let value1 = \"value1\";\n        let hash1 = HashValue(1);\n        ref_mut.shift_insert_unique(0, hash1, key1, value1);\n        \n        assert_eq!(entries.len(), 1);\n        assert_eq!(entries[0].key, key1);\n        assert_eq!(entries[0].value, value1);\n        \n        // Test inserting at index 1 (which is end)\n        let key2 = \"key2\";\n        let value2 = \"value2\";\n        let hash2 = HashValue(2);\n        ref_mut.shift_insert_unique(1, hash2, key2, value2);\n        \n        assert_eq!(entries.len(), 2);\n        assert_eq!(entries[1].key, key2);\n        assert_eq!(entries[1].value, value2);\n        \n        // Test inserting at index 0, shifting existing entries\n        let key3 = \"key3\";\n        let value3 = \"value3\";\n        let hash3 = HashValue(3);\n        ref_mut.shift_insert_unique(0, hash3, key3, value3);\n        \n        assert_eq!(entries.len(), 3);\n        assert_eq!(entries[0].key, key3);\n        assert_eq!(entries[1].key, key1);\n        assert_eq!(entries[2].key, key2);\n        \n        // Validate the values\n        assert_eq!(entries[0].value, value3);\n        assert_eq!(entries[1].value, value1);\n        assert_eq!(entries[2].value, value2);\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::shift_remove_finish": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_shift_remove_finish() {\n        // Setup\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        // Insert sample data\n        ref_mut.insert_unique(HashValue::new(1), \"key1\", \"value1\");\n        ref_mut.insert_unique(HashValue::new(2), \"key2\", \"value2\");\n        ref_mut.insert_unique(HashValue::new(3), \"key3\", \"value3\");\n\n        // Remove entry at index 1\n        let (key, value) = ref_mut.shift_remove_finish(1);\n\n        // Verify removed entry\n        assert_eq!(key, \"key2\");\n        assert_eq!(value, \"value2\");\n\n        // Verify the remaining entries\n        assert_eq!(ref_mut.entries.len(), 2);\n        assert_eq!(ref_mut.entries[0].key, \"key1\");\n        assert_eq!(ref_mut.entries[1].key, \"key3\");\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::shift_remove_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_index() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        // Setup some entries\n        ref_mut.insert_unique(HashValue::new(1), \"key1\", \"value1\");\n        ref_mut.insert_unique(HashValue::new(2), \"key2\", \"value2\");\n        ref_mut.insert_unique(HashValue::new(3), \"key3\", \"value3\");\n\n        // Remove index 1 (\"key2\", \"value2\")\n        let removed_entry = ref_mut.shift_remove_index(1);\n        assert_eq!(removed_entry, Some((\"key2\", \"value2\")));\n\n        // Check remaining entries after removal\n        assert_eq!(ref_mut.entries.len(), 2);\n        assert_eq!(ref_mut.entries.get(0).unwrap().key, \"key1\");\n        assert_eq!(ref_mut.entries.get(1).unwrap().key, \"key3\");\n    }\n\n    #[test]\n    fn test_shift_remove_index_out_of_bounds() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        // Setup some entries\n        ref_mut.insert_unique(HashValue::new(1), \"key1\", \"value1\");\n        ref_mut.insert_unique(HashValue::new(2), \"key2\", \"value2\");\n\n        // Attempt to remove an index that does not exist\n        let removed_entry = ref_mut.shift_remove_index(2);\n        assert_eq!(removed_entry, None);\n    }\n\n    #[test]\n    fn test_shift_remove_index_empty() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        // Attempt to remove an entry from an empty index\n        let removed_entry = ref_mut.shift_remove_index(0);\n        assert_eq!(removed_entry, None);\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::swap_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::{RefMut, Entries, Indices}; // Adjust the import path as necessary\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_swap_indices() {\n        let mut indices = Indices::new(); // Assuming Indices has a new() method\n        let mut entries = Entries::new(); // Assuming Entries has a new() method\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        ref_mut.insert_unique(1, \"key1\", \"value1\"); // Assuming insert_unique works like this\n        ref_mut.insert_unique(2, \"key2\", \"value2\");\n        \n        // Simulate the condition where indices are mutable\n        let original_a = entries.len() - 2; // index 0\n        let original_b = entries.len() - 1; // index 1\n\n        ref_mut.swap_indices(original_a, original_b);\n\n        assert_eq!(entries[original_a].key, \"key2\");\n        assert_eq!(entries[original_b].key, \"key1\");\n    }\n\n    #[test]\n    fn test_swap_indices_same_index() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        ref_mut.insert_unique(1, \"key1\", \"value1\"); \n\n        let original_a = 0;\n\n        // Swapping the same index should not change anything\n        ref_mut.swap_indices(original_a, original_a);\n\n        assert_eq!(entries[original_a].key, \"key1\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"indices not found\")]\n    fn test_swap_indices_out_of_bounds() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        ref_mut.insert_unique(1, \"key1\", \"value1\"); \n        ref_mut.insert_unique(2, \"key2\", \"value2\");\n\n        // Attempt to swap indices that are out of bounds\n        ref_mut.swap_indices(0, 2); // There is no index 2\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::swap_remove_finish": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import necessary items from the current module\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_swap_remove_finish() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n        \n        // Insert some test data\n        ref_mut.insert_unique(1.hash(), \"key1\", \"value1\");\n        ref_mut.insert_unique(2.hash(), \"key2\", \"value2\");\n        ref_mut.insert_unique(3.hash(), \"key3\", \"value3\");\n\n        // Remove the entry at index 1 (which is \"key2\", \"value2\")\n        let (key, value) = ref_mut.swap_remove_finish(1);\n\n        // Check that the key and value are correct\n        assert_eq!(key, \"key2\");\n        assert_eq!(value, \"value2\");\n\n        // Check that the remaining entries are swapped correctly\n        assert_eq!(ref_mut.entries.len(), 2);\n        assert_eq!(ref_mut.entries.get(1).unwrap().key, \"key3\");\n        assert_eq!(ref_mut.entries.get(0).unwrap().key, \"key1\");\n    }\n}\n```", "map::core::RefMut::<'a, K, V>::swap_remove_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::{RefMut, Indices, Entries, Bucket, HashValue}; // Update this import path according to your crate structure\n\n    #[test]\n    fn test_swap_remove_index_valid() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        // Inserting entries\n        let key1 = \"key1\".to_string();\n        let value1 = \"value1\".to_string();\n        let key2 = \"key2\".to_string();\n        let value2 = \"value2\".to_string();\n        let hash1 = HashValue::new(1);\n        let hash2 = HashValue::new(2);\n\n        ref_mut.insert_unique(hash1, key1.clone(), value1.clone());\n        ref_mut.insert_unique(hash2, key2.clone(), value2.clone());\n\n        // Swap remove the first entry\n        let result = ref_mut.swap_remove_index(0);\n        assert_eq!(result, Some((key1, value1)));\n\n        // Check that the remaining entry is now at index 0\n        assert_eq!(ref_mut.entries.len(), 1);\n        assert_eq!(ref_mut.entries.get(0).unwrap().key, key2);\n    }\n\n    #[test]\n    fn test_swap_remove_index_invalid() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        // Inserting entries\n        let key1 = \"key1\".to_string();\n        let value1 = \"value1\".to_string();\n        let hash1 = HashValue::new(1);\n\n        ref_mut.insert_unique(hash1, key1.clone(), value1.clone());\n\n        // Attempt to swap remove at an out-of-bounds index\n        let result = ref_mut.swap_remove_index(1);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_swap_remove_index_last_element() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n\n        // Inserting a single entry\n        let key1 = \"key1\".to_string();\n        let value1 = \"value1\".to_string();\n        let hash1 = HashValue::new(1);\n\n        ref_mut.insert_unique(hash1, key1.clone(), value1.clone());\n\n        // Swap remove the last entry\n        let result = ref_mut.swap_remove_index(0);\n        assert_eq!(result, Some((key1, value1)));\n\n        // Check that the entries are now empty\n        assert_eq!(ref_mut.entries.len(), 0);\n    }\n}\n```", "map::core::entry::<impl map::core::IndexMapCore<K, V>>::entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{HashValue, map::core::IndexMapCore, map::core::entry::Entry};\n\n    #[test]\n    fn test_entry_vacant() {\n        let mut map: IndexMapCore<u32, String> = IndexMapCore::new();\n        let hash = HashValue(0);\n        let key = 1;\n        let entry = map.entry(hash, key);\n        match entry {\n            Entry::Vacant(vacant_entry) => {\n                assert_eq!(vacant_entry.index(), 0);\n                assert_eq!(vacant_entry.key(), &key);\n            },\n            _ => panic!(\"Expected a Vacant entry\"),\n        }\n    }\n\n    #[test]\n    fn test_entry_occupied() {\n        let mut map: IndexMapCore<u32, String> = IndexMapCore::new();\n        let hash = HashValue(1);\n        let key = 1;\n        map.insert_full(hash, key, \"value\".to_string());\n        \n        let entry = map.entry(hash, key);\n        match entry {\n            Entry::Occupied(occupied_entry) => {\n                assert_eq!(occupied_entry.index(), 0);\n                assert_eq!(occupied_entry.get(), &\"value\".to_string());\n            },\n            _ => panic!(\"Expected an Occupied entry\"),\n        }\n    }\n\n    #[test]\n    fn test_entry_insert() {\n        let mut map: IndexMapCore<u32, String> = IndexMapCore::new();\n        let hash = HashValue(2);\n        let key = 2;\n\n        let entry = map.entry(hash, key);\n        let entry_ref = entry.or_insert(\"new_value\".to_string());\n        assert_eq!(entry_ref, &mut \"new_value\".to_string());\n        \n        let entry = map.entry(hash, key);\n        assert_eq!(entry.index(), 0);\n        assert_eq!(entry_ref, &mut \"new_value\".to_string());\n    }\n}\n```", "map::core::entry::Entry::<'a, K, V>::and_modify": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_and_modify_with_occupied_entry() {\n        let mut map: IndexMap<HashValue, u32> = IndexMap::new();\n        let key = HashValue(1);\n        map.insert(key, 10);\n\n        let entry = map.entry(key);\n        entry.and_modify(|value| *value += 5);\n\n        assert_eq!(map.get(&key), Some(&15));\n    }\n\n    #[test]\n    fn test_and_modify_with_vacant_entry() {\n        let mut map: IndexMap<HashValue, u32> = IndexMap::new();\n        let key = HashValue(1);\n\n        let entry = map.entry(key);\n        entry.and_modify(|value| *value += 5);\n\n        assert_eq!(map.get(&key), None);\n    }\n\n    #[test]\n    fn test_and_modify_does_not_modify_if_vacant() {\n        let mut map: IndexMap<HashValue, u32> = IndexMap::new();\n        let key = HashValue(2);\n        map.insert(HashValue(1), 10);\n\n        let entry = map.entry(key);\n        entry.and_modify(|value| *value += 5);\n\n        assert_eq!(map.get(&HashValue(1)), Some(&10));\n    }\n\n    #[test]\n    fn test_and_modify_multiple_modifications() {\n        let mut map: IndexMap<HashValue, u32> = IndexMap::new();\n        let key = HashValue(1);\n        map.insert(key, 10);\n\n        let entry = map.entry(key);\n        entry.and_modify(|value| *value *= 2);\n        entry.and_modify(|value| *value += 5);\n\n        assert_eq!(map.get(&key), Some(&25));\n    }\n}\n```", "map::core::entry::Entry::<'a, K, V>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::entry::{Entry, OccupiedEntry, VacantEntry};\n    use map::core::{RefMut, HashValue}; // adjust imports based on actual crate structure\n\n    #[test]\n    fn test_index_occupied_entry() {\n        let mut entries: Entries<_, _> = Entries::new(); // Placeholder\n        let hash_value = HashValue(1);\n        let key = \"key1\";\n        let value = \"value1\";\n        \n        let mut ref_mut = RefMut::new(&mut indices, &mut entries); // Placeholder for actual indices\n        let occupied_entry = OccupiedEntry::new(&mut entries, ref_mut.index(hash_value.get(), key)); // Placeholder for actual index retrieval\n        let entry = Entry::Occupied(occupied_entry);\n        \n        assert_eq!(entry.index(), expected_index); // Replace expected_index with actual expected value\n    }\n\n    #[test]\n    fn test_index_vacant_entry() {\n        let mut entries: Entries<_, _> = Entries::new(); // Placeholder\n        let hash_value = HashValue(2);\n        let key = \"key2\";\n        \n        let mut ref_mut = RefMut::new(&mut indices, &mut entries); // Placeholder for actual indices\n        let vacant_entry = VacantEntry::new(ref_mut, hash_value, key); // Adjust for actual VacantEntry constructor\n        let entry = Entry::Vacant(vacant_entry);\n        \n        assert_eq!(entry.index(), expected_index); // Replace expected_index with actual expected value\n    }\n}\n```", "map::core::entry::Entry::<'a, K, V>::insert_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::entry::{Entry, OccupiedEntry, VacantEntry};\n    use map::core::HashValue;\n\n    #[test]\n    fn test_insert_entry_on_vacant() {\n        let mut map = IndexMap::new();\n        let key = HashValue(1);\n        let value = \"value1\";\n\n        let entry = Entry::Vacant(VacantEntry::new(map.ref_mut(), key, key));\n        let occupied_entry = entry.insert_entry(value);\n\n        assert_eq!(occupied_entry.index(), 0);\n        assert_eq!(occupied_entry.get(), &value);\n    }\n\n    #[test]\n    fn test_insert_entry_on_occupied() {\n        let mut map = IndexMap::new();\n        let key = HashValue(1);\n        let value1 = \"value1\";\n        let value2 = \"value2\";\n\n        let entry = Entry::Vacant(VacantEntry::new(map.ref_mut(), key, key));\n        entry.insert_entry(value1);\n\n        let occupied_entry = Entry::Occupied(OccupiedEntry::new(map.ref_mut(), key));\n        let old_value = occupied_entry.insert(value2);\n\n        assert_eq!(old_value, value1);\n        assert_eq!(occupied_entry.get(), &value2);\n    }\n}\n```", "map::core::entry::Entry::<'a, K, V>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::{Entry, OccupiedEntry, VacantEntry};\n    use crate::map::IndexMap;\n\n    #[test]\n    fn test_key_for_occupied_entry() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"value1\");\n\n        let entry = map.entry(1);\n        match entry {\n            Entry::Occupied(occupied_entry) => {\n                assert_eq!(occupied_entry.key(), &1);\n            }\n            _ => panic!(\"Expected an occupied entry\"),\n        }\n    }\n\n    #[test]\n    fn test_key_for_vacant_entry() {\n        let mut map = IndexMap::new();\n        let entry = map.entry(2);\n        match entry {\n            Entry::Vacant(vacant_entry) => {\n                assert_eq!(vacant_entry.key(), &2);\n            }\n            _ => panic!(\"Expected a vacant entry\"),\n        }\n    }\n}\n```", "map::core::entry::Entry::<'a, K, V>::or_default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::boxed::Box;\n    use map::core::entry::{Entry, VacantEntry, OccupiedEntry};\n    use map::IndexMap;\n\n    #[test]\n    fn test_or_default_vacant_entry() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        let key = 1;\n        let entry = map.entry(key).or_default();\n        assert_eq!(entry, \"\");\n        assert_eq!(map.get(&key).unwrap(), \"\");\n    }\n    \n    #[test]\n    fn test_or_default_occupied_entry() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        let key = 1;\n        map.insert(key, String::from(\"existing value\"));\n        \n        {\n            let entry = map.entry(key).or_default();\n            assert_eq!(entry, &mut String::from(\"existing value\"));\n        }\n        \n        assert_eq!(map.get(&key).unwrap(), \"existing value\");\n    }\n    \n    #[test]\n    fn test_or_default_inserts_default() {\n        let mut map: IndexMap<i32, Vec<i32>> = IndexMap::new();\n        let key = 1;\n        {\n            let entry = map.entry(key).or_default();\n            assert_eq!(entry, &mut Vec::<i32>::new());\n            entry.push(10);\n        }\n\n        assert_eq!(map.get(&key).unwrap(), &vec![10]);\n    }\n}\n```", "map::core::entry::Entry::<'a, K, V>::or_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_or_insert_vacant() {\n        let mut map: HashMap<HashValue, usize> = HashMap::new();\n        let key = HashValue(1);\n        let entry = map.entry(key).or_insert(42);\n        assert_eq!(*entry, 42);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_occupied() {\n        let mut map: HashMap<HashValue, usize> = HashMap::new();\n        let key = HashValue(1);\n        map.insert(key, 42);\n        let entry = map.entry(key).or_insert(100);\n        assert_eq!(*entry, 42);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_with() {\n        let mut map: HashMap<HashValue, usize> = HashMap::new();\n        let key = HashValue(1);\n        let entry = map.entry(key).or_insert_with(|| 100);\n        assert_eq!(*entry, 100);\n        assert_eq!(map.len(), 1);\n        let entry_occupied = map.entry(key).or_insert_with(|| 200);\n        assert_eq!(*entry_occupied, 100);\n    }\n\n    #[test]\n    fn test_or_insert_with_key() {\n        let mut map: HashMap<HashValue, usize> = HashMap::new();\n        let key = HashValue(1);\n        let entry = map.entry(key).or_insert_with_key(|_key| 200);\n        assert_eq!(*entry, 200);\n        assert_eq!(map.len(), 1);\n        let entry_occupied = map.entry(key).or_insert_with_key(|_key| 300);\n        assert_eq!(*entry_occupied, 200);\n    }\n\n    #[test]\n    fn test_or_default() {\n        let mut map: HashMap<HashValue, usize> = HashMap::new();\n        let key = HashValue(1);\n        let entry = map.entry(key).or_default();\n        assert_eq!(*entry, 0);\n        assert_eq!(map.len(), 1);\n        let entry_occupied = map.entry(key).or_default();\n        assert_eq!(*entry_occupied, 0);\n    }\n}\n```", "map::core::entry::Entry::<'a, K, V>::or_insert_with": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::entry::Entry;\n    use map::core::entry::OccupiedEntry;\n    use map::core::entry::VacantEntry;\n    use map::core::HashValue;\n\n    #[test]\n    fn test_or_insert_with_vacant_entry() {\n        let mut map = IndexMap::new();\n        let key = HashValue(1);\n\n        let entry = map.entry(key);\n        let value = entry.or_insert_with(|| 42);\n        \n        assert_eq!(*value, 42);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_with_occupied_entry() {\n        let mut map = IndexMap::new();\n        let key = HashValue(1);\n        map.insert(key, 10);\n\n        let entry = map.entry(key);\n        let value = entry.or_insert_with(|| 42);\n        \n        assert_eq!(*value, 10);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_with_multiple_calls() {\n        let mut map = IndexMap::new();\n        let key = HashValue(1);\n        map.insert(key, 10);\n\n        let entry = map.entry(key);\n        entry.or_insert_with(|| 42);\n        \n        let value = entry.or_insert_with(|| 99);\n        \n        assert_eq!(*value, 10);  // The value should not change\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_with_return() {\n        let mut map = IndexMap::new();\n        let key = HashValue(1);\n        \n        let entry = map.entry(key);\n        let value = entry.or_insert_with(|| {\n            assert!(map.len() == 0); // Should only be called when vacant\n            42\n        });\n        \n        assert_eq!(*value, 42);\n        assert_eq!(map.len(), 1);\n    }\n}\n```", "map::core::entry::Entry::<'a, K, V>::or_insert_with_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::{Entry, OccupiedEntry, VacantEntry};\n    use crate::map::core::IndexMap;\n\n    #[test]\n    fn test_or_insert_with_key_vacant() {\n        let mut map: IndexMap<HashValue, i32> = IndexMap::new();\n        let key = HashValue(1);\n        let entry = map.entry(key);\n        \n        let value = entry.or_insert_with_key(|k| k.get() as i32 * 10);\n        \n        assert_eq!(*value, 10);\n        assert_eq!(map.get(&key).unwrap(), &10);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_occupied() {\n        let mut map: IndexMap<HashValue, i32> = IndexMap::new();\n        let key = HashValue(1);\n        map.insert(key, 20);\n        \n        let entry = map.entry(key);\n        \n        let value = entry.or_insert_with_key(|k| k.get() as i32 * 10);\n        \n        assert_eq!(*value, 20);\n        assert_eq!(map.get(&key).unwrap(), &20);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_vacant_custom_fn() {\n        let mut map: IndexMap<HashValue, i32> = IndexMap::new();\n        let key = HashValue(2);\n        let entry = map.entry(key);\n        \n        let value = entry.or_insert_with_key(|k| {\n            if k.get() == 1 {\n                30\n            } else {\n                40\n            }\n        });\n        \n        assert_eq!(*value, 40);\n        assert_eq!(map.get(&key).unwrap(), &40);\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::{IndexedEntry, RefMut};\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_get() {\n        let mut map = IndexMapCore::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let entry: IndexedEntry<&str, &str> = IndexedEntry::new(&mut map, 0);\n        assert_eq!(entry.get(), &\"value1\");\n\n        let entry: IndexedEntry<&str, &str> = IndexedEntry::new(&mut map, 1);\n        assert_eq!(entry.get(), &\"value2\");\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Replace with appropriate import if necessary\n    use crate::map::IndexMap; // Replace with relevant path\n    use crate::map::core::entry::IndexedEntry; // Replace with relevant path\n    use crate::map::core::RefMut; // Replace with relevant path\n\n    #[test]\n    fn test_get_mut() {\n        // Create a new IndexMap\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n\n        // Get a mutable entry\n        let mut entry = IndexedEntry::new(&mut map, 0);\n        \n        // Get mutable reference to the value\n        let value_mut = entry.get_mut();\n        \n        // Modify the value\n        *value_mut = \"new_value\";\n\n        // Assert the value in the map has been updated\n        assert_eq!(map.get(\"key1\"), Some(&\"new_value\"));\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::entry::IndexedEntry;\n    use map::core::RefMut;\n    use map::mutable::OccupiableEntry;\n\n    #[test]\n    fn test_index() {\n        let mut indices = Indices::default();\n        let mut entries = Entries::default();\n        let mut map_core = IndexMapCore::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n        \n        let key = \"test_key\";\n        let value = \"test_value\";\n        let hash = HashValue::new(key);\n        \n        let occupied_entry = ref_mut.insert_unique(hash, key, value);\n        let indexed_entry = IndexedEntry::from(occupied_entry);\n        \n        assert_eq!(indexed_entry.index(), 0);\n        \n        ref_mut.insert_unique(HashValue::new(\"another_key\"), \"another_value\");\n\n        assert_eq!(indexed_entry.index(), 0);\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::entry::IndexedEntry;\n    use map::core::IndexMapCore;\n\n    #[test]\n    fn test_insert() {\n        let mut map = IndexMapCore::<String, i32>::new();\n        let mut entry = IndexedEntry::new(&mut map, 0);\n\n        entry.insert(42);\n        assert_eq!(entry.get(), &42);\n\n        let old_value = entry.insert(100);\n        assert_eq!(old_value, 42);\n        assert_eq!(entry.get(), &100);\n    }\n\n    #[test]\n    fn test_insert_multiple() {\n        let mut map = IndexMapCore::<String, i32>::new();\n        map.insert(\"one\".to_string(), 1);\n        map.insert(\"two\".to_string(), 2);\n        map.insert(\"three\".to_string(), 3);\n\n        let mut entry_one = IndexedEntry::new(&mut map, 0);\n        let mut entry_two = IndexedEntry::new(&mut map, 1);\n\n        assert_eq!(entry_one.insert(10), 1);\n        assert_eq!(entry_two.insert(20), 2);\n        assert_eq!(entry_one.get(), &10);\n        assert_eq!(entry_two.get(), &20);\n    }\n\n    #[test]\n    fn test_insert_with_empty_map() {\n        let mut map = IndexMapCore::<String, i32>::new();\n        map.insert(\"key\".to_string(), 10);\n\n        let mut entry = IndexedEntry::new(&mut map, 0);\n        let old_value = entry.insert(20);\n        \n        assert_eq!(old_value, 10);\n        assert_eq!(entry.get(), &20);\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::into_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::{IndexedEntry, RefMut};\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_into_mut() {\n        let mut map: IndexMapCore<&str, i32> = IndexMapCore::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        \n        let entry = IndexedEntry::new(&mut map, 0);\n        let value_ref: &mut i32 = entry.into_mut();\n        \n        *value_ref = 10;  // Update value through mutable reference\n        \n        assert_eq!(map.get(\"key1\"), Some(&10));\n        assert_eq!(map.get(\"key2\"), Some(&2));\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::IndexedEntry;\n    use crate::map::core::IndexMapCore;\n\n    #[test]\n    fn test_key() {\n        // Setup test data\n        let mut map = IndexMapCore::new();\n        map.insert(\"test_key\", \"test_value\");\n\n        // Create an IndexedEntry\n        let entry = IndexedEntry::new(&mut map, 0);\n\n        // Test the key method\n        assert_eq!(entry.key(), &\"test_key\");\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::key_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::entry::IndexedEntry; // Adjust this path according to your actual crate structure\n    use map::core::index_map::IndexMapCore; // Adjust as necessary to your actual structure\n    use map::mutable::OccupiedEntry; // Adjust as necessary to your actual structure\n\n    #[test]\n    fn test_key_mut() {\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        map.insert(1, \"one\".to_string());\n        map.insert(2, \"two\".to_string());\n\n        let mut entry: IndexedEntry<i32, String> = IndexedEntry::new(&mut map, 0);\n        assert_eq!(entry.key_mut(), &mut 1);\n        *entry.key_mut() = 3; // change the key\n\n        // Verify that the key was changed\n        assert_eq!(entry.key(), &3);\n        assert_eq!(map.get(&3), Some(&\"one\".to_string()));\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::move_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::IndexMap; // Adjust the import path based on your crate structure\n    use crate::map::core::entry::IndexedEntry; // Adjust the import path accordingly\n    \n    #[test]\n    fn test_move_index() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut entry_a = map.get_index_entry(0).unwrap();\n        entry_a.move_index(2); // Move \"a\" from index 0 to index 2\n\n        // Verify the new order\n        let keys: Vec<&str> = map.keys().collect();\n        assert_eq!(keys, vec![\"b\", \"c\", \"a\"]); // \"a\" is now last\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_move_index_out_of_bounds() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n\n        let mut entry_a = map.get_index_entry(0).unwrap();\n        entry_a.move_index(3); // This should panic\n    }\n\n    #[test]\n    fn test_move_index_to_same_index() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        \n        let mut entry_a = map.get_index_entry(0).unwrap();\n        entry_a.move_index(0); // Move \"a\" to the same index\n\n        // Verify the order remains the same\n        let keys: Vec<&str> = map.keys().collect();\n        assert_eq!(keys, vec![\"a\", \"b\"]); // Order should remain unchanged\n    }\n\n    #[test]\n    fn test_move_index_shift_up() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut entry_b = map.get_index_entry(1).unwrap();\n        entry_b.move_index(0); // Move \"b\" from index 1 to index 0\n\n        // Verify the new order\n        let keys: Vec<&str> = map.keys().collect();\n        assert_eq!(keys, vec![\"b\", \"a\", \"c\"]); // \"b\" is now first\n    }\n\n    #[test]\n    fn test_move_index_shift_down() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut entry_a = map.get_index_entry(0).unwrap();\n        entry_a.move_index(2); // Move \"a\" from index 0 to index 2\n\n        // Verify the new order\n        let keys: Vec<&str> = map.keys().collect();\n        assert_eq!(keys, vec![\"b\", \"c\", \"a\"]); // \"a\" is now last\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::{IndexMapCore, RefMut};\n    \n    #[test]\n    fn test_indexed_entry_new() {\n        let mut map = IndexMapCore::new();\n        let index = 0;\n\n        let entry = IndexedEntry::new(&mut map, index);\n\n        assert_eq!(entry.index(), index);\n        assert_eq!(entry.map.entries.len(), 0);\n    }\n\n    #[test]\n    fn test_indexed_entry_new_with_existing_entries() {\n        let mut map = IndexMapCore::with_capacity(1);\n        map.entries.push(Bucket { hash: HashValue::default(), key: \"key\", value: \"value\" });\n        let index = 0;\n\n        let entry = IndexedEntry::new(&mut map, index);\n\n        assert_eq!(entry.index(), index);\n        assert_eq!(entry.key(), &\"key\");\n        assert_eq!(entry.get(), &\"value\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_indexed_entry_new_with_invalid_index() {\n        let mut map = IndexMapCore::with_capacity(1);\n        let index = 1; // index out of bounds\n\n        IndexedEntry::new(&mut map, index);\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::shift_remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::{IndexedEntry, RefMut};\n    use crate::map::core::IndexMapCore;  // Assuming there's an IndexMapCore struct to use in tests\n    use crate::map::mutable::OccupiedEntry; // Assuming there's an OccupiedEntry to create IndexedEntry\n\n    #[test]\n    fn test_shift_remove() {\n        // Setup an IndexMapCore and filled it with some entries\n        let mut map: IndexMapCore<i32, String> = IndexMapCore::new();\n        map.insert(1, \"One\".to_string());\n        map.insert(2, \"Two\".to_string());\n        map.insert(3, \"Three\".to_string());\n\n        // Get an IndexedEntry for the key 2\n        let entry: IndexedEntry<i32, String> = IndexedEntry::new(&mut map, 1); // Index for key 2\n\n        // Remove the entry\n        let removed_value = entry.shift_remove();\n\n        // Check that the removed value is correct\n        assert_eq!(removed_value, \"Two\".to_string());\n\n        // Check that the map has the correct state\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&1).is_some());\n        assert!(map.get(&3).is_some());\n        assert!(map.get(&2).is_none());\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::shift_remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_entry() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let entry = map.get_index_entry(1).unwrap();\n        let (key, value) = entry.shift_remove_entry();\n\n        assert_eq!(key, \"b\");\n        assert_eq!(value, 2);\n        assert_eq!(map.len(), 2);\n        assert!(map.get(\"b\").is_none());\n        assert_eq!(map.get(\"a\").unwrap(), &1);\n        assert_eq!(map.get(\"c\").unwrap(), &3);\n    }\n\n    #[test]\n    fn test_shift_remove_entry_when_empty() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n\n        let entry = map.get_index_entry(0);\n        assert!(entry.is_none());\n    }\n\n    #[test]\n    fn test_shift_remove_entry_first_element() {\n        let mut map = IndexMap::new();\n        map.insert(\"x\", 10);\n        map.insert(\"y\", 20);\n        map.insert(\"z\", 30);\n\n        let entry = map.get_index_entry(0).unwrap();\n        let (key, value) = entry.shift_remove_entry();\n\n        assert_eq!(key, \"x\");\n        assert_eq!(value, 10);\n        assert_eq!(map.len(), 2);\n        assert!(map.get(\"x\").is_none());\n        assert_eq!(map.get(\"y\").unwrap(), &20);\n        assert_eq!(map.get(\"z\").unwrap(), &30);\n    }\n\n    #[test]\n    fn test_shift_remove_entry_last_element() {\n        let mut map = IndexMap::new();\n        map.insert(\"m\", 100);\n        map.insert(\"n\", 200);\n\n        let entry = map.get_index_entry(1).unwrap();\n        let (key, value) = entry.shift_remove_entry();\n\n        assert_eq!(key, \"n\");\n        assert_eq!(value, 200);\n        assert_eq!(map.len(), 1);\n        assert!(map.get(\"n\").is_none());\n        assert_eq!(map.get(\"m\").unwrap(), &100);\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::swap_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::IndexMapCore;\n    use crate::map::core::entry::{IndexedEntry, RefMut};\n    use crate::map::mutable::OccupiedEntry;\n    \n    #[test]\n    fn test_swap_indices() {\n        let mut map: IndexMapCore<i32, &str> = IndexMapCore::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let entry_a = IndexedEntry::new(&mut map, 0); // entry for key 1\n        let entry_b = IndexedEntry::new(&mut map, 1); // entry for key 2\n\n        entry_a.swap_indices(1); // swap entry 1 and entry 2\n\n        assert_eq!(map.entries[0].key, 2);\n        assert_eq!(map.entries[0].value, \"b\");\n        assert_eq!(map.entries[1].key, 1);\n        assert_eq!(map.entries[1].value, \"a\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"indices not found\")]\n    fn test_swap_indices_out_of_bounds() {\n        let mut map: IndexMapCore<i32, &str> = IndexMapCore::new();\n        map.insert(1, \"a\");\n\n        let entry_a = IndexedEntry::new(&mut map, 0); // entry for key 1\n\n        entry_a.swap_indices(1); // swap with an out-of-bounds index\n    }\n\n    #[test]\n    fn test_swap_indices_no_op() {\n        let mut map: IndexMapCore<i32, &str> = IndexMapCore::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let entry = IndexedEntry::new(&mut map, 0); // entry for key 1\n        entry.swap_indices(0); // swap with itself\n\n        assert_eq!(map.entries[0].key, 1);\n        assert_eq!(map.entries[0].value, \"a\");\n        assert_eq!(map.entries[1].key, 2);\n        assert_eq!(map.entries[1].value, \"b\");\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::swap_remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Ensure to import the necessary items\n    use crate::map::core::{IndexMapCore, entry::IndexedEntry};\n\n    #[test]\n    fn test_swap_remove() {\n        let mut map = IndexMapCore::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        map.insert(\"key3\", \"value3\");\n\n        let entry = IndexedEntry::new(&mut map, 1);\n        let removed_value = entry.swap_remove();\n\n        assert_eq!(removed_value, \"value2\");\n        assert_eq!(map.len(), 2);\n        assert!(map.get(\"key2\").is_none());\n        assert_eq!(map.get(\"key1\").unwrap(), \"value1\");\n        assert_eq!(map.get(\"key3\").unwrap(), \"value3\");\n    }\n\n    #[test]\n    fn test_swap_remove_last_element() {\n        let mut map = IndexMapCore::new();\n        map.insert(\"key1\", \"value1\");\n\n        let entry = IndexedEntry::new(&mut map, 0);\n        let removed_value = entry.swap_remove();\n\n        assert_eq!(removed_value, \"value1\");\n        assert_eq!(map.len(), 0);\n        assert!(map.get(\"key1\").is_none());\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_swap_remove_out_of_bounds() {\n        let mut map = IndexMapCore::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let entry = IndexedEntry::new(&mut map, 2); // Invalid index\n        entry.swap_remove();\n    }\n}\n```", "map::core::entry::IndexedEntry::<'a, K, V>::swap_remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::IndexMapCore;\n\n    #[test]\n    fn test_swap_remove_entry() {\n        let mut map: IndexMapCore<&str, i32> = IndexMapCore::new();\n        let index = map.insert_unique(1, \"a\", 10).index();\n        let indexed_entry = IndexedEntry::new(&mut map, index);\n\n        let (key, value) = indexed_entry.swap_remove_entry();\n\n        assert_eq!(key, \"a\");\n        assert_eq!(value, 10);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_swap_remove_entry_multiple() {\n        let mut map: IndexMapCore<&str, i32> = IndexMapCore::new();\n        map.insert_unique(1, \"a\", 10);\n        map.insert_unique(1, \"b\", 20);\n        map.insert_unique(1, \"c\", 30);\n\n        let index = 1; // Index of \"b\"\n        let indexed_entry = IndexedEntry::new(&mut map, index);\n        \n        let (key, value) = indexed_entry.swap_remove_entry();\n\n        assert_eq!(key, \"b\");\n        assert_eq!(value, 20);\n        assert_eq!(map.len(), 2);\n        assert!(map.get(\"b\").is_none());\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get() {\n        let mut map: IndexMap<String, i32> = IndexMap::new();\n        map.insert(\"a\".to_string(), 1);\n        map.insert(\"b\".to_string(), 2);\n\n        let entry = map.entry(\"a\".to_string()).or_insert(0);\n        let occupied_entry = OccupiedEntry::new(&mut map.entries, entry);\n        \n        assert_eq!(*occupied_entry.get(), 1);\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_mut() {\n        let mut map = IndexMap::new();\n        map.insert(\"key\", 42);\n\n        let entry = map.entry(\"key\").or_insert(0);\n        let mut occupied_entry = OccupiedEntry::new(&mut map.entries, entry);\n        \n        // Obtain a mutable reference to the value\n        let value_mut = occupied_entry.get_mut();\n        \n        // Modify the value through the mutable reference\n        *value_mut += 1;\n\n        // Assert that the value has been updated\n        assert_eq!(*value_mut, 43);\n        assert_eq!(occupied_entry.get(), &43);\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let mut entry = OccupiedEntry::new(\n            &mut map.entries,\n            map.indices.find_entry(0).unwrap(),\n        );\n\n        assert_eq!(entry.index(), 0); // index of \"key1\"\n        \n        entry = OccupiedEntry::new(\n            &mut map.entries,\n            map.indices.find_entry(1).unwrap(),\n        );\n\n        assert_eq!(entry.index(), 1); // index of \"key2\"\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_insert_updates_value_and_returns_old_value() {\n        let mut map = IndexMap::new();\n        map.insert(\"key\", 42);\n        \n        let entry = map.entry(\"key\").or_insert(0);\n        let old_value = entry.insert(100);\n        \n        assert_eq!(old_value, 42);\n        assert_eq!(entry.get(), &100);\n    }\n\n    #[test]\n    fn test_insert_replaces_previous_value() {\n        let mut map = IndexMap::new();\n        map.insert(\"key\", \"old_value\");\n\n        let entry = map.entry(\"key\").or_insert(\"default_value\");\n        let old_value = entry.insert(\"new_value\");\n        \n        assert_eq!(old_value, \"old_value\");\n        assert_eq!(entry.get(), &\"new_value\");\n    }\n\n    #[test]\n    fn test_insert_with_no_previous_entry() {\n        let mut map = IndexMap::new();\n        \n        let entry = map.entry(\"new_key\").or_insert(\"default_value\");\n        let old_value = entry.insert(\"inserted_value\");\n        \n        assert_eq!(old_value, \"default_value\");\n        assert_eq!(entry.get(), &\"inserted_value\");\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::into_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_mut() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"key\", 42);\n        \n        let entry = map.entry(\"key\").or_insert(0);\n        let mut entry_mut = OccupiedEntry::new(&mut map.entries, entry.index());\n\n        let value_mut: &mut i32 = entry_mut.into_mut();\n        *value_mut += 1;\n\n        assert_eq!(*value_mut, 43);\n        assert_eq!(map.get(\"key\").unwrap(), &43);\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::into_muts": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::indexmap::{IndexMap, OccupiedEntry};\n\n    #[test]\n    fn test_into_muts() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let entry = map.entry(1).or_insert(10);\n        let occupied_entry: OccupiedEntry<i32, i32> = OccupiedEntry::from(entry);\n        \n        let (key_mut, value_mut) = occupied_entry.into_muts();\n        *key_mut = 5;\n        *value_mut = 50;\n        \n        assert_eq!(map.get(&5), Some(&50));\n        assert_eq!(map.get(&1), None);\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::into_ref_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::OccupiedEntry;\n    use crate::map::core::{Indices, Entries}; // Adjust these paths as necessary\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_into_ref_mut() {\n        // Setup test data\n        let mut entries = Entries::new(); // Implement/create Entries as required\n        let mut indices = Indices::new(); // Implement/create Indices as required\n\n        // Fill entries with some test data\n        entries.push(Bucket { hash: 0, key: \"key1\", value: \"value1\" });\n        let index = indices.insert_unique(0, 0, |i| i);\n        \n        let occupied_entry = OccupiedEntry::new(&mut entries, index);\n\n        // Use the method\n        let ref_mut = occupied_entry.into_ref_mut();\n\n        // Assert the internal mutable references are as expected\n        assert_eq!(ref_mut.entries.get(0).key, \"key1\");\n        assert_eq!(ref_mut.entries.get(0).value, \"value1\");\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_key() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"key1\", 1);\n        let occupied_entry = map.entry(\"key1\").or_insert(0);\n        let key = occupied_entry.key();\n        assert_eq!(*key, \"key1\");\n    }\n\n    #[test]\n    fn test_key_different_key_type() {\n        let mut map: IndexMap<(i32, i32), i32> = IndexMap::new();\n        map.insert((1, 2), 2);\n        let occupied_entry = map.entry((1, 2)).or_insert(0);\n        let key = occupied_entry.key();\n        assert_eq!(*key, (1, 2));\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::key_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_key_mut() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n\n        let mut entry = map.entry(\"key1\").or_insert(0);\n        let entry = OccupiedEntry::new(&mut map.entries, entry);\n\n        let key_mut = entry.key_mut();\n        *key_mut = \"new_key1\";\n\n        assert_eq!(entry.key(), &\"new_key1\");\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::move_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_move_index_for_lower_index() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut entry = map.entry(\"b\").or_insert(2);\n        let initial_index = entry.index();\n        entry.move_index(0);\n        \n        assert_eq!(map.keys().collect::<Vec<_>>(), [\"b\", \"a\", \"c\"]);\n        assert_eq!(entry.index(), 0);\n        assert!(initial_index > 0);\n    }\n\n    #[test]\n    fn test_move_index_for_higher_index() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut entry = map.entry(\"a\").or_insert(1);\n        let initial_index = entry.index();\n        entry.move_index(2);\n        \n        assert_eq!(map.keys().collect::<Vec<_>>(), [\"b\", \"c\", \"a\"]);\n        assert_eq!(entry.index(), 2);\n        assert!(initial_index < 2);\n    }\n    \n    #[test]\n    #[should_panic]\n    fn test_move_index_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        let entry = map.entry(\"a\").or_insert(1);\n        entry.move_index(1); // Out of bounds, should panic\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use map::core::entry::OccupiedEntry;\n    use map::core::Entries;\n    use hash_table::OccupiedEntry as HashOccupiedEntry;\n\n    #[test]\n    fn test_occupied_entry_new() {\n        let mut entries = // Initialize your Entries<K, V> here\n        let index = // Create an instance of hash_table::OccupiedEntry<'a, usize> here\n\n        let occupied_entry = OccupiedEntry::new(&mut entries, index);\n\n        // Check the correctness of the created OccupiedEntry\n        assert_eq!(occupied_entry.index(), index.get());\n        assert_eq!(occupied_entry.key(), /* expected key reference */);\n        assert_eq!(occupied_entry.get(), /* expected value reference */);\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_remove() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let occupied_entry = map.entry(\"key1\").or_insert(\"default\");\n        let value = occupied_entry.remove();\n\n        assert_eq!(value, \"value1\");\n        assert!(map.get(\"key1\").is_none());\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(\"key2\"), Some(&\"value2\"));\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_remove_entry() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        \n        // Get an occupied entry\n        let entry = map.entry(\"key2\").or_insert(0);\n        let (key, value) = entry.remove_entry();\n        \n        assert_eq!(key, \"key2\");\n        assert_eq!(value, 2);\n        assert!(!map.contains_key(\"key2\"));\n        assert_eq!(map.len(), 1);\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::shift_remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let entry = map.entry(\"b\").or_insert(0);\n        let value = entry.shift_remove();\n\n        assert_eq!(value, 2);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(\"a\"), Some(&1));\n        assert_eq!(map.get(\"c\"), Some(&3));\n        assert_eq!(map.get(\"b\"), None);\n    }\n\n    #[test]\n    fn test_shift_remove_first_element() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let entry = map.entry(\"a\").or_insert(0);\n        let value = entry.shift_remove();\n\n        assert_eq!(value, 1);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(\"b\"), Some(&2));\n        assert_eq!(map.get(\"c\"), Some(&3));\n        assert_eq!(map.get(\"a\"), None);\n    }\n\n    #[test]\n    fn test_shift_remove_last_element() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let entry = map.entry(\"c\").or_insert(0);\n        let value = entry.shift_remove();\n\n        assert_eq!(value, 3);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(\"a\"), Some(&1));\n        assert_eq!(map.get(\"b\"), Some(&2));\n        assert_eq!(map.get(\"c\"), None);\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::shift_remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_entry() {\n        let mut map: IndexMap<_, _> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut entry = map.entry(\"b\").or_insert(0);\n        let (key, value) = entry.shift_remove_entry();\n        \n        assert_eq!(key, \"b\");\n        assert_eq!(value, 2);\n        assert_eq!(map.len(), 2);\n        assert!(map.contains_key(\"a\"));\n        assert!(map.contains_key(\"c\"));\n        assert!(!map.contains_key(\"b\"));\n    }\n\n    #[test]\n    fn test_shift_remove_entry_preserves_order() {\n        let mut map: IndexMap<_, _> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        map.entry(\"a\").or_insert(0).shift_remove_entry();\n        \n        assert_eq!(map.keys().collect::<Vec<_>>(), vec![\"b\", \"c\"]);\n        assert_eq!(map[\"b\"], 2);\n        assert_eq!(map[\"c\"], 3);\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::swap_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_indices() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        let entry1 = map.entry(1).or_insert(10);\n        let entry2 = map.entry(3).or_insert(30);\n\n        // Initial state\n        assert_eq!(map.keys().collect::<Vec<_>>(), vec![&1, &2, &3]);\n\n        // Swap indices (0, 2)\n        entry1.swap_indices(2);\n\n        // After swap\n        assert_eq!(map.keys().collect::<Vec<_>>(), vec![&3, &2, &1]);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_swap_indices_out_of_bounds() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        let entry = map.entry(1).or_insert(10);\n\n        // Attempt to swap with out of bounds index\n        entry.swap_indices(1);\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::swap_remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_remove() {\n        // Setup\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        // Creating an OccupiedEntry for the key \"b\"\n        let entry = map.get_entry(\"b\").expect(\"Entry should exist\").to_occupied();\n\n        // Swap remove the entry\n        let value = entry.swap_remove();\n\n        // Assertions\n        assert_eq!(value, 2);\n        assert!(!map.contains_key(\"b\"));\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(\"a\"), Some(&1));\n        assert_eq!(map.get(\"c\"), Some(&3));\n    }\n\n    #[test]\n    fn test_swap_remove_last_entry() {\n        // Setup\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        \n        // Creating an OccupiedEntry for the key \"a\"\n        let entry = map.get_entry(\"a\").expect(\"Entry should exist\").to_occupied();\n\n        // Swap remove the entry\n        let value = entry.swap_remove();\n\n        // Assertions\n        assert_eq!(value, 1);\n        assert!(!map.contains_key(\"a\"));\n        assert_eq!(map.len(), 0);\n    }\n}\n```", "map::core::entry::OccupiedEntry::<'a, K, V>::swap_remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_remove_entry() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        {\n            let entry = map.get_mut(&2).unwrap();\n            let (key, value) = entry.swap_remove_entry();\n            assert_eq!(key, 2);\n            assert_eq!(value, \"two\");\n            assert_eq!(map.len(), 2);\n        }\n\n        assert!(map.get(&2).is_none());\n        assert_eq!(map.get(&1).unwrap(), &\"one\");\n        assert_eq!(map.get(&3).unwrap(), &\"three\");\n    }\n\n    #[test]\n    fn test_swap_remove_entry_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n\n        let result = map.get_mut(&1).map(|entry| entry.swap_remove_entry());\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_swap_remove_entry_last_element() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        \n        {\n            let entry = map.get_mut(&1).unwrap();\n            let (key, value) = entry.swap_remove_entry();\n            assert_eq!(key, 1);\n            assert_eq!(value, \"one\");\n            assert_eq!(map.len(), 0);\n        }\n\n        assert!(map.get(&1).is_none());\n    }\n}\n```", "map::core::entry::VacantEntry::<'a, K, V>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::VacantEntry;\n\n    #[test]\n    fn test_index() {\n        let mut indices = Indices::new(); // Assume indices can be initialized\n        let mut entries = Entries::new(); // Assume entries can be initialized\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n        \n        // Initialize a VacantEntry\n        let key = \"test_key\";\n        let hash = HashValue(42);\n        let vacant_entry = VacantEntry { map: ref_mut, hash, key };\n\n        // Test initial index\n        assert_eq!(vacant_entry.index(), 0); // Assumes indices is empty\n\n        // Simulate insertion\n        entries.push(Bucket { hash, key, value: \"test_value\" });\n        indices.push(0); // Simulate increasing index\n\n        // Test index after insertion\n        assert_eq!(vacant_entry.index(), 1);\n    }\n}\n```", "map::core::entry::VacantEntry::<'a, K, V>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_insert() {\n        let mut map: HashMap<HashValue, usize> = HashMap::new();\n        let key = HashValue(1);\n        let value = 10;\n\n        let vacant_entry = VacantEntry {\n            map: RefMut::new(&mut map),\n            hash: key,\n            key: key,\n        };\n\n        let result = vacant_entry.insert(value);\n        assert_eq!(*result, 10);\n        assert_eq!(map.len(), 1);\n        assert!(map.contains_key(&key));\n        assert_eq!(map[&key], 10);\n    }\n\n    #[test]\n    fn test_insert_multiple() {\n        let mut map: HashMap<HashValue, usize> = HashMap::new();\n        \n        for i in 1..=5 {\n            let key = HashValue(i);\n            let value = i * 10;\n\n            let vacant_entry = VacantEntry {\n                map: RefMut::new(&mut map),\n                hash: key,\n                key: key,\n            };\n\n            let result = vacant_entry.insert(value);\n            assert_eq!(*result, value);\n        }\n\n        assert_eq!(map.len(), 5);\n        for i in 1..=5 {\n            let key = HashValue(i);\n            assert_eq!(map[&key], i * 10);\n        }\n    }\n}\n```", "map::core::entry::VacantEntry::<'a, K, V>::insert_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::{VacantEntry, OccupiedEntry};\n    use crate::map::core::RefMut;\n    \n    #[test]\n    fn test_insert_entry() {\n        // Setup a test index map\n        let map = RefMut::new(/* initialize indices and entries */);\n\n        let key = /* some key */;\n        let value = /* some value */;\n        let hash_value = HashValue(/* hash calculation */);\n        let vacant_entry = VacantEntry {\n            map,\n            hash: hash_value,\n            key,\n        };\n\n        // Insert value and get occupied entry\n        let occupied_entry: OccupiedEntry<_, _> = vacant_entry.insert_entry(value);\n\n        // Verify that the entry is now occupied\n        assert_eq!(occupied_entry.key(), /* expected key reference */);\n        assert_eq!(occupied_entry.get(), /* expected value reference */);\n    }\n}\n```", "map::core::entry::VacantEntry::<'a, K, V>::insert_sorted": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_insert_sorted() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n\n        let key = 2;\n        let value = \"two\".to_string();\n\n        let mut vacant_entry = VacantEntry {\n            map: RefMut::new(&mut Indices::new(), &mut Entries::new()),\n            hash: HashValue(0),\n            key,\n        };\n\n        let (index, value_ref) = vacant_entry.insert_sorted(value.clone());\n        \n        assert_eq!(index, 0);\n        assert_eq!(value_ref, &mut value);\n        \n        let (index, value_ref) = vacant_entry.insert_sorted(\"three\".to_string());\n        \n        assert_eq!(index, 1);\n        assert_eq!(value_ref, &mut \"three\".to_string());\n        \n        // Check if values are as expected\n        assert_eq!(map.get(&2).unwrap(), \"two\");\n        assert_eq!(map.get(&3).unwrap(), \"three\");\n    }\n}\n```", "map::core::entry::VacantEntry::<'a, K, V>::into_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::VacantEntry;\n\n    #[test]\n    fn test_into_key() {\n        let key = HashValue(42);\n        let value = \"test_value\";\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n        \n        let vacant_entry = VacantEntry {\n            map: ref_mut,\n            hash: key,\n            key: HashValue(100),\n        };\n\n        let extracted_key = vacant_entry.into_key();\n        \n        assert_eq!(extracted_key, HashValue(100));\n    }\n}\n```", "map::core::entry::VacantEntry::<'a, K, V>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::VacantEntry;\n    use crate::map::core::RefMut;\n    use crate::map::core::HashValue;\n\n    #[test]\n    fn test_vacant_entry_key() {\n        // Setup a mock structure for testing\n        struct TestMap {\n            indices: Vec<usize>,\n            entries: Vec<Bucket<HashValue, String, String>>,\n        }\n\n        impl TestMap {\n            fn new() -> Self {\n                Self {\n                    indices: Vec::new(),\n                    entries: Vec::new(),\n                }\n            }\n\n            fn insert_vacant_entry(&mut self, key: String, value: String) -> VacantEntry<HashValue, String, String> {\n                let hash = HashValue(key.len()); // Simple hash for testing\n                self.entries.push(Bucket {\n                    hash: hash.clone(),\n                    key: key.clone(),\n                    value: value.clone(),\n                });\n                VacantEntry {\n                    map: RefMut::new(&mut self.indices, &mut self.entries), // Mock RefMut\n                    hash,\n                    key,\n                }\n            }\n        }\n\n        let mut test_map = TestMap::new();\n        let key = String::from(\"test_key\");\n        let value = String::from(\"test_value\");\n        let vacant_entry = test_map.insert_vacant_entry(key.clone(), value.clone());\n\n        // Test the `key` method\n        assert_eq!(vacant_entry.key(), &key);\n    }\n}\n```", "map::core::entry::VacantEntry::<'a, K, V>::key_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::VacantEntry;\n\n    #[test]\n    fn test_key_mut() {\n        let key = HashValue(42);\n        let key_value = 5;\n        let mut map = RefMut::new(/*indices, entries*/);\n        let mut entry = VacantEntry {\n            map,\n            hash: key,\n            key: key_value,\n        };\n\n        // Ensure the mutable reference returns the correct key\n        let key_mut_ref = entry.key_mut();\n        *key_mut_ref = 10;\n\n        // Check if the key has been updated\n        assert_eq!(entry.key(), &10);\n    }\n}\n```", "map::core::entry::VacantEntry::<'a, K, V>::shift_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::entry::VacantEntry;\n    use crate::map::core::RefMut;\n    use crate::HashValue;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    #[test]\n    fn test_shift_insert_within_bounds() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let map = RefMut::new(&mut indices, &mut entries);\n        let hash = HashValue(1);\n        let key = \"test_key\";\n\n        let vacant_entry = VacantEntry { map, hash, key };\n\n        let value = 42;\n        let mutable_ref = vacant_entry.shift_insert(0, value);\n\n        assert_eq!(*mutable_ref, value);\n        assert_eq!(entries.len(), 1);\n        assert_eq!(entries[0].value, value);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_shift_insert_out_of_bounds() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let map = RefMut::new(&mut indices, &mut entries);\n        let hash = HashValue(1);\n        let key = \"test_key\";\n\n        let vacant_entry = VacantEntry { map, hash, key };\n\n        // Insert at an out-of-bounds index\n        vacant_entry.shift_insert(1, 100);\n    }\n\n    #[test]\n    fn test_shift_insert_with_multiple_entries() {\n        let mut indices = Indices::new();\n        let mut entries = Entries::new();\n        let map = RefMut::new(&mut indices, &mut entries);\n        let hash1 = HashValue(1);\n        let key1 = \"key1\";\n        let hash2 = HashValue(2);\n        let key2 = \"key2\";\n\n        let vacant_entry1 = VacantEntry { map, hash: hash1, key: key1 };\n        vacant_entry1.shift_insert(0, 10);\n\n        let vacant_entry2 = VacantEntry { map, hash: hash2, key: key2 };\n        let mutable_ref = vacant_entry2.shift_insert(0, 20);\n\n        assert_eq!(*mutable_ref, 20);\n        assert_eq!(entries.len(), 2);\n        assert_eq!(entries[0].value, 20); // new entry\n        assert_eq!(entries[1].value, 10); // shifted entry\n    }\n}\n```", "map::core::equivalent": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashSet;\n\n    struct TestKey;\n    struct TestEquivalent;\n\n    impl Equivalent<TestKey> for TestEquivalent {\n        fn equivalent(a: &TestKey, b: &TestKey) -> bool {\n            true // or implement your equivalence logic\n        }\n    }\n\n    #[test]\n    fn test_equivalent() {\n        let key1 = TestKey;\n        let key2 = TestKey;\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: key1,\n            value: \"Value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: key2,\n            value: \"Value2\",\n        };\n        let entries = vec![bucket1, bucket2];\n\n        let eq_fn = equivalent(&TestEquivalent, &entries);\n        assert!(eq_fn(&0)); // Test equivalent for bucket1\n        assert!(eq_fn(&1)); // Test equivalent for bucket2\n    }\n}\n```", "map::core::erase_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::erase_index;\n    use crate::map::core::Indices;\n\n    #[test]\n    fn test_erase_index_removes_existing_entry() {\n        let mut table = Indices::new();\n        let hash = HashValue(42);\n        let index = 0;\n\n        // Assume a method `insert` exists to add entries to `Indices` for test setup\n        table.insert(hash.get(), index); // Add an entry with hash and index\n\n        erase_index(&mut table, hash, index); // Call the function to test\n\n        // Check that the entry was removed\n        assert!(table.find_entry(hash.get(), |&i| i == index).is_err());\n    }\n\n    #[test]\n    #[should_panic(expected = \"index not found\")]\n    fn test_erase_index_panics_on_nonexistent_entry() {\n        let mut table = Indices::new();\n        let hash = HashValue(42);\n        let index = 0;\n\n        // This will panic as no entry exists for this hash and index\n        erase_index(&mut table, hash, index);\n    }\n}\n```", "map::core::get_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::Bucket;\n    use crate::map::core::HashValue;\n\n    #[test]\n    fn test_get_hash() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n            Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            Bucket { hash: HashValue(3), key: \"key3\", value: \"value3\" },\n        ];\n\n        let hash_function = get_hash(&entries);\n\n        assert_eq!(hash_function(&0), 1);\n        assert_eq!(hash_function(&1), 2);\n        assert_eq!(hash_function(&2), 3);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_get_hash_index_out_of_bounds() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n        ];\n\n        let hash_function = get_hash(&entries);\n        hash_function(&1); // This should panic\n    }\n}\n```", "map::core::insert_bulk_no_grow": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::insert_bulk_no_grow;\n\n    #[derive(Debug)]\n    struct Indices {\n        data: Vec<Bucket<i32, String>>,\n        capacity: usize,\n    }\n\n    impl Indices {\n        fn new(capacity: usize) -> Self {\n            Self {\n                data: Vec::with_capacity(capacity),\n                capacity,\n            }\n        }\n\n        fn capacity(&self) -> usize {\n            self.capacity\n        }\n\n        fn len(&self) -> usize {\n            self.data.len()\n        }\n\n        fn insert_unique(&mut self, _hash: u64, _index: usize, _f: impl FnOnce()) {\n            // Simplified insert for testing purposes\n            // Note: This should insert the item based on the hash\n            // For the purpose of the test, we'll just insert a placeholder\n            self.data.push(Bucket {\n                hash: HashValue(0),\n                key: 0,\n                value: \"Placeholder\".to_string(),\n            });\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_insert_bulk_no_grow_panics_when_insufficient_capacity() {\n        let mut indices = Indices::new(2);\n        let entries = vec![\n            Bucket { hash: HashValue(1), key: 1, value: \"one\".to_string() },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\".to_string() },\n            // This third entry should cause a panic\n            Bucket { hash: HashValue(3), key: 3, value: \"three\".to_string() },\n        ];\n        insert_bulk_no_grow(&mut indices, &entries);\n    }\n\n    #[test]\n    fn test_insert_bulk_no_grow_success() {\n        let mut indices = Indices::new(3);\n        let entries = vec![\n            Bucket { hash: HashValue(1), key: 1, value: \"one\".to_string() },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\".to_string() },\n        ];\n        insert_bulk_no_grow(&mut indices, &entries);\n        assert_eq!(indices.len(), 2);\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_from_hash_existing_key() {\n        let mut map: IndexMap<u64, &str> = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let result = map.raw_entry_v1().from_hash(1, |&key| key == 1);\n        assert_eq!(result, Some((&1, &\"a\")));\n    }\n\n    #[test]\n    fn test_from_hash_non_existent_key() {\n        let mut map: IndexMap<u64, &str> = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let result = map.raw_entry_v1().from_hash(3, |&key| key == 3);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_from_hash_with_matching_fn() {\n        let mut map: IndexMap<u64, &str> = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let result = map.raw_entry_v1().from_hash(2, |&key| key == 2);\n        assert_eq!(result, Some((&2, &\"b\")));\n    }\n\n    #[test]\n    fn test_from_hash_with_non_matching_fn() {\n        let mut map: IndexMap<u64, &str> = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let result = map.raw_entry_v1().from_hash(2, |&key| key == 1);\n        assert_eq!(result, None);\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_hash_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_from_hash_full_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let raw_entry = map.raw_entry_mut_v1();\n        let result = raw_entry.from_hash_full(1.hash(), |&key| key == &1);\n        \n        assert_eq!(result, Some((0, &1, &\"a\")));\n    }\n\n    #[test]\n    fn test_from_hash_full_non_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let raw_entry = map.raw_entry_mut_v1();\n        let result = raw_entry.from_hash_full(3.hash(), |&key| key == &3);\n        \n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_from_hash_full_match_function() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let raw_entry = map.raw_entry_mut_v1();\n        let result = raw_entry.from_hash_full(2.hash(), |&key| key == &2);\n        \n        assert_eq!(result, Some((1, &2, &\"b\")));\n    }\n\n    #[test]\n    fn test_from_hash_full_empty_map() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        \n        let raw_entry = map.raw_entry_mut_v1();\n        let result = raw_entry.from_hash_full(0.hash(), |&key| key == &0);\n        \n        assert!(result.is_none());\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use std::collections::hash_map::RandomState;\n    use std::hash::{Hash, Hasher};\n\n    #[test]\n    fn test_from_key_found() {\n        let mut map: IndexMap<i32, &str, RandomState> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        \n        let entry = map.raw_entry_v1().from_key(&1);\n        assert_eq!(entry, Some((&1, &\"one\")));\n    }\n\n    #[test]\n    fn test_from_key_not_found() {\n        let mut map: IndexMap<i32, &str, RandomState> = IndexMap::new();\n        map.insert(1, \"one\");\n        \n        let entry = map.raw_entry_v1().from_key(&2);\n        assert_eq!(entry, None);\n    }\n\n    #[test]\n    fn test_from_key_multiple_entries() {\n        let mut map: IndexMap<i32, &str, RandomState> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let entry = map.raw_entry_v1().from_key(&3);\n        assert_eq!(entry, Some((&3, &\"three\")));\n        \n        let entry = map.raw_entry_v1().from_key(&1);\n        assert_eq!(entry, Some((&1, &\"one\")));\n    }\n\n    #[test]\n    fn test_from_key_empty_map() {\n        let map: IndexMap<i32, &str, RandomState> = IndexMap::new();\n        let entry = map.raw_entry_v1().from_key(&1);\n        assert_eq!(entry, None);\n    }\n\n    #[test]\n    fn test_from_key_with_different_type() {\n        let mut map: IndexMap<String, &str, RandomState> = IndexMap::new();\n        map.insert(\"key\".to_string(), \"value\");\n\n        let entry = map.raw_entry_v1().from_key(&\"key\".to_string());\n        assert_eq!(entry, Some((&\"key\".to_string(), &\"value\")));\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_key_hashed_nocheck": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_from_key_hashed_nocheck() {\n        let mut index_map: IndexMap<u64, String> = IndexMap::new();\n        index_map.insert(1, \"one\".to_string());\n        index_map.insert(2, \"two\".to_string());\n        index_map.insert(3, \"three\".to_string());\n\n        let hash_value = index_map.hash(&1);\n        let result = index_map.raw_entry_v1().from_key_hashed_nocheck(hash_value, &1);\n\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), (&1, &\"one\".to_string()));\n\n        let result_none = index_map.raw_entry_v1().from_key_hashed_nocheck(hash_value, &4);\n        assert!(result_none.is_none());\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::index_from_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_from_hash_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        \n        let hash = map.hash(&\"key1\");\n        let result = map.raw_entry_v1().index_from_hash(hash.get().0, |key| *key == \"key1\");\n        \n        assert_eq!(result, Some(0));\n    }\n\n    #[test]\n    fn test_index_from_hash_non_existing_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let hash = map.hash(&\"non_existing_key\");\n        let result = map.raw_entry_v1().index_from_hash(hash.get().0, |key| *key == \"non_existing_key\");\n\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_index_from_hash_multiple_keys() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        map.insert(\"key3\", \"value3\");\n\n        let hash = map.hash(&\"key2\");\n        let result = map.raw_entry_v1().index_from_hash(hash.get().0, |key| *key == \"key2\");\n\n        assert_eq!(result, Some(1));\n    }\n\n    #[test]\n    fn test_index_from_hash_empty_map() {\n        let map: IndexMap<&str, &str> = IndexMap::new();\n        let result = map.raw_entry_v1().index_from_hash(0, |key| *key == \"key1\");\n\n        assert_eq!(result, None);\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::IndexMap;\n    use std::hash::BuildHasherDefault;\n    use std::collections::hash_map::DefaultHasher;\n\n    #[test]\n    fn test_from_hash_occupied() {\n        let mut map: IndexMap<u64, &str, BuildHasherDefault<DefaultHasher>> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let occupied_entry = map.raw_entry_mut_v1().from_hash(1, |&key| key == 1);\n        match occupied_entry {\n            RawEntryMut::Occupied(_) => assert!(true),\n            _ => assert!(false, \"Entry should be occupied\"),\n        }\n    }\n\n    #[test]\n    fn test_from_hash_vacant() {\n        let mut map: IndexMap<u64, &str, BuildHasherDefault<DefaultHasher>> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let vacant_entry = map.raw_entry_mut_v1().from_hash(3, |&key| key == 3);\n        match vacant_entry {\n            RawEntryMut::Vacant(_) => assert!(true),\n            _ => assert!(false, \"Entry should be vacant\"),\n        }\n    }\n\n    #[test]\n    fn test_from_hash_with_non_matching() {\n        let mut map: IndexMap<u64, &str, BuildHasherDefault<DefaultHasher>> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let vacant_entry = map.raw_entry_mut_v1().from_hash(10, |&key| key == 3);\n        match vacant_entry {\n            RawEntryMut::Vacant(_) => assert!(true),\n            _ => assert!(false, \"Entry should be vacant\"),\n        }\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use std::collections::hash_map::RandomState;\n    use std::hash::{Hash, Hasher};\n\n    #[derive(Hash, PartialEq, Eq)]\n    struct Key {\n        value: i32,\n    }\n\n    #[test]\n    fn test_from_key_existing() {\n        let mut map: IndexMap<Key, String, RandomState> = IndexMap::new();\n        map.insert(Key { value: 1 }, \"value1\".to_string());\n\n        let key = Key { value: 1 };\n        let entry = map.raw_entry_mut_v1().from_key(&key);\n        assert!(entry.is_occupied());\n        assert_eq!(entry.get().unwrap().1, \"value1\");\n    }\n\n    #[test]\n    fn test_from_key_non_existing() {\n        let mut map: IndexMap<Key, String, RandomState> = IndexMap::new();\n        map.insert(Key { value: 1 }, \"value1\".to_string());\n\n        let key = Key { value: 2 };\n        let entry = map.raw_entry_mut_v1().from_key(&key);\n        assert!(entry.is_vacant());\n    }\n\n    #[test]\n    fn test_from_key_empty_map() {\n        let map: IndexMap<Key, String, RandomState> = IndexMap::new();\n        let key = Key { value: 1 };\n        let entry = map.raw_entry_mut_v1().from_key(&key);\n        assert!(entry.is_vacant());\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_key_hashed_nocheck": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_from_key_hashed_nocheck() {\n        let mut map = IndexMap::new();\n        map.insert(\"key\", \"value\");\n        \n        let hash = map.hasher().build_hasher().finish() as u64; // hash the key\n        let key = \"key\";\n        \n        // Use `from_key_hashed_nocheck` to get the entry\n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n\n        // Ensure the entry is occupied\n        assert!(entry.is_occupied());\n        \n        // Ensure the value can be accessed and modified\n        let value_mut = entry.get_mut();\n        assert_eq!(*value_mut, \"value\");\n        *value_mut = \"new_value\";\n\n        // Check that the value was updated\n        assert_eq!(map.get(key), Some(&\"new_value\"));\n    }\n\n    #[test]\n    fn test_from_key_hashed_nocheck_nonexistent_key() {\n        let mut map = IndexMap::new();\n\n        let hash = 12345; // Some arbitrary hash\n        let key = \"nonexistent_key\";\n\n        // Use `from_key_hashed_nocheck` to get the entry for a key that doesn't exist\n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n\n        // Ensure the entry is vacant\n        assert!(entry.is_vacant());\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::and_modify": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_and_modify_occupied() {\n        let mut entries: HashMap<i32, i32> = HashMap::new();\n        entries.insert(1, 10);\n\n        let entry = RawEntryMut::Occupied(RawOccupiedEntryMut {\n            entries: &mut entries,\n            index: /* index for key 1 */,\n            hash_builder: PhantomData,\n        });\n\n        let modified_entry = entry.and_modify(|k, v| {\n            *v += 5; // Modify the value\n            *k += 1; // Modify the key\n        });\n\n        // Assert the expected changes\n        let (k, v) = modified_entry.get_key_value_mut();\n        assert_eq!(*k, 2);\n        assert_eq!(*v, 15);\n    }\n\n    #[test]\n    fn test_and_modify_vacant() {\n        let mut entries: HashMap<i32, i32> = HashMap::new();\n\n        let entry = RawEntryMut::Vacant(RawVacantEntryMut {\n            map: RefMut::new(/* indices */, &mut entries),\n            hash_builder: /* hash builder */,\n        });\n\n        let modified_entry = entry.and_modify(|_k, _v| {\n            // No modification should happen\n        });\n\n        // Assert that the entry is still vacant (no key-value should be present)\n        assert!(matches!(modified_entry, RawEntryMut::Vacant(_)));\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    #[test]\n    fn test_index_occupied() {\n        let mut entries: Vec<Bucket<i32, i32>> = vec![\n            Bucket { hash: HashValue(0), key: 1, value: 10 },\n            Bucket { hash: HashValue(1), key: 2, value: 20 },\n        ];\n        let index = std::collections::hash_map::OccupiedEntry::from_index(0);\n        let occupied_entry = RawOccupiedEntryMut { entries: &mut entries, index, hash_builder: PhantomData };\n        let raw_entry = RawEntryMut::Occupied(occupied_entry);\n        assert_eq!(raw_entry.index(), 0);\n    }\n\n    #[test]\n    fn test_index_vacant() {\n        let mut entries: Vec<Bucket<i32, i32>> = vec![\n            Bucket { hash: HashValue(0), key: 1, value: 10 },\n        ];\n        let ref_mut = RefMut::new(&mut Indices::new(), &mut entries);\n        let vacant_entry = RawVacantEntryMut { map: ref_mut, hash_builder: &DefaultHasher::new() };\n        let raw_entry = RawEntryMut::Vacant(vacant_entry);\n        assert_eq!(raw_entry.index(), 1);\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::or_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n    use std::hash::Hash;\n\n    #[test]\n    fn test_or_insert_vacant() {\n        let mut map = HashMap::new();\n        let mut entry = RawEntryMut::Vacant(RawVacantEntryMut {\n            map: RefMut::new(&mut Indices::new(), &mut Entries::new()),\n            hash_builder: &RandomState::new(),\n        });\n\n        let (key_ref, value_ref) = entry.or_insert(\"key\", \"value\");\n        assert_eq!(*key_ref, \"key\");\n        assert_eq!(*value_ref, \"value\");\n    }\n\n    #[test]\n    fn test_or_insert_occupied() {\n        let mut map: HashMap<&str, &str, RandomState> = HashMap::new();\n        map.insert(\"key\", \"value\");\n        let index_entry = map.get_mut(\"key\").unwrap();\n        let entry = RawEntryMut::Occupied(RawOccupiedEntryMut {\n            entries: &mut map,\n            index: index_entry,\n            hash_builder: PhantomData,\n        });\n\n        let (key_ref, value_ref) = entry.or_insert(\"new_key\", \"new_value\");\n        assert_eq!(*key_ref, \"key\");\n        assert_eq!(*value_ref, \"value\");\n    }\n\n    #[test]\n    fn test_or_insert_with() {\n        let mut map: HashMap<&str, &str, RandomState> = HashMap::new();\n        let mut entry = RawEntryMut::Vacant(RawVacantEntryMut {\n            map: RefMut::new(&mut Indices::new(), &mut Entries::new()),\n            hash_builder: &RandomState::new(),\n        });\n\n        let default_value = || (\"key\", \"value\");\n        let (key_ref, value_ref) = entry.or_insert_with(default_value);\n        assert_eq!(*key_ref, \"key\");\n        assert_eq!(*value_ref, \"value\");\n    }\n}\n```", "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::or_insert_with": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::BuildHasherDefault;\n    \n    type IndexMap<K, V> = IndexMap<RawEntryMut<K, V, BuildHasherDefault<DefaultHasher>>>;\n\n    #[test]\n    fn test_or_insert_with_vacant() {\n        let mut map = IndexMap::new();\n        let key = \"test_key\";\n        let value = \"test_value\";\n        \n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(key, 0);\n        let (k, v) = entry.or_insert_with(|| (key.to_string(), value.to_string()));\n        \n        assert_eq!(*k, \"test_key\".to_string());\n        assert_eq!(*v, \"test_value\".to_string());\n    }\n\n    #[test]\n    fn test_or_insert_with_occupied() {\n        let mut map = IndexMap::new();\n        let key = \"test_key\";\n        let value = \"initial_value\";\n        \n        map.insert(key.to_string(), value.to_string());\n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(key, 0);\n        \n        let (k, v) = entry.or_insert_with(|| (\"new_key\".to_string(), \"new_value\".to_string()));\n        \n        assert_eq!(*k, \"test_key\".to_string());\n        assert_eq!(*v, \"initial_value\".to_string());\n        assert_eq!(map.get(key), Some(&\"initial_value\".to_string()));\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        let entry = map.raw_entry_mut().from_key(\"key1\").unwrap();\n        let occupied_entry = entry.into_mut();\n\n        assert_eq!(occupied_entry.get(), &\"value1\");\n    }\n\n    #[test]\n    fn test_get_with_different_types() {\n        let mut map: IndexMap<u32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n        map.insert(2, \"two\".to_string());\n\n        let entry = map.raw_entry_mut().from_key(&1).unwrap();\n        let occupied_entry = entry.into_mut();\n\n        assert_eq!(occupied_entry.get(), &\"one\");\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_key_value": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_key_value() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        // Assuming we have a way to obtain a `RawOccupiedEntryMut`\n        let entry = map.get_full(\"key1\").unwrap().1;\n\n        let (key, value) = entry.get_key_value();\n        assert_eq!(key, &\"key1\");\n        assert_eq!(value, &\"value1\");\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_key_value_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_key_value_mut() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 1);\n        let mut entry = map.get_key_value_mut(\"key1\").unwrap();\n        \n        let (key, value) = entry.get_key_value_mut();\n        \n        assert_eq!(*key, \"key1\");\n        assert_eq!(*value, 1);\n        \n        *value = 2; // Modify value\n        assert_eq!(map.get(\"key1\").unwrap(), &2);\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_mut() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", 10);\n        map.insert(\"key2\", 20);\n        \n        let mut occupied_entry_mut = map.get_mut(\"key1\").expect(\"Entry should exist\");\n        let value = occupied_entry_mut.get_mut();\n        \n        assert_eq!(*value, 10);\n        *value = 15;  // Updating the value\n        assert_eq!(*map.get(\"key1\").unwrap(), 15);\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use std::hash::BuildHasherDefault;\n    use std::marker::PhantomData;\n\n    #[derive(Debug, PartialEq, Eq, Hash)]\n    struct TestKey(usize);\n    #[derive(Debug, PartialEq, Eq)]\n    struct TestValue(usize);\n\n    #[test]\n    fn test_index() {\n        let mut map: IndexMap<TestKey, TestValue, BuildHasherDefault<std::collections::hash_map::RandomState>> = IndexMap::new();\n        map.insert(TestKey(1), TestValue(100));\n        map.insert(TestKey(2), TestValue(200));\n\n        let index_entry = map.get_full(&TestKey(1)).unwrap().1;\n        let raw_entry = RawOccupiedEntryMut {\n            entries: &mut map.entries,\n            index: index_entry,\n            hash_builder: PhantomData,\n        };\n\n        assert_eq!(raw_entry.index(), 0);\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_insert() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        let mut entry = RawOccupiedEntryMut {\n            entries: &mut map.entries,\n            index: map.get_index(\"key1\").unwrap(),\n            hash_builder: PhantomData,\n        };\n        \n        let old_value = entry.insert(\"new_value1\");\n        assert_eq!(old_value, \"value1\");\n        assert_eq!(entry.get(), &\"new_value1\");\n    }\n    \n    #[test]\n    fn test_insert_multiple() {\n        let mut map = IndexMap::new();\n        map.insert(\"key2\", \"value2\");\n        let mut entry = RawOccupiedEntryMut {\n            entries: &mut map.entries,\n            index: map.get_index(\"key2\").unwrap(),\n            hash_builder: PhantomData,\n        };\n        \n        let old_value = entry.insert(\"new_value2\");\n        assert_eq!(old_value, \"value2\");\n        assert_eq!(entry.get(), &\"new_value2\");\n    }\n    \n    #[test]\n    fn test_insert_return_value() {\n        let mut map = IndexMap::new();\n        map.insert(\"key3\", \"value3\");\n        let mut entry = RawOccupiedEntryMut {\n            entries: &mut map.entries,\n            index: map.get_index(\"key3\").unwrap(),\n            hash_builder: PhantomData,\n        };\n        \n        let old_value = entry.insert(\"new_value3\");\n        assert_eq!(old_value, \"value3\");\n        assert_eq!(entry.get(), &\"new_value3\");\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::insert_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_insert_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"old_key\", \"value\");\n        \n        let index = map.get_index_of(\"old_key\").unwrap();\n        let mut entry = map.get_index_mut(index).unwrap();\n\n        let old_key = entry.insert_key(\"new_key\");\n        \n        assert_eq!(old_key, \"old_key\");\n        assert_eq!(entry.key(), &\"new_key\");\n        assert_eq!(map.get(\"new_key\"), Some(&\"value\"));\n    }\n\n    #[test]\n    fn test_insert_key_updates_key() {\n        let mut map = IndexMap::new();\n        map.insert(\"initial_key\", \"value\");\n        \n        let index = map.get_index_of(\"initial_key\").unwrap();\n        let mut entry = map.get_index_mut(index).unwrap();\n\n        let old_key = entry.insert_key(\"updated_key\");\n        \n        assert_eq!(old_key, \"initial_key\");\n        assert_eq!(entry.key(), &\"updated_key\");\n        assert!(map.get(\"initial_key\").is_none());\n        assert_eq!(map.get(\"updated_key\"), Some(&\"value\"));\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_key() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let entry = map.get_index_mut(&1).unwrap();\n        let mut occupied_entry_mut = RawOccupiedEntryMut {\n            entries: map.entries_mut(),\n            index: entry.index.clone(),\n            hash_builder: PhantomData,\n        };\n\n        let key_mut = occupied_entry_mut.into_key();\n        *key_mut = 10;\n\n        assert_eq!(*key_mut, 10);\n        assert_eq!(map.get(&10), Some(&\"a\"));\n        assert!(map.get(&1).is_none());\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_key_value_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_key_value_mut() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        \n        let index = map.get_index_of(\"key1\").unwrap();\n        let mut entry = RawOccupiedEntryMut {\n            entries: &mut map.entries, // Assuming map.entries is a mutable reference to the entries\n            index: hash_table::OccupiedEntry::new(index),\n            hash_builder: PhantomData,\n        };\n\n        let (key_mut, value_mut) = entry.into_key_value_mut();\n        *key_mut = \"new_key1\"; // change the key\n        *value_mut = \"new_value1\"; // change the value\n\n        assert_eq!(map.get(\"new_key1\"), Some(&\"new_value1\"));\n        assert!(map.get(\"key1\").is_none());\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_mut() {\n        let mut index_map: IndexMap<i32, String> = IndexMap::new();\n        index_map.insert(1, \"value1\".to_string());\n        index_map.insert(2, \"value2\".to_string());\n\n        let mut entry_mut = index_map.raw_entry_mut().from_key(&1).unwrap();\n        let value_mut: &mut String = entry_mut.into_mut();\n\n        // Modify the value through the mutable reference\n        value_mut.push_str(\"_modified\");\n\n        // Verify the value in the IndexMap has been updated\n        assert_eq!(index_map.get(&1).unwrap(), \"value1_modified\");\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_ref_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::core::raw_entry_v1::{RawOccupiedEntryMut, RefMut};\n    use crate::map::IndexMap; // Assuming you're using IndexMap\n\n    #[test]\n    fn test_into_ref_mut() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n        map.insert(2, \"two\".to_string());\n\n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(&1, 1);\n        let mut occupied_entry: RawOccupiedEntryMut<_, _, _> = entry.unwrap().1;\n\n        let ref_mut: RefMut<i32, String> = occupied_entry.into_ref_mut();\n        assert_eq!(ref_mut.indices.len(), map.len());\n        assert_eq!(ref_mut.entries.len(), map.len());\n        assert_eq!(ref_mut.entries[0].key, 1);\n        assert_eq!(ref_mut.entries[0].value, \"one\");\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_key() {\n        let mut map: IndexMap<u32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        \n        let mut entry = map.raw_entry_mut().get_key_value_mut();\n        entry.insert_key(2);\n        \n        let occupied_entry = RawOccupiedEntryMut {\n            entries: &mut map,\n            index: entry.index().clone(),\n            hash_builder: PhantomData,\n        };\n        \n        let key = occupied_entry.key();\n        assert_eq!(*key, 2);\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::key_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_key_mut() {\n        let mut map = IndexMap::new();\n        map.insert(\"key1\", \"value1\");\n\n        let mut entry = map.raw_entry_mut().take(\"key1\").unwrap();\n        let key_mut = entry.key_mut();\n        *key_mut = \"new_key1\";\n\n        assert_eq!(map.get_key_value(\"new_key1\"), Some(&\"value1\"));\n        assert_eq!(map.get_key_value(\"key1\"), None);\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::move_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_move_index() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        let mut entry = map.get_index_mut(1).unwrap(); // Entry for \"b\"\n\n        // Move index from 1 (for \"b\") to 2 (after \"c\")\n        entry.move_index(2);\n        assert_eq!(map.get_index(2).map(|(k, _)| k), Some(&\"b\"));\n        assert_eq!(map.get_index(1).map(|(k, _)| k), Some(&\"c\"));\n        \n        // Move index from 2 (for \"b\") to 0 (before \"a\")\n        entry.move_index(0);\n        assert_eq!(map.get_index(0).map(|(k, _)| k), Some(&\"b\"));\n        assert_eq!(map.get_index(1).map(|(k, _)| k), Some(&\"a\"));\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_move_index_out_of_bounds() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        let mut entry = map.get_index_mut(0).unwrap(); // Entry for \"a\"\n\n        // Attempt to move index out of bounds\n        entry.move_index(2);\n    }\n\n    #[test]\n    fn test_move_index_with_shifts() {\n        let mut map: IndexMap<&str, i32> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut entry = map.get_index_mut(0).unwrap(); // Entry for \"a\"\n\n        // Move index from 0 (for \"a\") to 1 (after \"b\")\n        entry.move_index(1);\n        assert_eq!(map.get_index(1).map(|(k, _)| k), Some(&\"a\"));\n        assert_eq!(map.get_index(2).map(|(k, _)| k), Some(&\"b\"));\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_remove() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let mut entry = map.get_index_mut(&2).unwrap();\n        let value = entry.remove();\n\n        assert_eq!(value, 20);\n        assert!(map.get(&2).is_none());\n        assert_eq!(map.len(), 2);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_remove_non_existent() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n\n        let entry = map.get_index_mut(&2);\n        assert!(entry.is_none());\n        // We can't get an entry for a non-existent key, so removing it should panic\n        entry.unwrap().remove();\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_remove_entry() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        \n        let mut entry = map.get_entry(&2).unwrap().remove_entry();\n        \n        assert_eq!(entry, (2, 20));\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&2).is_none());\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::shift_remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, String::from(\"one\"));\n        map.insert(2, String::from(\"two\"));\n        map.insert(3, String::from(\"three\"));\n        \n        let mut entry = map.get_full_mut(&2).unwrap();\n        let value = entry.shift_remove();\n        \n        assert_eq!(value, String::from(\"two\"));\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&2).is_none());\n        assert_eq!(map.get(&1).unwrap(), \"one\");\n        assert_eq!(map.get(&3).unwrap(), \"three\");\n    }\n\n    #[test]\n    fn test_shift_remove_first_element() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, String::from(\"one\"));\n        map.insert(2, String::from(\"two\"));\n        \n        let mut entry = map.get_full_mut(&1).unwrap();\n        let value = entry.shift_remove();\n        \n        assert_eq!(value, String::from(\"one\"));\n        assert_eq!(map.len(), 1);\n        assert!(map.get(&1).is_none());\n        assert_eq!(map.get(&2).unwrap(), \"two\");\n    }\n\n    #[test]\n    fn test_shift_remove_last_element() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, String::from(\"one\"));\n        \n        let mut entry = map.get_full_mut(&1).unwrap();\n        let value = entry.shift_remove();\n        \n        assert_eq!(value, String::from(\"one\"));\n        assert_eq!(map.len(), 0);\n        assert!(map.get(&1).is_none());\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::shift_remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_entry() {\n        let mut map: IndexMap<_, _> = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        let entry = map.get_entry(\"b\").unwrap().into_mut();\n\n        let (key, value) = entry.shift_remove_entry();\n\n        assert_eq!(key, \"b\");\n        assert_eq!(value, 2);\n        assert_eq!(map.len(), 2);\n        assert!(map.get(\"b\").is_none());\n        assert_eq!(map.get(\"a\").unwrap(), &1);\n        assert_eq!(map.get(\"c\").unwrap(), &3);\n    }\n\n    #[test]\n    fn test_shift_remove_entry_on_single_element() {\n        let mut map: IndexMap<_, _> = IndexMap::new();\n        map.insert(\"a\", 1);\n        let entry = map.get_entry(\"a\").unwrap().into_mut();\n\n        let (key, value) = entry.shift_remove_entry();\n\n        assert_eq!(key, \"a\");\n        assert_eq!(value, 1);\n        assert_eq!(map.len(), 0);\n        assert!(map.get(\"a\").is_none());\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::{IndexMap, indexmap};\n\n    #[test]\n    fn test_swap_indices() {\n        let mut map: IndexMap<String, i32> = indexmap! {\n            \"a\".to_string() => 1,\n            \"b\".to_string() => 2,\n            \"c\".to_string() => 3,\n        };\n        \n        let entry_a = map.get_index_of(\"a\").unwrap();\n        let entry_b = map.get_index_of(\"b\").unwrap();\n        \n        let mut occupied_entry_a = RawOccupiedEntryMut {\n            entries: &mut map,\n            index: hash_table::OccupiedEntry::from_index(entry_a),\n            hash_builder: PhantomData,\n        };\n        \n        occupied_entry_a.swap_indices(entry_b);\n\n        assert_eq!(map.get_index(0).unwrap().0, \"b\");\n        assert_eq!(map.get_index(1).unwrap().0, \"a\");\n        assert_eq!(map.get_index(2).unwrap().0, \"c\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_swap_indices_out_of_bounds() {\n        let mut map: IndexMap<String, i32> = indexmap! {\n            \"a\".to_string() => 1,\n            \"b\".to_string() => 2,\n        };\n        \n        let entry_a = map.get_index_of(\"a\").unwrap();\n\n        let mut occupied_entry_a = RawOccupiedEntryMut {\n            entries: &mut map,\n            index: hash_table::OccupiedEntry::from_index(entry_a),\n            hash_builder: PhantomData,\n        };\n        \n        occupied_entry_a.swap_indices(2); // This should panic\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_remove() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".into());\n        map.insert(2, \"two\".into());\n        map.insert(3, \"three\".into());\n\n        {\n            let mut entry = map.get_mut(&2).unwrap();\n            let removed_value = entry.swap_remove();\n            assert_eq!(removed_value, \"two\");\n        }\n\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&2).is_none());\n        assert_eq!(map.get(&1).unwrap(), \"one\");\n        assert_eq!(map.get(&3).unwrap(), \"three\");\n    }\n\n    #[test]\n    fn test_swap_remove_last_element() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".into());\n\n        {\n            let mut entry = map.get_mut(&1).unwrap();\n            let removed_value = entry.swap_remove();\n            assert_eq!(removed_value, \"one\");\n        }\n\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_swap_remove_with_nonexistent_key() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".into());\n\n        let result = map.get_mut(&2); // should not panic, returns None\n        assert!(result.is_none());\n    }\n}\n```", "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_remove_entry() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut entry = map.entry(2).or_insert(\"b\");\n\n        let (key, value) = entry.swap_remove_entry();\n        \n        assert_eq!(key, 2);\n        assert_eq!(value, \"b\");\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&2).is_none());\n        assert_eq!(map.get(&1).unwrap(), \"a\");\n        assert_eq!(map.get(&3).unwrap(), \"c\");\n    }\n\n    #[test]\n    fn test_swap_remove_entry_last_element() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n\n        let mut entry = map.entry(1).or_insert(\"a\");\n\n        let (key, value) = entry.swap_remove_entry();\n\n        assert_eq!(key, 1);\n        assert_eq!(value, \"a\");\n        assert_eq!(map.len(), 0);\n        assert!(map.get(&1).is_none());\n    }\n\n    #[test]\n    fn test_swap_remove_entry_nonexistent() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let result = map.entry(3).or_insert(\"c\");\n\n        // It should not panic, and should return the default value since 3 is not in the map\n        assert!(result.is_none());\n    }\n}\n```", "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    struct TestMap<K, V> {\n        indices: Vec<usize>,\n        entries: Vec<Bucket<K, V>>,\n    }\n\n    impl<K, V> TestMap<K, V> {\n        fn new() -> Self {\n            Self {\n                indices: Vec::new(),\n                entries: Vec::new(),\n            }\n        }\n    }\n\n    #[test]\n    fn test_index() {\n        let mut indices = vec![0, 1, 2];\n        let entries: Vec<Bucket<_, _>> = vec![];\n        let ref_mut = RefMut::new(&mut indices, &mut entries);\n        let hash_builder: RandomState = RandomState::new();\n        let vacant_entry = RawVacantEntryMut { map: ref_mut, hash_builder: &hash_builder };\n\n        assert_eq!(vacant_entry.index(), 3);\n    }\n\n    #[test]\n    fn test_index_empty() {\n        let mut indices: Vec<usize> = vec![];\n        let entries: Vec<Bucket<_, _>> = vec![];\n        let ref_mut = RefMut::new(&mut indices, &mut entries);\n        let hash_builder: RandomState = RandomState::new();\n        let vacant_entry = RawVacantEntryMut { map: ref_mut, hash_builder: &hash_builder };\n\n        assert_eq!(vacant_entry.index(), 0);\n    }\n\n    #[test]\n    fn test_index_contract() {\n        let mut indices = vec![0, 1, 2, 3];\n        let entries: Vec<Bucket<_, _>> = vec![Bucket { hash: HashValue(0), key: 1, value: \"value1\" }];\n        let ref_mut = RefMut::new(&mut indices, &mut entries);\n        let hash_builder: RandomState = RandomState::new();\n        let vacant_entry = RawVacantEntryMut { map: ref_mut, hash_builder: &hash_builder };\n\n        assert_eq!(vacant_entry.index(), 4);\n    }\n}\n```", "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_insert() {\n        let mut indices = Indices::new(); // Assuming Indices is a struct that you can create\n        let mut entries = Entries::new(); // Assuming Entries is a struct that you can create\n        let mut hash_builder = RandomState::new();\n        \n        let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n        let raw_entry = RawVacantEntryMut {\n            map: ref_mut,\n            hash_builder: &hash_builder,\n        };\n\n        let key = String::from(\"test_key\");\n        let value = String::from(\"test_value\");\n        let (inserted_key, inserted_value) = raw_entry.insert(key.clone(), value.clone());\n\n        assert_eq!(*inserted_key, key);\n        assert_eq!(*inserted_value, value);\n    }\n}\n```", "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::insert_hashed_nocheck": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::BuildHasherDefault;\n\n    #[test]\n    fn test_insert_hashed_nocheck() {\n        // Create a mock-up of the required structures\n        let mut hasher = DefaultHasher::new();\n        let mut indices = Indices::new(); // Assuming you have a way to create a new Indices object\n        let mut entries = Entries::new(); // Assuming you have a way to create a new Entries object\n\n        // Create a RawVacantEntryMut\n        let mut entry_mut = RawVacantEntryMut {\n            map: RefMut::new(&mut indices, &mut entries),\n            hash_builder: &BuildHasherDefault::new(),\n        };\n\n        // Prepare key-value pair\n        let key = \"key1\".to_string();\n        let value = \"value1\".to_string();\n        let hash = {\n            let mut hasher = DefaultHasher::new();\n            key.hash(&mut hasher);\n            hasher.finish()\n        };\n\n        // Perform insertion using insert_hashed_nocheck\n        let (inserted_key, inserted_value) = entry_mut.insert_hashed_nocheck(hash, key.clone(), value.clone());\n\n        // Validate the insertion\n        assert_eq!(&*inserted_key, &key);\n        assert_eq!(&*inserted_value, &value);\n    }\n}\n```", "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::shift_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n    use std::hash::Hash;\n    use std::collections::HashMap;\n\n    #[test]\n    #[should_panic(expected = \"out of bounds\")]\n    fn test_shift_insert_out_of_bounds() {\n        let mut map = IndexMap::new();\n        let hasher = RandomState::new();\n        let entry = RawVacantEntryMut {\n            map: RefMut::new(&mut Indices::new(), &mut Entries::new()),\n            hash_builder: &hasher,\n        };\n        entry.shift_insert(1, \"key\", \"value\");\n    }\n\n    #[test]\n    fn test_shift_insert_valid() {\n        let mut map: IndexMap<&str, &str> = IndexMap::new();\n        let hasher = RandomState::new();\n        let entry = RawVacantEntryMut {\n            map: RefMut::new(&mut Indices::new(), &mut Entries::new()),\n            hash_builder: &hasher,\n        };\n        let (key_ref, value_ref) = entry.shift_insert(0, \"key\", \"value\");\n        \n        assert_eq!(key_ref, &\"key\");\n        assert_eq!(value_ref, &\"value\");\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(\"key\"), Some(&\"value\"));\n    }\n\n    #[test]\n    fn test_shift_insert_multiple() {\n        let mut map: IndexMap<&str, &str> = IndexMap::new();\n        let hasher = RandomState::new();\n        let entry = RawVacantEntryMut {\n            map: RefMut::new(&mut Indices::new(), &mut Entries::new()),\n            hash_builder: &hasher,\n        };\n        \n        entry.shift_insert(0, \"key1\", \"value1\");\n        entry.shift_insert(1, \"key2\", \"value2\");\n        \n        let (key_ref, value_ref) = entry.shift_insert(1, \"key3\", \"value3\");\n        \n        assert_eq!(key_ref, &\"key3\");\n        assert_eq!(value_ref, &\"value3\");\n        assert_eq!(map.len(), 3);\n        assert_eq!(map.get(\"key1\"), Some(&\"value1\"));\n        assert_eq!(map.get(\"key3\"), Some(&\"value3\"));\n        assert_eq!(map.get(\"key2\"), Some(&\"value2\"));\n    }\n}\n```", "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::shift_insert_hashed_nocheck": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use std::hash::BuildHasher;\n    use std::marker::PhantomData;\n\n    struct TestBuilder;\n    impl BuildHasher for TestBuilder {\n        type Hasher = std::collections::hash_map::DefaultHasher;\n        fn build_hasher(&self) -> Self::Hasher {\n            std::collections::hash_map::DefaultHasher::new()\n        }\n    }\n\n    #[test]\n    fn test_shift_insert_hashed_nocheck() {\n        const TEST_INDEX: usize = 0;\n        const TEST_HASH: u64 = 12345;\n        let mut map: IndexMap<String, String, TestBuilder> = IndexMap::new();\n        let hash_builder = TestBuilder;\n\n        let mut vacant_entry = RawVacantEntryMut {\n            map: RefMut::new(&mut map.indices, &mut map.entries),\n            hash_builder: &hash_builder,\n        };\n\n        let (key_ref, value_ref) = vacant_entry.shift_insert_hashed_nocheck(\n            TEST_INDEX,\n            TEST_HASH,\n            String::from(\"test_key\"),\n            String::from(\"test_value\"),\n        );\n\n        assert_eq!(*key_ref, \"test_key\");\n        assert_eq!(*value_ref, \"test_value\");\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.entries[TEST_INDEX].key, \"test_key\");\n        assert_eq!(map.entries[TEST_INDEX].value, \"test_value\");\n    }\n}\n```", "map::core::reserve_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_reserve_entries() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        let mut entries = map.entries();\n\n        // Initial entry count\n        assert_eq!(entries.len(), 0);\n\n        // Reserve space for 5 entries\n        reserve_entries(&mut entries, 5, 10);\n        assert!(entries.len() <= 5);\n\n        // Add an entry to test if the reserve worked\n        map.insert(1, 10);\n        assert_eq!(entries.len(), 1);\n\n        // Reserve space for 10 entries, should still work\n        reserve_entries(&mut entries, 10, 15);\n        assert!(entries.len() <= 11);\n\n        // Adding 11 entries to test the capacity\n        for i in 2..=11 {\n            map.insert(i, i * 10);\n        }\n        assert_eq!(entries.len(), 11);\n    }\n}\n```", "map::core::update_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[derive(Default)]\n    struct Indices(HashMap<u64, usize>);\n    \n    impl Indices {\n        fn find_mut<F>(&mut self, hash: u64, predicate: F) -> Option<&mut usize>\n        where\n            F: FnMut(&usize) -> bool,\n        {\n            self.0.iter_mut().find_map(|(&h, i)| if h == hash && predicate(i) { Some(i) } else { None })\n        }\n    }\n\n    #[test]\n    fn test_update_index() {\n        let mut indices = Indices::default();\n        let hash_value = HashValue(1);\n        let old_index = 0;\n        let new_index = 1;\n\n        indices.0.insert(hash_value.get(), old_index); // Setup initial state\n\n        update_index(&mut indices, hash_value, old_index, new_index); // Call the function\n\n        assert_eq!(indices.0.get(&hash_value.get()), Some(&new_index)); // Verify the update\n    }\n\n    #[test]\n    #[should_panic(expected = \"index not found\")]\n    fn test_update_index_panic() {\n        let mut indices = Indices::default();\n        let hash_value = HashValue(1);\n        let old_index = 0;\n        let new_index = 1;\n\n        indices.0.insert(hash_value.get(), old_index); // Setup initial state\n        // Update with an old_index that doesn't exist, should panic\n        update_index(&mut indices, hash_value, 999, new_index);\n    }\n}\n```", "map::iter::<impl core::iter::IntoIterator for &'a map::IndexMap<K, V, S>>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_iter() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut iter = map.into_iter();\n        let mut keys = vec![];\n        let mut values = vec![];\n\n        while let Some((key, value)) = iter.next() {\n            keys.push(key);\n            values.push(value);\n        }\n\n        assert_eq!(keys, vec![1, 2, 3]);\n        assert_eq!(values, vec![\"a\", \"b\", \"c\"]);\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let mut iter = map.into_iter();\n\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_after_mutation() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let mut iter = map.into_iter();\n        assert_eq!(iter.next(), Some((1, \"a\")));\n\n        map.insert(3, \"c\"); // mutation after iteration started\n        assert_eq!(iter.next(), Some((2, \"b\"))); // should still see the original values\n    }\n}\n```", "map::iter::<impl core::iter::IntoIterator for &'a mut map::IndexMap<K, V, S>>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_iter() {\n        let mut map = IndexMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut iter = map.iter_mut();\n        let first_entry = iter.next();\n        assert_eq!(first_entry, Some((&\"a\", &mut 1)));\n\n        let second_entry = iter.next();\n        assert_eq!(second_entry, Some((&\"b\", &mut 2)));\n\n        let third_entry = iter.next();\n        assert_eq!(third_entry, Some((&\"c\", &mut 3)));\n\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let map: IndexMap<&str, i32> = IndexMap::new();\n\n        let mut iter = map.iter_mut();\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_into_iter_multiple_entries() {\n        let mut map = IndexMap::new();\n        map.insert(\"first\", 1);\n        map.insert(\"second\", 2);\n        map.insert(\"third\", 3);\n\n        let entries: Vec<_> = map.iter_mut().collect();\n        assert_eq!(entries.len(), 3);\n        assert_eq!(entries[0], (&\"first\", &mut 1));\n        assert_eq!(entries[1], (&\"second\", &mut 2));\n        assert_eq!(entries[2], (&\"third\", &mut 3));\n    }\n\n    #[test]\n    fn test_into_iter_mut() {\n        let mut map: IndexMap<i32, i32> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        for (key, value) in map.iter_mut() {\n            *value *= 2; // Double the values\n        }\n        \n        assert_eq!(map[&1], 20);\n        assert_eq!(map[&2], 40);\n    }\n}\n```", "map::iter::<impl core::iter::IntoIterator for map::IndexMap<K, V, S>>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_iter() {\n        // Create an IndexMap\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        // Convert IndexMap into an iterator\n        let iter = map.into_iter();\n\n        // Collect the items into a Vec to check the contents\n        let items: Vec<(i32, &str)> = iter.collect();\n\n        // Check the items match expected values\n        assert_eq!(items, vec![(1, \"one\"), (2, \"two\"), (3, \"three\")]);\n    }\n\n    #[test]\n    fn test_into_iter_on_empty_map() {\n        // Create an empty IndexMap\n        let map: IndexMap<i32, &str> = IndexMap::new();\n\n        // Convert empty IndexMap into an iterator\n        let iter = map.into_iter();\n\n        // Collect the items into a Vec to check the contents\n        let items: Vec<(i32, &str)> = iter.collect();\n\n        // Check the items match expected values (should be empty)\n        assert!(items.is_empty());\n    }\n\n    #[test]\n    fn test_into_iter_order() {\n        // Create an IndexMap with specific insertion order\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(3, \"three\");\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        // Convert IndexMap into an iterator\n        let iter = map.into_iter();\n\n        // Collect the items into a Vec to check the contents\n        let items: Vec<(i32, &str)> = iter.collect();\n\n        // Check the items match expected insertion order\n        assert_eq!(items, vec![(3, \"three\"), (1, \"one\"), (2, \"two\")]);\n    }\n}\n```", "map::iter::Drain::<'a, K, V>::as_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_as_slice() {\n        // Create sample buckets\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n\n        let mut vec_buckets = vec![bucket1.clone(), bucket2.clone()];\n        let mut drain = Drain::new(vec_buckets.drain(..));\n\n        // Call the as_slice method\n        let slice = drain.as_slice();\n\n        // Ensure the slice length matches the number of remaining buckets\n        assert_eq!(slice.len(), 2);\n\n        // Test the content of the slice\n        assert_eq!(slice.get_index(0), Some((&\"key1\", &\"value1\")));\n        assert_eq!(slice.get_index(1), Some((&\"key2\", &\"value2\")));\n    }\n}\n```", "map::iter::Drain::<'a, K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n    use crate::map::iter::Drain;\n    use crate::Bucket;\n\n    #[test]\n    fn test_drain_new() {\n        let vec: Vec<Bucket<i32, String>> = vec![\n            Bucket::new(1, String::from(\"one\")),\n            Bucket::new(2, String::from(\"two\")),\n        ];\n\n        let mut drain_vec = vec.clone();\n        let drain = drain_vec.drain(0..2);\n\n        let drain_instance = Drain::new(drain);\n        assert_eq!(drain_instance.len(), 2);\n    }\n}\n```", "map::iter::IntoIter::<K, V>::as_mut_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_as_mut_slice() {\n        let key1 = \"key1\";\n        let value1 = 1;\n        let key2 = \"key2\";\n        let value2 = 2;\n\n        // Create buckets\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: key1.to_string(),\n            value: value1,\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: key2.to_string(),\n            value: value2,\n        };\n\n        // Create an IntoIter with some buckets\n        let mut iterator = IntoIter::new(vec![bucket1.clone(), bucket2.clone()]);\n\n        // Obtain a mutable slice\n        let slice = iterator.as_mut_slice();\n        \n        // Check the length of the mutable slice\n        assert_eq!(slice.len(), 2);\n\n        // Modify the values through the mutable slice\n        slice.entries[0].value_mut() = 10;\n        slice.entries[1].value_mut() = 20;\n\n        // Assert the values were modified\n        assert_eq!(iterator.as_slice().entries[0].value, 10);\n        assert_eq!(iterator.as_slice().entries[1].value, 20);\n    }\n}\n```", "map::iter::IntoIter::<K, V>::as_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_as_slice() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let mut iter = IntoIter::new(vec![bucket1.clone(), bucket2.clone()]);\n\n        let slice = iter.as_slice();\n\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice.get_index(0).unwrap(), (&bucket1.key, &bucket1.value));\n        assert_eq!(slice.get_index(1).unwrap(), (&bucket2.key, &bucket2.value));\n    }\n\n    #[test]\n    fn test_as_slice_empty() {\n        let iter: IntoIter<String, String> = IntoIter::default();\n        let slice = iter.as_slice();\n        assert!(slice.is_empty());\n        assert_eq!(slice.len(), 0);\n    }\n\n    #[test]\n    fn test_as_slice_single_element() {\n        let bucket = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let mut iter = IntoIter::new(vec![bucket.clone()]);\n\n        let slice = iter.as_slice();\n\n        assert_eq!(slice.len(), 1);\n        assert_eq!(slice.get_index(0).unwrap(), (&bucket.key, &bucket.value));\n    }\n}\n```", "map::iter::IntoIter::<K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::IntoIter;\n    use crate::map::Bucket;\n\n    #[test]\n    fn test_into_iter_new() {\n        let entries = vec![\n            Bucket::new(\"key1\", \"value1\"),\n            Bucket::new(\"key2\", \"value2\"),\n        ];\n\n        let iter = IntoIter::new(entries);\n        let collected: Vec<_> = iter.collect();\n\n        assert_eq!(collected.len(), 2);\n        assert_eq!(collected[0], (\"key1\", \"value1\"));\n        assert_eq!(collected[1], (\"key2\", \"value2\"));\n    }\n}\n```", "map::iter::IntoKeys::<K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::IntoKeys;\n    use crate::map::Bucket;\n\n    #[test]\n    fn test_into_keys_new() {\n        let bucket1 = Bucket::new(\"key1\", \"value1\");\n        let bucket2 = Bucket::new(\"key2\", \"value2\");\n        let entries = vec![bucket1, bucket2];\n\n        let into_keys = IntoKeys::new(entries);\n\n        let keys: Vec<_> = into_keys.collect();\n        assert_eq!(keys, vec![\"key1\", \"key2\"]);\n    }\n}\n```", "map::iter::IntoValues::<K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::IntoValues;\n    use crate::map::Bucket; // Adjust the import path as necessary based on your crate structure\n\n    #[test]\n    fn test_into_values_new() {\n        // Create test buckets\n        let bucket1 = Bucket::new(/* parameters for Bucket */);\n        let bucket2 = Bucket::new(/* parameters for Bucket */);\n        let buckets = vec![bucket1, bucket2];\n\n        // Create IntoValues from buckets\n        let into_values = IntoValues::new(buckets);\n\n        // Test that the iterator is correctly initialized\n        assert_eq!(into_values.len(), 2);\n    }\n}\n```", "map::iter::Iter::<'a, K, V>::as_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_as_slice() {\n        // Prepare test data\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let buckets = vec![bucket1, bucket2];\n        let slice = Slice::from_slice(&buckets);\n\n        // Create an iterator\n        let iter = Iter::new(slice.entries);\n\n        // Call as_slice\n        let result = iter.as_slice();\n\n        // Create the expected slice\n        let expected = Slice::from_slice(&buckets);\n\n        // Assert that the result is as expected\n        assert_eq!(result, expected);\n        assert_eq!(result.len(), buckets.len());\n        assert_eq!(result.get_index(0), Some((&\"key1\", &\"value1\")));\n        assert_eq!(result.get_index(1), Some((&\"key2\", &\"value2\")));\n    }\n}\n```", "map::iter::Iter::<'a, K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::Iter;\n\n    #[test]\n    fn test_iter_new() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let entries = vec![bucket1, bucket2];\n        let iter = Iter::new(&entries);\n\n        assert_eq!(iter.len(), 2);\n        let (key, value) = iter.iter().next().unwrap();\n        assert_eq!(key, &\"key1\");\n        assert_eq!(value, &\"value1\");\n    }\n}\n```", "map::iter::IterMut2::<'a, K, V>::as_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::IterMut2;\n    use crate::map::slice::Slice;\n    use crate::Bucket;\n\n    #[test]\n    fn test_as_slice() {\n        let mut buckets: Vec<Bucket<u32, String>> = vec![\n            Bucket { hash: HashValue(1), key: 1, value: String::from(\"one\") },\n            Bucket { hash: HashValue(2), key: 2, value: String::from(\"two\") },\n        ];\n        \n        let iter = IterMut2::new(&mut buckets);\n        let slice = iter.as_slice();\n\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice.get_index(0), Some((&1, &String::from(\"one\"))));\n        assert_eq!(slice.get_index(1), Some((&2, &String::from(\"two\"))));\n    }\n\n    #[test]\n    fn test_as_slice_empty() {\n        let mut buckets: Vec<Bucket<u32, String>> = Vec::new();\n\n        let iter = IterMut2::new(&mut buckets);\n        let slice = iter.as_slice();\n\n        assert_eq!(slice.len(), 0);\n        assert!(slice.is_empty());\n    }\n}\n```", "map::iter::IterMut2::<'a, K, V>::into_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::IterMut2;\n    use crate::map::slice::Slice;\n    use crate::Bucket;\n    use crate::HashValue;\n\n    #[test]\n    fn test_into_slice() {\n        let mut bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let mut bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        \n        let mut buckets: Vec<Bucket<&str, &str>> = vec![bucket1, bucket2];\n        let mut iter = IterMut2::new(&mut buckets);\n\n        let slice: &mut Slice<_, _> = iter.into_slice();\n\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice.get_index(0), Some((&\"key1\", &\"value1\")));\n        assert_eq!(slice.get_index(1), Some((&\"key2\", &\"value2\")));\n    }\n}\n```", "map::iter::IterMut2::<'a, K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt::Debug;\n\n    #[derive(Clone, Debug)]\n    struct TestKey(usize);\n    #[derive(Clone, Debug)]\n    struct TestValue(usize);\n\n    #[test]\n    fn test_iter_mut2_new() {\n        let mut buckets = [\n            Bucket { hash: HashValue(1), key: TestKey(1), value: TestValue(10) },\n            Bucket { hash: HashValue(2), key: TestKey(2), value: TestValue(20) },\n        ];\n\n        let iter = IterMut2::new(&mut buckets);\n\n        assert_eq!(iter.len(), 2);\n        assert_eq!(iter.as_slice().iter().map(|b| b.refs()).collect::<Vec<_>>(), vec![(&TestKey(1), &TestValue(10)), (&TestKey(2), &TestValue(20))]);\n    }\n}\n```", "map::iter::IterMut::<'a, K, V>::as_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::IterMut;\n    use crate::map::slice::Slice;\n    \n    #[test]\n    fn test_as_slice() {\n        let key1 = \"key1\";\n        let key2 = \"key2\";\n        let value1 = \"value1\";\n        let value2 = \"value2\";\n        \n        let mut bucket1 = Bucket {\n            hash: HashValue(1),\n            key: key1.to_string(),\n            value: value1.to_string(),\n        };\n        \n        let mut bucket2 = Bucket {\n            hash: HashValue(2),\n            key: key2.to_string(),\n            value: value2.to_string(),\n        };\n        \n        let mut buckets = vec![bucket1, bucket2];\n        let mut iter = IterMut::new(&mut buckets);\n        \n        let slice: &Slice<_, _> = iter.as_slice();\n        \n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice.get_index(0), Some((&key1.to_string(), &value1.to_string())));\n        assert_eq!(slice.get_index(1), Some((&key2.to_string(), &value2.to_string())));\n    }\n}\n```", "map::iter::IterMut::<'a, K, V>::into_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::slice;\n\n    #[test]\n    fn test_into_slice() {\n        // Initialize sample Bucket data\n        let mut buckets: [Bucket<i32, String>; 3] = [\n            Bucket { hash: HashValue(1), key: 1, value: String::from(\"a\") },\n            Bucket { hash: HashValue(2), key: 2, value: String::from(\"b\") },\n            Bucket { hash: HashValue(3), key: 3, value: String::from(\"c\") },\n        ];\n\n        // Create IterMut instance\n        let iter_mut = IterMut::new(&mut buckets);\n        let mut slice = iter_mut.into_slice();\n\n        // Verify the slice contents\n        assert_eq!(slice.len(), 3);\n        assert_eq!(slice.get_index(0), Some((&1, &mut String::from(\"a\"))));\n        assert_eq!(slice.get_index(1), Some((&2, &mut String::from(\"b\"))));\n        assert_eq!(slice.get_index(2), Some((&3, &mut String::from(\"c\"))));\n    }\n}\n```", "map::iter::IterMut::<'a, K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::marker::PhantomData;\n\n    struct TestKey(i32);\n    struct TestValue(i32);\n\n    #[derive(Clone, Copy, Debug)]\n    struct TestBucket {\n        hash: HashValue,\n        key: TestKey,\n        value: TestValue,\n    }\n\n    impl TestBucket {\n        fn new(key: i32, value: i32) -> Self {\n            Self {\n                hash: HashValue(key as usize),\n                key: TestKey(key),\n                value: TestValue(value),\n            }\n        }\n    }\n\n    #[test]\n    fn test_iter_mut_new() {\n        let mut buckets: Vec<TestBucket> = vec![\n            TestBucket::new(1, 10),\n            TestBucket::new(2, 20),\n        ];\n        \n        let mut iter_mut = IterMut::new(&mut buckets);\n        \n        assert_eq!(iter_mut.len(), 2);\n        \n        if let Some((key, value_mut)) = iter_mut.next() {\n            assert_eq!(key.0, 1);\n            assert_eq!(value_mut.0, 10);\n            *value_mut = TestValue(15);\n        }\n        \n        if let Some((key, value_mut)) = iter_mut.next() {\n            assert_eq!(key.0, 2);\n            assert_eq!(value_mut.0, 20);\n            *value_mut = TestValue(25);\n        }\n        \n        assert!(iter_mut.next().is_none());\n        assert_eq!(buckets[0].value.0, 15);\n        assert_eq!(buckets[1].value.0, 25);\n    }\n}\n```", "map::iter::Keys::<'a, K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::iter::Keys;\n\n    #[derive(Clone, Debug)]\n    struct TestKey(usize);\n    #[derive(Clone, Debug)]\n    struct TestValue(usize);\n    \n    #[test]\n    fn test_keys_new() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: TestKey(1), value: TestValue(10) },\n            Bucket { hash: HashValue(2), key: TestKey(2), value: TestValue(20) },\n        ];\n\n        let keys = Keys::new(&buckets);\n        let collected_keys: Vec<&TestKey> = keys.collect();\n\n        assert_eq!(collected_keys.len(), 2);\n        assert_eq!(collected_keys[0], &TestKey(1));\n        assert_eq!(collected_keys[1], &TestKey(2));\n    }\n}\n```", "map::iter::Splice::<'a, I, K, V, S>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_splice_new() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let range = 1..3;\n        let replace_with = vec![(4, \"d\"), (5, \"e\")];\n\n        let splice = Splice::new(&mut map, range, replace_with.clone().into_iter());\n\n        // Verify that the Splice contains the correct entries\n        let removed: Vec<_> = splice.collect();\n        assert_eq!(removed, vec![(2, \"b\"), (3, \"c\")]);\n        \n        // Verify the final state of the map\n        let mut expected = IndexMap::new();\n        expected.insert(1, \"a\");\n        expected.insert(4, \"d\");\n        expected.insert(5, \"e\");\n\n        assert_eq!(map, expected);\n    }\n\n    #[test]\n    fn test_splice_new_empty_map() {\n        let mut map = IndexMap::new();\n        let range = 0..0;\n        let replace_with = vec![(1, \"a\"), (2, \"b\"), (3, \"c\")];\n\n        let splice = Splice::new(&mut map, range, replace_with.clone().into_iter());\n\n        // Verify that the Splice contains no removed entries\n        let removed: Vec<_> = splice.collect();\n        assert!(removed.is_empty());\n\n        // Verify the final state of the map\n        let mut expected = IndexMap::new();\n        for (k, v) in replace_with {\n            expected.insert(k, v);\n        }\n\n        assert_eq!(map, expected);\n    }\n}\n```", "map::iter::Values::<'a, K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Importing relevant items from the current module\n    use std::fmt;\n\n    #[derive(Clone, Copy, Debug, PartialEq)]\n    struct TestKey(usize);\n    \n    #[derive(Clone, Debug)]\n    struct TestValue(String);\n\n    #[test]\n    fn test_values_new() {\n        let buckets = [\n            Bucket {\n                hash: HashValue(1),\n                key: TestKey(1),\n                value: TestValue(\"Value 1\".to_string()),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: TestKey(2),\n                value: TestValue(\"Value 2\".to_string()),\n            }\n        ];\n\n        let values_iter = Values::new(&buckets);\n\n        let values: Vec<&TestValue> = values_iter.collect();\n        \n        assert_eq!(values.len(), 2);\n        assert_eq!(values[0], &TestValue(\"Value 1\".to_string()));\n        assert_eq!(values[1], &TestValue(\"Value 2\".to_string()));\n    }\n}\n```", "map::iter::ValuesMut::<'a, K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_values_mut_new() {\n        let mut buckets: Vec<Bucket<u32, String>> = vec![\n            Bucket { hash: HashValue(1), key: 1, value: String::from(\"value1\") },\n            Bucket { hash: HashValue(2), key: 2, value: String::from(\"value2\") },\n        ];\n        \n        let mut_values = ValuesMut::new(&mut buckets);\n\n        assert_eq!(mut_values.len(), 2);\n        assert_eq!(*mut_values.iter.next().unwrap(), \"value1\");\n        assert_eq!(*mut_values.iter.next().unwrap(), \"value2\");\n    }\n}\n```", "map::slice::<impl core::clone::Clone for alloc::boxed::Box<map::slice::Slice<K, V>>>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::boxed::Box;\n    use map::slice::Slice;\n\n    #[test]\n    fn test_clone() {\n        // Creating a Slice instance\n        let original = Slice::from_boxed(Box::new(vec![(1, \"a\"), (2, \"b\")].into_boxed_slice()));\n\n        // Cloning the original Slice\n        let cloned = original.clone();\n\n        // Ensure the cloned slice has the same entries\n        assert_eq!(original.entries.to_vec(), cloned.entries.to_vec());\n        // Ensure that they are different instances\n        assert!(!std::ptr::eq(&original, &cloned));\n    }\n}\n```", "map::slice::<impl core::cmp::PartialEq<map::slice::Slice<K2, V2>> for [(K, V); N]>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_slice_eq() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n\n        let slice1 = Slice {\n            entries: [bucket1, bucket2],\n        };\n        let slice2 = Slice {\n            entries: [bucket1.clone(), bucket2.clone()],\n        };\n        let slice3 = Slice {\n            entries: [bucket1, Bucket {\n                hash: HashValue(3),\n                key: \"key3\",\n                value: \"value3\",\n            }],\n        };\n\n        assert!(slice1.eq(&slice2));\n        assert!(!slice1.eq(&slice3));\n    }\n}\n```", "map::slice::<impl core::cmp::PartialEq<map::slice::Slice<K2, V2>> for [(K, V)]>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    #[test]\n    fn test_slice_eq() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let slice1 = Slice {\n            entries: [bucket1.clone(), bucket2.clone()],\n        };\n        let slice2 = Slice {\n            entries: [bucket1, bucket2],\n        };\n        assert!(slice1.eq(&slice2));\n    }\n\n    #[test]\n    fn test_slice_eq_different_values() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let slice1 = Slice {\n            entries: [bucket1.clone(), bucket2.clone()],\n        };\n        let slice2 = Slice {\n            entries: [bucket1, Bucket { hash: HashValue(3), key: \"key2\", value: \"value3\" }],\n        };\n        assert!(!slice1.eq(&slice2));\n    }\n\n    #[test]\n    fn test_slice_eq_empty() {\n        let empty_slice1 = Slice { entries: [] };\n        let empty_slice2 = Slice { entries: [] };\n        assert!(empty_slice1.eq(&empty_slice2));\n    }\n\n    #[test]\n    fn test_slice_eq_different_length() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let slice1 = Slice {\n            entries: [bucket1.clone()],\n        };\n        let slice2 = Slice {\n            entries: [bucket1.clone(), Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" }],\n        };\n        assert!(!slice1.eq(&slice2));\n    }\n}\n```", "map::slice::<impl core::convert::From<&map::slice::Slice<K, V>> for alloc::boxed::Box<map::slice::Slice<K, V>>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::boxed::Box;\n\n    #[test]\n    fn test_from() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let slice = Slice {\n            entries: [bucket1, bucket2],\n        };\n\n        let boxed_slice: Box<Slice<&str, &str>> = Box::from(&slice);\n        let new_boxed_slice = Box::<Slice<_, _>>::from(&slice);\n\n        assert_eq!(boxed_slice.len(), new_boxed_slice.len());\n        assert_eq!(boxed_slice.get_index(0), new_boxed_slice.get_index(0));\n        assert_eq!(boxed_slice.get_index(1), new_boxed_slice.get_index(1));\n    }\n}\n```", "map::slice::<impl core::default::Default for alloc::boxed::Box<map::slice::Slice<K, V>>>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::boxed::Box;\n    use map::slice::Slice;\n\n    #[test]\n    fn test_default() {\n        let default_box: Box<Slice<i32, String>> = Box::default();\n        assert!(default_box.is_empty());\n    }\n}\n```", "map::slice::<impl core::iter::IntoIterator for alloc::boxed::Box<map::slice::Slice<K, V>>>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::boxed::Box;\n    use crate::map::slice::{Slice, IntoIter}; // Adjust the path based on your crate structure \n\n    #[test]\n    fn test_into_iter() {\n        let entries: Vec<(i32, i32)> = vec![(1, 10), (2, 20), (3, 30)];\n        let slice = Slice::from_vec(entries.clone());\n        let boxed_slice: Box<Slice<i32, i32>> = Box::from(&slice);\n\n        let mut iter = boxed_slice.into_iter();\n        \n        for (key, value) in entries {\n            assert_eq!(iter.next(), Some((key, value)));\n        }\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "map::slice::<impl core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for map::IndexMap<K, V, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use std::ops::Bound;\n\n    #[test]\n    fn test_index_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let slice = map.index(1..3); // Slice from index 1 to 3 (exclusive)\n        \n        assert_eq!(slice.len(), 2); // Slice length should be 2\n        assert_eq!(slice[0].key, 2); // First element should be (2, \"b\")\n        assert_eq!(slice[1].key, 3); // Second element should be (3, \"c\")\n    }\n\n    #[test]\n    fn test_index_single() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let value = map.index(1); // Accessing index 1\n        assert_eq!(value.1, \"b\"); // Should be \"b\"\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.index(5); // Accessing out of bounds\n    }\n\n    #[test]\n    fn test_index_mut_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let slice_mut = map.index_mut(1..3); // Mutable slice from index 1 to 3 (exclusive)\n        slice_mut[0].1 = \"x\"; // Changing value at index 1\n\n        assert_eq!(map.index(1).1, \"x\"); // Should reflect change in original map\n        assert_eq!(map.index(2).1, \"b\"); // Second element should still be \"b\"\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_mut_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.index_mut(5); // Accessing out of bounds\n    }\n}\n```", "map::slice::<impl core::ops::Index<core::ops::Range<usize>> for map::IndexMap<K, V, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_index_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let slice = map.index(0..2);\n        assert_eq!(slice.as_slice(), &[Bucket::new(1, \"one\"), Bucket::new(2, \"two\")]);\n\n        let slice = map.index(1..3);\n        assert_eq!(slice.as_slice(), &[Bucket::new(2, \"two\"), Bucket::new(3, \"three\")]);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\n    fn test_index_range_out_of_bounds() {\n        let map = IndexMap::from([(1, \"one\"), (2, \"two\"), (3, \"three\")]);\n        let _ = map.index(2..4); // Index 4 is out of bounds\n    }\n\n    #[test]\n    fn test_index_single() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let value = map.index(1);\n        assert_eq!(value, \"two\");\n\n        let value = map.index(0);\n        assert_eq!(value, \"one\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 2 but the index is 2\")]\n    fn test_index_single_out_of_bounds() {\n        let map = IndexMap::from([(1, \"one\"), (2, \"two\")]);\n        let _ = map.index(2); // Index 2 is out of bounds\n    }\n}\n```", "map::slice::<impl core::ops::Index<core::ops::RangeFrom<usize>> for map::IndexMap<K, V, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_with_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let slice = map.index(1..3); // should return a slice with entries for keys 2 and 3\n        assert_eq!(slice.as_slice(), &[(2, \"b\"), (3, \"c\")]);\n\n        // Testing index with a range that exceeds the bounds\n        let slice = map.index(0..2); // should return a slice with entries for keys 1 and 2\n        assert_eq!(slice.as_slice(), &[(1, \"a\"), (2, \"b\")]);\n\n        // Testing the full range\n        let slice = map.index(0..3); // should return a slice with all entries\n        assert_eq!(slice.as_slice(), &[(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n    }\n\n    #[test]\n    fn test_index_with_range_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let slice = map.index(0..0); // should return an empty slice\n        assert_eq!(slice.as_slice(), &[]);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        let _ = map.index(1..3); // out of bounds\n    }\n}\n```", "map::slice::<impl core::ops::Index<core::ops::RangeFull> for map::IndexMap<K, V, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_indexmap_index_range_full() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let slice = map.index(..);\n        assert_eq!(slice.len(), 3);\n        assert_eq!(slice[0].key, 1);\n        assert_eq!(slice[1].key, 2);\n        assert_eq!(slice[2].key, 3);\n    }\n\n    #[test]\n    fn test_indexmap_index_range_part() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let slice = map.index(1..3);\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice[0].key, 2);\n        assert_eq!(slice[1].key, 3);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_indexmap_index_range_full_panic() {\n        let map: IndexMap<usize, &str> = IndexMap::new();\n        let _slice = map.index(..); // Should panic as the map is empty\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_indexmap_index_out_of_bounds_panic() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        let _value = map.index(1); // This should panic due to index out of bounds\n    }\n}\n```", "map::slice::<impl core::ops::Index<core::ops::RangeInclusive<usize>> for map::IndexMap<K, V, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn indexmap_index_range_inclusive() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let slice: &Slice<i32, &str> = &map[1..=2];\n        assert_eq!(slice.as_entries().len(), 2);\n        assert_eq!(slice.as_entries()[0].key, 2);\n        assert_eq!(slice.as_entries()[1].key, 1);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\n    fn indexmap_index_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let _ = &map[3..=3]; // This should panic\n    }\n\n    #[test]\n    fn indexmap_index_range_inclusive_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        \n        // This should return None as the map is empty\n        let slice = map.get_range(0..=1);\n        assert!(slice.is_none());\n    }\n\n    #[test]\n    fn indexmap_index_range_inclusive_single_element() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n\n        let slice: &Slice<i32, &str> = &map[0..=0];\n        assert_eq!(slice.as_entries().len(), 1);\n        assert_eq!(slice.as_entries()[0].key, 1);\n    }\n}\n```", "map::slice::<impl core::ops::Index<core::ops::RangeTo<usize>> for map::IndexMap<K, V, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_single() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        assert_eq!(map.index(0), &(\"one\"));\n    }\n\n    #[test]\n    fn test_index_multiple() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        \n        assert_eq!(map.index(0), &(\"one\"));\n        assert_eq!(map.index(1), &(\"two\"));\n        assert_eq!(map.index(2), &(\"three\"));\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\n    fn test_index_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        \n        let _ = map.index(3); // This should panic\n    }\n\n    #[test]\n    fn test_index_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        assert_eq!(map.len(), 0);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_index_with_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        \n        let slice = map.index(0..2);\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice[0], (\"one\", 1));\n        assert_eq!(slice[1], (\"two\", 2));\n    }\n}\n```", "map::slice::<impl core::ops::Index<core::ops::RangeToInclusive<usize>> for map::IndexMap<K, V, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_with_valid_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"value1\");\n        map.insert(2, \"value2\");\n        map.insert(3, \"value3\");\n\n        let slice = map.index(1..=2);\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice[0].1, \"value2\");\n        assert_eq!(slice[1].1, \"value3\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_with_out_of_bounds() {\n        let map = IndexMap::new();\n        map.index(0..=0);\n    }\n\n    #[test]\n    fn test_index_with_empty_map() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let slice = map.index(0..=0);\n        assert_eq!(slice.len(), 0);\n    }\n\n    #[test]\n    fn test_index_mut() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"value1\");\n        map.insert(2, \"value2\");\n\n        {\n            let slice = map.index_mut(0..=1);\n            assert_eq!(slice.len(), 2);\n            slice[0].1 = \"modified_value1\";\n        }\n\n        assert_eq!(map.index(0..=1)[0].1, \"modified_value1\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_mut_with_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"value1\");\n        map.index_mut(1..=1);\n    }\n}\n```", "map::slice::<impl core::ops::IndexMut<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for map::IndexMap<K, V, S>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_mut_single_element() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        let value = map.index_mut(0);\n        *value = \"uno\";\n        assert_eq!(map[1], \"uno\");\n    }\n\n    #[test]\n    fn test_index_mut_multiple_elements() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        let slice = map.index_mut(1..3);\n        slice[0] = \"deux\";\n        slice[1] = \"trois\";\n        assert_eq!(map[2], \"deux\");\n        assert_eq!(map[3], \"trois\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_mut_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        let _value = map.index_mut(1);\n    }\n\n    #[test]\n    fn test_index_mut_empty_map() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.index_mut(0);  // Ensuring no panic for the initial access\n        map.insert(3, \"three\");\n\n        // Modifying with index_mut\n        let slice = map.index_mut(1..3);\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice[0], \"two\");\n        slice[0] = \"modified_two\";\n        assert_eq!(map[2], \"modified_two\");\n    }\n}\n```", "map::slice::<impl core::ops::IndexMut<core::ops::Range<usize>> for map::IndexMap<K, V, S>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_mut_range() {\n        let mut map: IndexMap<usize, usize> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        map.insert(4, 40);\n\n        {\n            let slice = map.index_mut(1..3);\n            slice[0].1 = 100;  // Changing the value of index 1\n            slice[1].1 = 200;  // Changing the value of index 2\n        }\n\n        assert_eq!(map[&1], 100);\n        assert_eq!(map[&2], 200);\n        assert_eq!(map[&3], 30);\n        assert_eq!(map[&4], 40);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_mut_range_out_of_bounds() {\n        let mut map: IndexMap<usize, usize> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        let _slice = map.index_mut(0..3); // Should panic because index 3 is out of bounds\n    }\n\n    #[test]\n    fn test_index_mut_single() {\n        let mut map: IndexMap<usize, usize> = IndexMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        let value = map.index_mut(1);\n        *value = 100;\n\n        assert_eq!(map[&1], 100);\n        assert_eq!(map[&2], 20);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_mut_single_out_of_bounds() {\n        let mut map: IndexMap<usize, usize> = IndexMap::new();\n        map.insert(1, 10);\n\n        let _value = map.index_mut(1); // Valid\n        let _value_out_of_bounds = map.index_mut(2); // Should panic\n    }\n}\n```", "map::slice::<impl core::ops::IndexMut<core::ops::RangeFrom<usize>> for map::IndexMap<K, V, S>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    \n    #[test]\n    fn test_index_mut_single() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n\n        // Get mutable reference to the value\n        let value = map.index_mut(0);\n        value.push_str(\" updated\");\n        \n        assert_eq!(map.index(&1), \"one updated\");\n    }\n\n    #[test]\n    fn test_index_mut_multiple() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n        map.insert(2, \"two\".to_string());\n\n        // Get mutable reference to the first value\n        {\n            let slice = map.index_mut(0..2);\n            slice[0].1.push_str(\" updated\");\n            slice[1].1.push_str(\" updated\");\n        }\n\n        assert_eq!(map.index(&1), \"one updated\");\n        assert_eq!(map.index(&2), \"two updated\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_mut_out_of_bounds() {\n        let mut map: IndexMap<i32, String> = IndexMap::new();\n        map.insert(1, \"one\".to_string());\n\n        // Attempt to access invalid index\n        let _ = map.index_mut(2);\n    }\n}\n```", "map::slice::<impl core::ops::IndexMut<core::ops::RangeFull> for map::IndexMap<K, V, S>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_mut_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        // Get mutable references to a range\n        {\n            let slice = map.index_mut(1..3);\n            slice[0].1 = \"modified_one\";\n            slice[1].1 = \"modified_two\";\n        }\n\n        // Verify that changes were made\n        assert_eq!(map[1], \"modified_one\");\n        assert_eq!(map[2], \"modified_two\");\n        assert_eq!(map[3], \"three\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_mut_range_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        // Attempt to mutate out of bounds\n        let _slice = map.index_mut(0..3);\n    }\n\n    #[test]\n    fn test_index_mut_single() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        // Mutate a single index\n        {\n            let value = map.index_mut(0);\n            value.1 = \"modified_one\";\n        }\n\n        assert_eq!(map[1], \"modified_one\");\n        assert_eq!(map[2], \"two\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_mut_single_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"one\");\n        \n        // Attempt to access out of bounds\n        let _value = map.index_mut(1);\n    }\n}\n```", "map::slice::<impl core::ops::IndexMut<core::ops::RangeInclusive<usize>> for map::IndexMap<K, V, S>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn index_mut_range_inclusive() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"A\");\n        map.insert(2, \"B\");\n        map.insert(3, \"C\");\n\n        {\n            let slice = map.index_mut(1..=2);\n            assert_eq!(slice[0], \"B\");\n            assert_eq!(slice[1], \"C\");\n\n            slice[0] = \"X\"; // Modify the value at the first index in the range\n        }\n\n        assert_eq!(map[1], \"X\");\n        assert_eq!(map[2], \"B\");\n        assert_eq!(map[3], \"C\");\n    }\n\n    #[test]\n    fn index_mut_range_inclusive_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"A\");\n        map.insert(2, \"B\");\n\n        let slice = map.index_mut(0..=1);\n        assert_eq!(slice[0], \"A\");\n        assert_eq!(slice[1], \"B\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn index_mut_out_of_bounds() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"A\");\n        map.insert(2, \"B\");\n\n        let _slice = map.index_mut(1..=2);\n        let _out_of_bounds = map.index_mut(2..=3); // This should panic\n    }\n}\n```", "map::slice::<impl core::ops::IndexMut<core::ops::RangeTo<usize>> for map::IndexMap<K, V, S>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_mut_range() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        // Get mutable slice reference for a range\n        let slice = map.index_mut(1..3);\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice[0], \"two\");\n        assert_eq!(slice[1], \"three\");\n\n        // Modify value through mutable slice\n        slice[0] = \"TWO\";\n        assert_eq!(map.index(1), &\"TWO\");\n        assert_eq!(map.index(2), &\"two\");\n    }\n\n    #[test]\n    fn test_index_mut_full_range() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        // Get mutable slice reference for the whole range\n        let slice = map.index_mut(..);\n        assert_eq!(slice.len(), 3);\n        assert_eq!(slice[0], \"one\");\n        assert_eq!(slice[1], \"two\");\n        assert_eq!(slice[2], \"three\");\n\n        // Modify value through mutable slice\n        slice[1] = \"TWO\";\n        assert_eq!(map.index(2), &\"TWO\");\n    }\n\n    #[should_panic(expected = \"index out of bounds\")]\n    #[test]\n    fn test_index_mut_out_of_bounds() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        // This should panic as it goes out of bounds\n        map.index_mut(2..5);\n    }\n}\n```", "map::slice::<impl core::ops::IndexMut<core::ops::RangeToInclusive<usize>> for map::IndexMap<K, V, S>>::index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_mut() {\n        let mut map = IndexMap::new();\n        map.insert(0, \"zero\");\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        {\n            let slice = map.index_mut(1..=2);\n            slice[0] = \"uno\";\n            slice[1] = \"dos\";\n        }\n\n        assert_eq!(map[0], \"zero\");\n        assert_eq!(map[1], \"uno\");\n        assert_eq!(map[2], \"dos\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 3 but the index is 3\")]\n    fn test_index_mut_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(0, \"zero\");\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        let _slice = map.index_mut(0..=3);  // This should panic\n    }\n\n    #[test]\n    fn test_index_mut_empty() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(0, \"zero\");\n\n        {\n            let slice = map.index_mut(0..=0);\n            slice[0] = \"updated\";\n        }\n\n        assert_eq!(map[0], \"updated\");\n    }\n}\n```", "map::slice::Slice::<K, V>::binary_search_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_binary_search_by_found() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by(|k, v| if *k == 2 { Ordering::Equal } else if *k < 2 { Ordering::Less } else { Ordering::Greater });\n        assert_eq!(result, Ok(1));\n    }\n\n    #[test]\n    fn test_binary_search_by_not_found() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by(|k, v| if *k == 4 { Ordering::Equal } else if *k < 4 { Ordering::Less } else { Ordering::Greater });\n        assert_eq!(result, Err(2)); // 4 would go at index 2\n    }\n\n    #[test]\n    fn test_binary_search_by_first_element() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by(|k, v| if *k == 1 { Ordering::Equal } else { Ordering::Greater });\n        assert_eq!(result, Ok(0));\n    }\n\n    #[test]\n    fn test_binary_search_by_last_element() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by(|k, v| if *k == 3 { Ordering::Equal } else { Ordering::Less });\n        assert_eq!(result, Ok(2));\n    }\n\n    #[test]\n    fn test_binary_search_by_empty_slice() {\n        let entries: [Bucket<i32, &str>; 0] = [];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by(|k, v| Ordering::Equal);\n        assert_eq!(result, Err(0)); // Empty slice, so insertion point is 0\n    }\n}\n```", "map::slice::Slice::<K, V>::binary_search_by_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::cmp::Ordering;\n\n    #[test]\n    fn test_binary_search_by_key_found() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by_key(&2, |k, _| *k);\n        assert_eq!(result, Ok(1));\n    }\n\n    #[test]\n    fn test_binary_search_by_key_not_found() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 3, value: \"three\" },\n            Bucket { hash: HashValue(3), key: 4, value: \"four\" },\n        ];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by_key(&2, |k, _| *k);\n        assert_eq!(result, Err(1)); // Should be inserted at index 1\n    }\n\n    #[test]\n    fn test_binary_search_by_key_insert_position() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by_key(&4, |k, _| *k);\n        assert_eq!(result, Err(3)); // Should be inserted at index 3\n    }\n\n    #[test]\n    fn test_binary_search_by_key_empty() {\n        let entries: [Bucket<i32, &str>; 0] = [];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by_key(&1, |k, _| *k);\n        assert_eq!(result, Err(0)); // Should be inserted at index 0\n    }\n}\n```", "map::slice::Slice::<K, V>::binary_search_keys": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_binary_search_keys_present() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"b\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"c\" },\n        ];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.binary_search_keys(&2), Ok(1));\n        assert_eq!(slice.binary_search_keys(&1), Ok(0));\n        assert_eq!(slice.binary_search_keys(&3), Ok(2));\n    }\n\n    #[test]\n    fn test_binary_search_keys_not_present() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"b\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"c\" },\n        ];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.binary_search_keys(&0), Err(0));\n        assert_eq!(slice.binary_search_keys(&4), Err(3));\n        assert_eq!(slice.binary_search_keys(&2), Ok(1));\n    }\n\n    #[test]\n    fn test_binary_search_keys_empty_slice() {\n        let entries: [] = [];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.binary_search_keys(&1), Err(0));\n    }\n}\n```", "map::slice::Slice::<K, V>::first": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_first() {\n        let bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let bucket2 = Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" };\n        let slice = Slice { entries: [bucket1, bucket2] };\n\n        let first = slice.first();\n        assert_eq!(first, Some((&\"key1\", &\"value1\")));\n    }\n\n    #[test]\n    fn test_first_empty() {\n        let slice: Slice<&str, &str> = Slice { entries: [] };\n        \n        let first = slice.first();\n        assert_eq!(first, None);\n    }\n}\n```", "map::slice::Slice::<K, V>::first_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_first_mut() {\n        // Arrange\n        let mut slice = Slice {\n            entries: [\n                Bucket {\n                    hash: HashValue(1),\n                    key: \"key1\",\n                    value: 1,\n                },\n                Bucket {\n                    hash: HashValue(2),\n                    key: \"key2\",\n                    value: 2,\n                },\n            ],\n        };\n\n        // Act\n        let first_mut = slice.first_mut();\n\n        // Assert\n        assert!(first_mut.is_some());\n        if let Some((key, value)) = first_mut {\n            assert_eq!(key, &\"key1\");\n            *value += 1; // Modify value\n        }\n        assert_eq!(slice.entries[0].value, 2); // Check if value was modified\n    }\n\n    #[test]\n    fn test_first_mut_empty_slice() {\n        // Arrange\n        let mut slice: Slice<&str, i32> = Slice { entries: [] };\n\n        // Act\n        let first_mut = slice.first_mut();\n\n        // Assert\n        assert!(first_mut.is_none());\n    }\n}\n```", "map::slice::Slice::<K, V>::from_boxed": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n    use alloc::boxed::Box;\n\n    #[test]\n    fn test_from_boxed() {\n        let entries: Box<[Bucket<i32, String>]> = Box::new([\n            Bucket::Occupied(1, String::from(\"one\")),\n            Bucket::Occupied(2, String::from(\"two\")),\n        ]);\n\n        let slice: Box<Slice<i32, String>> = Slice::from_boxed(entries);\n        \n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice[0], (1, String::from(\"one\")));\n        assert_eq!(slice[1], (2, String::from(\"two\")));\n    }\n}\n```", "map::slice::Slice::<K, V>::from_mut_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Layout;\n\n    #[test]\n    fn test_from_mut_slice() {\n        // Define test data\n        let mut buckets: [Bucket<i32, String>; 3] = [\n            Bucket {\n                hash: HashValue(1),\n                key: 1,\n                value: \"One\".to_string(),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: 2,\n                value: \"Two\".to_string(),\n            },\n            Bucket {\n                hash: HashValue(3),\n                key: 3,\n                value: \"Three\".to_string(),\n            },\n        ];\n\n        // Create a mutable slice\n        let len = buckets.len();\n        let slice: &mut Slice<i32, String> = Slice::from_mut_slice(&mut buckets);\n\n        // Check the length of the Slice\n        assert_eq!(slice.len(), len);\n        // Validate the contents of the Slice\n        assert_eq!(slice.get_index(0), Some((&1, &\"One\".to_string())));\n        assert_eq!(slice.get_index(1), Some((&2, &\"Two\".to_string())));\n        assert_eq!(slice.get_index(2), Some((&3, &\"Three\".to_string())));\n    }\n}\n```", "map::slice::Slice::<K, V>::from_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[derive(Clone, Debug, PartialEq, Eq)]\n    struct TestKey(usize);\n    #[derive(Clone, Debug, PartialEq, Eq)]\n    struct TestValue(String);\n\n    fn create_bucket_array() -> [Bucket<TestKey, TestValue>; 3] {\n        [\n            Bucket {\n                hash: HashValue(1),\n                key: TestKey(1),\n                value: TestValue(\"Value1\".to_string()),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: TestKey(2),\n                value: TestValue(\"Value2\".to_string()),\n            },\n            Bucket {\n                hash: HashValue(3),\n                key: TestKey(3),\n                value: TestValue(\"Value3\".to_string()),\n            },\n        ]\n    }\n\n    #[test]\n    fn test_from_slice() {\n        let buckets = create_bucket_array();\n        let slice: &Slice<TestKey, TestValue> = Slice::from_slice(&buckets);\n\n        assert_eq!(slice.len(), 3);\n        assert_eq!(slice.get_index(0), Some((&TestKey(1), &TestValue(\"Value1\".to_string()))));\n        assert_eq!(slice.get_index(1), Some((&TestKey(2), &TestValue(\"Value2\".to_string()))));\n        assert_eq!(slice.get_index(2), Some((&TestKey(3), &TestValue(\"Value3\".to_string()))));\n        assert!(slice.get_index(3).is_none());\n    }\n\n    #[test]\n    fn test_from_slice_empty() {\n        let buckets: &[Bucket<TestKey, TestValue>] = &[];\n        let slice: &Slice<TestKey, TestValue> = Slice::from_slice(buckets);\n\n        assert_eq!(slice.len(), 0);\n        assert!(slice.is_empty());\n    }\n}\n```", "map::slice::Slice::<K, V>::get_disjoint_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_get_disjoint_mut_valid_indices() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(0), key: \"key1\", value: 1 },\n                Bucket { hash: HashValue(1), key: \"key2\", value: 2 },\n                Bucket { hash: HashValue(2), key: \"key3\", value: 3 },\n            ],\n        };\n        \n        let result: Result<[(&str, &mut i32); 2], _> = slice.get_disjoint_mut([0, 2]);\n        assert!(result.is_ok());\n        let pairs = result.unwrap();\n        assert_eq!(pairs[0].0, \"key1\");\n        assert_eq!(pairs[1].0, \"key3\");\n    }\n\n    #[test]\n    fn test_get_disjoint_mut_overlapping_indices() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(0), key: \"key1\", value: 1 },\n                Bucket { hash: HashValue(1), key: \"key2\", value: 2 },\n                Bucket { hash: HashValue(2), key: \"key3\", value: 3 },\n            ],\n        };\n\n        let result: Result<[(&str, &mut i32); 2], _> = slice.get_disjoint_mut([0, 0]);\n        assert!(result.is_err());\n        assert_eq!(result.err(), Some(GetDisjointMutError::OverlappingIndices));\n    }\n\n    #[test]\n    fn test_get_disjoint_mut_out_of_bounds() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(0), key: \"key1\", value: 1 },\n                Bucket { hash: HashValue(1), key: \"key2\", value: 2 },\n                Bucket { hash: HashValue(2), key: \"key3\", value: 3 },\n            ],\n        };\n\n        let result: Result<[(&str, &mut i32); 2], _> = slice.get_disjoint_mut([0, 3]);\n        assert!(result.is_err());\n        assert_eq!(result.err(), Some(GetDisjointMutError::IndexOutOfBounds));\n    }\n\n    #[test]\n    fn test_get_disjoint_mut_empty_slice() {\n        let mut slice = Slice {\n            entries: [],\n        };\n\n        let result: Result<[(&str, &mut i32); 1], _> = slice.get_disjoint_mut([0]);\n        assert!(result.is_err());\n        assert_eq!(result.err(), Some(GetDisjointMutError::IndexOutOfBounds));\n    }\n}\n```", "map::slice::Slice::<K, V>::get_disjoint_opt_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n    \n    #[test]\n    fn test_get_disjoint_opt_mut_valid_indices() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n                Bucket { hash: HashValue(3), key: \"key3\", value: \"value3\" },\n            ],\n        };\n        let indices = [Some(0), Some(2)];\n        let result = slice.get_disjoint_opt_mut(indices);\n        assert!(result.is_ok());\n        let result_values = result.unwrap();\n        assert_eq!(result_values[0].as_ref().unwrap().0, &\"key1\");\n        assert_eq!(result_values[1].as_ref().unwrap().0, &\"key3\");\n    }\n\n    #[test]\n    fn test_get_disjoint_opt_mut_out_of_bounds() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            ],\n        };\n        let indices = [Some(0), Some(3)];\n        let result = slice.get_disjoint_opt_mut(indices);\n        assert!(result.is_err());\n        assert_eq!(result.err(), Some(GetDisjointMutError::IndexOutOfBounds));\n    }\n\n    #[test]\n    fn test_get_disjoint_opt_mut_overlapping_indices() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            ],\n        };\n        let indices = [Some(0), Some(0)];\n        let result = slice.get_disjoint_opt_mut(indices);\n        assert!(result.is_err());\n        assert_eq!(result.err(), Some(GetDisjointMutError::OverlappingIndices));\n    }\n\n    #[test]\n    fn test_get_disjoint_opt_mut_none_indices() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            ],\n        };\n        let indices = [None, None];\n        let result = slice.get_disjoint_opt_mut(indices);\n        assert!(result.is_ok());\n        let result_values = result.unwrap();\n        assert_eq!(result_values, [None, None]);\n    }\n}\n```", "map::slice::Slice::<K, V>::get_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_get_index_valid() {\n        let bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let bucket2 = Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" };\n        let buckets = [bucket1, bucket2];\n\n        let slice = Slice { entries: buckets };\n        \n        let result = slice.get_index(0);\n        assert_eq!(result, Some((&\"key1\", &\"value1\")));\n\n        let result = slice.get_index(1);\n        assert_eq!(result, Some((&\"key2\", &\"value2\")));\n    }\n\n    #[test]\n    fn test_get_index_out_of_bounds() {\n        let bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let buckets = [bucket1];\n\n        let slice = Slice { entries: buckets };\n        \n        let result = slice.get_index(1);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_index_empty_slice() {\n        let buckets: [Bucket<&str, &str>; 0] = [];\n        let slice = Slice { entries: buckets };\n        \n        let result = slice.get_index(0);\n        assert_eq!(result, None);\n    }\n}\n```", "map::slice::Slice::<K, V>::get_index_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::borrow::Cow;\n\n    #[test]\n    fn test_get_index_mut() {\n        let mut slice = Slice {\n            entries: [\n                Bucket {\n                    hash: HashValue(1),\n                    key: \"key1\",\n                    value: 10,\n                },\n                Bucket {\n                    hash: HashValue(2),\n                    key: \"key2\",\n                    value: 20,\n                },\n            ],\n        };\n\n        let result = slice.get_index_mut(1);\n        assert!(result.is_some());\n        if let Some((key, value)) = result {\n            assert_eq!(*key, \"key2\");\n            *value += 5;\n        }\n        assert_eq!(slice.get_index(1).unwrap().1, &25);\n    }\n\n    #[test]\n    fn test_get_index_mut_out_of_bounds() {\n        let mut slice = Slice {\n            entries: [\n                Bucket {\n                    hash: HashValue(1),\n                    key: \"key1\",\n                    value: 10,\n                },\n            ],\n        };\n\n        let result = slice.get_index_mut(1);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_index_mut_empty_slice() {\n        let mut slice: Slice<_, _> = Slice { entries: [] };\n\n        let result = slice.get_index_mut(0);\n        assert!(result.is_none());\n    }\n}\n```", "map::slice::Slice::<K, V>::get_range": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_get_range_valid() {\n        let bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let bucket2 = Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" };\n        let entries = vec![bucket1, bucket2];\n        let slice = Slice { entries: entries.try_into().unwrap() };\n\n        // Test valid range\n        let range = 0..2;\n        let result = slice.get_range(range);\n        assert!(result.is_some());\n        assert_eq!(result.unwrap().len(), 2);\n    }\n\n    #[test]\n    fn test_get_range_empty() {\n        let entries: Vec<Bucket<&str, &str>> = Vec::new();\n        let slice = Slice { entries: entries.try_into().unwrap() };\n\n        // Test range on empty slice\n        let range = 0..1;\n        let result = slice.get_range(range);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_range_out_of_bounds() {\n        let bucket = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let entries = vec![bucket];\n        let slice = Slice { entries: entries.try_into().unwrap() };\n\n        // Test range that exceeds bounds\n        let range = 1..2;\n        let result = slice.get_range(range);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_range_single() {\n        let bucket = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let entries = vec![bucket];\n        let slice = Slice { entries: entries.try_into().unwrap() };\n\n        // Test range for single entry\n        let range = 0..1;\n        let result = slice.get_range(range);\n        assert!(result.is_some());\n        assert_eq!(result.unwrap().len(), 1);\n    }\n}\n```", "map::slice::Slice::<K, V>::get_range_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_get_range_mut_valid_range() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n                Bucket { hash: HashValue(3), key: \"key3\", value: \"value3\" },\n            ],\n        };\n\n        let range = 0..2;\n        let result = slice.get_range_mut(range);\n\n        assert!(result.is_some());\n        let mut result_slice = result.unwrap();\n        assert_eq!(result_slice.len(), 2);\n        result_slice.entries[0].value_mut() = \"new_value1\";\n        assert_eq!(slice.entries[0].value_ref(), &\"new_value1\");\n    }\n\n    #[test]\n    fn test_get_range_mut_invalid_range() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            ],\n        };\n\n        let range = 2..4; // Out of bounds\n        let result = slice.get_range_mut(range);\n\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_range_mut_empty_slice() {\n        let mut slice = Slice { entries: [] };\n\n        let range = 0..1; // Valid range but slice is empty\n        let result = slice.get_range_mut(range);\n\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_range_mut_full_slice() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            ],\n        };\n\n        let range = 0..2;\n        let result = slice.get_range_mut(range);\n\n        assert!(result.is_some());\n        let mut result_slice = result.unwrap();\n        assert_eq!(result_slice.len(), 2);\n        result_slice.entries[1].value_mut() = \"new_value2\";\n        assert_eq!(slice.entries[1].value_ref(), &\"new_value2\");\n    }\n}\n```", "map::slice::Slice::<K, V>::into_boxed": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_into_boxed() {\n        let slice = Box::new(Slice::from_vec(vec![(1, \"a\"), (2, \"b\")]));\n        let boxed: Box<[Bucket<i32, &str>]> = slice.into_boxed();\n\n        assert_eq!(boxed.len(), 2);\n        assert_eq!(&boxed[0], &(1, \"a\"));\n        assert_eq!(&boxed[1], &(2, \"b\"));\n    }\n\n    #[test]\n    fn test_into_boxed_empty() {\n        let slice: Box<Slice<i32, &str>> = Box::new(Slice::from_vec(vec![]));\n        let boxed: Box<[Bucket<i32, &str>]> = slice.into_boxed();\n\n        assert_eq!(boxed.len(), 0);\n    }\n}\n```", "map::slice::Slice::<K, V>::into_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Ensure to include your module imports\n    use indexmap::map::slice::Slice; // Adjust the import path as necessary\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_into_entries() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        \n        let slice: Box<Slice<_, _>> = Box::from(&slice::from_entries(map.into_iter().collect::<Vec<_>>()));\n        \n        let entries = slice.into_entries();\n        \n        assert_eq!(entries.len(), 3);\n        assert!(entries.contains(&(1, 10)));\n        assert!(entries.contains(&(2, 20)));\n        assert!(entries.contains(&(3, 30)));\n    }\n}\n```", "map::slice::Slice::<K, V>::into_keys": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_into_keys() {\n        let mut map = Box::new(Slice::default());\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let keys: Vec<_> = map.into_keys().collect();\n        assert_eq!(keys, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_into_keys_empty() {\n        let map: Box<Slice<i32, &str>> = Box::new(Slice::default());\n        let keys: Vec<_> = map.into_keys().collect();\n        assert!(keys.is_empty());\n    }\n\n    #[test]\n    fn test_into_keys_clone() {\n        let mut map = Box::new(Slice::default());\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let keys1: Vec<_> = map.into_keys().collect();\n        let keys2: Vec<_> = map.clone().into_keys().collect();\n        assert_eq!(keys1, keys2);\n    }\n}\n```", "map::slice::Slice::<K, V>::into_values": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming this is in the same module, adjust import paths as necessary\n    use indexmap::map::slice::Slice;\n\n    #[test]\n    fn test_into_values() {\n        // Create a sample Slice with some key-value pairs\n        let keys = vec![1, 2, 3];\n        let values = vec![\"a\", \"b\", \"c\"];\n        let slice = Slice::from_boxed(Box::from(keys.iter().zip(values.iter()).collect::<Vec<_>>().into_boxed_slice()));\n\n        // Convert Slice into a Box\n        let boxed_slice: Box<Slice<_, _>> = Box::from(&slice);\n\n        // Call the into_values method\n        let values_iterator = boxed_slice.into_values();\n\n        // Collect the values into a Vec\n        let collected_values: Vec<_> = values_iterator.collect();\n\n        // Check if the collected values match the expected values\n        assert_eq!(collected_values, vec![\"a\", \"b\", \"c\"]);\n    }\n}\n```", "map::slice::Slice::<K, V>::is_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n    use crate::Bucket;\n    use crate::HashValue;\n\n    #[test]\n    fn test_is_empty() {\n        // Test with an empty slice\n        let empty_slice: &Slice<i32, i32> = Slice::new();\n        assert!(empty_slice.is_empty());\n\n        // Test with a non-empty slice\n        let non_empty_slice: Slice<i32, i32> = Slice {\n            entries: [Bucket {\n                hash: HashValue(1),\n                key: 1,\n                value: 100,\n            }],\n        };\n        assert!(!non_empty_slice.is_empty());\n    }\n}\n```", "map::slice::Slice::<K, V>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_iter() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n            Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n        ];\n\n        let slice = Slice { entries: buckets };\n\n        let mut iter = slice.iter();\n        assert_eq!(iter.len(), 2);\n        assert_eq!(iter.next(), Some((&\"key1\", &\"value1\")));\n        assert_eq!(iter.next(), Some((&\"key2\", &\"value2\")));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_empty_slice() {\n        let buckets: &[Bucket<&str, &str>] = &[];\n        let slice = Slice { entries: *buckets };\n\n        let mut iter = slice.iter();\n        assert!(iter.is_empty());\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "map::slice::Slice::<K, V>::iter_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_iter_mut() {\n        let mut buckets = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n            Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            Bucket { hash: HashValue(3), key: \"key3\", value: \"value3\" },\n        ];\n\n        let mut slice = Slice { entries: buckets };\n\n        let mut iter = slice.iter_mut();\n        \n        // Test the number of elements\n        assert_eq!(iter.len(), 3);\n\n        // Test if we can get mutable references to keys and values\n        if let Some((key_ref, value_ref)) = iter.next() {\n            assert_eq!(key_ref, &\"key1\");\n            *value_ref = \"new_value1\";\n        }\n\n        if let Some((key_ref, value_ref)) = iter.next() {\n            assert_eq!(key_ref, &\"key2\");\n            *value_ref = \"new_value2\";\n        }\n\n        // Test the modified values\n        assert_eq!(slice.entries[0].value_ref(), &\"new_value1\");\n        assert_eq!(slice.entries[1].value_ref(), &\"new_value2\");\n    }\n}\n```", "map::slice::Slice::<K, V>::keys": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming the `Slice`, `Bucket`, and `Keys` implementations are in scope\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_keys_empty() {\n        let slice: Slice<i32, i32> = Slice { entries: [] };\n        let keys: Vec<_> = slice.keys().collect();\n        assert!(keys.is_empty());\n    }\n\n    #[test]\n    fn test_keys_single_entry() {\n        let bucket = Bucket {\n            hash: HashValue(1),\n            key: 42,\n            value: \"value\",\n        };\n        let slice: Slice<i32, &str> = Slice { entries: [bucket] };\n        let keys: Vec<_> = slice.keys().collect();\n        assert_eq!(keys, vec![&42]);\n    }\n\n    #[test]\n    fn test_keys_multiple_entries() {\n        let buckets = [\n            Bucket {\n                hash: HashValue(1),\n                key: 1,\n                value: \"one\",\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: 2,\n                value: \"two\",\n            },\n            Bucket {\n                hash: HashValue(3),\n                key: 3,\n                value: \"three\",\n            },\n        ];\n        let slice: Slice<i32, &str> = Slice { entries: buckets };\n        let keys: Vec<_> = slice.keys().collect();\n        assert_eq!(keys, vec![&1, &2, &3]);\n    }\n}\n```", "map::slice::Slice::<K, V>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_last() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n            Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            Bucket { hash: HashValue(3), key: \"key3\", value: \"value3\" },\n        ];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.last(), Some((&\"key3\", &\"value3\")));\n    }\n\n    #[test]\n    fn test_last_empty() {\n        let entries: [Bucket<&str, &str>; 0] = [];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.last(), None);\n    }\n\n    #[test]\n    fn test_last_single_element() {\n        let entries = [Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" }];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.last(), Some((&\"key1\", &\"value1\")));\n    }\n}\n```", "map::slice::Slice::<K, V>::last_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_last_mut() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            ],\n        };\n        \n        let last_entry = slice.last_mut();\n        assert!(last_entry.is_some());\n        \n        if let Some((key, value)) = last_entry {\n            assert_eq!(*key, \"key2\");\n            *value = \"modified_value2\";  // Mutable access\n        }\n\n        // Check if the modification took effect\n        assert_eq!(slice.last().unwrap().1, \"modified_value2\");\n    }\n\n    #[test]\n    fn test_last_mut_empty_slice() {\n        let mut empty_slice: Slice<&str, &str> = Slice { entries: [] };\n        \n        let last_entry = empty_slice.last_mut();\n        assert!(last_entry.is_none());\n    }\n}\n```", "map::slice::Slice::<K, V>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_len_empty_slice() {\n        let slice: Slice<i32, i32> = Slice { entries: [] };\n        assert_eq!(slice.len(), 0);\n    }\n\n    #[test]\n    fn test_len_non_empty_slice() {\n        let slice = Slice {\n            entries: [\n                Bucket {\n                    hash: HashValue(1),\n                    key: 1,\n                    value: 10,\n                },\n                Bucket {\n                    hash: HashValue(2),\n                    key: 2,\n                    value: 20,\n                },\n            ],\n        };\n        assert_eq!(slice.len(), 2);\n    }\n\n    #[test]\n    fn test_len_large_slice() {\n        let entries = (0..100).map(|i| Bucket {\n            hash: HashValue(i),\n            key: i,\n            value: i * 10,\n        }).collect::<Vec<_>>();\n        let slice = Slice { entries: entries.try_into().unwrap() };\n        assert_eq!(slice.len(), 100);\n    }\n\n    #[test]\n    fn test_len_with_identical_keys() {\n        let slice = Slice {\n            entries: [\n                Bucket {\n                    hash: HashValue(1),\n                    key: 1,\n                    value: 10,\n                },\n                Bucket {\n                    hash: HashValue(1),\n                    key: 1,\n                    value: 20,\n                },\n            ],\n        };\n        assert_eq!(slice.len(), 2);\n    }\n}\n```", "map::slice::Slice::<K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Make sure to import the necessary components from the current module.\n    \n    #[test]\n    fn test_slice_new() {\n        let slice: &Slice<i32, i32> = Slice::new();\n        assert!(slice.is_empty());\n        assert_eq!(slice.len(), 0);\n    }\n}\n```", "map::slice::Slice::<K, V>::new_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::map::slice::Slice;\n    use super::Bucket;\n\n    #[test]\n    fn test_new_mut_creates_empty_slice() {\n        let slice: &mut Slice<i32, i32> = Slice::new_mut();\n        assert!(slice.is_empty());\n        assert_eq!(slice.len(), 0);\n    }\n}\n```", "map::slice::Slice::<K, V>::partition_point": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cmp::PartialOrd;\n\n    #[test]\n    fn test_partition_point() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: 'a' },\n            Bucket { hash: HashValue(2), key: 2, value: 'b' },\n            Bucket { hash: HashValue(3), key: 3, value: 'c' },\n            Bucket { hash: HashValue(4), key: 4, value: 'd' },\n        ];\n        \n        let slice = Slice { entries };\n\n        let pred = |key: &i32, value: &char| *key < 3;\n        \n        let index = slice.partition_point(pred);\n        \n        assert_eq!(index, 2, \"Expected partition index to be 2\");\n    }\n\n    #[test]\n    fn test_partition_point_no_elements() {\n        let entries: [Bucket<i32, char>; 0] = [];\n        \n        let slice = Slice { entries };\n\n        let pred = |_: &i32, _: &char| false;\n        \n        let index = slice.partition_point(pred);\n        \n        assert_eq!(index, 0, \"Expected partition index to be 0 for empty slice\");\n    }\n\n    #[test]\n    fn test_partition_point_all_elements() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: 'a' },\n            Bucket { hash: HashValue(2), key: 2, value: 'b' },\n            Bucket { hash: HashValue(3), key: 3, value: 'c' },\n        ];\n        \n        let slice = Slice { entries };\n\n        let pred = |key: &i32, _: &char| *key < 1;\n        \n        let index = slice.partition_point(pred);\n        \n        assert_eq!(index, 0, \"Expected partition index to be 0\");\n    }\n\n    #[test]\n    fn test_partition_point_mixed() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: 'a' },\n            Bucket { hash: HashValue(2), key: 2, value: 'b' },\n            Bucket { hash: HashValue(3), key: 4, value: 'd' },\n        ];\n        \n        let slice = Slice { entries };\n\n        let pred = |key: &i32, _: &char| *key < 3;\n        \n        let index = slice.partition_point(pred);\n        \n        assert_eq!(index, 2, \"Expected partition index to be 2 for mixed entries\");\n    }\n}\n```", "map::slice::Slice::<K, V>::split_at": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_split_at() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n            Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            Bucket { hash: HashValue(3), key: \"key3\", value: \"value3\" },\n        ];\n        let slice = Slice { entries };\n\n        let (left, right) = slice.split_at(2);\n        \n        assert_eq!(left.len(), 2);\n        assert_eq!(right.len(), 1);\n        assert_eq!(left.get_index(0), Some((&\"key1\", &\"value1\")));\n        assert_eq!(left.get_index(1), Some((&\"key2\", &\"value2\")));\n        assert_eq!(right.get_index(0), Some((&\"key3\", &\"value3\")));\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_split_at_panic() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n        ];\n        let slice = Slice { entries };\n\n        slice.split_at(2); // This should panic\n    }\n\n    #[test]\n    fn test_split_at_empty() {\n        let entries: [Bucket<&str, &str>; 0] = [];\n        let slice = Slice { entries };\n\n        let (left, right) = slice.split_at(0);\n        \n        assert_eq!(left.len(), 0);\n        assert_eq!(right.len(), 0);\n    }\n}\n```", "map::slice::Slice::<K, V>::split_at_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n\n    #[test]\n    fn test_split_at_mut() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n                Bucket { hash: HashValue(3), key: \"key3\", value: \"value3\" },\n            ]\n        };\n\n        let (left, right) = slice.split_at_mut(2);\n\n        assert_eq!(left.len(), 2);\n        assert_eq!(right.len(), 1);\n        assert_eq!(left.get_index(0), Some((&\"key1\", &\"value1\")));\n        assert_eq!(left.get_index(1), Some((&\"key2\", &\"value2\")));\n        assert_eq!(right.get_index(0), Some((&\"key3\", &\"value3\")));\n    }\n\n    #[should_panic]\n    #[test]\n    fn test_split_at_mut_panics_out_of_bounds() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            ]\n        };\n\n        let _ = slice.split_at_mut(3); // This should panic\n    }\n}\n```", "map::slice::Slice::<K, V>::split_first": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::marker::PhantomData;\n\n    struct TestK(u32);\n    struct TestV(String);\n\n    impl Clone for TestK {\n        fn clone(&self) -> Self {\n            TestK(self.0)\n        }\n    }\n\n    impl Clone for TestV {\n        fn clone(&self) -> Self {\n            TestV(self.0.clone())\n        }\n    }\n\n    impl PartialEq for TestK {\n        fn eq(&self, other: &Self) -> bool {\n            self.0 == other.0\n        }\n    }\n\n    impl PartialEq for TestV {\n        fn eq(&self, other: &Self) -> bool {\n            self.0 == other.0\n        }\n    }\n\n    #[test]\n    fn test_split_first_non_empty() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: TestK(1),\n            value: TestV(String::from(\"value1\")),\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: TestK(2),\n            value: TestV(String::from(\"value2\")),\n        };\n        let slice = Slice {\n            entries: [bucket1, bucket2],\n        };\n        \n        let result = slice.split_first();\n        assert!(result.is_some());\n\n        let ((key, value), rest) = result.unwrap();\n        assert_eq!(key.0, 1);\n        assert_eq!(value.0, \"value1\");\n        assert_eq!(rest.len(), 1);\n    }\n\n    #[test]\n    fn test_split_first_empty() {\n        let slice: Slice<TestK, TestV> = Slice {\n            entries: [],\n        };\n        \n        let result = slice.split_first();\n        assert!(result.is_none());\n    }\n}\n```", "map::slice::Slice::<K, V>::split_first_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_split_first_mut_non_empty() {\n        let mut bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let mut bucket2 = Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" };\n        let mut slice = Slice { entries: [bucket1, bucket2] };\n\n        let result = slice.split_first_mut();\n        assert!(result.is_some());\n\n        let ((key, value), rest) = result.unwrap();\n        assert_eq!(key, &\"key1\");\n        assert_eq!(*value, \"value1\");\n        assert_eq!(rest.len(), 1);\n        assert_eq!(rest.get_index(0), Some((&\"key2\", &\"value2\")));\n    }\n\n    #[test]\n    fn test_split_first_mut_empty() {\n        let mut slice: Slice<String, String> = Slice { entries: [] };\n\n        let result = slice.split_first_mut();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_split_first_mut_single_element() {\n        let mut bucket = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let mut slice = Slice { entries: [bucket] };\n\n        let result = slice.split_first_mut();\n        assert!(result.is_some());\n\n        let ((key, value), rest) = result.unwrap();\n        assert_eq!(key, &\"key1\");\n        assert_eq!(*value, \"value1\");\n        assert!(rest.is_empty());\n    }\n\n    #[test]\n    fn test_modify_value_after_split_first_mut() {\n        let mut bucket = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let mut slice = Slice { entries: [bucket] };\n\n        let result = slice.split_first_mut().unwrap();\n        let (_, value) = result.0;\n        *value = \"modified_value\";\n\n        assert_eq!(slice.get_index(0), Some((&\"key1\", &\"modified_value\")));\n    }\n}\n```", "map::slice::Slice::<K, V>::split_last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n\n    #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n    struct TestKey(usize);\n    \n    #[derive(Clone, Debug, PartialEq, Eq)]\n    struct TestValue(String);\n\n    #[test]\n    fn test_split_last_non_empty() {\n        let buckets = [\n            Bucket {\n                hash: HashValue(1),\n                key: TestKey(1),\n                value: TestValue(\"value1\".to_string()),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: TestKey(2),\n                value: TestValue(\"value2\".to_string()),\n            },\n        ];\n\n        let slice = Slice { entries: buckets };\n\n        let result = slice.split_last();\n        assert!(result.is_some());\n\n        if let Some(((last_key, last_value), rest_slice)) = result {\n            assert_eq!(last_key, &TestKey(2));\n            assert_eq!(last_value, &TestValue(\"value2\".to_string()));\n            assert_eq!(rest_slice.len(), 1);\n            assert_eq!(rest_slice.get_index(0).unwrap(), (&TestKey(1), &TestValue(\"value1\".to_string())));\n        }\n    }\n\n    #[test]\n    fn test_split_last_empty() {\n        let buckets: [Bucket<TestKey, TestValue>; 0] = [];\n        let slice = Slice { entries: buckets };\n\n        let result = slice.split_last();\n        assert!(result.is_none());\n    }\n}\n```", "map::slice::Slice::<K, V>::split_last_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_split_last_mut_non_empty() {\n        // Create a mutable Slice with 3 Bucket entries\n        let mut entries = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: 10 },\n            Bucket { hash: HashValue(2), key: \"key2\", value: 20 },\n            Bucket { hash: HashValue(3), key: \"key3\", value: 30 },\n        ];\n        let mut slice = Slice { entries };\n\n        // Call split_last_mut\n        let result = slice.split_last_mut().unwrap();\n\n        // Assert the last key-value pair and rest of the slice\n        let (last_pair, rest_slice) = result;\n        assert_eq!(last_pair.0, &\"key3\");\n        assert_eq!(*last_pair.1, 30);\n        assert_eq!(rest_slice.len(), 2);\n        assert_eq!(rest_slice.entries[0].value, 10);\n        assert_eq!(rest_slice.entries[1].value, 20);\n    }\n\n    #[test]\n    fn test_split_last_mut_empty() {\n        // Create an empty Slice\n        let mut entries: [Bucket<&str, i32>; 0] = [];\n        let mut slice = Slice { entries };\n\n        // Call split_last_mut\n        let result = slice.split_last_mut();\n\n        // Assert that the result is None\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_split_last_mut_after_mutation() {\n        // Create a mutable Slice with 2 Bucket entries\n        let mut entries = [\n            Bucket { hash: HashValue(1), key: \"key1\", value: 10 },\n            Bucket { hash: HashValue(2), key: \"key2\", value: 20 },\n        ];\n        let mut slice = Slice { entries };\n\n        // Call split_last_mut\n        let result = slice.split_last_mut().unwrap();\n        let (last_pair, _rest_slice) = result;\n\n        // Mutate the last value\n        *last_pair.1 += 5;\n\n        // Assert that the last key-value pair has the updated value\n        assert_eq!(*last_pair.1, 25);\n    }\n}\n```", "map::slice::Slice::<K, V>::values": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n    use crate::Bucket;\n\n    #[test]\n    fn test_values() {\n        let bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let bucket2 = Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" };\n        let entries = [bucket1, bucket2];\n        let slice = Slice { entries };\n\n        let mut values_iter = slice.values();\n        assert_eq!(values_iter.next(), Some(&\"value1\"));\n        assert_eq!(values_iter.next(), Some(&\"value2\"));\n        assert_eq!(values_iter.next(), None);\n    }\n\n    #[test]\n    fn test_values_empty() {\n        let entries: [Bucket<&str, &str>; 0] = [];\n        let slice = Slice { entries };\n        \n        let mut values_iter = slice.values();\n        assert_eq!(values_iter.next(), None);\n    }\n\n    #[test]\n    fn test_values_length() {\n        let bucket1 = Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" };\n        let bucket2 = Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" };\n        let entries = [bucket1, bucket2];\n        let slice = Slice { entries };\n\n        let values_iter = slice.values();\n        assert_eq!(values_iter.len(), 2);\n    }\n}\n```", "map::slice::Slice::<K, V>::values_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::slice::Slice;\n    \n    #[test]\n    fn test_values_mut() {\n        let mut slice = Slice {\n            entries: [\n                Bucket { hash: HashValue(1), key: \"key1\", value: \"value1\" },\n                Bucket { hash: HashValue(2), key: \"key2\", value: \"value2\" },\n            ],\n        };\n\n        let mut values_iter = slice.values_mut();\n\n        assert_eq!(values_iter.len(), 2);\n        assert_eq!(*values_iter.next().unwrap(), \"value1\");\n        assert_eq!(*values_iter.next().unwrap(), \"value2\");\n\n        // Modify values through the iterator\n        if let Some(first_value) = values_iter.next() {\n            *first_value = \"modified_value1\";\n        }\n\n        // Check if the modifications are reflected in the slice\n        assert_eq!(slice.entries[0].value_ref(), &\"modified_value1\");\n    }\n}\n```", "set::IndexSet::<T, S>::append": "```rust\n#[cfg(test)]\nmod tests {\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_append() {\n        let mut a = IndexSet::from([3, 2, 1]);\n        let mut b = IndexSet::from([3, 4, 5]);\n        let old_capacity = b.capacity();\n\n        a.append(&mut b);\n\n        assert_eq!(a.len(), 5);\n        assert_eq!(b.len(), 0);\n        assert_eq!(b.capacity(), old_capacity);\n        assert!(a.iter().eq(&[3, 2, 1, 4, 5]));\n    }\n\n    #[test]\n    fn test_append_empty() {\n        let mut a = IndexSet::from([1, 2, 3]);\n        let mut b: IndexSet<u32> = IndexSet::new();\n\n        a.append(&mut b);\n\n        assert_eq!(a.len(), 3);\n        assert_eq!(b.len(), 0);\n    }\n\n    #[test]\n    fn test_append_existing_entries() {\n        let mut a = IndexSet::from([1, 2, 3]);\n        let mut b = IndexSet::from([2, 3, 4]);\n        let old_capacity = b.capacity();\n\n        a.append(&mut b);\n\n        assert_eq!(a.len(), 4);\n        assert_eq!(b.len(), 0);\n        assert_eq!(b.capacity(), old_capacity);\n        assert!(a.iter().eq(&[1, 2, 3, 4]));\n    }\n\n    #[test]\n    fn test_append_persisted_order() {\n        let mut a = IndexSet::from([1, 3, 5]);\n        let mut b = IndexSet::from([2, 4, 4]); // Note duplicated \"4\"\n\n        a.append(&mut b);\n\n        assert_eq!(a.len(), 5);\n        assert!(a.iter().eq(&[1, 3, 5, 2, 4]));\n    }\n}\n```", "set::IndexSet::<T, S>::as_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_as_slice() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let slice = set.as_slice();\n        assert_eq!(slice.len(), 3);\n        assert_eq!(slice[0], 1);\n        assert_eq!(slice[1], 2);\n        assert_eq!(slice[2], 3);\n    }\n\n    #[test]\n    fn test_as_slice_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        let slice = set.as_slice();\n        assert_eq!(slice.len(), 0);\n    }\n\n    #[test]\n    fn test_as_slice_duplicates() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(1);\n        set.insert(2);\n        \n        let slice = set.as_slice();\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice[0], 1);\n        assert_eq!(slice[1], 2);\n    }\n}\n```", "set::IndexSet::<T, S>::binary_search": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_binary_search_found() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let result = set.binary_search(&2);\n        assert_eq!(result, Ok(1));\n    }\n\n    #[test]\n    fn test_binary_search_not_found() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let result = set.binary_search(&4);\n        assert_eq!(result, Err(3));\n    }\n\n    #[test]\n    fn test_binary_search_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        let result = set.binary_search(&1);\n        assert_eq!(result, Err(0));\n    }\n\n    #[test]\n    fn test_binary_search_multiple_inserts() {\n        let mut set = IndexSet::new();\n        set.insert(3);\n        set.insert(1);\n        set.insert(2);\n\n        let result = set.binary_search(&1);\n        assert_eq!(result, Ok(0));\n    }\n\n    #[test]\n    fn test_binary_search_with_duplicates() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(1);\n        set.insert(1);\n\n        let result = set.binary_search(&1);\n        assert_eq!(result, Ok(0));\n    }\n}\n```", "set::IndexSet::<T, S>::binary_search_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_binary_search_by_found() {\n        let set: IndexSet<i32> = (1..=5).collect();\n        let result = set.binary_search_by(|&x| {\n            if x < 3 {\n                Ordering::Less\n            } else if x > 3 {\n                Ordering::Greater\n            } else {\n                Ordering::Equal\n            }\n        });\n        assert_eq!(result, Ok(2)); // 3 is at index 2\n    }\n\n    #[test]\n    fn test_binary_search_by_not_found_insert_position() {\n        let set: IndexSet<i32> = (1..=5).collect();\n        let result = set.binary_search_by(|&x| {\n            if x < 3 {\n                Ordering::Less\n            } else if x > 4 {\n                Ordering::Greater\n            } else {\n                Ordering::Equal\n            }\n        });\n        assert_eq!(result, Err(3)); // 4 is at index 3; the position to insert 4 is 3\n    }\n\n    #[test]\n    fn test_binary_search_by_empty_set() {\n        let set: IndexSet<i32> = IndexSet::new();\n        let result = set.binary_search_by(|&x| {\n            if x < 5 {\n                Ordering::Less\n            } else {\n                Ordering::Greater\n            }\n        });\n        assert_eq!(result, Err(0)); // Inserting 5 would go at index 0\n    }\n\n    #[test]\n    fn test_binary_search_by_with_custom_ordering() {\n        let set: IndexSet<String> = [\"apple\", \"orange\", \"banana\"].iter().cloned().collect();\n        let result = set.binary_search_by(|x| {\n            if x < \"banana\" {\n                Ordering::Less\n            } else if x > \"banana\" {\n                Ordering::Greater\n            } else {\n                Ordering::Equal\n            }\n        });\n        assert_eq!(result, Ok(2)); // \"banana\" is at index 2\n    }\n}\n```", "set::IndexSet::<T, S>::binary_search_by_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_binary_search_by_key_existing_key() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let result = set.binary_search_by_key(&2, |&x| x);\n        assert_eq!(result, Ok(1));\n    }\n\n    #[test]\n    fn test_binary_search_by_key_non_existing_key() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(3);\n        set.insert(5);\n\n        let result = set.binary_search_by_key(&2, |&x| x);\n        assert_eq!(result, Err(1));\n    }\n\n    #[test]\n    fn test_binary_search_by_key_insert_position() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(3);\n        set.insert(5);\n\n        let result = set.binary_search_by_key(&4, |&x| x);\n        assert_eq!(result, Err(2));\n    }\n\n    #[test]\n    fn test_binary_search_by_key_empty_set() {\n        let set: IndexSet<i32> = IndexSet::new();\n        let result = set.binary_search_by_key(&1, |&x| x);\n        assert_eq!(result, Err(0));\n    }\n\n    #[test]\n    fn test_binary_search_by_key_multiple_elements() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(2);\n        set.insert(3);\n\n        let result = set.binary_search_by_key(&2, |&x| x);\n        assert_eq!(result, Ok(1)); // Should return Ok(1) for the first occurrence\n    }\n\n    #[test]\n    fn test_binary_search_by_key_with_custom_key_func() {\n        let mut set: IndexSet<String> = IndexSet::new();\n        set.insert(\"apple\".into());\n        set.insert(\"banana\".into());\n        set.insert(\"cherry\".into());\n\n        let result = set.binary_search_by_key(&\"banana\", |s| s);\n        assert_eq!(result, Ok(1));\n    }\n}\n```", "set::IndexSet::<T, S>::capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_capacity_empty_set() {\n        let set: IndexSet<i32> = IndexSet::new();\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_with_capacity() {\n        let mut set = IndexSet::with_capacity(10);\n        assert!(set.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_capacity_with_elements() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert!(set.capacity() >= 3);\n    }\n\n    #[test]\n    fn test_capacity_after_removal() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let capacity_before_removal = set.capacity();\n        set.remove(&1);\n        assert!(set.capacity() >= 2);\n        assert_eq!(capacity_before_removal, set.capacity());\n    }\n\n    #[test]\n    fn test_capacity_after_clear() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.clear();\n        assert_eq!(set.capacity(), 0);\n    }\n}\n```", "set::IndexSet::<T, S>::clear": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_clear_on_empty_index_set() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.clear();\n        assert!(index_set.is_empty());\n    }\n\n    #[test]\n    fn test_clear_on_non_empty_index_set() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.clear();\n        assert!(index_set.is_empty());\n    }\n\n    #[test]\n    fn test_clear_preserves_capacity() {\n        let mut index_set: IndexSet<i32> = IndexSet::with_capacity(10);\n        index_set.insert(1);\n        index_set.insert(2);\n        let capacity_before = index_set.capacity();\n        index_set.clear();\n        assert_eq!(index_set.capacity(), capacity_before);\n    }\n\n    #[test]\n    fn test_clear_does_not_panic() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.clear(); // should not panic\n    }\n}\n```", "set::IndexSet::<T, S>::contains": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_contains() {\n        // Creating an IndexSet\n        let mut set: IndexSet<i32> = IndexSet::new();\n\n        // Adding elements to the set\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        // Test cases\n        assert!(set.contains(&1)); // should return true\n        assert!(set.contains(&2)); // should return true\n        assert!(set.contains(&3)); // should return true\n        assert!(!set.contains(&4)); // should return false\n        assert!(!set.contains(&0)); // should return false\n    }\n\n    #[test]\n    fn test_contains_empty_set() {\n        // Creating an empty IndexSet\n        let set: IndexSet<i32> = IndexSet::new();\n\n        // Test cases\n        assert!(!set.contains(&1)); // should return false\n        assert!(!set.contains(&2)); // should return false\n    }\n\n    #[test]\n    fn test_contains_with_different_types() {\n        // Creating an IndexSet for strings\n        let mut set: IndexSet<&str> = IndexSet::new();\n\n        // Adding elements to the set\n        set.insert(\"hello\");\n        set.insert(\"world\");\n\n        // Test cases\n        assert!(set.contains(&\"hello\")); // should return true\n        assert!(set.contains(&\"world\")); // should return true\n        assert!(!set.contains(&\"rust\")); // should return false\n    }\n}\n```", "set::IndexSet::<T, S>::difference": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_difference() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        let mut set_b: IndexSet<i32> = IndexSet::new();\n\n        set_a.insert(1);\n        set_a.insert(2);\n        set_a.insert(3);\n\n        set_b.insert(2);\n        set_b.insert(3);\n        set_b.insert(4);\n\n        let difference: Vec<i32> = set_a.difference(&set_b).collect();\n        assert_eq!(difference, vec![1]);\n    }\n\n    #[test]\n    fn test_difference_empty_other() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        let set_b: IndexSet<i32> = IndexSet::new();\n\n        set_a.insert(1);\n        set_a.insert(2);\n        \n        let difference: Vec<i32> = set_a.difference(&set_b).collect();\n        assert_eq!(difference, vec![1, 2]);\n    }\n\n    #[test]\n    fn test_difference_empty_self() {\n        let set_a: IndexSet<i32> = IndexSet::new();\n        let mut set_b: IndexSet<i32> = IndexSet::new();\n\n        set_b.insert(2);\n        set_b.insert(3);\n        \n        let difference: Vec<i32> = set_a.difference(&set_b).collect();\n        assert_eq!(difference, Vec::<i32>::new());\n    }\n\n    #[test]\n    fn test_difference_no_common_elements() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        let mut set_b: IndexSet<i32> = IndexSet::new();\n\n        set_a.insert(1);\n        set_a.insert(2);\n\n        set_b.insert(3);\n        set_b.insert(4);\n        \n        let difference: Vec<i32> = set_a.difference(&set_b).collect();\n        assert_eq!(difference, vec![1, 2]);\n    }\n\n    #[test]\n    fn test_difference_all_common_elements() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        let mut set_b: IndexSet<i32> = IndexSet::new();\n\n        set_a.insert(1);\n        set_a.insert(2);\n        set_a.insert(3);\n\n        set_b.insert(1);\n        set_b.insert(2);\n        set_b.insert(3);\n        \n        let difference: Vec<i32> = set_a.difference(&set_b).collect();\n        assert_eq!(difference, Vec::<i32>::new());\n    }\n}\n```", "set::IndexSet::<T, S>::drain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    #[should_panic]\n    fn test_drain_panic_start_greater_than_end() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.drain(1..0); // This should panic\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_drain_panic_end_greater_than_length() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.drain(0..3); // This should panic\n    }\n\n    #[test]\n    fn test_drain_entire_set() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        let drained: Vec<_> = set.drain(..).collect();\n        \n        assert_eq!(drained, vec![1, 2]);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_drain_partial_set() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let drained: Vec<_> = set.drain(1..3).collect(); // Drench index 1 and 2\n        \n        assert_eq!(drained, vec![2, 3]);\n        assert!(set.contains(&1));\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_drain_empty_set() {\n        let mut set: IndexSet<u32> = IndexSet::new();\n        let drained: Vec<_> = set.drain(..).collect();\n        \n        assert!(drained.is_empty());\n        assert!(set.is_empty());\n    }\n}\n```", "set::IndexSet::<T, S>::first": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_first_non_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        assert_eq!(set.first(), Some(&1));\n    }\n\n    #[test]\n    fn test_first_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        assert_eq!(set.first(), None);\n    }\n\n    #[test]\n    fn test_first_with_duplicates() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(1);\n\n        assert_eq!(set.first(), Some(&1));\n    }\n    \n    #[test]\n    fn test_first_after_removal() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.remove(&1);\n\n        assert_eq!(set.first(), Some(&2));\n    }\n}\n```", "set::IndexSet::<T, S>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_existing_key() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.get(&2), Some(&2));\n    }\n\n    #[test]\n    fn test_get_non_existing_key() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.get(&4), None);\n    }\n\n    #[test]\n    fn test_get_key_from_empty_set() {\n        let set: IndexSet<i32> = IndexSet::new();\n        assert_eq!(set.get(&1), None);\n    }\n\n    #[test]\n    fn test_get_key_with_equivalent() {\n        #[derive(Hash, Eq, PartialEq)]\n        struct Key {\n            id: i32,\n        }\n\n        let mut set: IndexSet<Key> = IndexSet::new();\n        set.insert(Key { id: 1 });\n        set.insert(Key { id: 2 });\n        assert_eq!(set.get(&Key { id: 2 }), Some(&Key { id: 2 }));\n    }\n\n    #[test]\n    fn test_get_key_with_different_reference() {\n        #[derive(Hash, Eq, PartialEq)]\n        struct Key {\n            id: i32,\n        }\n\n        let mut set: IndexSet<Key> = IndexSet::new();\n        set.insert(Key { id: 1 });\n        set.insert(Key { id: 2 });\n        let key_reference = &Key { id: 2 };\n        assert_eq!(set.get(key_reference), Some(&Key { id: 2 }));\n    }\n}\n```", "set::IndexSet::<T, S>::get_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_full_existing_key() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(10);\n        set.insert(20);\n        set.insert(30);\n        \n        let result = set.get_full(&20);\n        assert_eq!(result, Some((1, &20)));\n    }\n\n    #[test]\n    fn test_get_full_non_existing_key() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(10);\n        set.insert(20);\n        \n        let result = set.get_full(&30);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_full_empty_set() {\n        let set: IndexSet<i32> = IndexSet::new();\n        \n        let result = set.get_full(&10);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_full_multiple_insertions() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(1); // Duplicate insertion\n        \n        let result = set.get_full(&1);\n        assert_eq!(result, Some((0, &1)));\n        \n        let result = set.get_full(&2);\n        assert_eq!(result, Some((1, &2)));\n    }\n}\n```", "set::IndexSet::<T, S>::get_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_get_index_with_valid_index() {\n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        set.insert(\"b\");\n        set.insert(\"c\");\n        \n        assert_eq!(set.get_index(0), Some(&\"a\"));\n        assert_eq!(set.get_index(1), Some(&\"b\"));\n        assert_eq!(set.get_index(2), Some(&\"c\"));\n    }\n\n    #[test]\n    fn test_get_index_with_invalid_index() {\n        let set = IndexSet::<&str>::new();\n        \n        assert_eq!(set.get_index(0), None);\n        \n        let mut set = IndexSet::new();\n        set.insert(\"a\");\n        set.insert(\"b\");\n        \n        assert_eq!(set.get_index(2), None);\n    }\n\n    #[test]\n    fn test_get_index_boundary_cases() {\n        let mut set = IndexSet::new();\n        set.insert(\"first\");\n        assert_eq!(set.get_index(0), Some(&\"first\"));\n        \n        set.insert(\"second\");\n        assert_eq!(set.get_index(1), Some(&\"second\"));\n        \n        assert_eq!(set.get_index(2), None);\n    }\n\n    #[test]\n    fn test_get_index_empty_set() {\n        let set: IndexSet<&str> = IndexSet::new();\n        assert_eq!(set.get_index(0), None);\n    }\n}\n```", "set::IndexSet::<T, S>::get_index_of": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_index_of_existing() {\n        let mut index_map = IndexMap::new();\n        index_map.insert(\"key1\", 1);\n        index_map.insert(\"key2\", 2);\n\n        assert_eq!(index_map.get_index_of(\"key1\"), Some(0));\n        assert_eq!(index_map.get_index_of(\"key2\"), Some(1));\n    }\n\n    #[test]\n    fn test_get_index_of_non_existing() {\n        let index_map = IndexMap::new();\n        assert_eq!(index_map.get_index_of(\"key\"), None);\n    }\n\n    #[test]\n    fn test_get_index_of_empty() {\n        let index_map: IndexMap<&str, i32> = IndexMap::new();\n        assert_eq!(index_map.get_index_of(\"key\"), None);\n    }\n\n    #[test]\n    fn test_get_index_of_with_equivalence() {\n        let mut index_map = IndexMap::new();\n        index_map.insert(\"duplicate\", 1);\n        index_map.insert(\"duplicate\", 2);  // Note: This may overwrite the previous value\n\n        assert_eq!(index_map.get_index_of(\"duplicate\"), Some(0));\n    }\n\n    #[test]\n    fn test_get_index_of_with_different_types() {\n        let mut index_map = IndexMap::new();\n        index_map.insert(\"1\", 10);\n\n        assert_eq!(index_map.get_index_of(&1), Some(0));\n        assert_eq!(index_map.get_index_of(\"1\"), Some(0));\n        assert_eq!(index_map.get_index_of(\"2\"), None);\n    }\n}\n```", "set::IndexSet::<T, S>::get_range": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_get_range_valid() {\n        let mut index_set = IndexMap::new();\n        index_set.insert(0, 'a');\n        index_set.insert(1, 'b');\n        index_set.insert(2, 'c');\n        \n        let result = index_set.get_range(1..3);\n        let expected = Some(&Slice::new(&[(1, 'b'), (2, 'c')]));\n        \n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_get_range_out_of_bounds() {\n        let mut index_set = IndexMap::new();\n        index_set.insert(0, 'a');\n\n        let result = index_set.get_range(1..2);\n        let expected: Option<&Slice<_, _>> = None;\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_get_range_empty() {\n        let index_set: IndexMap<u32, char> = IndexMap::new();\n        \n        let result = index_set.get_range(0..1);\n        let expected: Option<&Slice<_, _>> = None;\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_get_range_exceeding_bounds() {\n        let mut index_set = IndexMap::new();\n        index_set.insert(0, 'a');\n        index_set.insert(1, 'b');\n        \n        let result = index_set.get_range(0..4);\n        let expected = Some(&Slice::new(&[(0, 'a'), (1, 'b')]));\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_get_range_full_range() {\n        let mut index_set = IndexMap::new();\n        index_set.insert(0, 'a');\n        index_set.insert(1, 'b');\n        index_set.insert(2, 'c');\n\n        let result = index_set.get_range(0..3);\n        let expected = Some(&Slice::new(&[(0, 'a'), (1, 'b'), (2, 'c')]));\n\n        assert_eq!(result, expected);\n    }\n}\n```", "set::IndexSet::<T, S>::hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::BuildHasherDefault;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_hasher() {\n        let mut set: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let hasher_reference = set.hasher();\n        assert!(hasher_reference != std::ptr::null());\n        assert_eq!(hasher_reference.clone().build_hasher().finish(), hasher_reference.build_hasher().finish());\n    }\n\n    #[test]\n    fn test_hasher_with_custom_builder() {\n        let mut set: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::with_hasher(BuildHasherDefault::default());\n        set.insert(1);\n        set.insert(2);\n\n        let hasher_reference = set.hasher();\n        assert!(hasher_reference != std::ptr::null());\n        assert_eq!(hasher_reference.clone().build_hasher().finish(), hasher_reference.build_hasher().finish());\n    }\n\n    #[test]\n    fn test_hasher_with_empty_set() {\n        let set: IndexSet<i32, BuildHasherDefault<RandomState>> = IndexSet::new();\n        let hasher_reference = set.hasher();\n        assert!(hasher_reference != std::ptr::null());\n    }\n}\n```", "set::IndexSet::<T, S>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_insert_unique() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        assert!(set.insert(1));\n        assert!(set.insert(2));\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_insert_duplicate() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        assert!(set.insert(1));\n        assert!(!set.insert(1));\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_insert_order() {\n        let mut set: IndexSet<char> = IndexSet::new();\n        assert!(set.insert('a'));\n        assert!(set.insert('b'));\n        assert!(set.insert('c'));\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec!['a', 'b', 'c']);\n    }\n\n    #[test]\n    fn test_insert_and_retain_order() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        assert!(set.insert(1));\n        assert!(set.insert(2));\n        assert!(set.insert(3));\n        assert!(!set.insert(2)); // Duplicate\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![&1, &2, &3]);\n    }\n\n    #[test]\n    fn test_insert_return() {\n        let mut set: IndexSet<String> = IndexSet::new();\n        assert!(set.insert(\"foo\".to_string()));\n        assert!(!set.insert(\"foo\".to_string())); // Duplicate should return false\n    }\n\n    #[test]\n    fn test_insert_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        assert!(set.insert(10));\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_insert_order_preservation() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(3);\n        set.insert(2);\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![&1, &3, &2]);\n    }\n\n    #[test]\n    fn test_insert_non_default() {\n        let mut set: IndexSet<String> = IndexSet::new();\n        assert!(set.insert(\"Rust\".to_string()));\n        assert!(set.insert(\"Language\".to_string()));\n        assert_eq!(set.len(), 2);\n    }\n}\n```", "set::IndexSet::<T, S>::insert_before": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_insert_before() {\n        let mut set: IndexSet<char> = IndexSet::new();\n        set.extend('a'..='z');\n\n        // Test inserting a new value '*'\n        assert_eq!(set.get_index_of(&'*'), None);\n        assert_eq!(set.insert_before(10, '*'), (10, true));\n        assert_eq!(set.get_index_of(&'*'), Some(10));\n\n        // Test moving an existing value 'a' up\n        assert_eq!(set.insert_before(10, 'a'), (9, false));\n        assert_eq!(set.get_index_of(&'a'), Some(9));\n        assert_eq!(set.get_index_of(&'*'), Some(10));\n\n        // Test moving an existing value 'z' down\n        assert_eq!(set.insert_before(10, 'z'), (10, false));\n        assert_eq!(set.get_index_of(&'z'), Some(10));\n        assert_eq!(set.get_index_of(&'*'), Some(11));\n\n        // Test inserting before the endpoint\n        assert_eq!(set.insert_before(set.len(), '*'), (26, false));\n        assert_eq!(set.get_index_of(&'*'), Some(26));\n        assert_eq!(set.insert_before(set.len(), '+'), (27, true));\n        assert_eq!(set.get_index_of(&'+'), Some(27));\n        assert_eq!(set.len(), 28);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 26 but the index is 27. Expected index <= len\")]\n    fn test_insert_before_out_of_bounds() {\n        let mut set: IndexSet<char> = IndexSet::new();\n        set.extend('a'..='z');\n        // This should panic since index is out of bounds\n        let _ = set.insert_before(27, 'x');\n    }\n}\n```", "set::IndexSet::<T, S>::insert_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_insert_full_new_entry() {\n        let mut set = IndexSet::new();\n        let (index, inserted) = set.insert_full(42);\n        assert_eq!(index, 0);\n        assert!(inserted);\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&42));\n    }\n\n    #[test]\n    fn test_insert_full_existing_entry() {\n        let mut set = IndexSet::new();\n        set.insert(42);\n        let (index, inserted) = set.insert_full(42);\n        assert_eq!(index, 0);\n        assert!(!inserted);\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_insert_full_multiple_entries() {\n        let mut set = IndexSet::new();\n        let (index1, inserted1) = set.insert_full(1);\n        let (index2, inserted2) = set.insert_full(2);\n        let (index3, inserted3) = set.insert_full(1);\n        \n        assert_eq!(index1, 0); // First insert goes to index 0\n        assert_eq!(index2, 1); // Second insert goes to index 1\n        assert!(!inserted3);    // Re-inserting the same value\n        assert!(inserted1);\n        assert!(inserted2);\n        assert_eq!(set.len(), 2); // Should have only 2 unique items\n    }\n\n    #[test]\n    fn test_insert_full_ordering() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        let (index3, inserted3) = set.insert_full(3);\n        assert_eq!(index3, 2); // 3 goes to index 2\n        assert!(inserted3);\n        assert_eq!(set.len(), 3);\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![1, 2, 3]); // Should maintain insertion order\n    }\n}\n```", "set::IndexSet::<T, S>::insert_sorted": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_insert_sorted() {\n        let mut set = IndexSet::new();\n        assert_eq!(set.insert_sorted(5), (0, true)); // Inserting first element\n        assert_eq!(set.insert_sorted(3), (0, true)); // Inserting before\n        assert_eq!(set.insert_sorted(4), (1, true)); // Inserting in between\n        assert_eq!(set.insert_sorted(5), (2, false)); // Inserting duplicate\n        assert_eq!(set.insert_sorted(2), (0, true)); // Inserting before all\n        assert_eq!(set.insert_sorted(6), (5, true)); // Inserting at the end\n    }\n\n    #[test]\n    fn test_insert_sorted_with_order() {\n        let mut set = IndexSet::new();\n        assert_eq!(set.insert_sorted(10), (0, true)); // Inserting 10\n        assert_eq!(set.insert_sorted(20), (1, true)); // Inserting 20\n        assert_eq!(set.insert_sorted(15), (1, true)); // Inserting 15 in between\n        assert_eq!(set.insert_sorted(20), (3, false)); // Inserting duplicate 20\n        assert_eq!(set.insert_sorted(5), (0, true)); // Inserting 5 at start\n        assert_eq!(set.insert_sorted(25), (5, true)); // Inserting at end\n    }\n\n    #[test]\n    fn test_insert_sorted_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        assert_eq!(set.insert_sorted(1), (0, true)); // First element in empty set\n    }\n}\n```", "set::IndexSet::<T, S>::intersection": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_intersection() {\n        let set1: IndexSet<&str> = [\"a\", \"b\", \"c\"].iter().copied().collect();\n        let set2: IndexSet<&str> = [\"b\", \"c\", \"d\"].iter().copied().collect();\n\n        let intersection: Vec<_> = set1.intersection(&set2).collect();\n        \n        assert_eq!(intersection, vec![\"b\", \"c\"]);\n    }\n\n    #[test]\n    fn test_intersection_no_common_elements() {\n        let set1: IndexSet<&str> = [\"a\", \"b\"].iter().copied().collect();\n        let set2: IndexSet<&str> = [\"c\", \"d\"].iter().copied().collect();\n\n        let intersection: Vec<_> = set1.intersection(&set2).collect();\n        \n        assert!(intersection.is_empty());\n    }\n\n    #[test]\n    fn test_intersection_empty_set() {\n        let set1: IndexSet<&str> = [\"a\", \"b\"].iter().copied().collect();\n        let set2: IndexSet<&str> = IndexSet::new();\n\n        let intersection: Vec<_> = set1.intersection(&set2).collect();\n        \n        assert!(intersection.is_empty());\n    }\n\n    #[test]\n    fn test_intersection_self() {\n        let set: IndexSet<&str> = [\"a\", \"b\", \"c\"].iter().copied().collect();\n\n        let intersection: Vec<_> = set.intersection(&set).collect();\n        \n        assert_eq!(intersection, vec![\"a\", \"b\", \"c\"]);\n    }\n\n    #[test]\n    fn test_intersection_with_different_order() {\n        let set1: IndexSet<&str> = [\"a\", \"b\", \"c\"].iter().copied().collect();\n        let set2: IndexSet<&str> = [\"c\", \"a\", \"b\"].iter().copied().collect();\n\n        let intersection: Vec<_> = set1.intersection(&set2).collect();\n        \n        assert_eq!(intersection, vec![\"a\", \"b\", \"c\"]);\n    }\n}\n```", "set::IndexSet::<T, S>::into_boxed_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_boxed_slice() {\n        let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n        \n        let boxed_slice = index_set.into_boxed_slice();\n\n        assert_eq!(boxed_slice.len(), 3);\n        assert_eq!(boxed_slice[0], 1);\n        assert_eq!(boxed_slice[1], 2);\n        assert_eq!(boxed_slice[2], 3);\n    }\n\n    #[test]\n    fn test_into_boxed_slice_empty() {\n        let index_set: IndexSet<i32, RandomState> = IndexSet::new();\n        let boxed_slice = index_set.into_boxed_slice();\n\n        assert_eq!(boxed_slice.len(), 0);\n    }\n}\n```", "set::IndexSet::<T, S>::is_disjoint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_is_disjoint_with_no_common_elements() {\n        let set1: IndexSet<i32> = (1..=3).collect();\n        let set2: IndexSet<i32> = (4..=6).collect();\n        assert!(set1.is_disjoint(&set2));\n    }\n\n    #[test]\n    fn test_is_disjoint_with_common_elements() {\n        let set1: IndexSet<i32> = (1..=3).collect();\n        let set2: IndexSet<i32> = (3..=5).collect();\n        assert!(!set1.is_disjoint(&set2));\n    }\n\n    #[test]\n    fn test_is_disjoint_with_empty_set() {\n        let set1: IndexSet<i32> = (1..=3).collect();\n        let set2: IndexSet<i32> = IndexSet::new();\n        assert!(set1.is_disjoint(&set2));\n    }\n\n    #[test]\n    fn test_is_disjoint_with_identical_sets() {\n        let set1: IndexSet<i32> = (1..=3).collect();\n        let set2 = set1.clone();\n        assert!(!set1.is_disjoint(&set2));\n    }\n\n    #[test]\n    fn test_is_disjoint_larger_sets() {\n        let set1: IndexSet<i32> = (1..=5).collect();\n        let set2: IndexSet<i32> = (6..=10).collect();\n        assert!(set1.is_disjoint(&set2));\n\n        let set3: IndexSet<i32> = (4..=8).collect();\n        assert!(!set1.is_disjoint(&set3));\n    }\n}\n```", "set::IndexSet::<T, S>::is_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming your module imports the necessary items\n    use indexmap::IndexMap; // Assuming `IndexMap` is necessary for the tests\n\n    #[test]\n    fn test_is_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        assert!(set.is_empty());\n\n        let mut set_with_elements = IndexSet::new();\n        set_with_elements.insert(1);\n        assert!(!set_with_elements.is_empty());\n\n        set_with_elements.remove(&1);\n        assert!(set_with_elements.is_empty());\n    }\n}\n```", "set::IndexSet::<T, S>::is_subset": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_is_subset() {\n        let set1: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![1, 2, 3]);\n        let set2: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![1, 2, 3, 4, 5]);\n        let set3: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![4, 5, 6]);\n\n        assert!(set1.is_subset(&set2));\n        assert!(!set1.is_subset(&set3));\n        assert!(set1.is_subset(&set1)); // A set is always a subset of itself\n        assert!(!set3.is_subset(&set1)); // Distinct elements\n    }\n\n    #[test]\n    fn test_is_subset_empty() {\n        let set1: IndexSet<i32, RandomState> = IndexSet::new();\n        let set2: IndexSet<i32, RandomState> = IndexSet::new();\n        let set3: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![1, 2, 3]);\n\n        assert!(set1.is_subset(&set2)); // Both empty\n        assert!(!set3.is_subset(&set1)); // Non-empty is not subset of empty\n    }\n\n    #[test]\n    fn test_is_subset_same_elements_different_order() {\n        let set1: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![3, 2, 1]);\n        let set2: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![1, 2, 3]);\n\n        assert!(set1.is_subset(&set2));\n        assert!(set2.is_subset(&set1));\n    }\n}\n```", "set::IndexSet::<T, S>::is_superset": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_is_superset() {\n        let mut set_a: IndexSet<i32> = IndexSet::new();\n        set_a.insert(1);\n        set_a.insert(2);\n        set_a.insert(3);\n\n        let mut set_b: IndexSet<i32> = IndexSet::new();\n        set_b.insert(1);\n        set_b.insert(2);\n\n        let mut set_c: IndexSet<i32> = IndexSet::new();\n        set_c.insert(1);\n        set_c.insert(4);\n\n        assert!(set_a.is_superset(&set_b));\n        assert!(!set_a.is_superset(&set_c));\n        assert!(set_b.is_superset(&IndexSet::new())); // subset of empty\n        assert!(!set_c.is_superset(&set_a)); // set_c doesn't contain all of set_a\n    }\n\n    #[test]\n    fn test_is_superset_empty() {\n        let set_a: IndexSet<i32> = IndexSet::new();\n        let set_b: IndexSet<i32> = IndexSet::new();\n        let set_c: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3]);\n\n        assert!(set_a.is_superset(&set_b)); // empty set is superset of empty\n        assert!(!set_a.is_superset(&set_c)); // empty set is not superset of non-empty\n    }\n}\n```", "set::IndexSet::<T, S>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_iter() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let mut iter = set.iter();\n        assert_eq!(iter.next(), Some(&1));\n        assert_eq!(iter.next(), Some(&2));\n        assert_eq!(iter.next(), Some(&3));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_empty_iter() {\n        let set: IndexSet<i32> = IndexSet::new();\n        let mut iter = set.iter();\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_ordered_iter() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(3);\n        set.insert(1);\n        set.insert(2);\n\n        let mut iter = set.iter();\n        assert_eq!(iter.next(), Some(&3));\n        assert_eq!(iter.next(), Some(&1));\n        assert_eq!(iter.next(), Some(&2));\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "set::IndexSet::<T, S>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_last_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        assert_eq!(set.last(), None);\n    }\n\n    #[test]\n    fn test_last_one_element() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        assert_eq!(set.last(), Some(&1));\n    }\n\n    #[test]\n    fn test_last_multiple_elements() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.last(), Some(&3));\n    }\n\n    #[test]\n    fn test_last_elements_after_removal() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.remove(&2);\n        assert_eq!(set.last(), Some(&3));\n    }\n\n    #[test]\n    fn test_last_after_removal_of_last() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.remove(&3);\n        assert_eq!(set.last(), Some(&2));\n    }\n\n    #[test]\n    fn test_last_removing_all_elements() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.remove(&1);\n        set.remove(&2);\n        assert_eq!(set.last(), None);\n    }\n}\n```", "set::IndexSet::<T, S>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_len() {\n        let set: IndexSet<i32> = IndexSet::new();\n        assert_eq!(set.len(), 0);\n\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        assert_eq!(set.len(), 2);\n\n        set.remove(&1);\n        assert_eq!(set.len(), 1);\n\n        set.clear();\n        assert_eq!(set.len(), 0);\n    }\n}\n```", "set::IndexSet::<T, S>::move_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds: the len is 0 but the index is 0\")]\n    fn test_move_index_out_of_bounds() {\n        let mut set: IndexSet<u32> = IndexSet::new();\n        set.move_index(0, 1);\n    }\n\n    #[test]\n    fn test_move_index() {\n        let mut set: IndexSet<u32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        // Moving an element up\n        set.move_index(2, 0);\n        assert_eq!(set.iter().copied().collect::<Vec<_>>(), vec![3, 1, 2]);\n\n        // Moving an element down\n        set.move_index(0, 2);\n        assert_eq!(set.iter().copied().collect::<Vec<_>>(), vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_move_index_shift_up() {\n        let mut set: IndexSet<u32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        // Move 2 to the start, expect shift up\n        set.move_index(1, 0);\n        assert_eq!(set.iter().copied().collect::<Vec<_>>(), vec![2, 1, 3]);\n    }\n\n    #[test]\n    fn test_move_index_shift_down() {\n        let mut set: IndexSet<u32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        // Move 2 to the end, expect shift down\n        set.move_index(0, 2);\n        assert_eq!(set.iter().copied().collect::<Vec<_>>(), vec![1, 3, 2]);\n    }\n}\n```", "set::IndexSet::<T, S>::partition_point": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_partition_point() {\n        let set: IndexSet<i32> = (0..10).collect();\n\n        // Test partition point with a predicate that is true for values less than 5\n        let index = set.partition_point(|&x| x < 5);\n        assert_eq!(index, 5, \"Partition point should be at index 5\");\n\n        // Test partition point with a predicate that is true for values less than 0\n        let index = set.partition_point(|&x| x < 0);\n        assert_eq!(index, 0, \"Partition point should be at index 0\");\n\n        // Test partition point with a predicate that is true for values less than 10\n        let index = set.partition_point(|&x| x < 10);\n        assert_eq!(index, 10, \"Partition point should be at index 10\");\n\n        // Test partition point with a predicate that is true for all values\n        let index = set.partition_point(|_| true);\n        assert_eq!(index, 10, \"Partition point should be at index 10\");\n\n        // Test partition point with a predicate that is false for all values\n        let index = set.partition_point(|_| false);\n        assert_eq!(index, 0, \"Partition point should be at index 0\");\n    }\n}\n```", "set::IndexSet::<T, S>::pop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_pop() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let popped = set.pop();\n        assert_eq!(popped, Some(3));\n        assert_eq!(set.len(), 2);\n        assert_eq!(set.contains(&3), false);\n    }\n\n    #[test]\n    fn test_pop_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        assert_eq!(set.pop(), None);\n    }\n\n    #[test]\n    fn test_pop_preserves_order() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.pop();  // Pops 3\n\n        let remaining: Vec<_> = set.iter().collect();\n        assert_eq!(remaining, vec![1, 2]);\n    }\n}\n```", "set::IndexSet::<T, S>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_remove_existing_key() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        assert!(set.remove(&2));\n        assert!(!set.contains(&2));\n        assert!(set.contains(&1));\n        assert!(set.contains(&3));\n    }\n\n    #[test]\n    fn test_remove_non_existing_key() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        assert!(!set.remove(&3));\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n    }\n\n    #[test]\n    fn test_remove_key_from_empty_set() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        assert!(!set.remove(&1));\n    }\n\n    #[test]\n    #[deprecated(note = \"use swap_remove or shift_remove instead\")]\n    fn test_remove_deprecated() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        assert!(set.remove(&1));\n        assert!(!set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n    }\n}\n```", "set::IndexSet::<T, S>::replace": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_replace_existing_value() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        let replaced = set.replace(1);\n        assert_eq!(replaced, Some(1));\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_replace_new_value() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        let replaced = set.replace(3);\n        assert_eq!(replaced, None);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&3));\n    }\n\n    #[test]\n    fn test_replace_value_order() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.replace(1);\n        set.replace(3);\n        let elements: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(elements, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_replace_value_multiple_times() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        let replaced1 = set.replace(1);\n        let replaced2 = set.replace(2);\n        assert_eq!(replaced1, Some(1));\n        assert_eq!(replaced2, Some(2));\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_replace_value_with_different_types() {\n        let mut set: IndexSet<String> = IndexSet::new();\n        set.insert(\"foo\".to_string());\n        set.insert(\"bar\".to_string());\n        let replaced = set.replace(\"foo\".to_string());\n        assert_eq!(replaced, Some(\"foo\".to_string()));\n        assert_eq!(set.len(), 2);\n    }\n}\n```", "set::IndexSet::<T, S>::replace_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet; // Adjust the import path as necessary\n\n    #[test]\n    fn test_replace_full_new_value() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        let (index, replaced) = set.replace_full(42);\n        assert_eq!(index, 0);\n        assert_eq!(replaced, None);\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&42));\n    }\n\n    #[test]\n    fn test_replace_full_existing_value() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(42);\n        let (index, replaced) = set.replace_full(42);\n        assert_eq!(index, 0);\n        assert_eq!(replaced, Some(42));\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_replace_full_multiple_values() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(10);\n        set.insert(20);\n        let (index, replaced) = set.replace_full(10);\n        assert_eq!(index, 0);\n        assert_eq!(replaced, Some(10));\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_replace_full_ordering() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(10);\n        set.insert(20);\n        let (index1, _) = set.replace_full(10);\n        let (index2, _) = set.replace_full(30);\n        assert_eq!(index1, 0);\n        assert_eq!(index2, 2);\n        assert_eq!(set.len(), 3);\n        assert_eq!(set.get_index(0), Some(&10));\n        assert_eq!(set.get_index(1), Some(&20));\n        assert_eq!(set.get_index(2), Some(&30));\n    }\n}\n```", "set::IndexSet::<T, S>::reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_reserve() {\n        let mut index_set: IndexSet<u32, _> = IndexSet::new();\n        index_set.reserve(10);\n        assert!(index_set.capacity() >= 10);\n        \n        index_set.reserve(20);\n        assert!(index_set.capacity() >= 30);\n        \n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n        index_set.reserve(5);\n        assert!(index_set.capacity() >= 35);\n    }\n\n    #[test]\n    fn test_reserve_zero() {\n        let mut index_set: IndexSet<u32, _> = IndexSet::new();\n        let initial_capacity = index_set.capacity();\n        index_set.reserve(0);\n        assert_eq!(index_set.capacity(), initial_capacity);\n    }\n}\n```", "set::IndexSet::<T, S>::reserve_exact": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_reserve_exact() {\n        let mut index_set: IndexSet<u32> = IndexSet::new();\n        let initial_capacity = index_set.capacity();\n        \n        // Reserve exact 5 more\n        index_set.reserve_exact(5);\n        assert!(index_set.capacity() >= initial_capacity + 5);\n        \n        // Reserve exact 0\n        index_set.reserve_exact(0);\n        assert_eq!(index_set.capacity(), initial_capacity + 5);\n        \n        // Add some elements\n        index_set.insert(1);\n        index_set.insert(2);\n\n        // Reserve exact for more elements\n        let new_capacity = index_set.capacity();\n        index_set.reserve_exact(10);\n        assert!(index_set.capacity() >= new_capacity + 10);\n    }\n\n    #[test]\n    fn test_reserve_exact_does_not_over_allocate() {\n        let mut index_set: IndexSet<u32> = IndexSet::with_capacity(3);\n        index_set.reserve_exact(2);\n        let initial_capacity = index_set.capacity();\n        \n        index_set.reserve_exact(3);\n        assert_eq!(index_set.capacity(), initial_capacity);\n    }\n\n    #[test]\n    fn test_reserve_exact_after_inserts() {\n        let mut index_set: IndexSet<u32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        \n        let initial_capacity = index_set.capacity();\n        index_set.reserve_exact(5);\n        \n        assert!(index_set.capacity() >= initial_capacity);\n        assert!(index_set.capacity() >= initial_capacity + 5);\n    }\n\n    #[test]\n    fn test_reserve_exact_no_capacity_increase() {\n        let mut index_set: IndexSet<u32> = IndexSet::with_capacity(0);\n        index_set.reserve_exact(10);\n        \n        assert!(index_set.capacity() >= 10);\n    }\n}\n```", "set::IndexSet::<T, S>::retain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_retain_some_elements() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        set.retain(|&x| x > 1); // Retain only elements greater than 1\n        \n        let expected: IndexSet<_> = vec![2, 3].into_iter().collect();\n        assert_eq!(set, expected);\n    }\n\n    #[test]\n    fn test_retain_no_elements() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        set.retain(|&x| x > 3); // Retain only elements greater than 3, which will remove all\n        \n        let expected: IndexSet<_> = IndexSet::new();\n        assert_eq!(set, expected);\n    }\n\n    #[test]\n    fn test_retain_all_elements() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        set.retain(|&x| x > 0); // Retain all elements\n        \n        let expected: IndexSet<_> = vec![1, 2, 3].into_iter().collect();\n        assert_eq!(set, expected);\n    }\n\n    #[test]\n    fn test_retain_with_no_changes() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        \n        set.retain(|&x| x < 3); // No elements removed\n        \n        let expected: IndexSet<_> = vec![1, 2].into_iter().collect();\n        assert_eq!(set, expected);\n    }\n}\n```", "set::IndexSet::<T, S>::reverse": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_reverse_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.reverse();\n        assert_eq!(set.iter().collect::<Vec<_>>(), Vec::<i32>::new());\n    }\n\n    #[test]\n    fn test_reverse_single_element() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.reverse();\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![1]);\n    }\n\n    #[test]\n    fn test_reverse_multiple_elements() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.reverse();\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![3, 2, 1]);\n    }\n\n    #[test]\n    fn test_reverse_repeated_elements() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(1);\n        set.reverse();\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![1, 2]);\n    }\n\n    #[test]\n    fn test_reverse_preserves_order() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.reverse();\n        set.reverse(); // Reverse again to restore original order\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![1, 2, 3]);\n    }\n}\n```", "set::IndexSet::<T, S>::shift_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_shift_insert_insert_new_value() {\n        let mut set: IndexSet<char> = ('a'..='z').collect();\n        assert_eq!(set.shift_insert(10, '*'), true);\n        assert_eq!(set.get_index_of(&'*'), Some(10));\n    }\n\n    #[test]\n    fn test_shift_insert_move_existing_value() {\n        let mut set: IndexSet<char> = ('a'..='z').collect();\n        assert_eq!(set.shift_insert(10, 'a'), false);\n        assert_eq!(set.get_index_of(&'a'), Some(10));\n    }\n\n    #[test]\n    fn test_shift_insert_move_existing_value_shift_down() {\n        let mut set: IndexSet<char> = ('a'..='z').collect();\n        assert_eq!(set.shift_insert(9, 'z'), false);\n        assert_eq!(set.get_index_of(&'z'), Some(9));\n    }\n\n    #[test]\n    fn test_shift_insert_move_existing_value_at_last_index() {\n        let mut set: IndexSet<char> = ('a'..='z').collect();\n        assert_eq!(set.len(), 27);\n        assert_eq!(set.shift_insert(set.len() - 1, '*'), false); // moving existing value\n        assert_eq!(set.get_index_of(&'*'), Some(26));\n    }\n\n    #[test]\n    fn test_shift_insert_insert_at_end() {\n        let mut set: IndexSet<char> = ('a'..='z').collect();\n        assert_eq!(set.shift_insert(set.len(), '+'), true);\n        assert_eq!(set.get_index_of(&'+'), Some(27));\n        assert_eq!(set.len(), 28);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_shift_insert_panics_on_move_existing_value() {\n        let mut set: IndexSet<char> = ('a'..='z').collect();\n        set.shift_insert(set.len(), 'a');\n    }\n}\n```", "set::IndexSet::<T, S>::shift_remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_present() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        assert!(set.shift_remove(&2));\n        assert!(!set.contains(&2));\n        assert_eq!(set.len(), 2);\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![&1, &3]);\n    }\n\n    #[test]\n    fn test_shift_remove_absent() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        assert!(!set.shift_remove(&3)); // 3 is not in the set\n        assert_eq!(set.len(), 2);\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![&1, &2]);\n    }\n\n    #[test]\n    fn test_shift_remove_first() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        assert!(set.shift_remove(&1));\n        assert_eq!(set.len(), 2);\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![&2, &3]);\n    }\n\n    #[test]\n    fn test_shift_remove_last() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        assert!(set.shift_remove(&3));\n        assert_eq!(set.len(), 2);\n        assert_eq!(set.iter().collect::<Vec<_>>(), vec![&1, &2]);\n    }\n\n    #[test]\n    fn test_shift_remove_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        assert!(!set.shift_remove(&1)); // 1 is not in the set\n        assert_eq!(set.len(), 0);\n    }\n}\n```", "set::IndexSet::<T, S>::shift_remove_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_full() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(10);\n        set.insert(20);\n        set.insert(30);\n\n        // Test removing existing element\n        let result = set.shift_remove_full(&20);\n        assert_eq!(result, Some((1, 20))); // index 1, value 20\n        assert_eq!(set.len(), 2);\n        assert!(set.contains(&10));\n        assert!(set.contains(&30));\n        assert!(!set.contains(&20));\n\n        // Test removing first element\n        let result = set.shift_remove_full(&10);\n        assert_eq!(result, Some((0, 10))); // index 0, value 10\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&30));\n        assert!(!set.contains(&10));\n\n        // Test removing last element\n        let result = set.shift_remove_full(&30);\n        assert_eq!(result, Some((0, 30))); // index 0, value 30\n        assert_eq!(set.len(), 0);\n        assert!(!set.contains(&30));\n\n        // Test removing non-existent element\n        let result = set.shift_remove_full(&40);\n        assert_eq!(result, None);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_shift_remove_full_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        // Test removing from an empty set\n        let result = set.shift_remove_full(&1);\n        assert_eq!(result, None);\n    }\n}\n```", "set::IndexSet::<T, S>::shift_remove_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Make sure to bring the relevant items into scope\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_shift_remove_index() {\n        let mut index_set: IndexSet<u32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(3);\n\n        // Remove the item at index 1\n        let removed_value = index_set.shift_remove_index(1);\n        assert_eq!(removed_value, Some(2)); // Should remove the value 2\n\n        // Check the remaining items\n        let remaining: Vec<_> = index_set.iter().collect();\n        assert_eq!(remaining, vec![&1, &3]); // Should only have 1 and 3 left\n\n        // Check shifting\n        let removed_value_again = index_set.shift_remove_index(0);\n        assert_eq!(removed_value_again, Some(1)); // Should remove the value 1\n\n        let remaining_after_removal: Vec<_> = index_set.iter().collect();\n        assert_eq!(remaining_after_removal, vec![&3]); // Should only have 3 left\n\n        // Check out of bounds\n        let out_of_bounds = index_set.shift_remove_index(1);\n        assert_eq!(out_of_bounds, None); // Should return None since index 1 is out of bounds\n    }\n\n    #[test]\n    fn test_shift_remove_index_empty() {\n        let mut index_set: IndexSet<u32> = IndexSet::new();\n        // Check remove on empty index set\n        let removed_value = index_set.shift_remove_index(0);\n        assert_eq!(removed_value, None); // Should return None, as there are no items\n    }\n\n    #[test]\n    fn test_shift_remove_index_single_item() {\n        let mut index_set: IndexSet<u32> = IndexSet::new();\n        index_set.insert(42);\n\n        // Remove the only item\n        let removed_value = index_set.shift_remove_index(0);\n        assert_eq!(removed_value, Some(42)); // Should remove the value 42\n\n        // Check it is empty now\n        assert!(index_set.is_empty());\n    }\n\n    #[test]\n    fn test_shift_remove_index_multiple_removals() {\n        let mut index_set: IndexSet<u32> = IndexSet::new();\n        index_set.insert(10);\n        index_set.insert(20);\n        index_set.insert(30);\n        index_set.insert(40);\n\n        // Remove the first item\n        assert_eq!(index_set.shift_remove_index(0), Some(10));\n        assert_eq!(index_set.len(), 3);\n        \n        // Remove the now first item\n        assert_eq!(index_set.shift_remove_index(0), Some(20));\n        assert_eq!(index_set.len(), 2);\n        \n        // Remove the last item\n        assert_eq!(index_set.shift_remove_index(1), Some(40));\n        assert_eq!(index_set.len(), 1);\n        \n        // Finally, remove the last remaining item\n        assert_eq!(index_set.shift_remove_index(0), Some(30));\n        assert!(index_set.is_empty());\n    }\n}\n```", "set::IndexSet::<T, S>::shift_take": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_shift_take() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        assert_eq!(set.shift_take(&2), Some(2));\n        assert_eq!(set.contains(&2), false);\n        assert_eq!(set.shift_take(&4), None);\n        assert_eq!(set.shift_take(&3), Some(3));\n        assert_eq!(set.shift_take(&1), Some(1));\n        assert_eq!(set.shift_take(&1), None);\n    }\n\n    #[test]\n    fn test_shift_take_empty_set() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        assert_eq!(set.shift_take(&1), None);\n    }\n\n    #[test]\n    fn test_shift_take_multiple_elements() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.insert(4);\n\n        assert_eq!(set.shift_take(&3), Some(3));\n        assert_eq!(set.shift_take(&1), Some(1));\n        assert_eq!(set.shift_take(&4), Some(4));\n        assert_eq!(set.shift_take(&2), Some(2));\n    }\n}\n```", "set::IndexSet::<T, S>::shrink_to": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_shrink_to() {\n        let mut set = IndexSet::with_capacity(10);\n        \n        // Adding elements\n        set.insert(\"a\");\n        set.insert(\"b\");\n        set.insert(\"c\");\n        \n        // Initial capacity\n        let initial_capacity = set.capacity();\n        \n        // Shrinking to a lower number\n        set.shrink_to(2);\n        \n        // Capacity should not shrink below the number of elements\n        assert!(set.capacity() >= 2);\n        assert!(set.capacity() <= initial_capacity);\n\n        // Shrink to 1\n        set.shrink_to(1);\n        \n        // Capacity should not shrink below the number of elements\n        assert!(set.capacity() >= 1);\n    }\n\n    #[test]\n    fn test_shrink_to_empty() {\n        let mut set: IndexSet<&str> = IndexSet::new();\n        \n        // Initial capacity should be 0\n        assert_eq!(set.capacity(), 0);\n        \n        // Shrink to 1 should not change capacity as the set is empty\n        set.shrink_to(1);\n        assert_eq!(set.capacity(), 0);\n        \n        // Insert an element\n        set.insert(\"a\");\n        \n        // Shrink again, capacity should be at least 1\n        set.shrink_to(1);\n        assert!(set.capacity() >= 1);\n    }\n\n    #[test]\n    fn test_shrink_to_greater_capacity() {\n        let mut set = IndexSet::with_capacity(5);\n        set.insert(\"a\");\n        set.insert(\"b\");\n        \n        // Shrink to a capacity greater than current elements\n        set.shrink_to(10);\n        \n        // Capacity should be at least as large as the size\n        assert!(set.capacity() >= set.len());\n    }\n}\n```", "set::IndexSet::<T, S>::shrink_to_fit": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n\n        // Initially, capacity should be 0\n        assert_eq!(set.capacity(), 0);\n\n        // Insert elements to increase capacity\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.insert(4);\n\n        // Verify capacity is increased\n        assert!(set.capacity() > 0);\n\n        // Clear the set, which should leave capacity\n        set.clear();\n        assert!(set.capacity() > 0);\n\n        // Now shrink to fit\n        set.shrink_to_fit();\n\n        // Capacity should be equal to the length (which is now 0)\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_non_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        // Verify capacity\n        assert!(set.capacity() > 0);\n\n        // Shrink to fit\n        set.shrink_to_fit();\n\n        // Capacity should still be > 0 as we have elements\n        assert!(set.capacity() > 0);\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_empty_set() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n\n        // Initially shrink_to_fit should have no effect\n        set.shrink_to_fit();\n        assert_eq!(set.capacity(), 0);\n    }\n}\n```", "set::IndexSet::<T, S>::sort": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_sort() {\n        let mut set: IndexSet<i32> = IndexSet::from_iter(vec![3, 1, 4, 1, 5, 9, 2, 6, 5]);\n        set.sort();\n        let sorted: Vec<i32> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![1, 2, 3, 4, 5, 6, 9]);\n    }\n\n    #[test]\n    fn test_sort_empty_set() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.sort();\n        let sorted: Vec<i32> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![]);\n    }\n\n    #[test]\n    fn test_sort_single_element() {\n        let mut set: IndexSet<i32> = IndexSet::from_iter(vec![42]);\n        set.sort();\n        let sorted: Vec<i32> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![42]);\n    }\n\n    #[test]\n    fn test_sort_stable() {\n        let mut set: IndexSet<&str> = IndexSet::from_iter(vec![\"apple\", \"banana\", \"apple\", \"cherry\"]);\n        set.sort();\n        let sorted: Vec<&str> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![\"apple\", \"apple\", \"banana\", \"cherry\"]);\n    }\n}\n```", "set::IndexSet::<T, S>::sort_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_sort_by() {\n        let mut set = IndexSet::from([5, 3, 1, 4, 2]);\n        set.sort_by(|a, b| a.cmp(b));\n\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_sort_by_reverse() {\n        let mut set = IndexSet::from([5, 3, 1, 4, 2]);\n        set.sort_by(|a, b| b.cmp(a));\n\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![5, 4, 3, 2, 1]);\n    }\n\n    #[test]\n    fn test_sort_by_stability() {\n        let mut set = IndexSet::from(vec![(1, \"a\"), (2, \"b\"), (1, \"c\"), (3, \"d\")]);\n        set.sort_by(|(_, a), (_, b)| a.cmp(b));\n\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![(1, \"a\"), (1, \"c\"), (2, \"b\"), (3, \"d\")]);\n    }\n}\n```", "set::IndexSet::<T, S>::sort_by_cached_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_sort_by_cached_key() {\n        let mut set = IndexSet::from([3, 1, 2, 0]);\n        set.sort_by_cached_key(|&key| key);\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn test_sort_by_cached_key_stable() {\n        let mut set = IndexSet::from([4, 1, 3, 4, 2, 1]);\n        set.sort_by_cached_key(|&key| key);\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![1, 1, 2, 3, 4, 4]);\n    }\n\n    #[test]\n    fn test_sort_by_cached_key_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.sort_by_cached_key(|&key| key);\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, Vec::<i32>::new());\n    }\n\n    #[test]\n    fn test_sort_by_cached_key_custom_key() {\n        let mut set = IndexSet::from([(\"apple\", 2), (\"banana\", 1), (\"cherry\", 3)]);\n        set.sort_by_cached_key(|&(key, _)| key);\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![(\"apple\", 2), (\"banana\", 1), (\"cherry\", 3)]);\n    }\n\n    #[test]\n    fn test_sort_by_cached_key_complex() {\n        let mut set = IndexSet::from([(\"dog\", 2), (\"cat\", 3), (\"bird\", 1)]);\n        set.sort_by_cached_key(|&(key, _)| key.len());\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![(\"dog\", 2), (\"cat\", 3), (\"bird\", 1)]);\n    }\n}\n```", "set::IndexSet::<T, S>::sort_unstable": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_sort_unstable() {\n        let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();\n        index_set.insert(3);\n        index_set.insert(1);\n        index_set.insert(4);\n        index_set.insert(2);\n\n        index_set.sort_unstable();\n\n        let values: Vec<_> = index_set.iter().collect();\n        assert_eq!(values, vec![1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn test_sort_unstable_no_duplicates() {\n        let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();\n        index_set.insert(5);\n        index_set.insert(3);\n        index_set.insert(2);\n        index_set.insert(1);\n\n        index_set.sort_unstable();\n\n        let values: Vec<_> = index_set.iter().collect();\n        assert_eq!(values, vec![1, 2, 3, 5]);\n    }\n\n    #[test]\n    fn test_sort_unstable_with_duplicates() {\n        let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();\n        index_set.insert(2);\n        index_set.insert(3);\n        index_set.insert(3);\n        index_set.insert(1);\n\n        index_set.sort_unstable();\n\n        let values: Vec<_> = index_set.iter().collect();\n        assert_eq!(values, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_sort_unstable_empty() {\n        let mut index_set: IndexSet<i32, RandomState> = IndexSet::new();\n\n        index_set.sort_unstable();\n\n        let values: Vec<_> = index_set.iter().collect();\n        assert_eq!(values, Vec::<i32>::new());\n    }\n}\n```", "set::IndexSet::<T, S>::sort_unstable_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_sort_unstable_by() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(3);\n        set.insert(1);\n        set.insert(2);\n\n        set.sort_unstable_by(|a, b| a.cmp(b));\n\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_sort_unstable_by_with_custom_comparator() {\n        let mut set: IndexSet<String> = IndexSet::new();\n        set.insert(\"banana\".to_string());\n        set.insert(\"apple\".to_string());\n        set.insert(\"cherry\".to_string());\n\n        set.sort_unstable_by(|a, b| b.cmp(a));  // Sort in reverse order\n\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, vec![\"cherry\".to_string(), \"banana\".to_string(), \"apple\".to_string()]);\n    }\n\n    #[test]\n    fn test_sort_unstable_by_empty_set() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.sort_unstable_by(|a, b| a.cmp(b));\n\n        let sorted: Vec<_> = set.iter().cloned().collect();\n        assert_eq!(sorted, Vec::<i32>::new());\n    }\n}\n```", "set::IndexSet::<T, S>::sorted_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_sorted_by() {\n        let mut set = IndexSet::new();\n        set.insert(3);\n        set.insert(1);\n        set.insert(2);\n        \n        let sorted_iter = set.sorted_by(|a, b| a.cmp(b));\n        let sorted_vec: Vec<_> = sorted_iter.collect();\n\n        assert_eq!(sorted_vec, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_sorted_by_descending() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(3);\n        set.insert(2);\n\n        let sorted_iter = set.sorted_by(|a, b| b.cmp(a));\n        let sorted_vec: Vec<_> = sorted_iter.collect();\n\n        assert_eq!(sorted_vec, vec![3, 2, 1]);\n    }\n\n    #[test]\n    fn test_sorted_by_stability() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(3);\n        set.insert(2);\n        set.insert(2); // Duplicate to test stability\n\n        let sorted_iter = set.sorted_by(|a, b| a.cmp(b));\n        let sorted_vec: Vec<_> = sorted_iter.collect();\n\n        assert_eq!(sorted_vec, vec![2, 2, 1, 3]); // Duplicate 2 should remain in order\n    }\n}\n```", "set::IndexSet::<T, S>::sorted_unstable_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_sorted_unstable_by() {\n        let mut index_set = IndexSet::new();\n        index_set.insert(3);\n        index_set.insert(1);\n        index_set.insert(4);\n        index_set.insert(2);\n\n        let sorted: Vec<_> = index_set.sorted_unstable_by(|a, b| a.cmp(b)).collect();\n        \n        assert_eq!(sorted, vec![1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn test_sorted_unstable_by_reverse() {\n        let mut index_set = IndexSet::new();\n        index_set.insert(4);\n        index_set.insert(3);\n        index_set.insert(2);\n        index_set.insert(1);\n\n        let sorted: Vec<_> = index_set.sorted_unstable_by(|a, b| b.cmp(a)).collect();\n        \n        assert_eq!(sorted, vec![4, 3, 2, 1]);\n    }\n\n    #[test]\n    fn test_sorted_unstable_by_with_equal_elements() {\n        let mut index_set = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        index_set.insert(1); // Duplicate\n\n        let sorted: Vec<_> = index_set.sorted_unstable_by(|a, b| a.cmp(b)).collect();\n        \n        assert_eq!(sorted, vec![1, 1, 2]);\n    }\n}\n```", "set::IndexSet::<T, S>::splice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_splice_basic() {\n        let mut set = IndexSet::from([0, 1, 2, 3, 4]);\n        let new = [5, 4, 3, 2, 1];\n        let removed: Vec<_> = set.splice(2..4, new).collect();\n        \n        assert!(set.into_iter().eq([0, 1, 5, 3, 2, 4]));\n        assert_eq!(removed, &[2, 3]);\n    }\n\n    #[test]\n    fn test_splice_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        let new = [1, 2, 3];\n        let removed: Vec<_> = set.splice(0..0, new).collect();\n\n        assert!(set.is_empty());\n        assert_eq!(removed, &[]);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_splice_panic_start_greater_than_end() {\n        let mut set = IndexSet::from([0, 1, 2, 3]);\n        set.splice(3..1, [4, 5]);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_splice_panic_end_greater_than_length() {\n        let mut set = IndexSet::from([0, 1, 2]);\n        set.splice(0..4, [3]);\n    }\n\n    #[test]\n    fn test_splice_with_existing_elements() {\n        let mut set = IndexSet::from([0, 1, 2, 3, 4]);\n        let new = [2, 5, 6];\n        let removed: Vec<_> = set.splice(1..3, new).collect();\n\n        assert!(set.into_iter().eq([0, 2, 5, 6, 4]));\n        assert_eq!(removed, &[1, 2]);\n    }\n\n    #[test]\n    fn test_splice_no_elements_removed() {\n        let mut set = IndexSet::from([1, 2, 3]);\n        let new = [4];\n        let removed: Vec<_> = set.splice(1..1, new).collect();\n\n        assert!(set.into_iter().eq([1, 4, 2, 3]));\n        assert_eq!(removed, &[]);\n    }\n}\n```", "set::IndexSet::<T, S>::split_off": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_split_off() {\n        let mut index_set: IndexMap<i32, ()> = IndexMap::new();\n        index_set.insert(1, ());\n        index_set.insert(2, ());\n        index_set.insert(3, ());\n\n        let split_index = 2;\n        let split_result = index_set.split_off(split_index);\n\n        // Original should contain 1, 2\n        assert_eq!(index_set.len(), 2);\n        assert!(index_set.contains_key(&1));\n        assert!(index_set.contains_key(&2));\n        assert!(!index_set.contains_key(&3));\n\n        // Split result should contain 3\n        assert_eq!(split_result.len(), 1);\n        assert!(split_result.contains_key(&3));\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_split_off_panic() {\n        let mut index_set: IndexMap<i32, ()> = IndexMap::new();\n        index_set.insert(1, ());\n        index_set.insert(2, ());\n\n        index_set.split_off(3); // Should panic since index 3 is out of bounds\n    }\n\n    #[test]\n    fn test_split_off_empty() {\n        let mut index_set: IndexMap<i32, ()> = IndexMap::new();\n        let split_result = index_set.split_off(0);\n\n        // Splitting an empty set should result in an empty set\n        assert!(split_result.is_empty());\n        assert!(index_set.is_empty());\n    }\n\n    #[test]\n    fn test_split_off_first_index() {\n        let mut index_set: IndexMap<i32, ()> = IndexMap::new();\n        index_set.insert(1, ());\n        index_set.insert(2, ());\n        index_set.insert(3, ());\n\n        let split_result = index_set.split_off(0);\n\n        // Original should be empty\n        assert!(index_set.is_empty());\n\n        // Split result should contain all elements\n        assert_eq!(split_result.len(), 3);\n        assert!(split_result.contains_key(&1));\n        assert!(split_result.contains_key(&2));\n        assert!(split_result.contains_key(&3));\n    }\n}\n```", "set::IndexSet::<T, S>::swap_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_indices() {\n        let mut index_set: IndexSet<char> = IndexSet::new();\n        index_set.insert('a');\n        index_set.insert('b');\n        index_set.insert('c');\n\n        assert_eq!(index_set.iter().collect::<Vec<_>>(), vec!['a', 'b', 'c']);\n\n        // Swap indices 0 and 1\n        index_set.swap_indices(0, 1);\n        assert_eq!(index_set.iter().collect::<Vec<_>>(), vec!['b', 'a', 'c']);\n        \n        // Swap indices 1 and 2\n        index_set.swap_indices(1, 2);\n        assert_eq!(index_set.iter().collect::<Vec<_>>(), vec!['b', 'c', 'a']);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_swap_indices_out_of_bounds() {\n        let mut index_set: IndexSet<char> = IndexSet::new();\n        index_set.insert('a');\n        index_set.insert('b');\n\n        // This should panic as index 2 is out of bounds\n        index_set.swap_indices(0, 2);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_swap_indices_empty() {\n        let mut index_set: IndexSet<char> = IndexSet::new();\n\n        // This should panic when trying to swap indices in an empty IndexSet\n        index_set.swap_indices(0, 1);\n    }\n}\n```", "set::IndexSet::<T, S>::swap_remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_swap_remove() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        // Test removing an existing element\n        assert!(set.swap_remove(&2));\n        assert!(!set.contains(&2));\n        assert_eq!(set.len(), 2);\n\n        // Test removing a non-existing element\n        assert!(!set.swap_remove(&5));\n        assert_eq!(set.len(), 2);\n\n        // Test removing the last element\n        assert!(set.swap_remove(&3));\n        assert!(!set.contains(&3));\n        assert_eq!(set.len(), 1);\n        assert!(set.swap_remove(&1));\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_swap_remove_no_effect_on_last() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        // Remove the last element\n        assert!(set.swap_remove(&2));\n        assert!(set.len() == 1);\n        assert!(set.contains(&1));\n    }\n\n    #[test]\n    fn test_swap_remove_empty() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        assert!(!set.swap_remove(&1)); // Removing from an empty set\n        assert_eq!(set.len(), 0);\n    }\n}\n```", "set::IndexSet::<T, S>::swap_remove_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_swap_remove_full_existing_key() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let result = set.swap_remove_full(&2);\n        assert_eq!(result, Some((1, 2))); // Key 2 was at index 1\n        assert!(!set.contains(&2)); // Key 2 should no longer be present\n    }\n\n    #[test]\n    fn test_swap_remove_full_non_existing_key() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let result = set.swap_remove_full(&4);\n        assert_eq!(result, None); // Key 4 does not exist\n    }\n\n    #[test]\n    fn test_swap_remove_full_edge_case() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(42);\n\n        let result = set.swap_remove_full(&42);\n        assert_eq!(result, Some((0, 42))); // Key 42 was at index 0\n        assert!(set.is_empty()); // Set should be empty now\n    }\n\n    #[test]\n    fn test_swap_remove_full_multiple_keys() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.insert(4);\n        set.insert(5);\n\n        let result = set.swap_remove_full(&3);\n        assert_eq!(result, Some((2, 3))); // Key 3 was at index 2\n        assert_eq!(set.len(), 4); // Set should have 4 keys now\n    }\n}\n```", "set::IndexSet::<T, S>::swap_remove_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_swap_remove_index() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        \n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        // Check initial length\n        assert_eq!(set.len(), 3);\n        \n        // Swap remove index 1 (should remove 2)\n        assert_eq!(set.swap_remove_index(1), Some(2));\n        assert_eq!(set.len(), 2);\n        assert!(!set.contains(&2));\n        \n        // Check the remaining elements\n        let remaining: Vec<_> = set.iter().cloned().collect();\n        assert!(remaining.contains(&1));\n        assert!(remaining.contains(&3));\n        \n        // Swap remove index 0 (should remove 1)\n        assert_eq!(set.swap_remove_index(0), Some(1));\n        assert_eq!(set.len(), 1);\n        assert!(!set.contains(&1));\n        \n        // Swap remove index 0 (should remove 3)\n        assert_eq!(set.swap_remove_index(0), Some(3));\n        assert_eq!(set.len(), 0);\n        \n        // Attempt to swap remove from an empty set\n        assert_eq!(set.swap_remove_index(0), None);\n    }\n\n    #[test]\n    fn test_swap_remove_index_out_of_bounds() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        \n        set.insert(1);\n        set.insert(2);\n        \n        // Check that index 2 is out of bounds\n        assert_eq!(set.swap_remove_index(2), None);\n    }\n}\n```", "set::IndexSet::<T, S>::swap_take": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::{IndexMap, IndexSet};\n\n    #[test]\n    fn test_swap_take() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        assert_eq!(set.swap_take(&2), Some(2));\n        assert_eq!(set.contains(&2), false);\n        assert_eq!(set.len(), 2);\n        assert_eq!(set.swap_take(&4), None); // 4 is not in the set\n    }\n\n    #[test]\n    fn test_swap_take_removes_last_element() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        assert_eq!(set.swap_take(&1), Some(1));\n        assert_eq!(set.swap_take(&2), Some(2));\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_swap_take_no_elements() {\n        let mut set: IndexSet<i32> = IndexSet::new();\n        \n        assert_eq!(set.swap_take(&1), None); // set is empty\n    }\n}\n```", "set::IndexSet::<T, S>::symmetric_difference": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_symmetric_difference() {\n        let mut set_a = IndexSet::new();\n        set_a.insert(1);\n        set_a.insert(2);\n        set_a.insert(3);\n\n        let mut set_b = IndexSet::new();\n        set_b.insert(3);\n        set_b.insert(4);\n        set_b.insert(5);\n\n        let result: Vec<_> = set_a.symmetric_difference(&set_b).collect();\n        assert_eq!(result, vec![1, 2, 4, 5]);\n    }\n\n    #[test]\n    fn test_symmetric_difference_empty() {\n        let set_a: IndexSet<i32> = IndexSet::new();\n        let set_b: IndexSet<i32> = IndexSet::new();\n\n        let result: Vec<_> = set_a.symmetric_difference(&set_b).collect();\n        assert!(result.is_empty());\n    }\n\n    #[test]\n    fn test_symmetric_difference_with_empty_set() {\n        let mut set_a = IndexSet::new();\n        set_a.insert(1);\n        set_a.insert(2);\n\n        let set_b: IndexSet<i32> = IndexSet::new();\n\n        let result: Vec<_> = set_a.symmetric_difference(&set_b).collect();\n        assert_eq!(result, vec![1, 2]);\n    }\n\n    #[test]\n    fn test_symmetric_difference_same_set() {\n        let mut set_a = IndexSet::new();\n        set_a.insert(1);\n        set_a.insert(2);\n        set_a.insert(3);\n\n        let result: Vec<_> = set_a.symmetric_difference(&set_a).collect();\n        assert!(result.is_empty());\n    }\n}\n```", "set::IndexSet::<T, S>::take": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_take_existing_value() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        \n        let taken = set.take(&1);\n        assert_eq!(taken, Some(1));\n        assert!(!set.contains(&1));\n        assert_eq!(set.len(), 1);\n    }\n    \n    #[test]\n    fn test_take_non_existing_value() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        \n        let taken = set.take(&3);\n        assert_eq!(taken, None);\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_take_multiple_values() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        let taken_first = set.take(&2);\n        assert_eq!(taken_first, Some(2));\n        assert!(!set.contains(&2));\n        \n        let taken_second = set.take(&3);\n        assert_eq!(taken_second, Some(3));\n        assert!(!set.contains(&3));\n        \n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n    }\n\n    #[test]\n    fn test_take_on_empty_set() {\n        let mut set = IndexSet::new();\n        let taken = set.take(&1);\n        assert_eq!(taken, None);\n        assert_eq!(set.len(), 0);\n    }\n}\n```", "set::IndexSet::<T, S>::truncate": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_truncate() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        set.truncate(2);\n        assert_eq!(set.len(), 2);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(!set.contains(&3));\n\n        set.truncate(1);\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n        assert!(!set.contains(&2));\n        assert!(!set.contains(&3));\n\n        set.truncate(3);\n        assert_eq!(set.len(), 1);\n    }\n}\n```", "set::IndexSet::<T, S>::try_reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn try_reserve_success() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n        \n        // Ensure we can reserve additional capacity\n        assert!(index_set.try_reserve(5).is_ok());\n        assert!(index_set.try_reserve(0).is_ok()); // Reserving zero should succeed\n    }\n\n    #[test]\n    fn try_reserve_error() {\n        // Assuming a specific implementation where reserving\n        // more than capacity would return an error\n\n        let mut index_set: IndexSet<i32> = IndexSet::with_capacity(2);\n        index_set.insert(1);\n        index_set.insert(2);\n        \n        // Intentionally reserve more than what can be accommodated\n        let result = index_set.try_reserve(usize::MAX);\n        assert!(result.is_err()); // Expect an error\n    }\n\n    #[test]\n    fn try_reserve_on_empty() {\n        let mut index_set: IndexSet<i32> = IndexSet::new();\n        // Reserving when the index set is empty\n        assert!(index_set.try_reserve(10).is_ok());\n    }\n\n    #[test]\n    fn try_reserve_exact_success() {\n        let mut index_set = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n\n        // Ensure we can reserve exact additional capacity\n        assert!(index_set.try_reserve_exact(5).is_ok());\n    }\n\n    #[test]\n    fn try_reserve_exact_error() {\n        // Assuming a specific implementation where reserving\n        // more than capacity would return an error\n\n        let mut index_set: IndexSet<i32> = IndexSet::with_capacity(2);\n        index_set.insert(1);\n        index_set.insert(2);\n        \n        // Intentionally reserve more than what can be accommodated\n        let result = index_set.try_reserve_exact(usize::MAX);\n        assert!(result.is_err()); // Expect an error\n    }\n\n    #[test]\n    fn try_reserve_with_previous_elements() {\n        let mut index_set = IndexSet::new();\n        index_set.insert(1);\n        index_set.insert(2);\n\n        // Reserve additional elements\n        assert!(index_set.try_reserve(5).is_ok());\n        assert!(index_set.len() == 2); // Ensure elements remain intact\n    }\n}\n```", "set::IndexSet::<T, S>::try_reserve_exact": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // or use indexmap::set::IndexSet\n    use indexmap::IndexSet; // Adjust import according to your module path\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_try_reserve_exact_success() {\n        let mut set: IndexSet<u32, RandomState> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        assert_eq!(set.len(), 2);\n        assert!(set.try_reserve_exact(1).is_ok());\n        assert!(set.try_reserve_exact(2).is_ok());\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_try_reserve_exact_failure() {\n        let mut set: IndexSet<u32, RandomState> = IndexSet::with_capacity(1);\n        set.insert(1);\n\n        assert!(set.try_reserve_exact(2).is_ok());\n        assert_eq!(set.len(), 1); // Ensure length does not change until a successful `insert`\n    }\n\n    #[test]\n    fn test_try_reserve_exact_edge_case() {\n        let mut set: IndexSet<u32, RandomState> = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        // Initially have 2 elements, try to reserve 0\n        assert!(set.try_reserve_exact(0).is_ok());\n        assert_eq!(set.len(), 2);\n\n        // Attempt to reserve memory above current capacity\n        assert!(set.try_reserve_exact(10).is_ok());\n    }\n}\n```", "set::IndexSet::<T, S>::union": "```rust\n#[cfg(test)]\nmod tests {\n    use indexmap::IndexMap;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_union_with_overlapping() {\n        let set_a: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3]);\n        let set_b: IndexSet<i32> = IndexSet::from_iter(vec![2, 3, 4, 5]);\n\n        let union: Vec<_> = set_a.union(&set_b).collect();\n        assert_eq!(union, vec![1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_union_with_non_overlapping() {\n        let set_a: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3]);\n        let set_b: IndexSet<i32> = IndexSet::from_iter(vec![4, 5, 6]);\n\n        let union: Vec<_> = set_a.union(&set_b).collect();\n        assert_eq!(union, vec![1, 2, 3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn test_union_with_empty_set() {\n        let set_a: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3]);\n        let set_b: IndexSet<i32> = IndexSet::new();\n\n        let union: Vec<_> = set_a.union(&set_b).collect();\n        assert_eq!(union, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_union_with_self() {\n        let set_a: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3]);\n\n        let union: Vec<_> = set_a.union(&set_a).collect();\n        assert_eq!(union, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_union_with_other() {\n        let set_a: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3]);\n        let set_b: IndexSet<i32> = IndexSet::from_iter(vec![1, 2, 3]);\n\n        let union: Vec<_> = set_a.union(&set_b).collect();\n        assert_eq!(union, vec![1, 2, 3]);\n    }\n}\n```", "set::IndexSet::<T, S>::with_capacity_and_hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_with_capacity_and_hasher() {\n        let set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(10, RandomState::new());\n        assert_eq!(set.len(), 0);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_zero() {\n        let set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());\n        assert_eq!(set.len(), 0);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_non_zero_capacity() {\n        let mut set: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(5, RandomState::new());\n        assert_eq!(set.len(), 0);\n        assert!(set.is_empty());\n\n        set.insert(1);\n        set.insert(2);\n        assert_eq!(set.len(), 2);\n        assert!(!set.is_empty());\n    }\n}\n```", "set::IndexSet::<T, S>::with_hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_with_hasher() {\n        let hasher = RandomState::new();\n        let set: IndexSet<i32, RandomState> = IndexSet::with_hasher(hasher);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_with_hasher_non_empty() {\n        let hasher = RandomState::new();\n        let mut set: IndexSet<i32, RandomState> = IndexSet::with_hasher(hasher);\n        set.insert(1);\n        set.insert(2);\n        \n        assert_eq!(set.len(), 2);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n    }\n\n    #[test]\n    fn test_with_hasher_equality() {\n        let hasher1 = RandomState::new();\n        let set1: IndexSet<i32, RandomState> = IndexSet::with_hasher(hasher1);\n        let hasher2 = RandomState::new();\n        let set2: IndexSet<i32, RandomState> = IndexSet::with_hasher(hasher2);\n        \n        assert_eq!(set1, set2);\n    }\n}\n```", "set::IndexSet::<T>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::IndexSet;\n\n    #[test]\n    fn test_index_set_new() {\n        let index_set: IndexSet<i32> = IndexSet::new();\n        assert!(index_set.is_empty());\n        assert_eq!(index_set.len(), 0);\n    }\n}\n```", "set::IndexSet::<T>::with_capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let set: IndexSet<u32> = IndexSet::with_capacity(0);\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_non_zero() {\n        let set: IndexSet<u32> = IndexSet::with_capacity(5);\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n        assert!(set.capacity() >= 5);\n    }\n\n    #[test]\n    fn test_with_capacity_non_zero_multiple() {\n        let set: IndexSet<u32> = IndexSet::with_capacity(10);\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n        assert!(set.capacity() >= 10);\n    }\n}\n```", "set::iter::<impl core::iter::IntoIterator for &'a set::IndexSet<T, S>>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_into_iter() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let iter = set.into_iter();\n        let collected: Vec<_> = iter.collect();\n\n        assert_eq!(collected, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let set: IndexSet<i32> = IndexSet::new();\n        let iter = set.into_iter();\n        \n        let collected: Vec<_> = iter.collect();\n        \n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_into_iter_order() {\n        let mut set = IndexSet::new();\n        set.insert(3);\n        set.insert(1);\n        set.insert(2);\n\n        let iter = set.into_iter();\n        let collected: Vec<_> = iter.collect();\n\n        assert_eq!(collected, vec![3, 1, 2]); // Should match insertion order\n    }\n\n    #[test]\n    fn test_into_iter_duplicates() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(1); // Duplicate, should be ignored\n\n        let iter = set.into_iter();\n        let collected: Vec<_> = iter.collect();\n\n        assert_eq!(collected, vec![1, 2]); // Should still be unique\n    }\n}\n```", "set::iter::<impl core::iter::IntoIterator for set::IndexSet<T, S>>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_into_iter() {\n        let mut index_map = IndexMap::new();\n        index_map.insert(1, \"a\");\n        index_map.insert(2, \"b\");\n        index_map.insert(3, \"c\");\n\n        let mut iter = index_map.into_iter();\n        let mut entries: Vec<_> = iter.collect();\n\n        assert_eq!(entries.len(), 3);\n        assert!(entries.contains(&(1, \"a\")));\n        assert!(entries.contains(&(2, \"b\")));\n        assert!(entries.contains(&(3, \"c\")));\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let index_map: IndexMap<i32, &str> = IndexMap::new();\n        let iter: Vec<_> = index_map.into_iter().collect();\n\n        assert!(iter.is_empty());\n    }\n\n    #[test]\n    fn test_into_iter_order() {\n        let mut index_map = IndexMap::new();\n        index_map.insert(1, \"one\");\n        index_map.insert(2, \"two\");\n        index_map.insert(3, \"three\");\n\n        let mut iter = index_map.into_iter();\n        let first = iter.next().unwrap();\n        let second = iter.next().unwrap();\n        let third = iter.next().unwrap();\n\n        assert_eq!(first, (1, \"one\"));\n        assert_eq!(second, (2, \"two\"));\n        assert_eq!(third, (3, \"three\"));\n    }\n\n    #[test]\n    fn test_into_iter_mut() {\n        let mut index_map = IndexMap::new();\n        index_map.insert(1, 10);\n        index_map.insert(2, 20);\n        index_map.insert(3, 30);\n\n        let mut iter = index_map.into_iter();\n        let first = iter.next().unwrap();\n        let second = iter.next().unwrap();\n        let third = iter.next().unwrap();\n\n        assert_eq!(first, (1, 10));\n        assert_eq!(second, (2, 20));\n        assert_eq!(third, (3, 30));\n    }\n}\n```", "set::iter::Difference::<'a, T, S>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_difference_new() {\n        let set1: IndexSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set2: IndexSet<i32> = [3, 4, 5].iter().cloned().collect();\n\n        let difference = set::iter::Difference::new(&set1, &set2);\n\n        let expected: Vec<i32> = vec![1, 2];\n        let result: Vec<i32> = difference.iter().cloned().collect();\n\n        assert_eq!(result, expected);\n    }\n}\n```", "set::iter::Drain::<'a, T>::as_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_as_slice() {\n        let buckets = vec![\n            Bucket {\n                hash: HashValue(1),\n                key: \"first\",\n                value: 10,\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: \"second\",\n                value: 20,\n            },\n        ];\n        \n        let draining_iter = vec::Drain::new(buckets.clone());\n        let drain = Drain::new(draining_iter);\n        \n        let slice = drain.as_slice();\n        \n        assert_eq!(slice.len(), buckets.len());\n        assert_eq!(slice.get_index(0), Some(&\"first\"));\n        assert_eq!(slice.get_index(1), Some(&\"second\"));\n    }\n}\n```", "set::iter::Drain::<'a, T>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_drain_new() {\n        let mut vec_example = vec![Bucket::new(1), Bucket::new(2), Bucket::new(3)];\n        let drain = vec_example.drain(0..2); // Draining first two elements\n        let drain_instance = Drain::new(drain);\n        \n        assert_eq!(drain_instance.len(), 1); // Should only have one element left\n        assert_eq!(drain_instance.as_slice(), &vec![Bucket::new(3)]);\n    }\n}\n```", "set::iter::Intersection::<'a, T, S>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_intersection_new() {\n        let set1: IndexSet<u32> = IndexSet::from_iter(vec![1, 2, 3]);\n        let set2: IndexSet<u32> = IndexSet::from_iter(vec![2, 3, 4]);\n        let intersection = set::iter::Intersection::new(&set1, &set2);\n\n        let intersection_elements: Vec<_> = intersection.iter.collect();\n        assert_eq!(intersection_elements, vec![&2, &3]);\n    }\n\n    #[test]\n    fn test_intersection_new_empty() {\n        let set1: IndexSet<u32> = IndexSet::new();\n        let set2: IndexSet<u32> = IndexSet::new();\n        let intersection = set::iter::Intersection::new(&set1, &set2);\n\n        let intersection_elements: Vec<_> = intersection.iter.collect();\n        assert!(intersection_elements.is_empty());\n    }\n\n    #[test]\n    fn test_intersection_one_empty() {\n        let set1: IndexSet<u32> = IndexSet::from_iter(vec![1, 2, 3]);\n        let set2: IndexSet<u32> = IndexSet::new();\n        let intersection = set::iter::Intersection::new(&set1, &set2);\n\n        let intersection_elements: Vec<_> = intersection.iter.collect();\n        assert!(intersection_elements.is_empty());\n    }\n}\n```", "set::iter::IntoIter::<T>::as_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::iter::IntoIter;\n    use crate::set::slice::Slice;\n    use crate::Bucket;\n    use crate::HashValue;\n\n    #[test]\n    fn test_as_slice() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 42,\n            value: \"value1\",\n        };\n        \n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: 43,\n            value: \"value2\",\n        };\n\n        let iter = IntoIter::new(vec![bucket1.clone(), bucket2.clone()]);\n        let slice = iter.as_slice();\n\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice.get_index(0), Some(&bucket1.key));\n        assert_eq!(slice.get_index(1), Some(&bucket2.key));\n        assert!(slice.get_index(2).is_none());\n    }\n}\n```", "set::iter::IntoIter::<T>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::iter::IntoIter;\n    use crate::Bucket; // Adjust the import according to your crate structure.\n\n    #[test]\n    fn test_new_with_non_empty_vector() {\n        let entries = vec![\n            Bucket::new(\"key1\", \"value1\"),\n            Bucket::new(\"key2\", \"value2\"),\n        ];\n        let iter = IntoIter::new(entries);\n        assert_eq!(iter.len(), 2);\n    }\n\n    #[test]\n    fn test_new_with_empty_vector() {\n        let entries: Vec<Bucket<&str>> = Vec::new();\n        let iter = IntoIter::new(entries);\n        assert_eq!(iter.len(), 0);\n    }\n\n    #[test]\n    fn test_new_with_various_types() {\n        let entries = vec![\n            Bucket::new(1, \"value1\"),\n            Bucket::new(2, \"value2\"),\n        ];\n        let iter: IntoIter<i32> = IntoIter::new(entries);\n        assert_eq!(iter.len(), 2);\n    }\n}\n```", "set::iter::Iter::<'a, T>::as_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::{Bucket, Iter, Slice};\n\n    #[test]\n    fn test_as_slice() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let bucket3 = Bucket {\n            hash: HashValue(3),\n            key: \"key3\",\n            value: \"value3\",\n        };\n        \n        let buckets = vec![bucket1, bucket2, bucket3];\n        let iter = Iter::new(&buckets);\n        \n        let slice = iter.as_slice();\n        \n        assert_eq!(slice.len(), 3);\n        assert_eq!(slice.get_index(0), Some(&\"key1\"));\n        assert_eq!(slice.get_index(1), Some(&\"key2\"));\n        assert_eq!(slice.get_index(2), Some(&\"key3\"));\n    }\n}\n```", "set::iter::Iter::<'a, T>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::iter::Iter;\n    \n    #[test]\n    fn test_iter_new() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: \"value1\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: \"value2\",\n        };\n        let buckets = vec![bucket1, bucket2];\n\n        let iter = Iter::new(&buckets);\n        \n        assert_eq!(iter.len(), 2);\n        assert_eq!(iter.as_slice(), &[\"key1\", \"key2\"]);\n    }\n\n    #[test]\n    fn test_iter_new_empty() {\n        let buckets: Vec<Bucket<&str, &str>> = vec![];\n        let iter = Iter::new(&buckets);\n        \n        assert_eq!(iter.len(), 0);\n        assert!(iter.as_slice().is_empty());\n    }\n}\n```", "set::iter::Splice::<'a, I, T, S>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_splice_new() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let splice_iter = set.splice(1..2, [(4, 'd'), (5, 'e')]);\n        \n        let mut output = Vec::new();\n        for (key, value) in splice_iter {\n            output.push((key, value));\n        }\n\n        assert_eq!(set.len(), 4);\n        assert!(set.contains(&1));\n        assert!(set.contains(&4));\n        assert!(set.contains(&5));\n        assert!(set.contains(&3));\n        assert_eq!(output, vec![(2, 'd')]); // removed element\n    }\n\n    #[test]\n    fn test_splice_new_empty() {\n        let mut set = IndexSet::new();\n        let splice_iter = set.splice(0..0, [(1, 'a')]);\n        \n        let mut output = Vec::new();\n        for (key, value) in splice_iter {\n            output.push((key, value));\n        }\n\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n        assert!(output.is_empty()); // nothing was removed\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_splice_new_out_of_bounds() {\n        let mut set = IndexSet::new();\n        set.insert(1);\n        set.insert(2);\n        \n        // This should panic as we're trying to splice out of bounds\n        let _ = set.splice(2..3, [(3, 'c')]);\n    }\n}\n```", "set::iter::SymmetricDifference::<'a, T, S1, S2>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n\n    #[test]\n    fn test_symmetric_difference_new() {\n        let mut set1 = IndexSet::new();\n        let mut set2 = IndexSet::new();\n        \n        set1.insert(1);\n        set1.insert(2);\n        set2.insert(2);\n        set2.insert(3);\n        \n        let symmetric_diff = set::iter::SymmetricDifference::new(&set1, &set2);\n        \n        let result: Vec<_> = symmetric_diff.iter.collect();\n        \n        assert_eq!(result, vec![1, 3]);\n    }\n\n    #[test]\n    fn test_symmetric_difference_new_empty() {\n        let set1: IndexSet<i32> = IndexSet::new();\n        let set2: IndexSet<i32> = IndexSet::new();\n        \n        let symmetric_diff = set::iter::SymmetricDifference::new(&set1, &set2);\n        \n        let result: Vec<_> = symmetric_diff.iter.collect();\n        \n        assert!(result.is_empty());\n    }\n\n    #[test]\n    fn test_symmetric_difference_new_no_common() {\n        let mut set1 = IndexSet::new();\n        let mut set2 = IndexSet::new();\n        \n        set1.insert(1);\n        set1.insert(2);\n        set2.insert(3);\n        set2.insert(4);\n        \n        let symmetric_diff = set::iter::SymmetricDifference::new(&set1, &set2);\n        \n        let result: Vec<_> = symmetric_diff.iter.collect();\n        \n        assert_eq!(result, vec![1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn test_symmetric_difference_new_all_common() {\n        let mut set1 = IndexSet::new();\n        let mut set2 = IndexSet::new();\n        \n        set1.insert(1);\n        set1.insert(2);\n        set2.insert(1);\n        set2.insert(2);\n        \n        let symmetric_diff = set::iter::SymmetricDifference::new(&set1, &set2);\n        \n        let result: Vec<_> = symmetric_diff.iter.collect();\n        \n        assert!(result.is_empty());\n    }\n}\n```", "set::iter::Union::<'a, T, S>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexSet;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_union_new() {\n        let set1: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![1, 2, 3]);\n        let set2: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![3, 4, 5]);\n        let union = set::iter::Union::new(&set1, &set2);\n\n        let result: Vec<i32> = union.collect();\n        let expected: Vec<i32> = vec![1, 2, 3, 4, 5];\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_union_new_empty_sets() {\n        let set1: IndexSet<i32, RandomState> = IndexSet::new();\n        let set2: IndexSet<i32, RandomState> = IndexSet::new();\n        let union = set::iter::Union::new(&set1, &set2);\n\n        let result: Vec<i32> = union.collect();\n        let expected: Vec<i32> = vec![];\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_union_no_common_elements() {\n        let set1: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![1, 2]);\n        let set2: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![3, 4]);\n        let union = set::iter::Union::new(&set1, &set2);\n\n        let result: Vec<i32> = union.collect();\n        let expected: Vec<i32> = vec![1, 2, 3, 4];\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_union_with_duplicates() {\n        let set1: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![1, 2, 2]);\n        let set2: IndexSet<i32, RandomState> = IndexSet::from_iter(vec![2, 3, 4]);\n        let union = set::iter::Union::new(&set1, &set2);\n\n        let result: Vec<i32> = union.collect();\n        let expected: Vec<i32> = vec![1, 2, 3, 4];\n\n        assert_eq!(result, expected);\n    }\n}\n```", "set::slice::<impl core::clone::Clone for alloc::boxed::Box<set::slice::Slice<T>>>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::boxed::Box;\n    use set::slice::{Slice};\n\n    #[test]\n    fn test_clone() {\n        let original: Box<Slice<i32>> = Box::from(Slice::from_vec(vec![1, 2, 3]));\n        let cloned = original.clone();\n\n        assert_eq!(cloned.into_iter().collect::<Vec<_>>(), original.into_iter().collect::<Vec<_>>());\n    }\n\n    #[test]\n    fn test_clone_empty() {\n        let original: Box<Slice<i32>> = Box::from(Slice::from_vec(vec![]));\n        let cloned = original.clone();\n\n        assert_eq!(cloned.into_iter().collect::<Vec<_>>(), original.into_iter().collect::<Vec<_>>());\n    }\n}\n```", "set::slice::<impl core::cmp::PartialEq<set::slice::Slice<U>> for [T; N]>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cmp::PartialEq;\n\n    #[derive(Clone, Copy, Debug, PartialEq)]\n    struct TestKey {\n        id: usize,\n    }\n\n    #[derive(Clone, Debug, PartialEq)]\n    struct TestValue {\n        data: String,\n    }\n\n    #[test]\n    fn test_eq_identical_slices() {\n        let bucket1 = Bucket { \n            hash: HashValue(1), \n            key: TestKey { id: 1 }, \n            value: TestValue { data: \"Value1\".to_string() }\n        };\n        let bucket2 = Bucket { \n            hash: HashValue(1), \n            key: TestKey { id: 1 }, \n            value: TestValue { data: \"Value1\".to_string() }\n        };\n        let slice1 = Slice { entries: [bucket1] };\n        let slice2 = Slice { entries: [bucket2] };\n\n        assert!(slice1.eq(&slice2));\n    }\n\n    #[test]\n    fn test_eq_different_keys() {\n        let bucket1 = Bucket { \n            hash: HashValue(1), \n            key: TestKey { id: 1 }, \n            value: TestValue { data: \"Value1\".to_string() } \n        };\n        let bucket2 = Bucket { \n            hash: HashValue(1), \n            key: TestKey { id: 2 }, \n            value: TestValue { data: \"Value2\".to_string() } \n        };\n        let slice1 = Slice { entries: [bucket1] };\n        let slice2 = Slice { entries: [bucket2] };\n\n        assert!(!slice1.eq(&slice2));\n    }\n\n    #[test]\n    fn test_eq_different_lengths() {\n        let bucket1 = Bucket { \n            hash: HashValue(1), \n            key: TestKey { id: 1 }, \n            value: TestValue { data: \"Value1\".to_string() } \n        };\n        let bucket2 = Bucket { \n            hash: HashValue(1), \n            key: TestKey { id: 2 }, \n            value: TestValue { data: \"Value2\".to_string() \n        }};\n        let slice1 = Slice { entries: [bucket1] };\n        let slice2 = Slice { entries: [bucket2, bucket2] };\n\n        assert!(!slice1.eq(&slice2));\n    }\n}\n```", "set::slice::<impl core::cmp::PartialEq<set::slice::Slice<U>> for [T]>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::{Slice, Bucket};\n\n    #[test]\n    fn test_slice_eq_empty() {\n        let slice_a = Slice { entries: [] };\n        let slice_b = Slice { entries: [] };\n        assert!(slice_a.eq(&slice_b));\n    }\n\n    #[test]\n    fn test_slice_eq_with_equal_buckets() {\n        let bucket_a = Bucket { hash: HashValue(1), key: 42, value: \"value_a\" };\n        let bucket_b = Bucket { hash: HashValue(1), key: 42, value: \"value_b\" };\n        let slice_a = Slice { entries: [bucket_a] };\n        let slice_b = Slice { entries: [bucket_b] };\n        assert!(slice_a.eq(&slice_b));\n    }\n\n    #[test]\n    fn test_slice_eq_with_different_buckets() {\n        let bucket_a = Bucket { hash: HashValue(1), key: 42, value: \"value_a\" };\n        let bucket_b = Bucket { hash: HashValue(1), key: 43, value: \"value_b\" };\n        let slice_a = Slice { entries: [bucket_a] };\n        let slice_b = Slice { entries: [bucket_b] };\n        assert!(!slice_a.eq(&slice_b));\n    }\n\n    #[test]\n    fn test_slice_eq_with_multiple_buckets() {\n        let bucket_a1 = Bucket { hash: HashValue(1), key: 1, value: \"value1\" };\n        let bucket_a2 = Bucket { hash: HashValue(2), key: 2, value: \"value2\" };\n        let bucket_b1 = Bucket { hash: HashValue(1), key: 1, value: \"value1\" };\n        let bucket_b2 = Bucket { hash: HashValue(2), key: 2, value: \"value2\" };\n        let slice_a = Slice { entries: [bucket_a1, bucket_a2] };\n        let slice_b = Slice { entries: [bucket_b1, bucket_b2] };\n        assert!(slice_a.eq(&slice_b));\n    }\n\n    #[test]\n    fn test_slice_eq_different_length() {\n        let bucket_a = Bucket { hash: HashValue(1), key: 42, value: \"value\" };\n        let slice_a = Slice { entries: [bucket_a] };\n        let slice_b = Slice { entries: [] };\n        assert!(!slice_a.eq(&slice_b));\n    }\n}\n```", "set::slice::<impl core::convert::From<&set::slice::Slice<T>> for alloc::boxed::Box<set::slice::Slice<T>>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::{Slice, Bucket}; // adjust the import path according to your crate structure\n    use crate::HashValue;\n\n    #[test]\n    fn test_from() {\n        // Prepare a specific test case for the Slice<T>\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: 10,\n            value: \"ten\",\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: 20,\n            value: \"twenty\",\n        };\n        let entries = vec![bucket1, bucket2];\n\n        let slice = Slice { entries };\n\n        // Use the from function to create a Box<Slice<T>>\n        let boxed_slice: Box<Slice<_>> = Box::from(&slice);\n\n        // Check the length of the boxed slice\n        assert_eq!(boxed_slice.len(), 2);\n\n        // Check the first and last elements\n        assert_eq!(boxed_slice.first(), Some(&10));\n        assert_eq!(boxed_slice.last(), Some(&20));\n    }\n}\n```", "set::slice::<impl core::default::Default for alloc::boxed::Box<set::slice::Slice<T>>>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::boxed::Box;\n    use set::slice::Slice;\n\n    #[test]\n    fn test_box_slice_default() {\n        let default_box_slice: Box<Slice<i32>> = Box::default();\n        assert!(default_box_slice.is_empty());\n    }\n}\n```", "set::slice::<impl core::iter::IntoIterator for alloc::boxed::Box<set::slice::Slice<T>>>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::set::slice::{Slice, IntoIter};\n\n    #[test]\n    fn test_into_iter() {\n        // Create a Box<Slice<K, V>> with some test data\n        let data: Vec<(i32, i32)> = vec![(1, 10), (2, 20), (3, 30)];\n        let slice = Slice::from_slice(&data);\n        let boxed_slice: Box<Slice<i32, i32>> = Box::new(slice);\n\n        // Call the into_iter function\n        let mut iter: IntoIter<i32, i32> = boxed_slice.into_iter();\n\n        // Check the results\n        assert_eq!(iter.next(), Some((1, 10)));\n        assert_eq!(iter.next(), Some((2, 20)));\n        assert_eq!(iter.next(), Some((3, 30)));\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "set::slice::<impl core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for set::IndexSet<T, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_range() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        map.insert(4, \"four\");\n\n        let slice = map.index(1..3);\n        let expected: Vec<_> = vec![(&1, &\"one\"), (&2, &\"two\")];\n        let actual: Vec<_> = slice.collect();\n\n        assert_eq!(actual, expected);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_range_out_of_bounds() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.index(0..2);\n    }\n\n    #[test]\n    fn test_index_mut_range() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        map.insert(4, \"four\");\n\n        {\n            let slice_mut = map.index_mut(1..3);\n            slice_mut[0] = (&1, \"ONE\");\n            slice_mut[1] = (&2, \"TWO\");\n        }\n\n        assert_eq!(map[&1], \"ONE\");\n        assert_eq!(map[&2], \"TWO\");\n    }\n\n    #[test]\n    fn test_index_get() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        assert_eq!(map.index(0), &\"one\");\n        assert_eq!(map.index(1), &\"two\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_get_out_of_bounds() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        let _ = map.index(2);\n    }\n}\n```", "set::slice::<impl core::ops::Index<core::ops::Range<usize>> for set::IndexSet<T, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index() {\n        let mut map = IndexMap::new();\n        map.insert(0, \"zero\");\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        \n        let slice = map.index(0..2); // get the slice for index range 0..2\n        assert_eq!(slice.as_slice(), &[(0, \"zero\"), (1, \"one\")]);\n\n        let slice = map.index(1..3); // get the slice for index range 1..3\n        assert_eq!(slice.as_slice(), &[(1, \"one\"), (2, \"two\")]);\n\n        let slice = map.index(0..3); // get the slice for index range 0..3\n        assert_eq!(slice.as_slice(), &[(0, \"zero\"), (1, \"one\"), (2, \"two\")]);\n\n        // Check out of bounds - use a range that is too large\n        let result = std::panic::catch_unwind(|| {\n            let _ = map.index(0..4);\n        });\n        assert!(result.is_err());\n    }\n}\n```", "set::slice::<impl core::ops::Index<core::ops::RangeFrom<usize>> for set::IndexSet<T, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_range() {\n        let mut index_map = IndexMap::new();\n        index_map.insert(1, \"a\");\n        index_map.insert(2, \"b\");\n        index_map.insert(3, \"c\");\n\n        // Test valid range\n        let slice = index_map.index(1..3);\n        assert_eq!(slice.as_slice(), &[(2, \"b\"), (3, \"c\")]);\n\n        // Test range from start\n        let slice = index_map.index(0..2);\n        assert_eq!(slice.as_slice(), &[(1, \"a\"), (2, \"b\")]);\n\n        // Test full range\n        let slice = index_map.index(0..3);\n        assert_eq!(slice.as_slice(), &[(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n\n        // Test single index\n        let single = index_map.index(1..2);\n        assert_eq!(single.as_slice(), &[(2, \"b\")]);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_range_out_of_bounds() {\n        let index_map = IndexMap::new();\n        let _ = index_map.index(0..1); // Should panic\n    }\n}\n```", "set::slice::<impl core::ops::Index<core::ops::RangeFull> for set::IndexSet<T, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_range_full() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let slice: &Slice<i32, &str> = &map.index(..);\n        assert_eq!(slice.len(), 3);\n        assert_eq!(slice[0].0, 1);\n        assert_eq!(slice[1].0, 2);\n        assert_eq!(slice[2].0, 3);\n    }\n\n    #[test]\n    fn test_index_range_partial() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let slice: &Slice<i32, &str> = &map.index(1..3);\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice[0].0, 2);\n        assert_eq!(slice[1].0, 3);\n    }\n\n    #[test]\n    fn test_index_range_out_of_bounds() {\n        let mut map: IndexMap<i32, &str> = IndexMap::new();\n        map.insert(1, \"one\");\n\n        let slice: &Slice<i32, &str> = &map.index(0..1);\n        assert_eq!(slice.len(), 1);\n        assert_eq!(slice[0].0, 1);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_panic_out_of_bounds() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let _slice: &Slice<i32, &str> = &map.index(..);\n    }\n}\n```", "set::slice::<impl core::ops::Index<core::ops::RangeInclusive<usize>> for set::IndexSet<T, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_range_inclusive() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        map.insert(4, \"d\");\n\n        let slice = map.index(2..=3);\n        let expected_slice = &[\n            (2, \"b\"),\n            (3, \"c\"),\n        ];\n\n        assert_eq!(slice.as_slice(), expected_slice);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_range_out_of_bounds() {\n        let map = IndexMap::new();\n        let _ = map.index(0..1); // This should panic as the map is empty\n    }\n\n    #[test]\n    fn test_index_range_exceeding_length() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let slice = map.index(0..=1);\n        let expected_slice = &[\n            (1, \"a\"),\n            (2, \"b\"),\n        ];\n\n        assert_eq!(slice.as_slice(), expected_slice);\n    }\n\n    #[test]\n    fn test_index_empty_map() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        assert_eq!(map.index(0..=0).len(), 0); // Slicing an empty map should still yield an empty slice\n    }\n\n    #[test]\n    fn test_index_inclusive_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let slice = map.index(1..=2); // Should get the entries for keys 1 and 2\n        let expected_slice = &[\n            (1, \"a\"),\n            (2, \"b\"),\n        ];\n\n        assert_eq!(slice.as_slice(), expected_slice);\n    }\n\n    #[test]\n    fn test_index_modify_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let slice = map.index_mut(0..=1); // Should allow mutation\n        slice.as_mut().slice_mut().iter_mut().for_each(|(_, v)| *v = \"changed\");\n        \n        assert_eq!(map.index(0..=1).as_slice(), &[\n            (1, \"changed\"),\n            (2, \"changed\"),\n        ]);\n    }\n}\n```", "set::slice::<impl core::ops::Index<core::ops::RangeTo<usize>> for set::IndexSet<T, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_range_basic() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        let slice = map.index(1..3);\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice[0].key, 2);\n        assert_eq!(slice[1].key, 3);\n    }\n\n    #[test]\n    fn test_index_range_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        let slice = map.index(0..1);\n        assert_eq!(slice.len(), 1);\n        assert_eq!(slice[0].key, 1);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_index_range_panic() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        let _slice = map.index(1..5); // Out of bounds should panic\n    }\n\n    #[test]\n    fn test_index_range_empty() {\n        let map: IndexMap<i32, &str> = IndexMap::new();\n        let slice = map.index(0..1);\n        assert_eq!(slice.len(), 0);\n    }\n}\n```", "set::slice::<impl core::ops::Index<core::ops::RangeToInclusive<usize>> for set::IndexSet<T, S>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::IndexMap;\n\n    #[test]\n    fn test_index_range() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        map.insert(4, \"d\");\n\n        // Test valid index range\n        let slice = map.index(1..=3);\n        let entries: Vec<_> = slice.iter().map(|entry| (entry.key, entry.value)).collect();\n        assert_eq!(entries, vec![(2, \"b\"), (3, \"c\"), (4, \"d\")]);\n\n        // Test index range at the boundary\n        let slice_boundary = map.index(..=1);\n        let entries_boundary: Vec<_> = slice_boundary.iter().map(|entry| (entry.key, entry.value)).collect();\n        assert_eq!(entries_boundary, vec![(1, \"a\"), (2, \"b\")]);\n\n        // Test index range exceeding bounds\n        let slice_out_of_bounds = map.index(2..=5);\n        let entries_out_of_bounds: Vec<_> = slice_out_of_bounds.iter().map(|entry| (entry.key, entry.value)).collect();\n        assert_eq!(entries_out_of_bounds, vec![(3, \"c\"), (4, \"d\")]);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_index_out_of_bounds() {\n        let mut map = IndexMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        // This should panic since the index is out of bounds\n        let _ = map.index(3..=5);\n    }\n}\n```", "set::slice::Slice::<T>::binary_search": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n\n    #[test]\n    fn test_binary_search_existing() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"b\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"c\" },\n        ];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.binary_search(&2), Ok(1));\n        assert_eq!(slice.binary_search(&1), Ok(0));\n        assert_eq!(slice.binary_search(&3), Ok(2));\n    }\n\n    #[test]\n    fn test_binary_search_not_existing() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"b\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"c\" },\n        ];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.binary_search(&0), Err(0));\n        assert_eq!(slice.binary_search(&4), Err(3));\n    }\n\n    #[test]\n    fn test_binary_search_empty() {\n        let entries: [Bucket<i32>; 0] = [];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.binary_search(&1), Err(0));\n    }\n}\n```", "set::slice::Slice::<T>::binary_search_by": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // assuming the module for set::slice::Slice is imported\n    use std::cmp::Ordering;\n\n    #[test]\n    fn test_binary_search_by_found() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries: buckets };\n\n        let result = slice.binary_search_by(|&key| key.cmp(&2));\n\n        assert_eq!(result, Ok(1)); // 2 is at index 1\n    }\n\n    #[test]\n    fn test_binary_search_by_not_found() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries: buckets };\n\n        let result = slice.binary_search_by(|&key| key.cmp(&4));\n\n        assert_eq!(result, Err(3)); // 4 can be inserted at index 3\n    }\n\n    #[test]\n    fn test_binary_search_by_edge_case_empty() {\n        let buckets: [Bucket<i32, &str>; 0] = []; // empty\n        let slice = Slice { entries: buckets };\n\n        let result = slice.binary_search_by(|&key| key.cmp(&1));\n\n        assert_eq!(result, Err(0)); // 1 can be inserted at index 0\n    }\n\n    #[test]\n    fn test_binary_search_by_duplicate_keys() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 2, value: \"two_duplicate\" },\n        ];\n        let slice = Slice { entries: buckets };\n\n        let result = slice.binary_search_by(|&key| key.cmp(&2));\n\n        assert_eq!(result, Ok(1)); // First occurrence of key 2 is at index 1\n    }\n}\n```", "set::slice::Slice::<T>::binary_search_by_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n\n    #[test]\n    fn test_binary_search_by_key_existing() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by_key(&2, |&key| key);\n        assert_eq!(result, Ok(1));\n    }\n\n    #[test]\n    fn test_binary_search_by_key_non_existing() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by_key(&4, |&key| key);\n        assert_eq!(result, Err(3));\n    }\n\n    #[test]\n    fn test_binary_search_by_key_insert_position() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 1, value: \"one\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"two\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"three\" },\n        ];\n        let slice = Slice { entries };\n\n        let result = slice.binary_search_by_key(&0, |&key| key);\n        assert_eq!(result, Err(0));\n    }\n}\n```", "set::slice::Slice::<T>::first": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n    use crate::Bucket;\n\n    #[test]\n    fn test_first_non_empty() {\n        let bucket1 = Bucket { hash: HashValue(1), key: \"first\", value: 10 };\n        let bucket2 = Bucket { hash: HashValue(2), key: \"second\", value: 20 };\n        let entries = [bucket1, bucket2];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.first(), Some(&\"first\"));\n    }\n\n    #[test]\n    fn test_first_empty() {\n        let entries: [Bucket<&str>; 0] = [];\n        let slice = Slice { entries };\n\n        assert_eq!(slice.first(), None);\n    }\n}\n```", "set::slice::Slice::<T>::from_boxed": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::set::slice::Slice; // Adjust the import according to the actual structure\n    use std::boxed::Box;\n\n    #[test]\n    fn test_from_boxed() {\n        let entries: Box<[Bucket<i32>]> = Box::new([Bucket::new(1), Bucket::new(2)]);\n        let slice: Box<Slice<i32>> = Slice::from_boxed(entries);\n\n        assert_eq!(slice.into_iter().collect::<Vec<_>>(), vec![1, 2]);\n    }\n}\n```", "set::slice::Slice::<T>::from_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt::Debug;\n\n    #[derive(Clone, Copy, PartialEq, Debug)]\n    struct TestKey(usize);\n\n    #[derive(Clone, Copy, PartialEq, Debug)]\n    struct TestValue(usize);\n\n    #[test]\n    fn test_from_slice_empty() {\n        let slice = Slice::from_slice(&[]);\n        assert!(slice.is_empty());\n        assert_eq!(slice.len(), 0);\n    }\n\n    #[test]\n    fn test_from_slice_single() {\n        let bucket = Bucket {\n            hash: HashValue(1),\n            key: TestKey(42),\n            value: TestValue(100),\n        };\n        let slice = Slice::from_slice(&[bucket]);\n        assert!(!slice.is_empty());\n        assert_eq!(slice.len(), 1);\n        assert_eq!(slice.first(), Some(&TestKey(42)));\n        assert_eq!(slice.get_index(0), Some(&TestKey(42)));\n    }\n\n    #[test]\n    fn test_from_slice_multiple() {\n        let buckets = [\n            Bucket {\n                hash: HashValue(1),\n                key: TestKey(1),\n                value: TestValue(1),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: TestKey(2),\n                value: TestValue(2),\n            },\n        ];\n        let slice = Slice::from_slice(&buckets);\n        assert_eq!(slice.len(), 2);\n        assert_eq!(slice.first(), Some(&TestKey(1)));\n        assert_eq!(slice.last(), Some(&TestKey(2)));\n    }\n\n    #[test]\n    fn test_from_slice_eq() {\n        let buckets1 = [\n            Bucket {\n                hash: HashValue(1),\n                key: TestKey(1),\n                value: TestValue(1),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: TestKey(2),\n                value: TestValue(2),\n            },\n        ];\n        let buckets2 = [\n            Bucket {\n                hash: HashValue(1),\n                key: TestKey(1),\n                value: TestValue(1),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: TestKey(2),\n                value: TestValue(2),\n            },\n        ];\n        let slice1 = Slice::from_slice(&buckets1);\n        let slice2 = Slice::from_slice(&buckets2);\n        assert_eq!(slice1, slice2);\n    }\n}\n```", "set::slice::Slice::<T>::get_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n\n    #[test]\n    fn test_get_index() {\n        let entries = [\n            Bucket { hash: HashValue(1), key: 10, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 20, value: \"b\" },\n            Bucket { hash: HashValue(3), key: 30, value: \"c\" },\n        ];\n        \n        let slice = Slice { entries };\n\n        // Valid index\n        assert_eq!(slice.get_index(0), Some(&10));\n        assert_eq!(slice.get_index(1), Some(&20));\n        assert_eq!(slice.get_index(2), Some(&30));\n\n        // Invalid index\n        assert_eq!(slice.get_index(3), None);\n        assert_eq!(slice.get_index(usize::MAX), None);\n    }\n\n    #[test]\n    fn test_get_index_empty() {\n        let entries: [Bucket<i32>; 0] = [];\n        let slice = Slice { entries };\n\n        // Valid index\n        assert_eq!(slice.get_index(0), None);\n        assert_eq!(slice.get_index(1), None);\n    }\n}\n```", "set::slice::Slice::<T>::get_range": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[derive(Clone, Copy, PartialEq, Debug)]\n    struct TestKey(i32);\n\n    #[derive(Clone, PartialEq, Debug)]\n    struct TestValue(i32);\n\n    #[test]\n    fn test_get_range() {\n        let buckets = [\n            Bucket {\n                hash: HashValue(1),\n                key: TestKey(1),\n                value: TestValue(10),\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: TestKey(2),\n                value: TestValue(20),\n            },\n            Bucket {\n                hash: HashValue(3),\n                key: TestKey(3),\n                value: TestValue(30),\n            },\n        ];\n\n        let slice = Slice { entries: buckets };\n\n        // Test valid range\n        let range = slice.get_range(0..2);\n        assert!(range.is_some());\n        let range = range.unwrap();\n        assert_eq!(range.len(), 2);\n\n        // Test valid range with non-inclusive end\n        let range = slice.get_range(1..3);\n        assert!(range.is_some());\n        assert_eq!(range.unwrap().len(), 2);\n\n        // Test full range\n        let range = slice.get_range(0..3);\n        assert!(range.is_some());\n        assert_eq!(range.unwrap().len(), 3);\n\n        // Test out-of-bounds range\n        let range = slice.get_range(2..5);\n        assert!(range.is_none());\n    }\n\n    #[test]\n    fn test_get_range_empty_slice() {\n        let slice = Slice { entries: [] };\n\n        // Test range on empty slice\n        let range = slice.get_range(0..1);\n        assert!(range.is_none());\n    }\n\n    #[test]\n    fn test_get_range_negative_index() {\n        let buckets = [\n            Bucket {\n                hash: HashValue(1),\n                key: TestKey(1),\n                value: TestValue(10),\n            },\n        ];\n\n        let slice = Slice { entries: buckets };\n\n        // Test negative range\n        let range = slice.get_range(..);\n        assert!(range.is_none());\n    }\n}\n```", "set::slice::Slice::<T>::into_boxed": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n    use std::boxed::Box;\n\n    #[test]\n    fn test_into_boxed() {\n        // Setup\n        let slice: Box<Slice<i32>> = Box::new(Slice::from_boxed(Box::new([1, 2, 3])));\n        \n        // Execute\n        let boxed_array: Box<[Bucket<i32>]> = slice.into_boxed();\n\n        // Verify\n        let boxed_slice: &[Bucket<i32>] = &*boxed_array;\n        assert_eq!(boxed_slice, &[1.into(), 2.into(), 3.into()]);\n    }\n}\n```", "set::slice::Slice::<T>::into_entries": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use indexmap::set::slice::Slice;\n    use indexmap::Bucket;\n\n    #[test]\n    fn test_into_entries() {\n        let slice: Box<Slice<i32>> = Box::default(); // Create a default Box<Slice>\n        let entries: Vec<Bucket<i32>> = slice.into_entries(); // Call into_entries\n\n        // Since the default Slice is empty, entries should be empty\n        assert!(entries.is_empty());\n    }\n\n    #[test]\n    fn test_into_entries_with_values() {\n        let entries_vec = vec![Bucket::Occupied(1), Bucket::Occupied(2)];\n        let slice = Box::from(Slice::from_vec(entries_vec)); // Create a Box<Slice> with values\n        let entries: Vec<Bucket<i32>> = slice.into_entries(); // Call into_entries\n\n        // Entries should contain the values we inserted\n        assert_eq!(entries.len(), 2);\n        assert_eq!(entries[0], Bucket::Occupied(1));\n        assert_eq!(entries[1], Bucket::Occupied(2));\n    }\n}\n```", "set::slice::Slice::<T>::is_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n\n    #[test]\n    fn test_is_empty() {\n        let empty_slice: &Slice<u32> = Slice::new();\n        assert!(empty_slice.is_empty());\n\n        let non_empty_slice = Slice {\n            entries: [\n                Bucket {\n                    hash: HashValue(1),\n                    key: 42,\n                    value: \"value1\",\n                },\n                Bucket {\n                    hash: HashValue(2),\n                    key: 43,\n                    value: \"value2\",\n                },\n            ],\n        };\n        assert!(!non_empty_slice.is_empty());\n    }\n}\n```", "set::slice::Slice::<T>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n    use crate::set::iter::Iter;\n    use crate::Bucket;\n    \n    #[test]\n    fn test_iter() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: 10,\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: 20,\n        };\n        \n        let slice = Slice {\n            entries: [bucket1, bucket2],\n        };\n        \n        let mut iter = slice.iter();\n        \n        assert_eq!(iter.len(), 2);\n        assert_eq!(iter.next(), Some(&\"key1\"));\n        assert_eq!(iter.next(), Some(&\"key2\"));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_empty() {\n        let slice: Slice<&str> = Slice {\n            entries: [],\n        };\n        \n        let mut iter = slice.iter();\n        \n        assert!(iter.is_empty());\n        assert_eq!(iter.len(), 0);\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_with_multiple_elements() {\n        let bucket1 = Bucket {\n            hash: HashValue(1),\n            key: \"key1\",\n            value: 10,\n        };\n        let bucket2 = Bucket {\n            hash: HashValue(2),\n            key: \"key2\",\n            value: 20,\n        };\n        let bucket3 = Bucket {\n            hash: HashValue(3),\n            key: \"key3\",\n            value: 30,\n        };\n        \n        let slice = Slice {\n            entries: [bucket1, bucket2, bucket3],\n        };\n        \n        let mut iter = slice.iter();\n        \n        assert_eq!(iter.len(), 3);\n        assert_eq!(iter.next(), Some(&\"key1\"));\n        assert_eq!(iter.next(), Some(&\"key2\"));\n        assert_eq!(iter.next(), Some(&\"key3\"));\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "set::slice::Slice::<T>::last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n    use crate::Bucket;\n\n    #[test]\n    fn test_last_with_entries() {\n        let buckets = vec![\n            Bucket {\n                hash: HashValue(1),\n                key: 1,\n                value: \"Value1\",\n            },\n            Bucket {\n                hash: HashValue(2),\n                key: 2,\n                value: \"Value2\",\n            },\n            Bucket {\n                hash: HashValue(3),\n                key: 3,\n                value: \"Value3\",\n            },\n        ];\n        let slice = Slice { entries: buckets };\n\n        assert_eq!(slice.last(), Some(&3));\n    }\n\n    #[test]\n    fn test_last_empty() {\n        let buckets: Vec<Bucket<i32, &str>> = vec![];\n        let slice = Slice { entries: buckets };\n\n        assert_eq!(slice.last(), None);\n    }\n}\n```", "set::slice::Slice::<T>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n    use crate::Bucket;\n\n    #[test]\n    fn test_len() {\n        let bucket1 = Bucket { hash: HashValue(1), key: 1, value: \"a\" };\n        let bucket2 = Bucket { hash: HashValue(2), key: 2, value: \"b\" };\n        \n        let slice = Slice { entries: [bucket1, bucket2] };\n        \n        assert_eq!(slice.len(), 2);\n    }\n\n    #[test]\n    fn test_len_empty() {\n        let slice: Slice<i32> = Slice { entries: [] };\n        \n        assert_eq!(slice.len(), 0);\n    }\n}\n```", "set::slice::Slice::<T>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n\n    #[test]\n    fn test_slice_new() {\n        // Call the new function\n        let slice: &Slice<i32> = Slice::new();\n\n        // Check if the slice is empty\n        assert!(slice.is_empty());\n        assert_eq!(slice.len(), 0);\n    }\n}\n```", "set::slice::Slice::<T>::partition_point": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_partition_point() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: 1, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"b\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"c\" },\n        ];\n        let slice = Slice { entries: buckets };\n\n        // Predicate for partition_point: find the first element greater than 2\n        let index = slice.partition_point(|&key| key <= 2);\n        assert_eq!(index, 2);\n\n        // Test partition_point with all elements\n        let index_all = slice.partition_point(|&key| key <= 3);\n        assert_eq!(index_all, 3);\n\n        // Test partition_point with no elements\n        let empty_slice: Slice<i32> = Slice { entries: [] };\n        let index_empty = empty_slice.partition_point(|_| true);\n        assert_eq!(index_empty, 0);\n    }\n}\n```", "set::slice::Slice::<T>::split_at": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n\n    #[test]\n    fn test_split_at() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: 1, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"b\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"c\" },\n        ];\n        let slice = Slice { entries: buckets };\n\n        let (left, right) = slice.split_at(2);\n        \n        assert_eq!(left.len(), 2);\n        assert_eq!(right.len(), 1);\n        \n        assert_eq!(left.get_index(0), Some(&1));\n        assert_eq!(left.get_index(1), Some(&2));\n        assert_eq!(right.get_index(0), Some(&3));\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_split_at_panics_on_out_of_bounds() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: 1, value: \"a\" },\n            Bucket { hash: HashValue(2), key: 2, value: \"b\" },\n            Bucket { hash: HashValue(3), key: 3, value: \"c\" },\n        ];\n        let slice = Slice { entries: buckets };\n\n        // This should panic\n        slice.split_at(4);\n    }\n}\n```", "set::slice::Slice::<T>::split_first": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashSet;\n\n    #[test]\n    fn test_split_first_non_empty() {\n        // Setup test data\n        let bucket1 = Bucket { hash: HashValue(1), key: 1, value: \"a\" };\n        let bucket2 = Bucket { hash: HashValue(2), key: 2, value: \"b\" };\n        let slice = Slice { entries: [bucket1, bucket2] };\n\n        // Call split_first\n        let result = slice.split_first();\n\n        // Validate result\n        assert!(result.is_some());\n        let (first_key, rest_slice) = result.unwrap();\n        assert_eq!(*first_key, 1);\n        assert_eq!(rest_slice.len(), 1);\n        assert_eq!(rest_slice.get_index(0), Some(&2));\n    }\n\n    #[test]\n    fn test_split_first_empty() {\n        // Setup an empty slice\n        let slice: Slice<i32> = Slice { entries: [] };\n\n        // Call split_first\n        let result = slice.split_first();\n\n        // Validate result\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_split_first_single_element() {\n        // Setup test data\n        let bucket1 = Bucket { hash: HashValue(1), key: 1, value: \"a\" };\n        let slice = Slice { entries: [bucket1] };\n\n        // Call split_first\n        let result = slice.split_first();\n\n        // Validate result\n        assert!(result.is_some());\n        let (first_key, rest_slice) = result.unwrap();\n        assert_eq!(*first_key, 1);\n        assert!(rest_slice.is_empty());\n    }\n}\n```", "set::slice::Slice::<T>::split_last": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::set::slice::Slice;\n\n    #[test]\n    fn test_split_last_with_elements() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: \"a\", value: 1 },\n            Bucket { hash: HashValue(2), key: \"b\", value: 2 },\n            Bucket { hash: HashValue(3), key: \"c\", value: 3 },\n        ];\n        let slice = Slice { entries: buckets };\n\n        let result = slice.split_last();\n        assert!(result.is_some());\n        let (last_key, rest) = result.unwrap();\n        assert_eq!(last_key, &\"c\");\n        assert_eq!(rest.len(), 2);\n        assert_eq!(rest.get_index(0), Some(&\"a\"));\n        assert_eq!(rest.get_index(1), Some(&\"b\"));\n    }\n\n    #[test]\n    fn test_split_last_with_empty_slice() {\n        let buckets: [Bucket<&str, usize>; 0] = [];\n        let slice = Slice { entries: buckets };\n\n        let result = slice.split_last();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_split_last_with_one_element() {\n        let buckets = [\n            Bucket { hash: HashValue(1), key: \"a\", value: 1 },\n        ];\n        let slice = Slice { entries: buckets };\n\n        let result = slice.split_last();\n        assert!(result.is_some());\n        let (last_key, rest) = result.unwrap();\n        assert_eq!(last_key, &\"a\");\n        assert!(rest.is_empty());\n    }\n}\n```", "util::simplify_range": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::RangeBounds;\n    use std::ops::Range;\n    use std::ops::Bound;\n\n    #[test]\n    fn test_simplify_range_included_bounds() {\n        let range = 1..3;\n        let simplified = simplify_range(range, 5);\n        assert_eq!(simplified, 1..3);\n    }\n\n    #[test]\n    fn test_simplify_range_excluded_bounds() {\n        let range = 1..=3;\n        let simplified = simplify_range(range, 5);\n        assert_eq!(simplified, 1..4);\n    }\n\n    #[test]\n    fn test_simplify_range_unbounded() {\n        let range = std::ops::Bound::Unbounded..3;\n        let simplified = simplify_range(range, 5);\n        assert_eq!(simplified, 0..3);\n    }\n\n    #[test]\n    fn test_simplify_range_empty() {\n        let range = 3..=3;\n        let simplified = simplify_range(range, 5);\n        assert_eq!(simplified, 3..4);\n    }\n\n    #[test]\n    #[should_panic(expected = \"range start index 5 out of range for slice of length 5\")]\n    fn test_simplify_range_start_out_of_bounds() {\n        let range = 5..10;\n        simplify_range(range, 5);\n    }\n\n    #[test]\n    #[should_panic(expected = \"range end index 10 out of range for slice of length 5\")]\n    fn test_simplify_range_end_out_of_bounds() {\n        let range = 0..10;\n        simplify_range(range, 5);\n    }\n\n    #[test]\n    #[should_panic(expected = \"range start index 6 should be <= range end index 5\")]\n    fn test_simplify_range_start_greater_than_end() {\n        let range = 6..4;\n        simplify_range(range, 5);\n    }\n}\n```", "util::slice_eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::util::slice_eq;\n\n    #[test]\n    fn test_slice_eq_equal() {\n        let left = [1, 2, 3];\n        let right = [1, 2, 3];\n        let eq = |a: &i32, b: &i32| a == b;\n\n        assert!(slice_eq(&left, &right, eq));\n    }\n\n    #[test]\n    fn test_slice_eq_unequal_length() {\n        let left = [1, 2, 3];\n        let right = [1, 2];\n        let eq = |a: &i32, b: &i32| a == b;\n\n        assert!(!slice_eq(&left, &right, eq));\n    }\n\n    #[test]\n    fn test_slice_eq_unequal_elements() {\n        let left = [1, 2, 3];\n        let right = [1, 2, 4];\n        let eq = |a: &i32, b: &i32| a == b;\n\n        assert!(!slice_eq(&left, &right, eq));\n    }\n\n    #[test]\n    fn test_slice_eq_with_strings() {\n        let left = [\"hello\", \"world\"];\n        let right = [\"hello\", \"world\"];\n        let eq = |a: &&str, b: &&str| a == b;\n\n        assert!(slice_eq(&left, &right, eq));\n    }\n\n    #[test]\n    fn test_slice_eq_with_different_string_order() {\n        let left = [\"hello\", \"world\"];\n        let right = [\"world\", \"hello\"];\n        let eq = |a: &&str, b: &&str| a == b;\n\n        assert!(!slice_eq(&left, &right, eq));\n    }\n}\n```", "util::third": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_third() {\n        assert_eq!(third((1, 2, 3)), 3);\n        assert_eq!(third((\"a\", \"b\", \"c\")), \"c\");\n        assert_eq!(third((1.0, 2.0, 3.0)), 3.0);\n        assert_eq!(third((true, false, true)), true);\n    }\n}\n```", "util::try_simplify_range": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::{Bound, Range};\n    use std::ops::RangeBounds;\n\n    #[test]\n    fn test_try_simplify_range_inclusive_start() {\n        let range = 1..=3;\n        let len = 5;\n        let result = try_simplify_range(range, len);\n        assert_eq!(result, Some(1..4));\n    }\n\n    #[test]\n    fn test_try_simplify_range_exclusive_start() {\n        let range = 1..3;\n        let len = 5;\n        let result = try_simplify_range(range, len);\n        assert_eq!(result, Some(1..3));\n    }\n\n    #[test]\n    fn test_try_simplify_range_unbounded_start() {\n        let range = std::ops::Bound::<usize>::Unbounded..=3;\n        let len = 5;\n        let result = try_simplify_range(range, len);\n        assert_eq!(result, Some(0..4));\n    }\n\n    #[test]\n    fn test_try_simplify_range_inclusive_end() {\n        let range = 1..=5;\n        let len = 5;\n        let result = try_simplify_range(range, len);\n        assert_eq!(result, Some(1..6));\n    }\n\n    #[test]\n    fn test_try_simplify_range_exclusive_end() {\n        let range = 1..5;\n        let len = 5;\n        let result = try_simplify_range(range, len);\n        assert_eq!(result, Some(1..5));\n    }\n\n    #[test]\n    fn test_try_simplify_range_unbounded_end() {\n        let range = 1..std::ops::Bound::<usize>::Unbounded;\n        let len = 5;\n        let result = try_simplify_range(range, len);\n        assert_eq!(result, Some(1..5));\n    }\n\n    #[test]\n    fn test_try_simplify_range_invalid_case() {\n        let range = 4..6;\n        let len = 5;\n        let result = try_simplify_range(range, len);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_try_simplify_range_empty_case() {\n        let range = 5..=5;\n        let len = 5;\n        let result = try_simplify_range(range, len);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_try_simplify_range_unbounded_both() {\n        let range = std::ops::Bound::<usize>::Unbounded..std::ops::Bound::<usize>::Unbounded;\n        let len = 5;\n        let result = try_simplify_range(range, len);\n        assert_eq!(result, Some(0..5));\n    }\n}\n```"}