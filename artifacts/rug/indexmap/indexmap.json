{
    "dependencies": {
        "<&'a map::slice::Slice<K, V> as core::iter::IntoIterator>::into_iter": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<&'a mut map::slice::Slice<K, V> as core::iter::IntoIterator>::into_iter": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<&'a set::slice::Slice<T> as core::iter::IntoIterator>::into_iter": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "<&map::slice::Slice<K, V> as core::default::Default>::default": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<&mut map::slice::Slice<K, V> as core::default::Default>::default": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<&set::IndexSet<T, S1> as core::ops::BitAnd<&set::IndexSet<T, S2>>>::bitand": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<&set::IndexSet<T, S1> as core::ops::BitOr<&set::IndexSet<T, S2>>>::bitor": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<&set::IndexSet<T, S1> as core::ops::BitXor<&set::IndexSet<T, S2>>>::bitxor": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<&set::IndexSet<T, S1> as core::ops::Sub<&set::IndexSet<T, S2>>>::sub": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<&set::slice::Slice<T> as core::default::Default>::default": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "<Bucket<K, V> as core::clone::Clone>::clone": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "<Bucket<K, V> as core::clone::Clone>::clone_from": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "<Bucket<K, V> as core::fmt::Debug>::fmt": [
            "Bucket",
            "HashValue",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<GetDisjointMutError as core::clone::Clone>::clone": [
            "GetDisjointMutError"
        ],
        "<GetDisjointMutError as core::cmp::Eq>::assert_receiver_is_total_eq": [
            "GetDisjointMutError"
        ],
        "<GetDisjointMutError as core::cmp::PartialEq>::eq": [
            "GetDisjointMutError"
        ],
        "<GetDisjointMutError as core::fmt::Debug>::fmt": [
            "GetDisjointMutError",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<GetDisjointMutError as core::fmt::Display>::fmt": [
            "GetDisjointMutError",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<HashValue as core::clone::Clone>::clone": [
            "HashValue"
        ],
        "<HashValue as core::cmp::PartialEq>::eq": [
            "HashValue"
        ],
        "<HashValue as core::fmt::Debug>::fmt": [
            "HashValue",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<TryReserveError as core::clone::Clone>::clone": [
            "TryReserveError",
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout"
        ],
        "<TryReserveError as core::cmp::Eq>::assert_receiver_is_total_eq": [
            "TryReserveError",
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout"
        ],
        "<TryReserveError as core::cmp::PartialEq>::eq": [
            "TryReserveError",
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout"
        ],
        "<TryReserveError as core::fmt::Debug>::fmt": [
            "TryReserveError",
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<TryReserveError as core::fmt::Display>::fmt": [
            "TryReserveError",
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<TryReserveErrorKind as core::clone::Clone>::clone": [
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout"
        ],
        "<TryReserveErrorKind as core::cmp::Eq>::assert_receiver_is_total_eq": [
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout"
        ],
        "<TryReserveErrorKind as core::cmp::PartialEq>::eq": [
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout"
        ],
        "<TryReserveErrorKind as core::fmt::Debug>::fmt": [
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<map::IndexMap<K, V, S> as Entries>::as_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as Entries>::as_entries_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as Entries>::into_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as Entries>::with_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::clone::Clone>::clone": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::clone::Clone>::clone_from": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::default::Default>::default": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::iter::Extend<(K, V)>>::extend": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::iter::FromIterator<(K, V)>>::from_iter": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::ops::Index<&Q>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::ops::Index<usize>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::ops::IndexMut<&Q>>::index_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as core::ops::IndexMut<usize>>::index_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as map::core::raw_entry_v1::RawEntryApiV1<K, V, S>>::raw_entry_mut_v1": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilderMut"
        ],
        "<map::IndexMap<K, V, S> as map::core::raw_entry_v1::RawEntryApiV1<K, V, S>>::raw_entry_v1": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilder"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::get_full_mut2": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::get_index_mut2": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::iter_mut2": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::IterMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IterMut2"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::retain2": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V1, S1> as core::cmp::PartialEq<map::IndexMap<K, V2, S2>>>::eq": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::IndexMap<K, V> as core::convert::From<[(K, V); N]>>::from": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::as_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::as_entries_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::into_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::with_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "<map::core::IndexMapCore<K, V> as core::clone::Clone>::clone": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "<map::core::IndexMapCore<K, V> as core::clone::Clone>::clone_from": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "<map::core::IndexMapCore<K, V> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "<map::core::entry::Entry<'_, K, V> as core::fmt::Debug>::fmt": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "<map::core::entry::Entry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "<map::core::entry::IndexedEntry<'_, K, V> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "<map::core::entry::IndexedEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "<map::core::entry::IndexedEntry<'a, K, V> as core::convert::From<map::core::entry::OccupiedEntry<'a, K, V>>>::from": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry",
            "map::core::entry::OccupiedEntry"
        ],
        "<map::core::entry::OccupiedEntry<'_, K, V> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "<map::core::entry::OccupiedEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "<map::core::entry::OccupiedEntry<'a, K, V> as core::convert::From<map::core::entry::IndexedEntry<'a, K, V>>>::from": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry",
            "map::core::entry::OccupiedEntry"
        ],
        "<map::core::entry::VacantEntry<'_, K, V> as core::fmt::Debug>::fmt": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::VacantEntry"
        ],
        "<map::core::entry::VacantEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::VacantEntry"
        ],
        "<map::core::raw_entry_v1::RawEntryBuilder<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilder"
        ],
        "<map::core::raw_entry_v1::RawEntryBuilderMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilderMut"
        ],
        "<map::core::raw_entry_v1::RawEntryMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawEntryMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "<map::core::raw_entry_v1::RawOccupiedEntryMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "<map::core::raw_entry_v1::RawVacantEntryMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "<map::iter::Drain<'_, K, V> as core::fmt::Debug>::fmt": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "map::iter::Drain"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::Drain"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::Drain"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::Drain"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::collect": [
            "alloc::vec::Drain",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::count": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::Drain"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::last": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::Drain"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::next": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::Drain"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::nth": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::Drain"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::size_hint": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::Drain"
        ],
        "<map::iter::IntoIter<K, V> as core::clone::Clone>::clone": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::default::Default>::default": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::fmt::Debug>::fmt": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::ExactSizeIterator>::len": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::collect": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::count": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::last": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::next": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::nth": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::size_hint": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoIter"
        ],
        "<map::iter::IntoKeys<K, V> as core::default::Default>::default": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoKeys<K, V> as core::fmt::Debug>::fmt": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::ExactSizeIterator>::len": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::collect": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::count": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::last": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::next": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::nth": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::size_hint": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoKeys"
        ],
        "<map::iter::IntoValues<K, V> as core::default::Default>::default": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoValues"
        ],
        "<map::iter::IntoValues<K, V> as core::fmt::Debug>::fmt": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "map::iter::IntoValues"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoValues"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoValues"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::ExactSizeIterator>::len": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoValues"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::collect": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IntoValues"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::count": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoValues"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::last": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoValues"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::next": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoValues"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::nth": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoValues"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::size_hint": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "map::iter::IntoValues"
        ],
        "<map::iter::Iter<'_, K, V> as core::clone::Clone>::clone": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'_, K, V> as core::default::Default>::default": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'_, K, V> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::collect": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::count": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::last": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::next": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::nth": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::size_hint": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::default::Default>::default": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::collect": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "core::slice::IterMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::count": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::last": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::next": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::nth": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::size_hint": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "<map::iter::IterMut<'_, K, V> as core::default::Default>::default": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "<map::iter::IterMut<'_, K, V> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "<map::iter::IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "<map::iter::IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "<map::iter::IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::collect": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "core::slice::IterMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IterMut"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::count": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::last": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::next": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::nth": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::size_hint": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "<map::iter::Keys<'_, K, V> as core::clone::Clone>::clone": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'_, K, V> as core::default::Default>::default": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'_, K, V> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'_, K, V> as core::ops::Index<usize>>::index": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::collect": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::count": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::last": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::next": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::nth": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::size_hint": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::fmt::Debug>::fmt": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::fmt::Formatter",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::DoubleEndedIterator>::next_back": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::ExactSizeIterator>::len": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::Iterator>::next": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::Iterator>::size_hint": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::ops::Drop>::drop": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice"
        ],
        "<map::iter::Values<'_, K, V> as core::clone::Clone>::clone": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::Values<'_, K, V> as core::default::Default>::default": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::Values<'_, K, V> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::Values<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::Values<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::Values<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::collect": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Values"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::count": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::last": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::next": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::nth": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::size_hint": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::default::Default>::default": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::collect": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "core::slice::IterMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::ValuesMut"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::count": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::last": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::next": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::nth": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::size_hint": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "<map::slice::Slice<K, V> as core::cmp::Ord>::cmp": [
            "Bucket",
            "HashValue",
            "core::cmp::Ordering",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialEq<[(K2, V2); N]>>::eq": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialEq<[(K2, V2)]>>::eq": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialEq<map::slice::Slice<K2, V2>>>::eq": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialOrd>::partial_cmp": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::fmt::Debug>::fmt": [
            "Bucket",
            "HashValue",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::hash::Hash>::hash": [
            "Bucket",
            "HashValue",
            "core::hash::Hasher",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::Bound",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::Range<usize>>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::Range",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeFrom<usize>>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeFrom",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeFull>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeFull",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeInclusive<usize>>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeInclusive",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeTo<usize>>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeTo",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeToInclusive<usize>>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeToInclusive",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<usize>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::Bound",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::Range<usize>>>::index_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::Range",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeFrom<usize>>>::index_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeFrom",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeFull>>::index_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeFull",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeInclusive<usize>>>::index_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeInclusive",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeTo<usize>>>::index_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeTo",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeToInclusive<usize>>>::index_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeToInclusive",
            "map::slice::Slice"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<usize>>::index_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "<set::IndexSet<T, S1> as core::cmp::PartialEq<set::IndexSet<T, S2>>>::eq": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as Entries>::as_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as Entries>::as_entries_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as Entries>::into_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as Entries>::with_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as core::clone::Clone>::clone": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as core::clone::Clone>::clone_from": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as core::default::Default>::default": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as core::iter::Extend<&'a T>>::extend": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as core::iter::Extend<T>>::extend": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as core::iter::FromIterator<T>>::from_iter": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as core::ops::Index<usize>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as set::mutable::MutableValues>::get_full_mut2": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as set::mutable::MutableValues>::get_index_mut2": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T, S> as set::mutable::MutableValues>::retain2": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::IndexSet<T> as core::convert::From<[T; N]>>::from": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "<set::iter::Difference<'_, T, S> as core::clone::Clone>::clone": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Difference",
            "set::iter::Iter"
        ],
        "<set::iter::Difference<'_, T, S> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Difference",
            "set::iter::Iter"
        ],
        "<set::iter::Difference<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Difference",
            "set::iter::Iter"
        ],
        "<set::iter::Difference<'a, T, S> as core::iter::Iterator>::next": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Difference",
            "set::iter::Iter"
        ],
        "<set::iter::Difference<'a, T, S> as core::iter::Iterator>::size_hint": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Difference",
            "set::iter::Iter"
        ],
        "<set::iter::Drain<'_, T> as core::fmt::Debug>::fmt": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "set::iter::Drain"
        ],
        "<set::iter::Drain<'_, T> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::Drain"
        ],
        "<set::iter::Drain<'_, T> as core::iter::DoubleEndedIterator>::nth_back": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::Drain"
        ],
        "<set::iter::Drain<'_, T> as core::iter::ExactSizeIterator>::len": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::Drain"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::collect": [
            "alloc::vec::Drain",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::iter::Drain"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::count": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::Drain"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::last": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::Drain"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::next": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::Drain"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::nth": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::Drain"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::size_hint": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::Drain"
        ],
        "<set::iter::Intersection<'_, T, S> as core::clone::Clone>::clone": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Intersection",
            "set::iter::Iter"
        ],
        "<set::iter::Intersection<'_, T, S> as core::fmt::Debug>::fmt": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Intersection",
            "set::iter::Iter"
        ],
        "<set::iter::Intersection<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Intersection",
            "set::iter::Iter"
        ],
        "<set::iter::Intersection<'a, T, S> as core::iter::Iterator>::next": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Intersection",
            "set::iter::Iter"
        ],
        "<set::iter::Intersection<'a, T, S> as core::iter::Iterator>::size_hint": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Intersection",
            "set::iter::Iter"
        ],
        "<set::iter::IntoIter<T> as core::clone::Clone>::clone": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::default::Default>::default": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::fmt::Debug>::fmt": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::iter::DoubleEndedIterator>::next_back": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::iter::DoubleEndedIterator>::nth_back": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::iter::ExactSizeIterator>::len": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::collect": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::count": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::last": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::next": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::nth": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::IntoIter"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::size_hint": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::IntoIter"
        ],
        "<set::iter::Iter<'_, T> as core::clone::Clone>::clone": [
            "core::marker::Sized",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'_, T> as core::default::Default>::default": [
            "core::marker::Sized",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'_, T> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'_, T> as core::iter::DoubleEndedIterator>::next_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'_, T> as core::iter::DoubleEndedIterator>::nth_back": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'_, T> as core::iter::ExactSizeIterator>::len": [
            "core::marker::Sized",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::collect": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::FromIterator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::count": [
            "core::marker::Sized",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::last": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::next": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::nth": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::size_hint": [
            "core::marker::Sized",
            "core::option::Option",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::fmt::Debug>::fmt": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::fmt::Formatter",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice",
            "set::iter::Splice"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice",
            "set::iter::Splice"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::ExactSizeIterator>::len": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice",
            "set::iter::Splice"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::Iterator>::next": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice",
            "set::iter::Splice"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::Iterator>::size_hint": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice",
            "set::iter::Splice"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::clone::Clone>::clone": [
            "core::iter::Chain",
            "core::marker::Sized",
            "set::iter::SymmetricDifference"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::iter::Chain",
            "core::marker::Sized",
            "core::result::Result",
            "set::iter::SymmetricDifference"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::iter::DoubleEndedIterator>::next_back": [
            "core::iter::Chain",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::SymmetricDifference"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::iter::DoubleEndedIterator>::rfold": [
            "core::iter::Chain",
            "core::marker::Sized",
            "core::ops::FnMut",
            "set::iter::SymmetricDifference"
        ],
        "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::fold": [
            "core::iter::Chain",
            "core::marker::Sized",
            "core::ops::FnMut",
            "set::iter::SymmetricDifference"
        ],
        "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::next": [
            "core::iter::Chain",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::SymmetricDifference"
        ],
        "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::size_hint": [
            "core::iter::Chain",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::SymmetricDifference"
        ],
        "<set::iter::Union<'_, T, S> as core::clone::Clone>::clone": [
            "core::iter::Chain",
            "core::marker::Sized",
            "set::iter::Union"
        ],
        "<set::iter::Union<'_, T, S> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::iter::Chain",
            "core::marker::Sized",
            "core::result::Result",
            "set::iter::Union"
        ],
        "<set::iter::Union<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "core::iter::Chain",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::Union"
        ],
        "<set::iter::Union<'_, T, S> as core::iter::DoubleEndedIterator>::rfold": [
            "core::iter::Chain",
            "core::marker::Sized",
            "core::ops::FnMut",
            "set::iter::Union"
        ],
        "<set::iter::Union<'a, T, S> as core::iter::Iterator>::fold": [
            "core::iter::Chain",
            "core::marker::Sized",
            "core::ops::FnMut",
            "set::iter::Union"
        ],
        "<set::iter::Union<'a, T, S> as core::iter::Iterator>::next": [
            "core::iter::Chain",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::Union"
        ],
        "<set::iter::Union<'a, T, S> as core::iter::Iterator>::size_hint": [
            "core::iter::Chain",
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::Union"
        ],
        "<set::iter::UnitValue<I> as core::fmt::Debug>::fmt": [
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "set::iter::UnitValue"
        ],
        "<set::iter::UnitValue<I> as core::iter::Iterator>::next": [
            "core::marker::Sized",
            "core::option::Option",
            "set::iter::UnitValue"
        ],
        "<set::slice::Slice<T> as core::cmp::Ord>::cmp": [
            "Bucket",
            "HashValue",
            "core::cmp::Ordering",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialEq<[U; N]>>::eq": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialEq<[U]>>::eq": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialEq<set::slice::Slice<U>>>::eq": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialOrd>::partial_cmp": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::fmt::Debug>::fmt": [
            "Bucket",
            "HashValue",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::hash::Hash>::hash": [
            "Bucket",
            "HashValue",
            "core::hash::Hasher",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::Bound",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::Range<usize>>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::Range",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeFrom<usize>>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeFrom",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeFull>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeFull",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeInclusive<usize>>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeInclusive",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeTo<usize>>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeTo",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeToInclusive<usize>>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeToInclusive",
            "set::slice::Slice"
        ],
        "<set::slice::Slice<T> as core::ops::Index<usize>>::index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "Bucket": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "Bucket::<K, V>::key": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "Bucket::<K, V>::key_ref": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "Bucket::<K, V>::key_value": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "Bucket::<K, V>::muts": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "Bucket::<K, V>::ref_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "Bucket::<K, V>::refs": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "Bucket::<K, V>::value": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "Bucket::<K, V>::value_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "Bucket::<K, V>::value_ref": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "Entries::as_entries": [],
        "Entries::as_entries_mut": [],
        "Entries::into_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "Entries::with_entries": [
            "core::marker::Sized",
            "core::ops::FnOnce"
        ],
        "GetDisjointMutError": [
            "GetDisjointMutError"
        ],
        "HashValue": [
            "HashValue"
        ],
        "HashValue::get": [
            "HashValue"
        ],
        "TryReserveError": [
            "TryReserveError",
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout"
        ],
        "TryReserveError::from_alloc": [
            "TryReserveError",
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout"
        ],
        "TryReserveError::from_hashbrown": [
            "TryReserveError",
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout",
            "hashbrown::TryReserveError"
        ],
        "TryReserveErrorKind": [
            "TryReserveErrorKind",
            "alloc::collections::TryReserveError",
            "core::alloc::Layout"
        ],
        "map::IndexMap": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::append": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::as_mut_slice": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::as_slice": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::binary_search_by": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::binary_search_by_key": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::binary_search_keys": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::capacity": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::clear": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::contains_key": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::drain": [
            "alloc::vec::Drain",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain"
        ],
        "map::IndexMap::<K, V, S>::entry": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::IndexMap::<K, V, S>::first": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::first_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::first_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::get": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::get_disjoint_indices_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::get_disjoint_mut": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::get_full": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::get_full_mut": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::get_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::get_index_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::get_index_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::get_index_of": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::get_key_value": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::get_mut": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::get_range": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::get_range_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::hash": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::hasher": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::insert": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::insert_before": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::insert_full": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::insert_sorted": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::into_boxed_slice": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::into_keys": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IntoKeys"
        ],
        "map::IndexMap::<K, V, S>::into_values": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IntoValues"
        ],
        "map::IndexMap::<K, V, S>::is_empty": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::iter": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Iter"
        ],
        "map::IndexMap::<K, V, S>::iter_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::IterMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IterMut"
        ],
        "map::IndexMap::<K, V, S>::keys": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Keys"
        ],
        "map::IndexMap::<K, V, S>::last": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::last_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::last_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::len": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::move_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::partition_point": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::pop": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::remove": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::remove_entry": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::reserve": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::reserve_exact": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::retain": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::reverse": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::shift_insert": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::shift_remove": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::shift_remove_entry": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::shift_remove_full": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::shift_remove_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::shrink_to": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::shrink_to_fit": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::sort_by": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::sort_by_cached_key": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::sort_keys": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::sort_unstable_by": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::sort_unstable_keys": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::sorted_by": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IntoIter"
        ],
        "map::IndexMap::<K, V, S>::sorted_unstable_by": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IntoIter"
        ],
        "map::IndexMap::<K, V, S>::splice": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::boxed::Box",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::IntoIterator",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::split_off": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::swap_indices": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::swap_remove": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::swap_remove_entry": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::swap_remove_full": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice"
        ],
        "map::IndexMap::<K, V, S>::swap_remove_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::truncate": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::try_reserve": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::try_reserve_exact": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::values": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Values"
        ],
        "map::IndexMap::<K, V, S>::values_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::IterMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::ValuesMut"
        ],
        "map::IndexMap::<K, V, S>::with_capacity_and_hasher": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V, S>::with_hasher": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::IndexMap::<K, V>::with_capacity": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::append_unchecked": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::borrow_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore",
            "map::core::RefMut"
        ],
        "map::core::IndexMapCore::<K, V>::capacity": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::clear": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::drain": [
            "alloc::vec::Drain",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::erase_indices": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::get_index_of": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::insert_full": [
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::len": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::move_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::pop": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::push_entry": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::rebuild_hash_table": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::replace_full": [
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::reserve": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::reserve_exact": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::retain_in_order": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::reverse": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::shift_remove_full": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::shift_remove_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::shrink_to": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::split_off": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::split_splice": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::swap_indices": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::swap_remove_full": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::swap_remove_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::truncate": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::try_reserve": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::try_reserve_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::try_reserve_exact": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::IndexMapCore::<K, V>::with_capacity": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore"
        ],
        "map::core::RefMut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::decrement_indices": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::increment_indices": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::insert_unique": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::RefMut::<'a, K, V>::move_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::reserve_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::shift_insert_unique": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::shift_remove_finish": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::shift_remove_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::swap_indices": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::swap_remove_finish": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::RefMut::<'a, K, V>::swap_remove_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut"
        ],
        "map::core::entry::<impl map::core::IndexMapCore<K, V>>::entry": [
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::Entry": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::Entry::<'a, K, V>::and_modify": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::Entry::<'a, K, V>::index": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::Entry::<'a, K, V>::insert_entry": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::Entry::<'a, K, V>::key": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::Entry::<'a, K, V>::or_default": [
            "HashValue",
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::default::Default",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::Entry::<'a, K, V>::or_insert": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::Entry::<'a, K, V>::or_insert_with": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::Entry::<'a, K, V>::or_insert_with_key": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::Entry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::IndexedEntry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::get": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::get_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::insert": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::into_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::key": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::key_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::move_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::IndexMapCore",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::shift_remove": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::shift_remove_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::swap_indices": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::swap_remove": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::swap_remove_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::IndexedEntry"
        ],
        "map::core::entry::OccupiedEntry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::get": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::get_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::insert": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::into_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::into_muts": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::into_ref_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::key": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::key_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::move_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::remove": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::remove_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::shift_remove": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::shift_remove_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::swap_indices": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::swap_remove": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::swap_remove_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::entry::OccupiedEntry"
        ],
        "map::core::entry::VacantEntry": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::index": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::insert": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::insert_entry": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::insert_sorted": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::VacantEntry",
            "map::slice::Slice"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::into_key": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::key": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::key_mut": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::VacantEntry"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::shift_insert": [
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::entry::VacantEntry"
        ],
        "map::core::equivalent": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "equivalent::Equivalent"
        ],
        "map::core::erase_index": [
            "HashValue",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator"
        ],
        "map::core::get_hash": [
            "Bucket",
            "HashValue",
            "core::marker::Sized"
        ],
        "map::core::insert_bulk_no_grow": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator"
        ],
        "map::core::raw_entry_v1::RawEntryApiV1::raw_entry_mut_v1": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilderMut"
        ],
        "map::core::raw_entry_v1::RawEntryApiV1::raw_entry_v1": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilder"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilder"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_hash": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilder"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_hash_full": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilder"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_key": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilder",
            "map::slice::Slice"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_key_hashed_nocheck": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilder"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::index_from_hash": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilder"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::raw_entry_v1::RawEntryBuilderMut"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_hash": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawEntryBuilderMut",
            "map::core::raw_entry_v1::RawEntryMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_key": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawEntryBuilderMut",
            "map::core::raw_entry_v1::RawEntryMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut",
            "map::core::raw_entry_v1::RawVacantEntryMut",
            "map::slice::Slice"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_key_hashed_nocheck": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawEntryBuilderMut",
            "map::core::raw_entry_v1::RawEntryMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "map::core::raw_entry_v1::RawEntryMut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawEntryMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::and_modify": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawEntryMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawEntryMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::or_insert": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawEntryMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut",
            "map::core::raw_entry_v1::RawVacantEntryMut",
            "map::slice::Slice"
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::or_insert_with": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "core::ops::FnOnce",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawEntryMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut",
            "map::core::raw_entry_v1::RawVacantEntryMut",
            "map::slice::Slice"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_key_value": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_key_value_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::insert": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::insert_key": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_key": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_key_value_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_ref_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::key": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::key_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::move_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::remove": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::remove_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::shift_remove": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::shift_remove_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_indices": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_remove": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_remove_entry": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::PhantomData",
            "core::marker::Sized",
            "hashbrown::hash_table::OccupiedEntry",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::raw_entry_v1::RawOccupiedEntryMut"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::insert": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawVacantEntryMut",
            "map::slice::Slice"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::insert_hashed_nocheck": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::shift_insert": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawVacantEntryMut",
            "map::slice::Slice"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::shift_insert_hashed_nocheck": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::core::RefMut",
            "map::core::raw_entry_v1::RawVacantEntryMut"
        ],
        "map::core::reserve_entries": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "map::core::update_index": [
            "HashValue",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator"
        ],
        "map::iter::<impl core::iter::IntoIterator for &'a map::IndexMap<K, V, S>>::into_iter": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::iter::<impl core::iter::IntoIterator for &'a mut map::IndexMap<K, V, S>>::into_iter": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::iter::<impl core::iter::IntoIterator for map::IndexMap<K, V, S>>::into_iter": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::iter::Drain": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::Drain"
        ],
        "map::iter::Drain::<'a, K, V>::as_slice": [
            "Bucket",
            "HashValue",
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::Drain",
            "map::slice::Slice"
        ],
        "map::iter::Drain::<'a, K, V>::new": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::Drain"
        ],
        "map::iter::IntoIter": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoIter"
        ],
        "map::iter::IntoIter::<K, V>::as_mut_slice": [
            "Bucket",
            "HashValue",
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoIter",
            "map::slice::Slice"
        ],
        "map::iter::IntoIter::<K, V>::as_slice": [
            "Bucket",
            "HashValue",
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoIter",
            "map::slice::Slice"
        ],
        "map::iter::IntoIter::<K, V>::new": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoIter"
        ],
        "map::iter::IntoKeys": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoKeys"
        ],
        "map::iter::IntoKeys::<K, V>::new": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoKeys"
        ],
        "map::iter::IntoValues": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoValues"
        ],
        "map::iter::IntoValues::<K, V>::new": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoValues"
        ],
        "map::iter::Iter": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "map::iter::Iter::<'a, K, V>::as_slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Iter",
            "map::slice::Slice"
        ],
        "map::iter::Iter::<'a, K, V>::new": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Iter"
        ],
        "map::iter::IterMut": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "map::iter::IterMut2": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "map::iter::IterMut2::<'a, K, V>::as_slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut2",
            "map::slice::Slice"
        ],
        "map::iter::IterMut2::<'a, K, V>::into_slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut2",
            "map::slice::Slice"
        ],
        "map::iter::IterMut2::<'a, K, V>::new": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "map::iter::IterMut::<'a, K, V>::as_slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut",
            "map::slice::Slice"
        ],
        "map::iter::IterMut::<'a, K, V>::into_slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut",
            "map::slice::Slice"
        ],
        "map::iter::IterMut::<'a, K, V>::new": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut"
        ],
        "map::iter::Keys": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "map::iter::Keys::<'a, K, V>::new": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Keys"
        ],
        "map::iter::Splice": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice"
        ],
        "map::iter::Splice::<'a, I, K, V, S>::new": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice"
        ],
        "map::iter::Values": [
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "map::iter::Values::<'a, K, V>::new": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Values"
        ],
        "map::iter::ValuesMut": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "map::iter::ValuesMut::<'a, K, V>::new": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::ValuesMut"
        ],
        "map::mutable::MutableEntryKey::key_mut": [],
        "map::mutable::MutableKeys::get_full_mut2": [
            "Bucket",
            "HashValue",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "map::slice::Slice"
        ],
        "map::mutable::MutableKeys::get_index_mut2": [
            "core::marker::Sized",
            "core::option::Option"
        ],
        "map::mutable::MutableKeys::iter_mut2": [
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut2"
        ],
        "map::mutable::MutableKeys::retain2": [
            "core::marker::Sized",
            "core::ops::FnMut"
        ],
        "map::slice::<impl core::clone::Clone for alloc::boxed::Box<map::slice::Slice<K, V>>>::clone": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "map::slice::<impl core::cmp::PartialEq<map::slice::Slice<K2, V2>> for [(K, V); N]>::eq": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::<impl core::cmp::PartialEq<map::slice::Slice<K2, V2>> for [(K, V)]>::eq": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::<impl core::convert::From<&map::slice::Slice<K, V>> for alloc::boxed::Box<map::slice::Slice<K, V>>>::from": [
            "Bucket",
            "HashValue",
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::<impl core::default::Default for alloc::boxed::Box<map::slice::Slice<K, V>>>::default": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "map::slice::<impl core::iter::IntoIterator for alloc::boxed::Box<map::slice::Slice<K, V>>>::into_iter": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "map::slice::<impl core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for map::IndexMap<K, V, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::Bound",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::Index<core::ops::Range<usize>> for map::IndexMap<K, V, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::Range",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeFrom<usize>> for map::IndexMap<K, V, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeFrom",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeFull> for map::IndexMap<K, V, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeFull",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeInclusive<usize>> for map::IndexMap<K, V, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeInclusive",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeTo<usize>> for map::IndexMap<K, V, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeTo",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeToInclusive<usize>> for map::IndexMap<K, V, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeToInclusive",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::IndexMut<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for map::IndexMap<K, V, S>>::index_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::Bound",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::Range<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::Range",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeFrom<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeFrom",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeFull> for map::IndexMap<K, V, S>>::index_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeFull",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeInclusive<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeInclusive",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeTo<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeTo",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeToInclusive<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeToInclusive",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore"
        ],
        "map::slice::Slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::binary_search_by": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::result::Result",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::binary_search_by_key": [
            "Bucket",
            "HashValue",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::result::Result",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::binary_search_keys": [
            "Bucket",
            "HashValue",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::result::Result",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::first": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::first_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::from_boxed": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "map::slice::Slice::<K, V>::from_mut_slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::from_slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::get_disjoint_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::result::Result",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::get_disjoint_opt_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "core::result::Result",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::get_index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::get_index_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::get_range": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::get_range_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::into_boxed": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "map::slice::Slice::<K, V>::into_entries": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "map::slice::Slice::<K, V>::into_keys": [
            "alloc::boxed::Box",
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoKeys"
        ],
        "map::slice::Slice::<K, V>::into_values": [
            "alloc::boxed::Box",
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "map::iter::IntoValues"
        ],
        "map::slice::Slice::<K, V>::is_empty": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::iter": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Iter",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::iter_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::IterMut",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::keys": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Keys",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::last": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::last_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::len": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::new": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::new_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::partition_point": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::FnMut",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::split_at": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::split_at_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::split_first": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::split_first_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::split_last": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::split_last_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::values": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::Iter",
            "map::iter::Values",
            "map::slice::Slice"
        ],
        "map::slice::Slice::<K, V>::values_mut": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::IterMut",
            "map::iter::ValuesMut",
            "map::slice::Slice"
        ],
        "set::IndexSet": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::append": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::as_slice": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::slice::Slice"
        ],
        "set::IndexSet::<T, S>::binary_search": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::binary_search_by": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::binary_search_by_key": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::capacity": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::clear": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::contains": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::difference": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Difference",
            "set::iter::Iter"
        ],
        "set::IndexSet::<T, S>::drain": [
            "alloc::vec::Drain",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Drain"
        ],
        "set::IndexSet::<T, S>::first": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::get": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::get_full": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::get_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::get_index_of": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::get_range": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::hasher": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::insert": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::insert_before": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::insert_full": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::insert_sorted": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::intersection": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Intersection",
            "set::iter::Iter"
        ],
        "set::IndexSet::<T, S>::into_boxed_slice": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::is_disjoint": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::is_empty": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::is_subset": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::is_superset": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::iter": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Iter"
        ],
        "set::IndexSet::<T, S>::last": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::len": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::move_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::partition_point": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::pop": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::remove": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::replace": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::replace_full": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::reserve": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::reserve_exact": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::retain": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::reverse": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::shift_insert": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::shift_remove": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::shift_remove_full": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::shift_remove_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::shift_take": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::shrink_to": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::shrink_to_fit": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::sort": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::sort_by": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::sort_by_cached_key": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::sort_unstable": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Ord",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::sort_unstable_by": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::sorted_by": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::IntoIter"
        ],
        "set::IndexSet::<T, S>::sorted_unstable_by": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::FnMut",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::IntoIter"
        ],
        "set::IndexSet::<T, S>::splice": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::boxed::Box",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::IntoIterator",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice",
            "set::IndexSet",
            "set::iter::Splice"
        ],
        "set::IndexSet::<T, S>::split_off": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::clone::Clone",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::swap_indices": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::swap_remove": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::swap_remove_full": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::swap_remove_index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::option::Option",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::swap_take": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::symmetric_difference": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::iter::Chain",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::SymmetricDifference"
        ],
        "set::IndexSet::<T, S>::take": [
            "Bucket",
            "HashValue",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::slice::Slice",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::truncate": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::try_reserve": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::try_reserve_exact": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::result::Result",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::union": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::iter::Chain",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Union"
        ],
        "set::IndexSet::<T, S>::with_capacity_and_hasher": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T, S>::with_hasher": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::IndexSet::<T>::with_capacity": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::iter::<impl core::iter::IntoIterator for &'a set::IndexSet<T, S>>::into_iter": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::iter::<impl core::iter::IntoIterator for set::IndexSet<T, S>>::into_iter": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::iter::Difference": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Difference",
            "set::iter::Iter"
        ],
        "set::iter::Difference::<'a, T, S>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Difference",
            "set::iter::Iter"
        ],
        "set::iter::Drain": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::Drain"
        ],
        "set::iter::Drain::<'a, T>::as_slice": [
            "Bucket",
            "HashValue",
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::Drain",
            "set::slice::Slice"
        ],
        "set::iter::Drain::<'a, T>::new": [
            "alloc::vec::Drain",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::Drain"
        ],
        "set::iter::Intersection": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Intersection",
            "set::iter::Iter"
        ],
        "set::iter::Intersection::<'a, T, S>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::slice::Iter",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Intersection",
            "set::iter::Iter"
        ],
        "set::iter::IntoIter": [
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::IntoIter"
        ],
        "set::iter::IntoIter::<T>::as_slice": [
            "Bucket",
            "HashValue",
            "alloc::vec::IntoIter",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::IntoIter",
            "set::slice::Slice"
        ],
        "set::iter::IntoIter::<T>::new": [
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::iter::IntoIter"
        ],
        "set::iter::Iter": [
            "core::marker::Sized",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "set::iter::Iter::<'a, T>::as_slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::Iter",
            "set::iter::Iter",
            "set::slice::Slice"
        ],
        "set::iter::Iter::<'a, T>::new": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::Iter",
            "set::iter::Iter"
        ],
        "set::iter::Splice": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice",
            "set::iter::Splice"
        ],
        "set::iter::Splice::<'a, I, T, S>::new": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "alloc::vec::Drain",
            "alloc::vec::IntoIter",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::cmp::Eq",
            "core::hash::BuildHasher",
            "core::hash::Hash",
            "core::iter::Iterator",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::Drain",
            "map::iter::Splice",
            "map::slice::Slice",
            "set::IndexSet",
            "set::iter::Splice"
        ],
        "set::iter::SymmetricDifference": [
            "core::iter::Chain",
            "core::marker::Sized",
            "set::iter::SymmetricDifference"
        ],
        "set::iter::SymmetricDifference::<'a, T, S1, S2>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::Chain",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::SymmetricDifference"
        ],
        "set::iter::Union": [
            "core::iter::Chain",
            "core::marker::Sized",
            "set::iter::Union"
        ],
        "set::iter::Union::<'a, T, S>::new": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::hash::BuildHasher",
            "core::iter::Chain",
            "core::marker::Sized",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet",
            "set::iter::Union"
        ],
        "set::iter::UnitValue": [
            "core::marker::Sized",
            "set::iter::UnitValue"
        ],
        "set::mutable::MutableValues::get_full_mut2": [
            "Bucket",
            "HashValue",
            "core::hash::Hash",
            "core::marker::Sized",
            "core::option::Option",
            "equivalent::Equivalent",
            "map::slice::Slice"
        ],
        "set::mutable::MutableValues::get_index_mut2": [
            "core::marker::Sized",
            "core::option::Option"
        ],
        "set::mutable::MutableValues::retain2": [
            "core::marker::Sized",
            "core::ops::FnMut"
        ],
        "set::slice::<impl core::clone::Clone for alloc::boxed::Box<set::slice::Slice<T>>>::clone": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "set::slice::<impl core::cmp::PartialEq<set::slice::Slice<U>> for [T; N]>::eq": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "set::slice::<impl core::cmp::PartialEq<set::slice::Slice<U>> for [T]>::eq": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "set::slice::<impl core::convert::From<&set::slice::Slice<T>> for alloc::boxed::Box<set::slice::Slice<T>>>::from": [
            "Bucket",
            "HashValue",
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "set::slice::<impl core::default::Default for alloc::boxed::Box<set::slice::Slice<T>>>::default": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "set::slice::<impl core::iter::IntoIterator for alloc::boxed::Box<set::slice::Slice<T>>>::into_iter": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "set::slice::<impl core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for set::IndexSet<T, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::Bound",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::slice::<impl core::ops::Index<core::ops::Range<usize>> for set::IndexSet<T, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::Range",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeFrom<usize>> for set::IndexSet<T, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeFrom",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeFull> for set::IndexSet<T, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeFull",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeInclusive<usize>> for set::IndexSet<T, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeInclusive",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeTo<usize>> for set::IndexSet<T, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeTo",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeToInclusive<usize>> for set::IndexSet<T, S>>::index": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized",
            "core::ops::RangeToInclusive",
            "hashbrown::HashTable",
            "hashbrown::raw::alloc::inner::Allocator",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "set::slice::Slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::binary_search": [
            "Bucket",
            "HashValue",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::result::Result",
            "map::slice::Slice",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::binary_search_by": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::result::Result",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::binary_search_by_key": [
            "Bucket",
            "HashValue",
            "core::cmp::Ord",
            "core::marker::Sized",
            "core::ops::FnMut",
            "core::result::Result",
            "map::slice::Slice",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::first": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::from_boxed": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "set::slice::Slice::<T>::from_slice": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::get_index": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::get_range": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "core::option::Option",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::into_boxed": [
            "alloc::boxed::Box",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "set::slice::Slice::<T>::into_entries": [
            "alloc::boxed::Box",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::marker::Sized"
        ],
        "set::slice::Slice::<T>::is_empty": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::iter": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::slice::Iter",
            "set::iter::Iter",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::last": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::len": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::new": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::partition_point": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::ops::FnMut",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::split_at": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::split_first": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "set::slice::Slice"
        ],
        "set::slice::Slice::<T>::split_last": [
            "Bucket",
            "HashValue",
            "core::marker::Sized",
            "core::option::Option",
            "set::slice::Slice"
        ],
        "util::simplify_range": [
            "core::marker::Sized",
            "core::ops::Range",
            "core::ops::RangeBounds"
        ],
        "util::slice_eq": [
            "core::marker::Sized",
            "core::ops::Fn"
        ],
        "util::third": [
            "core::marker::Sized"
        ],
        "util::try_simplify_range": [
            "core::marker::Sized",
            "core::ops::RangeBounds",
            "core::option::Option"
        ]
    },
    "glob_path_import": {},
    "self_to_fn": {
        "Bucket": [
            "Copy",
            "Debug",
            "impl<K, V> Bucket<K, V> {\n    // field accessors -- used for `f` instead of closures in `.map(f)`\n    fn key_ref(&self) -> &K {\n        &self.key\n    }\n    fn value_ref(&self) -> &V {\n        &self.value\n    }\n    fn value_mut(&mut self) -> &mut V {\n        &mut self.value\n    }\n    fn key(self) -> K {\n        self.key\n    }\n    fn value(self) -> V {\n        self.value\n    }\n    fn key_value(self) -> (K, V) {\n        (self.key, self.value)\n    }\n    fn refs(&self) -> (&K, &V) {\n        (&self.key, &self.value)\n    }\n    fn ref_mut(&mut self) -> (&K, &mut V) {\n        (&self.key, &mut self.value)\n    }\n    fn muts(&mut self) -> (&mut K, &mut V) {\n        (&mut self.key, &mut self.value)\n    }\n}",
            "impl<K, V> Clone for Bucket<K, V>\nwhere\n    K: Clone,\n    V: Clone,\n{\n    fn clone(&self) -> Self {\n        Bucket {\n            hash: self.hash,\n            key: self.key.clone(),\n            value: self.value.clone(),\n        }\n    }\n\n    fn clone_from(&mut self, other: &Self) {\n        self.hash = other.hash;\n        self.key.clone_from(&other.key);\n        self.value.clone_from(&other.value);\n    }\n}"
        ],
        "GetDisjointMutError": [
            "Clone",
            "Debug",
            "Eq",
            "PartialEq",
            "impl core::fmt::Display for GetDisjointMutError {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let msg = match self {\n            GetDisjointMutError::IndexOutOfBounds => \"an index is out of bounds\",\n            GetDisjointMutError::OverlappingIndices => \"there were overlapping indices\",\n        };\n\n        core::fmt::Display::fmt(msg, f)\n    }\n}",
            "impl std::error::Error for GetDisjointMutError {}"
        ],
        "HashValue": [
            "Clone",
            "Copy",
            "Debug",
            "PartialEq",
            "impl HashValue {\n    #[inline(always)]\n    fn get(self) -> u64 {\n        self.0 as u64\n    }\n}"
        ],
        "TryReserveError": [
            "Clone",
            "Debug",
            "Eq",
            "PartialEq",
            "impl TryReserveError {\n    fn from_alloc(error: alloc::collections::TryReserveError) -> Self {\n        Self {\n            kind: TryReserveErrorKind::Std(error),\n        }\n    }\n\n    fn from_hashbrown(error: hashbrown::TryReserveError) -> Self {\n        Self {\n            kind: match error {\n                hashbrown::TryReserveError::CapacityOverflow => {\n                    TryReserveErrorKind::CapacityOverflow\n                }\n                hashbrown::TryReserveError::AllocError { layout } => {\n                    TryReserveErrorKind::AllocError { layout }\n                }\n            },\n        }\n    }\n}",
            "impl core::fmt::Display for TryReserveError {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        let reason = match &self.kind {\n            TryReserveErrorKind::Std(e) => return core::fmt::Display::fmt(e, f),\n            TryReserveErrorKind::CapacityOverflow => {\n                \" because the computed capacity exceeded the collection's maximum\"\n            }\n            TryReserveErrorKind::AllocError { .. } => {\n                \" because the memory allocator returned an error\"\n            }\n        };\n        f.write_str(\"memory allocation failed\")?;\n        f.write_str(reason)\n    }\n}",
            "impl std::error::Error for TryReserveError {}"
        ],
        "TryReserveErrorKind": [
            "Clone",
            "Debug",
            "Eq",
            "PartialEq"
        ],
        "alloc::boxed::Box": [
            "impl<K, V> Default for Box<Slice<K, V>> {\n    fn default() -> Self {\n        Slice::from_boxed(Box::default())\n    }\n}",
            "impl<K, V> IntoIterator for Box<Slice<K, V>> {\n    type IntoIter = IntoIter<K, V>;\n    type Item = (K, V);\n\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter::new(self.into_entries())\n    }\n}",
            "impl<K: Clone, V: Clone> Clone for Box<Slice<K, V>> {\n    fn clone(&self) -> Self {\n        Slice::from_boxed(self.entries.to_vec().into_boxed_slice())\n    }\n}",
            "impl<K: Copy, V: Copy> From<&Slice<K, V>> for Box<Slice<K, V>> {\n    fn from(slice: &Slice<K, V>) -> Self {\n        Slice::from_boxed(Box::from(&slice.entries))\n    }\n}",
            "impl<T: Clone> Clone for Box<Slice<T>> {\n    fn clone(&self) -> Self {\n        Slice::from_boxed(self.entries.to_vec().into_boxed_slice())\n    }\n}",
            "impl<T: Copy> From<&Slice<T>> for Box<Slice<T>> {\n    fn from(slice: &Slice<T>) -> Self {\n        Slice::from_boxed(Box::from(&slice.entries))\n    }\n}",
            "impl<T> Default for Box<Slice<T>> {\n    fn default() -> Self {\n        Slice::from_boxed(Box::default())\n    }\n}",
            "impl<T> IntoIterator for Box<Slice<T>> {\n    type IntoIter = IntoIter<T>;\n    type Item = T;\n\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter::new(self.into_entries())\n    }\n}"
        ],
        "map::IndexMap": [
            "impl<'a, K, V, S> Extend<(&'a K, &'a V)> for IndexMap<K, V, S>\nwhere\n    K: Hash + Eq + Copy,\n    V: Copy,\n    S: BuildHasher,\n{\n    /// Extend the map with all key-value pairs in the iterable.\n    ///\n    /// See the first extend method for more details.\n    fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iterable: I) {\n        self.extend(iterable.into_iter().map(|(&key, &value)| (key, value)));\n    }\n}",
            "impl<K, V, Q: ?Sized, S> Index<&Q> for IndexMap<K, V, S>\nwhere\n    Q: Hash + Equivalent<K>,\n    S: BuildHasher,\n{\n    type Output = V;\n\n    /// Returns a reference to the value corresponding to the supplied `key`.\n    ///\n    /// ***Panics*** if `key` is not present in the map.\n    fn index(&self, key: &Q) -> &V {\n        self.get(key).expect(\"no entry found for key\")\n    }\n}",
            "impl<K, V, Q: ?Sized, S> IndexMut<&Q> for IndexMap<K, V, S>\nwhere\n    Q: Hash + Equivalent<K>,\n    S: BuildHasher,\n{\n    /// Returns a mutable reference to the value corresponding to the supplied `key`.\n    ///\n    /// ***Panics*** if `key` is not present in the map.\n    fn index_mut(&mut self, key: &Q) -> &mut V {\n        self.get_mut(key).expect(\"no entry found for key\")\n    }\n}",
            "impl<K, V, S> Clone for IndexMap<K, V, S>\nwhere\n    K: Clone,\n    V: Clone,\n    S: Clone,\n{\n    fn clone(&self) -> Self {\n        IndexMap {\n            core: self.core.clone(),\n            hash_builder: self.hash_builder.clone(),\n        }\n    }\n\n    fn clone_from(&mut self, other: &Self) {\n        self.core.clone_from(&other.core);\n        self.hash_builder.clone_from(&other.hash_builder);\n    }\n}",
            "impl<K, V, S> Default for IndexMap<K, V, S>\nwhere\n    S: Default,\n{\n    /// Return an empty [`IndexMap`]\n    fn default() -> Self {\n        Self::with_capacity_and_hasher(0, S::default())\n    }\n}",
            "impl<K, V, S> Entries for IndexMap<K, V, S> {\n    type Entry = Bucket<K, V>;\n\n    #[inline]\n    fn into_entries(self) -> Vec<Self::Entry> {\n        self.core.into_entries()\n    }\n\n    #[inline]\n    fn as_entries(&self) -> &[Self::Entry] {\n        self.core.as_entries()\n    }\n\n    #[inline]\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry] {\n        self.core.as_entries_mut()\n    }\n\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]),\n    {\n        self.core.with_entries(f);\n    }\n}",
            "impl<K, V, S> Eq for IndexMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    S: BuildHasher,\n{\n}",
            "impl<K, V, S> Extend<(K, V)> for IndexMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    /// Extend the map with all key-value pairs in the iterable.\n    ///\n    /// This is equivalent to calling [`insert`][IndexMap::insert] for each of\n    /// them in order, which means that for keys that already existed\n    /// in the map, their value is updated but it keeps the existing order.\n    ///\n    /// New keys are inserted in the order they appear in the sequence. If\n    /// equivalents of a key occur more than once, the last corresponding value\n    /// prevails.\n    fn extend<I: IntoIterator<Item = (K, V)>>(&mut self, iterable: I) {\n        // (Note: this is a copy of `std`/`hashbrown`'s reservation logic.)\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let iter = iterable.into_iter();\n        let reserve = if self.is_empty() {\n            iter.size_hint().0\n        } else {\n            (iter.size_hint().0 + 1) / 2\n        };\n        self.reserve(reserve);\n        iter.for_each(move |(k, v)| {\n            self.insert(k, v);\n        });\n    }\n}",
            "impl<K, V, S> FromIterator<(K, V)> for IndexMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    S: BuildHasher + Default,\n{\n    /// Create an `IndexMap` from the sequence of key-value pairs in the\n    /// iterable.\n    ///\n    /// `from_iter` uses the same logic as `extend`. See\n    /// [`extend`][IndexMap::extend] for more details.\n    fn from_iter<I: IntoIterator<Item = (K, V)>>(iterable: I) -> Self {\n        let iter = iterable.into_iter();\n        let (low, _) = iter.size_hint();\n        let mut map = Self::with_capacity_and_hasher(low, <_>::default());\n        map.extend(iter);\n        map\n    }\n}",
            "impl<K, V, S> Index<$range> for IndexMap<K, V, S> {\n            type Output = Slice<K, V>;\n\n            fn index(&self, range: $range) -> &Self::Output {\n                Slice::from_slice(&self.as_entries()[range])\n            }\n        }",
            "impl<K, V, S> Index<usize> for IndexMap<K, V, S> {\n    type Output = V;\n\n    /// Returns a reference to the value at the supplied `index`.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    fn index(&self, index: usize) -> &V {\n        self.get_index(index)\n            .unwrap_or_else(|| {\n                panic!(\n                    \"index out of bounds: the len is {len} but the index is {index}\",\n                    len = self.len()\n                );\n            })\n            .1\n    }\n}",
            "impl<K, V, S> IndexMap<K, V, S>\nwhere\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    /// Insert a key-value pair in the map.\n    ///\n    /// If an equivalent key already exists in the map: the key remains and\n    /// retains in its place in the order, its corresponding value is updated\n    /// with `value`, and the older value is returned inside `Some(_)`.\n    ///\n    /// If no equivalent key existed in the map: the new key-value pair is\n    /// inserted, last in order, and `None` is returned.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    ///\n    /// See also [`entry`][Self::entry] if you want to insert *or* modify,\n    /// or [`insert_full`][Self::insert_full] if you need to get the index of\n    /// the corresponding key-value pair.\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n        self.insert_full(key, value).1\n    }\n\n    /// Insert a key-value pair in the map, and get their index.\n    ///\n    /// If an equivalent key already exists in the map: the key remains and\n    /// retains in its place in the order, its corresponding value is updated\n    /// with `value`, and the older value is returned inside `(index, Some(_))`.\n    ///\n    /// If no equivalent key existed in the map: the new key-value pair is\n    /// inserted, last in order, and `(index, None)` is returned.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    ///\n    /// See also [`entry`][Self::entry] if you want to insert *or* modify.\n    pub fn insert_full(&mut self, key: K, value: V) -> (usize, Option<V>) {\n        let hash = self.hash(&key);\n        self.core.insert_full(hash, key, value)\n    }\n\n    /// Insert a key-value pair in the map at its ordered position among sorted keys.\n    ///\n    /// This is equivalent to finding the position with\n    /// [`binary_search_keys`][Self::binary_search_keys], then either updating\n    /// it or calling [`insert_before`][Self::insert_before] for a new key.\n    ///\n    /// If the sorted key is found in the map, its corresponding value is\n    /// updated with `value`, and the older value is returned inside\n    /// `(index, Some(_))`. Otherwise, the new key-value pair is inserted at\n    /// the sorted position, and `(index, None)` is returned.\n    ///\n    /// If the existing keys are **not** already sorted, then the insertion\n    /// index is unspecified (like [`slice::binary_search`]), but the key-value\n    /// pair is moved to or inserted at that position regardless.\n    ///\n    /// Computes in **O(n)** time (average). Instead of repeating calls to\n    /// `insert_sorted`, it may be faster to call batched [`insert`][Self::insert]\n    /// or [`extend`][Self::extend] and only call [`sort_keys`][Self::sort_keys]\n    /// or [`sort_unstable_keys`][Self::sort_unstable_keys] once.\n    pub fn insert_sorted(&mut self, key: K, value: V) -> (usize, Option<V>)\n    where\n        K: Ord,\n    {\n        match self.binary_search_keys(&key) {\n            Ok(i) => (i, Some(mem::replace(&mut self[i], value))),\n            Err(i) => self.insert_before(i, key, value),\n        }\n    }\n\n    /// Insert a key-value pair in the map before the entry at the given index, or at the end.\n    ///\n    /// If an equivalent key already exists in the map: the key remains and\n    /// is moved to the new position in the map, its corresponding value is updated\n    /// with `value`, and the older value is returned inside `Some(_)`. The returned index\n    /// will either be the given index or one less, depending on how the entry moved.\n    /// (See [`shift_insert`](Self::shift_insert) for different behavior here.)\n    ///\n    /// If no equivalent key existed in the map: the new key-value pair is\n    /// inserted exactly at the given index, and `None` is returned.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    /// Valid indices are `0..=map.len()` (inclusive).\n    ///\n    /// Computes in **O(n)** time (average).\n    ///\n    /// See also [`entry`][Self::entry] if you want to insert *or* modify,\n    /// perhaps only using the index for new entries with [`VacantEntry::shift_insert`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use indexmap::IndexMap;\n    /// let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n    ///\n    /// // The new key '*' goes exactly at the given index.\n    /// assert_eq!(map.get_index_of(&'*'), None);\n    /// assert_eq!(map.insert_before(10, '*', ()), (10, None));\n    /// assert_eq!(map.get_index_of(&'*'), Some(10));\n    ///\n    /// // Moving the key 'a' up will shift others down, so this moves *before* 10 to index 9.\n    /// assert_eq!(map.insert_before(10, 'a', ()), (9, Some(())));\n    /// assert_eq!(map.get_index_of(&'a'), Some(9));\n    /// assert_eq!(map.get_index_of(&'*'), Some(10));\n    ///\n    /// // Moving the key 'z' down will shift others up, so this moves to exactly 10.\n    /// assert_eq!(map.insert_before(10, 'z', ()), (10, Some(())));\n    /// assert_eq!(map.get_index_of(&'z'), Some(10));\n    /// assert_eq!(map.get_index_of(&'*'), Some(11));\n    ///\n    /// // Moving or inserting before the endpoint is also valid.\n    /// assert_eq!(map.len(), 27);\n    /// assert_eq!(map.insert_before(map.len(), '*', ()), (26, Some(())));\n    /// assert_eq!(map.get_index_of(&'*'), Some(26));\n    /// assert_eq!(map.insert_before(map.len(), '+', ()), (27, None));\n    /// assert_eq!(map.get_index_of(&'+'), Some(27));\n    /// assert_eq!(map.len(), 28);\n    /// ```\n    #[track_caller]\n    pub fn insert_before(&mut self, mut index: usize, key: K, value: V) -> (usize, Option<V>) {\n        let len = self.len();\n\n        assert!(\n            index <= len,\n            \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"\n        );\n\n        match self.entry(key) {\n            Entry::Occupied(mut entry) => {\n                if index > entry.index() {\n                    // Some entries will shift down when this one moves up,\n                    // so \"insert before index\" becomes \"move to index - 1\",\n                    // keeping the entry at the original index unmoved.\n                    index -= 1;\n                }\n                let old = mem::replace(entry.get_mut(), value);\n                entry.move_index(index);\n                (index, Some(old))\n            }\n            Entry::Vacant(entry) => {\n                entry.shift_insert(index, value);\n                (index, None)\n            }\n        }\n    }\n\n    /// Insert a key-value pair in the map at the given index.\n    ///\n    /// If an equivalent key already exists in the map: the key remains and\n    /// is moved to the given index in the map, its corresponding value is updated\n    /// with `value`, and the older value is returned inside `Some(_)`.\n    /// Note that existing entries **cannot** be moved to `index == map.len()`!\n    /// (See [`insert_before`](Self::insert_before) for different behavior here.)\n    ///\n    /// If no equivalent key existed in the map: the new key-value pair is\n    /// inserted at the given index, and `None` is returned.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    /// Valid indices are `0..map.len()` (exclusive) when moving an existing entry, or\n    /// `0..=map.len()` (inclusive) when inserting a new key.\n    ///\n    /// Computes in **O(n)** time (average).\n    ///\n    /// See also [`entry`][Self::entry] if you want to insert *or* modify,\n    /// perhaps only using the index for new entries with [`VacantEntry::shift_insert`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use indexmap::IndexMap;\n    /// let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n    ///\n    /// // The new key '*' goes exactly at the given index.\n    /// assert_eq!(map.get_index_of(&'*'), None);\n    /// assert_eq!(map.shift_insert(10, '*', ()), None);\n    /// assert_eq!(map.get_index_of(&'*'), Some(10));\n    ///\n    /// // Moving the key 'a' up to 10 will shift others down, including the '*' that was at 10.\n    /// assert_eq!(map.shift_insert(10, 'a', ()), Some(()));\n    /// assert_eq!(map.get_index_of(&'a'), Some(10));\n    /// assert_eq!(map.get_index_of(&'*'), Some(9));\n    ///\n    /// // Moving the key 'z' down to 9 will shift others up, including the '*' that was at 9.\n    /// assert_eq!(map.shift_insert(9, 'z', ()), Some(()));\n    /// assert_eq!(map.get_index_of(&'z'), Some(9));\n    /// assert_eq!(map.get_index_of(&'*'), Some(10));\n    ///\n    /// // Existing keys can move to len-1 at most, but new keys can insert at the endpoint.\n    /// assert_eq!(map.len(), 27);\n    /// assert_eq!(map.shift_insert(map.len() - 1, '*', ()), Some(()));\n    /// assert_eq!(map.get_index_of(&'*'), Some(26));\n    /// assert_eq!(map.shift_insert(map.len(), '+', ()), None);\n    /// assert_eq!(map.get_index_of(&'+'), Some(27));\n    /// assert_eq!(map.len(), 28);\n    /// ```\n    ///\n    /// ```should_panic\n    /// use indexmap::IndexMap;\n    /// let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n    ///\n    /// // This is an invalid index for moving an existing key!\n    /// map.shift_insert(map.len(), 'a', ());\n    /// ```\n    #[track_caller]\n    pub fn shift_insert(&mut self, index: usize, key: K, value: V) -> Option<V> {\n        let len = self.len();\n        match self.entry(key) {\n            Entry::Occupied(mut entry) => {\n                assert!(\n                    index < len,\n                    \"index out of bounds: the len is {len} but the index is {index}\"\n                );\n\n                let old = mem::replace(entry.get_mut(), value);\n                entry.move_index(index);\n                Some(old)\n            }\n            Entry::Vacant(entry) => {\n                assert!(\n                    index <= len,\n                    \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"\n                );\n\n                entry.shift_insert(index, value);\n                None\n            }\n        }\n    }\n\n    /// Get the given keys corresponding entry in the map for insertion and/or\n    /// in-place manipulation.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n        let hash = self.hash(&key);\n        self.core.entry(hash, key)\n    }\n\n    /// Creates a splicing iterator that replaces the specified range in the map\n    /// with the given `replace_with` key-value iterator and yields the removed\n    /// items. `replace_with` does not need to be the same length as `range`.\n    ///\n    /// The `range` is removed even if the iterator is not consumed until the\n    /// end. It is unspecified how many elements are removed from the map if the\n    /// `Splice` value is leaked.\n    ///\n    /// The input iterator `replace_with` is only consumed when the `Splice`\n    /// value is dropped. If a key from the iterator matches an existing entry\n    /// in the map (outside of `range`), then the value will be updated in that\n    /// position. Otherwise, the new key-value pair will be inserted in the\n    /// replaced `range`.\n    ///\n    /// ***Panics*** if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use indexmap::IndexMap;\n    ///\n    /// let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);\n    /// let new = [(5, 'E'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'A')];\n    /// let removed: Vec<_> = map.splice(2..4, new).collect();\n    ///\n    /// // 1 and 4 got new values, while 5, 3, and 2 were newly inserted.\n    /// assert!(map.into_iter().eq([(0, '_'), (1, 'A'), (5, 'E'), (3, 'C'), (2, 'B'), (4, 'D')]));\n    /// assert_eq!(removed, &[(2, 'b'), (3, 'c')]);\n    /// ```\n    #[track_caller]\n    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter, K, V, S>\n    where\n        R: RangeBounds<usize>,\n        I: IntoIterator<Item = (K, V)>,\n    {\n        Splice::new(self, range, replace_with.into_iter())\n    }\n\n    /// Moves all key-value pairs from `other` into `self`, leaving `other` empty.\n    ///\n    /// This is equivalent to calling [`insert`][Self::insert] for each\n    /// key-value pair from `other` in order, which means that for keys that\n    /// already exist in `self`, their value is updated in the current position.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use indexmap::IndexMap;\n    ///\n    /// // Note: Key (3) is present in both maps.\n    /// let mut a = IndexMap::from([(3, \"c\"), (2, \"b\"), (1, \"a\")]);\n    /// let mut b = IndexMap::from([(3, \"d\"), (4, \"e\"), (5, \"f\")]);\n    /// let old_capacity = b.capacity();\n    ///\n    /// a.append(&mut b);\n    ///\n    /// assert_eq!(a.len(), 5);\n    /// assert_eq!(b.len(), 0);\n    /// assert_eq!(b.capacity(), old_capacity);\n    ///\n    /// assert!(a.keys().eq(&[3, 2, 1, 4, 5]));\n    /// assert_eq!(a[&3], \"d\"); // \"c\" was overwritten.\n    /// ```\n    pub fn append<S2>(&mut self, other: &mut IndexMap<K, V, S2>) {\n        self.extend(other.drain(..));\n    }\n}",
            "impl<K, V, S> IndexMap<K, V, S>\nwhere\n    S: BuildHasher,\n{\n    pub(crate) fn hash<Q: ?Sized + Hash>(&self, key: &Q) -> HashValue {\n        let mut h = self.hash_builder.build_hasher();\n        key.hash(&mut h);\n        HashValue(h.finish() as usize)\n    }\n\n    /// Return `true` if an equivalent to `key` exists in the map.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        self.get_index_of(key).is_some()\n    }\n\n    /// Return a reference to the value stored for `key`, if it is present,\n    /// else `None`.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn get<Q>(&self, key: &Q) -> Option<&V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &self.as_entries()[i];\n            Some(&entry.value)\n        } else {\n            None\n        }\n    }\n\n    /// Return references to the key-value pair stored for `key`,\n    /// if it is present, else `None`.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn get_key_value<Q>(&self, key: &Q) -> Option<(&K, &V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &self.as_entries()[i];\n            Some((&entry.key, &entry.value))\n        } else {\n            None\n        }\n    }\n\n    /// Return item index, key and value\n    pub fn get_full<Q>(&self, key: &Q) -> Option<(usize, &K, &V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &self.as_entries()[i];\n            Some((i, &entry.key, &entry.value))\n        } else {\n            None\n        }\n    }\n\n    /// Return item index, if it exists in the map\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn get_index_of<Q>(&self, key: &Q) -> Option<usize>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        match self.as_entries() {\n            [] => None,\n            [x] => key.equivalent(&x.key).then_some(0),\n            _ => {\n                let hash = self.hash(key);\n                self.core.get_index_of(hash, key)\n            }\n        }\n    }\n\n    pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &mut self.as_entries_mut()[i];\n            Some(&mut entry.value)\n        } else {\n            None\n        }\n    }\n\n    pub fn get_full_mut<Q>(&mut self, key: &Q) -> Option<(usize, &K, &mut V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &mut self.as_entries_mut()[i];\n            Some((i, &entry.key, &mut entry.value))\n        } else {\n            None\n        }\n    }\n\n    /// Return the values for `N` keys. If any key is duplicated, this function will panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut map = indexmap::IndexMap::from([(1, 'a'), (3, 'b'), (2, 'c')]);\n    /// assert_eq!(map.get_disjoint_mut([&2, &1]), [Some(&mut 'c'), Some(&mut 'a')]);\n    /// ```\n    pub fn get_disjoint_mut<Q, const N: usize>(&mut self, keys: [&Q; N]) -> [Option<&mut V>; N]\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        let indices = keys.map(|key| self.get_index_of(key));\n        match self.as_mut_slice().get_disjoint_opt_mut(indices) {\n            Err(GetDisjointMutError::IndexOutOfBounds) => {\n                unreachable!(\n                    \"Internal error: indices should never be OOB as we got them from get_index_of\"\n                );\n            }\n            Err(GetDisjointMutError::OverlappingIndices) => {\n                panic!(\"duplicate keys found\");\n            }\n            Ok(key_values) => key_values.map(|kv_opt| kv_opt.map(|kv| kv.1)),\n        }\n    }\n\n    /// Remove the key-value pair equivalent to `key` and return\n    /// its value.\n    ///\n    /// **NOTE:** This is equivalent to [`.swap_remove(key)`][Self::swap_remove], replacing this\n    /// entry's position with the last element, and it is deprecated in favor of calling that\n    /// explicitly. If you need to preserve the relative order of the keys in the map, use\n    /// [`.shift_remove(key)`][Self::shift_remove] instead.\n    #[deprecated(note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\")]\n    pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        self.swap_remove(key)\n    }\n\n    /// Remove and return the key-value pair equivalent to `key`.\n    ///\n    /// **NOTE:** This is equivalent to [`.swap_remove_entry(key)`][Self::swap_remove_entry],\n    /// replacing this entry's position with the last element, and it is deprecated in favor of\n    /// calling that explicitly. If you need to preserve the relative order of the keys in the map,\n    /// use [`.shift_remove_entry(key)`][Self::shift_remove_entry] instead.\n    #[deprecated(note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\")]\n    pub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        self.swap_remove_entry(key)\n    }\n\n    /// Remove the key-value pair equivalent to `key` and return\n    /// its value.\n    ///\n    /// Like [`Vec::swap_remove`], the pair is removed by swapping it with the\n    /// last element of the map and popping it off. **This perturbs\n    /// the position of what used to be the last element!**\n    ///\n    /// Return `None` if `key` is not in map.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        self.swap_remove_full(key).map(third)\n    }\n\n    /// Remove and return the key-value pair equivalent to `key`.\n    ///\n    /// Like [`Vec::swap_remove`], the pair is removed by swapping it with the\n    /// last element of the map and popping it off. **This perturbs\n    /// the position of what used to be the last element!**\n    ///\n    /// Return `None` if `key` is not in map.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        match self.swap_remove_full(key) {\n            Some((_, key, value)) => Some((key, value)),\n            None => None,\n        }\n    }\n\n    /// Remove the key-value pair equivalent to `key` and return it and\n    /// the index it had.\n    ///\n    /// Like [`Vec::swap_remove`], the pair is removed by swapping it with the\n    /// last element of the map and popping it off. **This perturbs\n    /// the position of what used to be the last element!**\n    ///\n    /// Return `None` if `key` is not in map.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove_full<Q>(&mut self, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        match self.as_entries() {\n            [x] if key.equivalent(&x.key) => {\n                let (k, v) = self.core.pop()?;\n                Some((0, k, v))\n            }\n            [_] | [] => None,\n            _ => {\n                let hash = self.hash(key);\n                self.core.swap_remove_full(hash, key)\n            }\n        }\n    }\n\n    /// Remove the key-value pair equivalent to `key` and return\n    /// its value.\n    ///\n    /// Like [`Vec::remove`], the pair is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Return `None` if `key` is not in map.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        self.shift_remove_full(key).map(third)\n    }\n\n    /// Remove and return the key-value pair equivalent to `key`.\n    ///\n    /// Like [`Vec::remove`], the pair is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Return `None` if `key` is not in map.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        match self.shift_remove_full(key) {\n            Some((_, key, value)) => Some((key, value)),\n            None => None,\n        }\n    }\n\n    /// Remove the key-value pair equivalent to `key` and return it and\n    /// the index it had.\n    ///\n    /// Like [`Vec::remove`], the pair is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Return `None` if `key` is not in map.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove_full<Q>(&mut self, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        match self.as_entries() {\n            [x] if key.equivalent(&x.key) => {\n                let (k, v) = self.core.pop()?;\n                Some((0, k, v))\n            }\n            [_] | [] => None,\n            _ => {\n                let hash = self.hash(key);\n                self.core.shift_remove_full(hash, key)\n            }\n        }\n    }\n}",
            "impl<K, V, S> IndexMap<K, V, S> {\n    /// Create a new map with capacity for `n` key-value pairs. (Does not\n    /// allocate if `n` is zero.)\n    ///\n    /// Computes in **O(n)** time.\n    #[inline]\n    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {\n        if n == 0 {\n            Self::with_hasher(hash_builder)\n        } else {\n            IndexMap {\n                core: IndexMapCore::with_capacity(n),\n                hash_builder,\n            }\n        }\n    }\n\n    /// Create a new map with `hash_builder`.\n    ///\n    /// This function is `const`, so it\n    /// can be called in `static` contexts.\n    pub const fn with_hasher(hash_builder: S) -> Self {\n        IndexMap {\n            core: IndexMapCore::new(),\n            hash_builder,\n        }\n    }\n\n    /// Return the number of elements the map can hold without reallocating.\n    ///\n    /// This number is a lower bound; the map might be able to hold more,\n    /// but is guaranteed to be able to hold at least this many.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn capacity(&self) -> usize {\n        self.core.capacity()\n    }\n\n    /// Return a reference to the map's `BuildHasher`.\n    pub fn hasher(&self) -> &S {\n        &self.hash_builder\n    }\n\n    /// Return the number of key-value pairs in the map.\n    ///\n    /// Computes in **O(1)** time.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.core.len()\n    }\n\n    /// Returns true if the map contains no elements.\n    ///\n    /// Computes in **O(1)** time.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Return an iterator over the key-value pairs of the map, in their order\n    pub fn iter(&self) -> Iter<'_, K, V> {\n        Iter::new(self.as_entries())\n    }\n\n    /// Return an iterator over the key-value pairs of the map, in their order\n    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n        IterMut::new(self.as_entries_mut())\n    }\n\n    /// Return an iterator over the keys of the map, in their order\n    pub fn keys(&self) -> Keys<'_, K, V> {\n        Keys::new(self.as_entries())\n    }\n\n    /// Return an owning iterator over the keys of the map, in their order\n    pub fn into_keys(self) -> IntoKeys<K, V> {\n        IntoKeys::new(self.into_entries())\n    }\n\n    /// Return an iterator over the values of the map, in their order\n    pub fn values(&self) -> Values<'_, K, V> {\n        Values::new(self.as_entries())\n    }\n\n    /// Return an iterator over mutable references to the values of the map,\n    /// in their order\n    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {\n        ValuesMut::new(self.as_entries_mut())\n    }\n\n    /// Return an owning iterator over the values of the map, in their order\n    pub fn into_values(self) -> IntoValues<K, V> {\n        IntoValues::new(self.into_entries())\n    }\n\n    /// Remove all key-value pairs in the map, while preserving its capacity.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn clear(&mut self) {\n        self.core.clear();\n    }\n\n    /// Shortens the map, keeping the first `len` elements and dropping the rest.\n    ///\n    /// If `len` is greater than the map's current length, this has no effect.\n    pub fn truncate(&mut self, len: usize) {\n        self.core.truncate(len);\n    }\n\n    /// Clears the `IndexMap` in the given index range, returning those\n    /// key-value pairs as a drain iterator.\n    ///\n    /// The range may be any type that implements [`RangeBounds<usize>`],\n    /// including all of the `std::ops::Range*` types, or even a tuple pair of\n    /// `Bound` start and end values. To drain the map entirely, use `RangeFull`\n    /// like `map.drain(..)`.\n    ///\n    /// This shifts down all entries following the drained range to fill the\n    /// gap, and keeps the allocated memory for reuse.\n    ///\n    /// ***Panics*** if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the map.\n    #[track_caller]\n    pub fn drain<R>(&mut self, range: R) -> Drain<'_, K, V>\n    where\n        R: RangeBounds<usize>,\n    {\n        Drain::new(self.core.drain(range))\n    }\n\n    /// Splits the collection into two at the given index.\n    ///\n    /// Returns a newly allocated map containing the elements in the range\n    /// `[at, len)`. After the call, the original map will be left containing\n    /// the elements `[0, at)` with its previous capacity unchanged.\n    ///\n    /// ***Panics*** if `at > len`.\n    #[track_caller]\n    pub fn split_off(&mut self, at: usize) -> Self\n    where\n        S: Clone,\n    {\n        Self {\n            core: self.core.split_off(at),\n            hash_builder: self.hash_builder.clone(),\n        }\n    }\n\n    /// Reserve capacity for `additional` more key-value pairs.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn reserve(&mut self, additional: usize) {\n        self.core.reserve(additional);\n    }\n\n    /// Reserve capacity for `additional` more key-value pairs, without over-allocating.\n    ///\n    /// Unlike `reserve`, this does not deliberately over-allocate the entry capacity to avoid\n    /// frequent re-allocations. However, the underlying data structures may still have internal\n    /// capacity requirements, and the allocator itself may give more space than requested, so this\n    /// cannot be relied upon to be precisely minimal.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.core.reserve_exact(additional);\n    }\n\n    /// Try to reserve capacity for `additional` more key-value pairs.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.core.try_reserve(additional)\n    }\n\n    /// Try to reserve capacity for `additional` more key-value pairs, without over-allocating.\n    ///\n    /// Unlike `try_reserve`, this does not deliberately over-allocate the entry capacity to avoid\n    /// frequent re-allocations. However, the underlying data structures may still have internal\n    /// capacity requirements, and the allocator itself may give more space than requested, so this\n    /// cannot be relied upon to be precisely minimal.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.core.try_reserve_exact(additional)\n    }\n\n    /// Shrink the capacity of the map as much as possible.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn shrink_to_fit(&mut self) {\n        self.core.shrink_to(0);\n    }\n\n    /// Shrink the capacity of the map with a lower limit.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.core.shrink_to(min_capacity);\n    }\n}",
            "impl<K, V, S> IndexMap<K, V, S> {\n    /// Remove the last key-value pair\n    ///\n    /// This preserves the order of the remaining elements.\n    ///\n    /// Computes in **O(1)** time (average).\n    #[doc(alias = \"pop_last\")] // like `BTreeMap`\n    pub fn pop(&mut self) -> Option<(K, V)> {\n        self.core.pop()\n    }\n\n    /// Scan through each key-value pair in the map and keep those where the\n    /// closure `keep` returns `true`.\n    ///\n    /// The elements are visited in order, and remaining elements keep their\n    /// order.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn retain<F>(&mut self, mut keep: F)\n    where\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        self.core.retain_in_order(move |k, v| keep(k, v));\n    }\n\n    /// Sort the maps key-value pairs by the default ordering of the keys.\n    ///\n    /// This is a stable sort -- but equivalent keys should not normally coexist in\n    /// a map at all, so [`sort_unstable_keys`][Self::sort_unstable_keys] is preferred\n    /// because it is generally faster and doesn't allocate auxiliary memory.\n    ///\n    /// See [`sort_by`](Self::sort_by) for details.\n    pub fn sort_keys(&mut self)\n    where\n        K: Ord,\n    {\n        self.with_entries(move |entries| {\n            entries.sort_by(move |a, b| K::cmp(&a.key, &b.key));\n        });\n    }\n\n    /// Sort the maps key-value pairs in place using the comparison\n    /// function `cmp`.\n    ///\n    /// The comparison function receives two key and value pairs to compare (you\n    /// can sort by keys or values or their combination as needed).\n    ///\n    /// Computes in **O(n log n + c)** time and **O(n)** space where *n* is\n    /// the length of the map and *c* the capacity. The sort is stable.\n    pub fn sort_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&K, &V, &K, &V) -> Ordering,\n    {\n        self.with_entries(move |entries| {\n            entries.sort_by(move |a, b| cmp(&a.key, &a.value, &b.key, &b.value));\n        });\n    }\n\n    /// Sort the key-value pairs of the map and return a by-value iterator of\n    /// the key-value pairs with the result.\n    ///\n    /// The sort is stable.\n    pub fn sorted_by<F>(self, mut cmp: F) -> IntoIter<K, V>\n    where\n        F: FnMut(&K, &V, &K, &V) -> Ordering,\n    {\n        let mut entries = self.into_entries();\n        entries.sort_by(move |a, b| cmp(&a.key, &a.value, &b.key, &b.value));\n        IntoIter::new(entries)\n    }\n\n    /// Sort the map's key-value pairs by the default ordering of the keys, but\n    /// may not preserve the order of equal elements.\n    ///\n    /// See [`sort_unstable_by`](Self::sort_unstable_by) for details.\n    pub fn sort_unstable_keys(&mut self)\n    where\n        K: Ord,\n    {\n        self.with_entries(move |entries| {\n            entries.sort_unstable_by(move |a, b| K::cmp(&a.key, &b.key));\n        });\n    }\n\n    /// Sort the map's key-value pairs in place using the comparison function `cmp`, but\n    /// may not preserve the order of equal elements.\n    ///\n    /// The comparison function receives two key and value pairs to compare (you\n    /// can sort by keys or values or their combination as needed).\n    ///\n    /// Computes in **O(n log n + c)** time where *n* is\n    /// the length of the map and *c* is the capacity. The sort is unstable.\n    pub fn sort_unstable_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&K, &V, &K, &V) -> Ordering,\n    {\n        self.with_entries(move |entries| {\n            entries.sort_unstable_by(move |a, b| cmp(&a.key, &a.value, &b.key, &b.value));\n        });\n    }\n\n    /// Sort the key-value pairs of the map and return a by-value iterator of\n    /// the key-value pairs with the result.\n    ///\n    /// The sort is unstable.\n    #[inline]\n    pub fn sorted_unstable_by<F>(self, mut cmp: F) -> IntoIter<K, V>\n    where\n        F: FnMut(&K, &V, &K, &V) -> Ordering,\n    {\n        let mut entries = self.into_entries();\n        entries.sort_unstable_by(move |a, b| cmp(&a.key, &a.value, &b.key, &b.value));\n        IntoIter::new(entries)\n    }\n\n    /// Sort the maps key-value pairs in place using a sort-key extraction function.\n    ///\n    /// During sorting, the function is called at most once per entry, by using temporary storage\n    /// to remember the results of its evaluation. The order of calls to the function is\n    /// unspecified and may change between versions of `indexmap` or the standard library.\n    ///\n    /// Computes in **O(m n + n log n + c)** time () and **O(n)** space, where the function is\n    /// **O(m)**, *n* is the length of the map, and *c* the capacity. The sort is stable.\n    pub fn sort_by_cached_key<T, F>(&mut self, mut sort_key: F)\n    where\n        T: Ord,\n        F: FnMut(&K, &V) -> T,\n    {\n        self.with_entries(move |entries| {\n            entries.sort_by_cached_key(move |a| sort_key(&a.key, &a.value));\n        });\n    }\n\n    /// Search over a sorted map for a key.\n    ///\n    /// Returns the position where that key is present, or the position where it can be inserted to\n    /// maintain the sort. See [`slice::binary_search`] for more details.\n    ///\n    /// Computes in **O(log(n))** time, which is notably less scalable than looking the key up\n    /// using [`get_index_of`][IndexMap::get_index_of], but this can also position missing keys.\n    pub fn binary_search_keys(&self, x: &K) -> Result<usize, usize>\n    where\n        K: Ord,\n    {\n        self.as_slice().binary_search_keys(x)\n    }\n\n    /// Search over a sorted map with a comparator function.\n    ///\n    /// Returns the position where that value is present, or the position where it can be inserted\n    /// to maintain the sort. See [`slice::binary_search_by`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[inline]\n    pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a K, &'a V) -> Ordering,\n    {\n        self.as_slice().binary_search_by(f)\n    }\n\n    /// Search over a sorted map with an extraction function.\n    ///\n    /// Returns the position where that value is present, or the position where it can be inserted\n    /// to maintain the sort. See [`slice::binary_search_by_key`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[inline]\n    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a K, &'a V) -> B,\n        B: Ord,\n    {\n        self.as_slice().binary_search_by_key(b, f)\n    }\n\n    /// Returns the index of the partition point of a sorted map according to the given predicate\n    /// (the index of the first element of the second partition).\n    ///\n    /// See [`slice::partition_point`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[must_use]\n    pub fn partition_point<P>(&self, pred: P) -> usize\n    where\n        P: FnMut(&K, &V) -> bool,\n    {\n        self.as_slice().partition_point(pred)\n    }\n\n    /// Reverses the order of the maps key-value pairs in place.\n    ///\n    /// Computes in **O(n)** time and **O(1)** space.\n    pub fn reverse(&mut self) {\n        self.core.reverse()\n    }\n\n    /// Returns a slice of all the key-value pairs in the map.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn as_slice(&self) -> &Slice<K, V> {\n        Slice::from_slice(self.as_entries())\n    }\n\n    /// Returns a mutable slice of all the key-value pairs in the map.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn as_mut_slice(&mut self) -> &mut Slice<K, V> {\n        Slice::from_mut_slice(self.as_entries_mut())\n    }\n\n    /// Converts into a boxed slice of all the key-value pairs in the map.\n    ///\n    /// Note that this will drop the inner hash table and any excess capacity.\n    pub fn into_boxed_slice(self) -> Box<Slice<K, V>> {\n        Slice::from_boxed(self.into_entries().into_boxed_slice())\n    }\n\n    /// Get a key-value pair by index\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn get_index(&self, index: usize) -> Option<(&K, &V)> {\n        self.as_entries().get(index).map(Bucket::refs)\n    }\n\n    /// Get a key-value pair by index\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn get_index_mut(&mut self, index: usize) -> Option<(&K, &mut V)> {\n        self.as_entries_mut().get_mut(index).map(Bucket::ref_mut)\n    }\n\n    /// Get an entry in the map by index for in-place manipulation.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn get_index_entry(&mut self, index: usize) -> Option<IndexedEntry<'_, K, V>> {\n        if index >= self.len() {\n            return None;\n        }\n        Some(IndexedEntry::new(&mut self.core, index))\n    }\n\n    /// Get an array of `N` key-value pairs by `N` indices\n    ///\n    /// Valid indices are *0 <= index < self.len()* and each index needs to be unique.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut map = indexmap::IndexMap::from([(1, 'a'), (3, 'b'), (2, 'c')]);\n    /// assert_eq!(map.get_disjoint_indices_mut([2, 0]), Ok([(&2, &mut 'c'), (&1, &mut 'a')]));\n    /// ```\n    pub fn get_disjoint_indices_mut<const N: usize>(\n        &mut self,\n        indices: [usize; N],\n    ) -> Result<[(&K, &mut V); N], GetDisjointMutError> {\n        self.as_mut_slice().get_disjoint_mut(indices)\n    }\n\n    /// Returns a slice of key-value pairs in the given range of indices.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Slice<K, V>> {\n        let entries = self.as_entries();\n        let range = try_simplify_range(range, entries.len())?;\n        entries.get(range).map(Slice::from_slice)\n    }\n\n    /// Returns a mutable slice of key-value pairs in the given range of indices.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn get_range_mut<R: RangeBounds<usize>>(&mut self, range: R) -> Option<&mut Slice<K, V>> {\n        let entries = self.as_entries_mut();\n        let range = try_simplify_range(range, entries.len())?;\n        entries.get_mut(range).map(Slice::from_mut_slice)\n    }\n\n    /// Get the first key-value pair\n    ///\n    /// Computes in **O(1)** time.\n    #[doc(alias = \"first_key_value\")] // like `BTreeMap`\n    pub fn first(&self) -> Option<(&K, &V)> {\n        self.as_entries().first().map(Bucket::refs)\n    }\n\n    /// Get the first key-value pair, with mutable access to the value\n    ///\n    /// Computes in **O(1)** time.\n    pub fn first_mut(&mut self) -> Option<(&K, &mut V)> {\n        self.as_entries_mut().first_mut().map(Bucket::ref_mut)\n    }\n\n    /// Get the first entry in the map for in-place manipulation.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn first_entry(&mut self) -> Option<IndexedEntry<'_, K, V>> {\n        self.get_index_entry(0)\n    }\n\n    /// Get the last key-value pair\n    ///\n    /// Computes in **O(1)** time.\n    #[doc(alias = \"last_key_value\")] // like `BTreeMap`\n    pub fn last(&self) -> Option<(&K, &V)> {\n        self.as_entries().last().map(Bucket::refs)\n    }\n\n    /// Get the last key-value pair, with mutable access to the value\n    ///\n    /// Computes in **O(1)** time.\n    pub fn last_mut(&mut self) -> Option<(&K, &mut V)> {\n        self.as_entries_mut().last_mut().map(Bucket::ref_mut)\n    }\n\n    /// Get the last entry in the map for in-place manipulation.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn last_entry(&mut self) -> Option<IndexedEntry<'_, K, V>> {\n        self.get_index_entry(self.len().checked_sub(1)?)\n    }\n\n    /// Remove the key-value pair by index\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Like [`Vec::swap_remove`], the pair is removed by swapping it with the\n    /// last element of the map and popping it off. **This perturbs\n    /// the position of what used to be the last element!**\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove_index(&mut self, index: usize) -> Option<(K, V)> {\n        self.core.swap_remove_index(index)\n    }\n\n    /// Remove the key-value pair by index\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Like [`Vec::remove`], the pair is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)> {\n        self.core.shift_remove_index(index)\n    }\n\n    /// Moves the position of a key-value pair from one index to another\n    /// by shifting all other pairs in-between.\n    ///\n    /// * If `from < to`, the other pairs will shift down while the targeted pair moves up.\n    /// * If `from > to`, the other pairs will shift up while the targeted pair moves down.\n    ///\n    /// ***Panics*** if `from` or `to` are out of bounds.\n    ///\n    /// Computes in **O(n)** time (average).\n    #[track_caller]\n    pub fn move_index(&mut self, from: usize, to: usize) {\n        self.core.move_index(from, to)\n    }\n\n    /// Swaps the position of two key-value pairs in the map.\n    ///\n    /// ***Panics*** if `a` or `b` are out of bounds.\n    ///\n    /// Computes in **O(1)** time (average).\n    #[track_caller]\n    pub fn swap_indices(&mut self, a: usize, b: usize) {\n        self.core.swap_indices(a, b)\n    }\n}",
            "impl<K, V, S> IndexMut<$range> for IndexMap<K, V, S> {\n            fn index_mut(&mut self, range: $range) -> &mut Self::Output {\n                Slice::from_mut_slice(&mut self.as_entries_mut()[range])\n            }\n        }",
            "impl<K, V, S> IndexMut<usize> for IndexMap<K, V, S> {\n    /// Returns a mutable reference to the value at the supplied `index`.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    fn index_mut(&mut self, index: usize) -> &mut V {\n        let len: usize = self.len();\n\n        self.get_index_mut(index)\n            .unwrap_or_else(|| {\n                panic!(\"index out of bounds: the len is {len} but the index is {index}\");\n            })\n            .1\n    }\n}",
            "impl<K, V, S> IntoIterator for IndexMap<K, V, S> {\n    type Item = (K, V);\n    type IntoIter = IntoIter<K, V>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter::new(self.into_entries())\n    }\n}",
            "impl<K, V, S> MutableKeys for IndexMap<K, V, S>\nwhere\n    S: BuildHasher,\n{\n    type Key = K;\n    type Value = V;\n\n    fn get_full_mut2<Q>(&mut self, key: &Q) -> Option<(usize, &mut K, &mut V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &mut self.as_entries_mut()[i];\n            Some((i, &mut entry.key, &mut entry.value))\n        } else {\n            None\n        }\n    }\n\n    fn get_index_mut2(&mut self, index: usize) -> Option<(&mut K, &mut V)> {\n        self.as_entries_mut().get_mut(index).map(Bucket::muts)\n    }\n\n    fn iter_mut2(&mut self) -> IterMut2<'_, Self::Key, Self::Value> {\n        IterMut2::new(self.as_entries_mut())\n    }\n\n    fn retain2<F>(&mut self, keep: F)\n    where\n        F: FnMut(&mut K, &mut V) -> bool,\n    {\n        self.core.retain_in_order(keep);\n    }\n}",
            "impl<K, V, S> RawEntryApiV1<K, V, S> for IndexMap<K, V, S> {\n    fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S> {\n        RawEntryBuilder { map: self }\n    }\n\n    fn raw_entry_mut_v1(&mut self) -> RawEntryBuilderMut<'_, K, V, S> {\n        RawEntryBuilderMut { map: self }\n    }\n}",
            "impl<K, V, S> Sealed for super::IndexMap<K, V, S> {}",
            "impl<K, V, S> fmt::Debug for IndexMap<K, V, S>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    #[cfg(not(feature = \"test_debug\"))]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_map().entries(self.iter()).finish()\n    }\n\n    #[cfg(feature = \"test_debug\")]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Let the inner `IndexMapCore` print all of its details\n        f.debug_struct(\"IndexMap\")\n            .field(\"core\", &self.core)\n            .finish()\n    }\n}",
            "impl<K, V, const N: usize> From<[(K, V); N]> for IndexMap<K, V, RandomState>\nwhere\n    K: Hash + Eq,\n{\n    /// # Examples\n    ///\n    /// ```\n    /// use indexmap::IndexMap;\n    ///\n    /// let map1 = IndexMap::from([(1, 2), (3, 4)]);\n    /// let map2: IndexMap<_, _> = [(1, 2), (3, 4)].into();\n    /// assert_eq!(map1, map2);\n    /// ```\n    fn from(arr: [(K, V); N]) -> Self {\n        Self::from_iter(arr)\n    }\n}",
            "impl<K, V1, S1, V2, S2> PartialEq<IndexMap<K, V2, S2>> for IndexMap<K, V1, S1>\nwhere\n    K: Hash + Eq,\n    V1: PartialEq<V2>,\n    S1: BuildHasher,\n    S2: BuildHasher,\n{\n    fn eq(&self, other: &IndexMap<K, V2, S2>) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter()\n            .all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\n    }\n}",
            "impl<K, V> IndexMap<K, V> {\n    /// Create a new map. (Does not allocate.)\n    #[inline]\n    pub fn new() -> Self {\n        Self::with_capacity(0)\n    }\n\n    /// Create a new map with capacity for `n` key-value pairs. (Does not\n    /// allocate if `n` is zero.)\n    ///\n    /// Computes in **O(n)** time.\n    #[inline]\n    pub fn with_capacity(n: usize) -> Self {\n        Self::with_capacity_and_hasher(n, <_>::default())\n    }\n}"
        ],
        "map::core::IndexMapCore": [
            "Debug",
            "impl<K, V> Clone for IndexMapCore<K, V>\nwhere\n    K: Clone,\n    V: Clone,\n{\n    fn clone(&self) -> Self {\n        let mut new = Self::new();\n        new.clone_from(self);\n        new\n    }\n\n    fn clone_from(&mut self, other: &Self) {\n        self.indices.clone_from(&other.indices);\n        if self.entries.capacity() < other.entries.len() {\n            // If we must resize, match the indices capacity.\n            let additional = other.entries.len() - self.entries.len();\n            self.borrow_mut().reserve_entries(additional);\n        }\n        self.entries.clone_from(&other.entries);\n    }\n}",
            "impl<K, V> IndexMapCore<K, V> {\n    /// The maximum capacity before the `entries` allocation would exceed `isize::MAX`.\n    const MAX_ENTRIES_CAPACITY: usize = (isize::MAX as usize) / mem::size_of::<Bucket<K, V>>();\n\n    #[inline]\n    pub(crate) const fn new() -> Self {\n        IndexMapCore {\n            indices: Indices::new(),\n            entries: Vec::new(),\n        }\n    }\n\n    #[inline]\n    fn borrow_mut(&mut self) -> RefMut<'_, K, V> {\n        RefMut::new(&mut self.indices, &mut self.entries)\n    }\n\n    #[inline]\n    pub(crate) fn with_capacity(n: usize) -> Self {\n        IndexMapCore {\n            indices: Indices::with_capacity(n),\n            entries: Vec::with_capacity(n),\n        }\n    }\n\n    #[inline]\n    pub(crate) fn len(&self) -> usize {\n        self.indices.len()\n    }\n\n    #[inline]\n    pub(crate) fn capacity(&self) -> usize {\n        Ord::min(self.indices.capacity(), self.entries.capacity())\n    }\n\n    pub(crate) fn clear(&mut self) {\n        self.indices.clear();\n        self.entries.clear();\n    }\n\n    pub(crate) fn truncate(&mut self, len: usize) {\n        if len < self.len() {\n            self.erase_indices(len, self.entries.len());\n            self.entries.truncate(len);\n        }\n    }\n\n    #[track_caller]\n    pub(crate) fn drain<R>(&mut self, range: R) -> vec::Drain<'_, Bucket<K, V>>\n    where\n        R: RangeBounds<usize>,\n    {\n        let range = simplify_range(range, self.entries.len());\n        self.erase_indices(range.start, range.end);\n        self.entries.drain(range)\n    }\n\n    #[cfg(feature = \"rayon\")]\n    pub(crate) fn par_drain<R>(&mut self, range: R) -> rayon::vec::Drain<'_, Bucket<K, V>>\n    where\n        K: Send,\n        V: Send,\n        R: RangeBounds<usize>,\n    {\n        use rayon::iter::ParallelDrainRange;\n        let range = simplify_range(range, self.entries.len());\n        self.erase_indices(range.start, range.end);\n        self.entries.par_drain(range)\n    }\n\n    #[track_caller]\n    pub(crate) fn split_off(&mut self, at: usize) -> Self {\n        let len = self.entries.len();\n        assert!(\n            at <= len,\n            \"index out of bounds: the len is {len} but the index is {at}. Expected index <= len\"\n        );\n\n        self.erase_indices(at, self.entries.len());\n        let entries = self.entries.split_off(at);\n\n        let mut indices = Indices::with_capacity(entries.len());\n        insert_bulk_no_grow(&mut indices, &entries);\n        Self { indices, entries }\n    }\n\n    #[track_caller]\n    pub(crate) fn split_splice<R>(&mut self, range: R) -> (Self, vec::IntoIter<Bucket<K, V>>)\n    where\n        R: RangeBounds<usize>,\n    {\n        let range = simplify_range(range, self.len());\n        self.erase_indices(range.start, self.entries.len());\n        let entries = self.entries.split_off(range.end);\n        let drained = self.entries.split_off(range.start);\n\n        let mut indices = Indices::with_capacity(entries.len());\n        insert_bulk_no_grow(&mut indices, &entries);\n        (Self { indices, entries }, drained.into_iter())\n    }\n\n    /// Append from another map without checking whether items already exist.\n    pub(crate) fn append_unchecked(&mut self, other: &mut Self) {\n        self.reserve(other.len());\n        insert_bulk_no_grow(&mut self.indices, &other.entries);\n        self.entries.append(&mut other.entries);\n        other.indices.clear();\n    }\n\n    /// Reserve capacity for `additional` more key-value pairs.\n    pub(crate) fn reserve(&mut self, additional: usize) {\n        self.indices.reserve(additional, get_hash(&self.entries));\n        // Only grow entries if necessary, since we also round up capacity.\n        if additional > self.entries.capacity() - self.entries.len() {\n            self.borrow_mut().reserve_entries(additional);\n        }\n    }\n\n    /// Reserve capacity for `additional` more key-value pairs, without over-allocating.\n    pub(crate) fn reserve_exact(&mut self, additional: usize) {\n        self.indices.reserve(additional, get_hash(&self.entries));\n        self.entries.reserve_exact(additional);\n    }\n\n    /// Try to reserve capacity for `additional` more key-value pairs.\n    pub(crate) fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.indices\n            .try_reserve(additional, get_hash(&self.entries))\n            .map_err(TryReserveError::from_hashbrown)?;\n        // Only grow entries if necessary, since we also round up capacity.\n        if additional > self.entries.capacity() - self.entries.len() {\n            self.try_reserve_entries(additional)\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Try to reserve entries capacity, rounded up to match the indices\n    fn try_reserve_entries(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        // Use a soft-limit on the maximum capacity, but if the caller explicitly\n        // requested more, do it and let them have the resulting error.\n        let new_capacity = Ord::min(self.indices.capacity(), Self::MAX_ENTRIES_CAPACITY);\n        let try_add = new_capacity - self.entries.len();\n        if try_add > additional && self.entries.try_reserve_exact(try_add).is_ok() {\n            return Ok(());\n        }\n        self.entries\n            .try_reserve_exact(additional)\n            .map_err(TryReserveError::from_alloc)\n    }\n\n    /// Try to reserve capacity for `additional` more key-value pairs, without over-allocating.\n    pub(crate) fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.indices\n            .try_reserve(additional, get_hash(&self.entries))\n            .map_err(TryReserveError::from_hashbrown)?;\n        self.entries\n            .try_reserve_exact(additional)\n            .map_err(TryReserveError::from_alloc)\n    }\n\n    /// Shrink the capacity of the map with a lower bound\n    pub(crate) fn shrink_to(&mut self, min_capacity: usize) {\n        self.indices\n            .shrink_to(min_capacity, get_hash(&self.entries));\n        self.entries.shrink_to(min_capacity);\n    }\n\n    /// Remove the last key-value pair\n    pub(crate) fn pop(&mut self) -> Option<(K, V)> {\n        if let Some(entry) = self.entries.pop() {\n            let last = self.entries.len();\n            erase_index(&mut self.indices, entry.hash, last);\n            Some((entry.key, entry.value))\n        } else {\n            None\n        }\n    }\n\n    /// Return the index in `entries` where an equivalent key can be found\n    pub(crate) fn get_index_of<Q>(&self, hash: HashValue, key: &Q) -> Option<usize>\n    where\n        Q: ?Sized + Equivalent<K>,\n    {\n        let eq = equivalent(key, &self.entries);\n        self.indices.find(hash.get(), eq).copied()\n    }\n\n    /// Append a key-value pair to `entries`,\n    /// *without* checking whether it already exists.\n    fn push_entry(&mut self, hash: HashValue, key: K, value: V) {\n        if self.entries.len() == self.entries.capacity() {\n            // Reserve our own capacity synced to the indices,\n            // rather than letting `Vec::push` just double it.\n            self.borrow_mut().reserve_entries(1);\n        }\n        self.entries.push(Bucket { hash, key, value });\n    }\n\n    pub(crate) fn insert_full(&mut self, hash: HashValue, key: K, value: V) -> (usize, Option<V>)\n    where\n        K: Eq,\n    {\n        let eq = equivalent(&key, &self.entries);\n        let hasher = get_hash(&self.entries);\n        match self.indices.entry(hash.get(), eq, hasher) {\n            hash_table::Entry::Occupied(entry) => {\n                let i = *entry.get();\n                (i, Some(mem::replace(&mut self.entries[i].value, value)))\n            }\n            hash_table::Entry::Vacant(entry) => {\n                let i = self.entries.len();\n                entry.insert(i);\n                self.push_entry(hash, key, value);\n                debug_assert_eq!(self.indices.len(), self.entries.len());\n                (i, None)\n            }\n        }\n    }\n\n    /// Same as `insert_full`, except it also replaces the key\n    pub(crate) fn replace_full(\n        &mut self,\n        hash: HashValue,\n        key: K,\n        value: V,\n    ) -> (usize, Option<(K, V)>)\n    where\n        K: Eq,\n    {\n        let eq = equivalent(&key, &self.entries);\n        let hasher = get_hash(&self.entries);\n        match self.indices.entry(hash.get(), eq, hasher) {\n            hash_table::Entry::Occupied(entry) => {\n                let i = *entry.get();\n                let entry = &mut self.entries[i];\n                let kv = (\n                    mem::replace(&mut entry.key, key),\n                    mem::replace(&mut entry.value, value),\n                );\n                (i, Some(kv))\n            }\n            hash_table::Entry::Vacant(entry) => {\n                let i = self.entries.len();\n                entry.insert(i);\n                self.push_entry(hash, key, value);\n                debug_assert_eq!(self.indices.len(), self.entries.len());\n                (i, None)\n            }\n        }\n    }\n\n    /// Remove an entry by shifting all entries that follow it\n    pub(crate) fn shift_remove_full<Q>(&mut self, hash: HashValue, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Equivalent<K>,\n    {\n        let eq = equivalent(key, &self.entries);\n        match self.indices.find_entry(hash.get(), eq) {\n            Ok(entry) => {\n                let (index, _) = entry.remove();\n                let (key, value) = self.borrow_mut().shift_remove_finish(index);\n                Some((index, key, value))\n            }\n            Err(_) => None,\n        }\n    }\n\n    /// Remove an entry by shifting all entries that follow it\n    #[inline]\n    pub(crate) fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)> {\n        self.borrow_mut().shift_remove_index(index)\n    }\n\n    #[inline]\n    #[track_caller]\n    pub(super) fn move_index(&mut self, from: usize, to: usize) {\n        self.borrow_mut().move_index(from, to);\n    }\n\n    #[inline]\n    #[track_caller]\n    pub(crate) fn swap_indices(&mut self, a: usize, b: usize) {\n        self.borrow_mut().swap_indices(a, b);\n    }\n\n    /// Remove an entry by swapping it with the last\n    pub(crate) fn swap_remove_full<Q>(&mut self, hash: HashValue, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Equivalent<K>,\n    {\n        let eq = equivalent(key, &self.entries);\n        match self.indices.find_entry(hash.get(), eq) {\n            Ok(entry) => {\n                let (index, _) = entry.remove();\n                let (key, value) = self.borrow_mut().swap_remove_finish(index);\n                Some((index, key, value))\n            }\n            Err(_) => None,\n        }\n    }\n\n    /// Remove an entry by swapping it with the last\n    #[inline]\n    pub(crate) fn swap_remove_index(&mut self, index: usize) -> Option<(K, V)> {\n        self.borrow_mut().swap_remove_index(index)\n    }\n\n    /// Erase `start..end` from `indices`, and shift `end..` indices down to `start..`\n    ///\n    /// All of these items should still be at their original location in `entries`.\n    /// This is used by `drain`, which will let `Vec::drain` do the work on `entries`.\n    fn erase_indices(&mut self, start: usize, end: usize) {\n        let (init, shifted_entries) = self.entries.split_at(end);\n        let (start_entries, erased_entries) = init.split_at(start);\n\n        let erased = erased_entries.len();\n        let shifted = shifted_entries.len();\n        let half_capacity = self.indices.capacity() / 2;\n\n        // Use a heuristic between different strategies\n        if erased == 0 {\n            // Degenerate case, nothing to do\n        } else if start + shifted < half_capacity && start < erased {\n            // Reinsert everything, as there are few kept indices\n            self.indices.clear();\n\n            // Reinsert stable indices, then shifted indices\n            insert_bulk_no_grow(&mut self.indices, start_entries);\n            insert_bulk_no_grow(&mut self.indices, shifted_entries);\n        } else if erased + shifted < half_capacity {\n            // Find each affected index, as there are few to adjust\n\n            // Find erased indices\n            for (i, entry) in (start..).zip(erased_entries) {\n                erase_index(&mut self.indices, entry.hash, i);\n            }\n\n            // Find shifted indices\n            for ((new, old), entry) in (start..).zip(end..).zip(shifted_entries) {\n                update_index(&mut self.indices, entry.hash, old, new);\n            }\n        } else {\n            // Sweep the whole table for adjustments\n            let offset = end - start;\n            self.indices.retain(move |i| {\n                if *i >= end {\n                    *i -= offset;\n                    true\n                } else {\n                    *i < start\n                }\n            });\n        }\n\n        debug_assert_eq!(self.indices.len(), start + shifted);\n    }\n\n    pub(crate) fn retain_in_order<F>(&mut self, mut keep: F)\n    where\n        F: FnMut(&mut K, &mut V) -> bool,\n    {\n        self.entries\n            .retain_mut(|entry| keep(&mut entry.key, &mut entry.value));\n        if self.entries.len() < self.indices.len() {\n            self.rebuild_hash_table();\n        }\n    }\n\n    fn rebuild_hash_table(&mut self) {\n        self.indices.clear();\n        insert_bulk_no_grow(&mut self.indices, &self.entries);\n    }\n\n    pub(crate) fn reverse(&mut self) {\n        self.entries.reverse();\n\n        // No need to save hash indices, can easily calculate what they should\n        // be, given that this is an in-place reversal.\n        let len = self.entries.len();\n        for i in &mut self.indices {\n            *i = len - *i - 1;\n        }\n    }\n}",
            "impl<K, V> IndexMapCore<K, V> {\n    pub(crate) fn entry(&mut self, hash: HashValue, key: K) -> Entry<'_, K, V>\n    where\n        K: Eq,\n    {\n        let entries = &mut self.entries;\n        let eq = equivalent(&key, entries);\n        match self.indices.find_entry(hash.get(), eq) {\n            Ok(index) => Entry::Occupied(OccupiedEntry { entries, index }),\n            Err(absent) => Entry::Vacant(VacantEntry {\n                map: RefMut::new(absent.into_table(), entries),\n                hash,\n                key,\n            }),\n        }\n    }\n}",
            "impl<K, V> crate::Entries for IndexMapCore<K, V> {\n    type Entry = Bucket<K, V>;\n\n    #[inline]\n    fn into_entries(self) -> Vec<Self::Entry> {\n        self.entries\n    }\n\n    #[inline]\n    fn as_entries(&self) -> &[Self::Entry] {\n        &self.entries\n    }\n\n    #[inline]\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry] {\n        &mut self.entries\n    }\n\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]),\n    {\n        f(&mut self.entries);\n        self.rebuild_hash_table();\n    }\n}"
        ],
        "map::core::RefMut": [
            "impl<'a, K, V> RefMut<'a, K, V> {\n    #[inline]\n    fn new(indices: &'a mut Indices, entries: &'a mut Entries<K, V>) -> Self {\n        Self { indices, entries }\n    }\n\n    /// Reserve entries capacity, rounded up to match the indices\n    #[inline]\n    fn reserve_entries(&mut self, additional: usize) {\n        reserve_entries(self.entries, additional, self.indices.capacity());\n    }\n\n    /// Insert a key-value pair in `entries`,\n    /// *without* checking whether it already exists.\n    fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n        let i = self.indices.len();\n        debug_assert_eq!(i, self.entries.len());\n        let entry = self\n            .indices\n            .insert_unique(hash.get(), i, get_hash(self.entries));\n        if self.entries.len() == self.entries.capacity() {\n            // We can't call `indices.capacity()` while this `entry` has borrowed it, so we'll have\n            // to amortize growth on our own. It's still an improvement over the basic `Vec::push`\n            // doubling though, since we also consider `MAX_ENTRIES_CAPACITY`.\n            reserve_entries(self.entries, 1, 2 * self.entries.capacity());\n        }\n        self.entries.push(Bucket { hash, key, value });\n        OccupiedEntry::new(self.entries, entry)\n    }\n\n    /// Insert a key-value pair in `entries` at a particular index,\n    /// *without* checking whether it already exists.\n    fn shift_insert_unique(&mut self, index: usize, hash: HashValue, key: K, value: V) {\n        let end = self.indices.len();\n        assert!(index <= end);\n        // Increment others first so we don't have duplicate indices.\n        self.increment_indices(index, end);\n        let entries = &*self.entries;\n        self.indices.insert_unique(hash.get(), index, move |&i| {\n            // Adjust for the incremented indices to find hashes.\n            debug_assert_ne!(i, index);\n            let i = if i < index { i } else { i - 1 };\n            entries[i].hash.get()\n        });\n        if self.entries.len() == self.entries.capacity() {\n            // Reserve our own capacity synced to the indices,\n            // rather than letting `Vec::insert` just double it.\n            self.reserve_entries(1);\n        }\n        self.entries.insert(index, Bucket { hash, key, value });\n    }\n\n    /// Remove an entry by shifting all entries that follow it\n    fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)> {\n        match self.entries.get(index) {\n            Some(entry) => {\n                erase_index(self.indices, entry.hash, index);\n                Some(self.shift_remove_finish(index))\n            }\n            None => None,\n        }\n    }\n\n    /// Remove an entry by shifting all entries that follow it\n    ///\n    /// The index should already be removed from `self.indices`.\n    fn shift_remove_finish(&mut self, index: usize) -> (K, V) {\n        // Correct indices that point to the entries that followed the removed entry.\n        self.decrement_indices(index + 1, self.entries.len());\n\n        // Use Vec::remove to actually remove the entry.\n        let entry = self.entries.remove(index);\n        (entry.key, entry.value)\n    }\n\n    /// Remove an entry by swapping it with the last\n    fn swap_remove_index(&mut self, index: usize) -> Option<(K, V)> {\n        match self.entries.get(index) {\n            Some(entry) => {\n                erase_index(self.indices, entry.hash, index);\n                Some(self.swap_remove_finish(index))\n            }\n            None => None,\n        }\n    }\n\n    /// Finish removing an entry by swapping it with the last\n    ///\n    /// The index should already be removed from `self.indices`.\n    fn swap_remove_finish(&mut self, index: usize) -> (K, V) {\n        // use swap_remove, but then we need to update the index that points\n        // to the other entry that has to move\n        let entry = self.entries.swap_remove(index);\n\n        // correct index that points to the entry that had to swap places\n        if let Some(entry) = self.entries.get(index) {\n            // was not last element\n            // examine new element in `index` and find it in indices\n            let last = self.entries.len();\n            update_index(self.indices, entry.hash, last, index);\n        }\n\n        (entry.key, entry.value)\n    }\n\n    /// Decrement all indices in the range `start..end`.\n    ///\n    /// The index `start - 1` should not exist in `self.indices`.\n    /// All entries should still be in their original positions.\n    fn decrement_indices(&mut self, start: usize, end: usize) {\n        // Use a heuristic between a full sweep vs. a `find()` for every shifted item.\n        let shifted_entries = &self.entries[start..end];\n        if shifted_entries.len() > self.indices.capacity() / 2 {\n            // Shift all indices in range.\n            for i in &mut *self.indices {\n                if start <= *i && *i < end {\n                    *i -= 1;\n                }\n            }\n        } else {\n            // Find each entry in range to shift its index.\n            for (i, entry) in (start..end).zip(shifted_entries) {\n                update_index(self.indices, entry.hash, i, i - 1);\n            }\n        }\n    }\n\n    /// Increment all indices in the range `start..end`.\n    ///\n    /// The index `end` should not exist in `self.indices`.\n    /// All entries should still be in their original positions.\n    fn increment_indices(&mut self, start: usize, end: usize) {\n        // Use a heuristic between a full sweep vs. a `find()` for every shifted item.\n        let shifted_entries = &self.entries[start..end];\n        if shifted_entries.len() > self.indices.capacity() / 2 {\n            // Shift all indices in range.\n            for i in &mut *self.indices {\n                if start <= *i && *i < end {\n                    *i += 1;\n                }\n            }\n        } else {\n            // Find each entry in range to shift its index, updated in reverse so\n            // we never have duplicated indices that might have a hash collision.\n            for (i, entry) in (start..end).zip(shifted_entries).rev() {\n                update_index(self.indices, entry.hash, i, i + 1);\n            }\n        }\n    }\n\n    #[track_caller]\n    fn move_index(&mut self, from: usize, to: usize) {\n        let from_hash = self.entries[from].hash;\n        let _ = self.entries[to]; // explicit bounds check\n        if from != to {\n            // Use a sentinel index so other indices don't collide.\n            update_index(self.indices, from_hash, from, usize::MAX);\n\n            // Update all other indices and rotate the entry positions.\n            if from < to {\n                self.decrement_indices(from + 1, to + 1);\n                self.entries[from..=to].rotate_left(1);\n            } else if to < from {\n                self.increment_indices(to, from);\n                self.entries[to..=from].rotate_right(1);\n            }\n\n            // Change the sentinel index to its final position.\n            update_index(self.indices, from_hash, usize::MAX, to);\n        }\n    }\n\n    #[track_caller]\n    fn swap_indices(&mut self, a: usize, b: usize) {\n        // If they're equal and in-bounds, there's nothing to do.\n        if a == b && a < self.entries.len() {\n            return;\n        }\n\n        // We'll get a \"nice\" bounds-check from indexing `entries`,\n        // and then we expect to find it in the table as well.\n        match self.indices.get_many_mut(\n            [self.entries[a].hash.get(), self.entries[b].hash.get()],\n            move |i, &x| if i == 0 { x == a } else { x == b },\n        ) {\n            [Some(ref_a), Some(ref_b)] => {\n                mem::swap(ref_a, ref_b);\n                self.entries.swap(a, b);\n            }\n            _ => panic!(\"indices not found\"),\n        }\n    }\n}"
        ],
        "map::core::entry::Entry": [
            "impl<'a, K, V> Entry<'a, K, V> {\n    /// Return the index where the key-value pair exists or will be inserted.\n    pub fn index(&self) -> usize {\n        match *self {\n            Entry::Occupied(ref entry) => entry.index(),\n            Entry::Vacant(ref entry) => entry.index(),\n        }\n    }\n\n    /// Sets the value of the entry (after inserting if vacant), and returns an `OccupiedEntry`.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {\n        match self {\n            Entry::Occupied(mut entry) => {\n                entry.insert(value);\n                entry\n            }\n            Entry::Vacant(entry) => entry.insert_entry(value),\n        }\n    }\n\n    /// Inserts the given default value in the entry if it is vacant and returns a mutable\n    /// reference to it. Otherwise a mutable reference to an already existent value is returned.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    pub fn or_insert(self, default: V) -> &'a mut V {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default),\n        }\n    }\n\n    /// Inserts the result of the `call` function in the entry if it is vacant and returns a mutable\n    /// reference to it. Otherwise a mutable reference to an already existent value is returned.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    pub fn or_insert_with<F>(self, call: F) -> &'a mut V\n    where\n        F: FnOnce() -> V,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(call()),\n        }\n    }\n\n    /// Inserts the result of the `call` function with a reference to the entry's key if it is\n    /// vacant, and returns a mutable reference to the new value. Otherwise a mutable reference to\n    /// an already existent value is returned.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    pub fn or_insert_with_key<F>(self, call: F) -> &'a mut V\n    where\n        F: FnOnce(&K) -> V,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => {\n                let value = call(&entry.key);\n                entry.insert(value)\n            }\n        }\n    }\n\n    /// Gets a reference to the entry's key, either within the map if occupied,\n    /// or else the new key that was used to find the entry.\n    pub fn key(&self) -> &K {\n        match *self {\n            Entry::Occupied(ref entry) => entry.key(),\n            Entry::Vacant(ref entry) => entry.key(),\n        }\n    }\n\n    /// Modifies the entry if it is occupied.\n    pub fn and_modify<F>(mut self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n        if let Entry::Occupied(entry) = &mut self {\n            f(entry.get_mut());\n        }\n        self\n    }\n\n    /// Inserts a default-constructed value in the entry if it is vacant and returns a mutable\n    /// reference to it. Otherwise a mutable reference to an already existent value is returned.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    pub fn or_default(self) -> &'a mut V\n    where\n        V: Default,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(V::default()),\n        }\n    }\n}",
            "impl<K, V> MutableEntryKey for Entry<'_, K, V> {\n    type Key = K;\n    fn key_mut(&mut self) -> &mut Self::Key {\n        match self {\n            Entry::Occupied(e) => e.key_mut(),\n            Entry::Vacant(e) => e.key_mut(),\n        }\n    }\n}",
            "impl<K, V> Sealed for super::Entry<'_, K, V> {}",
            "impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Entry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut tuple = f.debug_tuple(\"Entry\");\n        match self {\n            Entry::Vacant(v) => tuple.field(v),\n            Entry::Occupied(o) => tuple.field(o),\n        };\n        tuple.finish()\n    }\n}"
        ],
        "map::core::entry::IndexedEntry": [
            "impl<'a, K, V> From<OccupiedEntry<'a, K, V>> for IndexedEntry<'a, K, V> {\n    fn from(other: OccupiedEntry<'a, K, V>) -> Self {\n        Self {\n            index: other.index(),\n            map: other.into_ref_mut(),\n        }\n    }\n}",
            "impl<'a, K, V> IndexedEntry<'a, K, V> {\n    pub(crate) fn new(map: &'a mut IndexMapCore<K, V>, index: usize) -> Self {\n        Self {\n            map: map.borrow_mut(),\n            index,\n        }\n    }\n\n    /// Return the index of the key-value pair\n    #[inline]\n    pub fn index(&self) -> usize {\n        self.index\n    }\n\n    /// Gets a reference to the entry's key in the map.\n    pub fn key(&self) -> &K {\n        &self.map.entries[self.index].key\n    }\n\n    pub(crate) fn key_mut(&mut self) -> &mut K {\n        &mut self.map.entries[self.index].key\n    }\n\n    /// Gets a reference to the entry's value in the map.\n    pub fn get(&self) -> &V {\n        &self.map.entries[self.index].value\n    }\n\n    /// Gets a mutable reference to the entry's value in the map.\n    ///\n    /// If you need a reference which may outlive the destruction of the\n    /// `IndexedEntry` value, see [`into_mut`][Self::into_mut].\n    pub fn get_mut(&mut self) -> &mut V {\n        &mut self.map.entries[self.index].value\n    }\n\n    /// Sets the value of the entry to `value`, and returns the entry's old value.\n    pub fn insert(&mut self, value: V) -> V {\n        mem::replace(self.get_mut(), value)\n    }\n\n    /// Converts into a mutable reference to the entry's value in the map,\n    /// with a lifetime bound to the map itself.\n    pub fn into_mut(self) -> &'a mut V {\n        &mut self.map.entries[self.index].value\n    }\n\n    /// Remove and return the key, value pair stored in the map for this entry\n    ///\n    /// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n    /// the last element of the map and popping it off.\n    /// **This perturbs the position of what used to be the last element!**\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove_entry(mut self) -> (K, V) {\n        self.map.swap_remove_index(self.index).unwrap()\n    }\n\n    /// Remove and return the key, value pair stored in the map for this entry\n    ///\n    /// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove_entry(mut self) -> (K, V) {\n        self.map.shift_remove_index(self.index).unwrap()\n    }\n\n    /// Remove the key, value pair stored in the map for this entry, and return the value.\n    ///\n    /// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n    /// the last element of the map and popping it off.\n    /// **This perturbs the position of what used to be the last element!**\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove(self) -> V {\n        self.swap_remove_entry().1\n    }\n\n    /// Remove the key, value pair stored in the map for this entry, and return the value.\n    ///\n    /// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove(self) -> V {\n        self.shift_remove_entry().1\n    }\n\n    /// Moves the position of the entry to a new index\n    /// by shifting all other entries in-between.\n    ///\n    /// This is equivalent to [`IndexMap::move_index`][`crate::IndexMap::move_index`]\n    /// coming `from` the current [`.index()`][Self::index].\n    ///\n    /// * If `self.index() < to`, the other pairs will shift down while the targeted pair moves up.\n    /// * If `self.index() > to`, the other pairs will shift up while the targeted pair moves down.\n    ///\n    /// ***Panics*** if `to` is out of bounds.\n    ///\n    /// Computes in **O(n)** time (average).\n    #[track_caller]\n    pub fn move_index(mut self, to: usize) {\n        self.map.move_index(self.index, to);\n    }\n\n    /// Swaps the position of entry with another.\n    ///\n    /// This is equivalent to [`IndexMap::swap_indices`][`crate::IndexMap::swap_indices`]\n    /// with the current [`.index()`][Self::index] as one of the two being swapped.\n    ///\n    /// ***Panics*** if the `other` index is out of bounds.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_indices(mut self, other: usize) {\n        self.map.swap_indices(self.index, other);\n    }\n}",
            "impl<K, V> MutableEntryKey for IndexedEntry<'_, K, V> {\n    type Key = K;\n    fn key_mut(&mut self) -> &mut Self::Key {\n        self.key_mut()\n    }\n}",
            "impl<K, V> Sealed for super::IndexedEntry<'_, K, V> {}",
            "impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IndexedEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"IndexedEntry\")\n            .field(\"index\", &self.index)\n            .field(\"key\", self.key())\n            .field(\"value\", self.get())\n            .finish()\n    }\n}"
        ],
        "map::core::entry::OccupiedEntry": [
            "impl<'a, K, V> From<IndexedEntry<'a, K, V>> for OccupiedEntry<'a, K, V> {\n    fn from(other: IndexedEntry<'a, K, V>) -> Self {\n        let IndexedEntry {\n            map: RefMut { indices, entries },\n            index,\n        } = other;\n        let hash = entries[index].hash;\n        Self {\n            entries,\n            index: indices\n                .find_entry(hash.get(), move |&i| i == index)\n                .expect(\"index not found\"),\n        }\n    }\n}",
            "impl<'a, K, V> OccupiedEntry<'a, K, V> {\n    pub(crate) fn new(\n        entries: &'a mut Entries<K, V>,\n        index: hash_table::OccupiedEntry<'a, usize>,\n    ) -> Self {\n        Self { entries, index }\n    }\n\n    /// Return the index of the key-value pair\n    #[inline]\n    pub fn index(&self) -> usize {\n        *self.index.get()\n    }\n\n    #[inline]\n    fn into_ref_mut(self) -> RefMut<'a, K, V> {\n        RefMut::new(self.index.into_table(), self.entries)\n    }\n\n    /// Gets a reference to the entry's key in the map.\n    ///\n    /// Note that this is not the key that was used to find the entry. There may be an observable\n    /// difference if the key type has any distinguishing features outside of `Hash` and `Eq`, like\n    /// extra fields or the memory address of an allocation.\n    pub fn key(&self) -> &K {\n        &self.entries[self.index()].key\n    }\n\n    pub(crate) fn key_mut(&mut self) -> &mut K {\n        let index = self.index();\n        &mut self.entries[index].key\n    }\n\n    /// Gets a reference to the entry's value in the map.\n    pub fn get(&self) -> &V {\n        &self.entries[self.index()].value\n    }\n\n    /// Gets a mutable reference to the entry's value in the map.\n    ///\n    /// If you need a reference which may outlive the destruction of the\n    /// [`Entry`] value, see [`into_mut`][Self::into_mut].\n    pub fn get_mut(&mut self) -> &mut V {\n        let index = self.index();\n        &mut self.entries[index].value\n    }\n\n    /// Converts into a mutable reference to the entry's value in the map,\n    /// with a lifetime bound to the map itself.\n    pub fn into_mut(self) -> &'a mut V {\n        let index = self.index();\n        &mut self.entries[index].value\n    }\n\n    pub(super) fn into_muts(self) -> (&'a mut K, &'a mut V) {\n        let index = self.index();\n        self.entries[index].muts()\n    }\n\n    /// Sets the value of the entry to `value`, and returns the entry's old value.\n    pub fn insert(&mut self, value: V) -> V {\n        mem::replace(self.get_mut(), value)\n    }\n\n    /// Remove the key, value pair stored in the map for this entry, and return the value.\n    ///\n    /// **NOTE:** This is equivalent to [`.swap_remove()`][Self::swap_remove], replacing this\n    /// entry's position with the last element, and it is deprecated in favor of calling that\n    /// explicitly. If you need to preserve the relative order of the keys in the map, use\n    /// [`.shift_remove()`][Self::shift_remove] instead.\n    #[deprecated(note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\")]\n    pub fn remove(self) -> V {\n        self.swap_remove()\n    }\n\n    /// Remove the key, value pair stored in the map for this entry, and return the value.\n    ///\n    /// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n    /// the last element of the map and popping it off.\n    /// **This perturbs the position of what used to be the last element!**\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove(self) -> V {\n        self.swap_remove_entry().1\n    }\n\n    /// Remove the key, value pair stored in the map for this entry, and return the value.\n    ///\n    /// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove(self) -> V {\n        self.shift_remove_entry().1\n    }\n\n    /// Remove and return the key, value pair stored in the map for this entry\n    ///\n    /// **NOTE:** This is equivalent to [`.swap_remove_entry()`][Self::swap_remove_entry],\n    /// replacing this entry's position with the last element, and it is deprecated in favor of\n    /// calling that explicitly. If you need to preserve the relative order of the keys in the map,\n    /// use [`.shift_remove_entry()`][Self::shift_remove_entry] instead.\n    #[deprecated(note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\")]\n    pub fn remove_entry(self) -> (K, V) {\n        self.swap_remove_entry()\n    }\n\n    /// Remove and return the key, value pair stored in the map for this entry\n    ///\n    /// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n    /// the last element of the map and popping it off.\n    /// **This perturbs the position of what used to be the last element!**\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove_entry(self) -> (K, V) {\n        let (index, entry) = self.index.remove();\n        RefMut::new(entry.into_table(), self.entries).swap_remove_finish(index)\n    }\n\n    /// Remove and return the key, value pair stored in the map for this entry\n    ///\n    /// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove_entry(self) -> (K, V) {\n        let (index, entry) = self.index.remove();\n        RefMut::new(entry.into_table(), self.entries).shift_remove_finish(index)\n    }\n\n    /// Moves the position of the entry to a new index\n    /// by shifting all other entries in-between.\n    ///\n    /// This is equivalent to [`IndexMap::move_index`][`crate::IndexMap::move_index`]\n    /// coming `from` the current [`.index()`][Self::index].\n    ///\n    /// * If `self.index() < to`, the other pairs will shift down while the targeted pair moves up.\n    /// * If `self.index() > to`, the other pairs will shift up while the targeted pair moves down.\n    ///\n    /// ***Panics*** if `to` is out of bounds.\n    ///\n    /// Computes in **O(n)** time (average).\n    #[track_caller]\n    pub fn move_index(self, to: usize) {\n        let index = self.index();\n        self.into_ref_mut().move_index(index, to);\n    }\n\n    /// Swaps the position of entry with another.\n    ///\n    /// This is equivalent to [`IndexMap::swap_indices`][`crate::IndexMap::swap_indices`]\n    /// with the current [`.index()`][Self::index] as one of the two being swapped.\n    ///\n    /// ***Panics*** if the `other` index is out of bounds.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_indices(self, other: usize) {\n        let index = self.index();\n        self.into_ref_mut().swap_indices(index, other);\n    }\n}",
            "impl<K, V> MutableEntryKey for OccupiedEntry<'_, K, V> {\n    type Key = K;\n    fn key_mut(&mut self) -> &mut Self::Key {\n        self.key_mut()\n    }\n}",
            "impl<K, V> Sealed for super::OccupiedEntry<'_, K, V> {}",
            "impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for OccupiedEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"OccupiedEntry\")\n            .field(\"key\", self.key())\n            .field(\"value\", self.get())\n            .finish()\n    }\n}"
        ],
        "map::core::entry::VacantEntry": [
            "impl<'a, K, V> VacantEntry<'a, K, V> {\n    /// Return the index where a key-value pair may be inserted.\n    pub fn index(&self) -> usize {\n        self.map.indices.len()\n    }\n\n    /// Gets a reference to the key that was used to find the entry.\n    pub fn key(&self) -> &K {\n        &self.key\n    }\n\n    pub(crate) fn key_mut(&mut self) -> &mut K {\n        &mut self.key\n    }\n\n    /// Takes ownership of the key, leaving the entry vacant.\n    pub fn into_key(self) -> K {\n        self.key\n    }\n\n    /// Inserts the entry's key and the given value into the map, and returns a mutable reference\n    /// to the value.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    pub fn insert(self, value: V) -> &'a mut V {\n        self.insert_entry(value).into_mut()\n    }\n\n    /// Inserts the entry's key and the given value into the map, and returns an `OccupiedEntry`.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {\n        let Self { map, hash, key } = self;\n        map.insert_unique(hash, key, value)\n    }\n\n    /// Inserts the entry's key and the given value into the map at its ordered\n    /// position among sorted keys, and returns the new index and a mutable\n    /// reference to the value.\n    ///\n    /// If the existing keys are **not** already sorted, then the insertion\n    /// index is unspecified (like [`slice::binary_search`]), but the key-value\n    /// pair is inserted at that position regardless.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn insert_sorted(self, value: V) -> (usize, &'a mut V)\n    where\n        K: Ord,\n    {\n        let slice = crate::map::Slice::from_slice(self.map.entries);\n        let i = slice.binary_search_keys(&self.key).unwrap_err();\n        (i, self.shift_insert(i, value))\n    }\n\n    /// Inserts the entry's key and the given value into the map at the given index,\n    /// shifting others to the right, and returns a mutable reference to the value.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_insert(mut self, index: usize, value: V) -> &'a mut V {\n        self.map\n            .shift_insert_unique(index, self.hash, self.key, value);\n        &mut self.map.entries[index].value\n    }\n}",
            "impl<K, V> MutableEntryKey for VacantEntry<'_, K, V> {\n    type Key = K;\n    fn key_mut(&mut self) -> &mut Self::Key {\n        self.key_mut()\n    }\n}",
            "impl<K, V> Sealed for super::VacantEntry<'_, K, V> {}",
            "impl<K: fmt::Debug, V> fmt::Debug for VacantEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n    }\n}"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder": [
            "impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S> {\n    /// Access an entry by key.\n    pub fn from_key<Q>(self, key: &Q) -> Option<(&'a K, &'a V)>\n    where\n        S: BuildHasher,\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        self.map.get_key_value(key)\n    }\n\n    /// Access an entry by a key and its hash.\n    pub fn from_key_hashed_nocheck<Q>(self, hash: u64, key: &Q) -> Option<(&'a K, &'a V)>\n    where\n        Q: ?Sized + Equivalent<K>,\n    {\n        let hash = HashValue(hash as usize);\n        let i = self.map.core.get_index_of(hash, key)?;\n        self.map.get_index(i)\n    }\n\n    /// Access an entry by hash.\n    pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n    where\n        F: FnMut(&K) -> bool,\n    {\n        let map = self.map;\n        let i = self.index_from_hash(hash, is_match)?;\n        map.get_index(i)\n    }\n\n    /// Access an entry by hash, including its index.\n    pub fn from_hash_full<F>(self, hash: u64, is_match: F) -> Option<(usize, &'a K, &'a V)>\n    where\n        F: FnMut(&K) -> bool,\n    {\n        let map = self.map;\n        let i = self.index_from_hash(hash, is_match)?;\n        let (key, value) = map.get_index(i)?;\n        Some((i, key, value))\n    }\n\n    /// Access the index of an entry by hash.\n    pub fn index_from_hash<F>(self, hash: u64, mut is_match: F) -> Option<usize>\n    where\n        F: FnMut(&K) -> bool,\n    {\n        let hash = HashValue(hash as usize);\n        let entries = &*self.map.core.entries;\n        let eq = move |&i: &usize| is_match(&entries[i].key);\n        self.map.core.indices.find(hash.get(), eq).copied()\n    }\n}",
            "impl<K, V, S> fmt::Debug for RawEntryBuilder<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawEntryBuilder\").finish_non_exhaustive()\n    }\n}"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut": [
            "impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S> {\n    /// Access an entry by key.\n    pub fn from_key<Q>(self, key: &Q) -> RawEntryMut<'a, K, V, S>\n    where\n        S: BuildHasher,\n        Q: ?Sized + Hash + Equivalent<K>,\n    {\n        let hash = self.map.hash(key);\n        self.from_key_hashed_nocheck(hash.get(), key)\n    }\n\n    /// Access an entry by a key and its hash.\n    pub fn from_key_hashed_nocheck<Q>(self, hash: u64, key: &Q) -> RawEntryMut<'a, K, V, S>\n    where\n        Q: ?Sized + Equivalent<K>,\n    {\n        self.from_hash(hash, |k| Q::equivalent(key, k))\n    }\n\n    /// Access an entry by hash.\n    pub fn from_hash<F>(self, hash: u64, mut is_match: F) -> RawEntryMut<'a, K, V, S>\n    where\n        F: FnMut(&K) -> bool,\n    {\n        let ref_entries = &*self.map.core.entries;\n        let eq = move |&i: &usize| is_match(&ref_entries[i].key);\n        match self.map.core.indices.find_entry(hash, eq) {\n            Ok(index) => RawEntryMut::Occupied(RawOccupiedEntryMut {\n                entries: &mut self.map.core.entries,\n                index,\n                hash_builder: PhantomData,\n            }),\n            Err(absent) => RawEntryMut::Vacant(RawVacantEntryMut {\n                map: RefMut::new(absent.into_table(), &mut self.map.core.entries),\n                hash_builder: &self.map.hash_builder,\n            }),\n        }\n    }\n}",
            "impl<K, V, S> fmt::Debug for RawEntryBuilderMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawEntryBuilderMut\").finish_non_exhaustive()\n    }\n}"
        ],
        "map::core::raw_entry_v1::RawEntryMut": [
            "impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n    /// Return the index where the key-value pair exists or may be inserted.\n    #[inline]\n    pub fn index(&self) -> usize {\n        match self {\n            Self::Occupied(entry) => entry.index(),\n            Self::Vacant(entry) => entry.index(),\n        }\n    }\n\n    /// Inserts the given default key and value in the entry if it is vacant and returns mutable\n    /// references to them. Otherwise mutable references to an already existent pair are returned.\n    pub fn or_insert(self, default_key: K, default_value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            Self::Occupied(entry) => entry.into_key_value_mut(),\n            Self::Vacant(entry) => entry.insert(default_key, default_value),\n        }\n    }\n\n    /// Inserts the result of the `call` function in the entry if it is vacant and returns mutable\n    /// references to them. Otherwise mutable references to an already existent pair are returned.\n    pub fn or_insert_with<F>(self, call: F) -> (&'a mut K, &'a mut V)\n    where\n        F: FnOnce() -> (K, V),\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            Self::Occupied(entry) => entry.into_key_value_mut(),\n            Self::Vacant(entry) => {\n                let (key, value) = call();\n                entry.insert(key, value)\n            }\n        }\n    }\n\n    /// Modifies the entry if it is occupied.\n    pub fn and_modify<F>(mut self, f: F) -> Self\n    where\n        F: FnOnce(&mut K, &mut V),\n    {\n        if let Self::Occupied(entry) = &mut self {\n            let (k, v) = entry.get_key_value_mut();\n            f(k, v);\n        }\n        self\n    }\n}",
            "impl<K: fmt::Debug, V: fmt::Debug, S> fmt::Debug for RawEntryMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut tuple = f.debug_tuple(\"RawEntryMut\");\n        match self {\n            Self::Vacant(v) => tuple.field(v),\n            Self::Occupied(o) => tuple.field(o),\n        };\n        tuple.finish()\n    }\n}"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut": [
            "impl<'a, K, V, S> RawOccupiedEntryMut<'a, K, V, S> {\n    /// Return the index of the key-value pair\n    #[inline]\n    pub fn index(&self) -> usize {\n        *self.index.get()\n    }\n\n    #[inline]\n    fn into_ref_mut(self) -> RefMut<'a, K, V> {\n        RefMut::new(self.index.into_table(), self.entries)\n    }\n\n    /// Gets a reference to the entry's key in the map.\n    ///\n    /// Note that this is not the key that was used to find the entry. There may be an observable\n    /// difference if the key type has any distinguishing features outside of `Hash` and `Eq`, like\n    /// extra fields or the memory address of an allocation.\n    pub fn key(&self) -> &K {\n        &self.entries[self.index()].key\n    }\n\n    /// Gets a mutable reference to the entry's key in the map.\n    ///\n    /// Note that this is not the key that was used to find the entry. There may be an observable\n    /// difference if the key type has any distinguishing features outside of `Hash` and `Eq`, like\n    /// extra fields or the memory address of an allocation.\n    pub fn key_mut(&mut self) -> &mut K {\n        let index = self.index();\n        &mut self.entries[index].key\n    }\n\n    /// Converts into a mutable reference to the entry's key in the map,\n    /// with a lifetime bound to the map itself.\n    ///\n    /// Note that this is not the key that was used to find the entry. There may be an observable\n    /// difference if the key type has any distinguishing features outside of `Hash` and `Eq`, like\n    /// extra fields or the memory address of an allocation.\n    pub fn into_key(self) -> &'a mut K {\n        let index = self.index();\n        &mut self.entries[index].key\n    }\n\n    /// Gets a reference to the entry's value in the map.\n    pub fn get(&self) -> &V {\n        &self.entries[self.index()].value\n    }\n\n    /// Gets a mutable reference to the entry's value in the map.\n    ///\n    /// If you need a reference which may outlive the destruction of the\n    /// [`RawEntryMut`] value, see [`into_mut`][Self::into_mut].\n    pub fn get_mut(&mut self) -> &mut V {\n        let index = self.index();\n        &mut self.entries[index].value\n    }\n\n    /// Converts into a mutable reference to the entry's value in the map,\n    /// with a lifetime bound to the map itself.\n    pub fn into_mut(self) -> &'a mut V {\n        let index = self.index();\n        &mut self.entries[index].value\n    }\n\n    /// Gets a reference to the entry's key and value in the map.\n    pub fn get_key_value(&self) -> (&K, &V) {\n        self.entries[self.index()].refs()\n    }\n\n    /// Gets a reference to the entry's key and value in the map.\n    pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {\n        let index = self.index();\n        self.entries[index].muts()\n    }\n\n    /// Converts into a mutable reference to the entry's key and value in the map,\n    /// with a lifetime bound to the map itself.\n    pub fn into_key_value_mut(self) -> (&'a mut K, &'a mut V) {\n        let index = self.index();\n        self.entries[index].muts()\n    }\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    pub fn insert(&mut self, value: V) -> V {\n        mem::replace(self.get_mut(), value)\n    }\n\n    /// Sets the key of the entry, and returns the entry's old key.\n    pub fn insert_key(&mut self, key: K) -> K {\n        mem::replace(self.key_mut(), key)\n    }\n\n    /// Remove the key, value pair stored in the map for this entry, and return the value.\n    ///\n    /// **NOTE:** This is equivalent to [`.swap_remove()`][Self::swap_remove], replacing this\n    /// entry's position with the last element, and it is deprecated in favor of calling that\n    /// explicitly. If you need to preserve the relative order of the keys in the map, use\n    /// [`.shift_remove()`][Self::shift_remove] instead.\n    #[deprecated(note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\")]\n    pub fn remove(self) -> V {\n        self.swap_remove()\n    }\n\n    /// Remove the key, value pair stored in the map for this entry, and return the value.\n    ///\n    /// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n    /// the last element of the map and popping it off.\n    /// **This perturbs the position of what used to be the last element!**\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove(self) -> V {\n        self.swap_remove_entry().1\n    }\n\n    /// Remove the key, value pair stored in the map for this entry, and return the value.\n    ///\n    /// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove(self) -> V {\n        self.shift_remove_entry().1\n    }\n\n    /// Remove and return the key, value pair stored in the map for this entry\n    ///\n    /// **NOTE:** This is equivalent to [`.swap_remove_entry()`][Self::swap_remove_entry],\n    /// replacing this entry's position with the last element, and it is deprecated in favor of\n    /// calling that explicitly. If you need to preserve the relative order of the keys in the map,\n    /// use [`.shift_remove_entry()`][Self::shift_remove_entry] instead.\n    #[deprecated(note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\")]\n    pub fn remove_entry(self) -> (K, V) {\n        self.swap_remove_entry()\n    }\n\n    /// Remove and return the key, value pair stored in the map for this entry\n    ///\n    /// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n    /// the last element of the map and popping it off.\n    /// **This perturbs the position of what used to be the last element!**\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove_entry(self) -> (K, V) {\n        let (index, entry) = self.index.remove();\n        RefMut::new(entry.into_table(), self.entries).swap_remove_finish(index)\n    }\n\n    /// Remove and return the key, value pair stored in the map for this entry\n    ///\n    /// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove_entry(self) -> (K, V) {\n        let (index, entry) = self.index.remove();\n        RefMut::new(entry.into_table(), self.entries).shift_remove_finish(index)\n    }\n\n    /// Moves the position of the entry to a new index\n    /// by shifting all other entries in-between.\n    ///\n    /// This is equivalent to [`IndexMap::move_index`]\n    /// coming `from` the current [`.index()`][Self::index].\n    ///\n    /// * If `self.index() < to`, the other pairs will shift down while the targeted pair moves up.\n    /// * If `self.index() > to`, the other pairs will shift up while the targeted pair moves down.\n    ///\n    /// ***Panics*** if `to` is out of bounds.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn move_index(self, to: usize) {\n        let index = self.index();\n        self.into_ref_mut().move_index(index, to);\n    }\n\n    /// Swaps the position of entry with another.\n    ///\n    /// This is equivalent to [`IndexMap::swap_indices`]\n    /// with the current [`.index()`][Self::index] as one of the two being swapped.\n    ///\n    /// ***Panics*** if the `other` index is out of bounds.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_indices(self, other: usize) {\n        let index = self.index();\n        self.into_ref_mut().swap_indices(index, other);\n    }\n}",
            "impl<K: fmt::Debug, V: fmt::Debug, S> fmt::Debug for RawOccupiedEntryMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawOccupiedEntryMut\")\n            .field(\"key\", self.key())\n            .field(\"value\", self.get())\n            .finish_non_exhaustive()\n    }\n}"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut": [
            "impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n    /// Return the index where a key-value pair may be inserted.\n    pub fn index(&self) -> usize {\n        self.map.indices.len()\n    }\n\n    /// Inserts the given key and value into the map,\n    /// and returns mutable references to them.\n    pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        let mut h = self.hash_builder.build_hasher();\n        key.hash(&mut h);\n        self.insert_hashed_nocheck(h.finish(), key, value)\n    }\n\n    /// Inserts the given key and value into the map with the provided hash,\n    /// and returns mutable references to them.\n    pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V) {\n        let hash = HashValue(hash as usize);\n        self.map.insert_unique(hash, key, value).into_muts()\n    }\n\n    /// Inserts the given key and value into the map at the given index,\n    /// shifting others to the right, and returns mutable references to them.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_insert(self, index: usize, key: K, value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        let mut h = self.hash_builder.build_hasher();\n        key.hash(&mut h);\n        self.shift_insert_hashed_nocheck(index, h.finish(), key, value)\n    }\n\n    /// Inserts the given key and value into the map with the provided hash\n    /// at the given index, and returns mutable references to them.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_insert_hashed_nocheck(\n        mut self,\n        index: usize,\n        hash: u64,\n        key: K,\n        value: V,\n    ) -> (&'a mut K, &'a mut V) {\n        let hash = HashValue(hash as usize);\n        self.map.shift_insert_unique(index, hash, key, value);\n        self.map.entries[index].muts()\n    }\n}",
            "impl<K, V, S> fmt::Debug for RawVacantEntryMut<'_, K, V, S> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RawVacantEntryMut\").finish_non_exhaustive()\n    }\n}"
        ],
        "map::iter::Drain": [
            "impl<'a, K, V> Drain<'a, K, V> {\n    pub(super) fn new(iter: vec::Drain<'a, Bucket<K, V>>) -> Self {\n        Self { iter }\n    }\n\n    /// Returns a slice of the remaining entries in the iterator.\n    pub fn as_slice(&self) -> &Slice<K, V> {\n        Slice::from_slice(self.iter.as_slice())\n    }\n}",
            "impl<K, V> DoubleEndedIterator for Drain<'_, K, V> {\n    double_ended_iterator_methods!(Bucket::key_value);\n}",
            "impl<K, V> ExactSizeIterator for Drain<'_, K, V> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<K, V> FusedIterator for Drain<'_, K, V> {}",
            "impl<K, V> Iterator for Drain<'_, K, V> {\n    type Item = (K, V);\n\n    iterator_methods!(Bucket::key_value);\n}",
            "impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Drain<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let iter = self.iter.as_slice().iter().map(Bucket::refs);\n        f.debug_list().entries(iter).finish()\n    }\n}"
        ],
        "map::iter::IntoIter": [
            "Clone",
            "impl<K, V> Default for IntoIter<K, V> {\n    fn default() -> Self {\n        Self {\n            iter: Vec::new().into_iter(),\n        }\n    }\n}",
            "impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n    double_ended_iterator_methods!(Bucket::key_value);\n}",
            "impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<K, V> FusedIterator for IntoIter<K, V> {}",
            "impl<K, V> IntoIter<K, V> {\n    pub(super) fn new(entries: Vec<Bucket<K, V>>) -> Self {\n        Self {\n            iter: entries.into_iter(),\n        }\n    }\n\n    /// Returns a slice of the remaining entries in the iterator.\n    pub fn as_slice(&self) -> &Slice<K, V> {\n        Slice::from_slice(self.iter.as_slice())\n    }\n\n    /// Returns a mutable slice of the remaining entries in the iterator.\n    pub fn as_mut_slice(&mut self) -> &mut Slice<K, V> {\n        Slice::from_mut_slice(self.iter.as_mut_slice())\n    }\n}",
            "impl<K, V> Iterator for IntoIter<K, V> {\n    type Item = (K, V);\n\n    iterator_methods!(Bucket::key_value);\n}",
            "impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let iter = self.iter.as_slice().iter().map(Bucket::refs);\n        f.debug_list().entries(iter).finish()\n    }\n}"
        ],
        "map::iter::IntoKeys": [
            "impl<K, V> Default for IntoKeys<K, V> {\n    fn default() -> Self {\n        Self {\n            iter: Vec::new().into_iter(),\n        }\n    }\n}",
            "impl<K, V> DoubleEndedIterator for IntoKeys<K, V> {\n    double_ended_iterator_methods!(Bucket::key);\n}",
            "impl<K, V> ExactSizeIterator for IntoKeys<K, V> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<K, V> FusedIterator for IntoKeys<K, V> {}",
            "impl<K, V> IntoKeys<K, V> {\n    pub(super) fn new(entries: Vec<Bucket<K, V>>) -> Self {\n        Self {\n            iter: entries.into_iter(),\n        }\n    }\n}",
            "impl<K, V> Iterator for IntoKeys<K, V> {\n    type Item = K;\n\n    iterator_methods!(Bucket::key);\n}",
            "impl<K: fmt::Debug, V> fmt::Debug for IntoKeys<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let iter = self.iter.as_slice().iter().map(Bucket::key_ref);\n        f.debug_list().entries(iter).finish()\n    }\n}"
        ],
        "map::iter::IntoValues": [
            "impl<K, V: fmt::Debug> fmt::Debug for IntoValues<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let iter = self.iter.as_slice().iter().map(Bucket::value_ref);\n        f.debug_list().entries(iter).finish()\n    }\n}",
            "impl<K, V> Default for IntoValues<K, V> {\n    fn default() -> Self {\n        Self {\n            iter: Vec::new().into_iter(),\n        }\n    }\n}",
            "impl<K, V> DoubleEndedIterator for IntoValues<K, V> {\n    double_ended_iterator_methods!(Bucket::value);\n}",
            "impl<K, V> ExactSizeIterator for IntoValues<K, V> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<K, V> FusedIterator for IntoValues<K, V> {}",
            "impl<K, V> IntoValues<K, V> {\n    pub(super) fn new(entries: Vec<Bucket<K, V>>) -> Self {\n        Self {\n            iter: entries.into_iter(),\n        }\n    }\n}",
            "impl<K, V> Iterator for IntoValues<K, V> {\n    type Item = V;\n\n    iterator_methods!(Bucket::value);\n}"
        ],
        "map::iter::Iter": [
            "impl<'a, K, V> Iter<'a, K, V> {\n    pub(super) fn new(entries: &'a [Bucket<K, V>]) -> Self {\n        Self {\n            iter: entries.iter(),\n        }\n    }\n\n    /// Returns a slice of the remaining entries in the iterator.\n    pub fn as_slice(&self) -> &'a Slice<K, V> {\n        Slice::from_slice(self.iter.as_slice())\n    }\n}",
            "impl<'a, K, V> Iterator for Iter<'a, K, V> {\n    type Item = (&'a K, &'a V);\n\n    iterator_methods!(Bucket::refs);\n}",
            "impl<K, V> Clone for Iter<'_, K, V> {\n    fn clone(&self) -> Self {\n        Iter {\n            iter: self.iter.clone(),\n        }\n    }\n}",
            "impl<K, V> Default for Iter<'_, K, V> {\n    fn default() -> Self {\n        Self { iter: [].iter() }\n    }\n}",
            "impl<K, V> DoubleEndedIterator for Iter<'_, K, V> {\n    double_ended_iterator_methods!(Bucket::refs);\n}",
            "impl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<K, V> FusedIterator for Iter<'_, K, V> {}",
            "impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Iter<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"
        ],
        "map::iter::IterMut": [
            "impl<'a, K, V> IterMut<'a, K, V> {\n    pub(super) fn new(entries: &'a mut [Bucket<K, V>]) -> Self {\n        Self {\n            iter: entries.iter_mut(),\n        }\n    }\n\n    /// Returns a slice of the remaining entries in the iterator.\n    pub fn as_slice(&self) -> &Slice<K, V> {\n        Slice::from_slice(self.iter.as_slice())\n    }\n\n    /// Returns a mutable slice of the remaining entries in the iterator.\n    ///\n    /// To avoid creating `&mut` references that alias, this is forced to consume the iterator.\n    pub fn into_slice(self) -> &'a mut Slice<K, V> {\n        Slice::from_mut_slice(self.iter.into_slice())\n    }\n}",
            "impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n    type Item = (&'a K, &'a mut V);\n\n    iterator_methods!(Bucket::ref_mut);\n}",
            "impl<K, V> Default for IterMut<'_, K, V> {\n    fn default() -> Self {\n        Self {\n            iter: [].iter_mut(),\n        }\n    }\n}",
            "impl<K, V> DoubleEndedIterator for IterMut<'_, K, V> {\n    double_ended_iterator_methods!(Bucket::ref_mut);\n}",
            "impl<K, V> ExactSizeIterator for IterMut<'_, K, V> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<K, V> FusedIterator for IterMut<'_, K, V> {}",
            "impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IterMut<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let iter = self.iter.as_slice().iter().map(Bucket::refs);\n        f.debug_list().entries(iter).finish()\n    }\n}"
        ],
        "map::iter::IterMut2": [
            "impl<'a, K, V> IterMut2<'a, K, V> {\n    pub(super) fn new(entries: &'a mut [Bucket<K, V>]) -> Self {\n        Self {\n            iter: entries.iter_mut(),\n        }\n    }\n\n    /// Returns a slice of the remaining entries in the iterator.\n    pub fn as_slice(&self) -> &Slice<K, V> {\n        Slice::from_slice(self.iter.as_slice())\n    }\n\n    /// Returns a mutable slice of the remaining entries in the iterator.\n    ///\n    /// To avoid creating `&mut` references that alias, this is forced to consume the iterator.\n    pub fn into_slice(self) -> &'a mut Slice<K, V> {\n        Slice::from_mut_slice(self.iter.into_slice())\n    }\n}",
            "impl<'a, K, V> Iterator for IterMut2<'a, K, V> {\n    type Item = (&'a mut K, &'a mut V);\n\n    iterator_methods!(Bucket::muts);\n}",
            "impl<K, V> Default for IterMut2<'_, K, V> {\n    fn default() -> Self {\n        Self {\n            iter: [].iter_mut(),\n        }\n    }\n}",
            "impl<K, V> DoubleEndedIterator for IterMut2<'_, K, V> {\n    double_ended_iterator_methods!(Bucket::muts);\n}",
            "impl<K, V> ExactSizeIterator for IterMut2<'_, K, V> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<K, V> FusedIterator for IterMut2<'_, K, V> {}",
            "impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IterMut2<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let iter = self.iter.as_slice().iter().map(Bucket::refs);\n        f.debug_list().entries(iter).finish()\n    }\n}"
        ],
        "map::iter::Keys": [
            "impl<'a, K, V> Iterator for Keys<'a, K, V> {\n    type Item = &'a K;\n\n    iterator_methods!(Bucket::key_ref);\n}",
            "impl<'a, K, V> Keys<'a, K, V> {\n    pub(super) fn new(entries: &'a [Bucket<K, V>]) -> Self {\n        Self {\n            iter: entries.iter(),\n        }\n    }\n}",
            "impl<K, V> Clone for Keys<'_, K, V> {\n    fn clone(&self) -> Self {\n        Keys {\n            iter: self.iter.clone(),\n        }\n    }\n}",
            "impl<K, V> Default for Keys<'_, K, V> {\n    fn default() -> Self {\n        Self { iter: [].iter() }\n    }\n}",
            "impl<K, V> DoubleEndedIterator for Keys<'_, K, V> {\n    double_ended_iterator_methods!(Bucket::key_ref);\n}",
            "impl<K, V> ExactSizeIterator for Keys<'_, K, V> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<K, V> FusedIterator for Keys<'_, K, V> {}",
            "impl<K, V> Index<usize> for Keys<'_, K, V> {\n    type Output = K;\n\n    /// Returns a reference to the key at the supplied `index`.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    fn index(&self, index: usize) -> &K {\n        &self.iter.as_slice()[index].key\n    }\n}",
            "impl<K: fmt::Debug, V> fmt::Debug for Keys<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"
        ],
        "map::iter::Splice": [
            "impl<'a, I, K, V, S> Splice<'a, I, K, V, S>\nwhere\n    I: Iterator<Item = (K, V)>,\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    #[track_caller]\n    pub(super) fn new<R>(map: &'a mut IndexMap<K, V, S>, range: R, replace_with: I) -> Self\n    where\n        R: RangeBounds<usize>,\n    {\n        let (tail, drain) = map.core.split_splice(range);\n        Self {\n            map,\n            tail,\n            drain,\n            replace_with,\n        }\n    }\n}",
            "impl<I, K, V, S> DoubleEndedIterator for Splice<'_, I, K, V, S>\nwhere\n    I: Iterator<Item = (K, V)>,\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.drain.next_back().map(Bucket::key_value)\n    }\n}",
            "impl<I, K, V, S> Drop for Splice<'_, I, K, V, S>\nwhere\n    I: Iterator<Item = (K, V)>,\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    fn drop(&mut self) {\n        // Finish draining unconsumed items. We don't strictly *have* to do this\n        // manually, since we already split it into separate memory, but it will\n        // match the drop order of `vec::Splice` items this way.\n        let _ = self.drain.nth(usize::MAX);\n\n        // Now insert all the new items. If a key matches an existing entry, it\n        // keeps the original position and only replaces the value, like `insert`.\n        while let Some((key, value)) = self.replace_with.next() {\n            // Since the tail is disjoint, we can try to update it first,\n            // or else insert (update or append) the primary map.\n            let hash = self.map.hash(&key);\n            if let Some(i) = self.tail.get_index_of(hash, &key) {\n                self.tail.as_entries_mut()[i].value = value;\n            } else {\n                self.map.core.insert_full(hash, key, value);\n            }\n        }\n\n        // Finally, re-append the tail\n        self.map.core.append_unchecked(&mut self.tail);\n    }\n}",
            "impl<I, K, V, S> ExactSizeIterator for Splice<'_, I, K, V, S>\nwhere\n    I: Iterator<Item = (K, V)>,\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    fn len(&self) -> usize {\n        self.drain.len()\n    }\n}",
            "impl<I, K, V, S> FusedIterator for Splice<'_, I, K, V, S>\nwhere\n    I: Iterator<Item = (K, V)>,\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n}",
            "impl<I, K, V, S> Iterator for Splice<'_, I, K, V, S>\nwhere\n    I: Iterator<Item = (K, V)>,\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    type Item = (K, V);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.drain.next().map(Bucket::key_value)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.drain.size_hint()\n    }\n}",
            "impl<I, K, V, S> fmt::Debug for Splice<'_, I, K, V, S>\nwhere\n    I: fmt::Debug + Iterator<Item = (K, V)>,\n    K: fmt::Debug + Hash + Eq,\n    V: fmt::Debug,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Follow `vec::Splice` in only printing the drain and replacement\n        f.debug_struct(\"Splice\")\n            .field(\"drain\", &self.drain)\n            .field(\"replace_with\", &self.replace_with)\n            .finish()\n    }\n}"
        ],
        "map::iter::Values": [
            "impl<'a, K, V> Iterator for Values<'a, K, V> {\n    type Item = &'a V;\n\n    iterator_methods!(Bucket::value_ref);\n}",
            "impl<'a, K, V> Values<'a, K, V> {\n    pub(super) fn new(entries: &'a [Bucket<K, V>]) -> Self {\n        Self {\n            iter: entries.iter(),\n        }\n    }\n}",
            "impl<K, V: fmt::Debug> fmt::Debug for Values<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}",
            "impl<K, V> Clone for Values<'_, K, V> {\n    fn clone(&self) -> Self {\n        Values {\n            iter: self.iter.clone(),\n        }\n    }\n}",
            "impl<K, V> Default for Values<'_, K, V> {\n    fn default() -> Self {\n        Self { iter: [].iter() }\n    }\n}",
            "impl<K, V> DoubleEndedIterator for Values<'_, K, V> {\n    double_ended_iterator_methods!(Bucket::value_ref);\n}",
            "impl<K, V> ExactSizeIterator for Values<'_, K, V> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<K, V> FusedIterator for Values<'_, K, V> {}"
        ],
        "map::iter::ValuesMut": [
            "impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n    type Item = &'a mut V;\n\n    iterator_methods!(Bucket::value_mut);\n}",
            "impl<'a, K, V> ValuesMut<'a, K, V> {\n    pub(super) fn new(entries: &'a mut [Bucket<K, V>]) -> Self {\n        Self {\n            iter: entries.iter_mut(),\n        }\n    }\n}",
            "impl<K, V: fmt::Debug> fmt::Debug for ValuesMut<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let iter = self.iter.as_slice().iter().map(Bucket::value_ref);\n        f.debug_list().entries(iter).finish()\n    }\n}",
            "impl<K, V> Default for ValuesMut<'_, K, V> {\n    fn default() -> Self {\n        Self {\n            iter: [].iter_mut(),\n        }\n    }\n}",
            "impl<K, V> DoubleEndedIterator for ValuesMut<'_, K, V> {\n    double_ended_iterator_methods!(Bucket::value_mut);\n}",
            "impl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}"
        ],
        "map::slice::Slice": [
            "impl<K, V, K2, V2, const N: usize> PartialEq<[(K2, V2); N]> for Slice<K, V>\nwhere\n    K: PartialEq<K2>,\n    V: PartialEq<V2>,\n{\n    fn eq(&self, other: &[(K2, V2); N]) -> bool {\n        <Self as PartialEq<[_]>>::eq(self, other)\n    }\n}",
            "impl<K, V, K2, V2> PartialEq<Slice<K2, V2>> for Slice<K, V>\nwhere\n    K: PartialEq<K2>,\n    V: PartialEq<V2>,\n{\n    fn eq(&self, other: &Slice<K2, V2>) -> bool {\n        slice_eq(&self.entries, &other.entries, |b1, b2| {\n            b1.key == b2.key && b1.value == b2.value\n        })\n    }\n}",
            "impl<K, V, K2, V2> PartialEq<[(K2, V2)]> for Slice<K, V>\nwhere\n    K: PartialEq<K2>,\n    V: PartialEq<V2>,\n{\n    fn eq(&self, other: &[(K2, V2)]) -> bool {\n        slice_eq(&self.entries, other, |b, t| b.key == t.0 && b.value == t.1)\n    }\n}",
            "impl<K, V> Index<$range> for Slice<K, V> {\n            type Output = Slice<K, V>;\n\n            fn index(&self, range: $range) -> &Self {\n                Self::from_slice(&self.entries[range])\n            }\n        }",
            "impl<K, V> Index<usize> for Slice<K, V> {\n    type Output = V;\n\n    fn index(&self, index: usize) -> &V {\n        &self.entries[index].value\n    }\n}",
            "impl<K, V> IndexMut<$range> for Slice<K, V> {\n            fn index_mut(&mut self, range: $range) -> &mut Self {\n                Self::from_mut_slice(&mut self.entries[range])\n            }\n        }",
            "impl<K, V> IndexMut<usize> for Slice<K, V> {\n    fn index_mut(&mut self, index: usize) -> &mut V {\n        &mut self.entries[index].value\n    }\n}",
            "impl<K, V> Slice<K, V> {\n    pub(crate) fn into_entries(self: Box<Self>) -> Vec<Bucket<K, V>> {\n        self.into_boxed().into_vec()\n    }\n\n    /// Returns an empty slice.\n    pub const fn new<'a>() -> &'a Self {\n        Self::from_slice(&[])\n    }\n\n    /// Returns an empty mutable slice.\n    pub fn new_mut<'a>() -> &'a mut Self {\n        Self::from_mut_slice(&mut [])\n    }\n\n    /// Return the number of key-value pairs in the map slice.\n    #[inline]\n    pub const fn len(&self) -> usize {\n        self.entries.len()\n    }\n\n    /// Returns true if the map slice contains no elements.\n    #[inline]\n    pub const fn is_empty(&self) -> bool {\n        self.entries.is_empty()\n    }\n\n    /// Get a key-value pair by index.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    pub fn get_index(&self, index: usize) -> Option<(&K, &V)> {\n        self.entries.get(index).map(Bucket::refs)\n    }\n\n    /// Get a key-value pair by index, with mutable access to the value.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    pub fn get_index_mut(&mut self, index: usize) -> Option<(&K, &mut V)> {\n        self.entries.get_mut(index).map(Bucket::ref_mut)\n    }\n\n    /// Returns a slice of key-value pairs in the given range of indices.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    pub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Self> {\n        let range = try_simplify_range(range, self.entries.len())?;\n        self.entries.get(range).map(Slice::from_slice)\n    }\n\n    /// Returns a mutable slice of key-value pairs in the given range of indices.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    pub fn get_range_mut<R: RangeBounds<usize>>(&mut self, range: R) -> Option<&mut Self> {\n        let range = try_simplify_range(range, self.entries.len())?;\n        self.entries.get_mut(range).map(Slice::from_mut_slice)\n    }\n\n    /// Get the first key-value pair.\n    pub fn first(&self) -> Option<(&K, &V)> {\n        self.entries.first().map(Bucket::refs)\n    }\n\n    /// Get the first key-value pair, with mutable access to the value.\n    pub fn first_mut(&mut self) -> Option<(&K, &mut V)> {\n        self.entries.first_mut().map(Bucket::ref_mut)\n    }\n\n    /// Get the last key-value pair.\n    pub fn last(&self) -> Option<(&K, &V)> {\n        self.entries.last().map(Bucket::refs)\n    }\n\n    /// Get the last key-value pair, with mutable access to the value.\n    pub fn last_mut(&mut self) -> Option<(&K, &mut V)> {\n        self.entries.last_mut().map(Bucket::ref_mut)\n    }\n\n    /// Divides one slice into two at an index.\n    ///\n    /// ***Panics*** if `index > len`.\n    pub fn split_at(&self, index: usize) -> (&Self, &Self) {\n        let (first, second) = self.entries.split_at(index);\n        (Self::from_slice(first), Self::from_slice(second))\n    }\n\n    /// Divides one mutable slice into two at an index.\n    ///\n    /// ***Panics*** if `index > len`.\n    pub fn split_at_mut(&mut self, index: usize) -> (&mut Self, &mut Self) {\n        let (first, second) = self.entries.split_at_mut(index);\n        (Self::from_mut_slice(first), Self::from_mut_slice(second))\n    }\n\n    /// Returns the first key-value pair and the rest of the slice,\n    /// or `None` if it is empty.\n    pub fn split_first(&self) -> Option<((&K, &V), &Self)> {\n        if let [first, rest @ ..] = &self.entries {\n            Some((first.refs(), Self::from_slice(rest)))\n        } else {\n            None\n        }\n    }\n\n    /// Returns the first key-value pair and the rest of the slice,\n    /// with mutable access to the value, or `None` if it is empty.\n    pub fn split_first_mut(&mut self) -> Option<((&K, &mut V), &mut Self)> {\n        if let [first, rest @ ..] = &mut self.entries {\n            Some((first.ref_mut(), Self::from_mut_slice(rest)))\n        } else {\n            None\n        }\n    }\n\n    /// Returns the last key-value pair and the rest of the slice,\n    /// or `None` if it is empty.\n    pub fn split_last(&self) -> Option<((&K, &V), &Self)> {\n        if let [rest @ .., last] = &self.entries {\n            Some((last.refs(), Self::from_slice(rest)))\n        } else {\n            None\n        }\n    }\n\n    /// Returns the last key-value pair and the rest of the slice,\n    /// with mutable access to the value, or `None` if it is empty.\n    pub fn split_last_mut(&mut self) -> Option<((&K, &mut V), &mut Self)> {\n        if let [rest @ .., last] = &mut self.entries {\n            Some((last.ref_mut(), Self::from_mut_slice(rest)))\n        } else {\n            None\n        }\n    }\n\n    /// Return an iterator over the key-value pairs of the map slice.\n    pub fn iter(&self) -> Iter<'_, K, V> {\n        Iter::new(&self.entries)\n    }\n\n    /// Return an iterator over the key-value pairs of the map slice.\n    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n        IterMut::new(&mut self.entries)\n    }\n\n    /// Return an iterator over the keys of the map slice.\n    pub fn keys(&self) -> Keys<'_, K, V> {\n        Keys::new(&self.entries)\n    }\n\n    /// Return an owning iterator over the keys of the map slice.\n    pub fn into_keys(self: Box<Self>) -> IntoKeys<K, V> {\n        IntoKeys::new(self.into_entries())\n    }\n\n    /// Return an iterator over the values of the map slice.\n    pub fn values(&self) -> Values<'_, K, V> {\n        Values::new(&self.entries)\n    }\n\n    /// Return an iterator over mutable references to the the values of the map slice.\n    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {\n        ValuesMut::new(&mut self.entries)\n    }\n\n    /// Return an owning iterator over the values of the map slice.\n    pub fn into_values(self: Box<Self>) -> IntoValues<K, V> {\n        IntoValues::new(self.into_entries())\n    }\n\n    /// Search over a sorted map for a key.\n    ///\n    /// Returns the position where that key is present, or the position where it can be inserted to\n    /// maintain the sort. See [`slice::binary_search`] for more details.\n    ///\n    /// Computes in **O(log(n))** time, which is notably less scalable than looking the key up in\n    /// the map this is a slice from using [`IndexMap::get_index_of`], but this can also position\n    /// missing keys.\n    pub fn binary_search_keys(&self, x: &K) -> Result<usize, usize>\n    where\n        K: Ord,\n    {\n        self.binary_search_by(|p, _| p.cmp(x))\n    }\n\n    /// Search over a sorted map with a comparator function.\n    ///\n    /// Returns the position where that value is present, or the position where it can be inserted\n    /// to maintain the sort. See [`slice::binary_search_by`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[inline]\n    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a K, &'a V) -> Ordering,\n    {\n        self.entries.binary_search_by(move |a| f(&a.key, &a.value))\n    }\n\n    /// Search over a sorted map with an extraction function.\n    ///\n    /// Returns the position where that value is present, or the position where it can be inserted\n    /// to maintain the sort. See [`slice::binary_search_by_key`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[inline]\n    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a K, &'a V) -> B,\n        B: Ord,\n    {\n        self.binary_search_by(|k, v| f(k, v).cmp(b))\n    }\n\n    /// Returns the index of the partition point of a sorted map according to the given predicate\n    /// (the index of the first element of the second partition).\n    ///\n    /// See [`slice::partition_point`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[must_use]\n    pub fn partition_point<P>(&self, mut pred: P) -> usize\n    where\n        P: FnMut(&K, &V) -> bool,\n    {\n        self.entries\n            .partition_point(move |a| pred(&a.key, &a.value))\n    }\n\n    /// Get an array of `N` key-value pairs by `N` indices\n    ///\n    /// Valid indices are *0 <= index < self.len()* and each index needs to be unique.\n    pub fn get_disjoint_mut<const N: usize>(\n        &mut self,\n        indices: [usize; N],\n    ) -> Result<[(&K, &mut V); N], GetDisjointMutError> {\n        let indices = indices.map(Some);\n        let key_values = self.get_disjoint_opt_mut(indices)?;\n        Ok(key_values.map(Option::unwrap))\n    }\n\n    #[allow(unsafe_code)]\n    pub(crate) fn get_disjoint_opt_mut<const N: usize>(\n        &mut self,\n        indices: [Option<usize>; N],\n    ) -> Result<[Option<(&K, &mut V)>; N], GetDisjointMutError> {\n        // SAFETY: Can't allow duplicate indices as we would return several mutable refs to the same data.\n        let len = self.len();\n        for i in 0..N {\n            if let Some(idx) = indices[i] {\n                if idx >= len {\n                    return Err(GetDisjointMutError::IndexOutOfBounds);\n                } else if indices[..i].contains(&Some(idx)) {\n                    return Err(GetDisjointMutError::OverlappingIndices);\n                }\n            }\n        }\n\n        let entries_ptr = self.entries.as_mut_ptr();\n        let out = indices.map(|idx_opt| {\n            match idx_opt {\n                Some(idx) => {\n                    // SAFETY: The base pointer is valid as it comes from a slice and the reference is always\n                    // in-bounds & unique as we've already checked the indices above.\n                    let kv = unsafe { (*(entries_ptr.add(idx))).ref_mut() };\n                    Some(kv)\n                }\n                None => None,\n            }\n        });\n\n        Ok(out)\n    }\n}",
            "impl<K, V> Slice<K, V> {\n    pub(super) const fn from_slice(entries: &[Bucket<K, V>]) -> &Self {\n        unsafe { &*(entries as *const [Bucket<K, V>] as *const Self) }\n    }\n\n    pub(super) fn from_mut_slice(entries: &mut [Bucket<K, V>]) -> &mut Self {\n        unsafe { &mut *(entries as *mut [Bucket<K, V>] as *mut Self) }\n    }\n\n    pub(super) fn from_boxed(entries: Box<[Bucket<K, V>]>) -> Box<Self> {\n        unsafe { Box::from_raw(Box::into_raw(entries) as *mut Self) }\n    }\n\n    fn into_boxed(self: Box<Self>) -> Box<[Bucket<K, V>]> {\n        unsafe { Box::from_raw(Box::into_raw(self) as *mut [Bucket<K, V>]) }\n    }\n}",
            "impl<K: Eq, V: Eq> Eq for Slice<K, V> {}",
            "impl<K: Hash, V: Hash> Hash for Slice<K, V> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.len().hash(state);\n        for (key, value) in self {\n            key.hash(state);\n            value.hash(state);\n        }\n    }\n}",
            "impl<K: Ord, V: Ord> Ord for Slice<K, V> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.iter().cmp(other)\n    }\n}",
            "impl<K: PartialOrd, V: PartialOrd> PartialOrd for Slice<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.iter().partial_cmp(other)\n    }\n}",
            "impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Slice<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self).finish()\n    }\n}"
        ],
        "set::IndexSet": [
            "impl<'a, T, S> Extend<&'a T> for IndexSet<T, S>\nwhere\n    T: Hash + Eq + Copy + 'a,\n    S: BuildHasher,\n{\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iterable: I) {\n        let iter = iterable.into_iter().copied();\n        self.extend(iter);\n    }\n}",
            "impl<T, S1, S2> PartialEq<IndexSet<T, S2>> for IndexSet<T, S1>\nwhere\n    T: Hash + Eq,\n    S1: BuildHasher,\n    S2: BuildHasher,\n{\n    fn eq(&self, other: &IndexSet<T, S2>) -> bool {\n        self.len() == other.len() && self.is_subset(other)\n    }\n}",
            "impl<T, S> Clone for IndexSet<T, S>\nwhere\n    T: Clone,\n    S: Clone,\n{\n    fn clone(&self) -> Self {\n        IndexSet {\n            map: self.map.clone(),\n        }\n    }\n\n    fn clone_from(&mut self, other: &Self) {\n        self.map.clone_from(&other.map);\n    }\n}",
            "impl<T, S> Default for IndexSet<T, S>\nwhere\n    S: Default,\n{\n    /// Return an empty [`IndexSet`]\n    fn default() -> Self {\n        IndexSet {\n            map: IndexMap::default(),\n        }\n    }\n}",
            "impl<T, S> Entries for IndexSet<T, S> {\n    type Entry = Bucket<T>;\n\n    #[inline]\n    fn into_entries(self) -> Vec<Self::Entry> {\n        self.map.into_entries()\n    }\n\n    #[inline]\n    fn as_entries(&self) -> &[Self::Entry] {\n        self.map.as_entries()\n    }\n\n    #[inline]\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry] {\n        self.map.as_entries_mut()\n    }\n\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]),\n    {\n        self.map.with_entries(f);\n    }\n}",
            "impl<T, S> Eq for IndexSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}",
            "impl<T, S> Extend<T> for IndexSet<T, S>\nwhere\n    T: Hash + Eq,\n    S: BuildHasher,\n{\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iterable: I) {\n        let iter = iterable.into_iter().map(|x| (x, ()));\n        self.map.extend(iter);\n    }\n}",
            "impl<T, S> FromIterator<T> for IndexSet<T, S>\nwhere\n    T: Hash + Eq,\n    S: BuildHasher + Default,\n{\n    fn from_iter<I: IntoIterator<Item = T>>(iterable: I) -> Self {\n        let iter = iterable.into_iter().map(|x| (x, ()));\n        IndexSet {\n            map: IndexMap::from_iter(iter),\n        }\n    }\n}",
            "impl<T, S> Index<$range> for IndexSet<T, S> {\n            type Output = Slice<T>;\n\n            fn index(&self, range: $range) -> &Self::Output {\n                Slice::from_slice(&self.as_entries()[range])\n            }\n        }",
            "impl<T, S> Index<usize> for IndexSet<T, S> {\n    type Output = T;\n\n    /// Returns a reference to the value at the supplied `index`.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    fn index(&self, index: usize) -> &T {\n        self.get_index(index).unwrap_or_else(|| {\n            panic!(\n                \"index out of bounds: the len is {len} but the index is {index}\",\n                len = self.len()\n            );\n        })\n    }\n}",
            "impl<T, S> IndexSet<T, S>\nwhere\n    S: BuildHasher,\n{\n    /// Return `true` if an equivalent to `value` exists in the set.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn contains<Q>(&self, value: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.map.contains_key(value)\n    }\n\n    /// Return a reference to the value stored in the set, if it is present,\n    /// else `None`.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn get<Q>(&self, value: &Q) -> Option<&T>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.map.get_key_value(value).map(|(x, &())| x)\n    }\n\n    /// Return item index and value\n    pub fn get_full<Q>(&self, value: &Q) -> Option<(usize, &T)>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.map.get_full(value).map(|(i, x, &())| (i, x))\n    }\n\n    /// Return item index, if it exists in the set\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn get_index_of<Q>(&self, value: &Q) -> Option<usize>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.map.get_index_of(value)\n    }\n\n    /// Remove the value from the set, and return `true` if it was present.\n    ///\n    /// **NOTE:** This is equivalent to [`.swap_remove(value)`][Self::swap_remove], replacing this\n    /// value's position with the last element, and it is deprecated in favor of calling that\n    /// explicitly. If you need to preserve the relative order of the values in the set, use\n    /// [`.shift_remove(value)`][Self::shift_remove] instead.\n    #[deprecated(note = \"`remove` disrupts the set order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\")]\n    pub fn remove<Q>(&mut self, value: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.swap_remove(value)\n    }\n\n    /// Remove the value from the set, and return `true` if it was present.\n    ///\n    /// Like [`Vec::swap_remove`], the value is removed by swapping it with the\n    /// last element of the set and popping it off. **This perturbs\n    /// the position of what used to be the last element!**\n    ///\n    /// Return `false` if `value` was not in the set.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove<Q>(&mut self, value: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.map.swap_remove(value).is_some()\n    }\n\n    /// Remove the value from the set, and return `true` if it was present.\n    ///\n    /// Like [`Vec::remove`], the value is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Return `false` if `value` was not in the set.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove<Q>(&mut self, value: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.map.shift_remove(value).is_some()\n    }\n\n    /// Removes and returns the value in the set, if any, that is equal to the\n    /// given one.\n    ///\n    /// **NOTE:** This is equivalent to [`.swap_take(value)`][Self::swap_take], replacing this\n    /// value's position with the last element, and it is deprecated in favor of calling that\n    /// explicitly. If you need to preserve the relative order of the values in the set, use\n    /// [`.shift_take(value)`][Self::shift_take] instead.\n    #[deprecated(note = \"`take` disrupts the set order -- \\\n        use `swap_take` or `shift_take` for explicit behavior.\")]\n    pub fn take<Q>(&mut self, value: &Q) -> Option<T>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.swap_take(value)\n    }\n\n    /// Removes and returns the value in the set, if any, that is equal to the\n    /// given one.\n    ///\n    /// Like [`Vec::swap_remove`], the value is removed by swapping it with the\n    /// last element of the set and popping it off. **This perturbs\n    /// the position of what used to be the last element!**\n    ///\n    /// Return `None` if `value` was not in the set.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_take<Q>(&mut self, value: &Q) -> Option<T>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.map.swap_remove_entry(value).map(|(x, ())| x)\n    }\n\n    /// Removes and returns the value in the set, if any, that is equal to the\n    /// given one.\n    ///\n    /// Like [`Vec::remove`], the value is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Return `None` if `value` was not in the set.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_take<Q>(&mut self, value: &Q) -> Option<T>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.map.shift_remove_entry(value).map(|(x, ())| x)\n    }\n\n    /// Remove the value from the set return it and the index it had.\n    ///\n    /// Like [`Vec::swap_remove`], the value is removed by swapping it with the\n    /// last element of the set and popping it off. **This perturbs\n    /// the position of what used to be the last element!**\n    ///\n    /// Return `None` if `value` was not in the set.\n    pub fn swap_remove_full<Q>(&mut self, value: &Q) -> Option<(usize, T)>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.map.swap_remove_full(value).map(|(i, x, ())| (i, x))\n    }\n\n    /// Remove the value from the set return it and the index it had.\n    ///\n    /// Like [`Vec::remove`], the value is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Return `None` if `value` was not in the set.\n    pub fn shift_remove_full<Q>(&mut self, value: &Q) -> Option<(usize, T)>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        self.map.shift_remove_full(value).map(|(i, x, ())| (i, x))\n    }\n}",
            "impl<T, S> IndexSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    /// Returns `true` if `self` has no elements in common with `other`.\n    pub fn is_disjoint<S2>(&self, other: &IndexSet<T, S2>) -> bool\n    where\n        S2: BuildHasher,\n    {\n        if self.len() <= other.len() {\n            self.iter().all(move |value| !other.contains(value))\n        } else {\n            other.iter().all(move |value| !self.contains(value))\n        }\n    }\n\n    /// Returns `true` if all elements of `self` are contained in `other`.\n    pub fn is_subset<S2>(&self, other: &IndexSet<T, S2>) -> bool\n    where\n        S2: BuildHasher,\n    {\n        self.len() <= other.len() && self.iter().all(move |value| other.contains(value))\n    }\n\n    /// Returns `true` if all elements of `other` are contained in `self`.\n    pub fn is_superset<S2>(&self, other: &IndexSet<T, S2>) -> bool\n    where\n        S2: BuildHasher,\n    {\n        other.is_subset(self)\n    }\n}",
            "impl<T, S> IndexSet<T, S>\nwhere\n    T: Hash + Eq,\n    S: BuildHasher,\n{\n    /// Insert the value into the set.\n    ///\n    /// If an equivalent item already exists in the set, it returns\n    /// `false` leaving the original value in the set and without\n    /// altering its insertion order. Otherwise, it inserts the new\n    /// item and returns `true`.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    pub fn insert(&mut self, value: T) -> bool {\n        self.map.insert(value, ()).is_none()\n    }\n\n    /// Insert the value into the set, and get its index.\n    ///\n    /// If an equivalent item already exists in the set, it returns\n    /// the index of the existing item and `false`, leaving the\n    /// original value in the set and without altering its insertion\n    /// order. Otherwise, it inserts the new item and returns the index\n    /// of the inserted item and `true`.\n    ///\n    /// Computes in **O(1)** time (amortized average).\n    pub fn insert_full(&mut self, value: T) -> (usize, bool) {\n        let (index, existing) = self.map.insert_full(value, ());\n        (index, existing.is_none())\n    }\n\n    /// Insert the value into the set at its ordered position among sorted values.\n    ///\n    /// This is equivalent to finding the position with\n    /// [`binary_search`][Self::binary_search], and if needed calling\n    /// [`insert_before`][Self::insert_before] for a new value.\n    ///\n    /// If the sorted item is found in the set, it returns the index of that\n    /// existing item and `false`, without any change. Otherwise, it inserts the\n    /// new item and returns its sorted index and `true`.\n    ///\n    /// If the existing items are **not** already sorted, then the insertion\n    /// index is unspecified (like [`slice::binary_search`]), but the value\n    /// is moved to or inserted at that position regardless.\n    ///\n    /// Computes in **O(n)** time (average). Instead of repeating calls to\n    /// `insert_sorted`, it may be faster to call batched [`insert`][Self::insert]\n    /// or [`extend`][Self::extend] and only call [`sort`][Self::sort] or\n    /// [`sort_unstable`][Self::sort_unstable] once.\n    pub fn insert_sorted(&mut self, value: T) -> (usize, bool)\n    where\n        T: Ord,\n    {\n        let (index, existing) = self.map.insert_sorted(value, ());\n        (index, existing.is_none())\n    }\n\n    /// Insert the value into the set before the value at the given index, or at the end.\n    ///\n    /// If an equivalent item already exists in the set, it returns `false` leaving the\n    /// original value in the set, but moved to the new position. The returned index\n    /// will either be the given index or one less, depending on how the value moved.\n    /// (See [`shift_insert`](Self::shift_insert) for different behavior here.)\n    ///\n    /// Otherwise, it inserts the new value exactly at the given index and returns `true`.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    /// Valid indices are `0..=set.len()` (inclusive).\n    ///\n    /// Computes in **O(n)** time (average).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use indexmap::IndexSet;\n    /// let mut set: IndexSet<char> = ('a'..='z').collect();\n    ///\n    /// // The new value '*' goes exactly at the given index.\n    /// assert_eq!(set.get_index_of(&'*'), None);\n    /// assert_eq!(set.insert_before(10, '*'), (10, true));\n    /// assert_eq!(set.get_index_of(&'*'), Some(10));\n    ///\n    /// // Moving the value 'a' up will shift others down, so this moves *before* 10 to index 9.\n    /// assert_eq!(set.insert_before(10, 'a'), (9, false));\n    /// assert_eq!(set.get_index_of(&'a'), Some(9));\n    /// assert_eq!(set.get_index_of(&'*'), Some(10));\n    ///\n    /// // Moving the value 'z' down will shift others up, so this moves to exactly 10.\n    /// assert_eq!(set.insert_before(10, 'z'), (10, false));\n    /// assert_eq!(set.get_index_of(&'z'), Some(10));\n    /// assert_eq!(set.get_index_of(&'*'), Some(11));\n    ///\n    /// // Moving or inserting before the endpoint is also valid.\n    /// assert_eq!(set.len(), 27);\n    /// assert_eq!(set.insert_before(set.len(), '*'), (26, false));\n    /// assert_eq!(set.get_index_of(&'*'), Some(26));\n    /// assert_eq!(set.insert_before(set.len(), '+'), (27, true));\n    /// assert_eq!(set.get_index_of(&'+'), Some(27));\n    /// assert_eq!(set.len(), 28);\n    /// ```\n    #[track_caller]\n    pub fn insert_before(&mut self, index: usize, value: T) -> (usize, bool) {\n        let (index, existing) = self.map.insert_before(index, value, ());\n        (index, existing.is_none())\n    }\n\n    /// Insert the value into the set at the given index.\n    ///\n    /// If an equivalent item already exists in the set, it returns `false` leaving\n    /// the original value in the set, but moved to the given index.\n    /// Note that existing values **cannot** be moved to `index == set.len()`!\n    /// (See [`insert_before`](Self::insert_before) for different behavior here.)\n    ///\n    /// Otherwise, it inserts the new value at the given index and returns `true`.\n    ///\n    /// ***Panics*** if `index` is out of bounds.\n    /// Valid indices are `0..set.len()` (exclusive) when moving an existing value, or\n    /// `0..=set.len()` (inclusive) when inserting a new value.\n    ///\n    /// Computes in **O(n)** time (average).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use indexmap::IndexSet;\n    /// let mut set: IndexSet<char> = ('a'..='z').collect();\n    ///\n    /// // The new value '*' goes exactly at the given index.\n    /// assert_eq!(set.get_index_of(&'*'), None);\n    /// assert_eq!(set.shift_insert(10, '*'), true);\n    /// assert_eq!(set.get_index_of(&'*'), Some(10));\n    ///\n    /// // Moving the value 'a' up to 10 will shift others down, including the '*' that was at 10.\n    /// assert_eq!(set.shift_insert(10, 'a'), false);\n    /// assert_eq!(set.get_index_of(&'a'), Some(10));\n    /// assert_eq!(set.get_index_of(&'*'), Some(9));\n    ///\n    /// // Moving the value 'z' down to 9 will shift others up, including the '*' that was at 9.\n    /// assert_eq!(set.shift_insert(9, 'z'), false);\n    /// assert_eq!(set.get_index_of(&'z'), Some(9));\n    /// assert_eq!(set.get_index_of(&'*'), Some(10));\n    ///\n    /// // Existing values can move to len-1 at most, but new values can insert at the endpoint.\n    /// assert_eq!(set.len(), 27);\n    /// assert_eq!(set.shift_insert(set.len() - 1, '*'), false);\n    /// assert_eq!(set.get_index_of(&'*'), Some(26));\n    /// assert_eq!(set.shift_insert(set.len(), '+'), true);\n    /// assert_eq!(set.get_index_of(&'+'), Some(27));\n    /// assert_eq!(set.len(), 28);\n    /// ```\n    ///\n    /// ```should_panic\n    /// use indexmap::IndexSet;\n    /// let mut set: IndexSet<char> = ('a'..='z').collect();\n    ///\n    /// // This is an invalid index for moving an existing value!\n    /// set.shift_insert(set.len(), 'a');\n    /// ```\n    #[track_caller]\n    pub fn shift_insert(&mut self, index: usize, value: T) -> bool {\n        self.map.shift_insert(index, value, ()).is_none()\n    }\n\n    /// Adds a value to the set, replacing the existing value, if any, that is\n    /// equal to the given one, without altering its insertion order. Returns\n    /// the replaced value.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn replace(&mut self, value: T) -> Option<T> {\n        self.replace_full(value).1\n    }\n\n    /// Adds a value to the set, replacing the existing value, if any, that is\n    /// equal to the given one, without altering its insertion order. Returns\n    /// the index of the item and its replaced value.\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn replace_full(&mut self, value: T) -> (usize, Option<T>) {\n        let hash = self.map.hash(&value);\n        match self.map.core.replace_full(hash, value, ()) {\n            (i, Some((replaced, ()))) => (i, Some(replaced)),\n            (i, None) => (i, None),\n        }\n    }\n\n    /// Return an iterator over the values that are in `self` but not `other`.\n    ///\n    /// Values are produced in the same order that they appear in `self`.\n    pub fn difference<'a, S2>(&'a self, other: &'a IndexSet<T, S2>) -> Difference<'a, T, S2>\n    where\n        S2: BuildHasher,\n    {\n        Difference::new(self, other)\n    }\n\n    /// Return an iterator over the values that are in `self` or `other`,\n    /// but not in both.\n    ///\n    /// Values from `self` are produced in their original order, followed by\n    /// values from `other` in their original order.\n    pub fn symmetric_difference<'a, S2>(\n        &'a self,\n        other: &'a IndexSet<T, S2>,\n    ) -> SymmetricDifference<'a, T, S, S2>\n    where\n        S2: BuildHasher,\n    {\n        SymmetricDifference::new(self, other)\n    }\n\n    /// Return an iterator over the values that are in both `self` and `other`.\n    ///\n    /// Values are produced in the same order that they appear in `self`.\n    pub fn intersection<'a, S2>(&'a self, other: &'a IndexSet<T, S2>) -> Intersection<'a, T, S2>\n    where\n        S2: BuildHasher,\n    {\n        Intersection::new(self, other)\n    }\n\n    /// Return an iterator over all values that are in `self` or `other`.\n    ///\n    /// Values from `self` are produced in their original order, followed by\n    /// values that are unique to `other` in their original order.\n    pub fn union<'a, S2>(&'a self, other: &'a IndexSet<T, S2>) -> Union<'a, T, S>\n    where\n        S2: BuildHasher,\n    {\n        Union::new(self, other)\n    }\n\n    /// Creates a splicing iterator that replaces the specified range in the set\n    /// with the given `replace_with` iterator and yields the removed items.\n    /// `replace_with` does not need to be the same length as `range`.\n    ///\n    /// The `range` is removed even if the iterator is not consumed until the\n    /// end. It is unspecified how many elements are removed from the set if the\n    /// `Splice` value is leaked.\n    ///\n    /// The input iterator `replace_with` is only consumed when the `Splice`\n    /// value is dropped. If a value from the iterator matches an existing entry\n    /// in the set (outside of `range`), then the original will be unchanged.\n    /// Otherwise, the new value will be inserted in the replaced `range`.\n    ///\n    /// ***Panics*** if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use indexmap::IndexSet;\n    ///\n    /// let mut set = IndexSet::from([0, 1, 2, 3, 4]);\n    /// let new = [5, 4, 3, 2, 1];\n    /// let removed: Vec<_> = set.splice(2..4, new).collect();\n    ///\n    /// // 1 and 4 kept their positions, while 5, 3, and 2 were newly inserted.\n    /// assert!(set.into_iter().eq([0, 1, 5, 3, 2, 4]));\n    /// assert_eq!(removed, &[2, 3]);\n    /// ```\n    #[track_caller]\n    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter, T, S>\n    where\n        R: RangeBounds<usize>,\n        I: IntoIterator<Item = T>,\n    {\n        Splice::new(self, range, replace_with.into_iter())\n    }\n\n    /// Moves all values from `other` into `self`, leaving `other` empty.\n    ///\n    /// This is equivalent to calling [`insert`][Self::insert] for each value\n    /// from `other` in order, which means that values that already exist\n    /// in `self` are unchanged in their current position.\n    ///\n    /// See also [`union`][Self::union] to iterate the combined values by\n    /// reference, without modifying `self` or `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use indexmap::IndexSet;\n    ///\n    /// let mut a = IndexSet::from([3, 2, 1]);\n    /// let mut b = IndexSet::from([3, 4, 5]);\n    /// let old_capacity = b.capacity();\n    ///\n    /// a.append(&mut b);\n    ///\n    /// assert_eq!(a.len(), 5);\n    /// assert_eq!(b.len(), 0);\n    /// assert_eq!(b.capacity(), old_capacity);\n    ///\n    /// assert!(a.iter().eq(&[3, 2, 1, 4, 5]));\n    /// ```\n    pub fn append<S2>(&mut self, other: &mut IndexSet<T, S2>) {\n        self.map.append(&mut other.map);\n    }\n}",
            "impl<T, S> IndexSet<T, S> {\n    /// Create a new set with capacity for `n` elements.\n    /// (Does not allocate if `n` is zero.)\n    ///\n    /// Computes in **O(n)** time.\n    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {\n        IndexSet {\n            map: IndexMap::with_capacity_and_hasher(n, hash_builder),\n        }\n    }\n\n    /// Create a new set with `hash_builder`.\n    ///\n    /// This function is `const`, so it\n    /// can be called in `static` contexts.\n    pub const fn with_hasher(hash_builder: S) -> Self {\n        IndexSet {\n            map: IndexMap::with_hasher(hash_builder),\n        }\n    }\n\n    /// Return the number of elements the set can hold without reallocating.\n    ///\n    /// This number is a lower bound; the set might be able to hold more,\n    /// but is guaranteed to be able to hold at least this many.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn capacity(&self) -> usize {\n        self.map.capacity()\n    }\n\n    /// Return a reference to the set's `BuildHasher`.\n    pub fn hasher(&self) -> &S {\n        self.map.hasher()\n    }\n\n    /// Return the number of elements in the set.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn len(&self) -> usize {\n        self.map.len()\n    }\n\n    /// Returns true if the set contains no elements.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn is_empty(&self) -> bool {\n        self.map.is_empty()\n    }\n\n    /// Return an iterator over the values of the set, in their order\n    pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self.as_entries())\n    }\n\n    /// Remove all elements in the set, while preserving its capacity.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn clear(&mut self) {\n        self.map.clear();\n    }\n\n    /// Shortens the set, keeping the first `len` elements and dropping the rest.\n    ///\n    /// If `len` is greater than the set's current length, this has no effect.\n    pub fn truncate(&mut self, len: usize) {\n        self.map.truncate(len);\n    }\n\n    /// Clears the `IndexSet` in the given index range, returning those values\n    /// as a drain iterator.\n    ///\n    /// The range may be any type that implements [`RangeBounds<usize>`],\n    /// including all of the `std::ops::Range*` types, or even a tuple pair of\n    /// `Bound` start and end values. To drain the set entirely, use `RangeFull`\n    /// like `set.drain(..)`.\n    ///\n    /// This shifts down all entries following the drained range to fill the\n    /// gap, and keeps the allocated memory for reuse.\n    ///\n    /// ***Panics*** if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the set.\n    #[track_caller]\n    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n    where\n        R: RangeBounds<usize>,\n    {\n        Drain::new(self.map.core.drain(range))\n    }\n\n    /// Splits the collection into two at the given index.\n    ///\n    /// Returns a newly allocated set containing the elements in the range\n    /// `[at, len)`. After the call, the original set will be left containing\n    /// the elements `[0, at)` with its previous capacity unchanged.\n    ///\n    /// ***Panics*** if `at > len`.\n    #[track_caller]\n    pub fn split_off(&mut self, at: usize) -> Self\n    where\n        S: Clone,\n    {\n        Self {\n            map: self.map.split_off(at),\n        }\n    }\n\n    /// Reserve capacity for `additional` more values.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn reserve(&mut self, additional: usize) {\n        self.map.reserve(additional);\n    }\n\n    /// Reserve capacity for `additional` more values, without over-allocating.\n    ///\n    /// Unlike `reserve`, this does not deliberately over-allocate the entry capacity to avoid\n    /// frequent re-allocations. However, the underlying data structures may still have internal\n    /// capacity requirements, and the allocator itself may give more space than requested, so this\n    /// cannot be relied upon to be precisely minimal.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.map.reserve_exact(additional);\n    }\n\n    /// Try to reserve capacity for `additional` more values.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.map.try_reserve(additional)\n    }\n\n    /// Try to reserve capacity for `additional` more values, without over-allocating.\n    ///\n    /// Unlike `try_reserve`, this does not deliberately over-allocate the entry capacity to avoid\n    /// frequent re-allocations. However, the underlying data structures may still have internal\n    /// capacity requirements, and the allocator itself may give more space than requested, so this\n    /// cannot be relied upon to be precisely minimal.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.map.try_reserve_exact(additional)\n    }\n\n    /// Shrink the capacity of the set as much as possible.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn shrink_to_fit(&mut self) {\n        self.map.shrink_to_fit();\n    }\n\n    /// Shrink the capacity of the set with a lower limit.\n    ///\n    /// Computes in **O(n)** time.\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.map.shrink_to(min_capacity);\n    }\n}",
            "impl<T, S> IndexSet<T, S> {\n    /// Remove the last value\n    ///\n    /// This preserves the order of the remaining elements.\n    ///\n    /// Computes in **O(1)** time (average).\n    #[doc(alias = \"pop_last\")] // like `BTreeSet`\n    pub fn pop(&mut self) -> Option<T> {\n        self.map.pop().map(|(x, ())| x)\n    }\n\n    /// Scan through each value in the set and keep those where the\n    /// closure `keep` returns `true`.\n    ///\n    /// The elements are visited in order, and remaining elements keep their\n    /// order.\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn retain<F>(&mut self, mut keep: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n        self.map.retain(move |x, &mut ()| keep(x))\n    }\n\n    /// Sort the sets values by their default ordering.\n    ///\n    /// This is a stable sort -- but equivalent values should not normally coexist in\n    /// a set at all, so [`sort_unstable`][Self::sort_unstable] is preferred\n    /// because it is generally faster and doesn't allocate auxiliary memory.\n    ///\n    /// See [`sort_by`](Self::sort_by) for details.\n    pub fn sort(&mut self)\n    where\n        T: Ord,\n    {\n        self.map.sort_keys()\n    }\n\n    /// Sort the sets values in place using the comparison function `cmp`.\n    ///\n    /// Computes in **O(n log n)** time and **O(n)** space. The sort is stable.\n    pub fn sort_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        self.map.sort_by(move |a, _, b, _| cmp(a, b));\n    }\n\n    /// Sort the values of the set and return a by-value iterator of\n    /// the values with the result.\n    ///\n    /// The sort is stable.\n    pub fn sorted_by<F>(self, mut cmp: F) -> IntoIter<T>\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        let mut entries = self.into_entries();\n        entries.sort_by(move |a, b| cmp(&a.key, &b.key));\n        IntoIter::new(entries)\n    }\n\n    /// Sort the set's values by their default ordering.\n    ///\n    /// See [`sort_unstable_by`](Self::sort_unstable_by) for details.\n    pub fn sort_unstable(&mut self)\n    where\n        T: Ord,\n    {\n        self.map.sort_unstable_keys()\n    }\n\n    /// Sort the set's values in place using the comparison function `cmp`.\n    ///\n    /// Computes in **O(n log n)** time. The sort is unstable.\n    pub fn sort_unstable_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        self.map.sort_unstable_by(move |a, _, b, _| cmp(a, b))\n    }\n\n    /// Sort the values of the set and return a by-value iterator of\n    /// the values with the result.\n    pub fn sorted_unstable_by<F>(self, mut cmp: F) -> IntoIter<T>\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        let mut entries = self.into_entries();\n        entries.sort_unstable_by(move |a, b| cmp(&a.key, &b.key));\n        IntoIter::new(entries)\n    }\n\n    /// Sort the sets values in place using a key extraction function.\n    ///\n    /// During sorting, the function is called at most once per entry, by using temporary storage\n    /// to remember the results of its evaluation. The order of calls to the function is\n    /// unspecified and may change between versions of `indexmap` or the standard library.\n    ///\n    /// Computes in **O(m n + n log n + c)** time () and **O(n)** space, where the function is\n    /// **O(m)**, *n* is the length of the map, and *c* the capacity. The sort is stable.\n    pub fn sort_by_cached_key<K, F>(&mut self, mut sort_key: F)\n    where\n        K: Ord,\n        F: FnMut(&T) -> K,\n    {\n        self.with_entries(move |entries| {\n            entries.sort_by_cached_key(move |a| sort_key(&a.key));\n        });\n    }\n\n    /// Search over a sorted set for a value.\n    ///\n    /// Returns the position where that value is present, or the position where it can be inserted\n    /// to maintain the sort. See [`slice::binary_search`] for more details.\n    ///\n    /// Computes in **O(log(n))** time, which is notably less scalable than looking the value up\n    /// using [`get_index_of`][IndexSet::get_index_of], but this can also position missing values.\n    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n    where\n        T: Ord,\n    {\n        self.as_slice().binary_search(x)\n    }\n\n    /// Search over a sorted set with a comparator function.\n    ///\n    /// Returns the position where that value is present, or the position where it can be inserted\n    /// to maintain the sort. See [`slice::binary_search_by`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[inline]\n    pub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,\n    {\n        self.as_slice().binary_search_by(f)\n    }\n\n    /// Search over a sorted set with an extraction function.\n    ///\n    /// Returns the position where that value is present, or the position where it can be inserted\n    /// to maintain the sort. See [`slice::binary_search_by_key`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[inline]\n    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> B,\n        B: Ord,\n    {\n        self.as_slice().binary_search_by_key(b, f)\n    }\n\n    /// Returns the index of the partition point of a sorted set according to the given predicate\n    /// (the index of the first element of the second partition).\n    ///\n    /// See [`slice::partition_point`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[must_use]\n    pub fn partition_point<P>(&self, pred: P) -> usize\n    where\n        P: FnMut(&T) -> bool,\n    {\n        self.as_slice().partition_point(pred)\n    }\n\n    /// Reverses the order of the sets values in place.\n    ///\n    /// Computes in **O(n)** time and **O(1)** space.\n    pub fn reverse(&mut self) {\n        self.map.reverse()\n    }\n\n    /// Returns a slice of all the values in the set.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn as_slice(&self) -> &Slice<T> {\n        Slice::from_slice(self.as_entries())\n    }\n\n    /// Converts into a boxed slice of all the values in the set.\n    ///\n    /// Note that this will drop the inner hash table and any excess capacity.\n    pub fn into_boxed_slice(self) -> Box<Slice<T>> {\n        Slice::from_boxed(self.into_entries().into_boxed_slice())\n    }\n\n    /// Get a value by index\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn get_index(&self, index: usize) -> Option<&T> {\n        self.as_entries().get(index).map(Bucket::key_ref)\n    }\n\n    /// Returns a slice of values in the given range of indices.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Computes in **O(1)** time.\n    pub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Slice<T>> {\n        let entries = self.as_entries();\n        let range = try_simplify_range(range, entries.len())?;\n        entries.get(range).map(Slice::from_slice)\n    }\n\n    /// Get the first value\n    ///\n    /// Computes in **O(1)** time.\n    pub fn first(&self) -> Option<&T> {\n        self.as_entries().first().map(Bucket::key_ref)\n    }\n\n    /// Get the last value\n    ///\n    /// Computes in **O(1)** time.\n    pub fn last(&self) -> Option<&T> {\n        self.as_entries().last().map(Bucket::key_ref)\n    }\n\n    /// Remove the value by index\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Like [`Vec::swap_remove`], the value is removed by swapping it with the\n    /// last element of the set and popping it off. **This perturbs\n    /// the position of what used to be the last element!**\n    ///\n    /// Computes in **O(1)** time (average).\n    pub fn swap_remove_index(&mut self, index: usize) -> Option<T> {\n        self.map.swap_remove_index(index).map(|(x, ())| x)\n    }\n\n    /// Remove the value by index\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Like [`Vec::remove`], the value is removed by shifting all of the\n    /// elements that follow it, preserving their relative order.\n    /// **This perturbs the index of all of those elements!**\n    ///\n    /// Computes in **O(n)** time (average).\n    pub fn shift_remove_index(&mut self, index: usize) -> Option<T> {\n        self.map.shift_remove_index(index).map(|(x, ())| x)\n    }\n\n    /// Moves the position of a value from one index to another\n    /// by shifting all other values in-between.\n    ///\n    /// * If `from < to`, the other values will shift down while the targeted value moves up.\n    /// * If `from > to`, the other values will shift up while the targeted value moves down.\n    ///\n    /// ***Panics*** if `from` or `to` are out of bounds.\n    ///\n    /// Computes in **O(n)** time (average).\n    #[track_caller]\n    pub fn move_index(&mut self, from: usize, to: usize) {\n        self.map.move_index(from, to)\n    }\n\n    /// Swaps the position of two values in the set.\n    ///\n    /// ***Panics*** if `a` or `b` are out of bounds.\n    ///\n    /// Computes in **O(1)** time (average).\n    #[track_caller]\n    pub fn swap_indices(&mut self, a: usize, b: usize) {\n        self.map.swap_indices(a, b)\n    }\n}",
            "impl<T, S> IntoIterator for IndexSet<T, S> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter::new(self.into_entries())\n    }\n}",
            "impl<T, S> MutableValues for IndexSet<T, S>\nwhere\n    S: BuildHasher,\n{\n    type Value = T;\n\n    fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut T)>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,\n    {\n        match self.map.get_full_mut2(value) {\n            Some((index, value, ())) => Some((index, value)),\n            None => None,\n        }\n    }\n\n    fn get_index_mut2(&mut self, index: usize) -> Option<&mut T> {\n        match self.map.get_index_mut2(index) {\n            Some((value, ())) => Some(value),\n            None => None,\n        }\n    }\n\n    fn retain2<F>(&mut self, mut keep: F)\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n        self.map.retain2(move |value, ()| keep(value));\n    }\n}",
            "impl<T, S> Sealed for super::IndexSet<T, S> {}",
            "impl<T, S> fmt::Debug for IndexSet<T, S>\nwhere\n    T: fmt::Debug,\n{\n    #[cfg(not(feature = \"test_debug\"))]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_set().entries(self.iter()).finish()\n    }\n\n    #[cfg(feature = \"test_debug\")]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Let the inner `IndexMap` print all of its details\n        f.debug_struct(\"IndexSet\").field(\"map\", &self.map).finish()\n    }\n}",
            "impl<T, const N: usize> From<[T; N]> for IndexSet<T, RandomState>\nwhere\n    T: Eq + Hash,\n{\n    /// # Examples\n    ///\n    /// ```\n    /// use indexmap::IndexSet;\n    ///\n    /// let set1 = IndexSet::from([1, 2, 3, 4]);\n    /// let set2: IndexSet<_> = [1, 2, 3, 4].into();\n    /// assert_eq!(set1, set2);\n    /// ```\n    fn from(arr: [T; N]) -> Self {\n        Self::from_iter(arr)\n    }\n}",
            "impl<T> IndexSet<T> {\n    /// Create a new set. (Does not allocate.)\n    pub fn new() -> Self {\n        IndexSet {\n            map: IndexMap::new(),\n        }\n    }\n\n    /// Create a new set with capacity for `n` elements.\n    /// (Does not allocate if `n` is zero.)\n    ///\n    /// Computes in **O(n)** time.\n    pub fn with_capacity(n: usize) -> Self {\n        IndexSet {\n            map: IndexMap::with_capacity(n),\n        }\n    }\n}"
        ],
        "set::iter::Difference": [
            "impl<'a, T, S> Difference<'a, T, S> {\n    pub(super) fn new<S1>(set: &'a IndexSet<T, S1>, other: &'a IndexSet<T, S>) -> Self {\n        Self {\n            iter: set.iter(),\n            other,\n        }\n    }\n}",
            "impl<'a, T, S> Iterator for Difference<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(item) = self.iter.next() {\n            if !self.other.contains(item) {\n                return Some(item);\n            }\n        }\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}",
            "impl<T, S> Clone for Difference<'_, T, S> {\n    fn clone(&self) -> Self {\n        Difference {\n            iter: self.iter.clone(),\n            ..*self\n        }\n    }\n}",
            "impl<T, S> DoubleEndedIterator for Difference<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while let Some(item) = self.iter.next_back() {\n            if !self.other.contains(item) {\n                return Some(item);\n            }\n        }\n        None\n    }\n}",
            "impl<T, S> FusedIterator for Difference<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}",
            "impl<T, S> fmt::Debug for Difference<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"
        ],
        "set::iter::Drain": [
            "impl<'a, T> Drain<'a, T> {\n    pub(super) fn new(iter: vec::Drain<'a, Bucket<T>>) -> Self {\n        Self { iter }\n    }\n\n    /// Returns a slice of the remaining entries in the iterator.\n    pub fn as_slice(&self) -> &Slice<T> {\n        Slice::from_slice(self.iter.as_slice())\n    }\n}",
            "impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let iter = self.iter.as_slice().iter().map(Bucket::key_ref);\n        f.debug_list().entries(iter).finish()\n    }\n}",
            "impl<T> DoubleEndedIterator for Drain<'_, T> {\n    double_ended_iterator_methods!(Bucket::key);\n}",
            "impl<T> ExactSizeIterator for Drain<'_, T> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<T> FusedIterator for Drain<'_, T> {}",
            "impl<T> Iterator for Drain<'_, T> {\n    type Item = T;\n\n    iterator_methods!(Bucket::key);\n}"
        ],
        "set::iter::Intersection": [
            "impl<'a, T, S> Intersection<'a, T, S> {\n    pub(super) fn new<S1>(set: &'a IndexSet<T, S1>, other: &'a IndexSet<T, S>) -> Self {\n        Self {\n            iter: set.iter(),\n            other,\n        }\n    }\n}",
            "impl<'a, T, S> Iterator for Intersection<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        while let Some(item) = self.iter.next() {\n            if self.other.contains(item) {\n                return Some(item);\n            }\n        }\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.iter.size_hint().1)\n    }\n}",
            "impl<T, S> Clone for Intersection<'_, T, S> {\n    fn clone(&self) -> Self {\n        Intersection {\n            iter: self.iter.clone(),\n            ..*self\n        }\n    }\n}",
            "impl<T, S> DoubleEndedIterator for Intersection<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        while let Some(item) = self.iter.next_back() {\n            if self.other.contains(item) {\n                return Some(item);\n            }\n        }\n        None\n    }\n}",
            "impl<T, S> FusedIterator for Intersection<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}",
            "impl<T, S> fmt::Debug for Intersection<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"
        ],
        "set::iter::IntoIter": [
            "Clone",
            "impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let iter = self.iter.as_slice().iter().map(Bucket::key_ref);\n        f.debug_list().entries(iter).finish()\n    }\n}",
            "impl<T> Default for IntoIter<T> {\n    fn default() -> Self {\n        Self {\n            iter: Vec::new().into_iter(),\n        }\n    }\n}",
            "impl<T> DoubleEndedIterator for IntoIter<T> {\n    double_ended_iterator_methods!(Bucket::key);\n}",
            "impl<T> ExactSizeIterator for IntoIter<T> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<T> FusedIterator for IntoIter<T> {}",
            "impl<T> IntoIter<T> {\n    pub(super) fn new(entries: Vec<Bucket<T>>) -> Self {\n        Self {\n            iter: entries.into_iter(),\n        }\n    }\n\n    /// Returns a slice of the remaining entries in the iterator.\n    pub fn as_slice(&self) -> &Slice<T> {\n        Slice::from_slice(self.iter.as_slice())\n    }\n}",
            "impl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    iterator_methods!(Bucket::key);\n}"
        ],
        "set::iter::Iter": [
            "impl<'a, T> Iter<'a, T> {\n    pub(super) fn new(entries: &'a [Bucket<T>]) -> Self {\n        Self {\n            iter: entries.iter(),\n        }\n    }\n\n    /// Returns a slice of the remaining entries in the iterator.\n    pub fn as_slice(&self) -> &'a Slice<T> {\n        Slice::from_slice(self.iter.as_slice())\n    }\n}",
            "impl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    iterator_methods!(Bucket::key_ref);\n}",
            "impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}",
            "impl<T> Clone for Iter<'_, T> {\n    fn clone(&self) -> Self {\n        Iter {\n            iter: self.iter.clone(),\n        }\n    }\n}",
            "impl<T> Default for Iter<'_, T> {\n    fn default() -> Self {\n        Self { iter: [].iter() }\n    }\n}",
            "impl<T> DoubleEndedIterator for Iter<'_, T> {\n    double_ended_iterator_methods!(Bucket::key_ref);\n}",
            "impl<T> ExactSizeIterator for Iter<'_, T> {\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<T> FusedIterator for Iter<'_, T> {}"
        ],
        "set::iter::Splice": [
            "impl<'a, I, T, S> Splice<'a, I, T, S>\nwhere\n    I: Iterator<Item = T>,\n    T: Hash + Eq,\n    S: BuildHasher,\n{\n    #[track_caller]\n    pub(super) fn new<R>(set: &'a mut IndexSet<T, S>, range: R, replace_with: I) -> Self\n    where\n        R: RangeBounds<usize>,\n    {\n        Self {\n            iter: set.map.splice(range, UnitValue(replace_with)),\n        }\n    }\n}",
            "impl<I, T, S> DoubleEndedIterator for Splice<'_, I, T, S>\nwhere\n    I: Iterator<Item = T>,\n    T: Hash + Eq,\n    S: BuildHasher,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        Some(self.iter.next_back()?.0)\n    }\n}",
            "impl<I, T, S> ExactSizeIterator for Splice<'_, I, T, S>\nwhere\n    I: Iterator<Item = T>,\n    T: Hash + Eq,\n    S: BuildHasher,\n{\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}",
            "impl<I, T, S> FusedIterator for Splice<'_, I, T, S>\nwhere\n    I: Iterator<Item = T>,\n    T: Hash + Eq,\n    S: BuildHasher,\n{\n}",
            "impl<I, T, S> Iterator for Splice<'_, I, T, S>\nwhere\n    I: Iterator<Item = T>,\n    T: Hash + Eq,\n    S: BuildHasher,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        Some(self.iter.next()?.0)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}",
            "impl<I, T, S> fmt::Debug for Splice<'_, I, T, S>\nwhere\n    I: fmt::Debug + Iterator<Item = T>,\n    T: fmt::Debug + Hash + Eq,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.iter, f)\n    }\n}"
        ],
        "set::iter::SymmetricDifference": [
            "impl<'a, T, S1, S2> Iterator for SymmetricDifference<'a, T, S1, S2>\nwhere\n    T: Eq + Hash,\n    S1: BuildHasher,\n    S2: BuildHasher,\n{\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, f)\n    }\n}",
            "impl<'a, T, S1, S2> SymmetricDifference<'a, T, S1, S2>\nwhere\n    T: Eq + Hash,\n    S1: BuildHasher,\n    S2: BuildHasher,\n{\n    pub(super) fn new(set1: &'a IndexSet<T, S1>, set2: &'a IndexSet<T, S2>) -> Self {\n        let diff1 = set1.difference(set2);\n        let diff2 = set2.difference(set1);\n        Self {\n            iter: diff1.chain(diff2),\n        }\n    }\n}",
            "impl<T, S1, S2> Clone for SymmetricDifference<'_, T, S1, S2> {\n    fn clone(&self) -> Self {\n        SymmetricDifference {\n            iter: self.iter.clone(),\n        }\n    }\n}",
            "impl<T, S1, S2> DoubleEndedIterator for SymmetricDifference<'_, T, S1, S2>\nwhere\n    T: Eq + Hash,\n    S1: BuildHasher,\n    S2: BuildHasher,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back()\n    }\n\n    fn rfold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.rfold(init, f)\n    }\n}",
            "impl<T, S1, S2> FusedIterator for SymmetricDifference<'_, T, S1, S2>\nwhere\n    T: Eq + Hash,\n    S1: BuildHasher,\n    S2: BuildHasher,\n{\n}",
            "impl<T, S1, S2> fmt::Debug for SymmetricDifference<'_, T, S1, S2>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S1: BuildHasher,\n    S2: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"
        ],
        "set::iter::Union": [
            "impl<'a, T, S> Iterator for Union<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.iter.next()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, f)\n    }\n}",
            "impl<'a, T, S> Union<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    pub(super) fn new<S2>(set1: &'a IndexSet<T, S>, set2: &'a IndexSet<T, S2>) -> Self\n    where\n        S2: BuildHasher,\n    {\n        Self {\n            iter: set1.iter().chain(set2.difference(set1)),\n        }\n    }\n}",
            "impl<T, S> Clone for Union<'_, T, S> {\n    fn clone(&self) -> Self {\n        Union {\n            iter: self.iter.clone(),\n        }\n    }\n}",
            "impl<T, S> DoubleEndedIterator for Union<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.iter.next_back()\n    }\n\n    fn rfold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.rfold(init, f)\n    }\n}",
            "impl<T, S> FusedIterator for Union<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}",
            "impl<T, S> fmt::Debug for Union<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"
        ],
        "set::iter::UnitValue": [
            "impl<I: Iterator> Iterator for UnitValue<I> {\n    type Item = (I::Item, ());\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.next().map(|x| (x, ()))\n    }\n}",
            "impl<I: fmt::Debug> fmt::Debug for UnitValue<I> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.0, f)\n    }\n}"
        ],
        "set::slice::Slice": [
            "impl<T, U, const N: usize> PartialEq<[U; N]> for Slice<T>\nwhere\n    T: PartialEq<U>,\n{\n    fn eq(&self, other: &[U; N]) -> bool {\n        <Self as PartialEq<[U]>>::eq(self, other)\n    }\n}",
            "impl<T, U> PartialEq<Slice<U>> for Slice<T>\nwhere\n    T: PartialEq<U>,\n{\n    fn eq(&self, other: &Slice<U>) -> bool {\n        slice_eq(&self.entries, &other.entries, |b1, b2| b1.key == b2.key)\n    }\n}",
            "impl<T, U> PartialEq<[U]> for Slice<T>\nwhere\n    T: PartialEq<U>,\n{\n    fn eq(&self, other: &[U]) -> bool {\n        slice_eq(&self.entries, other, |b, o| b.key == *o)\n    }\n}",
            "impl<T: Eq> Eq for Slice<T> {}",
            "impl<T: Hash> Hash for Slice<T> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.len().hash(state);\n        for value in self {\n            value.hash(state);\n        }\n    }\n}",
            "impl<T: Ord> Ord for Slice<T> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.iter().cmp(other)\n    }\n}",
            "impl<T: PartialOrd> PartialOrd for Slice<T> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.iter().partial_cmp(other)\n    }\n}",
            "impl<T: fmt::Debug> fmt::Debug for Slice<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self).finish()\n    }\n}",
            "impl<T> Index<$range> for Slice<T> {\n            type Output = Self;\n\n            fn index(&self, range: $range) -> &Self::Output {\n                Slice::from_slice(&self.entries[range])\n            }\n        }",
            "impl<T> Index<usize> for Slice<T> {\n    type Output = T;\n\n    fn index(&self, index: usize) -> &Self::Output {\n        &self.entries[index].key\n    }\n}",
            "impl<T> Slice<T> {\n    pub(crate) fn into_entries(self: Box<Self>) -> Vec<Bucket<T>> {\n        self.into_boxed().into_vec()\n    }\n\n    /// Returns an empty slice.\n    pub const fn new<'a>() -> &'a Self {\n        Self::from_slice(&[])\n    }\n\n    /// Return the number of elements in the set slice.\n    pub const fn len(&self) -> usize {\n        self.entries.len()\n    }\n\n    /// Returns true if the set slice contains no elements.\n    pub const fn is_empty(&self) -> bool {\n        self.entries.is_empty()\n    }\n\n    /// Get a value by index.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    pub fn get_index(&self, index: usize) -> Option<&T> {\n        self.entries.get(index).map(Bucket::key_ref)\n    }\n\n    /// Returns a slice of values in the given range of indices.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    pub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Self> {\n        let range = try_simplify_range(range, self.entries.len())?;\n        self.entries.get(range).map(Self::from_slice)\n    }\n\n    /// Get the first value.\n    pub fn first(&self) -> Option<&T> {\n        self.entries.first().map(Bucket::key_ref)\n    }\n\n    /// Get the last value.\n    pub fn last(&self) -> Option<&T> {\n        self.entries.last().map(Bucket::key_ref)\n    }\n\n    /// Divides one slice into two at an index.\n    ///\n    /// ***Panics*** if `index > len`.\n    pub fn split_at(&self, index: usize) -> (&Self, &Self) {\n        let (first, second) = self.entries.split_at(index);\n        (Self::from_slice(first), Self::from_slice(second))\n    }\n\n    /// Returns the first value and the rest of the slice,\n    /// or `None` if it is empty.\n    pub fn split_first(&self) -> Option<(&T, &Self)> {\n        if let [first, rest @ ..] = &self.entries {\n            Some((&first.key, Self::from_slice(rest)))\n        } else {\n            None\n        }\n    }\n\n    /// Returns the last value and the rest of the slice,\n    /// or `None` if it is empty.\n    pub fn split_last(&self) -> Option<(&T, &Self)> {\n        if let [rest @ .., last] = &self.entries {\n            Some((&last.key, Self::from_slice(rest)))\n        } else {\n            None\n        }\n    }\n\n    /// Return an iterator over the values of the set slice.\n    pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(&self.entries)\n    }\n\n    /// Search over a sorted set for a value.\n    ///\n    /// Returns the position where that value is present, or the position where it can be inserted\n    /// to maintain the sort. See [`slice::binary_search`] for more details.\n    ///\n    /// Computes in **O(log(n))** time, which is notably less scalable than looking the value up in\n    /// the set this is a slice from using [`IndexSet::get_index_of`], but this can also position\n    /// missing values.\n    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n    where\n        T: Ord,\n    {\n        self.binary_search_by(|p| p.cmp(x))\n    }\n\n    /// Search over a sorted set with a comparator function.\n    ///\n    /// Returns the position where that value is present, or the position where it can be inserted\n    /// to maintain the sort. See [`slice::binary_search_by`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[inline]\n    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,\n    {\n        self.entries.binary_search_by(move |a| f(&a.key))\n    }\n\n    /// Search over a sorted set with an extraction function.\n    ///\n    /// Returns the position where that value is present, or the position where it can be inserted\n    /// to maintain the sort. See [`slice::binary_search_by_key`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[inline]\n    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> B,\n        B: Ord,\n    {\n        self.binary_search_by(|k| f(k).cmp(b))\n    }\n\n    /// Returns the index of the partition point of a sorted set according to the given predicate\n    /// (the index of the first element of the second partition).\n    ///\n    /// See [`slice::partition_point`] for more details.\n    ///\n    /// Computes in **O(log(n))** time.\n    #[must_use]\n    pub fn partition_point<P>(&self, mut pred: P) -> usize\n    where\n        P: FnMut(&T) -> bool,\n    {\n        self.entries.partition_point(move |a| pred(&a.key))\n    }\n}",
            "impl<T> Slice<T> {\n    pub(super) const fn from_slice(entries: &[Bucket<T>]) -> &Self {\n        unsafe { &*(entries as *const [Bucket<T>] as *const Self) }\n    }\n\n    pub(super) fn from_boxed(entries: Box<[Bucket<T>]>) -> Box<Self> {\n        unsafe { Box::from_raw(Box::into_raw(entries) as *mut Self) }\n    }\n\n    fn into_boxed(self: Box<Self>) -> Box<[Bucket<T>]> {\n        unsafe { Box::from_raw(Box::into_raw(self) as *mut [Bucket<T>]) }\n    }\n}"
        ]
    },
    "single_path_import": {
        "equivalent::Equivalent": "Equivalent",
        "map::IndexMap": "IndexMap",
        "map::core::entry::Entry": "map::Entry",
        "map::core::entry::IndexedEntry": "map::IndexedEntry",
        "map::core::entry::OccupiedEntry": "map::OccupiedEntry",
        "map::core::entry::VacantEntry": "map::VacantEntry",
        "map::core::raw_entry_v1": "map::raw_entry_v1",
        "map::core::raw_entry_v1::RawEntryApiV1": "map::RawEntryApiV1",
        "map::iter::Drain": "map::Drain",
        "map::iter::IntoIter": "map::IntoIter",
        "map::iter::IntoKeys": "map::IntoKeys",
        "map::iter::IntoValues": "map::IntoValues",
        "map::iter::Iter": "map::Iter",
        "map::iter::IterMut": "map::IterMut",
        "map::iter::IterMut2": "map::IterMut2",
        "map::iter::Keys": "map::Keys",
        "map::iter::Splice": "map::Splice",
        "map::iter::Values": "map::Values",
        "map::iter::ValuesMut": "map::ValuesMut",
        "map::mutable::MutableEntryKey": "map::MutableEntryKey",
        "map::mutable::MutableKeys": "map::MutableKeys",
        "map::slice::Slice": "map::Slice",
        "set::IndexSet": "IndexSet",
        "set::iter::Difference": "set::Difference",
        "set::iter::Drain": "set::Drain",
        "set::iter::Intersection": "set::Intersection",
        "set::iter::IntoIter": "set::IntoIter",
        "set::iter::Iter": "set::Iter",
        "set::iter::Splice": "set::Splice",
        "set::iter::SymmetricDifference": "set::SymmetricDifference",
        "set::iter::Union": "set::Union",
        "set::mutable::MutableValues": "set::MutableValues",
        "set::slice::Slice": "set::Slice"
    },
    "srcs": {
        "<&'a map::slice::Slice<K, V> as core::iter::IntoIterator>::into_iter": [
            "fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<&'a mut map::slice::Slice<K, V> as core::iter::IntoIterator>::into_iter": [
            "fn into_iter(self) -> Self::IntoIter{\n        self.iter_mut()\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<&'a set::slice::Slice<T> as core::iter::IntoIterator>::into_iter": [
            "fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<&map::slice::Slice<K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Slice::from_slice(&[])\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<&mut map::slice::Slice<K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Slice::from_mut_slice(&mut [])\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<&set::IndexSet<T, S1> as core::ops::BitAnd<&set::IndexSet<T, S2>>>::bitand": [
            "/// Returns the set intersection, cloned into a new set.\n///\n/// Values are collected in the same order that they appear in `self`.\nfn bitand(self, other: &IndexSet<T, S2>) -> Self::Output{\n        self.intersection(other).cloned().collect()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<&set::IndexSet<T, S1> as core::ops::BitOr<&set::IndexSet<T, S2>>>::bitor": [
            "/// Returns the set union, cloned into a new set.\n///\n/// Values from `self` are collected in their original order, followed by\n/// values that are unique to `other` in their original order.\nfn bitor(self, other: &IndexSet<T, S2>) -> Self::Output{\n        self.union(other).cloned().collect()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<&set::IndexSet<T, S1> as core::ops::BitXor<&set::IndexSet<T, S2>>>::bitxor": [
            "/// Returns the set symmetric-difference, cloned into a new set.\n///\n/// Values from `self` are collected in their original order, followed by\n/// values from `other` in their original order.\nfn bitxor(self, other: &IndexSet<T, S2>) -> Self::Output{\n        self.symmetric_difference(other).cloned().collect()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<&set::IndexSet<T, S1> as core::ops::Sub<&set::IndexSet<T, S2>>>::sub": [
            "/// Returns the set difference, cloned into a new set.\n///\n/// Values are collected in the same order that they appear in `self`.\nfn sub(self, other: &IndexSet<T, S2>) -> Self::Output{\n        self.difference(other).cloned().collect()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<&set::slice::Slice<T> as core::default::Default>::default": [
            "fn default() -> Self{\n        Slice::from_slice(&[])\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<Bucket<K, V> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        Bucket {\n            hash: self.hash,\n            key: self.key.clone(),\n            value: self.value.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "<Bucket<K, V> as core::clone::Clone>::clone_from": [
            "fn clone_from(&mut self, other: &Self){\n        self.hash = other.hash;\n        self.key.clone_from(&other.key);\n        self.value.clone_from(&other.value);\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "<GetDisjointMutError as core::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        let msg = match self {\n            GetDisjointMutError::IndexOutOfBounds => \"an index is out of bounds\",\n            GetDisjointMutError::OverlappingIndices => \"there were overlapping indices\",\n        };\n\n        core::fmt::Display::fmt(msg, f)\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "<TryReserveError as core::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        let reason = match &self.kind {\n            TryReserveErrorKind::Std(e) => return core::fmt::Display::fmt(e, f),\n            TryReserveErrorKind::CapacityOverflow => {\n                \" because the computed capacity exceeded the collection's maximum\"\n            }\n            TryReserveErrorKind::AllocError { .. } => {\n                \" because the memory allocator returned an error\"\n            }\n        };\n        f.write_str(\"memory allocation failed\")?;\n        f.write_str(reason)\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as Entries>::as_entries": [
            "#[inline]\nfn as_entries(&self) -> &[Self::Entry]{\n        self.core.as_entries()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as Entries>::as_entries_mut": [
            "#[inline]\nfn as_entries_mut(&mut self) -> &mut [Self::Entry]{\n        self.core.as_entries_mut()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as Entries>::into_entries": [
            "#[inline]\nfn into_entries(self) -> Vec<Self::Entry>{\n        self.core.into_entries()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as Entries>::with_entries": [
            "fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]),{\n        self.core.with_entries(f);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        IndexMap {\n            core: self.core.clone(),\n            hash_builder: self.hash_builder.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::clone::Clone>::clone_from": [
            "fn clone_from(&mut self, other: &Self){\n        self.core.clone_from(&other.core);\n        self.hash_builder.clone_from(&other.hash_builder);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::default::Default>::default": [
            "/// Return an empty [`IndexMap`]\nfn default() -> Self{\n        Self::with_capacity_and_hasher(0, S::default())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::fmt::Debug>::fmt": [
            "#[cfg(not(feature = \"test_debug\"))]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_map().entries(self.iter()).finish()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend": [
            "/// Extend the map with all key-value pairs in the iterable.\n///\n/// See the first extend method for more details.\nfn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iterable: I){\n        self.extend(iterable.into_iter().map(|(&key, &value)| (key, value)));\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::iter::Extend<(K, V)>>::extend": [
            "/// Extend the map with all key-value pairs in the iterable.\n///\n/// This is equivalent to calling [`insert`][IndexMap::insert] for each of\n/// them in order, which means that for keys that already existed\n/// in the map, their value is updated but it keeps the existing order.\n///\n/// New keys are inserted in the order they appear in the sequence. If\n/// equivalents of a key occur more than once, the last corresponding value\n/// prevails.\nfn extend<I: IntoIterator<Item = (K, V)>>(&mut self, iterable: I){\n        // (Note: this is a copy of `std`/`hashbrown`'s reservation logic.)\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let iter = iterable.into_iter();\n        let reserve = if self.is_empty() {\n            iter.size_hint().0\n        } else {\n            (iter.size_hint().0 + 1) / 2\n        };\n        self.reserve(reserve);\n        iter.for_each(move |(k, v)| {\n            self.insert(k, v);\n        });\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::iter::FromIterator<(K, V)>>::from_iter": [
            "/// Create an `IndexMap` from the sequence of key-value pairs in the\n/// iterable.\n///\n/// `from_iter` uses the same logic as `extend`. See\n/// [`extend`][IndexMap::extend] for more details.\nfn from_iter<I: IntoIterator<Item = (K, V)>>(iterable: I) -> Self{\n        let iter = iterable.into_iter();\n        let (low, _) = iter.size_hint();\n        let mut map = Self::with_capacity_and_hasher(low, <_>::default());\n        map.extend(iter);\n        map\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::ops::Index<&Q>>::index": [
            "/// Returns a reference to the value corresponding to the supplied `key`.\n///\n/// ***Panics*** if `key` is not present in the map.\nfn index(&self, key: &Q) -> &V{\n        self.get(key).expect(\"no entry found for key\")\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::ops::Index<usize>>::index": [
            "/// Returns a reference to the value at the supplied `index`.\n///\n/// ***Panics*** if `index` is out of bounds.\nfn index(&self, index: usize) -> &V{\n        self.get_index(index)\n            .unwrap_or_else(|| {\n                panic!(\n                    \"index out of bounds: the len is {len} but the index is {index}\",\n                    len = self.len()\n                );\n            })\n            .1\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::ops::IndexMut<&Q>>::index_mut": [
            "/// Returns a mutable reference to the value corresponding to the supplied `key`.\n///\n/// ***Panics*** if `key` is not present in the map.\nfn index_mut(&mut self, key: &Q) -> &mut V{\n        self.get_mut(key).expect(\"no entry found for key\")\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as core::ops::IndexMut<usize>>::index_mut": [
            "/// Returns a mutable reference to the value at the supplied `index`.\n///\n/// ***Panics*** if `index` is out of bounds.\nfn index_mut(&mut self, index: usize) -> &mut V{\n        let len: usize = self.len();\n\n        self.get_index_mut(index)\n            .unwrap_or_else(|| {\n                panic!(\"index out of bounds: the len is {len} but the index is {index}\");\n            })\n            .1\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as map::core::raw_entry_v1::RawEntryApiV1<K, V, S>>::raw_entry_mut_v1": [
            "fn raw_entry_mut_v1(&mut self) -> RawEntryBuilderMut<'_, K, V, S>{\n        RawEntryBuilderMut { map: self }\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as map::core::raw_entry_v1::RawEntryApiV1<K, V, S>>::raw_entry_v1": [
            "fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S>{\n        RawEntryBuilder { map: self }\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::get_full_mut2": [
            "fn get_full_mut2<Q>(&mut self, key: &Q) -> Option<(usize, &mut K, &mut V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &mut self.as_entries_mut()[i];\n            Some((i, &mut entry.key, &mut entry.value))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::get_index_mut2": [
            "fn get_index_mut2(&mut self, index: usize) -> Option<(&mut K, &mut V)>{\n        self.as_entries_mut().get_mut(index).map(Bucket::muts)\n    }",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::iter_mut2": [
            "fn iter_mut2(&mut self) -> IterMut2<'_, Self::Key, Self::Value>{\n        IterMut2::new(self.as_entries_mut())\n    }",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::retain2": [
            "fn retain2<F>(&mut self, keep: F)\n    where\n        F: FnMut(&mut K, &mut V) -> bool,{\n        self.core.retain_in_order(keep);\n    }",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "<map::IndexMap<K, V1, S1> as core::cmp::PartialEq<map::IndexMap<K, V2, S2>>>::eq": [
            "fn eq(&self, other: &IndexMap<K, V2, S2>) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter()\n            .all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::IndexMap<K, V> as core::convert::From<[(K, V); N]>>::from": [
            "/// # Examples\n///\n/// ```\n/// use indexmap::IndexMap;\n///\n/// let map1 = IndexMap::from([(1, 2), (3, 4)]);\n/// let map2: IndexMap<_, _> = [(1, 2), (3, 4)].into();\n/// assert_eq!(map1, map2);\n/// ```\nfn from(arr: [(K, V); N]) -> Self{\n        Self::from_iter(arr)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::as_entries": [
            "#[inline]\nfn as_entries(&self) -> &[Self::Entry]{\n        &self.entries\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::as_entries_mut": [
            "#[inline]\nfn as_entries_mut(&mut self) -> &mut [Self::Entry]{\n        &mut self.entries\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::into_entries": [
            "#[inline]\nfn into_entries(self) -> Vec<Self::Entry>{\n        self.entries\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::with_entries": [
            "fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]),{\n        f(&mut self.entries);\n        self.rebuild_hash_table();\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "<map::core::IndexMapCore<K, V> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        let mut new = Self::new();\n        new.clone_from(self);\n        new\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "<map::core::IndexMapCore<K, V> as core::clone::Clone>::clone_from": [
            "fn clone_from(&mut self, other: &Self){\n        self.indices.clone_from(&other.indices);\n        if self.entries.capacity() < other.entries.len() {\n            // If we must resize, match the indices capacity.\n            let additional = other.entries.len() - self.entries.len();\n            self.borrow_mut().reserve_entries(additional);\n        }\n        self.entries.clone_from(&other.entries);\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "<map::core::entry::Entry<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let mut tuple = f.debug_tuple(\"Entry\");\n        match self {\n            Entry::Vacant(v) => tuple.field(v),\n            Entry::Occupied(o) => tuple.field(o),\n        };\n        tuple.finish()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "<map::core::entry::Entry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "fn key_mut(&mut self) -> &mut Self::Key{\n        match self {\n            Entry::Occupied(e) => e.key_mut(),\n            Entry::Vacant(e) => e.key_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "<map::core::entry::IndexedEntry<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"IndexedEntry\")\n            .field(\"index\", &self.index)\n            .field(\"key\", self.key())\n            .field(\"value\", self.get())\n            .finish()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "<map::core::entry::IndexedEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "fn key_mut(&mut self) -> &mut Self::Key{\n        self.key_mut()\n    }",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "<map::core::entry::IndexedEntry<'a, K, V> as core::convert::From<map::core::entry::OccupiedEntry<'a, K, V>>>::from": [
            "fn from(other: OccupiedEntry<'a, K, V>) -> Self{\n        Self {\n            index: other.index(),\n            map: other.into_ref_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "<map::core::entry::OccupiedEntry<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"OccupiedEntry\")\n            .field(\"key\", self.key())\n            .field(\"value\", self.get())\n            .finish()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "<map::core::entry::OccupiedEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "fn key_mut(&mut self) -> &mut Self::Key{\n        self.key_mut()\n    }",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "<map::core::entry::OccupiedEntry<'a, K, V> as core::convert::From<map::core::entry::IndexedEntry<'a, K, V>>>::from": [
            "fn from(other: IndexedEntry<'a, K, V>) -> Self{\n        let IndexedEntry {\n            map: RefMut { indices, entries },\n            index,\n        } = other;\n        let hash = entries[index].hash;\n        Self {\n            entries,\n            index: indices\n                .find_entry(hash.get(), move |&i| i == index)\n                .expect(\"index not found\"),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "<map::core::entry::VacantEntry<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "<map::core::entry::VacantEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "fn key_mut(&mut self) -> &mut Self::Key{\n        self.key_mut()\n    }",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "<map::core::raw_entry_v1::RawEntryBuilder<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"RawEntryBuilder\").finish_non_exhaustive()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "<map::core::raw_entry_v1::RawEntryBuilderMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"RawEntryBuilderMut\").finish_non_exhaustive()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "<map::core::raw_entry_v1::RawEntryMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let mut tuple = f.debug_tuple(\"RawEntryMut\");\n        match self {\n            Self::Vacant(v) => tuple.field(v),\n            Self::Occupied(o) => tuple.field(o),\n        };\n        tuple.finish()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "<map::core::raw_entry_v1::RawOccupiedEntryMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"RawOccupiedEntryMut\")\n            .field(\"key\", self.key())\n            .field(\"value\", self.get())\n            .finish_non_exhaustive()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "<map::core::raw_entry_v1::RawVacantEntryMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"RawVacantEntryMut\").finish_non_exhaustive()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "<map::iter::Drain<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let iter = self.iter.as_slice().iter().map(Bucket::refs);\n        f.debug_list().entries(iter).finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self {\n            iter: Vec::new().into_iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let iter = self.iter.as_slice().iter().map(Bucket::refs);\n        f.debug_list().entries(iter).finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self {\n            iter: Vec::new().into_iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let iter = self.iter.as_slice().iter().map(Bucket::key_ref);\n        f.debug_list().entries(iter).finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self {\n            iter: Vec::new().into_iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let iter = self.iter.as_slice().iter().map(Bucket::value_ref);\n        f.debug_list().entries(iter).finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Iter<'_, K, V> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        Iter {\n            iter: self.iter.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Iter<'_, K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self { iter: [].iter() }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Iter<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Iter<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Iter<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Iter<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self {\n            iter: [].iter_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let iter = self.iter.as_slice().iter().map(Bucket::refs);\n        f.debug_list().entries(iter).finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut<'_, K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self {\n            iter: [].iter_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IterMut<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let iter = self.iter.as_slice().iter().map(Bucket::refs);\n        f.debug_list().entries(iter).finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Keys<'_, K, V> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        Keys {\n            iter: self.iter.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Keys<'_, K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self { iter: [].iter() }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Keys<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Keys<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Keys<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Keys<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Keys<'_, K, V> as core::ops::Index<usize>>::index": [
            "/// Returns a reference to the key at the supplied `index`.\n///\n/// ***Panics*** if `index` is out of bounds.\nfn index(&self, index: usize) -> &K{\n        &self.iter.as_slice()[index].key\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        // Follow `vec::Splice` in only printing the drain and replacement\n        f.debug_struct(\"Splice\")\n            .field(\"drain\", &self.drain)\n            .field(\"replace_with\", &self.replace_with)\n            .finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n        self.drain.next_back().map(Bucket::key_value)\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.drain.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        self.drain.next().map(Bucket::key_value)\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        self.drain.size_hint()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::ops::Drop>::drop": [
            "fn drop(&mut self){\n        // Finish draining unconsumed items. We don't strictly *have* to do this\n        // manually, since we already split it into separate memory, but it will\n        // match the drop order of `vec::Splice` items this way.\n        let _ = self.drain.nth(usize::MAX);\n\n        // Now insert all the new items. If a key matches an existing entry, it\n        // keeps the original position and only replaces the value, like `insert`.\n        while let Some((key, value)) = self.replace_with.next() {\n            // Since the tail is disjoint, we can try to update it first,\n            // or else insert (update or append) the primary map.\n            let hash = self.map.hash(&key);\n            if let Some(i) = self.tail.get_index_of(hash, &key) {\n                self.tail.as_entries_mut()[i].value = value;\n            } else {\n                self.map.core.insert_full(hash, key, value);\n            }\n        }\n\n        // Finally, re-append the tail\n        self.map.core.append_unchecked(&mut self.tail);\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Values<'_, K, V> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        Values {\n            iter: self.iter.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Values<'_, K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self { iter: [].iter() }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Values<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Values<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Values<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Values<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self {\n            iter: [].iter_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let iter = self.iter.as_slice().iter().map(Bucket::value_ref);\n        f.debug_list().entries(iter).finish()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::cmp::Ord>::cmp": [
            "fn cmp(&self, other: &Self) -> Ordering{\n        self.iter().cmp(other)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialEq<[(K2, V2); N]>>::eq": [
            "fn eq(&self, other: &[(K2, V2); N]) -> bool{\n        <Self as PartialEq<[_]>>::eq(self, other)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialEq<[(K2, V2)]>>::eq": [
            "fn eq(&self, other: &[(K2, V2)]) -> bool{\n        slice_eq(&self.entries, other, |b, t| b.key == t.0 && b.value == t.1)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialEq<map::slice::Slice<K2, V2>>>::eq": [
            "fn eq(&self, other: &Slice<K2, V2>) -> bool{\n        slice_eq(&self.entries, &other.entries, |b1, b2| {\n            b1.key == b2.key && b1.value == b2.value\n        })\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialOrd>::partial_cmp": [
            "fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        self.iter().partial_cmp(other)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self).finish()\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::hash::Hash>::hash": [
            "fn hash<H: Hasher>(&self, state: &mut H){\n        self.len().hash(state);\n        for (key, value) in self {\n            key.hash(state);\n            value.hash(state);\n        }\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index": [
            "fn index(&self, range: $range) -> &Self{\n                Self::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::Range<usize>>>::index": [
            "fn index(&self, range: $range) -> &Self{\n                Self::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeFrom<usize>>>::index": [
            "fn index(&self, range: $range) -> &Self{\n                Self::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeFull>>::index": [
            "fn index(&self, range: $range) -> &Self{\n                Self::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeInclusive<usize>>>::index": [
            "fn index(&self, range: $range) -> &Self{\n                Self::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeTo<usize>>>::index": [
            "fn index(&self, range: $range) -> &Self{\n                Self::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeToInclusive<usize>>>::index": [
            "fn index(&self, range: $range) -> &Self{\n                Self::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<usize>>::index": [
            "fn index(&self, index: usize) -> &V{\n        &self.entries[index].value\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self{\n                Self::from_mut_slice(&mut self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::Range<usize>>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self{\n                Self::from_mut_slice(&mut self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeFrom<usize>>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self{\n                Self::from_mut_slice(&mut self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeFull>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self{\n                Self::from_mut_slice(&mut self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeInclusive<usize>>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self{\n                Self::from_mut_slice(&mut self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeTo<usize>>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self{\n                Self::from_mut_slice(&mut self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeToInclusive<usize>>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self{\n                Self::from_mut_slice(&mut self.entries[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<usize>>::index_mut": [
            "fn index_mut(&mut self, index: usize) -> &mut V{\n        &mut self.entries[index].value\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "<set::IndexSet<T, S1> as core::cmp::PartialEq<set::IndexSet<T, S2>>>::eq": [
            "fn eq(&self, other: &IndexSet<T, S2>) -> bool{\n        self.len() == other.len() && self.is_subset(other)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as Entries>::as_entries": [
            "#[inline]\nfn as_entries(&self) -> &[Self::Entry]{\n        self.map.as_entries()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as Entries>::as_entries_mut": [
            "#[inline]\nfn as_entries_mut(&mut self) -> &mut [Self::Entry]{\n        self.map.as_entries_mut()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as Entries>::into_entries": [
            "#[inline]\nfn into_entries(self) -> Vec<Self::Entry>{\n        self.map.into_entries()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as Entries>::with_entries": [
            "fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]),{\n        self.map.with_entries(f);\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        IndexSet {\n            map: self.map.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as core::clone::Clone>::clone_from": [
            "fn clone_from(&mut self, other: &Self){\n        self.map.clone_from(&other.map);\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as core::default::Default>::default": [
            "/// Return an empty [`IndexSet`]\nfn default() -> Self{\n        IndexSet {\n            map: IndexMap::default(),\n        }\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as core::fmt::Debug>::fmt": [
            "#[cfg(not(feature = \"test_debug\"))]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_set().entries(self.iter()).finish()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as core::iter::Extend<&'a T>>::extend": [
            "fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iterable: I){\n        let iter = iterable.into_iter().copied();\n        self.extend(iter);\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as core::iter::Extend<T>>::extend": [
            "fn extend<I: IntoIterator<Item = T>>(&mut self, iterable: I){\n        let iter = iterable.into_iter().map(|x| (x, ()));\n        self.map.extend(iter);\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as core::iter::FromIterator<T>>::from_iter": [
            "fn from_iter<I: IntoIterator<Item = T>>(iterable: I) -> Self{\n        let iter = iterable.into_iter().map(|x| (x, ()));\n        IndexSet {\n            map: IndexMap::from_iter(iter),\n        }\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as core::ops::Index<usize>>::index": [
            "/// Returns a reference to the value at the supplied `index`.\n///\n/// ***Panics*** if `index` is out of bounds.\nfn index(&self, index: usize) -> &T{\n        self.get_index(index).unwrap_or_else(|| {\n            panic!(\n                \"index out of bounds: the len is {len} but the index is {index}\",\n                len = self.len()\n            );\n        })\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::IndexSet<T, S> as set::mutable::MutableValues>::get_full_mut2": [
            "fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut T)>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        match self.map.get_full_mut2(value) {\n            Some((index, value, ())) => Some((index, value)),\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/set/mutable.rs\"))"
        ],
        "<set::IndexSet<T, S> as set::mutable::MutableValues>::get_index_mut2": [
            "fn get_index_mut2(&mut self, index: usize) -> Option<&mut T>{\n        match self.map.get_index_mut2(index) {\n            Some((value, ())) => Some(value),\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/set/mutable.rs\"))"
        ],
        "<set::IndexSet<T, S> as set::mutable::MutableValues>::retain2": [
            "fn retain2<F>(&mut self, mut keep: F)\n    where\n        F: FnMut(&mut T) -> bool,{\n        self.map.retain2(move |value, ()| keep(value));\n    }",
            "Real(LocalPath(\"src/set/mutable.rs\"))"
        ],
        "<set::IndexSet<T> as core::convert::From<[T; N]>>::from": [
            "/// # Examples\n///\n/// ```\n/// use indexmap::IndexSet;\n///\n/// let set1 = IndexSet::from([1, 2, 3, 4]);\n/// let set2: IndexSet<_> = [1, 2, 3, 4].into();\n/// assert_eq!(set1, set2);\n/// ```\nfn from(arr: [T; N]) -> Self{\n        Self::from_iter(arr)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "<set::iter::Difference<'_, T, S> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        Difference {\n            iter: self.iter.clone(),\n            ..*self\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Difference<'_, T, S> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Difference<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n        while let Some(item) = self.iter.next_back() {\n            if !self.other.contains(item) {\n                return Some(item);\n            }\n        }\n        None\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Difference<'a, T, S> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        while let Some(item) = self.iter.next() {\n            if !self.other.contains(item) {\n                return Some(item);\n            }\n        }\n        None\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Difference<'a, T, S> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        (0, self.iter.size_hint().1)\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Drain<'_, T> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let iter = self.iter.as_slice().iter().map(Bucket::key_ref);\n        f.debug_list().entries(iter).finish()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Drain<'_, T> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Drain<'_, T> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Drain<'_, T> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Intersection<'_, T, S> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        Intersection {\n            iter: self.iter.clone(),\n            ..*self\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Intersection<'_, T, S> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Intersection<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n        while let Some(item) = self.iter.next_back() {\n            if self.other.contains(item) {\n                return Some(item);\n            }\n        }\n        None\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Intersection<'a, T, S> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        while let Some(item) = self.iter.next() {\n            if self.other.contains(item) {\n                return Some(item);\n            }\n        }\n        None\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Intersection<'a, T, S> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        (0, self.iter.size_hint().1)\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self {\n            iter: Vec::new().into_iter(),\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let iter = self.iter.as_slice().iter().map(Bucket::key_ref);\n        f.debug_list().entries(iter).finish()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Iter<'_, T> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        Iter {\n            iter: self.iter.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Iter<'_, T> as core::default::Default>::default": [
            "fn default() -> Self{\n        Self { iter: [].iter() }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Iter<'_, T> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Iter<'_, T> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n            self.iter.next_back().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Iter<'_, T> as core::iter::DoubleEndedIterator>::nth_back": [
            "fn nth_back(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth_back(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Iter<'_, T> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::collect": [
            "fn collect<C>(self) -> C\n        where\n            C: FromIterator<Self::Item>,{\n            // NB: forwarding this directly to standard iterators will\n            // allow it to leverage unstable traits like `TrustedLen`.\n            self.iter.map($map_elt).collect()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::count": [
            "fn count(self) -> usize{\n            self.iter.len()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::last": [
            "fn last(mut self) -> Option<Self::Item>{\n            self.next_back()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n            self.iter.next().map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n            self.iter.nth(n).map($map_elt)\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n            self.iter.size_hint()\n        }",
            "Real(LocalPath(\"src/macros.rs\"))"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Debug::fmt(&self.iter, f)\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n        Some(self.iter.next_back()?.0)\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::ExactSizeIterator>::len": [
            "fn len(&self) -> usize{\n        self.iter.len()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        Some(self.iter.next()?.0)\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        SymmetricDifference {\n            iter: self.iter.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n        self.iter.next_back()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::iter::DoubleEndedIterator>::rfold": [
            "fn rfold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.rfold(init, f)\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::fold": [
            "fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.fold(init, f)\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Union<'_, T, S> as core::clone::Clone>::clone": [
            "fn clone(&self) -> Self{\n        Union {\n            iter: self.iter.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Union<'_, T, S> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Union<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n        self.iter.next_back()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Union<'_, T, S> as core::iter::DoubleEndedIterator>::rfold": [
            "fn rfold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.rfold(init, f)\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Union<'a, T, S> as core::iter::Iterator>::fold": [
            "fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.fold(init, f)\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Union<'a, T, S> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        self.iter.next()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::Union<'a, T, S> as core::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::UnitValue<I> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Debug::fmt(&self.0, f)\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::iter::UnitValue<I> as core::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        self.0.next().map(|x| (x, ()))\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "<set::slice::Slice<T> as core::cmp::Ord>::cmp": [
            "fn cmp(&self, other: &Self) -> Ordering{\n        self.iter().cmp(other)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialEq<[U; N]>>::eq": [
            "fn eq(&self, other: &[U; N]) -> bool{\n        <Self as PartialEq<[U]>>::eq(self, other)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialEq<[U]>>::eq": [
            "fn eq(&self, other: &[U]) -> bool{\n        slice_eq(&self.entries, other, |b, o| b.key == *o)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialEq<set::slice::Slice<U>>>::eq": [
            "fn eq(&self, other: &Slice<U>) -> bool{\n        slice_eq(&self.entries, &other.entries, |b1, b2| b1.key == b2.key)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialOrd>::partial_cmp": [
            "fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n        self.iter().partial_cmp(other)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self).finish()\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::hash::Hash>::hash": [
            "fn hash<H: Hasher>(&self, state: &mut H){\n        self.len().hash(state);\n        for value in self {\n            value.hash(state);\n        }\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::Range<usize>>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeFrom<usize>>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeFull>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeInclusive<usize>>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeTo<usize>>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeToInclusive<usize>>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.entries[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "<set::slice::Slice<T> as core::ops::Index<usize>>::index": [
            "fn index(&self, index: usize) -> &Self::Output{\n        &self.entries[index].key\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "Bucket": [
            "struct Bucket<K, V> {\n    hash: HashValue,\n    key: K,\n    value: V,\n}",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Bucket::<K, V>::key": [
            "fn key(self) -> K{\n        self.key\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Bucket::<K, V>::key_ref": [
            "fn key_ref(&self) -> &K{\n        &self.key\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Bucket::<K, V>::key_value": [
            "fn key_value(self) -> (K, V){\n        (self.key, self.value)\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Bucket::<K, V>::muts": [
            "fn muts(&mut self) -> (&mut K, &mut V){\n        (&mut self.key, &mut self.value)\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Bucket::<K, V>::ref_mut": [
            "fn ref_mut(&mut self) -> (&K, &mut V){\n        (&self.key, &mut self.value)\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Bucket::<K, V>::refs": [
            "fn refs(&self) -> (&K, &V){\n        (&self.key, &self.value)\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Bucket::<K, V>::value": [
            "fn value(self) -> V{\n        self.value\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Bucket::<K, V>::value_mut": [
            "fn value_mut(&mut self) -> &mut V{\n        &mut self.value\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Bucket::<K, V>::value_ref": [
            "fn value_ref(&self) -> &V{\n        &self.value\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Entries": [
            "trait Entries {\n    type Entry;\n    fn into_entries(self) -> Vec<Self::Entry>;\n    fn as_entries(&self) -> &[Self::Entry];\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry];\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]);\n}",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "GetDisjointMutError": [
            "/// The error type returned by [`get_disjoint_indices_mut`][`IndexMap::get_disjoint_indices_mut`].\n///\n/// It indicates one of two possible errors:\n/// - An index is out-of-bounds.\n/// - The same index appeared multiple times in the array.\npub enum GetDisjointMutError {\n    /// An index provided was out-of-bounds for the slice.\n    IndexOutOfBounds,\n    /// Two indices provided were overlapping.\n    OverlappingIndices,\n}",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "HashValue": [
            "/// Hash value newtype. Not larger than usize, since anything larger\n/// isn't used for selecting position anyway.\nstruct HashValue(usize);",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "HashValue::get": [
            "#[inline(always)]\nfn get(self) -> u64{\n        self.0 as u64\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "TryReserveError": [
            "/// The error type for [`try_reserve`][IndexMap::try_reserve] methods.\npub struct TryReserveError {\n    kind: TryReserveErrorKind,\n}",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "TryReserveError::from_alloc": [
            "fn from_alloc(error: alloc::collections::TryReserveError) -> Self{\n        Self {\n            kind: TryReserveErrorKind::Std(error),\n        }\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "TryReserveError::from_hashbrown": [
            "fn from_hashbrown(error: hashbrown::TryReserveError) -> Self{\n        Self {\n            kind: match error {\n                hashbrown::TryReserveError::CapacityOverflow => {\n                    TryReserveErrorKind::CapacityOverflow\n                }\n                hashbrown::TryReserveError::AllocError { layout } => {\n                    TryReserveErrorKind::AllocError { layout }\n                }\n            },\n        }\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "TryReserveErrorKind": [
            "enum TryReserveErrorKind {\n    // The standard library's kind is currently opaque to us, otherwise we could unify this.\n    Std(alloc::collections::TryReserveError),\n    CapacityOverflow,\n    AllocError { layout: alloc::alloc::Layout },\n}",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "map::IndexMap": [
            "/// A hash table where the iteration order of the key-value pairs is independent\n/// of the hash values of the keys.\n///\n/// The interface is closely compatible with the standard\n/// [`HashMap`][std::collections::HashMap],\n/// but also has additional features.\n///\n/// # Order\n///\n/// The key-value pairs have a consistent order that is determined by\n/// the sequence of insertion and removal calls on the map. The order does\n/// not depend on the keys or the hash function at all.\n///\n/// All iterators traverse the map in *the order*.\n///\n/// The insertion order is preserved, with **notable exceptions** like the\n/// [`.remove()`][Self::remove] or [`.swap_remove()`][Self::swap_remove] methods.\n/// Methods such as [`.sort_by()`][Self::sort_by] of\n/// course result in a new order, depending on the sorting order.\n///\n/// # Indices\n///\n/// The key-value pairs are indexed in a compact range without holes in the\n/// range `0..self.len()`. For example, the method `.get_full` looks up the\n/// index for a key, and the method `.get_index` looks up the key-value pair by\n/// index.\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexMap;\n///\n/// // count the frequency of each letter in a sentence.\n/// let mut letters = IndexMap::new();\n/// for ch in \"a short treatise on fungi\".chars() {\n///     *letters.entry(ch).or_insert(0) += 1;\n/// }\n///\n/// assert_eq!(letters[&'s'], 2);\n/// assert_eq!(letters[&'t'], 3);\n/// assert_eq!(letters[&'u'], 1);\n/// assert_eq!(letters.get(&'y'), None);\n/// ```\n#[cfg(feature = \"std\")]\npub struct IndexMap<K, V, S = RandomState> {\n    pub(crate) core: IndexMapCore<K, V>,\n    hash_builder: S,\n}",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::append": [
            "/// Moves all key-value pairs from `other` into `self`, leaving `other` empty.\n///\n/// This is equivalent to calling [`insert`][Self::insert] for each\n/// key-value pair from `other` in order, which means that for keys that\n/// already exist in `self`, their value is updated in the current position.\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexMap;\n///\n/// // Note: Key (3) is present in both maps.\n/// let mut a = IndexMap::from([(3, \"c\"), (2, \"b\"), (1, \"a\")]);\n/// let mut b = IndexMap::from([(3, \"d\"), (4, \"e\"), (5, \"f\")]);\n/// let old_capacity = b.capacity();\n///\n/// a.append(&mut b);\n///\n/// assert_eq!(a.len(), 5);\n/// assert_eq!(b.len(), 0);\n/// assert_eq!(b.capacity(), old_capacity);\n///\n/// assert!(a.keys().eq(&[3, 2, 1, 4, 5]));\n/// assert_eq!(a[&3], \"d\"); // \"c\" was overwritten.\n/// ```\npub fn append<S2>(&mut self, other: &mut IndexMap<K, V, S2>){\n        self.extend(other.drain(..));\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::as_mut_slice": [
            "/// Returns a mutable slice of all the key-value pairs in the map.\n///\n/// Computes in **O(1)** time.\npub fn as_mut_slice(&mut self) -> &mut Slice<K, V>{\n        Slice::from_mut_slice(self.as_entries_mut())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::as_slice": [
            "/// Returns a slice of all the key-value pairs in the map.\n///\n/// Computes in **O(1)** time.\npub fn as_slice(&self) -> &Slice<K, V>{\n        Slice::from_slice(self.as_entries())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::binary_search_by": [
            "/// Search over a sorted map with a comparator function.\n///\n/// Returns the position where that value is present, or the position where it can be inserted\n/// to maintain the sort. See [`slice::binary_search_by`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[inline]\npub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a K, &'a V) -> Ordering,{\n        self.as_slice().binary_search_by(f)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::binary_search_by_key": [
            "/// Search over a sorted map with an extraction function.\n///\n/// Returns the position where that value is present, or the position where it can be inserted\n/// to maintain the sort. See [`slice::binary_search_by_key`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[inline]\npub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a K, &'a V) -> B,\n        B: Ord,{\n        self.as_slice().binary_search_by_key(b, f)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::binary_search_keys": [
            "/// Search over a sorted map for a key.\n///\n/// Returns the position where that key is present, or the position where it can be inserted to\n/// maintain the sort. See [`slice::binary_search`] for more details.\n///\n/// Computes in **O(log(n))** time, which is notably less scalable than looking the key up\n/// using [`get_index_of`][IndexMap::get_index_of], but this can also position missing keys.\npub fn binary_search_keys(&self, x: &K) -> Result<usize, usize>\n    where\n        K: Ord,{\n        self.as_slice().binary_search_keys(x)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::capacity": [
            "/// Return the number of elements the map can hold without reallocating.\n///\n/// This number is a lower bound; the map might be able to hold more,\n/// but is guaranteed to be able to hold at least this many.\n///\n/// Computes in **O(1)** time.\npub fn capacity(&self) -> usize{\n        self.core.capacity()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::clear": [
            "/// Remove all key-value pairs in the map, while preserving its capacity.\n///\n/// Computes in **O(n)** time.\npub fn clear(&mut self){\n        self.core.clear();\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::contains_key": [
            "/// Return `true` if an equivalent to `key` exists in the map.\n///\n/// Computes in **O(1)** time (average).\npub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        self.get_index_of(key).is_some()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::drain": [
            "/// Clears the `IndexMap` in the given index range, returning those\n/// key-value pairs as a drain iterator.\n///\n/// The range may be any type that implements [`RangeBounds<usize>`],\n/// including all of the `std::ops::Range*` types, or even a tuple pair of\n/// `Bound` start and end values. To drain the map entirely, use `RangeFull`\n/// like `map.drain(..)`.\n///\n/// This shifts down all entries following the drained range to fill the\n/// gap, and keeps the allocated memory for reuse.\n///\n/// ***Panics*** if the starting point is greater than the end point or if\n/// the end point is greater than the length of the map.\n#[track_caller]\npub fn drain<R>(&mut self, range: R) -> Drain<'_, K, V>\n    where\n        R: RangeBounds<usize>,{\n        Drain::new(self.core.drain(range))\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::entry": [
            "/// Get the given keys corresponding entry in the map for insertion and/or\n/// in-place manipulation.\n///\n/// Computes in **O(1)** time (amortized average).\npub fn entry(&mut self, key: K) -> Entry<'_, K, V>{\n        let hash = self.hash(&key);\n        self.core.entry(hash, key)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::first": [
            "/// Get the first key-value pair\n///\n/// Computes in **O(1)** time.\n#[doc(alias = \"first_key_value\")]\npub fn first(&self) -> Option<(&K, &V)>{\n        self.as_entries().first().map(Bucket::refs)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::first_entry": [
            "/// Get the first entry in the map for in-place manipulation.\n///\n/// Computes in **O(1)** time.\npub fn first_entry(&mut self) -> Option<IndexedEntry<'_, K, V>>{\n        self.get_index_entry(0)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::first_mut": [
            "/// Get the first key-value pair, with mutable access to the value\n///\n/// Computes in **O(1)** time.\npub fn first_mut(&mut self) -> Option<(&K, &mut V)>{\n        self.as_entries_mut().first_mut().map(Bucket::ref_mut)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get": [
            "/// Return a reference to the value stored for `key`, if it is present,\n/// else `None`.\n///\n/// Computes in **O(1)** time (average).\npub fn get<Q>(&self, key: &Q) -> Option<&V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &self.as_entries()[i];\n            Some(&entry.value)\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_disjoint_indices_mut": [
            "/// Get an array of `N` key-value pairs by `N` indices\n///\n/// Valid indices are *0 <= index < self.len()* and each index needs to be unique.\n///\n/// # Examples\n///\n/// ```\n/// let mut map = indexmap::IndexMap::from([(1, 'a'), (3, 'b'), (2, 'c')]);\n/// assert_eq!(map.get_disjoint_indices_mut([2, 0]), Ok([(&2, &mut 'c'), (&1, &mut 'a')]));\n/// ```\npub fn get_disjoint_indices_mut<const N: usize>(\n        &mut self,\n        indices: [usize; N],\n    ) -> Result<[(&K, &mut V); N], GetDisjointMutError>{\n        self.as_mut_slice().get_disjoint_mut(indices)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_disjoint_mut": [
            "/// Return the values for `N` keys. If any key is duplicated, this function will panic.\n///\n/// # Examples\n///\n/// ```\n/// let mut map = indexmap::IndexMap::from([(1, 'a'), (3, 'b'), (2, 'c')]);\n/// assert_eq!(map.get_disjoint_mut([&2, &1]), [Some(&mut 'c'), Some(&mut 'a')]);\n/// ```\npub fn get_disjoint_mut<Q, const N: usize>(&mut self, keys: [&Q; N]) -> [Option<&mut V>; N]\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        let indices = keys.map(|key| self.get_index_of(key));\n        match self.as_mut_slice().get_disjoint_opt_mut(indices) {\n            Err(GetDisjointMutError::IndexOutOfBounds) => {\n                unreachable!(\n                    \"Internal error: indices should never be OOB as we got them from get_index_of\"\n                );\n            }\n            Err(GetDisjointMutError::OverlappingIndices) => {\n                panic!(\"duplicate keys found\");\n            }\n            Ok(key_values) => key_values.map(|kv_opt| kv_opt.map(|kv| kv.1)),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_full": [
            "/// Return item index, key and value\npub fn get_full<Q>(&self, key: &Q) -> Option<(usize, &K, &V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &self.as_entries()[i];\n            Some((i, &entry.key, &entry.value))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_full_mut": [
            "pub fn get_full_mut<Q>(&mut self, key: &Q) -> Option<(usize, &K, &mut V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &mut self.as_entries_mut()[i];\n            Some((i, &entry.key, &mut entry.value))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_index": [
            "/// Get a key-value pair by index\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Computes in **O(1)** time.\npub fn get_index(&self, index: usize) -> Option<(&K, &V)>{\n        self.as_entries().get(index).map(Bucket::refs)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_index_entry": [
            "/// Get an entry in the map by index for in-place manipulation.\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Computes in **O(1)** time.\npub fn get_index_entry(&mut self, index: usize) -> Option<IndexedEntry<'_, K, V>>{\n        if index >= self.len() {\n            return None;\n        }\n        Some(IndexedEntry::new(&mut self.core, index))\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_index_mut": [
            "/// Get a key-value pair by index\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Computes in **O(1)** time.\npub fn get_index_mut(&mut self, index: usize) -> Option<(&K, &mut V)>{\n        self.as_entries_mut().get_mut(index).map(Bucket::ref_mut)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_index_of": [
            "/// Return item index, if it exists in the map\n///\n/// Computes in **O(1)** time (average).\npub fn get_index_of<Q>(&self, key: &Q) -> Option<usize>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        match self.as_entries() {\n            [] => None,\n            [x] => key.equivalent(&x.key).then_some(0),\n            _ => {\n                let hash = self.hash(key);\n                self.core.get_index_of(hash, key)\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_key_value": [
            "/// Return references to the key-value pair stored for `key`,\n/// if it is present, else `None`.\n///\n/// Computes in **O(1)** time (average).\npub fn get_key_value<Q>(&self, key: &Q) -> Option<(&K, &V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &self.as_entries()[i];\n            Some((&entry.key, &entry.value))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_mut": [
            "pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        if let Some(i) = self.get_index_of(key) {\n            let entry = &mut self.as_entries_mut()[i];\n            Some(&mut entry.value)\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_range": [
            "/// Returns a slice of key-value pairs in the given range of indices.\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Computes in **O(1)** time.\npub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Slice<K, V>>{\n        let entries = self.as_entries();\n        let range = try_simplify_range(range, entries.len())?;\n        entries.get(range).map(Slice::from_slice)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::get_range_mut": [
            "/// Returns a mutable slice of key-value pairs in the given range of indices.\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Computes in **O(1)** time.\npub fn get_range_mut<R: RangeBounds<usize>>(&mut self, range: R) -> Option<&mut Slice<K, V>>{\n        let entries = self.as_entries_mut();\n        let range = try_simplify_range(range, entries.len())?;\n        entries.get_mut(range).map(Slice::from_mut_slice)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::hash": [
            "pub(crate) fn hash<Q: ?Sized + Hash>(&self, key: &Q) -> HashValue{\n        let mut h = self.hash_builder.build_hasher();\n        key.hash(&mut h);\n        HashValue(h.finish() as usize)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::hasher": [
            "/// Return a reference to the map's `BuildHasher`.\npub fn hasher(&self) -> &S{\n        &self.hash_builder\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::insert": [
            "/// Insert a key-value pair in the map.\n///\n/// If an equivalent key already exists in the map: the key remains and\n/// retains in its place in the order, its corresponding value is updated\n/// with `value`, and the older value is returned inside `Some(_)`.\n///\n/// If no equivalent key existed in the map: the new key-value pair is\n/// inserted, last in order, and `None` is returned.\n///\n/// Computes in **O(1)** time (amortized average).\n///\n/// See also [`entry`][Self::entry] if you want to insert *or* modify,\n/// or [`insert_full`][Self::insert_full] if you need to get the index of\n/// the corresponding key-value pair.\npub fn insert(&mut self, key: K, value: V) -> Option<V>{\n        self.insert_full(key, value).1\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::insert_before": [
            "/// Insert a key-value pair in the map before the entry at the given index, or at the end.\n///\n/// If an equivalent key already exists in the map: the key remains and\n/// is moved to the new position in the map, its corresponding value is updated\n/// with `value`, and the older value is returned inside `Some(_)`. The returned index\n/// will either be the given index or one less, depending on how the entry moved.\n/// (See [`shift_insert`](Self::shift_insert) for different behavior here.)\n///\n/// If no equivalent key existed in the map: the new key-value pair is\n/// inserted exactly at the given index, and `None` is returned.\n///\n/// ***Panics*** if `index` is out of bounds.\n/// Valid indices are `0..=map.len()` (inclusive).\n///\n/// Computes in **O(n)** time (average).\n///\n/// See also [`entry`][Self::entry] if you want to insert *or* modify,\n/// perhaps only using the index for new entries with [`VacantEntry::shift_insert`].\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexMap;\n/// let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n///\n/// // The new key '*' goes exactly at the given index.\n/// assert_eq!(map.get_index_of(&'*'), None);\n/// assert_eq!(map.insert_before(10, '*', ()), (10, None));\n/// assert_eq!(map.get_index_of(&'*'), Some(10));\n///\n/// // Moving the key 'a' up will shift others down, so this moves *before* 10 to index 9.\n/// assert_eq!(map.insert_before(10, 'a', ()), (9, Some(())));\n/// assert_eq!(map.get_index_of(&'a'), Some(9));\n/// assert_eq!(map.get_index_of(&'*'), Some(10));\n///\n/// // Moving the key 'z' down will shift others up, so this moves to exactly 10.\n/// assert_eq!(map.insert_before(10, 'z', ()), (10, Some(())));\n/// assert_eq!(map.get_index_of(&'z'), Some(10));\n/// assert_eq!(map.get_index_of(&'*'), Some(11));\n///\n/// // Moving or inserting before the endpoint is also valid.\n/// assert_eq!(map.len(), 27);\n/// assert_eq!(map.insert_before(map.len(), '*', ()), (26, Some(())));\n/// assert_eq!(map.get_index_of(&'*'), Some(26));\n/// assert_eq!(map.insert_before(map.len(), '+', ()), (27, None));\n/// assert_eq!(map.get_index_of(&'+'), Some(27));\n/// assert_eq!(map.len(), 28);\n/// ```\n#[track_caller]\npub fn insert_before(&mut self, mut index: usize, key: K, value: V) -> (usize, Option<V>){\n        let len = self.len();\n\n        assert!(\n            index <= len,\n            \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"\n        );\n\n        match self.entry(key) {\n            Entry::Occupied(mut entry) => {\n                if index > entry.index() {\n                    // Some entries will shift down when this one moves up,\n                    // so \"insert before index\" becomes \"move to index - 1\",\n                    // keeping the entry at the original index unmoved.\n                    index -= 1;\n                }\n                let old = mem::replace(entry.get_mut(), value);\n                entry.move_index(index);\n                (index, Some(old))\n            }\n            Entry::Vacant(entry) => {\n                entry.shift_insert(index, value);\n                (index, None)\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::insert_full": [
            "/// Insert a key-value pair in the map, and get their index.\n///\n/// If an equivalent key already exists in the map: the key remains and\n/// retains in its place in the order, its corresponding value is updated\n/// with `value`, and the older value is returned inside `(index, Some(_))`.\n///\n/// If no equivalent key existed in the map: the new key-value pair is\n/// inserted, last in order, and `(index, None)` is returned.\n///\n/// Computes in **O(1)** time (amortized average).\n///\n/// See also [`entry`][Self::entry] if you want to insert *or* modify.\npub fn insert_full(&mut self, key: K, value: V) -> (usize, Option<V>){\n        let hash = self.hash(&key);\n        self.core.insert_full(hash, key, value)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::insert_sorted": [
            "/// Insert a key-value pair in the map at its ordered position among sorted keys.\n///\n/// This is equivalent to finding the position with\n/// [`binary_search_keys`][Self::binary_search_keys], then either updating\n/// it or calling [`insert_before`][Self::insert_before] for a new key.\n///\n/// If the sorted key is found in the map, its corresponding value is\n/// updated with `value`, and the older value is returned inside\n/// `(index, Some(_))`. Otherwise, the new key-value pair is inserted at\n/// the sorted position, and `(index, None)` is returned.\n///\n/// If the existing keys are **not** already sorted, then the insertion\n/// index is unspecified (like [`slice::binary_search`]), but the key-value\n/// pair is moved to or inserted at that position regardless.\n///\n/// Computes in **O(n)** time (average). Instead of repeating calls to\n/// `insert_sorted`, it may be faster to call batched [`insert`][Self::insert]\n/// or [`extend`][Self::extend] and only call [`sort_keys`][Self::sort_keys]\n/// or [`sort_unstable_keys`][Self::sort_unstable_keys] once.\npub fn insert_sorted(&mut self, key: K, value: V) -> (usize, Option<V>)\n    where\n        K: Ord,{\n        match self.binary_search_keys(&key) {\n            Ok(i) => (i, Some(mem::replace(&mut self[i], value))),\n            Err(i) => self.insert_before(i, key, value),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::into_boxed_slice": [
            "/// Converts into a boxed slice of all the key-value pairs in the map.\n///\n/// Note that this will drop the inner hash table and any excess capacity.\npub fn into_boxed_slice(self) -> Box<Slice<K, V>>{\n        Slice::from_boxed(self.into_entries().into_boxed_slice())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::into_keys": [
            "/// Return an owning iterator over the keys of the map, in their order\npub fn into_keys(self) -> IntoKeys<K, V>{\n        IntoKeys::new(self.into_entries())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::into_values": [
            "/// Return an owning iterator over the values of the map, in their order\npub fn into_values(self) -> IntoValues<K, V>{\n        IntoValues::new(self.into_entries())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::is_empty": [
            "/// Returns true if the map contains no elements.\n///\n/// Computes in **O(1)** time.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::iter": [
            "/// Return an iterator over the key-value pairs of the map, in their order\npub fn iter(&self) -> Iter<'_, K, V>{\n        Iter::new(self.as_entries())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::iter_mut": [
            "/// Return an iterator over the key-value pairs of the map, in their order\npub fn iter_mut(&mut self) -> IterMut<'_, K, V>{\n        IterMut::new(self.as_entries_mut())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::keys": [
            "/// Return an iterator over the keys of the map, in their order\npub fn keys(&self) -> Keys<'_, K, V>{\n        Keys::new(self.as_entries())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::last": [
            "/// Get the last key-value pair\n///\n/// Computes in **O(1)** time.\n#[doc(alias = \"last_key_value\")]\npub fn last(&self) -> Option<(&K, &V)>{\n        self.as_entries().last().map(Bucket::refs)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::last_entry": [
            "/// Get the last entry in the map for in-place manipulation.\n///\n/// Computes in **O(1)** time.\npub fn last_entry(&mut self) -> Option<IndexedEntry<'_, K, V>>{\n        self.get_index_entry(self.len().checked_sub(1)?)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::last_mut": [
            "/// Get the last key-value pair, with mutable access to the value\n///\n/// Computes in **O(1)** time.\npub fn last_mut(&mut self) -> Option<(&K, &mut V)>{\n        self.as_entries_mut().last_mut().map(Bucket::ref_mut)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::len": [
            "/// Return the number of key-value pairs in the map.\n///\n/// Computes in **O(1)** time.\n#[inline]\npub fn len(&self) -> usize{\n        self.core.len()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::move_index": [
            "/// Moves the position of a key-value pair from one index to another\n/// by shifting all other pairs in-between.\n///\n/// * If `from < to`, the other pairs will shift down while the targeted pair moves up.\n/// * If `from > to`, the other pairs will shift up while the targeted pair moves down.\n///\n/// ***Panics*** if `from` or `to` are out of bounds.\n///\n/// Computes in **O(n)** time (average).\n#[track_caller]\npub fn move_index(&mut self, from: usize, to: usize){\n        self.core.move_index(from, to)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::partition_point": [
            "/// Returns the index of the partition point of a sorted map according to the given predicate\n/// (the index of the first element of the second partition).\n///\n/// See [`slice::partition_point`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[must_use]\npub fn partition_point<P>(&self, pred: P) -> usize\n    where\n        P: FnMut(&K, &V) -> bool,{\n        self.as_slice().partition_point(pred)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::pop": [
            "/// Remove the last key-value pair\n///\n/// This preserves the order of the remaining elements.\n///\n/// Computes in **O(1)** time (average).\n#[doc(alias = \"pop_last\")]\npub fn pop(&mut self) -> Option<(K, V)>{\n        self.core.pop()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::remove": [
            "/// Remove the key-value pair equivalent to `key` and return\n/// its value.\n///\n/// **NOTE:** This is equivalent to [`.swap_remove(key)`][Self::swap_remove], replacing this\n/// entry's position with the last element, and it is deprecated in favor of calling that\n/// explicitly. If you need to preserve the relative order of the keys in the map, use\n/// [`.shift_remove(key)`][Self::shift_remove] instead.\n#[deprecated(note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\")]\npub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        self.swap_remove(key)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::remove_entry": [
            "/// Remove and return the key-value pair equivalent to `key`.\n///\n/// **NOTE:** This is equivalent to [`.swap_remove_entry(key)`][Self::swap_remove_entry],\n/// replacing this entry's position with the last element, and it is deprecated in favor of\n/// calling that explicitly. If you need to preserve the relative order of the keys in the map,\n/// use [`.shift_remove_entry(key)`][Self::shift_remove_entry] instead.\n#[deprecated(note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\")]\npub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        self.swap_remove_entry(key)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::reserve": [
            "/// Reserve capacity for `additional` more key-value pairs.\n///\n/// Computes in **O(n)** time.\npub fn reserve(&mut self, additional: usize){\n        self.core.reserve(additional);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::reserve_exact": [
            "/// Reserve capacity for `additional` more key-value pairs, without over-allocating.\n///\n/// Unlike `reserve`, this does not deliberately over-allocate the entry capacity to avoid\n/// frequent re-allocations. However, the underlying data structures may still have internal\n/// capacity requirements, and the allocator itself may give more space than requested, so this\n/// cannot be relied upon to be precisely minimal.\n///\n/// Computes in **O(n)** time.\npub fn reserve_exact(&mut self, additional: usize){\n        self.core.reserve_exact(additional);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::retain": [
            "/// Scan through each key-value pair in the map and keep those where the\n/// closure `keep` returns `true`.\n///\n/// The elements are visited in order, and remaining elements keep their\n/// order.\n///\n/// Computes in **O(n)** time (average).\npub fn retain<F>(&mut self, mut keep: F)\n    where\n        F: FnMut(&K, &mut V) -> bool,{\n        self.core.retain_in_order(move |k, v| keep(k, v));\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::reverse": [
            "/// Reverses the order of the maps key-value pairs in place.\n///\n/// Computes in **O(n)** time and **O(1)** space.\npub fn reverse(&mut self){\n        self.core.reverse()\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::shift_insert": [
            "/// Insert a key-value pair in the map at the given index.\n///\n/// If an equivalent key already exists in the map: the key remains and\n/// is moved to the given index in the map, its corresponding value is updated\n/// with `value`, and the older value is returned inside `Some(_)`.\n/// Note that existing entries **cannot** be moved to `index == map.len()`!\n/// (See [`insert_before`](Self::insert_before) for different behavior here.)\n///\n/// If no equivalent key existed in the map: the new key-value pair is\n/// inserted at the given index, and `None` is returned.\n///\n/// ***Panics*** if `index` is out of bounds.\n/// Valid indices are `0..map.len()` (exclusive) when moving an existing entry, or\n/// `0..=map.len()` (inclusive) when inserting a new key.\n///\n/// Computes in **O(n)** time (average).\n///\n/// See also [`entry`][Self::entry] if you want to insert *or* modify,\n/// perhaps only using the index for new entries with [`VacantEntry::shift_insert`].\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexMap;\n/// let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n///\n/// // The new key '*' goes exactly at the given index.\n/// assert_eq!(map.get_index_of(&'*'), None);\n/// assert_eq!(map.shift_insert(10, '*', ()), None);\n/// assert_eq!(map.get_index_of(&'*'), Some(10));\n///\n/// // Moving the key 'a' up to 10 will shift others down, including the '*' that was at 10.\n/// assert_eq!(map.shift_insert(10, 'a', ()), Some(()));\n/// assert_eq!(map.get_index_of(&'a'), Some(10));\n/// assert_eq!(map.get_index_of(&'*'), Some(9));\n///\n/// // Moving the key 'z' down to 9 will shift others up, including the '*' that was at 9.\n/// assert_eq!(map.shift_insert(9, 'z', ()), Some(()));\n/// assert_eq!(map.get_index_of(&'z'), Some(9));\n/// assert_eq!(map.get_index_of(&'*'), Some(10));\n///\n/// // Existing keys can move to len-1 at most, but new keys can insert at the endpoint.\n/// assert_eq!(map.len(), 27);\n/// assert_eq!(map.shift_insert(map.len() - 1, '*', ()), Some(()));\n/// assert_eq!(map.get_index_of(&'*'), Some(26));\n/// assert_eq!(map.shift_insert(map.len(), '+', ()), None);\n/// assert_eq!(map.get_index_of(&'+'), Some(27));\n/// assert_eq!(map.len(), 28);\n/// ```\n///\n/// ```should_panic\n/// use indexmap::IndexMap;\n/// let mut map: IndexMap<char, ()> = ('a'..='z').map(|c| (c, ())).collect();\n///\n/// // This is an invalid index for moving an existing key!\n/// map.shift_insert(map.len(), 'a', ());\n/// ```\n#[track_caller]\npub fn shift_insert(&mut self, index: usize, key: K, value: V) -> Option<V>{\n        let len = self.len();\n        match self.entry(key) {\n            Entry::Occupied(mut entry) => {\n                assert!(\n                    index < len,\n                    \"index out of bounds: the len is {len} but the index is {index}\"\n                );\n\n                let old = mem::replace(entry.get_mut(), value);\n                entry.move_index(index);\n                Some(old)\n            }\n            Entry::Vacant(entry) => {\n                assert!(\n                    index <= len,\n                    \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\"\n                );\n\n                entry.shift_insert(index, value);\n                None\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::shift_remove": [
            "/// Remove the key-value pair equivalent to `key` and return\n/// its value.\n///\n/// Like [`Vec::remove`], the pair is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Return `None` if `key` is not in map.\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        self.shift_remove_full(key).map(third)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::shift_remove_entry": [
            "/// Remove and return the key-value pair equivalent to `key`.\n///\n/// Like [`Vec::remove`], the pair is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Return `None` if `key` is not in map.\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        match self.shift_remove_full(key) {\n            Some((_, key, value)) => Some((key, value)),\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::shift_remove_full": [
            "/// Remove the key-value pair equivalent to `key` and return it and\n/// the index it had.\n///\n/// Like [`Vec::remove`], the pair is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Return `None` if `key` is not in map.\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove_full<Q>(&mut self, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        match self.as_entries() {\n            [x] if key.equivalent(&x.key) => {\n                let (k, v) = self.core.pop()?;\n                Some((0, k, v))\n            }\n            [_] | [] => None,\n            _ => {\n                let hash = self.hash(key);\n                self.core.shift_remove_full(hash, key)\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::shift_remove_index": [
            "/// Remove the key-value pair by index\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Like [`Vec::remove`], the pair is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)>{\n        self.core.shift_remove_index(index)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::shrink_to": [
            "/// Shrink the capacity of the map with a lower limit.\n///\n/// Computes in **O(n)** time.\npub fn shrink_to(&mut self, min_capacity: usize){\n        self.core.shrink_to(min_capacity);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::shrink_to_fit": [
            "/// Shrink the capacity of the map as much as possible.\n///\n/// Computes in **O(n)** time.\npub fn shrink_to_fit(&mut self){\n        self.core.shrink_to(0);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::sort_by": [
            "/// Sort the maps key-value pairs in place using the comparison\n/// function `cmp`.\n///\n/// The comparison function receives two key and value pairs to compare (you\n/// can sort by keys or values or their combination as needed).\n///\n/// Computes in **O(n log n + c)** time and **O(n)** space where *n* is\n/// the length of the map and *c* the capacity. The sort is stable.\npub fn sort_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&K, &V, &K, &V) -> Ordering,{\n        self.with_entries(move |entries| {\n            entries.sort_by(move |a, b| cmp(&a.key, &a.value, &b.key, &b.value));\n        });\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::sort_by_cached_key": [
            "/// Sort the maps key-value pairs in place using a sort-key extraction function.\n///\n/// During sorting, the function is called at most once per entry, by using temporary storage\n/// to remember the results of its evaluation. The order of calls to the function is\n/// unspecified and may change between versions of `indexmap` or the standard library.\n///\n/// Computes in **O(m n + n log n + c)** time () and **O(n)** space, where the function is\n/// **O(m)**, *n* is the length of the map, and *c* the capacity. The sort is stable.\npub fn sort_by_cached_key<T, F>(&mut self, mut sort_key: F)\n    where\n        T: Ord,\n        F: FnMut(&K, &V) -> T,{\n        self.with_entries(move |entries| {\n            entries.sort_by_cached_key(move |a| sort_key(&a.key, &a.value));\n        });\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::sort_keys": [
            "/// Sort the maps key-value pairs by the default ordering of the keys.\n///\n/// This is a stable sort -- but equivalent keys should not normally coexist in\n/// a map at all, so [`sort_unstable_keys`][Self::sort_unstable_keys] is preferred\n/// because it is generally faster and doesn't allocate auxiliary memory.\n///\n/// See [`sort_by`](Self::sort_by) for details.\npub fn sort_keys(&mut self)\n    where\n        K: Ord,{\n        self.with_entries(move |entries| {\n            entries.sort_by(move |a, b| K::cmp(&a.key, &b.key));\n        });\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::sort_unstable_by": [
            "/// Sort the map's key-value pairs in place using the comparison function `cmp`, but\n/// may not preserve the order of equal elements.\n///\n/// The comparison function receives two key and value pairs to compare (you\n/// can sort by keys or values or their combination as needed).\n///\n/// Computes in **O(n log n + c)** time where *n* is\n/// the length of the map and *c* is the capacity. The sort is unstable.\npub fn sort_unstable_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&K, &V, &K, &V) -> Ordering,{\n        self.with_entries(move |entries| {\n            entries.sort_unstable_by(move |a, b| cmp(&a.key, &a.value, &b.key, &b.value));\n        });\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::sort_unstable_keys": [
            "/// Sort the map's key-value pairs by the default ordering of the keys, but\n/// may not preserve the order of equal elements.\n///\n/// See [`sort_unstable_by`](Self::sort_unstable_by) for details.\npub fn sort_unstable_keys(&mut self)\n    where\n        K: Ord,{\n        self.with_entries(move |entries| {\n            entries.sort_unstable_by(move |a, b| K::cmp(&a.key, &b.key));\n        });\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::sorted_by": [
            "/// Sort the key-value pairs of the map and return a by-value iterator of\n/// the key-value pairs with the result.\n///\n/// The sort is stable.\npub fn sorted_by<F>(self, mut cmp: F) -> IntoIter<K, V>\n    where\n        F: FnMut(&K, &V, &K, &V) -> Ordering,{\n        let mut entries = self.into_entries();\n        entries.sort_by(move |a, b| cmp(&a.key, &a.value, &b.key, &b.value));\n        IntoIter::new(entries)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::sorted_unstable_by": [
            "/// Sort the key-value pairs of the map and return a by-value iterator of\n/// the key-value pairs with the result.\n///\n/// The sort is unstable.\n#[inline]\npub fn sorted_unstable_by<F>(self, mut cmp: F) -> IntoIter<K, V>\n    where\n        F: FnMut(&K, &V, &K, &V) -> Ordering,{\n        let mut entries = self.into_entries();\n        entries.sort_unstable_by(move |a, b| cmp(&a.key, &a.value, &b.key, &b.value));\n        IntoIter::new(entries)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::splice": [
            "/// Creates a splicing iterator that replaces the specified range in the map\n/// with the given `replace_with` key-value iterator and yields the removed\n/// items. `replace_with` does not need to be the same length as `range`.\n///\n/// The `range` is removed even if the iterator is not consumed until the\n/// end. It is unspecified how many elements are removed from the map if the\n/// `Splice` value is leaked.\n///\n/// The input iterator `replace_with` is only consumed when the `Splice`\n/// value is dropped. If a key from the iterator matches an existing entry\n/// in the map (outside of `range`), then the value will be updated in that\n/// position. Otherwise, the new key-value pair will be inserted in the\n/// replaced `range`.\n///\n/// ***Panics*** if the starting point is greater than the end point or if\n/// the end point is greater than the length of the map.\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexMap;\n///\n/// let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);\n/// let new = [(5, 'E'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'A')];\n/// let removed: Vec<_> = map.splice(2..4, new).collect();\n///\n/// // 1 and 4 got new values, while 5, 3, and 2 were newly inserted.\n/// assert!(map.into_iter().eq([(0, '_'), (1, 'A'), (5, 'E'), (3, 'C'), (2, 'B'), (4, 'D')]));\n/// assert_eq!(removed, &[(2, 'b'), (3, 'c')]);\n/// ```\n#[track_caller]\npub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter, K, V, S>\n    where\n        R: RangeBounds<usize>,\n        I: IntoIterator<Item = (K, V)>,{\n        Splice::new(self, range, replace_with.into_iter())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::split_off": [
            "/// Splits the collection into two at the given index.\n///\n/// Returns a newly allocated map containing the elements in the range\n/// `[at, len)`. After the call, the original map will be left containing\n/// the elements `[0, at)` with its previous capacity unchanged.\n///\n/// ***Panics*** if `at > len`.\n#[track_caller]\npub fn split_off(&mut self, at: usize) -> Self\n    where\n        S: Clone,{\n        Self {\n            core: self.core.split_off(at),\n            hash_builder: self.hash_builder.clone(),\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::swap_indices": [
            "/// Swaps the position of two key-value pairs in the map.\n///\n/// ***Panics*** if `a` or `b` are out of bounds.\n///\n/// Computes in **O(1)** time (average).\n#[track_caller]\npub fn swap_indices(&mut self, a: usize, b: usize){\n        self.core.swap_indices(a, b)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::swap_remove": [
            "/// Remove the key-value pair equivalent to `key` and return\n/// its value.\n///\n/// Like [`Vec::swap_remove`], the pair is removed by swapping it with the\n/// last element of the map and popping it off. **This perturbs\n/// the position of what used to be the last element!**\n///\n/// Return `None` if `key` is not in map.\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove<Q>(&mut self, key: &Q) -> Option<V>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        self.swap_remove_full(key).map(third)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::swap_remove_entry": [
            "/// Remove and return the key-value pair equivalent to `key`.\n///\n/// Like [`Vec::swap_remove`], the pair is removed by swapping it with the\n/// last element of the map and popping it off. **This perturbs\n/// the position of what used to be the last element!**\n///\n/// Return `None` if `key` is not in map.\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        match self.swap_remove_full(key) {\n            Some((_, key, value)) => Some((key, value)),\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::swap_remove_full": [
            "/// Remove the key-value pair equivalent to `key` and return it and\n/// the index it had.\n///\n/// Like [`Vec::swap_remove`], the pair is removed by swapping it with the\n/// last element of the map and popping it off. **This perturbs\n/// the position of what used to be the last element!**\n///\n/// Return `None` if `key` is not in map.\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove_full<Q>(&mut self, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Hash + Equivalent<K>,{\n        match self.as_entries() {\n            [x] if key.equivalent(&x.key) => {\n                let (k, v) = self.core.pop()?;\n                Some((0, k, v))\n            }\n            [_] | [] => None,\n            _ => {\n                let hash = self.hash(key);\n                self.core.swap_remove_full(hash, key)\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::swap_remove_index": [
            "/// Remove the key-value pair by index\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Like [`Vec::swap_remove`], the pair is removed by swapping it with the\n/// last element of the map and popping it off. **This perturbs\n/// the position of what used to be the last element!**\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove_index(&mut self, index: usize) -> Option<(K, V)>{\n        self.core.swap_remove_index(index)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::truncate": [
            "/// Shortens the map, keeping the first `len` elements and dropping the rest.\n///\n/// If `len` is greater than the map's current length, this has no effect.\npub fn truncate(&mut self, len: usize){\n        self.core.truncate(len);\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::try_reserve": [
            "/// Try to reserve capacity for `additional` more key-value pairs.\n///\n/// Computes in **O(n)** time.\npub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError>{\n        self.core.try_reserve(additional)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::try_reserve_exact": [
            "/// Try to reserve capacity for `additional` more key-value pairs, without over-allocating.\n///\n/// Unlike `try_reserve`, this does not deliberately over-allocate the entry capacity to avoid\n/// frequent re-allocations. However, the underlying data structures may still have internal\n/// capacity requirements, and the allocator itself may give more space than requested, so this\n/// cannot be relied upon to be precisely minimal.\n///\n/// Computes in **O(n)** time.\npub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>{\n        self.core.try_reserve_exact(additional)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::values": [
            "/// Return an iterator over the values of the map, in their order\npub fn values(&self) -> Values<'_, K, V>{\n        Values::new(self.as_entries())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::values_mut": [
            "/// Return an iterator over mutable references to the values of the map,\n/// in their order\npub fn values_mut(&mut self) -> ValuesMut<'_, K, V>{\n        ValuesMut::new(self.as_entries_mut())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::with_capacity_and_hasher": [
            "/// Create a new map with capacity for `n` key-value pairs. (Does not\n/// allocate if `n` is zero.)\n///\n/// Computes in **O(n)** time.\n#[inline]\npub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self{\n        if n == 0 {\n            Self::with_hasher(hash_builder)\n        } else {\n            IndexMap {\n                core: IndexMapCore::with_capacity(n),\n                hash_builder,\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V, S>::with_hasher": [
            "/// Create a new map with `hash_builder`.\n///\n/// This function is `const`, so it\n/// can be called in `static` contexts.\npub const fn with_hasher(hash_builder: S) -> Self{\n        IndexMap {\n            core: IndexMapCore::new(),\n            hash_builder,\n        }\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V>::new": [
            "/// Create a new map. (Does not allocate.)\n#[inline]\npub fn new() -> Self{\n        Self::with_capacity(0)\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::IndexMap::<K, V>::with_capacity": [
            "/// Create a new map with capacity for `n` key-value pairs. (Does not\n/// allocate if `n` is zero.)\n///\n/// Computes in **O(n)** time.\n#[inline]\npub fn with_capacity(n: usize) -> Self{\n        Self::with_capacity_and_hasher(n, <_>::default())\n    }",
            "Real(LocalPath(\"src/map.rs\"))"
        ],
        "map::core::IndexMapCore": [
            "/// Core of the map that does not depend on S\npub(crate) struct IndexMapCore<K, V> {\n    /// indices mapping from the entry hash to its index.\n    indices: Indices,\n    /// entries is a dense vec maintaining entry order.\n    entries: Entries<K, V>,\n}",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::append_unchecked": [
            "/// Append from another map without checking whether items already exist.\npub(crate) fn append_unchecked(&mut self, other: &mut Self){\n        self.reserve(other.len());\n        insert_bulk_no_grow(&mut self.indices, &other.entries);\n        self.entries.append(&mut other.entries);\n        other.indices.clear();\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::borrow_mut": [
            "#[inline]\nfn borrow_mut(&mut self) -> RefMut<'_, K, V>{\n        RefMut::new(&mut self.indices, &mut self.entries)\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::capacity": [
            "#[inline]\npub(crate) fn capacity(&self) -> usize{\n        Ord::min(self.indices.capacity(), self.entries.capacity())\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::clear": [
            "pub(crate) fn clear(&mut self){\n        self.indices.clear();\n        self.entries.clear();\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::drain": [
            "#[track_caller]\npub(crate) fn drain<R>(&mut self, range: R) -> vec::Drain<'_, Bucket<K, V>>\n    where\n        R: RangeBounds<usize>,{\n        let range = simplify_range(range, self.entries.len());\n        self.erase_indices(range.start, range.end);\n        self.entries.drain(range)\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::erase_indices": [
            "/// Erase `start..end` from `indices`, and shift `end..` indices down to `start..`\n///\n/// All of these items should still be at their original location in `entries`.\n/// This is used by `drain`, which will let `Vec::drain` do the work on `entries`.\nfn erase_indices(&mut self, start: usize, end: usize){\n        let (init, shifted_entries) = self.entries.split_at(end);\n        let (start_entries, erased_entries) = init.split_at(start);\n\n        let erased = erased_entries.len();\n        let shifted = shifted_entries.len();\n        let half_capacity = self.indices.capacity() / 2;\n\n        // Use a heuristic between different strategies\n        if erased == 0 {\n            // Degenerate case, nothing to do\n        } else if start + shifted < half_capacity && start < erased {\n            // Reinsert everything, as there are few kept indices\n            self.indices.clear();\n\n            // Reinsert stable indices, then shifted indices\n            insert_bulk_no_grow(&mut self.indices, start_entries);\n            insert_bulk_no_grow(&mut self.indices, shifted_entries);\n        } else if erased + shifted < half_capacity {\n            // Find each affected index, as there are few to adjust\n\n            // Find erased indices\n            for (i, entry) in (start..).zip(erased_entries) {\n                erase_index(&mut self.indices, entry.hash, i);\n            }\n\n            // Find shifted indices\n            for ((new, old), entry) in (start..).zip(end..).zip(shifted_entries) {\n                update_index(&mut self.indices, entry.hash, old, new);\n            }\n        } else {\n            // Sweep the whole table for adjustments\n            let offset = end - start;\n            self.indices.retain(move |i| {\n                if *i >= end {\n                    *i -= offset;\n                    true\n                } else {\n                    *i < start\n                }\n            });\n        }\n\n        debug_assert_eq!(self.indices.len(), start + shifted);\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::get_index_of": [
            "/// Return the index in `entries` where an equivalent key can be found\npub(crate) fn get_index_of<Q>(&self, hash: HashValue, key: &Q) -> Option<usize>\n    where\n        Q: ?Sized + Equivalent<K>,{\n        let eq = equivalent(key, &self.entries);\n        self.indices.find(hash.get(), eq).copied()\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::insert_full": [
            "pub(crate) fn insert_full(&mut self, hash: HashValue, key: K, value: V) -> (usize, Option<V>)\n    where\n        K: Eq,{\n        let eq = equivalent(&key, &self.entries);\n        let hasher = get_hash(&self.entries);\n        match self.indices.entry(hash.get(), eq, hasher) {\n            hash_table::Entry::Occupied(entry) => {\n                let i = *entry.get();\n                (i, Some(mem::replace(&mut self.entries[i].value, value)))\n            }\n            hash_table::Entry::Vacant(entry) => {\n                let i = self.entries.len();\n                entry.insert(i);\n                self.push_entry(hash, key, value);\n                debug_assert_eq!(self.indices.len(), self.entries.len());\n                (i, None)\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::len": [
            "#[inline]\npub(crate) fn len(&self) -> usize{\n        self.indices.len()\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::move_index": [
            "#[inline]\n#[track_caller]\npub(super) fn move_index(&mut self, from: usize, to: usize){\n        self.borrow_mut().move_index(from, to);\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::new": [
            "#[inline]\npub(crate) const fn new() -> Self{\n        IndexMapCore {\n            indices: Indices::new(),\n            entries: Vec::new(),\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::pop": [
            "/// Remove the last key-value pair\npub(crate) fn pop(&mut self) -> Option<(K, V)>{\n        if let Some(entry) = self.entries.pop() {\n            let last = self.entries.len();\n            erase_index(&mut self.indices, entry.hash, last);\n            Some((entry.key, entry.value))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::push_entry": [
            "/// Append a key-value pair to `entries`,\n/// *without* checking whether it already exists.\nfn push_entry(&mut self, hash: HashValue, key: K, value: V){\n        if self.entries.len() == self.entries.capacity() {\n            // Reserve our own capacity synced to the indices,\n            // rather than letting `Vec::push` just double it.\n            self.borrow_mut().reserve_entries(1);\n        }\n        self.entries.push(Bucket { hash, key, value });\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::rebuild_hash_table": [
            "fn rebuild_hash_table(&mut self){\n        self.indices.clear();\n        insert_bulk_no_grow(&mut self.indices, &self.entries);\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::replace_full": [
            "/// Same as `insert_full`, except it also replaces the key\npub(crate) fn replace_full(\n        &mut self,\n        hash: HashValue,\n        key: K,\n        value: V,\n    ) -> (usize, Option<(K, V)>)\n    where\n        K: Eq,{\n        let eq = equivalent(&key, &self.entries);\n        let hasher = get_hash(&self.entries);\n        match self.indices.entry(hash.get(), eq, hasher) {\n            hash_table::Entry::Occupied(entry) => {\n                let i = *entry.get();\n                let entry = &mut self.entries[i];\n                let kv = (\n                    mem::replace(&mut entry.key, key),\n                    mem::replace(&mut entry.value, value),\n                );\n                (i, Some(kv))\n            }\n            hash_table::Entry::Vacant(entry) => {\n                let i = self.entries.len();\n                entry.insert(i);\n                self.push_entry(hash, key, value);\n                debug_assert_eq!(self.indices.len(), self.entries.len());\n                (i, None)\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::reserve": [
            "/// Reserve capacity for `additional` more key-value pairs.\npub(crate) fn reserve(&mut self, additional: usize){\n        self.indices.reserve(additional, get_hash(&self.entries));\n        // Only grow entries if necessary, since we also round up capacity.\n        if additional > self.entries.capacity() - self.entries.len() {\n            self.borrow_mut().reserve_entries(additional);\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::reserve_exact": [
            "/// Reserve capacity for `additional` more key-value pairs, without over-allocating.\npub(crate) fn reserve_exact(&mut self, additional: usize){\n        self.indices.reserve(additional, get_hash(&self.entries));\n        self.entries.reserve_exact(additional);\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::retain_in_order": [
            "pub(crate) fn retain_in_order<F>(&mut self, mut keep: F)\n    where\n        F: FnMut(&mut K, &mut V) -> bool,{\n        self.entries\n            .retain_mut(|entry| keep(&mut entry.key, &mut entry.value));\n        if self.entries.len() < self.indices.len() {\n            self.rebuild_hash_table();\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::reverse": [
            "pub(crate) fn reverse(&mut self){\n        self.entries.reverse();\n\n        // No need to save hash indices, can easily calculate what they should\n        // be, given that this is an in-place reversal.\n        let len = self.entries.len();\n        for i in &mut self.indices {\n            *i = len - *i - 1;\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::shift_remove_full": [
            "/// Remove an entry by shifting all entries that follow it\npub(crate) fn shift_remove_full<Q>(&mut self, hash: HashValue, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Equivalent<K>,{\n        let eq = equivalent(key, &self.entries);\n        match self.indices.find_entry(hash.get(), eq) {\n            Ok(entry) => {\n                let (index, _) = entry.remove();\n                let (key, value) = self.borrow_mut().shift_remove_finish(index);\n                Some((index, key, value))\n            }\n            Err(_) => None,\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::shift_remove_index": [
            "/// Remove an entry by shifting all entries that follow it\n#[inline]\npub(crate) fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)>{\n        self.borrow_mut().shift_remove_index(index)\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::shrink_to": [
            "/// Shrink the capacity of the map with a lower bound\npub(crate) fn shrink_to(&mut self, min_capacity: usize){\n        self.indices\n            .shrink_to(min_capacity, get_hash(&self.entries));\n        self.entries.shrink_to(min_capacity);\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::split_off": [
            "#[track_caller]\npub(crate) fn split_off(&mut self, at: usize) -> Self{\n        let len = self.entries.len();\n        assert!(\n            at <= len,\n            \"index out of bounds: the len is {len} but the index is {at}. Expected index <= len\"\n        );\n\n        self.erase_indices(at, self.entries.len());\n        let entries = self.entries.split_off(at);\n\n        let mut indices = Indices::with_capacity(entries.len());\n        insert_bulk_no_grow(&mut indices, &entries);\n        Self { indices, entries }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::split_splice": [
            "#[track_caller]\npub(crate) fn split_splice<R>(&mut self, range: R) -> (Self, vec::IntoIter<Bucket<K, V>>)\n    where\n        R: RangeBounds<usize>,{\n        let range = simplify_range(range, self.len());\n        self.erase_indices(range.start, self.entries.len());\n        let entries = self.entries.split_off(range.end);\n        let drained = self.entries.split_off(range.start);\n\n        let mut indices = Indices::with_capacity(entries.len());\n        insert_bulk_no_grow(&mut indices, &entries);\n        (Self { indices, entries }, drained.into_iter())\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::swap_indices": [
            "#[inline]\n#[track_caller]\npub(crate) fn swap_indices(&mut self, a: usize, b: usize){\n        self.borrow_mut().swap_indices(a, b);\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::swap_remove_full": [
            "/// Remove an entry by swapping it with the last\npub(crate) fn swap_remove_full<Q>(&mut self, hash: HashValue, key: &Q) -> Option<(usize, K, V)>\n    where\n        Q: ?Sized + Equivalent<K>,{\n        let eq = equivalent(key, &self.entries);\n        match self.indices.find_entry(hash.get(), eq) {\n            Ok(entry) => {\n                let (index, _) = entry.remove();\n                let (key, value) = self.borrow_mut().swap_remove_finish(index);\n                Some((index, key, value))\n            }\n            Err(_) => None,\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::swap_remove_index": [
            "/// Remove an entry by swapping it with the last\n#[inline]\npub(crate) fn swap_remove_index(&mut self, index: usize) -> Option<(K, V)>{\n        self.borrow_mut().swap_remove_index(index)\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::truncate": [
            "pub(crate) fn truncate(&mut self, len: usize){\n        if len < self.len() {\n            self.erase_indices(len, self.entries.len());\n            self.entries.truncate(len);\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::try_reserve": [
            "/// Try to reserve capacity for `additional` more key-value pairs.\npub(crate) fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError>{\n        self.indices\n            .try_reserve(additional, get_hash(&self.entries))\n            .map_err(TryReserveError::from_hashbrown)?;\n        // Only grow entries if necessary, since we also round up capacity.\n        if additional > self.entries.capacity() - self.entries.len() {\n            self.try_reserve_entries(additional)\n        } else {\n            Ok(())\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::try_reserve_entries": [
            "/// Try to reserve entries capacity, rounded up to match the indices\nfn try_reserve_entries(&mut self, additional: usize) -> Result<(), TryReserveError>{\n        // Use a soft-limit on the maximum capacity, but if the caller explicitly\n        // requested more, do it and let them have the resulting error.\n        let new_capacity = Ord::min(self.indices.capacity(), Self::MAX_ENTRIES_CAPACITY);\n        let try_add = new_capacity - self.entries.len();\n        if try_add > additional && self.entries.try_reserve_exact(try_add).is_ok() {\n            return Ok(());\n        }\n        self.entries\n            .try_reserve_exact(additional)\n            .map_err(TryReserveError::from_alloc)\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::try_reserve_exact": [
            "/// Try to reserve capacity for `additional` more key-value pairs, without over-allocating.\npub(crate) fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>{\n        self.indices\n            .try_reserve(additional, get_hash(&self.entries))\n            .map_err(TryReserveError::from_hashbrown)?;\n        self.entries\n            .try_reserve_exact(additional)\n            .map_err(TryReserveError::from_alloc)\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::IndexMapCore::<K, V>::with_capacity": [
            "#[inline]\npub(crate) fn with_capacity(n: usize) -> Self{\n        IndexMapCore {\n            indices: Indices::with_capacity(n),\n            entries: Vec::with_capacity(n),\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut": [
            "/// Mutable references to the parts of an `IndexMapCore`.\n///\n/// When using `HashTable::find_entry`, that takes hold of `&mut indices`, so we have to borrow our\n/// `&mut entries` separately, and there's no way to go back to a `&mut IndexMapCore`. So this type\n/// is used to implement methods on the split references, and `IndexMapCore` can also call those to\n/// avoid duplication.\nstruct RefMut<'a, K, V> {\n    indices: &'a mut Indices,\n    entries: &'a mut Entries<K, V>,\n}",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::decrement_indices": [
            "/// Decrement all indices in the range `start..end`.\n///\n/// The index `start - 1` should not exist in `self.indices`.\n/// All entries should still be in their original positions.\nfn decrement_indices(&mut self, start: usize, end: usize){\n        // Use a heuristic between a full sweep vs. a `find()` for every shifted item.\n        let shifted_entries = &self.entries[start..end];\n        if shifted_entries.len() > self.indices.capacity() / 2 {\n            // Shift all indices in range.\n            for i in &mut *self.indices {\n                if start <= *i && *i < end {\n                    *i -= 1;\n                }\n            }\n        } else {\n            // Find each entry in range to shift its index.\n            for (i, entry) in (start..end).zip(shifted_entries) {\n                update_index(self.indices, entry.hash, i, i - 1);\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::increment_indices": [
            "/// Increment all indices in the range `start..end`.\n///\n/// The index `end` should not exist in `self.indices`.\n/// All entries should still be in their original positions.\nfn increment_indices(&mut self, start: usize, end: usize){\n        // Use a heuristic between a full sweep vs. a `find()` for every shifted item.\n        let shifted_entries = &self.entries[start..end];\n        if shifted_entries.len() > self.indices.capacity() / 2 {\n            // Shift all indices in range.\n            for i in &mut *self.indices {\n                if start <= *i && *i < end {\n                    *i += 1;\n                }\n            }\n        } else {\n            // Find each entry in range to shift its index, updated in reverse so\n            // we never have duplicated indices that might have a hash collision.\n            for (i, entry) in (start..end).zip(shifted_entries).rev() {\n                update_index(self.indices, entry.hash, i, i + 1);\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::insert_unique": [
            "/// Insert a key-value pair in `entries`,\n/// *without* checking whether it already exists.\nfn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V>{\n        let i = self.indices.len();\n        debug_assert_eq!(i, self.entries.len());\n        let entry = self\n            .indices\n            .insert_unique(hash.get(), i, get_hash(self.entries));\n        if self.entries.len() == self.entries.capacity() {\n            // We can't call `indices.capacity()` while this `entry` has borrowed it, so we'll have\n            // to amortize growth on our own. It's still an improvement over the basic `Vec::push`\n            // doubling though, since we also consider `MAX_ENTRIES_CAPACITY`.\n            reserve_entries(self.entries, 1, 2 * self.entries.capacity());\n        }\n        self.entries.push(Bucket { hash, key, value });\n        OccupiedEntry::new(self.entries, entry)\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::move_index": [
            "#[track_caller]\nfn move_index(&mut self, from: usize, to: usize){\n        let from_hash = self.entries[from].hash;\n        let _ = self.entries[to]; // explicit bounds check\n        if from != to {\n            // Use a sentinel index so other indices don't collide.\n            update_index(self.indices, from_hash, from, usize::MAX);\n\n            // Update all other indices and rotate the entry positions.\n            if from < to {\n                self.decrement_indices(from + 1, to + 1);\n                self.entries[from..=to].rotate_left(1);\n            } else if to < from {\n                self.increment_indices(to, from);\n                self.entries[to..=from].rotate_right(1);\n            }\n\n            // Change the sentinel index to its final position.\n            update_index(self.indices, from_hash, usize::MAX, to);\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::new": [
            "#[inline]\nfn new(indices: &'a mut Indices, entries: &'a mut Entries<K, V>) -> Self{\n        Self { indices, entries }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::reserve_entries": [
            "/// Reserve entries capacity, rounded up to match the indices\n#[inline]\nfn reserve_entries(&mut self, additional: usize){\n        reserve_entries(self.entries, additional, self.indices.capacity());\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::shift_insert_unique": [
            "/// Insert a key-value pair in `entries` at a particular index,\n/// *without* checking whether it already exists.\nfn shift_insert_unique(&mut self, index: usize, hash: HashValue, key: K, value: V){\n        let end = self.indices.len();\n        assert!(index <= end);\n        // Increment others first so we don't have duplicate indices.\n        self.increment_indices(index, end);\n        let entries = &*self.entries;\n        self.indices.insert_unique(hash.get(), index, move |&i| {\n            // Adjust for the incremented indices to find hashes.\n            debug_assert_ne!(i, index);\n            let i = if i < index { i } else { i - 1 };\n            entries[i].hash.get()\n        });\n        if self.entries.len() == self.entries.capacity() {\n            // Reserve our own capacity synced to the indices,\n            // rather than letting `Vec::insert` just double it.\n            self.reserve_entries(1);\n        }\n        self.entries.insert(index, Bucket { hash, key, value });\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::shift_remove_finish": [
            "/// Remove an entry by shifting all entries that follow it\n///\n/// The index should already be removed from `self.indices`.\nfn shift_remove_finish(&mut self, index: usize) -> (K, V){\n        // Correct indices that point to the entries that followed the removed entry.\n        self.decrement_indices(index + 1, self.entries.len());\n\n        // Use Vec::remove to actually remove the entry.\n        let entry = self.entries.remove(index);\n        (entry.key, entry.value)\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::shift_remove_index": [
            "/// Remove an entry by shifting all entries that follow it\nfn shift_remove_index(&mut self, index: usize) -> Option<(K, V)>{\n        match self.entries.get(index) {\n            Some(entry) => {\n                erase_index(self.indices, entry.hash, index);\n                Some(self.shift_remove_finish(index))\n            }\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::swap_indices": [
            "#[track_caller]\nfn swap_indices(&mut self, a: usize, b: usize){\n        // If they're equal and in-bounds, there's nothing to do.\n        if a == b && a < self.entries.len() {\n            return;\n        }\n\n        // We'll get a \"nice\" bounds-check from indexing `entries`,\n        // and then we expect to find it in the table as well.\n        match self.indices.get_many_mut(\n            [self.entries[a].hash.get(), self.entries[b].hash.get()],\n            move |i, &x| if i == 0 { x == a } else { x == b },\n        ) {\n            [Some(ref_a), Some(ref_b)] => {\n                mem::swap(ref_a, ref_b);\n                self.entries.swap(a, b);\n            }\n            _ => panic!(\"indices not found\"),\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::swap_remove_finish": [
            "/// Finish removing an entry by swapping it with the last\n///\n/// The index should already be removed from `self.indices`.\nfn swap_remove_finish(&mut self, index: usize) -> (K, V){\n        // use swap_remove, but then we need to update the index that points\n        // to the other entry that has to move\n        let entry = self.entries.swap_remove(index);\n\n        // correct index that points to the entry that had to swap places\n        if let Some(entry) = self.entries.get(index) {\n            // was not last element\n            // examine new element in `index` and find it in indices\n            let last = self.entries.len();\n            update_index(self.indices, entry.hash, last, index);\n        }\n\n        (entry.key, entry.value)\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::RefMut::<'a, K, V>::swap_remove_index": [
            "/// Remove an entry by swapping it with the last\nfn swap_remove_index(&mut self, index: usize) -> Option<(K, V)>{\n        match self.entries.get(index) {\n            Some(entry) => {\n                erase_index(self.indices, entry.hash, index);\n                Some(self.swap_remove_finish(index))\n            }\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::entry::<impl map::core::IndexMapCore<K, V>>::entry": [
            "pub(crate) fn entry(&mut self, hash: HashValue, key: K) -> Entry<'_, K, V>\n    where\n        K: Eq,{\n        let entries = &mut self.entries;\n        let eq = equivalent(&key, entries);\n        match self.indices.find_entry(hash.get(), eq) {\n            Ok(index) => Entry::Occupied(OccupiedEntry { entries, index }),\n            Err(absent) => Entry::Vacant(VacantEntry {\n                map: RefMut::new(absent.into_table(), entries),\n                hash,\n                key,\n            }),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::Entry": [
            "/// Entry for an existing key-value pair in an [`IndexMap`][crate::IndexMap]\n/// or a vacant location to insert one.\npub enum Entry<'a, K, V> {\n    /// Existing slot with equivalent key.\n    Occupied(OccupiedEntry<'a, K, V>),\n    /// Vacant slot (no equivalent key in the map).\n    Vacant(VacantEntry<'a, K, V>),\n}",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::Entry::<'a, K, V>::and_modify": [
            "/// Modifies the entry if it is occupied.\npub fn and_modify<F>(mut self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),{\n        if let Entry::Occupied(entry) = &mut self {\n            f(entry.get_mut());\n        }\n        self\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::Entry::<'a, K, V>::index": [
            "/// Return the index where the key-value pair exists or will be inserted.\npub fn index(&self) -> usize{\n        match *self {\n            Entry::Occupied(ref entry) => entry.index(),\n            Entry::Vacant(ref entry) => entry.index(),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::Entry::<'a, K, V>::insert_entry": [
            "/// Sets the value of the entry (after inserting if vacant), and returns an `OccupiedEntry`.\n///\n/// Computes in **O(1)** time (amortized average).\npub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V>{\n        match self {\n            Entry::Occupied(mut entry) => {\n                entry.insert(value);\n                entry\n            }\n            Entry::Vacant(entry) => entry.insert_entry(value),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::Entry::<'a, K, V>::key": [
            "/// Gets a reference to the entry's key, either within the map if occupied,\n/// or else the new key that was used to find the entry.\npub fn key(&self) -> &K{\n        match *self {\n            Entry::Occupied(ref entry) => entry.key(),\n            Entry::Vacant(ref entry) => entry.key(),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::Entry::<'a, K, V>::or_default": [
            "/// Inserts a default-constructed value in the entry if it is vacant and returns a mutable\n/// reference to it. Otherwise a mutable reference to an already existent value is returned.\n///\n/// Computes in **O(1)** time (amortized average).\npub fn or_default(self) -> &'a mut V\n    where\n        V: Default,{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(V::default()),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::Entry::<'a, K, V>::or_insert": [
            "/// Inserts the given default value in the entry if it is vacant and returns a mutable\n/// reference to it. Otherwise a mutable reference to an already existent value is returned.\n///\n/// Computes in **O(1)** time (amortized average).\npub fn or_insert(self, default: V) -> &'a mut V{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::Entry::<'a, K, V>::or_insert_with": [
            "/// Inserts the result of the `call` function in the entry if it is vacant and returns a mutable\n/// reference to it. Otherwise a mutable reference to an already existent value is returned.\n///\n/// Computes in **O(1)** time (amortized average).\npub fn or_insert_with<F>(self, call: F) -> &'a mut V\n    where\n        F: FnOnce() -> V,{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(call()),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::Entry::<'a, K, V>::or_insert_with_key": [
            "/// Inserts the result of the `call` function with a reference to the entry's key if it is\n/// vacant, and returns a mutable reference to the new value. Otherwise a mutable reference to\n/// an already existent value is returned.\n///\n/// Computes in **O(1)** time (amortized average).\npub fn or_insert_with_key<F>(self, call: F) -> &'a mut V\n    where\n        F: FnOnce(&K) -> V,{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => {\n                let value = call(&entry.key);\n                entry.insert(value)\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry": [
            "/// A view into an occupied entry in an [`IndexMap`][crate::IndexMap] obtained by index.\n///\n/// This `struct` is created from the [`get_index_entry`][crate::IndexMap::get_index_entry] method.\npub struct IndexedEntry<'a, K, V> {\n    map: RefMut<'a, K, V>,\n    // We have a mutable reference to the map, which keeps the index\n    // valid and pointing to the correct entry.\n    index: usize,\n}",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::get": [
            "/// Gets a reference to the entry's value in the map.\npub fn get(&self) -> &V{\n        &self.map.entries[self.index].value\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::get_mut": [
            "/// Gets a mutable reference to the entry's value in the map.\n///\n/// If you need a reference which may outlive the destruction of the\n/// `IndexedEntry` value, see [`into_mut`][Self::into_mut].\npub fn get_mut(&mut self) -> &mut V{\n        &mut self.map.entries[self.index].value\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::index": [
            "/// Return the index of the key-value pair\n#[inline]\npub fn index(&self) -> usize{\n        self.index\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::insert": [
            "/// Sets the value of the entry to `value`, and returns the entry's old value.\npub fn insert(&mut self, value: V) -> V{\n        mem::replace(self.get_mut(), value)\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::into_mut": [
            "/// Converts into a mutable reference to the entry's value in the map,\n/// with a lifetime bound to the map itself.\npub fn into_mut(self) -> &'a mut V{\n        &mut self.map.entries[self.index].value\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::key": [
            "/// Gets a reference to the entry's key in the map.\npub fn key(&self) -> &K{\n        &self.map.entries[self.index].key\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::key_mut": [
            "pub(crate) fn key_mut(&mut self) -> &mut K{\n        &mut self.map.entries[self.index].key\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::move_index": [
            "/// Moves the position of the entry to a new index\n/// by shifting all other entries in-between.\n///\n/// This is equivalent to [`IndexMap::move_index`][`crate::IndexMap::move_index`]\n/// coming `from` the current [`.index()`][Self::index].\n///\n/// * If `self.index() < to`, the other pairs will shift down while the targeted pair moves up.\n/// * If `self.index() > to`, the other pairs will shift up while the targeted pair moves down.\n///\n/// ***Panics*** if `to` is out of bounds.\n///\n/// Computes in **O(n)** time (average).\n#[track_caller]\npub fn move_index(mut self, to: usize){\n        self.map.move_index(self.index, to);\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::new": [
            "pub(crate) fn new(map: &'a mut IndexMapCore<K, V>, index: usize) -> Self{\n        Self {\n            map: map.borrow_mut(),\n            index,\n        }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::shift_remove": [
            "/// Remove the key, value pair stored in the map for this entry, and return the value.\n///\n/// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove(self) -> V{\n        self.shift_remove_entry().1\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::shift_remove_entry": [
            "/// Remove and return the key, value pair stored in the map for this entry\n///\n/// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove_entry(mut self) -> (K, V){\n        self.map.shift_remove_index(self.index).unwrap()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::swap_indices": [
            "/// Swaps the position of entry with another.\n///\n/// This is equivalent to [`IndexMap::swap_indices`][`crate::IndexMap::swap_indices`]\n/// with the current [`.index()`][Self::index] as one of the two being swapped.\n///\n/// ***Panics*** if the `other` index is out of bounds.\n///\n/// Computes in **O(1)** time (average).\npub fn swap_indices(mut self, other: usize){\n        self.map.swap_indices(self.index, other);\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::swap_remove": [
            "/// Remove the key, value pair stored in the map for this entry, and return the value.\n///\n/// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n/// the last element of the map and popping it off.\n/// **This perturbs the position of what used to be the last element!**\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove(self) -> V{\n        self.swap_remove_entry().1\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::swap_remove_entry": [
            "/// Remove and return the key, value pair stored in the map for this entry\n///\n/// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n/// the last element of the map and popping it off.\n/// **This perturbs the position of what used to be the last element!**\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove_entry(mut self) -> (K, V){\n        self.map.swap_remove_index(self.index).unwrap()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry": [
            "/// A view into an occupied entry in an [`IndexMap`][crate::IndexMap].\n/// It is part of the [`Entry`] enum.\npub struct OccupiedEntry<'a, K, V> {\n    entries: &'a mut Entries<K, V>,\n    index: hash_table::OccupiedEntry<'a, usize>,\n}",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::get": [
            "/// Gets a reference to the entry's value in the map.\npub fn get(&self) -> &V{\n        &self.entries[self.index()].value\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::get_mut": [
            "/// Gets a mutable reference to the entry's value in the map.\n///\n/// If you need a reference which may outlive the destruction of the\n/// [`Entry`] value, see [`into_mut`][Self::into_mut].\npub fn get_mut(&mut self) -> &mut V{\n        let index = self.index();\n        &mut self.entries[index].value\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::index": [
            "/// Return the index of the key-value pair\n#[inline]\npub fn index(&self) -> usize{\n        *self.index.get()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::insert": [
            "/// Sets the value of the entry to `value`, and returns the entry's old value.\npub fn insert(&mut self, value: V) -> V{\n        mem::replace(self.get_mut(), value)\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::into_mut": [
            "/// Converts into a mutable reference to the entry's value in the map,\n/// with a lifetime bound to the map itself.\npub fn into_mut(self) -> &'a mut V{\n        let index = self.index();\n        &mut self.entries[index].value\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::into_muts": [
            "pub(super) fn into_muts(self) -> (&'a mut K, &'a mut V){\n        let index = self.index();\n        self.entries[index].muts()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::into_ref_mut": [
            "#[inline]\nfn into_ref_mut(self) -> RefMut<'a, K, V>{\n        RefMut::new(self.index.into_table(), self.entries)\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::key": [
            "/// Gets a reference to the entry's key in the map.\n///\n/// Note that this is not the key that was used to find the entry. There may be an observable\n/// difference if the key type has any distinguishing features outside of `Hash` and `Eq`, like\n/// extra fields or the memory address of an allocation.\npub fn key(&self) -> &K{\n        &self.entries[self.index()].key\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::key_mut": [
            "pub(crate) fn key_mut(&mut self) -> &mut K{\n        let index = self.index();\n        &mut self.entries[index].key\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::move_index": [
            "/// Moves the position of the entry to a new index\n/// by shifting all other entries in-between.\n///\n/// This is equivalent to [`IndexMap::move_index`][`crate::IndexMap::move_index`]\n/// coming `from` the current [`.index()`][Self::index].\n///\n/// * If `self.index() < to`, the other pairs will shift down while the targeted pair moves up.\n/// * If `self.index() > to`, the other pairs will shift up while the targeted pair moves down.\n///\n/// ***Panics*** if `to` is out of bounds.\n///\n/// Computes in **O(n)** time (average).\n#[track_caller]\npub fn move_index(self, to: usize){\n        let index = self.index();\n        self.into_ref_mut().move_index(index, to);\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::new": [
            "pub(crate) fn new(\n        entries: &'a mut Entries<K, V>,\n        index: hash_table::OccupiedEntry<'a, usize>,\n    ) -> Self{\n        Self { entries, index }\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::remove": [
            "/// Remove the key, value pair stored in the map for this entry, and return the value.\n///\n/// **NOTE:** This is equivalent to [`.swap_remove()`][Self::swap_remove], replacing this\n/// entry's position with the last element, and it is deprecated in favor of calling that\n/// explicitly. If you need to preserve the relative order of the keys in the map, use\n/// [`.shift_remove()`][Self::shift_remove] instead.\n#[deprecated(note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\")]\npub fn remove(self) -> V{\n        self.swap_remove()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::remove_entry": [
            "/// Remove and return the key, value pair stored in the map for this entry\n///\n/// **NOTE:** This is equivalent to [`.swap_remove_entry()`][Self::swap_remove_entry],\n/// replacing this entry's position with the last element, and it is deprecated in favor of\n/// calling that explicitly. If you need to preserve the relative order of the keys in the map,\n/// use [`.shift_remove_entry()`][Self::shift_remove_entry] instead.\n#[deprecated(note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\")]\npub fn remove_entry(self) -> (K, V){\n        self.swap_remove_entry()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::shift_remove": [
            "/// Remove the key, value pair stored in the map for this entry, and return the value.\n///\n/// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove(self) -> V{\n        self.shift_remove_entry().1\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::shift_remove_entry": [
            "/// Remove and return the key, value pair stored in the map for this entry\n///\n/// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove_entry(self) -> (K, V){\n        let (index, entry) = self.index.remove();\n        RefMut::new(entry.into_table(), self.entries).shift_remove_finish(index)\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::swap_indices": [
            "/// Swaps the position of entry with another.\n///\n/// This is equivalent to [`IndexMap::swap_indices`][`crate::IndexMap::swap_indices`]\n/// with the current [`.index()`][Self::index] as one of the two being swapped.\n///\n/// ***Panics*** if the `other` index is out of bounds.\n///\n/// Computes in **O(1)** time (average).\npub fn swap_indices(self, other: usize){\n        let index = self.index();\n        self.into_ref_mut().swap_indices(index, other);\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::swap_remove": [
            "/// Remove the key, value pair stored in the map for this entry, and return the value.\n///\n/// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n/// the last element of the map and popping it off.\n/// **This perturbs the position of what used to be the last element!**\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove(self) -> V{\n        self.swap_remove_entry().1\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::swap_remove_entry": [
            "/// Remove and return the key, value pair stored in the map for this entry\n///\n/// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n/// the last element of the map and popping it off.\n/// **This perturbs the position of what used to be the last element!**\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove_entry(self) -> (K, V){\n        let (index, entry) = self.index.remove();\n        RefMut::new(entry.into_table(), self.entries).swap_remove_finish(index)\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::VacantEntry": [
            "/// A view into a vacant entry in an [`IndexMap`][crate::IndexMap].\n/// It is part of the [`Entry`] enum.\npub struct VacantEntry<'a, K, V> {\n    map: RefMut<'a, K, V>,\n    hash: HashValue,\n    key: K,\n}",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::index": [
            "/// Return the index where a key-value pair may be inserted.\npub fn index(&self) -> usize{\n        self.map.indices.len()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::insert": [
            "/// Inserts the entry's key and the given value into the map, and returns a mutable reference\n/// to the value.\n///\n/// Computes in **O(1)** time (amortized average).\npub fn insert(self, value: V) -> &'a mut V{\n        self.insert_entry(value).into_mut()\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::insert_entry": [
            "/// Inserts the entry's key and the given value into the map, and returns an `OccupiedEntry`.\n///\n/// Computes in **O(1)** time (amortized average).\npub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V>{\n        let Self { map, hash, key } = self;\n        map.insert_unique(hash, key, value)\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::insert_sorted": [
            "/// Inserts the entry's key and the given value into the map at its ordered\n/// position among sorted keys, and returns the new index and a mutable\n/// reference to the value.\n///\n/// If the existing keys are **not** already sorted, then the insertion\n/// index is unspecified (like [`slice::binary_search`]), but the key-value\n/// pair is inserted at that position regardless.\n///\n/// Computes in **O(n)** time (average).\npub fn insert_sorted(self, value: V) -> (usize, &'a mut V)\n    where\n        K: Ord,{\n        let slice = crate::map::Slice::from_slice(self.map.entries);\n        let i = slice.binary_search_keys(&self.key).unwrap_err();\n        (i, self.shift_insert(i, value))\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::into_key": [
            "/// Takes ownership of the key, leaving the entry vacant.\npub fn into_key(self) -> K{\n        self.key\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::key": [
            "/// Gets a reference to the key that was used to find the entry.\npub fn key(&self) -> &K{\n        &self.key\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::key_mut": [
            "pub(crate) fn key_mut(&mut self) -> &mut K{\n        &mut self.key\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::shift_insert": [
            "/// Inserts the entry's key and the given value into the map at the given index,\n/// shifting others to the right, and returns a mutable reference to the value.\n///\n/// ***Panics*** if `index` is out of bounds.\n///\n/// Computes in **O(n)** time (average).\npub fn shift_insert(mut self, index: usize, value: V) -> &'a mut V{\n        self.map\n            .shift_insert_unique(index, self.hash, self.key, value);\n        &mut self.map.entries[index].value\n    }",
            "Real(LocalPath(\"src/map/core/entry.rs\"))"
        ],
        "map::core::equivalent": [
            "#[inline]\nfn equivalent<'a, K, V, Q: ?Sized + Equivalent<K>>(\n    key: &'a Q,\n    entries: &'a [Bucket<K, V>],\n) -> impl Fn(&usize) -> bool + 'a{\n    move |&i| Q::equivalent(key, &entries[i].key)\n}",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::erase_index": [
            "#[inline]\nfn erase_index(table: &mut Indices, hash: HashValue, index: usize){\n    if let Ok(entry) = table.find_entry(hash.get(), move |&i| i == index) {\n        entry.remove();\n    } else if cfg!(debug_assertions) {\n        panic!(\"index not found\");\n    }\n}",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::get_hash": [
            "#[inline(always)]\nfn get_hash<K, V>(entries: &[Bucket<K, V>]) -> impl Fn(&usize) -> u64 + '_{\n    move |&i| entries[i].hash.get()\n}",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::insert_bulk_no_grow": [
            "/// Inserts many entries into the indices table without reallocating,\n/// and without regard for duplication.\n///\n/// ***Panics*** if there is not sufficient capacity already.\nfn insert_bulk_no_grow<K, V>(indices: &mut Indices, entries: &[Bucket<K, V>]){\n    assert!(indices.capacity() - indices.len() >= entries.len());\n    for entry in entries {\n        indices.insert_unique(entry.hash.get(), indices.len(), |_| unreachable!());\n    }\n}",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryApiV1": [
            "/// Opt-in access to the experimental raw entry API.\n///\n/// See the [`raw_entry_v1`][self] module documentation for more information.\npub trait RawEntryApiV1<K, V, S>: private::Sealed {\n    /// Creates a raw immutable entry builder for the [`IndexMap`].\n    ///\n    /// Raw entries provide the lowest level of control for searching and\n    /// manipulating a map. They must be manually initialized with a hash and\n    /// then manually searched.\n    ///\n    /// This is useful for\n    /// * Hash memoization\n    /// * Using a search key that doesn't work with the [`Equivalent`] trait\n    /// * Using custom comparison logic without newtype wrappers\n    ///\n    /// Unless you are in such a situation, higher-level and more foolproof APIs like\n    /// [`get`][IndexMap::get] should be preferred.\n    ///\n    /// Immutable raw entries have very limited use; you might instead want\n    /// [`raw_entry_mut_v1`][Self::raw_entry_mut_v1].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use core::hash::{BuildHasher, Hash};\n    /// use indexmap::map::{IndexMap, RawEntryApiV1};\n    ///\n    /// let mut map = IndexMap::new();\n    /// map.extend([(\"a\", 100), (\"b\", 200), (\"c\", 300)]);\n    ///\n    /// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n    ///     use core::hash::Hasher;\n    ///     let mut state = hash_builder.build_hasher();\n    ///     key.hash(&mut state);\n    ///     state.finish()\n    /// }\n    ///\n    /// for k in [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] {\n    ///     let hash = compute_hash(map.hasher(), k);\n    ///     let i = map.get_index_of(k);\n    ///     let v = map.get(k);\n    ///     let kv = map.get_key_value(k);\n    ///     let ikv = map.get_full(k);\n    ///\n    ///     println!(\"Key: {} and value: {:?}\", k, v);\n    ///\n    ///     assert_eq!(map.raw_entry_v1().from_key(k), kv);\n    ///     assert_eq!(map.raw_entry_v1().from_hash(hash, |q| *q == k), kv);\n    ///     assert_eq!(map.raw_entry_v1().from_key_hashed_nocheck(hash, k), kv);\n    ///     assert_eq!(map.raw_entry_v1().from_hash_full(hash, |q| *q == k), ikv);\n    ///     assert_eq!(map.raw_entry_v1().index_from_hash(hash, |q| *q == k), i);\n    /// }\n    /// ```\n    fn raw_entry_v1(&self) -> RawEntryBuilder<'_, K, V, S>;\n\n    /// Creates a raw entry builder for the [`IndexMap`].\n    ///\n    /// Raw entries provide the lowest level of control for searching and\n    /// manipulating a map. They must be manually initialized with a hash and\n    /// then manually searched. After this, insertions into a vacant entry\n    /// still require an owned key to be provided.\n    ///\n    /// Raw entries are useful for such exotic situations as:\n    ///\n    /// * Hash memoization\n    /// * Deferring the creation of an owned key until it is known to be required\n    /// * Using a search key that doesn't work with the [`Equivalent`] trait\n    /// * Using custom comparison logic without newtype wrappers\n    ///\n    /// Because raw entries provide much more low-level control, it's much easier\n    /// to put the `IndexMap` into an inconsistent state which, while memory-safe,\n    /// will cause the map to produce seemingly random results. Higher-level and more\n    /// foolproof APIs like [`entry`][IndexMap::entry] should be preferred when possible.\n    ///\n    /// Raw entries give mutable access to the keys. This must not be used\n    /// to modify how the key would compare or hash, as the map will not re-evaluate\n    /// where the key should go, meaning the keys may become \"lost\" if their\n    /// location does not reflect their state. For instance, if you change a key\n    /// so that the map now contains keys which compare equal, search may start\n    /// acting erratically, with two keys randomly masking each other. Implementations\n    /// are free to assume this doesn't happen (within the limits of memory-safety).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use core::hash::{BuildHasher, Hash};\n    /// use indexmap::map::{IndexMap, RawEntryApiV1};\n    /// use indexmap::map::raw_entry_v1::RawEntryMut;\n    ///\n    /// let mut map = IndexMap::new();\n    /// map.extend([(\"a\", 100), (\"b\", 200), (\"c\", 300)]);\n    ///\n    /// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n    ///     use core::hash::Hasher;\n    ///     let mut state = hash_builder.build_hasher();\n    ///     key.hash(&mut state);\n    ///     state.finish()\n    /// }\n    ///\n    /// // Existing key (insert and update)\n    /// match map.raw_entry_mut_v1().from_key(\"a\") {\n    ///     RawEntryMut::Vacant(_) => unreachable!(),\n    ///     RawEntryMut::Occupied(mut view) => {\n    ///         assert_eq!(view.index(), 0);\n    ///         assert_eq!(view.get(), &100);\n    ///         let v = view.get_mut();\n    ///         let new_v = (*v) * 10;\n    ///         *v = new_v;\n    ///         assert_eq!(view.insert(1111), 1000);\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(map[\"a\"], 1111);\n    /// assert_eq!(map.len(), 3);\n    ///\n    /// // Existing key (take)\n    /// let hash = compute_hash(map.hasher(), \"c\");\n    /// match map.raw_entry_mut_v1().from_key_hashed_nocheck(hash, \"c\") {\n    ///     RawEntryMut::Vacant(_) => unreachable!(),\n    ///     RawEntryMut::Occupied(view) => {\n    ///         assert_eq!(view.index(), 2);\n    ///         assert_eq!(view.shift_remove_entry(), (\"c\", 300));\n    ///     }\n    /// }\n    /// assert_eq!(map.raw_entry_v1().from_key(\"c\"), None);\n    /// assert_eq!(map.len(), 2);\n    ///\n    /// // Nonexistent key (insert and update)\n    /// let key = \"d\";\n    /// let hash = compute_hash(map.hasher(), key);\n    /// match map.raw_entry_mut_v1().from_hash(hash, |q| *q == key) {\n    ///     RawEntryMut::Occupied(_) => unreachable!(),\n    ///     RawEntryMut::Vacant(view) => {\n    ///         assert_eq!(view.index(), 2);\n    ///         let (k, value) = view.insert(\"d\", 4000);\n    ///         assert_eq!((*k, *value), (\"d\", 4000));\n    ///         *value = 40000;\n    ///     }\n    /// }\n    /// assert_eq!(map[\"d\"], 40000);\n    /// assert_eq!(map.len(), 3);\n    ///\n    /// match map.raw_entry_mut_v1().from_hash(hash, |q| *q == key) {\n    ///     RawEntryMut::Vacant(_) => unreachable!(),\n    ///     RawEntryMut::Occupied(view) => {\n    ///         assert_eq!(view.index(), 2);\n    ///         assert_eq!(view.swap_remove_entry(), (\"d\", 40000));\n    ///     }\n    /// }\n    /// assert_eq!(map.get(\"d\"), None);\n    /// assert_eq!(map.len(), 2);\n    /// ```\n    fn raw_entry_mut_v1(&mut self) -> RawEntryBuilderMut<'_, K, V, S>;\n}",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder": [
            "/// A builder for computing where in an [`IndexMap`] a key-value pair would be stored.\n///\n/// This `struct` is created by the [`IndexMap::raw_entry_v1`] method, provided by the\n/// [`RawEntryApiV1`] trait. See its documentation for more.\npub struct RawEntryBuilder<'a, K, V, S> {\n    map: &'a IndexMap<K, V, S>,\n}",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_hash": [
            "/// Access an entry by hash.\npub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n    where\n        F: FnMut(&K) -> bool,{\n        let map = self.map;\n        let i = self.index_from_hash(hash, is_match)?;\n        map.get_index(i)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_hash_full": [
            "/// Access an entry by hash, including its index.\npub fn from_hash_full<F>(self, hash: u64, is_match: F) -> Option<(usize, &'a K, &'a V)>\n    where\n        F: FnMut(&K) -> bool,{\n        let map = self.map;\n        let i = self.index_from_hash(hash, is_match)?;\n        let (key, value) = map.get_index(i)?;\n        Some((i, key, value))\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_key": [
            "/// Access an entry by key.\npub fn from_key<Q>(self, key: &Q) -> Option<(&'a K, &'a V)>\n    where\n        S: BuildHasher,\n        Q: ?Sized + Hash + Equivalent<K>,{\n        self.map.get_key_value(key)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_key_hashed_nocheck": [
            "/// Access an entry by a key and its hash.\npub fn from_key_hashed_nocheck<Q>(self, hash: u64, key: &Q) -> Option<(&'a K, &'a V)>\n    where\n        Q: ?Sized + Equivalent<K>,{\n        let hash = HashValue(hash as usize);\n        let i = self.map.core.get_index_of(hash, key)?;\n        self.map.get_index(i)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::index_from_hash": [
            "/// Access the index of an entry by hash.\npub fn index_from_hash<F>(self, hash: u64, mut is_match: F) -> Option<usize>\n    where\n        F: FnMut(&K) -> bool,{\n        let hash = HashValue(hash as usize);\n        let entries = &*self.map.core.entries;\n        let eq = move |&i: &usize| is_match(&entries[i].key);\n        self.map.core.indices.find(hash.get(), eq).copied()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut": [
            "/// A builder for computing where in an [`IndexMap`] a key-value pair would be stored.\n///\n/// This `struct` is created by the [`IndexMap::raw_entry_mut_v1`] method, provided by the\n/// [`RawEntryApiV1`] trait. See its documentation for more.\npub struct RawEntryBuilderMut<'a, K, V, S> {\n    map: &'a mut IndexMap<K, V, S>,\n}",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_hash": [
            "/// Access an entry by hash.\npub fn from_hash<F>(self, hash: u64, mut is_match: F) -> RawEntryMut<'a, K, V, S>\n    where\n        F: FnMut(&K) -> bool,{\n        let ref_entries = &*self.map.core.entries;\n        let eq = move |&i: &usize| is_match(&ref_entries[i].key);\n        match self.map.core.indices.find_entry(hash, eq) {\n            Ok(index) => RawEntryMut::Occupied(RawOccupiedEntryMut {\n                entries: &mut self.map.core.entries,\n                index,\n                hash_builder: PhantomData,\n            }),\n            Err(absent) => RawEntryMut::Vacant(RawVacantEntryMut {\n                map: RefMut::new(absent.into_table(), &mut self.map.core.entries),\n                hash_builder: &self.map.hash_builder,\n            }),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_key": [
            "/// Access an entry by key.\npub fn from_key<Q>(self, key: &Q) -> RawEntryMut<'a, K, V, S>\n    where\n        S: BuildHasher,\n        Q: ?Sized + Hash + Equivalent<K>,{\n        let hash = self.map.hash(key);\n        self.from_key_hashed_nocheck(hash.get(), key)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_key_hashed_nocheck": [
            "/// Access an entry by a key and its hash.\npub fn from_key_hashed_nocheck<Q>(self, hash: u64, key: &Q) -> RawEntryMut<'a, K, V, S>\n    where\n        Q: ?Sized + Equivalent<K>,{\n        self.from_hash(hash, |k| Q::equivalent(key, k))\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryMut": [
            "/// Raw entry for an existing key-value pair or a vacant location to\n/// insert one.\npub enum RawEntryMut<'a, K, V, S> {\n    /// Existing slot with equivalent key.\n    Occupied(RawOccupiedEntryMut<'a, K, V, S>),\n    /// Vacant slot (no equivalent key in the map).\n    Vacant(RawVacantEntryMut<'a, K, V, S>),\n}",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::and_modify": [
            "/// Modifies the entry if it is occupied.\npub fn and_modify<F>(mut self, f: F) -> Self\n    where\n        F: FnOnce(&mut K, &mut V),{\n        if let Self::Occupied(entry) = &mut self {\n            let (k, v) = entry.get_key_value_mut();\n            f(k, v);\n        }\n        self\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::index": [
            "/// Return the index where the key-value pair exists or may be inserted.\n#[inline]\npub fn index(&self) -> usize{\n        match self {\n            Self::Occupied(entry) => entry.index(),\n            Self::Vacant(entry) => entry.index(),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::or_insert": [
            "/// Inserts the given default key and value in the entry if it is vacant and returns mutable\n/// references to them. Otherwise mutable references to an already existent pair are returned.\npub fn or_insert(self, default_key: K, default_value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,{\n        match self {\n            Self::Occupied(entry) => entry.into_key_value_mut(),\n            Self::Vacant(entry) => entry.insert(default_key, default_value),\n        }\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::or_insert_with": [
            "/// Inserts the result of the `call` function in the entry if it is vacant and returns mutable\n/// references to them. Otherwise mutable references to an already existent pair are returned.\npub fn or_insert_with<F>(self, call: F) -> (&'a mut K, &'a mut V)\n    where\n        F: FnOnce() -> (K, V),\n        K: Hash,\n        S: BuildHasher,{\n        match self {\n            Self::Occupied(entry) => entry.into_key_value_mut(),\n            Self::Vacant(entry) => {\n                let (key, value) = call();\n                entry.insert(key, value)\n            }\n        }\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut": [
            "/// A raw view into an occupied entry in an [`IndexMap`].\n/// It is part of the [`RawEntryMut`] enum.\npub struct RawOccupiedEntryMut<'a, K, V, S> {\n    entries: &'a mut Entries<K, V>,\n    index: hash_table::OccupiedEntry<'a, usize>,\n    hash_builder: PhantomData<&'a S>,\n}",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get": [
            "/// Gets a reference to the entry's value in the map.\npub fn get(&self) -> &V{\n        &self.entries[self.index()].value\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_key_value": [
            "/// Gets a reference to the entry's key and value in the map.\npub fn get_key_value(&self) -> (&K, &V){\n        self.entries[self.index()].refs()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_key_value_mut": [
            "/// Gets a reference to the entry's key and value in the map.\npub fn get_key_value_mut(&mut self) -> (&mut K, &mut V){\n        let index = self.index();\n        self.entries[index].muts()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_mut": [
            "/// Gets a mutable reference to the entry's value in the map.\n///\n/// If you need a reference which may outlive the destruction of the\n/// [`RawEntryMut`] value, see [`into_mut`][Self::into_mut].\npub fn get_mut(&mut self) -> &mut V{\n        let index = self.index();\n        &mut self.entries[index].value\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::index": [
            "/// Return the index of the key-value pair\n#[inline]\npub fn index(&self) -> usize{\n        *self.index.get()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::insert": [
            "/// Sets the value of the entry, and returns the entry's old value.\npub fn insert(&mut self, value: V) -> V{\n        mem::replace(self.get_mut(), value)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::insert_key": [
            "/// Sets the key of the entry, and returns the entry's old key.\npub fn insert_key(&mut self, key: K) -> K{\n        mem::replace(self.key_mut(), key)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_key": [
            "/// Converts into a mutable reference to the entry's key in the map,\n/// with a lifetime bound to the map itself.\n///\n/// Note that this is not the key that was used to find the entry. There may be an observable\n/// difference if the key type has any distinguishing features outside of `Hash` and `Eq`, like\n/// extra fields or the memory address of an allocation.\npub fn into_key(self) -> &'a mut K{\n        let index = self.index();\n        &mut self.entries[index].key\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_key_value_mut": [
            "/// Converts into a mutable reference to the entry's key and value in the map,\n/// with a lifetime bound to the map itself.\npub fn into_key_value_mut(self) -> (&'a mut K, &'a mut V){\n        let index = self.index();\n        self.entries[index].muts()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_mut": [
            "/// Converts into a mutable reference to the entry's value in the map,\n/// with a lifetime bound to the map itself.\npub fn into_mut(self) -> &'a mut V{\n        let index = self.index();\n        &mut self.entries[index].value\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_ref_mut": [
            "#[inline]\nfn into_ref_mut(self) -> RefMut<'a, K, V>{\n        RefMut::new(self.index.into_table(), self.entries)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::key": [
            "/// Gets a reference to the entry's key in the map.\n///\n/// Note that this is not the key that was used to find the entry. There may be an observable\n/// difference if the key type has any distinguishing features outside of `Hash` and `Eq`, like\n/// extra fields or the memory address of an allocation.\npub fn key(&self) -> &K{\n        &self.entries[self.index()].key\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::key_mut": [
            "/// Gets a mutable reference to the entry's key in the map.\n///\n/// Note that this is not the key that was used to find the entry. There may be an observable\n/// difference if the key type has any distinguishing features outside of `Hash` and `Eq`, like\n/// extra fields or the memory address of an allocation.\npub fn key_mut(&mut self) -> &mut K{\n        let index = self.index();\n        &mut self.entries[index].key\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::move_index": [
            "/// Moves the position of the entry to a new index\n/// by shifting all other entries in-between.\n///\n/// This is equivalent to [`IndexMap::move_index`]\n/// coming `from` the current [`.index()`][Self::index].\n///\n/// * If `self.index() < to`, the other pairs will shift down while the targeted pair moves up.\n/// * If `self.index() > to`, the other pairs will shift up while the targeted pair moves down.\n///\n/// ***Panics*** if `to` is out of bounds.\n///\n/// Computes in **O(n)** time (average).\npub fn move_index(self, to: usize){\n        let index = self.index();\n        self.into_ref_mut().move_index(index, to);\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::remove": [
            "/// Remove the key, value pair stored in the map for this entry, and return the value.\n///\n/// **NOTE:** This is equivalent to [`.swap_remove()`][Self::swap_remove], replacing this\n/// entry's position with the last element, and it is deprecated in favor of calling that\n/// explicitly. If you need to preserve the relative order of the keys in the map, use\n/// [`.shift_remove()`][Self::shift_remove] instead.\n#[deprecated(note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\")]\npub fn remove(self) -> V{\n        self.swap_remove()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::remove_entry": [
            "/// Remove and return the key, value pair stored in the map for this entry\n///\n/// **NOTE:** This is equivalent to [`.swap_remove_entry()`][Self::swap_remove_entry],\n/// replacing this entry's position with the last element, and it is deprecated in favor of\n/// calling that explicitly. If you need to preserve the relative order of the keys in the map,\n/// use [`.shift_remove_entry()`][Self::shift_remove_entry] instead.\n#[deprecated(note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\")]\npub fn remove_entry(self) -> (K, V){\n        self.swap_remove_entry()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::shift_remove": [
            "/// Remove the key, value pair stored in the map for this entry, and return the value.\n///\n/// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove(self) -> V{\n        self.shift_remove_entry().1\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::shift_remove_entry": [
            "/// Remove and return the key, value pair stored in the map for this entry\n///\n/// Like [`Vec::remove`][crate::Vec::remove], the pair is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove_entry(self) -> (K, V){\n        let (index, entry) = self.index.remove();\n        RefMut::new(entry.into_table(), self.entries).shift_remove_finish(index)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_indices": [
            "/// Swaps the position of entry with another.\n///\n/// This is equivalent to [`IndexMap::swap_indices`]\n/// with the current [`.index()`][Self::index] as one of the two being swapped.\n///\n/// ***Panics*** if the `other` index is out of bounds.\n///\n/// Computes in **O(1)** time (average).\npub fn swap_indices(self, other: usize){\n        let index = self.index();\n        self.into_ref_mut().swap_indices(index, other);\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_remove": [
            "/// Remove the key, value pair stored in the map for this entry, and return the value.\n///\n/// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n/// the last element of the map and popping it off.\n/// **This perturbs the position of what used to be the last element!**\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove(self) -> V{\n        self.swap_remove_entry().1\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_remove_entry": [
            "/// Remove and return the key, value pair stored in the map for this entry\n///\n/// Like [`Vec::swap_remove`][crate::Vec::swap_remove], the pair is removed by swapping it with\n/// the last element of the map and popping it off.\n/// **This perturbs the position of what used to be the last element!**\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove_entry(self) -> (K, V){\n        let (index, entry) = self.index.remove();\n        RefMut::new(entry.into_table(), self.entries).swap_remove_finish(index)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut": [
            "/// A view into a vacant raw entry in an [`IndexMap`].\n/// It is part of the [`RawEntryMut`] enum.\npub struct RawVacantEntryMut<'a, K, V, S> {\n    map: RefMut<'a, K, V>,\n    hash_builder: &'a S,\n}",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::index": [
            "/// Return the index where a key-value pair may be inserted.\npub fn index(&self) -> usize{\n        self.map.indices.len()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::insert": [
            "/// Inserts the given key and value into the map,\n/// and returns mutable references to them.\npub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,{\n        let mut h = self.hash_builder.build_hasher();\n        key.hash(&mut h);\n        self.insert_hashed_nocheck(h.finish(), key, value)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::insert_hashed_nocheck": [
            "/// Inserts the given key and value into the map with the provided hash,\n/// and returns mutable references to them.\npub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V){\n        let hash = HashValue(hash as usize);\n        self.map.insert_unique(hash, key, value).into_muts()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::shift_insert": [
            "/// Inserts the given key and value into the map at the given index,\n/// shifting others to the right, and returns mutable references to them.\n///\n/// ***Panics*** if `index` is out of bounds.\n///\n/// Computes in **O(n)** time (average).\npub fn shift_insert(self, index: usize, key: K, value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,{\n        let mut h = self.hash_builder.build_hasher();\n        key.hash(&mut h);\n        self.shift_insert_hashed_nocheck(index, h.finish(), key, value)\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::shift_insert_hashed_nocheck": [
            "/// Inserts the given key and value into the map with the provided hash\n/// at the given index, and returns mutable references to them.\n///\n/// ***Panics*** if `index` is out of bounds.\n///\n/// Computes in **O(n)** time (average).\npub fn shift_insert_hashed_nocheck(\n        mut self,\n        index: usize,\n        hash: u64,\n        key: K,\n        value: V,\n    ) -> (&'a mut K, &'a mut V){\n        let hash = HashValue(hash as usize);\n        self.map.shift_insert_unique(index, hash, key, value);\n        self.map.entries[index].muts()\n    }",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::raw_entry_v1::private::Sealed": [
            "pub trait Sealed {}",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))"
        ],
        "map::core::reserve_entries": [
            "/// Reserve entries capacity, rounded up to match the indices (via `try_capacity`).\nfn reserve_entries<K, V>(entries: &mut Entries<K, V>, additional: usize, try_capacity: usize){\n    // Use a soft-limit on the maximum capacity, but if the caller explicitly\n    // requested more, do it and let them have the resulting panic.\n    let try_capacity = try_capacity.min(IndexMapCore::<K, V>::MAX_ENTRIES_CAPACITY);\n    let try_add = try_capacity - entries.len();\n    if try_add > additional && entries.try_reserve_exact(try_add).is_ok() {\n        return;\n    }\n    entries.reserve_exact(additional);\n}",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::core::update_index": [
            "#[inline]\nfn update_index(table: &mut Indices, hash: HashValue, old: usize, new: usize){\n    let index = table\n        .find_mut(hash.get(), move |&i| i == old)\n        .expect(\"index not found\");\n    *index = new;\n}",
            "Real(LocalPath(\"src/map/core.rs\"))"
        ],
        "map::iter::<impl core::iter::IntoIterator for &'a map::IndexMap<K, V, S>>::into_iter": [
            "fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::<impl core::iter::IntoIterator for &'a mut map::IndexMap<K, V, S>>::into_iter": [
            "fn into_iter(self) -> Self::IntoIter{\n        self.iter_mut()\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::<impl core::iter::IntoIterator for map::IndexMap<K, V, S>>::into_iter": [
            "fn into_iter(self) -> Self::IntoIter{\n        IntoIter::new(self.into_entries())\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Drain": [
            "/// A draining iterator over the entries of an [`IndexMap`].\n///\n/// This `struct` is created by the [`IndexMap::drain`] method.\n/// See its documentation for more.\npub struct Drain<'a, K, V> {\n    iter: vec::Drain<'a, Bucket<K, V>>,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Drain::<'a, K, V>::as_slice": [
            "/// Returns a slice of the remaining entries in the iterator.\npub fn as_slice(&self) -> &Slice<K, V>{\n        Slice::from_slice(self.iter.as_slice())\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Drain::<'a, K, V>::new": [
            "pub(super) fn new(iter: vec::Drain<'a, Bucket<K, V>>) -> Self{\n        Self { iter }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IntoIter": [
            "/// An owning iterator over the entries of an [`IndexMap`].\n///\n/// This `struct` is created by the [`IndexMap::into_iter`] method\n/// (provided by the [`IntoIterator`] trait). See its documentation for more.\npub struct IntoIter<K, V> {\n    iter: vec::IntoIter<Bucket<K, V>>,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IntoIter::<K, V>::as_mut_slice": [
            "/// Returns a mutable slice of the remaining entries in the iterator.\npub fn as_mut_slice(&mut self) -> &mut Slice<K, V>{\n        Slice::from_mut_slice(self.iter.as_mut_slice())\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IntoIter::<K, V>::as_slice": [
            "/// Returns a slice of the remaining entries in the iterator.\npub fn as_slice(&self) -> &Slice<K, V>{\n        Slice::from_slice(self.iter.as_slice())\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IntoIter::<K, V>::new": [
            "pub(super) fn new(entries: Vec<Bucket<K, V>>) -> Self{\n        Self {\n            iter: entries.into_iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IntoKeys": [
            "/// An owning iterator over the keys of an [`IndexMap`].\n///\n/// This `struct` is created by the [`IndexMap::into_keys`] method.\n/// See its documentation for more.\npub struct IntoKeys<K, V> {\n    iter: vec::IntoIter<Bucket<K, V>>,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IntoKeys::<K, V>::new": [
            "pub(super) fn new(entries: Vec<Bucket<K, V>>) -> Self{\n        Self {\n            iter: entries.into_iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IntoValues": [
            "/// An owning iterator over the values of an [`IndexMap`].\n///\n/// This `struct` is created by the [`IndexMap::into_values`] method.\n/// See its documentation for more.\npub struct IntoValues<K, V> {\n    iter: vec::IntoIter<Bucket<K, V>>,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IntoValues::<K, V>::new": [
            "pub(super) fn new(entries: Vec<Bucket<K, V>>) -> Self{\n        Self {\n            iter: entries.into_iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Iter": [
            "/// An iterator over the entries of an [`IndexMap`].\n///\n/// This `struct` is created by the [`IndexMap::iter`] method.\n/// See its documentation for more.\npub struct Iter<'a, K, V> {\n    iter: slice::Iter<'a, Bucket<K, V>>,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Iter::<'a, K, V>::as_slice": [
            "/// Returns a slice of the remaining entries in the iterator.\npub fn as_slice(&self) -> &'a Slice<K, V>{\n        Slice::from_slice(self.iter.as_slice())\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Iter::<'a, K, V>::new": [
            "pub(super) fn new(entries: &'a [Bucket<K, V>]) -> Self{\n        Self {\n            iter: entries.iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IterMut": [
            "/// A mutable iterator over the entries of an [`IndexMap`].\n///\n/// This `struct` is created by the [`IndexMap::iter_mut`] method.\n/// See its documentation for more.\npub struct IterMut<'a, K, V> {\n    iter: slice::IterMut<'a, Bucket<K, V>>,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IterMut2": [
            "/// A mutable iterator over the entries of an [`IndexMap`].\n///\n/// This `struct` is created by the [`MutableKeys::iter_mut2`][super::MutableKeys::iter_mut2] method.\n/// See its documentation for more.\npub struct IterMut2<'a, K, V> {\n    iter: slice::IterMut<'a, Bucket<K, V>>,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IterMut2::<'a, K, V>::as_slice": [
            "/// Returns a slice of the remaining entries in the iterator.\npub fn as_slice(&self) -> &Slice<K, V>{\n        Slice::from_slice(self.iter.as_slice())\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IterMut2::<'a, K, V>::into_slice": [
            "/// Returns a mutable slice of the remaining entries in the iterator.\n///\n/// To avoid creating `&mut` references that alias, this is forced to consume the iterator.\npub fn into_slice(self) -> &'a mut Slice<K, V>{\n        Slice::from_mut_slice(self.iter.into_slice())\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IterMut2::<'a, K, V>::new": [
            "pub(super) fn new(entries: &'a mut [Bucket<K, V>]) -> Self{\n        Self {\n            iter: entries.iter_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IterMut::<'a, K, V>::as_slice": [
            "/// Returns a slice of the remaining entries in the iterator.\npub fn as_slice(&self) -> &Slice<K, V>{\n        Slice::from_slice(self.iter.as_slice())\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IterMut::<'a, K, V>::into_slice": [
            "/// Returns a mutable slice of the remaining entries in the iterator.\n///\n/// To avoid creating `&mut` references that alias, this is forced to consume the iterator.\npub fn into_slice(self) -> &'a mut Slice<K, V>{\n        Slice::from_mut_slice(self.iter.into_slice())\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::IterMut::<'a, K, V>::new": [
            "pub(super) fn new(entries: &'a mut [Bucket<K, V>]) -> Self{\n        Self {\n            iter: entries.iter_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Keys": [
            "/// An iterator over the keys of an [`IndexMap`].\n///\n/// This `struct` is created by the [`IndexMap::keys`] method.\n/// See its documentation for more.\npub struct Keys<'a, K, V> {\n    iter: slice::Iter<'a, Bucket<K, V>>,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Keys::<'a, K, V>::new": [
            "pub(super) fn new(entries: &'a [Bucket<K, V>]) -> Self{\n        Self {\n            iter: entries.iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Splice": [
            "/// A splicing iterator for `IndexMap`.\n///\n/// This `struct` is created by [`IndexMap::splice()`].\n/// See its documentation for more.\npub struct Splice<'a, I, K, V, S>\nwhere\n    I: Iterator<Item = (K, V)>,\n    K: Hash + Eq,\n    S: BuildHasher,\n{\n    map: &'a mut IndexMap<K, V, S>,\n    tail: IndexMapCore<K, V>,\n    drain: vec::IntoIter<Bucket<K, V>>,\n    replace_with: I,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Splice::<'a, I, K, V, S>::new": [
            "#[track_caller]\npub(super) fn new<R>(map: &'a mut IndexMap<K, V, S>, range: R, replace_with: I) -> Self\n    where\n        R: RangeBounds<usize>,{\n        let (tail, drain) = map.core.split_splice(range);\n        Self {\n            map,\n            tail,\n            drain,\n            replace_with,\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Values": [
            "/// An iterator over the values of an [`IndexMap`].\n///\n/// This `struct` is created by the [`IndexMap::values`] method.\n/// See its documentation for more.\npub struct Values<'a, K, V> {\n    iter: slice::Iter<'a, Bucket<K, V>>,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::Values::<'a, K, V>::new": [
            "pub(super) fn new(entries: &'a [Bucket<K, V>]) -> Self{\n        Self {\n            iter: entries.iter(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::ValuesMut": [
            "/// A mutable iterator over the values of an [`IndexMap`].\n///\n/// This `struct` is created by the [`IndexMap::values_mut`] method.\n/// See its documentation for more.\npub struct ValuesMut<'a, K, V> {\n    iter: slice::IterMut<'a, Bucket<K, V>>,\n}",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::iter::ValuesMut::<'a, K, V>::new": [
            "pub(super) fn new(entries: &'a mut [Bucket<K, V>]) -> Self{\n        Self {\n            iter: entries.iter_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/map/iter.rs\"))"
        ],
        "map::mutable::MutableEntryKey": [
            "/// Opt-in mutable access to [`Entry`] keys.\n///\n/// These methods expose `&mut K`, mutable references to the key as it is stored\n/// in the map.\n/// You are allowed to modify the keys in the map **if the modification\n/// does not change the keys hash and equality**.\n///\n/// If keys are modified erroneously, you can no longer look them up.\n/// This is sound (memory safe) but a logical error hazard (just like\n/// implementing `PartialEq`, `Eq`, or `Hash` incorrectly would be).\n///\n/// `use` this trait to enable its methods for `Entry`.\n///\n/// This trait is sealed and cannot be implemented for types outside this crate.\npub trait MutableEntryKey: private::Sealed {\n    type Key;\n\n    /// Gets a mutable reference to the entry's key, either within the map if occupied,\n    /// or else the new key that was used to find the entry.\n    fn key_mut(&mut self) -> &mut Self::Key;\n}",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "map::mutable::MutableKeys": [
            "/// Opt-in mutable access to [`IndexMap`] keys.\n///\n/// These methods expose `&mut K`, mutable references to the key as it is stored\n/// in the map.\n/// You are allowed to modify the keys in the map **if the modification\n/// does not change the keys hash and equality**.\n///\n/// If keys are modified erroneously, you can no longer look them up.\n/// This is sound (memory safe) but a logical error hazard (just like\n/// implementing `PartialEq`, `Eq`, or `Hash` incorrectly would be).\n///\n/// `use` this trait to enable its methods for `IndexMap`.\n///\n/// This trait is sealed and cannot be implemented for types outside this crate.\npub trait MutableKeys: private::Sealed {\n    type Key;\n    type Value;\n\n    /// Return item index, mutable reference to key and value\n    ///\n    /// Computes in **O(1)** time (average).\n    fn get_full_mut2<Q>(&mut self, key: &Q) -> Option<(usize, &mut Self::Key, &mut Self::Value)>\n    where\n        Q: ?Sized + Hash + Equivalent<Self::Key>;\n\n    /// Return mutable reference to key and value at an index.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Computes in **O(1)** time.\n    fn get_index_mut2(&mut self, index: usize) -> Option<(&mut Self::Key, &mut Self::Value)>;\n\n    /// Return an iterator over the key-value pairs of the map, in their order\n    fn iter_mut2(&mut self) -> IterMut2<'_, Self::Key, Self::Value>;\n\n    /// Scan through each key-value pair in the map and keep those where the\n    /// closure `keep` returns `true`.\n    ///\n    /// The elements are visited in order, and remaining elements keep their\n    /// order.\n    ///\n    /// Computes in **O(n)** time (average).\n    fn retain2<F>(&mut self, keep: F)\n    where\n        F: FnMut(&mut Self::Key, &mut Self::Value) -> bool;\n}",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "map::mutable::private::Sealed": [
            "pub trait Sealed {}",
            "Real(LocalPath(\"src/map/mutable.rs\"))"
        ],
        "map::slice::<impl core::clone::Clone for alloc::boxed::Box<map::slice::Slice<K, V>>>::clone": [
            "fn clone(&self) -> Self{\n        Slice::from_boxed(self.entries.to_vec().into_boxed_slice())\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::cmp::PartialEq<map::slice::Slice<K2, V2>> for [(K, V); N]>::eq": [
            "fn eq(&self, other: &Slice<K2, V2>) -> bool{\n        <[_] as PartialEq<_>>::eq(self, other)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::cmp::PartialEq<map::slice::Slice<K2, V2>> for [(K, V)]>::eq": [
            "fn eq(&self, other: &Slice<K2, V2>) -> bool{\n        slice_eq(self, &other.entries, |t, b| t.0 == b.key && t.1 == b.value)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::convert::From<&map::slice::Slice<K, V>> for alloc::boxed::Box<map::slice::Slice<K, V>>>::from": [
            "fn from(slice: &Slice<K, V>) -> Self{\n        Slice::from_boxed(Box::from(&slice.entries))\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::default::Default for alloc::boxed::Box<map::slice::Slice<K, V>>>::default": [
            "fn default() -> Self{\n        Slice::from_boxed(Box::default())\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::iter::IntoIterator for alloc::boxed::Box<map::slice::Slice<K, V>>>::into_iter": [
            "fn into_iter(self) -> Self::IntoIter{\n        IntoIter::new(self.into_entries())\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for map::IndexMap<K, V, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::Index<core::ops::Range<usize>> for map::IndexMap<K, V, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeFrom<usize>> for map::IndexMap<K, V, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeFull> for map::IndexMap<K, V, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeInclusive<usize>> for map::IndexMap<K, V, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeTo<usize>> for map::IndexMap<K, V, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeToInclusive<usize>> for map::IndexMap<K, V, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::IndexMut<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for map::IndexMap<K, V, S>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self::Output{\n                Slice::from_mut_slice(&mut self.as_entries_mut()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::Range<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self::Output{\n                Slice::from_mut_slice(&mut self.as_entries_mut()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeFrom<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self::Output{\n                Slice::from_mut_slice(&mut self.as_entries_mut()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeFull> for map::IndexMap<K, V, S>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self::Output{\n                Slice::from_mut_slice(&mut self.as_entries_mut()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeInclusive<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self::Output{\n                Slice::from_mut_slice(&mut self.as_entries_mut()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeTo<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self::Output{\n                Slice::from_mut_slice(&mut self.as_entries_mut()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeToInclusive<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "fn index_mut(&mut self, range: $range) -> &mut Self::Output{\n                Slice::from_mut_slice(&mut self.as_entries_mut()[range])\n            }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice": [
            "/// A dynamically-sized slice of key-value pairs in an [`IndexMap`].\n///\n/// This supports indexed operations much like a `[(K, V)]` slice,\n/// but not any hashed operations on the map keys.\n///\n/// Unlike `IndexMap`, `Slice` does consider the order for [`PartialEq`]\n/// and [`Eq`], and it also implements [`PartialOrd`], [`Ord`], and [`Hash`].\n#[repr(transparent)]\npub struct Slice<K, V> {\n    pub(crate) entries: [Bucket<K, V>],\n}",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::binary_search_by": [
            "/// Search over a sorted map with a comparator function.\n///\n/// Returns the position where that value is present, or the position where it can be inserted\n/// to maintain the sort. See [`slice::binary_search_by`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[inline]\npub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a K, &'a V) -> Ordering,{\n        self.entries.binary_search_by(move |a| f(&a.key, &a.value))\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::binary_search_by_key": [
            "/// Search over a sorted map with an extraction function.\n///\n/// Returns the position where that value is present, or the position where it can be inserted\n/// to maintain the sort. See [`slice::binary_search_by_key`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[inline]\npub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a K, &'a V) -> B,\n        B: Ord,{\n        self.binary_search_by(|k, v| f(k, v).cmp(b))\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::binary_search_keys": [
            "/// Search over a sorted map for a key.\n///\n/// Returns the position where that key is present, or the position where it can be inserted to\n/// maintain the sort. See [`slice::binary_search`] for more details.\n///\n/// Computes in **O(log(n))** time, which is notably less scalable than looking the key up in\n/// the map this is a slice from using [`IndexMap::get_index_of`], but this can also position\n/// missing keys.\npub fn binary_search_keys(&self, x: &K) -> Result<usize, usize>\n    where\n        K: Ord,{\n        self.binary_search_by(|p, _| p.cmp(x))\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::first": [
            "/// Get the first key-value pair.\npub fn first(&self) -> Option<(&K, &V)>{\n        self.entries.first().map(Bucket::refs)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::first_mut": [
            "/// Get the first key-value pair, with mutable access to the value.\npub fn first_mut(&mut self) -> Option<(&K, &mut V)>{\n        self.entries.first_mut().map(Bucket::ref_mut)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::from_boxed": [
            "pub(super) fn from_boxed(entries: Box<[Bucket<K, V>]>) -> Box<Self>{\n        unsafe { Box::from_raw(Box::into_raw(entries) as *mut Self) }\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::from_mut_slice": [
            "pub(super) fn from_mut_slice(entries: &mut [Bucket<K, V>]) -> &mut Self{\n        unsafe { &mut *(entries as *mut [Bucket<K, V>] as *mut Self) }\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::from_slice": [
            "pub(super) const fn from_slice(entries: &[Bucket<K, V>]) -> &Self{\n        unsafe { &*(entries as *const [Bucket<K, V>] as *const Self) }\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::get_disjoint_mut": [
            "/// Get an array of `N` key-value pairs by `N` indices\n///\n/// Valid indices are *0 <= index < self.len()* and each index needs to be unique.\npub fn get_disjoint_mut<const N: usize>(\n        &mut self,\n        indices: [usize; N],\n    ) -> Result<[(&K, &mut V); N], GetDisjointMutError>{\n        let indices = indices.map(Some);\n        let key_values = self.get_disjoint_opt_mut(indices)?;\n        Ok(key_values.map(Option::unwrap))\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::get_disjoint_opt_mut": [
            "#[allow(unsafe_code)]\npub(crate) fn get_disjoint_opt_mut<const N: usize>(\n        &mut self,\n        indices: [Option<usize>; N],\n    ) -> Result<[Option<(&K, &mut V)>; N], GetDisjointMutError>{\n        // SAFETY: Can't allow duplicate indices as we would return several mutable refs to the same data.\n        let len = self.len();\n        for i in 0..N {\n            if let Some(idx) = indices[i] {\n                if idx >= len {\n                    return Err(GetDisjointMutError::IndexOutOfBounds);\n                } else if indices[..i].contains(&Some(idx)) {\n                    return Err(GetDisjointMutError::OverlappingIndices);\n                }\n            }\n        }\n\n        let entries_ptr = self.entries.as_mut_ptr();\n        let out = indices.map(|idx_opt| {\n            match idx_opt {\n                Some(idx) => {\n                    // SAFETY: The base pointer is valid as it comes from a slice and the reference is always\n                    // in-bounds & unique as we've already checked the indices above.\n                    let kv = unsafe { (*(entries_ptr.add(idx))).ref_mut() };\n                    Some(kv)\n                }\n                None => None,\n            }\n        });\n\n        Ok(out)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::get_index": [
            "/// Get a key-value pair by index.\n///\n/// Valid indices are `0 <= index < self.len()`.\npub fn get_index(&self, index: usize) -> Option<(&K, &V)>{\n        self.entries.get(index).map(Bucket::refs)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::get_index_mut": [
            "/// Get a key-value pair by index, with mutable access to the value.\n///\n/// Valid indices are `0 <= index < self.len()`.\npub fn get_index_mut(&mut self, index: usize) -> Option<(&K, &mut V)>{\n        self.entries.get_mut(index).map(Bucket::ref_mut)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::get_range": [
            "/// Returns a slice of key-value pairs in the given range of indices.\n///\n/// Valid indices are `0 <= index < self.len()`.\npub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Self>{\n        let range = try_simplify_range(range, self.entries.len())?;\n        self.entries.get(range).map(Slice::from_slice)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::get_range_mut": [
            "/// Returns a mutable slice of key-value pairs in the given range of indices.\n///\n/// Valid indices are `0 <= index < self.len()`.\npub fn get_range_mut<R: RangeBounds<usize>>(&mut self, range: R) -> Option<&mut Self>{\n        let range = try_simplify_range(range, self.entries.len())?;\n        self.entries.get_mut(range).map(Slice::from_mut_slice)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::into_boxed": [
            "fn into_boxed(self: Box<Self>) -> Box<[Bucket<K, V>]>{\n        unsafe { Box::from_raw(Box::into_raw(self) as *mut [Bucket<K, V>]) }\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::into_entries": [
            "pub(crate) fn into_entries(self: Box<Self>) -> Vec<Bucket<K, V>>{\n        self.into_boxed().into_vec()\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::into_keys": [
            "/// Return an owning iterator over the keys of the map slice.\npub fn into_keys(self: Box<Self>) -> IntoKeys<K, V>{\n        IntoKeys::new(self.into_entries())\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::into_values": [
            "/// Return an owning iterator over the values of the map slice.\npub fn into_values(self: Box<Self>) -> IntoValues<K, V>{\n        IntoValues::new(self.into_entries())\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::is_empty": [
            "/// Returns true if the map slice contains no elements.\n#[inline]\npub const fn is_empty(&self) -> bool{\n        self.entries.is_empty()\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::iter": [
            "/// Return an iterator over the key-value pairs of the map slice.\npub fn iter(&self) -> Iter<'_, K, V>{\n        Iter::new(&self.entries)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::iter_mut": [
            "/// Return an iterator over the key-value pairs of the map slice.\npub fn iter_mut(&mut self) -> IterMut<'_, K, V>{\n        IterMut::new(&mut self.entries)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::keys": [
            "/// Return an iterator over the keys of the map slice.\npub fn keys(&self) -> Keys<'_, K, V>{\n        Keys::new(&self.entries)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::last": [
            "/// Get the last key-value pair.\npub fn last(&self) -> Option<(&K, &V)>{\n        self.entries.last().map(Bucket::refs)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::last_mut": [
            "/// Get the last key-value pair, with mutable access to the value.\npub fn last_mut(&mut self) -> Option<(&K, &mut V)>{\n        self.entries.last_mut().map(Bucket::ref_mut)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::len": [
            "/// Return the number of key-value pairs in the map slice.\n#[inline]\npub const fn len(&self) -> usize{\n        self.entries.len()\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::new": [
            "/// Returns an empty slice.\npub const fn new<'a>() -> &'a Self{\n        Self::from_slice(&[])\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::new_mut": [
            "/// Returns an empty mutable slice.\npub fn new_mut<'a>() -> &'a mut Self{\n        Self::from_mut_slice(&mut [])\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::partition_point": [
            "/// Returns the index of the partition point of a sorted map according to the given predicate\n/// (the index of the first element of the second partition).\n///\n/// See [`slice::partition_point`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[must_use]\npub fn partition_point<P>(&self, mut pred: P) -> usize\n    where\n        P: FnMut(&K, &V) -> bool,{\n        self.entries\n            .partition_point(move |a| pred(&a.key, &a.value))\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::split_at": [
            "/// Divides one slice into two at an index.\n///\n/// ***Panics*** if `index > len`.\npub fn split_at(&self, index: usize) -> (&Self, &Self){\n        let (first, second) = self.entries.split_at(index);\n        (Self::from_slice(first), Self::from_slice(second))\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::split_at_mut": [
            "/// Divides one mutable slice into two at an index.\n///\n/// ***Panics*** if `index > len`.\npub fn split_at_mut(&mut self, index: usize) -> (&mut Self, &mut Self){\n        let (first, second) = self.entries.split_at_mut(index);\n        (Self::from_mut_slice(first), Self::from_mut_slice(second))\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::split_first": [
            "/// Returns the first key-value pair and the rest of the slice,\n/// or `None` if it is empty.\npub fn split_first(&self) -> Option<((&K, &V), &Self)>{\n        if let [first, rest @ ..] = &self.entries {\n            Some((first.refs(), Self::from_slice(rest)))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::split_first_mut": [
            "/// Returns the first key-value pair and the rest of the slice,\n/// with mutable access to the value, or `None` if it is empty.\npub fn split_first_mut(&mut self) -> Option<((&K, &mut V), &mut Self)>{\n        if let [first, rest @ ..] = &mut self.entries {\n            Some((first.ref_mut(), Self::from_mut_slice(rest)))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::split_last": [
            "/// Returns the last key-value pair and the rest of the slice,\n/// or `None` if it is empty.\npub fn split_last(&self) -> Option<((&K, &V), &Self)>{\n        if let [rest @ .., last] = &self.entries {\n            Some((last.refs(), Self::from_slice(rest)))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::split_last_mut": [
            "/// Returns the last key-value pair and the rest of the slice,\n/// with mutable access to the value, or `None` if it is empty.\npub fn split_last_mut(&mut self) -> Option<((&K, &mut V), &mut Self)>{\n        if let [rest @ .., last] = &mut self.entries {\n            Some((last.ref_mut(), Self::from_mut_slice(rest)))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::values": [
            "/// Return an iterator over the values of the map slice.\npub fn values(&self) -> Values<'_, K, V>{\n        Values::new(&self.entries)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "map::slice::Slice::<K, V>::values_mut": [
            "/// Return an iterator over mutable references to the the values of the map slice.\npub fn values_mut(&mut self) -> ValuesMut<'_, K, V>{\n        ValuesMut::new(&mut self.entries)\n    }",
            "Real(LocalPath(\"src/map/slice.rs\"))"
        ],
        "set::IndexSet": [
            "/// A hash set where the iteration order of the values is independent of their\n/// hash values.\n///\n/// The interface is closely compatible with the standard\n/// [`HashSet`][std::collections::HashSet],\n/// but also has additional features.\n///\n/// # Order\n///\n/// The values have a consistent order that is determined by the sequence of\n/// insertion and removal calls on the set. The order does not depend on the\n/// values or the hash function at all. Note that insertion order and value\n/// are not affected if a re-insertion is attempted once an element is\n/// already present.\n///\n/// All iterators traverse the set *in order*.  Set operation iterators like\n/// [`IndexSet::union`] produce a concatenated order, as do their matching \"bitwise\"\n/// operators.  See their documentation for specifics.\n///\n/// The insertion order is preserved, with **notable exceptions** like the\n/// [`.remove()`][Self::remove] or [`.swap_remove()`][Self::swap_remove] methods.\n/// Methods such as [`.sort_by()`][Self::sort_by] of\n/// course result in a new order, depending on the sorting order.\n///\n/// # Indices\n///\n/// The values are indexed in a compact range without holes in the range\n/// `0..self.len()`. For example, the method `.get_full` looks up the index for\n/// a value, and the method `.get_index` looks up the value by index.\n///\n/// # Complexity\n///\n/// Internally, `IndexSet<T, S>` just holds an [`IndexMap<T, (), S>`](IndexMap). Thus the complexity\n/// of the two are the same for most methods.\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexSet;\n///\n/// // Collects which letters appear in a sentence.\n/// let letters: IndexSet<_> = \"a short treatise on fungi\".chars().collect();\n///\n/// assert!(letters.contains(&'s'));\n/// assert!(letters.contains(&'t'));\n/// assert!(letters.contains(&'u'));\n/// assert!(!letters.contains(&'y'));\n/// ```\n#[cfg(feature = \"std\")]\npub struct IndexSet<T, S = RandomState> {\n    pub(crate) map: IndexMap<T, (), S>,\n}",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::append": [
            "/// Moves all values from `other` into `self`, leaving `other` empty.\n///\n/// This is equivalent to calling [`insert`][Self::insert] for each value\n/// from `other` in order, which means that values that already exist\n/// in `self` are unchanged in their current position.\n///\n/// See also [`union`][Self::union] to iterate the combined values by\n/// reference, without modifying `self` or `other`.\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexSet;\n///\n/// let mut a = IndexSet::from([3, 2, 1]);\n/// let mut b = IndexSet::from([3, 4, 5]);\n/// let old_capacity = b.capacity();\n///\n/// a.append(&mut b);\n///\n/// assert_eq!(a.len(), 5);\n/// assert_eq!(b.len(), 0);\n/// assert_eq!(b.capacity(), old_capacity);\n///\n/// assert!(a.iter().eq(&[3, 2, 1, 4, 5]));\n/// ```\npub fn append<S2>(&mut self, other: &mut IndexSet<T, S2>){\n        self.map.append(&mut other.map);\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::as_slice": [
            "/// Returns a slice of all the values in the set.\n///\n/// Computes in **O(1)** time.\npub fn as_slice(&self) -> &Slice<T>{\n        Slice::from_slice(self.as_entries())\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::binary_search": [
            "/// Search over a sorted set for a value.\n///\n/// Returns the position where that value is present, or the position where it can be inserted\n/// to maintain the sort. See [`slice::binary_search`] for more details.\n///\n/// Computes in **O(log(n))** time, which is notably less scalable than looking the value up\n/// using [`get_index_of`][IndexSet::get_index_of], but this can also position missing values.\npub fn binary_search(&self, x: &T) -> Result<usize, usize>\n    where\n        T: Ord,{\n        self.as_slice().binary_search(x)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::binary_search_by": [
            "/// Search over a sorted set with a comparator function.\n///\n/// Returns the position where that value is present, or the position where it can be inserted\n/// to maintain the sort. See [`slice::binary_search_by`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[inline]\npub fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,{\n        self.as_slice().binary_search_by(f)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::binary_search_by_key": [
            "/// Search over a sorted set with an extraction function.\n///\n/// Returns the position where that value is present, or the position where it can be inserted\n/// to maintain the sort. See [`slice::binary_search_by_key`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[inline]\npub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> B,\n        B: Ord,{\n        self.as_slice().binary_search_by_key(b, f)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::capacity": [
            "/// Return the number of elements the set can hold without reallocating.\n///\n/// This number is a lower bound; the set might be able to hold more,\n/// but is guaranteed to be able to hold at least this many.\n///\n/// Computes in **O(1)** time.\npub fn capacity(&self) -> usize{\n        self.map.capacity()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::clear": [
            "/// Remove all elements in the set, while preserving its capacity.\n///\n/// Computes in **O(n)** time.\npub fn clear(&mut self){\n        self.map.clear();\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::contains": [
            "/// Return `true` if an equivalent to `value` exists in the set.\n///\n/// Computes in **O(1)** time (average).\npub fn contains<Q>(&self, value: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.map.contains_key(value)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::difference": [
            "/// Return an iterator over the values that are in `self` but not `other`.\n///\n/// Values are produced in the same order that they appear in `self`.\npub fn difference<'a, S2>(&'a self, other: &'a IndexSet<T, S2>) -> Difference<'a, T, S2>\n    where\n        S2: BuildHasher,{\n        Difference::new(self, other)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::drain": [
            "/// Clears the `IndexSet` in the given index range, returning those values\n/// as a drain iterator.\n///\n/// The range may be any type that implements [`RangeBounds<usize>`],\n/// including all of the `std::ops::Range*` types, or even a tuple pair of\n/// `Bound` start and end values. To drain the set entirely, use `RangeFull`\n/// like `set.drain(..)`.\n///\n/// This shifts down all entries following the drained range to fill the\n/// gap, and keeps the allocated memory for reuse.\n///\n/// ***Panics*** if the starting point is greater than the end point or if\n/// the end point is greater than the length of the set.\n#[track_caller]\npub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n    where\n        R: RangeBounds<usize>,{\n        Drain::new(self.map.core.drain(range))\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::first": [
            "/// Get the first value\n///\n/// Computes in **O(1)** time.\npub fn first(&self) -> Option<&T>{\n        self.as_entries().first().map(Bucket::key_ref)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::get": [
            "/// Return a reference to the value stored in the set, if it is present,\n/// else `None`.\n///\n/// Computes in **O(1)** time (average).\npub fn get<Q>(&self, value: &Q) -> Option<&T>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.map.get_key_value(value).map(|(x, &())| x)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::get_full": [
            "/// Return item index and value\npub fn get_full<Q>(&self, value: &Q) -> Option<(usize, &T)>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.map.get_full(value).map(|(i, x, &())| (i, x))\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::get_index": [
            "/// Get a value by index\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Computes in **O(1)** time.\npub fn get_index(&self, index: usize) -> Option<&T>{\n        self.as_entries().get(index).map(Bucket::key_ref)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::get_index_of": [
            "/// Return item index, if it exists in the set\n///\n/// Computes in **O(1)** time (average).\npub fn get_index_of<Q>(&self, value: &Q) -> Option<usize>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.map.get_index_of(value)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::get_range": [
            "/// Returns a slice of values in the given range of indices.\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Computes in **O(1)** time.\npub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Slice<T>>{\n        let entries = self.as_entries();\n        let range = try_simplify_range(range, entries.len())?;\n        entries.get(range).map(Slice::from_slice)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::hasher": [
            "/// Return a reference to the set's `BuildHasher`.\npub fn hasher(&self) -> &S{\n        self.map.hasher()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::insert": [
            "/// Insert the value into the set.\n///\n/// If an equivalent item already exists in the set, it returns\n/// `false` leaving the original value in the set and without\n/// altering its insertion order. Otherwise, it inserts the new\n/// item and returns `true`.\n///\n/// Computes in **O(1)** time (amortized average).\npub fn insert(&mut self, value: T) -> bool{\n        self.map.insert(value, ()).is_none()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::insert_before": [
            "/// Insert the value into the set before the value at the given index, or at the end.\n///\n/// If an equivalent item already exists in the set, it returns `false` leaving the\n/// original value in the set, but moved to the new position. The returned index\n/// will either be the given index or one less, depending on how the value moved.\n/// (See [`shift_insert`](Self::shift_insert) for different behavior here.)\n///\n/// Otherwise, it inserts the new value exactly at the given index and returns `true`.\n///\n/// ***Panics*** if `index` is out of bounds.\n/// Valid indices are `0..=set.len()` (inclusive).\n///\n/// Computes in **O(n)** time (average).\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexSet;\n/// let mut set: IndexSet<char> = ('a'..='z').collect();\n///\n/// // The new value '*' goes exactly at the given index.\n/// assert_eq!(set.get_index_of(&'*'), None);\n/// assert_eq!(set.insert_before(10, '*'), (10, true));\n/// assert_eq!(set.get_index_of(&'*'), Some(10));\n///\n/// // Moving the value 'a' up will shift others down, so this moves *before* 10 to index 9.\n/// assert_eq!(set.insert_before(10, 'a'), (9, false));\n/// assert_eq!(set.get_index_of(&'a'), Some(9));\n/// assert_eq!(set.get_index_of(&'*'), Some(10));\n///\n/// // Moving the value 'z' down will shift others up, so this moves to exactly 10.\n/// assert_eq!(set.insert_before(10, 'z'), (10, false));\n/// assert_eq!(set.get_index_of(&'z'), Some(10));\n/// assert_eq!(set.get_index_of(&'*'), Some(11));\n///\n/// // Moving or inserting before the endpoint is also valid.\n/// assert_eq!(set.len(), 27);\n/// assert_eq!(set.insert_before(set.len(), '*'), (26, false));\n/// assert_eq!(set.get_index_of(&'*'), Some(26));\n/// assert_eq!(set.insert_before(set.len(), '+'), (27, true));\n/// assert_eq!(set.get_index_of(&'+'), Some(27));\n/// assert_eq!(set.len(), 28);\n/// ```\n#[track_caller]\npub fn insert_before(&mut self, index: usize, value: T) -> (usize, bool){\n        let (index, existing) = self.map.insert_before(index, value, ());\n        (index, existing.is_none())\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::insert_full": [
            "/// Insert the value into the set, and get its index.\n///\n/// If an equivalent item already exists in the set, it returns\n/// the index of the existing item and `false`, leaving the\n/// original value in the set and without altering its insertion\n/// order. Otherwise, it inserts the new item and returns the index\n/// of the inserted item and `true`.\n///\n/// Computes in **O(1)** time (amortized average).\npub fn insert_full(&mut self, value: T) -> (usize, bool){\n        let (index, existing) = self.map.insert_full(value, ());\n        (index, existing.is_none())\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::insert_sorted": [
            "/// Insert the value into the set at its ordered position among sorted values.\n///\n/// This is equivalent to finding the position with\n/// [`binary_search`][Self::binary_search], and if needed calling\n/// [`insert_before`][Self::insert_before] for a new value.\n///\n/// If the sorted item is found in the set, it returns the index of that\n/// existing item and `false`, without any change. Otherwise, it inserts the\n/// new item and returns its sorted index and `true`.\n///\n/// If the existing items are **not** already sorted, then the insertion\n/// index is unspecified (like [`slice::binary_search`]), but the value\n/// is moved to or inserted at that position regardless.\n///\n/// Computes in **O(n)** time (average). Instead of repeating calls to\n/// `insert_sorted`, it may be faster to call batched [`insert`][Self::insert]\n/// or [`extend`][Self::extend] and only call [`sort`][Self::sort] or\n/// [`sort_unstable`][Self::sort_unstable] once.\npub fn insert_sorted(&mut self, value: T) -> (usize, bool)\n    where\n        T: Ord,{\n        let (index, existing) = self.map.insert_sorted(value, ());\n        (index, existing.is_none())\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::intersection": [
            "/// Return an iterator over the values that are in both `self` and `other`.\n///\n/// Values are produced in the same order that they appear in `self`.\npub fn intersection<'a, S2>(&'a self, other: &'a IndexSet<T, S2>) -> Intersection<'a, T, S2>\n    where\n        S2: BuildHasher,{\n        Intersection::new(self, other)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::into_boxed_slice": [
            "/// Converts into a boxed slice of all the values in the set.\n///\n/// Note that this will drop the inner hash table and any excess capacity.\npub fn into_boxed_slice(self) -> Box<Slice<T>>{\n        Slice::from_boxed(self.into_entries().into_boxed_slice())\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::is_disjoint": [
            "/// Returns `true` if `self` has no elements in common with `other`.\npub fn is_disjoint<S2>(&self, other: &IndexSet<T, S2>) -> bool\n    where\n        S2: BuildHasher,{\n        if self.len() <= other.len() {\n            self.iter().all(move |value| !other.contains(value))\n        } else {\n            other.iter().all(move |value| !self.contains(value))\n        }\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::is_empty": [
            "/// Returns true if the set contains no elements.\n///\n/// Computes in **O(1)** time.\npub fn is_empty(&self) -> bool{\n        self.map.is_empty()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::is_subset": [
            "/// Returns `true` if all elements of `self` are contained in `other`.\npub fn is_subset<S2>(&self, other: &IndexSet<T, S2>) -> bool\n    where\n        S2: BuildHasher,{\n        self.len() <= other.len() && self.iter().all(move |value| other.contains(value))\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::is_superset": [
            "/// Returns `true` if all elements of `other` are contained in `self`.\npub fn is_superset<S2>(&self, other: &IndexSet<T, S2>) -> bool\n    where\n        S2: BuildHasher,{\n        other.is_subset(self)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::iter": [
            "/// Return an iterator over the values of the set, in their order\npub fn iter(&self) -> Iter<'_, T>{\n        Iter::new(self.as_entries())\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::last": [
            "/// Get the last value\n///\n/// Computes in **O(1)** time.\npub fn last(&self) -> Option<&T>{\n        self.as_entries().last().map(Bucket::key_ref)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::len": [
            "/// Return the number of elements in the set.\n///\n/// Computes in **O(1)** time.\npub fn len(&self) -> usize{\n        self.map.len()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::move_index": [
            "/// Moves the position of a value from one index to another\n/// by shifting all other values in-between.\n///\n/// * If `from < to`, the other values will shift down while the targeted value moves up.\n/// * If `from > to`, the other values will shift up while the targeted value moves down.\n///\n/// ***Panics*** if `from` or `to` are out of bounds.\n///\n/// Computes in **O(n)** time (average).\n#[track_caller]\npub fn move_index(&mut self, from: usize, to: usize){\n        self.map.move_index(from, to)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::partition_point": [
            "/// Returns the index of the partition point of a sorted set according to the given predicate\n/// (the index of the first element of the second partition).\n///\n/// See [`slice::partition_point`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[must_use]\npub fn partition_point<P>(&self, pred: P) -> usize\n    where\n        P: FnMut(&T) -> bool,{\n        self.as_slice().partition_point(pred)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::pop": [
            "/// Remove the last value\n///\n/// This preserves the order of the remaining elements.\n///\n/// Computes in **O(1)** time (average).\n#[doc(alias = \"pop_last\")]\npub fn pop(&mut self) -> Option<T>{\n        self.map.pop().map(|(x, ())| x)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::remove": [
            "/// Remove the value from the set, and return `true` if it was present.\n///\n/// **NOTE:** This is equivalent to [`.swap_remove(value)`][Self::swap_remove], replacing this\n/// value's position with the last element, and it is deprecated in favor of calling that\n/// explicitly. If you need to preserve the relative order of the values in the set, use\n/// [`.shift_remove(value)`][Self::shift_remove] instead.\n#[deprecated(note = \"`remove` disrupts the set order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\")]\npub fn remove<Q>(&mut self, value: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.swap_remove(value)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::replace": [
            "/// Adds a value to the set, replacing the existing value, if any, that is\n/// equal to the given one, without altering its insertion order. Returns\n/// the replaced value.\n///\n/// Computes in **O(1)** time (average).\npub fn replace(&mut self, value: T) -> Option<T>{\n        self.replace_full(value).1\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::replace_full": [
            "/// Adds a value to the set, replacing the existing value, if any, that is\n/// equal to the given one, without altering its insertion order. Returns\n/// the index of the item and its replaced value.\n///\n/// Computes in **O(1)** time (average).\npub fn replace_full(&mut self, value: T) -> (usize, Option<T>){\n        let hash = self.map.hash(&value);\n        match self.map.core.replace_full(hash, value, ()) {\n            (i, Some((replaced, ()))) => (i, Some(replaced)),\n            (i, None) => (i, None),\n        }\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::reserve": [
            "/// Reserve capacity for `additional` more values.\n///\n/// Computes in **O(n)** time.\npub fn reserve(&mut self, additional: usize){\n        self.map.reserve(additional);\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::reserve_exact": [
            "/// Reserve capacity for `additional` more values, without over-allocating.\n///\n/// Unlike `reserve`, this does not deliberately over-allocate the entry capacity to avoid\n/// frequent re-allocations. However, the underlying data structures may still have internal\n/// capacity requirements, and the allocator itself may give more space than requested, so this\n/// cannot be relied upon to be precisely minimal.\n///\n/// Computes in **O(n)** time.\npub fn reserve_exact(&mut self, additional: usize){\n        self.map.reserve_exact(additional);\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::retain": [
            "/// Scan through each value in the set and keep those where the\n/// closure `keep` returns `true`.\n///\n/// The elements are visited in order, and remaining elements keep their\n/// order.\n///\n/// Computes in **O(n)** time (average).\npub fn retain<F>(&mut self, mut keep: F)\n    where\n        F: FnMut(&T) -> bool,{\n        self.map.retain(move |x, &mut ()| keep(x))\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::reverse": [
            "/// Reverses the order of the sets values in place.\n///\n/// Computes in **O(n)** time and **O(1)** space.\npub fn reverse(&mut self){\n        self.map.reverse()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::shift_insert": [
            "/// Insert the value into the set at the given index.\n///\n/// If an equivalent item already exists in the set, it returns `false` leaving\n/// the original value in the set, but moved to the given index.\n/// Note that existing values **cannot** be moved to `index == set.len()`!\n/// (See [`insert_before`](Self::insert_before) for different behavior here.)\n///\n/// Otherwise, it inserts the new value at the given index and returns `true`.\n///\n/// ***Panics*** if `index` is out of bounds.\n/// Valid indices are `0..set.len()` (exclusive) when moving an existing value, or\n/// `0..=set.len()` (inclusive) when inserting a new value.\n///\n/// Computes in **O(n)** time (average).\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexSet;\n/// let mut set: IndexSet<char> = ('a'..='z').collect();\n///\n/// // The new value '*' goes exactly at the given index.\n/// assert_eq!(set.get_index_of(&'*'), None);\n/// assert_eq!(set.shift_insert(10, '*'), true);\n/// assert_eq!(set.get_index_of(&'*'), Some(10));\n///\n/// // Moving the value 'a' up to 10 will shift others down, including the '*' that was at 10.\n/// assert_eq!(set.shift_insert(10, 'a'), false);\n/// assert_eq!(set.get_index_of(&'a'), Some(10));\n/// assert_eq!(set.get_index_of(&'*'), Some(9));\n///\n/// // Moving the value 'z' down to 9 will shift others up, including the '*' that was at 9.\n/// assert_eq!(set.shift_insert(9, 'z'), false);\n/// assert_eq!(set.get_index_of(&'z'), Some(9));\n/// assert_eq!(set.get_index_of(&'*'), Some(10));\n///\n/// // Existing values can move to len-1 at most, but new values can insert at the endpoint.\n/// assert_eq!(set.len(), 27);\n/// assert_eq!(set.shift_insert(set.len() - 1, '*'), false);\n/// assert_eq!(set.get_index_of(&'*'), Some(26));\n/// assert_eq!(set.shift_insert(set.len(), '+'), true);\n/// assert_eq!(set.get_index_of(&'+'), Some(27));\n/// assert_eq!(set.len(), 28);\n/// ```\n///\n/// ```should_panic\n/// use indexmap::IndexSet;\n/// let mut set: IndexSet<char> = ('a'..='z').collect();\n///\n/// // This is an invalid index for moving an existing value!\n/// set.shift_insert(set.len(), 'a');\n/// ```\n#[track_caller]\npub fn shift_insert(&mut self, index: usize, value: T) -> bool{\n        self.map.shift_insert(index, value, ()).is_none()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::shift_remove": [
            "/// Remove the value from the set, and return `true` if it was present.\n///\n/// Like [`Vec::remove`], the value is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Return `false` if `value` was not in the set.\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove<Q>(&mut self, value: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.map.shift_remove(value).is_some()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::shift_remove_full": [
            "/// Remove the value from the set return it and the index it had.\n///\n/// Like [`Vec::remove`], the value is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Return `None` if `value` was not in the set.\npub fn shift_remove_full<Q>(&mut self, value: &Q) -> Option<(usize, T)>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.map.shift_remove_full(value).map(|(i, x, ())| (i, x))\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::shift_remove_index": [
            "/// Remove the value by index\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Like [`Vec::remove`], the value is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Computes in **O(n)** time (average).\npub fn shift_remove_index(&mut self, index: usize) -> Option<T>{\n        self.map.shift_remove_index(index).map(|(x, ())| x)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::shift_take": [
            "/// Removes and returns the value in the set, if any, that is equal to the\n/// given one.\n///\n/// Like [`Vec::remove`], the value is removed by shifting all of the\n/// elements that follow it, preserving their relative order.\n/// **This perturbs the index of all of those elements!**\n///\n/// Return `None` if `value` was not in the set.\n///\n/// Computes in **O(n)** time (average).\npub fn shift_take<Q>(&mut self, value: &Q) -> Option<T>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.map.shift_remove_entry(value).map(|(x, ())| x)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::shrink_to": [
            "/// Shrink the capacity of the set with a lower limit.\n///\n/// Computes in **O(n)** time.\npub fn shrink_to(&mut self, min_capacity: usize){\n        self.map.shrink_to(min_capacity);\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::shrink_to_fit": [
            "/// Shrink the capacity of the set as much as possible.\n///\n/// Computes in **O(n)** time.\npub fn shrink_to_fit(&mut self){\n        self.map.shrink_to_fit();\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::sort": [
            "/// Sort the sets values by their default ordering.\n///\n/// This is a stable sort -- but equivalent values should not normally coexist in\n/// a set at all, so [`sort_unstable`][Self::sort_unstable] is preferred\n/// because it is generally faster and doesn't allocate auxiliary memory.\n///\n/// See [`sort_by`](Self::sort_by) for details.\npub fn sort(&mut self)\n    where\n        T: Ord,{\n        self.map.sort_keys()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::sort_by": [
            "/// Sort the sets values in place using the comparison function `cmp`.\n///\n/// Computes in **O(n log n)** time and **O(n)** space. The sort is stable.\npub fn sort_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,{\n        self.map.sort_by(move |a, _, b, _| cmp(a, b));\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::sort_by_cached_key": [
            "/// Sort the sets values in place using a key extraction function.\n///\n/// During sorting, the function is called at most once per entry, by using temporary storage\n/// to remember the results of its evaluation. The order of calls to the function is\n/// unspecified and may change between versions of `indexmap` or the standard library.\n///\n/// Computes in **O(m n + n log n + c)** time () and **O(n)** space, where the function is\n/// **O(m)**, *n* is the length of the map, and *c* the capacity. The sort is stable.\npub fn sort_by_cached_key<K, F>(&mut self, mut sort_key: F)\n    where\n        K: Ord,\n        F: FnMut(&T) -> K,{\n        self.with_entries(move |entries| {\n            entries.sort_by_cached_key(move |a| sort_key(&a.key));\n        });\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::sort_unstable": [
            "/// Sort the set's values by their default ordering.\n///\n/// See [`sort_unstable_by`](Self::sort_unstable_by) for details.\npub fn sort_unstable(&mut self)\n    where\n        T: Ord,{\n        self.map.sort_unstable_keys()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::sort_unstable_by": [
            "/// Sort the set's values in place using the comparison function `cmp`.\n///\n/// Computes in **O(n log n)** time. The sort is unstable.\npub fn sort_unstable_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,{\n        self.map.sort_unstable_by(move |a, _, b, _| cmp(a, b))\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::sorted_by": [
            "/// Sort the values of the set and return a by-value iterator of\n/// the values with the result.\n///\n/// The sort is stable.\npub fn sorted_by<F>(self, mut cmp: F) -> IntoIter<T>\n    where\n        F: FnMut(&T, &T) -> Ordering,{\n        let mut entries = self.into_entries();\n        entries.sort_by(move |a, b| cmp(&a.key, &b.key));\n        IntoIter::new(entries)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::sorted_unstable_by": [
            "/// Sort the values of the set and return a by-value iterator of\n/// the values with the result.\npub fn sorted_unstable_by<F>(self, mut cmp: F) -> IntoIter<T>\n    where\n        F: FnMut(&T, &T) -> Ordering,{\n        let mut entries = self.into_entries();\n        entries.sort_unstable_by(move |a, b| cmp(&a.key, &b.key));\n        IntoIter::new(entries)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::splice": [
            "/// Creates a splicing iterator that replaces the specified range in the set\n/// with the given `replace_with` iterator and yields the removed items.\n/// `replace_with` does not need to be the same length as `range`.\n///\n/// The `range` is removed even if the iterator is not consumed until the\n/// end. It is unspecified how many elements are removed from the set if the\n/// `Splice` value is leaked.\n///\n/// The input iterator `replace_with` is only consumed when the `Splice`\n/// value is dropped. If a value from the iterator matches an existing entry\n/// in the set (outside of `range`), then the original will be unchanged.\n/// Otherwise, the new value will be inserted in the replaced `range`.\n///\n/// ***Panics*** if the starting point is greater than the end point or if\n/// the end point is greater than the length of the set.\n///\n/// # Examples\n///\n/// ```\n/// use indexmap::IndexSet;\n///\n/// let mut set = IndexSet::from([0, 1, 2, 3, 4]);\n/// let new = [5, 4, 3, 2, 1];\n/// let removed: Vec<_> = set.splice(2..4, new).collect();\n///\n/// // 1 and 4 kept their positions, while 5, 3, and 2 were newly inserted.\n/// assert!(set.into_iter().eq([0, 1, 5, 3, 2, 4]));\n/// assert_eq!(removed, &[2, 3]);\n/// ```\n#[track_caller]\npub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter, T, S>\n    where\n        R: RangeBounds<usize>,\n        I: IntoIterator<Item = T>,{\n        Splice::new(self, range, replace_with.into_iter())\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::split_off": [
            "/// Splits the collection into two at the given index.\n///\n/// Returns a newly allocated set containing the elements in the range\n/// `[at, len)`. After the call, the original set will be left containing\n/// the elements `[0, at)` with its previous capacity unchanged.\n///\n/// ***Panics*** if `at > len`.\n#[track_caller]\npub fn split_off(&mut self, at: usize) -> Self\n    where\n        S: Clone,{\n        Self {\n            map: self.map.split_off(at),\n        }\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::swap_indices": [
            "/// Swaps the position of two values in the set.\n///\n/// ***Panics*** if `a` or `b` are out of bounds.\n///\n/// Computes in **O(1)** time (average).\n#[track_caller]\npub fn swap_indices(&mut self, a: usize, b: usize){\n        self.map.swap_indices(a, b)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::swap_remove": [
            "/// Remove the value from the set, and return `true` if it was present.\n///\n/// Like [`Vec::swap_remove`], the value is removed by swapping it with the\n/// last element of the set and popping it off. **This perturbs\n/// the position of what used to be the last element!**\n///\n/// Return `false` if `value` was not in the set.\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove<Q>(&mut self, value: &Q) -> bool\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.map.swap_remove(value).is_some()\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::swap_remove_full": [
            "/// Remove the value from the set return it and the index it had.\n///\n/// Like [`Vec::swap_remove`], the value is removed by swapping it with the\n/// last element of the set and popping it off. **This perturbs\n/// the position of what used to be the last element!**\n///\n/// Return `None` if `value` was not in the set.\npub fn swap_remove_full<Q>(&mut self, value: &Q) -> Option<(usize, T)>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.map.swap_remove_full(value).map(|(i, x, ())| (i, x))\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::swap_remove_index": [
            "/// Remove the value by index\n///\n/// Valid indices are `0 <= index < self.len()`.\n///\n/// Like [`Vec::swap_remove`], the value is removed by swapping it with the\n/// last element of the set and popping it off. **This perturbs\n/// the position of what used to be the last element!**\n///\n/// Computes in **O(1)** time (average).\npub fn swap_remove_index(&mut self, index: usize) -> Option<T>{\n        self.map.swap_remove_index(index).map(|(x, ())| x)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::swap_take": [
            "/// Removes and returns the value in the set, if any, that is equal to the\n/// given one.\n///\n/// Like [`Vec::swap_remove`], the value is removed by swapping it with the\n/// last element of the set and popping it off. **This perturbs\n/// the position of what used to be the last element!**\n///\n/// Return `None` if `value` was not in the set.\n///\n/// Computes in **O(1)** time (average).\npub fn swap_take<Q>(&mut self, value: &Q) -> Option<T>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.map.swap_remove_entry(value).map(|(x, ())| x)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::symmetric_difference": [
            "/// Return an iterator over the values that are in `self` or `other`,\n/// but not in both.\n///\n/// Values from `self` are produced in their original order, followed by\n/// values from `other` in their original order.\npub fn symmetric_difference<'a, S2>(\n        &'a self,\n        other: &'a IndexSet<T, S2>,\n    ) -> SymmetricDifference<'a, T, S, S2>\n    where\n        S2: BuildHasher,{\n        SymmetricDifference::new(self, other)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::take": [
            "/// Removes and returns the value in the set, if any, that is equal to the\n/// given one.\n///\n/// **NOTE:** This is equivalent to [`.swap_take(value)`][Self::swap_take], replacing this\n/// value's position with the last element, and it is deprecated in favor of calling that\n/// explicitly. If you need to preserve the relative order of the values in the set, use\n/// [`.shift_take(value)`][Self::shift_take] instead.\n#[deprecated(note = \"`take` disrupts the set order -- \\\n        use `swap_take` or `shift_take` for explicit behavior.\")]\npub fn take<Q>(&mut self, value: &Q) -> Option<T>\n    where\n        Q: ?Sized + Hash + Equivalent<T>,{\n        self.swap_take(value)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::truncate": [
            "/// Shortens the set, keeping the first `len` elements and dropping the rest.\n///\n/// If `len` is greater than the set's current length, this has no effect.\npub fn truncate(&mut self, len: usize){\n        self.map.truncate(len);\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::try_reserve": [
            "/// Try to reserve capacity for `additional` more values.\n///\n/// Computes in **O(n)** time.\npub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError>{\n        self.map.try_reserve(additional)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::try_reserve_exact": [
            "/// Try to reserve capacity for `additional` more values, without over-allocating.\n///\n/// Unlike `try_reserve`, this does not deliberately over-allocate the entry capacity to avoid\n/// frequent re-allocations. However, the underlying data structures may still have internal\n/// capacity requirements, and the allocator itself may give more space than requested, so this\n/// cannot be relied upon to be precisely minimal.\n///\n/// Computes in **O(n)** time.\npub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>{\n        self.map.try_reserve_exact(additional)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::union": [
            "/// Return an iterator over all values that are in `self` or `other`.\n///\n/// Values from `self` are produced in their original order, followed by\n/// values that are unique to `other` in their original order.\npub fn union<'a, S2>(&'a self, other: &'a IndexSet<T, S2>) -> Union<'a, T, S>\n    where\n        S2: BuildHasher,{\n        Union::new(self, other)\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::with_capacity_and_hasher": [
            "/// Create a new set with capacity for `n` elements.\n/// (Does not allocate if `n` is zero.)\n///\n/// Computes in **O(n)** time.\npub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self{\n        IndexSet {\n            map: IndexMap::with_capacity_and_hasher(n, hash_builder),\n        }\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T, S>::with_hasher": [
            "/// Create a new set with `hash_builder`.\n///\n/// This function is `const`, so it\n/// can be called in `static` contexts.\npub const fn with_hasher(hash_builder: S) -> Self{\n        IndexSet {\n            map: IndexMap::with_hasher(hash_builder),\n        }\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T>::new": [
            "/// Create a new set. (Does not allocate.)\npub fn new() -> Self{\n        IndexSet {\n            map: IndexMap::new(),\n        }\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::IndexSet::<T>::with_capacity": [
            "/// Create a new set with capacity for `n` elements.\n/// (Does not allocate if `n` is zero.)\n///\n/// Computes in **O(n)** time.\npub fn with_capacity(n: usize) -> Self{\n        IndexSet {\n            map: IndexMap::with_capacity(n),\n        }\n    }",
            "Real(LocalPath(\"src/set.rs\"))"
        ],
        "set::iter::<impl core::iter::IntoIterator for &'a set::IndexSet<T, S>>::into_iter": [
            "fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::<impl core::iter::IntoIterator for set::IndexSet<T, S>>::into_iter": [
            "fn into_iter(self) -> Self::IntoIter{\n        IntoIter::new(self.into_entries())\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Difference": [
            "/// A lazy iterator producing elements in the difference of [`IndexSet`]s.\n///\n/// This `struct` is created by the [`IndexSet::difference`] method.\n/// See its documentation for more.\npub struct Difference<'a, T, S> {\n    iter: Iter<'a, T>,\n    other: &'a IndexSet<T, S>,\n}",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Difference::<'a, T, S>::new": [
            "pub(super) fn new<S1>(set: &'a IndexSet<T, S1>, other: &'a IndexSet<T, S>) -> Self{\n        Self {\n            iter: set.iter(),\n            other,\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Drain": [
            "/// A draining iterator over the items of an [`IndexSet`].\n///\n/// This `struct` is created by the [`IndexSet::drain`] method.\n/// See its documentation for more.\npub struct Drain<'a, T> {\n    iter: vec::Drain<'a, Bucket<T>>,\n}",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Drain::<'a, T>::as_slice": [
            "/// Returns a slice of the remaining entries in the iterator.\npub fn as_slice(&self) -> &Slice<T>{\n        Slice::from_slice(self.iter.as_slice())\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Drain::<'a, T>::new": [
            "pub(super) fn new(iter: vec::Drain<'a, Bucket<T>>) -> Self{\n        Self { iter }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Intersection": [
            "/// A lazy iterator producing elements in the intersection of [`IndexSet`]s.\n///\n/// This `struct` is created by the [`IndexSet::intersection`] method.\n/// See its documentation for more.\npub struct Intersection<'a, T, S> {\n    iter: Iter<'a, T>,\n    other: &'a IndexSet<T, S>,\n}",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Intersection::<'a, T, S>::new": [
            "pub(super) fn new<S1>(set: &'a IndexSet<T, S1>, other: &'a IndexSet<T, S>) -> Self{\n        Self {\n            iter: set.iter(),\n            other,\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::IntoIter": [
            "/// An owning iterator over the items of an [`IndexSet`].\n///\n/// This `struct` is created by the [`IndexSet::into_iter`] method\n/// (provided by the [`IntoIterator`] trait). See its documentation for more.\npub struct IntoIter<T> {\n    iter: vec::IntoIter<Bucket<T>>,\n}",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::IntoIter::<T>::as_slice": [
            "/// Returns a slice of the remaining entries in the iterator.\npub fn as_slice(&self) -> &Slice<T>{\n        Slice::from_slice(self.iter.as_slice())\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::IntoIter::<T>::new": [
            "pub(super) fn new(entries: Vec<Bucket<T>>) -> Self{\n        Self {\n            iter: entries.into_iter(),\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Iter": [
            "/// An iterator over the items of an [`IndexSet`].\n///\n/// This `struct` is created by the [`IndexSet::iter`] method.\n/// See its documentation for more.\npub struct Iter<'a, T> {\n    iter: SliceIter<'a, Bucket<T>>,\n}",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Iter::<'a, T>::as_slice": [
            "/// Returns a slice of the remaining entries in the iterator.\npub fn as_slice(&self) -> &'a Slice<T>{\n        Slice::from_slice(self.iter.as_slice())\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Iter::<'a, T>::new": [
            "pub(super) fn new(entries: &'a [Bucket<T>]) -> Self{\n        Self {\n            iter: entries.iter(),\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Splice": [
            "/// A splicing iterator for `IndexSet`.\n///\n/// This `struct` is created by [`IndexSet::splice()`].\n/// See its documentation for more.\npub struct Splice<'a, I, T, S>\nwhere\n    I: Iterator<Item = T>,\n    T: Hash + Eq,\n    S: BuildHasher,\n{\n    iter: crate::map::Splice<'a, UnitValue<I>, T, (), S>,\n}",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Splice::<'a, I, T, S>::new": [
            "#[track_caller]\npub(super) fn new<R>(set: &'a mut IndexSet<T, S>, range: R, replace_with: I) -> Self\n    where\n        R: RangeBounds<usize>,{\n        Self {\n            iter: set.map.splice(range, UnitValue(replace_with)),\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::SymmetricDifference": [
            "/// A lazy iterator producing elements in the symmetric difference of [`IndexSet`]s.\n///\n/// This `struct` is created by the [`IndexSet::symmetric_difference`] method.\n/// See its documentation for more.\npub struct SymmetricDifference<'a, T, S1, S2> {\n    iter: Chain<Difference<'a, T, S2>, Difference<'a, T, S1>>,\n}",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::SymmetricDifference::<'a, T, S1, S2>::new": [
            "pub(super) fn new(set1: &'a IndexSet<T, S1>, set2: &'a IndexSet<T, S2>) -> Self{\n        let diff1 = set1.difference(set2);\n        let diff2 = set2.difference(set1);\n        Self {\n            iter: diff1.chain(diff2),\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Union": [
            "/// A lazy iterator producing elements in the union of [`IndexSet`]s.\n///\n/// This `struct` is created by the [`IndexSet::union`] method.\n/// See its documentation for more.\npub struct Union<'a, T, S> {\n    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>,\n}",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::Union::<'a, T, S>::new": [
            "pub(super) fn new<S2>(set1: &'a IndexSet<T, S>, set2: &'a IndexSet<T, S2>) -> Self\n    where\n        S2: BuildHasher,{\n        Self {\n            iter: set1.iter().chain(set2.difference(set1)),\n        }\n    }",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::iter::UnitValue": [
            "struct UnitValue<I>(I);",
            "Real(LocalPath(\"src/set/iter.rs\"))"
        ],
        "set::mutable::MutableValues": [
            "/// Opt-in mutable access to [`IndexSet`] values.\n///\n/// These methods expose `&mut T`, mutable references to the value as it is stored\n/// in the set.\n/// You are allowed to modify the values in the set **if the modification\n/// does not change the values hash and equality**.\n///\n/// If values are modified erroneously, you can no longer look them up.\n/// This is sound (memory safe) but a logical error hazard (just like\n/// implementing `PartialEq`, `Eq`, or `Hash` incorrectly would be).\n///\n/// `use` this trait to enable its methods for `IndexSet`.\n///\n/// This trait is sealed and cannot be implemented for types outside this crate.\npub trait MutableValues: private::Sealed {\n    type Value;\n\n    /// Return item index and mutable reference to the value\n    ///\n    /// Computes in **O(1)** time (average).\n    fn get_full_mut2<Q>(&mut self, value: &Q) -> Option<(usize, &mut Self::Value)>\n    where\n        Q: ?Sized + Hash + Equivalent<Self::Value>;\n\n    /// Return mutable reference to the value at an index.\n    ///\n    /// Valid indices are `0 <= index < self.len()`.\n    ///\n    /// Computes in **O(1)** time.\n    fn get_index_mut2(&mut self, index: usize) -> Option<&mut Self::Value>;\n\n    /// Scan through each value in the set and keep those where the\n    /// closure `keep` returns `true`.\n    ///\n    /// The values are visited in order, and remaining values keep their order.\n    ///\n    /// Computes in **O(n)** time (average).\n    fn retain2<F>(&mut self, keep: F)\n    where\n        F: FnMut(&mut Self::Value) -> bool;\n}",
            "Real(LocalPath(\"src/set/mutable.rs\"))"
        ],
        "set::mutable::private::Sealed": [
            "pub trait Sealed {}",
            "Real(LocalPath(\"src/set/mutable.rs\"))"
        ],
        "set::slice::<impl core::clone::Clone for alloc::boxed::Box<set::slice::Slice<T>>>::clone": [
            "fn clone(&self) -> Self{\n        Slice::from_boxed(self.entries.to_vec().into_boxed_slice())\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::cmp::PartialEq<set::slice::Slice<U>> for [T; N]>::eq": [
            "fn eq(&self, other: &Slice<U>) -> bool{\n        <[T] as PartialEq<Slice<U>>>::eq(self, other)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::cmp::PartialEq<set::slice::Slice<U>> for [T]>::eq": [
            "fn eq(&self, other: &Slice<U>) -> bool{\n        slice_eq(self, &other.entries, |o, b| *o == b.key)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::convert::From<&set::slice::Slice<T>> for alloc::boxed::Box<set::slice::Slice<T>>>::from": [
            "fn from(slice: &Slice<T>) -> Self{\n        Slice::from_boxed(Box::from(&slice.entries))\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::default::Default for alloc::boxed::Box<set::slice::Slice<T>>>::default": [
            "fn default() -> Self{\n        Slice::from_boxed(Box::default())\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::iter::IntoIterator for alloc::boxed::Box<set::slice::Slice<T>>>::into_iter": [
            "fn into_iter(self) -> Self::IntoIter{\n        IntoIter::new(self.into_entries())\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for set::IndexSet<T, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::ops::Index<core::ops::Range<usize>> for set::IndexSet<T, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeFrom<usize>> for set::IndexSet<T, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeFull> for set::IndexSet<T, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeInclusive<usize>> for set::IndexSet<T, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeTo<usize>> for set::IndexSet<T, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeToInclusive<usize>> for set::IndexSet<T, S>>::index": [
            "fn index(&self, range: $range) -> &Self::Output{\n                Slice::from_slice(&self.as_entries()[range])\n            }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice": [
            "/// A dynamically-sized slice of values in an [`IndexSet`].\n///\n/// This supports indexed operations much like a `[T]` slice,\n/// but not any hashed operations on the values.\n///\n/// Unlike `IndexSet`, `Slice` does consider the order for [`PartialEq`]\n/// and [`Eq`], and it also implements [`PartialOrd`], [`Ord`], and [`Hash`].\n#[repr(transparent)]\npub struct Slice<T> {\n    pub(crate) entries: [Bucket<T>],\n}",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::binary_search": [
            "/// Search over a sorted set for a value.\n///\n/// Returns the position where that value is present, or the position where it can be inserted\n/// to maintain the sort. See [`slice::binary_search`] for more details.\n///\n/// Computes in **O(log(n))** time, which is notably less scalable than looking the value up in\n/// the set this is a slice from using [`IndexSet::get_index_of`], but this can also position\n/// missing values.\npub fn binary_search(&self, x: &T) -> Result<usize, usize>\n    where\n        T: Ord,{\n        self.binary_search_by(|p| p.cmp(x))\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::binary_search_by": [
            "/// Search over a sorted set with a comparator function.\n///\n/// Returns the position where that value is present, or the position where it can be inserted\n/// to maintain the sort. See [`slice::binary_search_by`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[inline]\npub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,{\n        self.entries.binary_search_by(move |a| f(&a.key))\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::binary_search_by_key": [
            "/// Search over a sorted set with an extraction function.\n///\n/// Returns the position where that value is present, or the position where it can be inserted\n/// to maintain the sort. See [`slice::binary_search_by_key`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[inline]\npub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> B,\n        B: Ord,{\n        self.binary_search_by(|k| f(k).cmp(b))\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::first": [
            "/// Get the first value.\npub fn first(&self) -> Option<&T>{\n        self.entries.first().map(Bucket::key_ref)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::from_boxed": [
            "pub(super) fn from_boxed(entries: Box<[Bucket<T>]>) -> Box<Self>{\n        unsafe { Box::from_raw(Box::into_raw(entries) as *mut Self) }\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::from_slice": [
            "pub(super) const fn from_slice(entries: &[Bucket<T>]) -> &Self{\n        unsafe { &*(entries as *const [Bucket<T>] as *const Self) }\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::get_index": [
            "/// Get a value by index.\n///\n/// Valid indices are `0 <= index < self.len()`.\npub fn get_index(&self, index: usize) -> Option<&T>{\n        self.entries.get(index).map(Bucket::key_ref)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::get_range": [
            "/// Returns a slice of values in the given range of indices.\n///\n/// Valid indices are `0 <= index < self.len()`.\npub fn get_range<R: RangeBounds<usize>>(&self, range: R) -> Option<&Self>{\n        let range = try_simplify_range(range, self.entries.len())?;\n        self.entries.get(range).map(Self::from_slice)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::into_boxed": [
            "fn into_boxed(self: Box<Self>) -> Box<[Bucket<T>]>{\n        unsafe { Box::from_raw(Box::into_raw(self) as *mut [Bucket<T>]) }\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::into_entries": [
            "pub(crate) fn into_entries(self: Box<Self>) -> Vec<Bucket<T>>{\n        self.into_boxed().into_vec()\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::is_empty": [
            "/// Returns true if the set slice contains no elements.\npub const fn is_empty(&self) -> bool{\n        self.entries.is_empty()\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::iter": [
            "/// Return an iterator over the values of the set slice.\npub fn iter(&self) -> Iter<'_, T>{\n        Iter::new(&self.entries)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::last": [
            "/// Get the last value.\npub fn last(&self) -> Option<&T>{\n        self.entries.last().map(Bucket::key_ref)\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::len": [
            "/// Return the number of elements in the set slice.\npub const fn len(&self) -> usize{\n        self.entries.len()\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::new": [
            "/// Returns an empty slice.\npub const fn new<'a>() -> &'a Self{\n        Self::from_slice(&[])\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::partition_point": [
            "/// Returns the index of the partition point of a sorted set according to the given predicate\n/// (the index of the first element of the second partition).\n///\n/// See [`slice::partition_point`] for more details.\n///\n/// Computes in **O(log(n))** time.\n#[must_use]\npub fn partition_point<P>(&self, mut pred: P) -> usize\n    where\n        P: FnMut(&T) -> bool,{\n        self.entries.partition_point(move |a| pred(&a.key))\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::split_at": [
            "/// Divides one slice into two at an index.\n///\n/// ***Panics*** if `index > len`.\npub fn split_at(&self, index: usize) -> (&Self, &Self){\n        let (first, second) = self.entries.split_at(index);\n        (Self::from_slice(first), Self::from_slice(second))\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::split_first": [
            "/// Returns the first value and the rest of the slice,\n/// or `None` if it is empty.\npub fn split_first(&self) -> Option<(&T, &Self)>{\n        if let [first, rest @ ..] = &self.entries {\n            Some((&first.key, Self::from_slice(rest)))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "set::slice::Slice::<T>::split_last": [
            "/// Returns the last value and the rest of the slice,\n/// or `None` if it is empty.\npub fn split_last(&self) -> Option<(&T, &Self)>{\n        if let [rest @ .., last] = &self.entries {\n            Some((&last.key, Self::from_slice(rest)))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/set/slice.rs\"))"
        ],
        "util::simplify_range": [
            "#[track_caller]\npub(crate) fn simplify_range<R>(range: R, len: usize) -> Range<usize>\nwhere\n    R: RangeBounds<usize>,{\n    let start = match range.start_bound() {\n        Bound::Unbounded => 0,\n        Bound::Included(&i) if i <= len => i,\n        Bound::Excluded(&i) if i < len => i + 1,\n        Bound::Included(i) | Bound::Excluded(i) => {\n            panic!(\"range start index {i} out of range for slice of length {len}\")\n        }\n    };\n    let end = match range.end_bound() {\n        Bound::Unbounded => len,\n        Bound::Excluded(&i) if i <= len => i,\n        Bound::Included(&i) if i < len => i + 1,\n        Bound::Included(i) | Bound::Excluded(i) => {\n            panic!(\"range end index {i} out of range for slice of length {len}\")\n        }\n    };\n    if start > end {\n        panic!(\n            \"range start index {:?} should be <= range end index {:?}\",\n            range.start_bound(),\n            range.end_bound()\n        );\n    }\n    start..end\n}",
            "Real(LocalPath(\"src/util.rs\"))"
        ],
        "util::slice_eq": [
            "pub(crate) fn slice_eq<T, U>(left: &[T], right: &[U], eq: impl Fn(&T, &U) -> bool) -> bool{\n    if left.len() != right.len() {\n        return false;\n    }\n\n    // Implemented as explicit indexing rather\n    // than zipped iterators for performance reasons.\n    // See PR https://github.com/rust-lang/rust/pull/116846\n    for i in 0..left.len() {\n        // bound checks are optimized away\n        if !eq(&left[i], &right[i]) {\n            return false;\n        }\n    }\n\n    true\n}",
            "Real(LocalPath(\"src/util.rs\"))"
        ],
        "util::third": [
            "pub(crate) fn third<A, B, C>(t: (A, B, C)) -> C{\n    t.2\n}",
            "Real(LocalPath(\"src/util.rs\"))"
        ],
        "util::try_simplify_range": [
            "pub(crate) fn try_simplify_range<R>(range: R, len: usize) -> Option<Range<usize>>\nwhere\n    R: RangeBounds<usize>,{\n    let start = match range.start_bound() {\n        Bound::Unbounded => 0,\n        Bound::Included(&i) if i <= len => i,\n        Bound::Excluded(&i) if i < len => i + 1,\n        _ => return None,\n    };\n    let end = match range.end_bound() {\n        Bound::Unbounded => len,\n        Bound::Excluded(&i) if i <= len => i,\n        Bound::Included(&i) if i < len => i + 1,\n        _ => return None,\n    };\n    if start > end {\n        return None;\n    }\n    Some(start..end)\n}",
            "Real(LocalPath(\"src/util.rs\"))"
        ]
    },
    "struct_constructor": {
        "&'^0.Named(DefId(0:2760 ~ indexmap[c409]::map::core::{impl#1}::as_entries::'_), \"'_\") [Alias(Projection, AliasTy { args: [map::core::IndexMapCore<K/#0, V/#1>], def_id: DefId(0:2234 ~ indexmap[c409]::Entries::Entry) })]": [
            "as_entries"
        ],
        "&'^0.Named(DefId(0:2761 ~ indexmap[c409]::map::core::{impl#1}::as_entries_mut::'_), \"'_\") mut [Alias(Projection, AliasTy { args: [map::core::IndexMapCore<K/#0, V/#1>], def_id: DefId(0:2234 ~ indexmap[c409]::Entries::Entry) })]": [
            "as_entries_mut"
        ],
        "&'^0.Named(DefId(0:2928 ~ indexmap[c409]::map::mutable::MutableEntryKey::key_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [Self/#0], def_id: DefId(0:940 ~ indexmap[c409]::map::mutable::MutableEntryKey::Key) })": [
            "key_mut"
        ],
        "&'^0.Named(DefId(0:2930 ~ indexmap[c409]::map::mutable::{impl#1}::key_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::core::entry::Entry<'_/#0, K/#1, V/#2>], def_id: DefId(0:940 ~ indexmap[c409]::map::mutable::MutableEntryKey::Key) })": [
            "key_mut"
        ],
        "&'^0.Named(DefId(0:2932 ~ indexmap[c409]::map::mutable::{impl#2}::key_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::core::entry::OccupiedEntry<'_/#0, K/#1, V/#2>], def_id: DefId(0:940 ~ indexmap[c409]::map::mutable::MutableEntryKey::Key) })": [
            "key_mut"
        ],
        "&'^0.Named(DefId(0:2934 ~ indexmap[c409]::map::mutable::{impl#3}::key_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::core::entry::VacantEntry<'_/#0, K/#1, V/#2>], def_id: DefId(0:940 ~ indexmap[c409]::map::mutable::MutableEntryKey::Key) })": [
            "key_mut"
        ],
        "&'^0.Named(DefId(0:2936 ~ indexmap[c409]::map::mutable::{impl#4}::key_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::core::entry::IndexedEntry<'_/#0, K/#1, V/#2>], def_id: DefId(0:940 ~ indexmap[c409]::map::mutable::MutableEntryKey::Key) })": [
            "key_mut"
        ],
        "&'^0.Named(DefId(0:3001 ~ indexmap[c409]::map::{impl#1}::as_entries::'_), \"'_\") [Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>], def_id: DefId(0:2234 ~ indexmap[c409]::Entries::Entry) })]": [
            "as_entries"
        ],
        "&'^0.Named(DefId(0:3002 ~ indexmap[c409]::map::{impl#1}::as_entries_mut::'_), \"'_\") mut [Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>], def_id: DefId(0:2234 ~ indexmap[c409]::Entries::Entry) })]": [
            "as_entries_mut"
        ],
        "&'^0.Named(DefId(0:3270 ~ indexmap[c409]::set::slice::{impl#18}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::slice::Slice<T/#0>, usize], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3274 ~ indexmap[c409]::set::{impl#1}::as_entries::'_), \"'_\") [Alias(Projection, AliasTy { args: [set::IndexSet<T/#0, S/#1>], def_id: DefId(0:2234 ~ indexmap[c409]::Entries::Entry) })]": [
            "as_entries"
        ],
        "&'^0.Named(DefId(0:3275 ~ indexmap[c409]::set::{impl#1}::as_entries_mut::'_), \"'_\") mut [Alias(Projection, AliasTy { args: [set::IndexSet<T/#0, S/#1>], def_id: DefId(0:2234 ~ indexmap[c409]::Entries::Entry) })]": [
            "as_entries_mut"
        ],
        "&'^0.Named(DefId(0:3394 ~ indexmap[c409]::Entries::as_entries::'_), \"'_\") [Alias(Projection, AliasTy { args: [Self/#0], def_id: DefId(0:2234 ~ indexmap[c409]::Entries::Entry) })]": [
            "as_entries"
        ],
        "&'^0.Named(DefId(0:3395 ~ indexmap[c409]::Entries::as_entries_mut::'_), \"'_\") mut [Alias(Projection, AliasTy { args: [Self/#0], def_id: DefId(0:2234 ~ indexmap[c409]::Entries::Entry) })]": [
            "as_entries_mut"
        ],
        "&'^0.Named(DefId(0:3458 ~ indexmap[c409]::map::slice::{impl#22}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::Range<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3459 ~ indexmap[c409]::map::slice::{impl#23}::index_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::Range<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index_mut"
        ],
        "&'^0.Named(DefId(0:3462 ~ indexmap[c409]::map::slice::{impl#26}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::RangeFrom<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3463 ~ indexmap[c409]::map::slice::{impl#27}::index_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::RangeFrom<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index_mut"
        ],
        "&'^0.Named(DefId(0:3466 ~ indexmap[c409]::map::slice::{impl#30}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::RangeFull], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3467 ~ indexmap[c409]::map::slice::{impl#31}::index_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::RangeFull], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index_mut"
        ],
        "&'^0.Named(DefId(0:3470 ~ indexmap[c409]::map::slice::{impl#34}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::RangeInclusive<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3471 ~ indexmap[c409]::map::slice::{impl#35}::index_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::RangeInclusive<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index_mut"
        ],
        "&'^0.Named(DefId(0:3474 ~ indexmap[c409]::map::slice::{impl#38}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::RangeTo<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3475 ~ indexmap[c409]::map::slice::{impl#39}::index_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::RangeTo<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index_mut"
        ],
        "&'^0.Named(DefId(0:3478 ~ indexmap[c409]::map::slice::{impl#42}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::RangeToInclusive<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3479 ~ indexmap[c409]::map::slice::{impl#43}::index_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, core::ops::RangeToInclusive<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index_mut"
        ],
        "&'^0.Named(DefId(0:3482 ~ indexmap[c409]::map::slice::{impl#46}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, (core::ops::Bound<usize>, core::ops::Bound<usize>)], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3483 ~ indexmap[c409]::map::slice::{impl#47}::index_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>, (core::ops::Bound<usize>, core::ops::Bound<usize>)], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index_mut"
        ],
        "&'^0.Named(DefId(0:3502 ~ indexmap[c409]::set::slice::{impl#19}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::IndexSet<T/#0, S/#1>, core::ops::Range<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3503 ~ indexmap[c409]::set::slice::{impl#20}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::slice::Slice<T/#0>, core::ops::Range<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3504 ~ indexmap[c409]::set::slice::{impl#21}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::IndexSet<T/#0, S/#1>, core::ops::RangeFrom<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3505 ~ indexmap[c409]::set::slice::{impl#22}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::slice::Slice<T/#0>, core::ops::RangeFrom<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3506 ~ indexmap[c409]::set::slice::{impl#23}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::IndexSet<T/#0, S/#1>, core::ops::RangeFull], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3507 ~ indexmap[c409]::set::slice::{impl#24}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::slice::Slice<T/#0>, core::ops::RangeFull], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3508 ~ indexmap[c409]::set::slice::{impl#25}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::IndexSet<T/#0, S/#1>, core::ops::RangeInclusive<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3509 ~ indexmap[c409]::set::slice::{impl#26}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::slice::Slice<T/#0>, core::ops::RangeInclusive<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3510 ~ indexmap[c409]::set::slice::{impl#27}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::IndexSet<T/#0, S/#1>, core::ops::RangeTo<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3511 ~ indexmap[c409]::set::slice::{impl#28}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::slice::Slice<T/#0>, core::ops::RangeTo<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3512 ~ indexmap[c409]::set::slice::{impl#29}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::IndexSet<T/#0, S/#1>, core::ops::RangeToInclusive<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3513 ~ indexmap[c409]::set::slice::{impl#30}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::slice::Slice<T/#0>, core::ops::RangeToInclusive<usize>], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3514 ~ indexmap[c409]::set::slice::{impl#31}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::IndexSet<T/#0, S/#1>, (core::ops::Bound<usize>, core::ops::Bound<usize>)], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:3515 ~ indexmap[c409]::set::slice::{impl#32}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [set::slice::Slice<T/#0>, (core::ops::Bound<usize>, core::ops::Bound<usize>)], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "(&'^0.Named(DefId(0:2737 ~ indexmap[c409]::map::core::raw_entry_v1::{impl#8}::get_key_value::'_), \"'_\") K/#1, &'^0.Named(DefId(0:2737 ~ indexmap[c409]::map::core::raw_entry_v1::{impl#8}::get_key_value::'_), \"'_\") V/#2)": [
            "get_key_value"
        ],
        "(&'^0.Named(DefId(0:2738 ~ indexmap[c409]::map::core::raw_entry_v1::{impl#8}::get_key_value_mut::'_), \"'_\") mut K/#1, &'^0.Named(DefId(0:2738 ~ indexmap[c409]::map::core::raw_entry_v1::{impl#8}::get_key_value_mut::'_), \"'_\") mut V/#2)": [
            "get_key_value_mut"
        ],
        "(&'^0.Named(DefId(0:2953 ~ indexmap[c409]::map::slice::{impl#1}::split_at::'_), \"'_\") map::slice::Slice<K/#0, V/#1>, &'^0.Named(DefId(0:2953 ~ indexmap[c409]::map::slice::{impl#1}::split_at::'_), \"'_\") map::slice::Slice<K/#0, V/#1>)": [
            "split_at"
        ],
        "(&'^0.Named(DefId(0:2954 ~ indexmap[c409]::map::slice::{impl#1}::split_at_mut::'_), \"'_\") mut map::slice::Slice<K/#0, V/#1>, &'^0.Named(DefId(0:2954 ~ indexmap[c409]::map::slice::{impl#1}::split_at_mut::'_), \"'_\") mut map::slice::Slice<K/#0, V/#1>)": [
            "split_at_mut"
        ],
        "(&'^0.Named(DefId(0:3238 ~ indexmap[c409]::set::slice::{impl#1}::split_at::'_), \"'_\") set::slice::Slice<T/#0>, &'^0.Named(DefId(0:3238 ~ indexmap[c409]::set::slice::{impl#1}::split_at::'_), \"'_\") set::slice::Slice<T/#0>)": [
            "split_at"
        ],
        "(&'^0.Named(DefId(0:3391 ~ indexmap[c409]::{impl#2}::refs::'_), \"'_\") K/#0, &'^0.Named(DefId(0:3391 ~ indexmap[c409]::{impl#2}::refs::'_), \"'_\") V/#1)": [
            "refs"
        ],
        "(&'^0.Named(DefId(0:3392 ~ indexmap[c409]::{impl#2}::ref_mut::'_), \"'_\") K/#0, &'^0.Named(DefId(0:3392 ~ indexmap[c409]::{impl#2}::ref_mut::'_), \"'_\") mut V/#1)": [
            "ref_mut"
        ],
        "(&'^0.Named(DefId(0:3393 ~ indexmap[c409]::{impl#2}::muts::'_), \"'_\") mut K/#0, &'^0.Named(DefId(0:3393 ~ indexmap[c409]::{impl#2}::muts::'_), \"'_\") mut V/#1)": [
            "muts"
        ],
        "(&'a/#0 mut K/#1, &'a/#0 mut V/#2)": [
            "insert",
            "insert_hashed_nocheck",
            "into_key_value_mut",
            "into_muts",
            "or_insert",
            "or_insert_with",
            "shift_insert",
            "shift_insert_hashed_nocheck"
        ],
        "(K/#0, V/#1)": [
            "key_value"
        ],
        "(K/#1, V/#2)": [
            "remove_entry",
            "shift_remove_entry",
            "shift_remove_finish",
            "swap_remove_entry",
            "swap_remove_finish"
        ],
        "(map::core::IndexMapCore<K/#0, V/#1>, alloc::vec::IntoIter<Bucket<K/#0, V/#1>, alloc::alloc::Global>)": [
            "split_splice"
        ],
        "(usize, &'a/#0 mut V/#2)": [
            "insert_sorted"
        ],
        "(usize, bool)": [
            "insert_before",
            "insert_full",
            "insert_sorted"
        ],
        "(usize, core::option::Option<(K/#0, V/#1)>)": [
            "replace_full"
        ],
        "(usize, core::option::Option<T/#0>)": [
            "replace_full"
        ],
        "(usize, core::option::Option<V/#1>)": [
            "insert_before",
            "insert_full",
            "insert_sorted"
        ],
        "(usize, core::option::Option<usize>)": [
            "size_hint"
        ],
        "Alias(Opaque, AliasTy { args: [K/#0, V/#1, '^0.Named(DefId(0:2746 ~ indexmap[c409]::map::core::get_hash::'_), \"'_\")], def_id: DefId(0:2747 ~ indexmap[c409]::map::core::get_hash::{opaque#0}) })": [
            "get_hash"
        ],
        "Alias(Opaque, AliasTy { args: [K/#0, V/#1, Q/#2, '^0.Named(DefId(0:378 ~ indexmap[c409]::map::core::equivalent::'a), \"'a\")], def_id: DefId(0:2750 ~ indexmap[c409]::map::core::equivalent::{opaque#0}) })": [
            "equivalent"
        ],
        "Alias(Projection, AliasTy { args: [&'_/#1 set::IndexSet<T/#2, S1/#3>, &'_/#0 set::IndexSet<T/#2, S2/#4>], def_id: DefId(1:3396 ~ core[a245]::ops::arith::Sub::Output) })": [
            "sub"
        ],
        "Alias(Projection, AliasTy { args: [&'_/#1 set::IndexSet<T/#2, S1/#3>, &'_/#0 set::IndexSet<T/#2, S2/#4>], def_id: DefId(1:34459 ~ core[a245]::ops::bit::BitAnd::Output) })": [
            "bitand"
        ],
        "Alias(Projection, AliasTy { args: [&'_/#1 set::IndexSet<T/#2, S1/#3>, &'_/#0 set::IndexSet<T/#2, S2/#4>], def_id: DefId(1:34632 ~ core[a245]::ops::bit::BitOr::Output) })": [
            "bitor"
        ],
        "Alias(Projection, AliasTy { args: [&'_/#1 set::IndexSet<T/#2, S1/#3>, &'_/#0 set::IndexSet<T/#2, S2/#4>], def_id: DefId(1:34805 ~ core[a245]::ops::bit::BitXor::Output) })": [
            "bitxor"
        ],
        "Alias(Projection, AliasTy { args: [&'a/#0 map::IndexMap<K/#1, V/#2, S/#3>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [&'a/#0 map::slice::Slice<K/#1, V/#2>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [&'a/#0 mut map::IndexMap<K/#1, V/#2, S/#3>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [&'a/#0 mut map::slice::Slice<K/#1, V/#2>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [&'a/#0 set::IndexSet<T/#1, S/#2>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [&'a/#0 set::slice::Slice<T/#1>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [alloc::boxed::Box<map::slice::Slice<K/#0, V/#1>, alloc::alloc::Global>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [alloc::boxed::Box<set::slice::Slice<T/#0>, alloc::alloc::Global>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [map::IndexMap<K/#0, V/#1, S/#2>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Alias(Projection, AliasTy { args: [set::IndexSet<T/#0, S/#1>], def_id: DefId(1:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })": [
            "into_iter"
        ],
        "Bucket": [
            "clone"
        ],
        "GetDisjointMutError": [
            "clone"
        ],
        "HashValue": [
            "clone",
            "hash"
        ],
        "TryReserveError": [
            "clone",
            "from_alloc",
            "from_hashbrown"
        ],
        "TryReserveErrorKind": [
            "clone"
        ],
        "[core::option::Option<&'^0.Named(DefId(0:3052 ~ indexmap[c409]::map::{impl#6}::get_disjoint_mut::'_), \"'_\") mut V/#1>; N/#4]": [
            "get_disjoint_mut"
        ],
        "alloc::boxed::Box": [
            "clone",
            "default",
            "from",
            "into_boxed_slice"
        ],
        "alloc::vec::Drain": [
            "drain"
        ],
        "alloc::vec::Vec": [
            "into_entries"
        ],
        "bool": [
            "contains",
            "contains_key",
            "eq",
            "insert",
            "is_disjoint",
            "is_empty",
            "is_subset",
            "is_superset",
            "remove",
            "shift_insert",
            "shift_remove",
            "slice_eq",
            "swap_remove"
        ],
        "core::cmp::Ordering": [
            "cmp"
        ],
        "core::ops::Range": [
            "simplify_range"
        ],
        "core::option::Option": [
            "first",
            "first_entry",
            "first_mut",
            "from_hash",
            "from_hash_full",
            "from_key",
            "from_key_hashed_nocheck",
            "get",
            "get_full",
            "get_full_mut",
            "get_full_mut2",
            "get_index",
            "get_index_entry",
            "get_index_mut",
            "get_index_mut2",
            "get_index_of",
            "get_key_value",
            "get_mut",
            "get_range",
            "get_range_mut",
            "index_from_hash",
            "insert",
            "last",
            "last_entry",
            "last_mut",
            "next",
            "next_back",
            "nth",
            "nth_back",
            "partial_cmp",
            "pop",
            "remove",
            "remove_entry",
            "replace",
            "shift_insert",
            "shift_remove",
            "shift_remove_entry",
            "shift_remove_full",
            "shift_remove_index",
            "shift_take",
            "split_first",
            "split_first_mut",
            "split_last",
            "split_last_mut",
            "swap_remove",
            "swap_remove_entry",
            "swap_remove_full",
            "swap_remove_index",
            "swap_take",
            "take",
            "try_simplify_range"
        ],
        "core::result::Result": [
            "binary_search",
            "binary_search_by",
            "binary_search_by_key",
            "binary_search_keys",
            "fmt",
            "get_disjoint_indices_mut",
            "get_disjoint_mut",
            "get_disjoint_opt_mut",
            "try_reserve",
            "try_reserve_entries",
            "try_reserve_exact"
        ],
        "map::IndexMap": [
            "clone",
            "default",
            "from",
            "from_iter",
            "new",
            "split_off",
            "with_capacity",
            "with_capacity_and_hasher",
            "with_hasher"
        ],
        "map::core::IndexMapCore": [
            "clone",
            "new",
            "split_off",
            "with_capacity"
        ],
        "map::core::RefMut": [
            "borrow_mut",
            "into_ref_mut",
            "new"
        ],
        "map::core::entry::Entry": [
            "entry"
        ],
        "map::core::entry::IndexedEntry": [
            "from",
            "new"
        ],
        "map::core::entry::OccupiedEntry": [
            "from",
            "insert_entry",
            "insert_unique",
            "new"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder": [
            "raw_entry_v1"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut": [
            "raw_entry_mut_v1"
        ],
        "map::core::raw_entry_v1::RawEntryMut": [
            "from_hash",
            "from_key",
            "from_key_hashed_nocheck"
        ],
        "map::iter::Drain": [
            "drain",
            "new"
        ],
        "map::iter::IntoIter": [
            "clone",
            "default",
            "new",
            "sorted_by",
            "sorted_unstable_by"
        ],
        "map::iter::IntoKeys": [
            "default",
            "into_keys",
            "new"
        ],
        "map::iter::IntoValues": [
            "default",
            "into_values",
            "new"
        ],
        "map::iter::Iter": [
            "clone",
            "default",
            "iter",
            "new"
        ],
        "map::iter::IterMut": [
            "default",
            "iter_mut",
            "new"
        ],
        "map::iter::IterMut2": [
            "default",
            "iter_mut2",
            "new"
        ],
        "map::iter::Keys": [
            "clone",
            "default",
            "keys",
            "new"
        ],
        "map::iter::Splice": [
            "new",
            "splice"
        ],
        "map::iter::Values": [
            "clone",
            "default",
            "new",
            "values"
        ],
        "map::iter::ValuesMut": [
            "default",
            "new",
            "values_mut"
        ],
        "set::IndexSet": [
            "clone",
            "default",
            "from",
            "from_iter",
            "new",
            "split_off",
            "with_capacity",
            "with_capacity_and_hasher",
            "with_hasher"
        ],
        "set::iter::Difference": [
            "clone",
            "difference",
            "new"
        ],
        "set::iter::Drain": [
            "drain",
            "new"
        ],
        "set::iter::Intersection": [
            "clone",
            "intersection",
            "new"
        ],
        "set::iter::IntoIter": [
            "clone",
            "default",
            "new",
            "sorted_by",
            "sorted_unstable_by"
        ],
        "set::iter::Iter": [
            "clone",
            "default",
            "iter",
            "new"
        ],
        "set::iter::Splice": [
            "new",
            "splice"
        ],
        "set::iter::SymmetricDifference": [
            "clone",
            "new",
            "symmetric_difference"
        ],
        "set::iter::Union": [
            "clone",
            "new",
            "union"
        ],
        "u64": [
            "get"
        ],
        "usize": [
            "capacity",
            "count",
            "index",
            "len",
            "partition_point"
        ]
    },
    "struct_to_trait": {
        "Bucket": [
            "core::clone::Clone",
            "core::fmt::Debug",
            "core::marker::Copy"
        ],
        "GetDisjointMutError": [
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::error::Error",
            "core::fmt::Debug",
            "core::fmt::Display",
            "core::marker::StructuralPartialEq"
        ],
        "HashValue": [
            "core::clone::Clone",
            "core::cmp::PartialEq",
            "core::fmt::Debug",
            "core::marker::Copy",
            "core::marker::StructuralPartialEq"
        ],
        "TryReserveError": [
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::error::Error",
            "core::fmt::Debug",
            "core::fmt::Display",
            "core::marker::StructuralPartialEq"
        ],
        "TryReserveErrorKind": [
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::fmt::Debug",
            "core::marker::StructuralPartialEq"
        ],
        "alloc::boxed::Box": [
            "core::clone::Clone",
            "core::convert::From",
            "core::default::Default",
            "core::iter::IntoIterator"
        ],
        "map::IndexMap": [
            "Entries",
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::convert::From",
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::Extend",
            "core::iter::FromIterator",
            "core::iter::IntoIterator",
            "core::ops::Index",
            "core::ops::IndexMut",
            "map::core::raw_entry_v1::RawEntryApiV1",
            "map::core::raw_entry_v1::private::Sealed",
            "map::mutable::MutableKeys",
            "map::mutable::private::Sealed"
        ],
        "map::core::IndexMapCore": [
            "Entries",
            "core::clone::Clone",
            "core::fmt::Debug"
        ],
        "map::core::entry::Entry": [
            "core::fmt::Debug",
            "map::mutable::MutableEntryKey",
            "map::mutable::private::Sealed"
        ],
        "map::core::entry::IndexedEntry": [
            "core::convert::From",
            "core::fmt::Debug",
            "map::mutable::MutableEntryKey",
            "map::mutable::private::Sealed"
        ],
        "map::core::entry::OccupiedEntry": [
            "core::convert::From",
            "core::fmt::Debug",
            "map::mutable::MutableEntryKey",
            "map::mutable::private::Sealed"
        ],
        "map::core::entry::VacantEntry": [
            "core::fmt::Debug",
            "map::mutable::MutableEntryKey",
            "map::mutable::private::Sealed"
        ],
        "map::core::raw_entry_v1::RawEntryBuilder": [
            "core::fmt::Debug"
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut": [
            "core::fmt::Debug"
        ],
        "map::core::raw_entry_v1::RawEntryMut": [
            "core::fmt::Debug"
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut": [
            "core::fmt::Debug"
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut": [
            "core::fmt::Debug"
        ],
        "map::iter::Drain": [
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::iter::IntoIter": [
            "core::clone::Clone",
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::iter::IntoKeys": [
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::iter::IntoValues": [
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::iter::Iter": [
            "core::clone::Clone",
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::iter::IterMut": [
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::iter::IterMut2": [
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::iter::Keys": [
            "core::clone::Clone",
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator",
            "core::ops::Index"
        ],
        "map::iter::Splice": [
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator",
            "core::ops::Drop"
        ],
        "map::iter::Values": [
            "core::clone::Clone",
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::iter::ValuesMut": [
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "map::slice::Slice": [
            "core::cmp::Eq",
            "core::cmp::Ord",
            "core::cmp::PartialEq",
            "core::cmp::PartialOrd",
            "core::fmt::Debug",
            "core::hash::Hash",
            "core::ops::Index",
            "core::ops::IndexMut"
        ],
        "set::IndexSet": [
            "Entries",
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::convert::From",
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::Extend",
            "core::iter::FromIterator",
            "core::iter::IntoIterator",
            "core::ops::Index",
            "set::mutable::MutableValues",
            "set::mutable::private::Sealed"
        ],
        "set::iter::Difference": [
            "core::clone::Clone",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "set::iter::Drain": [
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "set::iter::Intersection": [
            "core::clone::Clone",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "set::iter::IntoIter": [
            "core::clone::Clone",
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "set::iter::Iter": [
            "core::clone::Clone",
            "core::default::Default",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "set::iter::Splice": [
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::ExactSizeIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "set::iter::SymmetricDifference": [
            "core::clone::Clone",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "set::iter::Union": [
            "core::clone::Clone",
            "core::fmt::Debug",
            "core::iter::DoubleEndedIterator",
            "core::iter::FusedIterator",
            "core::iter::Iterator"
        ],
        "set::iter::UnitValue": [
            "core::fmt::Debug",
            "core::iter::Iterator"
        ],
        "set::slice::Slice": [
            "core::cmp::Eq",
            "core::cmp::Ord",
            "core::cmp::PartialEq",
            "core::cmp::PartialOrd",
            "core::fmt::Debug",
            "core::hash::Hash",
            "core::ops::Index"
        ]
    },
    "targets": {
        "<&'a map::slice::Slice<K, V> as core::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::iter::IntoIterator"
        ],
        "<&'a mut map::slice::Slice<K, V> as core::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::iter::IntoIterator"
        ],
        "<&'a set::slice::Slice<T> as core::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::iter::IntoIterator"
        ],
        "<&map::slice::Slice<K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::default::Default"
        ],
        "<&mut map::slice::Slice<K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::default::Default"
        ],
        "<&set::IndexSet<T, S1> as core::ops::BitAnd<&set::IndexSet<T, S2>>>::bitand": [
            "bitand",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::ops::BitAnd"
        ],
        "<&set::IndexSet<T, S1> as core::ops::BitOr<&set::IndexSet<T, S2>>>::bitor": [
            "bitor",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::ops::BitOr"
        ],
        "<&set::IndexSet<T, S1> as core::ops::BitXor<&set::IndexSet<T, S2>>>::bitxor": [
            "bitxor",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::ops::BitXor"
        ],
        "<&set::IndexSet<T, S1> as core::ops::Sub<&set::IndexSet<T, S2>>>::sub": [
            "sub",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::ops::Sub"
        ],
        "<&set::slice::Slice<T> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::default::Default"
        ],
        "<Bucket<K, V> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/lib.rs\"))",
            "core::clone::Clone"
        ],
        "<Bucket<K, V> as core::clone::Clone>::clone_from": [
            "clone_from",
            "Real(LocalPath(\"src/lib.rs\"))",
            "core::clone::Clone"
        ],
        "<GetDisjointMutError as core::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/lib.rs\"))",
            "core::fmt::Display"
        ],
        "<TryReserveError as core::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/lib.rs\"))",
            "core::fmt::Display"
        ],
        "<map::IndexMap<K, V, S> as Entries>::as_entries": [
            "as_entries",
            "Real(LocalPath(\"src/map.rs\"))",
            "Entries"
        ],
        "<map::IndexMap<K, V, S> as Entries>::as_entries_mut": [
            "as_entries_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            "Entries"
        ],
        "<map::IndexMap<K, V, S> as Entries>::into_entries": [
            "into_entries",
            "Real(LocalPath(\"src/map.rs\"))",
            "Entries"
        ],
        "<map::IndexMap<K, V, S> as Entries>::with_entries": [
            "with_entries",
            "Real(LocalPath(\"src/map.rs\"))",
            "Entries"
        ],
        "<map::IndexMap<K, V, S> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::clone::Clone"
        ],
        "<map::IndexMap<K, V, S> as core::clone::Clone>::clone_from": [
            "clone_from",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::clone::Clone"
        ],
        "<map::IndexMap<K, V, S> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::default::Default"
        ],
        "<map::IndexMap<K, V, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::IndexMap<K, V, S> as core::iter::Extend<(&'a K, &'a V)>>::extend": [
            "extend",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Extend"
        ],
        "<map::IndexMap<K, V, S> as core::iter::Extend<(K, V)>>::extend": [
            "extend",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::Extend"
        ],
        "<map::IndexMap<K, V, S> as core::iter::FromIterator<(K, V)>>::from_iter": [
            "from_iter",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::iter::FromIterator"
        ],
        "<map::IndexMap<K, V, S> as core::ops::Index<&Q>>::index": [
            "index",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::ops::Index"
        ],
        "<map::IndexMap<K, V, S> as core::ops::Index<usize>>::index": [
            "index",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::ops::Index"
        ],
        "<map::IndexMap<K, V, S> as core::ops::IndexMut<&Q>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::ops::IndexMut"
        ],
        "<map::IndexMap<K, V, S> as core::ops::IndexMut<usize>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::ops::IndexMut"
        ],
        "<map::IndexMap<K, V, S> as map::core::raw_entry_v1::RawEntryApiV1<K, V, S>>::raw_entry_mut_v1": [
            "raw_entry_mut_v1",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            "map::core::raw_entry_v1::RawEntryApiV1"
        ],
        "<map::IndexMap<K, V, S> as map::core::raw_entry_v1::RawEntryApiV1<K, V, S>>::raw_entry_v1": [
            "raw_entry_v1",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            "map::core::raw_entry_v1::RawEntryApiV1"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::get_full_mut2": [
            "get_full_mut2",
            "Real(LocalPath(\"src/map/mutable.rs\"))",
            "map::mutable::MutableKeys"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::get_index_mut2": [
            "get_index_mut2",
            "Real(LocalPath(\"src/map/mutable.rs\"))",
            "map::mutable::MutableKeys"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::iter_mut2": [
            "iter_mut2",
            "Real(LocalPath(\"src/map/mutable.rs\"))",
            "map::mutable::MutableKeys"
        ],
        "<map::IndexMap<K, V, S> as map::mutable::MutableKeys>::retain2": [
            "retain2",
            "Real(LocalPath(\"src/map/mutable.rs\"))",
            "map::mutable::MutableKeys"
        ],
        "<map::IndexMap<K, V1, S1> as core::cmp::PartialEq<map::IndexMap<K, V2, S2>>>::eq": [
            "eq",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::cmp::PartialEq"
        ],
        "<map::IndexMap<K, V> as core::convert::From<[(K, V); N]>>::from": [
            "from",
            "Real(LocalPath(\"src/map.rs\"))",
            "core::convert::From"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::as_entries": [
            "as_entries",
            "Real(LocalPath(\"src/map/core.rs\"))",
            "Entries"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::as_entries_mut": [
            "as_entries_mut",
            "Real(LocalPath(\"src/map/core.rs\"))",
            "Entries"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::into_entries": [
            "into_entries",
            "Real(LocalPath(\"src/map/core.rs\"))",
            "Entries"
        ],
        "<map::core::IndexMapCore<K, V> as Entries>::with_entries": [
            "with_entries",
            "Real(LocalPath(\"src/map/core.rs\"))",
            "Entries"
        ],
        "<map::core::IndexMapCore<K, V> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/map/core.rs\"))",
            "core::clone::Clone"
        ],
        "<map::core::IndexMapCore<K, V> as core::clone::Clone>::clone_from": [
            "clone_from",
            "Real(LocalPath(\"src/map/core.rs\"))",
            "core::clone::Clone"
        ],
        "<map::core::entry::Entry<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::core::entry::Entry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "key_mut",
            "Real(LocalPath(\"src/map/mutable.rs\"))",
            "map::mutable::MutableEntryKey"
        ],
        "<map::core::entry::IndexedEntry<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::core::entry::IndexedEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "key_mut",
            "Real(LocalPath(\"src/map/mutable.rs\"))",
            "map::mutable::MutableEntryKey"
        ],
        "<map::core::entry::IndexedEntry<'a, K, V> as core::convert::From<map::core::entry::OccupiedEntry<'a, K, V>>>::from": [
            "from",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            "core::convert::From"
        ],
        "<map::core::entry::OccupiedEntry<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::core::entry::OccupiedEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "key_mut",
            "Real(LocalPath(\"src/map/mutable.rs\"))",
            "map::mutable::MutableEntryKey"
        ],
        "<map::core::entry::OccupiedEntry<'a, K, V> as core::convert::From<map::core::entry::IndexedEntry<'a, K, V>>>::from": [
            "from",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            "core::convert::From"
        ],
        "<map::core::entry::VacantEntry<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::core::entry::VacantEntry<'_, K, V> as map::mutable::MutableEntryKey>::key_mut": [
            "key_mut",
            "Real(LocalPath(\"src/map/mutable.rs\"))",
            "map::mutable::MutableEntryKey"
        ],
        "<map::core::raw_entry_v1::RawEntryBuilder<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::core::raw_entry_v1::RawEntryBuilderMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::core::raw_entry_v1::RawEntryMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::core::raw_entry_v1::RawOccupiedEntryMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::core::raw_entry_v1::RawVacantEntryMut<'_, K, V, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::Drain<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Drain<'_, K, V> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoIter<K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::default::Default"
        ],
        "<map::iter::IntoIter<K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoIter<K, V> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoKeys<K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::default::Default"
        ],
        "<map::iter::IntoKeys<K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoKeys<K, V> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoValues<K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::default::Default"
        ],
        "<map::iter::IntoValues<K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IntoValues<K, V> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Iter<'_, K, V> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::clone::Clone"
        ],
        "<map::iter::Iter<'_, K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::default::Default"
        ],
        "<map::iter::Iter<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::Iter<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::Iter<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::Iter<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Iter<'a, K, V> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::default::Default"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::IterMut2<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut2<'a, K, V> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut<'_, K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::default::Default"
        ],
        "<map::iter::IterMut<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::IterMut<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::IterMut<'a, K, V> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Keys<'_, K, V> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::clone::Clone"
        ],
        "<map::iter::Keys<'_, K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::default::Default"
        ],
        "<map::iter::Keys<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::Keys<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::Keys<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::Keys<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::Keys<'_, K, V> as core::ops::Index<usize>>::index": [
            "index",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::ops::Index"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Keys<'a, K, V> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Splice<'_, I, K, V, S> as core::ops::Drop>::drop": [
            "drop",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::ops::Drop"
        ],
        "<map::iter::Values<'_, K, V> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::clone::Clone"
        ],
        "<map::iter::Values<'_, K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::default::Default"
        ],
        "<map::iter::Values<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::Values<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::Values<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::Values<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::Values<'a, K, V> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::default::Default"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<map::iter::ValuesMut<'_, K, V> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::iter::ValuesMut<'a, K, V> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<map::slice::Slice<K, V> as core::cmp::Ord>::cmp": [
            "cmp",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::cmp::Ord"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialEq<[(K2, V2); N]>>::eq": [
            "eq",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::cmp::PartialEq"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialEq<[(K2, V2)]>>::eq": [
            "eq",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::cmp::PartialEq"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialEq<map::slice::Slice<K2, V2>>>::eq": [
            "eq",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::cmp::PartialEq"
        ],
        "<map::slice::Slice<K, V> as core::cmp::PartialOrd>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::cmp::PartialOrd"
        ],
        "<map::slice::Slice<K, V> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::fmt::Debug"
        ],
        "<map::slice::Slice<K, V> as core::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::hash::Hash"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::Range<usize>>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeFrom<usize>>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeFull>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeInclusive<usize>>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeTo<usize>>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<core::ops::RangeToInclusive<usize>>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "<map::slice::Slice<K, V> as core::ops::Index<usize>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::Range<usize>>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeFrom<usize>>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeFull>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeInclusive<usize>>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeTo<usize>>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<core::ops::RangeToInclusive<usize>>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "<map::slice::Slice<K, V> as core::ops::IndexMut<usize>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "<set::IndexSet<T, S1> as core::cmp::PartialEq<set::IndexSet<T, S2>>>::eq": [
            "eq",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::cmp::PartialEq"
        ],
        "<set::IndexSet<T, S> as Entries>::as_entries": [
            "as_entries",
            "Real(LocalPath(\"src/set.rs\"))",
            "Entries"
        ],
        "<set::IndexSet<T, S> as Entries>::as_entries_mut": [
            "as_entries_mut",
            "Real(LocalPath(\"src/set.rs\"))",
            "Entries"
        ],
        "<set::IndexSet<T, S> as Entries>::into_entries": [
            "into_entries",
            "Real(LocalPath(\"src/set.rs\"))",
            "Entries"
        ],
        "<set::IndexSet<T, S> as Entries>::with_entries": [
            "with_entries",
            "Real(LocalPath(\"src/set.rs\"))",
            "Entries"
        ],
        "<set::IndexSet<T, S> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::clone::Clone"
        ],
        "<set::IndexSet<T, S> as core::clone::Clone>::clone_from": [
            "clone_from",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::clone::Clone"
        ],
        "<set::IndexSet<T, S> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::default::Default"
        ],
        "<set::IndexSet<T, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::IndexSet<T, S> as core::iter::Extend<&'a T>>::extend": [
            "extend",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::iter::Extend"
        ],
        "<set::IndexSet<T, S> as core::iter::Extend<T>>::extend": [
            "extend",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::iter::Extend"
        ],
        "<set::IndexSet<T, S> as core::iter::FromIterator<T>>::from_iter": [
            "from_iter",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::iter::FromIterator"
        ],
        "<set::IndexSet<T, S> as core::ops::Index<usize>>::index": [
            "index",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::ops::Index"
        ],
        "<set::IndexSet<T, S> as set::mutable::MutableValues>::get_full_mut2": [
            "get_full_mut2",
            "Real(LocalPath(\"src/set/mutable.rs\"))",
            "set::mutable::MutableValues"
        ],
        "<set::IndexSet<T, S> as set::mutable::MutableValues>::get_index_mut2": [
            "get_index_mut2",
            "Real(LocalPath(\"src/set/mutable.rs\"))",
            "set::mutable::MutableValues"
        ],
        "<set::IndexSet<T, S> as set::mutable::MutableValues>::retain2": [
            "retain2",
            "Real(LocalPath(\"src/set/mutable.rs\"))",
            "set::mutable::MutableValues"
        ],
        "<set::IndexSet<T> as core::convert::From<[T; N]>>::from": [
            "from",
            "Real(LocalPath(\"src/set.rs\"))",
            "core::convert::From"
        ],
        "<set::iter::Difference<'_, T, S> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::clone::Clone"
        ],
        "<set::iter::Difference<'_, T, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::iter::Difference<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::Difference<'a, T, S> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Difference<'a, T, S> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Drain<'_, T> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::iter::Drain<'_, T> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::Drain<'_, T> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::Drain<'_, T> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Drain<'_, T> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Intersection<'_, T, S> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::clone::Clone"
        ],
        "<set::iter::Intersection<'_, T, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::iter::Intersection<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::Intersection<'a, T, S> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Intersection<'a, T, S> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::IntoIter<T> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::default::Default"
        ],
        "<set::iter::IntoIter<T> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::iter::IntoIter<T> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::IntoIter<T> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::IntoIter<T> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::IntoIter<T> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Iter<'_, T> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::clone::Clone"
        ],
        "<set::iter::Iter<'_, T> as core::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::default::Default"
        ],
        "<set::iter::Iter<'_, T> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::iter::Iter<'_, T> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::Iter<'_, T> as core::iter::DoubleEndedIterator>::nth_back": [
            "nth_back",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::Iter<'_, T> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::collect": [
            "collect",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Iter<'a, T> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/macros.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::ExactSizeIterator>::len": [
            "len",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::ExactSizeIterator"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Splice<'_, I, T, S> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::clone::Clone"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::SymmetricDifference<'_, T, S1, S2> as core::iter::DoubleEndedIterator>::rfold": [
            "rfold",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::fold": [
            "fold",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::SymmetricDifference<'a, T, S1, S2> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Union<'_, T, S> as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::clone::Clone"
        ],
        "<set::iter::Union<'_, T, S> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::iter::Union<'_, T, S> as core::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::Union<'_, T, S> as core::iter::DoubleEndedIterator>::rfold": [
            "rfold",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::DoubleEndedIterator"
        ],
        "<set::iter::Union<'a, T, S> as core::iter::Iterator>::fold": [
            "fold",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Union<'a, T, S> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::Union<'a, T, S> as core::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::iter::UnitValue<I> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::iter::UnitValue<I> as core::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::Iterator"
        ],
        "<set::slice::Slice<T> as core::cmp::Ord>::cmp": [
            "cmp",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::cmp::Ord"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialEq<[U; N]>>::eq": [
            "eq",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::cmp::PartialEq"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialEq<[U]>>::eq": [
            "eq",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::cmp::PartialEq"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialEq<set::slice::Slice<U>>>::eq": [
            "eq",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::cmp::PartialEq"
        ],
        "<set::slice::Slice<T> as core::cmp::PartialOrd>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::cmp::PartialOrd"
        ],
        "<set::slice::Slice<T> as core::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::fmt::Debug"
        ],
        "<set::slice::Slice<T> as core::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::hash::Hash"
        ],
        "<set::slice::Slice<T> as core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::Range<usize>>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeFrom<usize>>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeFull>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeInclusive<usize>>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeTo<usize>>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "<set::slice::Slice<T> as core::ops::Index<core::ops::RangeToInclusive<usize>>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "<set::slice::Slice<T> as core::ops::Index<usize>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "Bucket::<K, V>::key": [
            "key",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Bucket::<K, V>::key_ref": [
            "key_ref",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Bucket::<K, V>::key_value": [
            "key_value",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Bucket::<K, V>::muts": [
            "muts",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Bucket::<K, V>::ref_mut": [
            "ref_mut",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Bucket::<K, V>::refs": [
            "refs",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Bucket::<K, V>::value": [
            "value",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Bucket::<K, V>::value_mut": [
            "value_mut",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Bucket::<K, V>::value_ref": [
            "value_ref",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "HashValue::get": [
            "get",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "TryReserveError::from_alloc": [
            "from_alloc",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "TryReserveError::from_hashbrown": [
            "from_hashbrown",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::append": [
            "append",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::as_mut_slice": [
            "as_mut_slice",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::as_slice": [
            "as_slice",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::binary_search_by": [
            "binary_search_by",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::binary_search_by_key": [
            "binary_search_by_key",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::binary_search_keys": [
            "binary_search_keys",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::capacity": [
            "capacity",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::clear": [
            "clear",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::contains_key": [
            "contains_key",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::drain": [
            "drain",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::entry": [
            "entry",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::first": [
            "first",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::first_entry": [
            "first_entry",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::first_mut": [
            "first_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get": [
            "get",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_disjoint_indices_mut": [
            "get_disjoint_indices_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_disjoint_mut": [
            "get_disjoint_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_full": [
            "get_full",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_full_mut": [
            "get_full_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_index": [
            "get_index",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_index_entry": [
            "get_index_entry",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_index_mut": [
            "get_index_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_index_of": [
            "get_index_of",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_key_value": [
            "get_key_value",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_range": [
            "get_range",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::get_range_mut": [
            "get_range_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::hash": [
            "hash",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::hasher": [
            "hasher",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::insert": [
            "insert",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::insert_before": [
            "insert_before",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::insert_full": [
            "insert_full",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::insert_sorted": [
            "insert_sorted",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::into_boxed_slice": [
            "into_boxed_slice",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::into_keys": [
            "into_keys",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::into_values": [
            "into_values",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::is_empty": [
            "is_empty",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::iter": [
            "iter",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::iter_mut": [
            "iter_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::keys": [
            "keys",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::last": [
            "last",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::last_entry": [
            "last_entry",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::last_mut": [
            "last_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::len": [
            "len",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::move_index": [
            "move_index",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::partition_point": [
            "partition_point",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::pop": [
            "pop",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::remove": [
            "remove",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::remove_entry": [
            "remove_entry",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::reserve": [
            "reserve",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::reserve_exact": [
            "reserve_exact",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::retain": [
            "retain",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::reverse": [
            "reverse",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::shift_insert": [
            "shift_insert",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::shift_remove": [
            "shift_remove",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::shift_remove_entry": [
            "shift_remove_entry",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::shift_remove_full": [
            "shift_remove_full",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::shift_remove_index": [
            "shift_remove_index",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::shrink_to": [
            "shrink_to",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::shrink_to_fit": [
            "shrink_to_fit",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::sort_by": [
            "sort_by",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::sort_by_cached_key": [
            "sort_by_cached_key",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::sort_keys": [
            "sort_keys",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::sort_unstable_by": [
            "sort_unstable_by",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::sort_unstable_keys": [
            "sort_unstable_keys",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::sorted_by": [
            "sorted_by",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::sorted_unstable_by": [
            "sorted_unstable_by",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::splice": [
            "splice",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::split_off": [
            "split_off",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::swap_indices": [
            "swap_indices",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::swap_remove": [
            "swap_remove",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::swap_remove_entry": [
            "swap_remove_entry",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::swap_remove_full": [
            "swap_remove_full",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::swap_remove_index": [
            "swap_remove_index",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::truncate": [
            "truncate",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::try_reserve": [
            "try_reserve",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::try_reserve_exact": [
            "try_reserve_exact",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::values": [
            "values",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::values_mut": [
            "values_mut",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::with_capacity_and_hasher": [
            "with_capacity_and_hasher",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V, S>::with_hasher": [
            "with_hasher",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::IndexMap::<K, V>::with_capacity": [
            "with_capacity",
            "Real(LocalPath(\"src/map.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::append_unchecked": [
            "append_unchecked",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::borrow_mut": [
            "borrow_mut",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::capacity": [
            "capacity",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::clear": [
            "clear",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::drain": [
            "drain",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::erase_indices": [
            "erase_indices",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::get_index_of": [
            "get_index_of",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::insert_full": [
            "insert_full",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::len": [
            "len",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::move_index": [
            "move_index",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::pop": [
            "pop",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::push_entry": [
            "push_entry",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::rebuild_hash_table": [
            "rebuild_hash_table",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::replace_full": [
            "replace_full",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::reserve": [
            "reserve",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::reserve_exact": [
            "reserve_exact",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::retain_in_order": [
            "retain_in_order",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::reverse": [
            "reverse",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::shift_remove_full": [
            "shift_remove_full",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::shift_remove_index": [
            "shift_remove_index",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::shrink_to": [
            "shrink_to",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::split_off": [
            "split_off",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::split_splice": [
            "split_splice",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::swap_indices": [
            "swap_indices",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::swap_remove_full": [
            "swap_remove_full",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::swap_remove_index": [
            "swap_remove_index",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::truncate": [
            "truncate",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::try_reserve": [
            "try_reserve",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::try_reserve_entries": [
            "try_reserve_entries",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::try_reserve_exact": [
            "try_reserve_exact",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::IndexMapCore::<K, V>::with_capacity": [
            "with_capacity",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::decrement_indices": [
            "decrement_indices",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::increment_indices": [
            "increment_indices",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::insert_unique": [
            "insert_unique",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::move_index": [
            "move_index",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::reserve_entries": [
            "reserve_entries",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::shift_insert_unique": [
            "shift_insert_unique",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::shift_remove_finish": [
            "shift_remove_finish",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::shift_remove_index": [
            "shift_remove_index",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::swap_indices": [
            "swap_indices",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::swap_remove_finish": [
            "swap_remove_finish",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::RefMut::<'a, K, V>::swap_remove_index": [
            "swap_remove_index",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::entry::<impl map::core::IndexMapCore<K, V>>::entry": [
            "entry",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::Entry::<'a, K, V>::and_modify": [
            "and_modify",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::Entry::<'a, K, V>::index": [
            "index",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::Entry::<'a, K, V>::insert_entry": [
            "insert_entry",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::Entry::<'a, K, V>::key": [
            "key",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::Entry::<'a, K, V>::or_default": [
            "or_default",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::Entry::<'a, K, V>::or_insert": [
            "or_insert",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::Entry::<'a, K, V>::or_insert_with": [
            "or_insert_with",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::Entry::<'a, K, V>::or_insert_with_key": [
            "or_insert_with_key",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::get": [
            "get",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::index": [
            "index",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::insert": [
            "insert",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::into_mut": [
            "into_mut",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::key": [
            "key",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::key_mut": [
            "key_mut",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::move_index": [
            "move_index",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::shift_remove": [
            "shift_remove",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::shift_remove_entry": [
            "shift_remove_entry",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::swap_indices": [
            "swap_indices",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::swap_remove": [
            "swap_remove",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::IndexedEntry::<'a, K, V>::swap_remove_entry": [
            "swap_remove_entry",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::get": [
            "get",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::index": [
            "index",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::insert": [
            "insert",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::into_mut": [
            "into_mut",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::into_muts": [
            "into_muts",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::into_ref_mut": [
            "into_ref_mut",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::key": [
            "key",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::key_mut": [
            "key_mut",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::move_index": [
            "move_index",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::remove": [
            "remove",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::remove_entry": [
            "remove_entry",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::shift_remove": [
            "shift_remove",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::shift_remove_entry": [
            "shift_remove_entry",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::swap_indices": [
            "swap_indices",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::swap_remove": [
            "swap_remove",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::OccupiedEntry::<'a, K, V>::swap_remove_entry": [
            "swap_remove_entry",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::index": [
            "index",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::insert": [
            "insert",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::insert_entry": [
            "insert_entry",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::insert_sorted": [
            "insert_sorted",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::into_key": [
            "into_key",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::key": [
            "key",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::key_mut": [
            "key_mut",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::entry::VacantEntry::<'a, K, V>::shift_insert": [
            "shift_insert",
            "Real(LocalPath(\"src/map/core/entry.rs\"))",
            ""
        ],
        "map::core::equivalent": [
            "equivalent",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::erase_index": [
            "erase_index",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::get_hash": [
            "get_hash",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::insert_bulk_no_grow": [
            "insert_bulk_no_grow",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_hash": [
            "from_hash",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_hash_full": [
            "from_hash_full",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_key": [
            "from_key",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::from_key_hashed_nocheck": [
            "from_key_hashed_nocheck",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryBuilder::<'a, K, V, S>::index_from_hash": [
            "index_from_hash",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_hash": [
            "from_hash",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_key": [
            "from_key",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryBuilderMut::<'a, K, V, S>::from_key_hashed_nocheck": [
            "from_key_hashed_nocheck",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::and_modify": [
            "and_modify",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::index": [
            "index",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::or_insert": [
            "or_insert",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawEntryMut::<'a, K, V, S>::or_insert_with": [
            "or_insert_with",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get": [
            "get",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_key_value": [
            "get_key_value",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_key_value_mut": [
            "get_key_value_mut",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::index": [
            "index",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::insert": [
            "insert",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::insert_key": [
            "insert_key",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_key": [
            "into_key",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_key_value_mut": [
            "into_key_value_mut",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_mut": [
            "into_mut",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::into_ref_mut": [
            "into_ref_mut",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::key": [
            "key",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::key_mut": [
            "key_mut",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::move_index": [
            "move_index",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::remove": [
            "remove",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::remove_entry": [
            "remove_entry",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::shift_remove": [
            "shift_remove",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::shift_remove_entry": [
            "shift_remove_entry",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_indices": [
            "swap_indices",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_remove": [
            "swap_remove",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawOccupiedEntryMut::<'a, K, V, S>::swap_remove_entry": [
            "swap_remove_entry",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::index": [
            "index",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::insert": [
            "insert",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::insert_hashed_nocheck": [
            "insert_hashed_nocheck",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::shift_insert": [
            "shift_insert",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::raw_entry_v1::RawVacantEntryMut::<'a, K, V, S>::shift_insert_hashed_nocheck": [
            "shift_insert_hashed_nocheck",
            "Real(LocalPath(\"src/map/core/raw_entry_v1.rs\"))",
            ""
        ],
        "map::core::reserve_entries": [
            "reserve_entries",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::core::update_index": [
            "update_index",
            "Real(LocalPath(\"src/map/core.rs\"))",
            ""
        ],
        "map::iter::<impl core::iter::IntoIterator for &'a map::IndexMap<K, V, S>>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::IntoIterator"
        ],
        "map::iter::<impl core::iter::IntoIterator for &'a mut map::IndexMap<K, V, S>>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::IntoIterator"
        ],
        "map::iter::<impl core::iter::IntoIterator for map::IndexMap<K, V, S>>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            "core::iter::IntoIterator"
        ],
        "map::iter::Drain::<'a, K, V>::as_slice": [
            "as_slice",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::Drain::<'a, K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IntoIter::<K, V>::as_mut_slice": [
            "as_mut_slice",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IntoIter::<K, V>::as_slice": [
            "as_slice",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IntoIter::<K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IntoKeys::<K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IntoValues::<K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::Iter::<'a, K, V>::as_slice": [
            "as_slice",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::Iter::<'a, K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IterMut2::<'a, K, V>::as_slice": [
            "as_slice",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IterMut2::<'a, K, V>::into_slice": [
            "into_slice",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IterMut2::<'a, K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IterMut::<'a, K, V>::as_slice": [
            "as_slice",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IterMut::<'a, K, V>::into_slice": [
            "into_slice",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::IterMut::<'a, K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::Keys::<'a, K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::Splice::<'a, I, K, V, S>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::Values::<'a, K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::iter::ValuesMut::<'a, K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/iter.rs\"))",
            ""
        ],
        "map::slice::<impl core::clone::Clone for alloc::boxed::Box<map::slice::Slice<K, V>>>::clone": [
            "clone",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::clone::Clone"
        ],
        "map::slice::<impl core::cmp::PartialEq<map::slice::Slice<K2, V2>> for [(K, V); N]>::eq": [
            "eq",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::cmp::PartialEq"
        ],
        "map::slice::<impl core::cmp::PartialEq<map::slice::Slice<K2, V2>> for [(K, V)]>::eq": [
            "eq",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::cmp::PartialEq"
        ],
        "map::slice::<impl core::convert::From<&map::slice::Slice<K, V>> for alloc::boxed::Box<map::slice::Slice<K, V>>>::from": [
            "from",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::convert::From"
        ],
        "map::slice::<impl core::default::Default for alloc::boxed::Box<map::slice::Slice<K, V>>>::default": [
            "default",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::default::Default"
        ],
        "map::slice::<impl core::iter::IntoIterator for alloc::boxed::Box<map::slice::Slice<K, V>>>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::iter::IntoIterator"
        ],
        "map::slice::<impl core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for map::IndexMap<K, V, S>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "map::slice::<impl core::ops::Index<core::ops::Range<usize>> for map::IndexMap<K, V, S>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeFrom<usize>> for map::IndexMap<K, V, S>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeFull> for map::IndexMap<K, V, S>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeInclusive<usize>> for map::IndexMap<K, V, S>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeTo<usize>> for map::IndexMap<K, V, S>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "map::slice::<impl core::ops::Index<core::ops::RangeToInclusive<usize>> for map::IndexMap<K, V, S>>::index": [
            "index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::Index"
        ],
        "map::slice::<impl core::ops::IndexMut<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for map::IndexMap<K, V, S>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::Range<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeFrom<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeFull> for map::IndexMap<K, V, S>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeInclusive<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeTo<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "map::slice::<impl core::ops::IndexMut<core::ops::RangeToInclusive<usize>> for map::IndexMap<K, V, S>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            "core::ops::IndexMut"
        ],
        "map::slice::Slice::<K, V>::binary_search_by": [
            "binary_search_by",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::binary_search_by_key": [
            "binary_search_by_key",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::binary_search_keys": [
            "binary_search_keys",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::first": [
            "first",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::first_mut": [
            "first_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::from_boxed": [
            "from_boxed",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::from_mut_slice": [
            "from_mut_slice",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::from_slice": [
            "from_slice",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::get_disjoint_mut": [
            "get_disjoint_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::get_disjoint_opt_mut": [
            "get_disjoint_opt_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::get_index": [
            "get_index",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::get_index_mut": [
            "get_index_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::get_range": [
            "get_range",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::get_range_mut": [
            "get_range_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::into_boxed": [
            "into_boxed",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::into_entries": [
            "into_entries",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::into_keys": [
            "into_keys",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::into_values": [
            "into_values",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::is_empty": [
            "is_empty",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::iter": [
            "iter",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::iter_mut": [
            "iter_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::keys": [
            "keys",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::last": [
            "last",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::last_mut": [
            "last_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::len": [
            "len",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::new": [
            "new",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::new_mut": [
            "new_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::partition_point": [
            "partition_point",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::split_at": [
            "split_at",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::split_at_mut": [
            "split_at_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::split_first": [
            "split_first",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::split_first_mut": [
            "split_first_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::split_last": [
            "split_last",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::split_last_mut": [
            "split_last_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::values": [
            "values",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "map::slice::Slice::<K, V>::values_mut": [
            "values_mut",
            "Real(LocalPath(\"src/map/slice.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::append": [
            "append",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::as_slice": [
            "as_slice",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::binary_search": [
            "binary_search",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::binary_search_by": [
            "binary_search_by",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::binary_search_by_key": [
            "binary_search_by_key",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::capacity": [
            "capacity",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::clear": [
            "clear",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::contains": [
            "contains",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::difference": [
            "difference",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::drain": [
            "drain",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::first": [
            "first",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::get": [
            "get",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::get_full": [
            "get_full",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::get_index": [
            "get_index",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::get_index_of": [
            "get_index_of",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::get_range": [
            "get_range",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::hasher": [
            "hasher",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::insert": [
            "insert",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::insert_before": [
            "insert_before",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::insert_full": [
            "insert_full",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::insert_sorted": [
            "insert_sorted",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::intersection": [
            "intersection",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::into_boxed_slice": [
            "into_boxed_slice",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::is_disjoint": [
            "is_disjoint",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::is_empty": [
            "is_empty",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::is_subset": [
            "is_subset",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::is_superset": [
            "is_superset",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::iter": [
            "iter",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::last": [
            "last",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::len": [
            "len",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::move_index": [
            "move_index",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::partition_point": [
            "partition_point",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::pop": [
            "pop",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::remove": [
            "remove",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::replace": [
            "replace",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::replace_full": [
            "replace_full",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::reserve": [
            "reserve",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::reserve_exact": [
            "reserve_exact",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::retain": [
            "retain",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::reverse": [
            "reverse",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::shift_insert": [
            "shift_insert",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::shift_remove": [
            "shift_remove",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::shift_remove_full": [
            "shift_remove_full",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::shift_remove_index": [
            "shift_remove_index",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::shift_take": [
            "shift_take",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::shrink_to": [
            "shrink_to",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::shrink_to_fit": [
            "shrink_to_fit",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::sort": [
            "sort",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::sort_by": [
            "sort_by",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::sort_by_cached_key": [
            "sort_by_cached_key",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::sort_unstable": [
            "sort_unstable",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::sort_unstable_by": [
            "sort_unstable_by",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::sorted_by": [
            "sorted_by",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::sorted_unstable_by": [
            "sorted_unstable_by",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::splice": [
            "splice",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::split_off": [
            "split_off",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::swap_indices": [
            "swap_indices",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::swap_remove": [
            "swap_remove",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::swap_remove_full": [
            "swap_remove_full",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::swap_remove_index": [
            "swap_remove_index",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::swap_take": [
            "swap_take",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::symmetric_difference": [
            "symmetric_difference",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::take": [
            "take",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::truncate": [
            "truncate",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::try_reserve": [
            "try_reserve",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::try_reserve_exact": [
            "try_reserve_exact",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::union": [
            "union",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::with_capacity_and_hasher": [
            "with_capacity_and_hasher",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T, S>::with_hasher": [
            "with_hasher",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T>::new": [
            "new",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::IndexSet::<T>::with_capacity": [
            "with_capacity",
            "Real(LocalPath(\"src/set.rs\"))",
            ""
        ],
        "set::iter::<impl core::iter::IntoIterator for &'a set::IndexSet<T, S>>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::IntoIterator"
        ],
        "set::iter::<impl core::iter::IntoIterator for set::IndexSet<T, S>>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            "core::iter::IntoIterator"
        ],
        "set::iter::Difference::<'a, T, S>::new": [
            "new",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::iter::Drain::<'a, T>::as_slice": [
            "as_slice",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::iter::Drain::<'a, T>::new": [
            "new",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::iter::Intersection::<'a, T, S>::new": [
            "new",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::iter::IntoIter::<T>::as_slice": [
            "as_slice",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::iter::IntoIter::<T>::new": [
            "new",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::iter::Iter::<'a, T>::as_slice": [
            "as_slice",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::iter::Iter::<'a, T>::new": [
            "new",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::iter::Splice::<'a, I, T, S>::new": [
            "new",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::iter::SymmetricDifference::<'a, T, S1, S2>::new": [
            "new",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::iter::Union::<'a, T, S>::new": [
            "new",
            "Real(LocalPath(\"src/set/iter.rs\"))",
            ""
        ],
        "set::slice::<impl core::clone::Clone for alloc::boxed::Box<set::slice::Slice<T>>>::clone": [
            "clone",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::clone::Clone"
        ],
        "set::slice::<impl core::cmp::PartialEq<set::slice::Slice<U>> for [T; N]>::eq": [
            "eq",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::cmp::PartialEq"
        ],
        "set::slice::<impl core::cmp::PartialEq<set::slice::Slice<U>> for [T]>::eq": [
            "eq",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::cmp::PartialEq"
        ],
        "set::slice::<impl core::convert::From<&set::slice::Slice<T>> for alloc::boxed::Box<set::slice::Slice<T>>>::from": [
            "from",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::convert::From"
        ],
        "set::slice::<impl core::default::Default for alloc::boxed::Box<set::slice::Slice<T>>>::default": [
            "default",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::default::Default"
        ],
        "set::slice::<impl core::iter::IntoIterator for alloc::boxed::Box<set::slice::Slice<T>>>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::iter::IntoIterator"
        ],
        "set::slice::<impl core::ops::Index<(core::ops::Bound<usize>, core::ops::Bound<usize>)> for set::IndexSet<T, S>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "set::slice::<impl core::ops::Index<core::ops::Range<usize>> for set::IndexSet<T, S>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeFrom<usize>> for set::IndexSet<T, S>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeFull> for set::IndexSet<T, S>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeInclusive<usize>> for set::IndexSet<T, S>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeTo<usize>> for set::IndexSet<T, S>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "set::slice::<impl core::ops::Index<core::ops::RangeToInclusive<usize>> for set::IndexSet<T, S>>::index": [
            "index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            "core::ops::Index"
        ],
        "set::slice::Slice::<T>::binary_search": [
            "binary_search",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::binary_search_by": [
            "binary_search_by",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::binary_search_by_key": [
            "binary_search_by_key",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::first": [
            "first",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::from_boxed": [
            "from_boxed",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::from_slice": [
            "from_slice",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::get_index": [
            "get_index",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::get_range": [
            "get_range",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::into_boxed": [
            "into_boxed",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::into_entries": [
            "into_entries",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::is_empty": [
            "is_empty",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::iter": [
            "iter",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::last": [
            "last",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::len": [
            "len",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::new": [
            "new",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::partition_point": [
            "partition_point",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::split_at": [
            "split_at",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::split_first": [
            "split_first",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "set::slice::Slice::<T>::split_last": [
            "split_last",
            "Real(LocalPath(\"src/set/slice.rs\"))",
            ""
        ],
        "util::simplify_range": [
            "simplify_range",
            "Real(LocalPath(\"src/util.rs\"))",
            ""
        ],
        "util::slice_eq": [
            "slice_eq",
            "Real(LocalPath(\"src/util.rs\"))",
            ""
        ],
        "util::third": [
            "third",
            "Real(LocalPath(\"src/util.rs\"))",
            ""
        ],
        "util::try_simplify_range": [
            "try_simplify_range",
            "Real(LocalPath(\"src/util.rs\"))",
            ""
        ]
    },
    "trait_to_struct": {
        "Entries": [
            "map::IndexMap",
            "map::core::IndexMapCore",
            "set::IndexSet"
        ],
        "core::clone::Clone": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "TryReserveError",
            "TryReserveErrorKind",
            "alloc::boxed::Box",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::iter::IntoIter",
            "map::iter::Iter",
            "map::iter::Keys",
            "map::iter::Values",
            "set::IndexSet",
            "set::iter::Difference",
            "set::iter::Intersection",
            "set::iter::IntoIter",
            "set::iter::Iter",
            "set::iter::SymmetricDifference",
            "set::iter::Union"
        ],
        "core::cmp::Eq": [
            "GetDisjointMutError",
            "TryReserveError",
            "TryReserveErrorKind",
            "map::IndexMap",
            "map::slice::Slice",
            "set::IndexSet",
            "set::slice::Slice"
        ],
        "core::cmp::Ord": [
            "map::slice::Slice",
            "set::slice::Slice"
        ],
        "core::cmp::PartialEq": [
            "GetDisjointMutError",
            "HashValue",
            "TryReserveError",
            "TryReserveErrorKind",
            "map::IndexMap",
            "map::slice::Slice",
            "set::IndexSet",
            "set::slice::Slice"
        ],
        "core::cmp::PartialOrd": [
            "map::slice::Slice",
            "set::slice::Slice"
        ],
        "core::convert::From": [
            "alloc::boxed::Box",
            "map::IndexMap",
            "map::core::entry::IndexedEntry",
            "map::core::entry::OccupiedEntry",
            "set::IndexSet"
        ],
        "core::default::Default": [
            "alloc::boxed::Box",
            "map::IndexMap",
            "map::iter::IntoIter",
            "map::iter::IntoKeys",
            "map::iter::IntoValues",
            "map::iter::Iter",
            "map::iter::IterMut",
            "map::iter::IterMut2",
            "map::iter::Keys",
            "map::iter::Values",
            "map::iter::ValuesMut",
            "set::IndexSet",
            "set::iter::IntoIter",
            "set::iter::Iter"
        ],
        "core::error::Error": [
            "GetDisjointMutError",
            "TryReserveError"
        ],
        "core::fmt::Debug": [
            "Bucket",
            "GetDisjointMutError",
            "HashValue",
            "TryReserveError",
            "TryReserveErrorKind",
            "map::IndexMap",
            "map::core::IndexMapCore",
            "map::core::entry::Entry",
            "map::core::entry::IndexedEntry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry",
            "map::core::raw_entry_v1::RawEntryBuilder",
            "map::core::raw_entry_v1::RawEntryBuilderMut",
            "map::core::raw_entry_v1::RawEntryMut",
            "map::core::raw_entry_v1::RawOccupiedEntryMut",
            "map::core::raw_entry_v1::RawVacantEntryMut",
            "map::iter::Drain",
            "map::iter::IntoIter",
            "map::iter::IntoKeys",
            "map::iter::IntoValues",
            "map::iter::Iter",
            "map::iter::IterMut",
            "map::iter::IterMut2",
            "map::iter::Keys",
            "map::iter::Splice",
            "map::iter::Values",
            "map::iter::ValuesMut",
            "map::slice::Slice",
            "set::IndexSet",
            "set::iter::Difference",
            "set::iter::Drain",
            "set::iter::Intersection",
            "set::iter::IntoIter",
            "set::iter::Iter",
            "set::iter::Splice",
            "set::iter::SymmetricDifference",
            "set::iter::Union",
            "set::iter::UnitValue",
            "set::slice::Slice"
        ],
        "core::fmt::Display": [
            "GetDisjointMutError",
            "TryReserveError"
        ],
        "core::hash::Hash": [
            "map::slice::Slice",
            "set::slice::Slice"
        ],
        "core::iter::DoubleEndedIterator": [
            "map::iter::Drain",
            "map::iter::IntoIter",
            "map::iter::IntoKeys",
            "map::iter::IntoValues",
            "map::iter::Iter",
            "map::iter::IterMut",
            "map::iter::IterMut2",
            "map::iter::Keys",
            "map::iter::Splice",
            "map::iter::Values",
            "map::iter::ValuesMut",
            "set::iter::Difference",
            "set::iter::Drain",
            "set::iter::Intersection",
            "set::iter::IntoIter",
            "set::iter::Iter",
            "set::iter::Splice",
            "set::iter::SymmetricDifference",
            "set::iter::Union"
        ],
        "core::iter::ExactSizeIterator": [
            "map::iter::Drain",
            "map::iter::IntoIter",
            "map::iter::IntoKeys",
            "map::iter::IntoValues",
            "map::iter::Iter",
            "map::iter::IterMut",
            "map::iter::IterMut2",
            "map::iter::Keys",
            "map::iter::Splice",
            "map::iter::Values",
            "map::iter::ValuesMut",
            "set::iter::Drain",
            "set::iter::IntoIter",
            "set::iter::Iter",
            "set::iter::Splice"
        ],
        "core::iter::Extend": [
            "map::IndexMap",
            "set::IndexSet"
        ],
        "core::iter::FromIterator": [
            "map::IndexMap",
            "set::IndexSet"
        ],
        "core::iter::FusedIterator": [
            "map::iter::Drain",
            "map::iter::IntoIter",
            "map::iter::IntoKeys",
            "map::iter::IntoValues",
            "map::iter::Iter",
            "map::iter::IterMut",
            "map::iter::IterMut2",
            "map::iter::Keys",
            "map::iter::Splice",
            "map::iter::Values",
            "map::iter::ValuesMut",
            "set::iter::Difference",
            "set::iter::Drain",
            "set::iter::Intersection",
            "set::iter::IntoIter",
            "set::iter::Iter",
            "set::iter::Splice",
            "set::iter::SymmetricDifference",
            "set::iter::Union"
        ],
        "core::iter::IntoIterator": [
            "alloc::boxed::Box",
            "map::IndexMap",
            "set::IndexSet"
        ],
        "core::iter::Iterator": [
            "map::iter::Drain",
            "map::iter::IntoIter",
            "map::iter::IntoKeys",
            "map::iter::IntoValues",
            "map::iter::Iter",
            "map::iter::IterMut",
            "map::iter::IterMut2",
            "map::iter::Keys",
            "map::iter::Splice",
            "map::iter::Values",
            "map::iter::ValuesMut",
            "set::iter::Difference",
            "set::iter::Drain",
            "set::iter::Intersection",
            "set::iter::IntoIter",
            "set::iter::Iter",
            "set::iter::Splice",
            "set::iter::SymmetricDifference",
            "set::iter::Union",
            "set::iter::UnitValue"
        ],
        "core::marker::Copy": [
            "Bucket",
            "HashValue"
        ],
        "core::marker::StructuralPartialEq": [
            "GetDisjointMutError",
            "HashValue",
            "TryReserveError",
            "TryReserveErrorKind"
        ],
        "core::ops::Drop": [
            "map::iter::Splice"
        ],
        "core::ops::Index": [
            "map::IndexMap",
            "map::iter::Keys",
            "map::slice::Slice",
            "set::IndexSet",
            "set::slice::Slice"
        ],
        "core::ops::IndexMut": [
            "map::IndexMap",
            "map::slice::Slice"
        ],
        "map::core::raw_entry_v1::RawEntryApiV1": [
            "map::IndexMap"
        ],
        "map::core::raw_entry_v1::private::Sealed": [
            "map::IndexMap"
        ],
        "map::mutable::MutableEntryKey": [
            "map::core::entry::Entry",
            "map::core::entry::IndexedEntry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "map::mutable::MutableKeys": [
            "map::IndexMap"
        ],
        "map::mutable::private::Sealed": [
            "map::IndexMap",
            "map::core::entry::Entry",
            "map::core::entry::IndexedEntry",
            "map::core::entry::OccupiedEntry",
            "map::core::entry::VacantEntry"
        ],
        "set::mutable::MutableValues": [
            "set::IndexSet"
        ],
        "set::mutable::private::Sealed": [
            "set::IndexSet"
        ]
    },
    "type_to_def_path": {
        "Bucket<K, V>": "Bucket",
        "GetDisjointMutError": "GetDisjointMutError",
        "HashValue": "HashValue",
        "TryReserveError": "TryReserveError",
        "TryReserveErrorKind": "TryReserveErrorKind",
        "map::IndexMap<K, V, S>": "map::IndexMap",
        "map::core::IndexMapCore<K, V>": "map::core::IndexMapCore",
        "map::core::RefMut<'a, K, V>": "map::core::RefMut",
        "map::core::entry::Entry<'a, K, V>": "map::core::entry::Entry",
        "map::core::entry::IndexedEntry<'a, K, V>": "map::core::entry::IndexedEntry",
        "map::core::entry::OccupiedEntry<'a, K, V>": "map::core::entry::OccupiedEntry",
        "map::core::entry::VacantEntry<'a, K, V>": "map::core::entry::VacantEntry",
        "map::core::raw_entry_v1::RawEntryBuilder<'a, K, V, S>": "map::core::raw_entry_v1::RawEntryBuilder",
        "map::core::raw_entry_v1::RawEntryBuilderMut<'a, K, V, S>": "map::core::raw_entry_v1::RawEntryBuilderMut",
        "map::core::raw_entry_v1::RawEntryMut<'a, K, V, S>": "map::core::raw_entry_v1::RawEntryMut",
        "map::core::raw_entry_v1::RawOccupiedEntryMut<'a, K, V, S>": "map::core::raw_entry_v1::RawOccupiedEntryMut",
        "map::core::raw_entry_v1::RawVacantEntryMut<'a, K, V, S>": "map::core::raw_entry_v1::RawVacantEntryMut",
        "map::iter::Drain<'a, K, V>": "map::iter::Drain",
        "map::iter::IntoIter<K, V>": "map::iter::IntoIter",
        "map::iter::IntoKeys<K, V>": "map::iter::IntoKeys",
        "map::iter::IntoValues<K, V>": "map::iter::IntoValues",
        "map::iter::Iter<'a, K, V>": "map::iter::Iter",
        "map::iter::IterMut2<'a, K, V>": "map::iter::IterMut2",
        "map::iter::IterMut<'a, K, V>": "map::iter::IterMut",
        "map::iter::Keys<'a, K, V>": "map::iter::Keys",
        "map::iter::Splice<'a, I, K, V, S>": "map::iter::Splice",
        "map::iter::Values<'a, K, V>": "map::iter::Values",
        "map::iter::ValuesMut<'a, K, V>": "map::iter::ValuesMut",
        "map::slice::Slice<K, V>": "map::slice::Slice",
        "set::IndexSet<T, S>": "set::IndexSet",
        "set::iter::Difference<'a, T, S>": "set::iter::Difference",
        "set::iter::Drain<'a, T>": "set::iter::Drain",
        "set::iter::Intersection<'a, T, S>": "set::iter::Intersection",
        "set::iter::IntoIter<T>": "set::iter::IntoIter",
        "set::iter::Iter<'a, T>": "set::iter::Iter",
        "set::iter::Splice<'a, I, T, S>": "set::iter::Splice",
        "set::iter::SymmetricDifference<'a, T, S1, S2>": "set::iter::SymmetricDifference",
        "set::iter::Union<'a, T, S>": "set::iter::Union",
        "set::iter::UnitValue<I>": "set::iter::UnitValue",
        "set::slice::Slice<T>": "set::slice::Slice"
    }
}