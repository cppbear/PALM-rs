{"<&'a map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let vec: Vec<_> = map.into_iter().collect();\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_into_iter() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        map.insert(3, 300);\n        \n        let mut vec: Vec<_> = map.into_iter().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, vec![(1, 100), (2, 200), (3, 300)]);\n    }\n\n    #[test]\n    fn test_into_iter_random_order() {\n        let mut map = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        map.insert(4, 40);\n\n        let mut vec: Vec<_> = map.into_iter().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, vec![(1, 10), (2, 20), (3, 30), (4, 40)]);\n    }\n\n    #[test]\n    fn test_into_iter_modified_map() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        \n        let mut iter = map.clone().into_iter();\n        assert_eq!(iter.next(), Some((\"a\", 1)));\n        assert_eq!(iter.next(), Some((\"b\", 2)));\n        assert_eq!(iter.next(), None);\n        \n        map.insert(\"c\", 3);\n        \n        let mut iter2 = map.into_iter();\n        let mut count = 0;\n        while let Some((_, _)) = iter2.next() {\n            count += 1;\n        }\n        assert_eq!(count, 3);\n    }\n}\n```", "<&'a mut map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter() {\n        let mut map: HashMap<_, _> = [(\"a\", 1), (\"b\", 2), (\"c\", 3)].into();\n\n        for (key, value) in map.iter_mut() {\n            *value *= 2;\n        }\n\n        let mut vec = map.iter().collect::<Vec<_>>();\n        vec.sort_unstable();\n        assert_eq!(vec, [(&\"a\", &2), (&\"b\", &4), (&\"c\", &6)]);\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        let mut entries = map.iter_mut();\n\n        assert!(entries.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_single_entry() {\n        let mut map = HashMap::new();\n        map.insert(\"key\", 1);\n\n        for (key, value) in map.iter_mut() {\n            assert_eq!(key, &\"key\");\n            *value += 1;\n        }\n\n        let mut vec = map.iter().collect::<Vec<_>>();\n        vec.sort_unstable();\n        assert_eq!(vec, [(&\"key\", &2)]);\n    }\n}\n```", "<&'a mut table::HashTable<T, A> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_into_iter() {\n        let mut table: HashTable<i32> = HashTable::default();\n        table.insert(1, 10);\n        table.insert(2, 20);\n        table.insert(3, 30);\n        \n        let iter = table.into_iter();\n        let mut collected: Vec<(i32, i32)> = iter.collect();\n\n        collected.sort_by_key(|(k, _)| *k); // Sort to compare keys\n\n        assert_eq!(collected, vec![(1, 10), (2, 20), (3, 30)]);\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let mut table: HashTable<i32> = HashTable::default();\n        let iter = table.into_iter();\n        let collected: Vec<(i32, i32)>: Vec<(i32, i32)> = iter.collect();\n        assert!(collected.is_empty());\n    }\n}\n```", "<&'a set::HashSet<T, S, A> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        map.insert(3, 300);\n\n        let mut vec: Vec<(i32, i32)> = map.into_iter().collect();\n        vec.sort_unstable(); // Ensure a stable order for comparison\n\n        assert_eq!(vec.len(), 3);\n        assert!(vec.contains(&(1, 100)));\n        assert!(vec.contains(&(2, 200)));\n        assert!(vec.contains(&(3, 300)));\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let vec: Vec<(i32, i32)>: Vec<(i32, i32)> = map.into_iter().collect();\n\n        assert!(vec.is_empty());\n    }\n}\n```", "<&'a table::HashTable<T, A> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::RawTable;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_into_iter() {\n        let mut table: RawTable<i32> = RawTable::default();\n\n        // Insert some values into the table\n        let hashes = vec![1, 2, 3, 4, 5];\n        for &v in &hashes {\n            unsafe {\n                table.insert(v as u64, v, |v: &i32| *v as u64);\n            }\n        }\n\n        let iter = table.into_iter();\n\n        // Prepare to collect values\n        let collected: Vec<i32> = iter.collect();\n\n        // Check that the collected values match the inserted values\n        assert_eq!(collected.len(), hashes.len());\n        for &v in &hashes {\n            assert!(collected.contains(&v));\n        }\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let table: RawTable<i32> = RawTable::default();\n\n        let iter = table.into_iter();\n\n        // Collect values from the empty iterator\n        let collected: Vec<i32> = iter.collect();\n\n        // Check that the collected values are empty\n        assert!(collected.is_empty());\n    }\n}\n```", "<&set::HashSet<T, S, A> as core::ops::BitAnd<&set::HashSet<T, S, A>>>::bitand": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitand() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n\n        let intersected_set = &a & &b;\n\n        let expected: HashSet<_> = vec![2, 3].into_iter().collect();\n        assert_eq!(intersected_set, expected);\n    }\n\n    #[test]\n    fn test_bitand_empty_set() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = HashSet::new();\n\n        let intersected_set = &a & &b;\n\n        assert!(intersected_set.is_empty());\n    }\n\n    #[test]\n    fn test_bitand_no_common_elements() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![4, 5, 6].into_iter().collect();\n\n        let intersected_set = &a & &b;\n\n        assert!(intersected_set.is_empty());\n    }\n\n    #[test]\n    fn test_bitand_self() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n\n        let intersected_set = &a & &a;\n\n        assert_eq!(intersected_set, a);\n    }\n}\n```", "<&set::HashSet<T, S, A> as core::ops::BitOr<&set::HashSet<T, S, A>>>::bitor": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitor() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n        \n        let set = &a | &b;\n        \n        let mut i = 0;\n        let expected = [1, 2, 3, 4, 5];\n        for x in &set {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n}\n```", "<&set::HashSet<T, S, A> as core::ops::BitXor<&set::HashSet<T, S, A>>>::bitxor": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitxor_symmetric_difference() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n\n        let set = &a ^ &b;\n\n        let expected = [1, 2, 4, 5];\n        let mut i = 0;\n        for x in &set {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n\n    #[test]\n    fn test_bitxor_empty_set() {\n        let a: HashSet<i32> = HashSet::new();\n        let b: HashSet<i32> = HashSet::new();\n\n        let set = &a ^ &b;\n\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_bitxor_no_overlap() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![4, 5, 6].into_iter().collect();\n\n        let set = &a ^ &b;\n\n        let expected = [1, 2, 3, 4, 5, 6];\n        let mut i = 0;\n        for x in &set {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n\n    #[test]\n    fn test_bitxor_partial_overlap() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n\n        let set = &a ^ &b;\n\n        let expected = [1, 4];\n        let mut i = 0;\n        for x in &set {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n}\n```", "<&set::HashSet<T, S, A> as core::ops::Sub<&set::HashSet<T, S, A>>>::sub": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_subtraction() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n        let result: HashSet<_> = a - &b;\n\n        let expected: HashSet<_> = vec![1, 2].into_iter().collect();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_subtraction_empty() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = HashSet::new();\n        let result: HashSet<_> = a - &b;\n\n        assert_eq!(result, a);\n    }\n\n    #[test]\n    fn test_subtraction_all_elements() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = a.clone();\n        let result: HashSet<_> = a - &b;\n\n        let expected: HashSet<_> = HashSet::new();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_subtraction_no_common_elements() {\n        let a: HashSet<_> = vec![1, 2].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4].into_iter().collect();\n        let result: HashSet<_> = a - &b;\n\n        assert_eq!(result, a);\n    }\n}\n```", "<[control::tag::Tag] as control::tag::TagSliceExt>::fill_tag": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::tag::{Tag, TagSliceExt}; // Adjust the import path as necessary\n\n    #[test]\n    fn test_fill_tag() {\n        let mut tags: [Tag; 5] = [Tag::EMPTY; 5];\n        let new_tag = Tag::full(42); // Replace 42 with an actual hash you want to test\n        tags.fill_tag(new_tag);\n        \n        for tag in &tags {\n            assert_eq!(*tag, new_tag);\n        }\n    }\n    \n    #[test]\n    fn test_fill_tag_with_different_tag() {\n        let mut tags: [Tag; 3] = [Tag::EMPTY; 3];\n        let new_tag = Tag::DELETED;\n        tags.fill_tag(new_tag);\n\n        for tag in &tags {\n            assert_eq!(*tag, new_tag);\n        }\n    }\n}\n```", "<control::bitmask::BitMask as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n\n    #[test]\n    fn test_into_iter_empty() {\n        let bitmask = BitMask(0);\n        let mut iter = bitmask.into_iter();\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_single_bit() {\n        let bitmask = BitMask(1); // Only the first bit is set\n        let mut iter = bitmask.into_iter();\n        assert_eq!(iter.next(), Some(0));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_multiple_bits() {\n        let bitmask = BitMask(0b101); // Bits at positions 0 and 2 are set\n        let mut iter = bitmask.into_iter();\n        assert_eq!(iter.next(), Some(0));\n        assert_eq!(iter.next(), Some(2));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_non_consecutive_bits() {\n        let bitmask = BitMask(0b100010); // Bits at positions 1 and 5 are set\n        let mut iter = bitmask.into_iter();\n        assert_eq!(iter.next(), Some(1));\n        assert_eq!(iter.next(), Some(5));\n        assert!(iter.next().is_none());\n    }\n}\n```", "<control::bitmask::BitMaskIter as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_next() {\n        let mut bitmask = BitMask(0b10100); // Example bitmask with bits 2 and 4 set\n        let mut iter = bitmask.into_iter();\n\n        // First call to next should return the lowest set bit (2)\n        assert_eq!(iter.next(), Some(2));\n        // Next call should return the next lowest set bit (4)\n        assert_eq!(iter.next(), Some(4));\n        // After all set bits are iterated, next should return None\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_no_bits_set() {\n        let mut bitmask = BitMask(0b00000); // Bitmask with no bits set\n        let mut iter = bitmask.into_iter();\n\n        // Should return None since there are no set bits\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_single_bit_set() {\n        let mut bitmask = BitMask(0b00010); // Bitmask with a single bit set (bit 1)\n        let mut iter = bitmask.into_iter();\n\n        // First call to next should return the only set bit (1)\n        assert_eq!(iter.next(), Some(1));\n        // Next call should return None\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "<map::Drain<'_, K, V, A> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_drain_len() {\n        let mut map: HashMap<_, _> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        let drain = map.drain();\n        let length = drain.len();\n        assert_eq!(length, 3, \"The length of the drain should be 3 after initializing with 3 elements\");\n        \n        // Consume some elements\n        let _ = drain.next();\n        let length_after_one = drain.len();\n        assert_eq!(length_after_one, 2, \"The length of the drain should be 2 after consuming one element\");\n        \n        // Consume remaining elements\n        let _ = drain.next();\n        let _ = drain.next();\n        let length_after_all = drain.len();\n        assert_eq!(length_after_all, 0, \"The length of the drain should be 0 after consuming all elements\");\n    }\n\n    #[test]\n    fn test_drain_empty() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        let drain = map.drain();\n        let length = drain.len();\n        assert_eq!(length, 0, \"The length of the drain should be 0 for an empty map\");\n    }\n\n    #[test]\n    fn test_drain_fused() {\n        let mut map: HashMap<_, _> = [(1, \"a\"), (2, \"b\")].into();\n        let mut drain = map.drain();\n        let _ = drain.next();\n        let _ = drain.next();\n        \n        // Ensure that the drain is fused\n        assert_eq!(drain.next(), None, \"After consuming all elements, drain should yield None\");\n        assert_eq!(drain.next(), None, \"Subsequent calls should still yield None\");\n    }\n}\n```", "<map::Drain<'_, K, V, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_fold() {\n        // Create a HashMap to test\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        // Drain the hash map to iterate over its entries\n        let mut drain_iter = map.drain();\n\n        // Use fold to sum the values in the map, starting from an initial sum of 0\n        let sum = drain_iter.fold(0, |acc, (_key, value)| acc + value);\n\n        // Since the values are 10, 20, and 30, the sum should be 60\n        assert_eq!(sum, 60);\n    }\n\n    #[test]\n    fn test_fold_empty() {\n        // Create an empty HashMap\n        let map: HashMap<i32, i32> = HashMap::new();\n\n        // Drain the hash map to iterate over its entries\n        let drain_iter = map.drain();\n\n        // Use fold to sum the values in the empty map, starting from an initial sum of 0\n        let sum = drain_iter.fold(0, |acc, (_key, value)| acc + value);\n\n        // Since the map is empty, the sum should remain 0\n        assert_eq!(sum, 0);\n    }\n\n    #[test]\n    fn test_fold_with_mutation() {\n        // Create a HashMap\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        // Drain the hash map to iterate over its entries\n        let mut drain_iter = map.drain();\n\n        // Initial sum\n        let initial_sum = 5;\n\n        // Use fold and add to the initial sum\n        let total_sum = drain_iter.fold(initial_sum, |acc, (_key, value)| acc + value);\n\n        // The sum should be 5 + 10 + 20 = 35\n        assert_eq!(total_sum, 35);\n    }\n}\n```", "<map::Drain<'_, K, V, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_drain_next() {\n        let mut map: HashMap<_, _> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n\n        let mut drain_iter = map.drain();\n\n        let item1 = drain_iter.next();\n        let item2 = drain_iter.next();\n        let item3 = drain_iter.next();\n\n        // Ensure all items are present, regardless of order\n        let mut items: Vec<_> = vec![item1, item2, item3];\n        items.retain(Option::is_some); // Filter None values\n        items.sort(); // Sort items to check equality\n\n        let expected: Vec<_> = vec![Some((1, \"a\")), Some((2, \"b\")), Some((3, \"c\"))];\n        assert_eq!(items, expected);\n\n        // Ensure that after consuming all items, next returns None\n        assert_eq!(drain_iter.next(), None);\n    }\n\n    #[test]\n    fn test_drain_fused() {\n        let mut map: HashMap<_, _> = [(1, \"a\")].into();\n        let mut drain_iter = map.drain();\n\n        assert_eq!(drain_iter.next(), Some((1, \"a\")));\n        assert_eq!(drain_iter.next(), None);\n        assert_eq!(drain_iter.next(), None); // Fused iterator should consistently return None\n    }\n\n    #[test]\n    fn test_drain_empty() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        let mut drain_iter = map.drain();\n\n        assert_eq!(drain_iter.next(), None); // Nothing to drain\n    }\n}\n```", "<map::Drain<'_, K, V, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let mut drain = map.drain();\n        \n        // Since the map has 3 elements, the size hint should be (3, Some(3)).\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 3);\n        assert_eq!(upper, Some(3));\n\n        drain.next(); // Draining one element\n\n        // After draining one element, the size hint should be (2, Some(2)).\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n\n        drain.next(); // Draining another element\n\n        // After draining another element, the size hint should be (1, Some(1)).\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n\n        drain.next(); // Draining the last element\n\n        // After draining the last element, the size hint should be (0, Some(0)).\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n\n        // Check that the drain is fused\n        assert_eq!(drain.next(), None);\n        assert_eq!(drain.next(), None);\n    }\n}\n```", "<map::ExtractIf<'_, K, V, F, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_extract_if_next() {\n        let mut map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        \n        {\n            let mut extract_if = map.extract_if(|&k, _| k % 2 != 0);\n            let mut results = vec![extract_if.next(), extract_if.next()];\n\n            results.sort_unstable();\n            assert_eq!(results, vec![Some((1, \"a\")), Some((3, \"c\"))]);\n        }\n        \n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_extract_if_next_none() {\n        let mut map: HashMap<i32, &str> = [(2, \"b\")].into();\n        \n        {\n            let mut extract_if = map.extract_if(|&k, _| k % 2 != 0);\n            assert_eq!(extract_if.next(), None);\n        }\n        \n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_extract_if_fused() {\n        let mut map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\")].into();\n        \n        let mut extract_if = map.extract_if(|&k, _| k % 2 != 0);\n        assert_eq!(extract_if.next(), Some((1, \"a\")));\n        assert_eq!(extract_if.next(), None);\n        assert_eq!(extract_if.next(), None); // should still return None\n    }\n}\n```", "<map::ExtractIf<'_, K, V, F, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        let extract_if = map.extract_if(|_, _| false);\n        assert_eq!(extract_if.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_some_elements() {\n        let mut map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        let extract_if = map.extract_if(|_, _| false);\n        assert_eq!(extract_if.size_hint(), (0, Some(3))); // 3 elements exist\n    }\n\n    #[test]\n    fn test_size_hint_after_extraction() {\n        let mut map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        let mut extract_if = map.extract_if(|k, _| k % 2 != 0); // extract odd keys\n        extract_if.next(); // extract one\n        assert_eq!(extract_if.size_hint(), (0, Some(2))); // 2 elements remain\n    }\n\n    #[test]\n    fn test_size_hint_after_extraction_empty() {\n        let mut map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        let mut extract_if = map.extract_if(|k, _| k % 2 != 0); // extract odd keys\n        extract_if.next(); // extract one\n        extract_if.next(); // extract another\n        let _ = extract_if.next(); // extract last\n        assert_eq!(extract_if.size_hint(), (0, Some(0))); // no elements remain\n    }\n}\n```", "<map::HashMap<K, V, S, A> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_clone_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let cloned_map = map.clone();\n        assert_eq!(map.len(), 0);\n        assert_eq!(cloned_map.len(), 0);\n        assert_eq!(cloned_map, map);\n    }\n\n    #[test]\n    fn test_clone_single_entry() {\n        let mut map = HashMap::new();\n        map.insert(1, 2);\n        let cloned_map = map.clone();\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(cloned_map.len(), 1);\n        assert_eq!(cloned_map, map);\n        assert_eq!(cloned_map.get(&1), Some(&2));\n    }\n\n    #[test]\n    fn test_clone_multiple_entries() {\n        let mut map = HashMap::new();\n        map.insert(1, 2);\n        map.insert(3, 4);\n        map.insert(5, 6);\n        let cloned_map = map.clone();\n\n        assert_eq!(map.len(), 3);\n        assert_eq!(cloned_map.len(), 3);\n        assert_eq!(cloned_map, map);\n        assert_eq!(cloned_map.get(&3), Some(&4));\n    }\n\n    #[test]\n    fn test_clone_non_empty_map() {\n        let mut map = HashMap::new();\n        map.insert(\"foo\", \"bar\");\n        map.insert(\"baz\", \"qux\");\n        \n        let cloned_map = map.clone();\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(cloned_map.len(), 2);\n        assert_eq!(cloned_map.get(\"foo\"), Some(&\"bar\"));\n        assert_eq!(cloned_map.get(\"baz\"), Some(&\"qux\"));\n        assert_eq!(cloned_map, map);\n    }\n\n    #[test]\n    fn test_clone_and_modify() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        let cloned_map = map.clone();\n\n        map.insert(2, \"b\");\n        \n        assert_eq!(map.len(), 2);\n        assert_eq!(cloned_map.len(), 1);\n        assert_eq!(cloned_map.get(&1), Some(&\"a\"));\n        assert!(cloned_map.get(&2).is_none());\n    }\n}\n```", "<map::HashMap<K, V, S, A> as core::clone::Clone>::clone_from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_clone_from_different_maps() {\n        let mut source_map: HashMap<i32, &str> = HashMap::new();\n        source_map.insert(1, \"one\");\n        source_map.insert(2, \"two\");\n        \n        let mut target_map: HashMap<i32, &str> = HashMap::new();\n\n        // Clone from source_map to target_map\n        target_map.clone_from(&source_map);\n\n        assert_eq!(target_map.get(&1), Some(&\"one\"));\n        assert_eq!(target_map.get(&2), Some(&\"two\"));\n        assert_eq!(target_map.len(), 2);\n    }\n\n    #[test]\n    fn test_clone_from_empty_map() {\n        let source_map: HashMap<i32, &str> = HashMap::new();\n        let mut target_map: HashMap<i32, &str> = HashMap::new();\n\n        // Clone from empty source_map to target_map\n        target_map.clone_from(&source_map);\n\n        assert!(target_map.is_empty());\n    }\n\n    #[test]\n    fn test_clone_from_map_with_clashing_keys() {\n        let mut source_map: HashMap<i32, &str> = HashMap::new();\n        source_map.insert(1, \"one\");\n        \n        let mut target_map: HashMap<i32, &str> = HashMap::new();\n        target_map.insert(1, \"old_value\");\n\n        // Clone from source_map to target_map\n        target_map.clone_from(&source_map);\n\n        assert_eq!(target_map.get(&1), Some(&\"one\")); // It should overwrite \"old_value\"\n    }\n\n    #[test]\n    fn test_clone_from_map_with_different_sizes() {\n        let mut source_map: HashMap<i32, &str> = HashMap::new();\n        source_map.insert(1, \"one\");\n        source_map.insert(2, \"two\");\n        source_map.insert(3, \"three\");\n\n        let mut target_map: HashMap<i32, &str> = HashMap::new();\n        target_map.insert(1, \"old_value\");\n\n        // Clone from source_map to target_map\n        target_map.clone_from(&source_map);\n\n        assert_eq!(target_map.get(&1), Some(&\"one\"));    // should overwrite\n        assert_eq!(target_map.get(&2), Some(&\"two\"));    // should insert new\n        assert_eq!(target_map.get(&3), Some(&\"three\"));  // should insert new\n        assert_eq!(target_map.len(), 3);                  // should have 3 elements now\n    }\n\n    #[test]\n    fn test_clone_from_with_same_map() {\n        let mut source_map: HashMap<i32, &str> = HashMap::new();\n        source_map.insert(1, \"one\");\n        source_map.insert(2, \"two\");\n\n        // Clone from itself\n        source_map.clone_from(&source_map);\n\n        assert_eq!(source_map.len(), 2);\n        assert_eq!(source_map.get(&1), Some(&\"one\"));\n        assert_eq!(source_map.get(&2), Some(&\"two\"));\n    }\n\n    #[test]\n    fn test_clone_from_with_different_key_value_types() {\n        let mut source_map: HashMap<i32, &str> = HashMap::new();\n        source_map.insert(1, \"one\");\n        source_map.insert(2, \"two\");\n\n        let mut target_map: HashMap<i32, String> = HashMap::new();\n\n        // Clone from source_map to target_map\n        target_map.clone_from(&source_map);\n\n        assert_eq!(target_map.get(&1), Some(&\"one\".to_string())); // Assert with String comparison\n        assert_eq!(target_map.get(&2), Some(&\"two\".to_string())); // Assert with String comparison\n    }\n}\n```", "<map::HashMap<K, V, S, A> as core::cmp::PartialEq>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_eq_different_length() {\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        map1.insert(1, \"a\");\n        map2.insert(1, \"a\");\n        map2.insert(2, \"b\");\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_different_keys() {\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        map1.insert(1, \"a\");\n        map2.insert(2, \"a\");\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_different_values() {\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        map1.insert(1, \"a\");\n        map2.insert(1, \"b\");\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_same() {\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        map1.insert(1, \"a\");\n        map1.insert(2, \"b\");\n        map2.insert(1, \"a\");\n        map2.insert(2, \"b\");\n        assert!(map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_with_different_order() {\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        map1.insert(1, \"a\");\n        map1.insert(2, \"b\");\n        map2.insert(2, \"b\");\n        map2.insert(1, \"a\");\n        assert!(map1.eq(&map2));\n    }\n}\n```", "<map::HashMap<K, V, S, A> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_default_empty_hashmap() {\n        // Test default creation of HashMap\n        let map: HashMap<u32, String> = HashMap::default();\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_default_with_random_state() {\n        use std::collections::hash_map::RandomState;\n\n        // Test default creation of HashMap with RandomState hasher\n        let map: HashMap<u32, String, RandomState> = HashMap::default();\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_default_hashmap_with_elements() {\n        let mut map: HashMap<u32, String> = HashMap::default();\n        map.insert(1, \"one\".to_string());\n        map.insert(2, \"two\".to_string());\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&\"one\".to_string()));\n        assert_eq!(map.get(&2), Some(&\"two\".to_string()));\n    }\n}\n```", "<map::HashMap<K, V, S, A> as core::iter::Extend<&'a (K, V)>>::extend": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_extend_with_tuple_array() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n\n        let arr = [(1, 1), (2, 2)];\n        map.extend(arr.iter());\n        assert_eq!(map.get(&1), Some(&1));\n        \n        let some_vec: Vec<_> = vec![(3, 3), (4, 4)];\n        map.extend(&some_vec);\n\n        let some_arr = [(5, 5), (6, 6)];\n        map.extend(&some_arr);\n\n        let mut vec: Vec<_> = map.into_iter().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]);\n    }\n\n    #[test]\n    fn test_extend_with_another_hashmap() {\n        let mut map1 = HashMap::new();\n        map1.insert(1, 1);\n        map1.insert(2, 2);\n\n        let mut map2 = HashMap::new();\n        map2.extend(map1.clone());\n\n        let mut vec: Vec<_> = map2.into_iter().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [(1, 1), (2, 2)]);\n    }\n\n    #[test]\n    fn test_extend_empty_iterator() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        \n        let empty_vec: Vec<(&usize, &usize)> = Vec::new();\n        map.extend(empty_vec.iter());\n        assert_eq!(map.get(&1), Some(&100));\n    }\n\n    #[test]\n    fn test_replace_existing_values() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n\n        let arr = [(1, 200), (2, 2)];\n        map.extend(arr.iter());\n        assert_eq!(map.get(&1), Some(&200));\n        assert_eq!(map.get(&2), Some(&2));\n    }\n}\n```", "<map::HashMap<K, V, S, A> as core::iter::Extend<(&'a K, &'a V)>>::extend": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_extend_with_array() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        \n        let arr = [(1, 1), (2, 2)];\n        map.extend(arr.iter()); // Extending with an array reference\n        \n        assert_eq!(map.get(&1), Some(&1)); // Check if value 1 is updated\n        assert_eq!(map.get(&2), Some(&2)); // Check if new value is added\n    }\n\n    #[test]\n    fn test_extend_with_vec() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        \n        let vec = vec![(3, 3), (4, 4)];\n        map.extend(vec.iter()); // Extending with a vector\n        \n        assert_eq!(map.get(&3), Some(&3)); // Check if new value is added\n        assert_eq!(map.get(&4), Some(&4)); // Check if new value is added\n    }\n\n    #[test]\n    fn test_extend_with_other_hashmap() {\n        let mut map1 = HashMap::new();\n        map1.insert(1, 100);\n        \n        let mut map2 = HashMap::new();\n        map2.insert(2, 200);\n        \n        map1.extend(&map2);\n        \n        assert_eq!(map1.get(&1), Some(&100)); // Ensure map1 still contains original value\n        assert_eq!(map1.get(&2), Some(&200)); // Ensure new value is added\n    }\n\n    #[test]\n    fn test_extend_overriding_values() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        \n        let arr = [(1, 111), (2, 222)];\n        map.extend(arr.iter()); // Overriding values\n        \n        assert_eq!(map.get(&1), Some(&111)); // Ensure value is updated\n        assert_eq!(map.get(&2), Some(&222)); // Ensure value is updated\n    }\n\n    #[test]\n    fn test_extend_with_empty() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        \n        let empty_vec: Vec<(&i32, &i32)> = vec![];\n        map.extend(empty_vec.iter()); // Extending with an empty vector\n        \n        assert_eq!(map.get(&1), Some(&100)); // Ensure original value is still there\n    }\n\n    #[test]\n    fn test_extend_into_keys() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        \n        let keys: [(i32, i32); 2] = [(2, 200), (3, 300)];\n        map.extend(keys.iter()); // Extending with an array of tuples\n        \n        assert_eq!(map.get(&2), Some(&200)); // Ensure new values are added\n        assert_eq!(map.get(&3), Some(&300)); // Ensure new values are added\n    }\n}\n```", "<map::HashMap<K, V, S, A> as core::iter::Extend<(K, V)>>::extend": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_extend_with_array() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n\n        let some_arr = [(1, 1), (2, 2)];\n        map.extend(some_arr.iter().cloned());\n        assert_eq!(map.get(&1), Some(&1));\n        assert_eq!(map.get(&2), Some(&2));\n    }\n\n    #[test]\n    fn test_extend_with_vec() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n\n        let some_vec = vec![(1, 1), (2, 2)];\n        map.extend(some_vec.iter().cloned());\n        assert_eq!(map.get(&1), Some(&1));\n        assert_eq!(map.get(&2), Some(&2));\n    }\n\n    #[test]\n    fn test_extend_from_another_hashmap() {\n        let mut map1 = HashMap::new();\n        map1.insert(1, 100);\n        map1.insert(2, 200);\n\n        let mut map2 = HashMap::new();\n        map2.extend(map1);\n        assert_eq!(map2.get(&1), Some(&100));\n        assert_eq!(map2.get(&2), Some(&200));\n    }\n\n    #[test]\n    fn test_extend_with_mixed_types() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n\n        let mixed_iter = vec![(1, 150), (3, 300)];\n        map.extend(mixed_iter.iter().cloned());\n        assert_eq!(map.get(&1), Some(&150));\n        assert_eq!(map.get(&2), Some(&200));\n        assert_eq!(map.get(&3), Some(&300));\n    }\n\n    #[test]\n    fn test_extend_does_not_change_unrelated_keys() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n\n        let some_iter = [(3, 300), (4, 400)];\n        map.extend(some_iter.iter().cloned());\n        \n        assert_eq!(map.get(&1), Some(&100));\n        assert_eq!(map.get(&2), Some(&200));\n        assert_eq!(map.get(&3), Some(&300));\n        assert_eq!(map.get(&4), Some(&400));\n    }\n\n    #[test]\n    fn test_extend_and_check_final_length() {\n        let mut map = HashMap::new();\n        let initial_length = map.len();\n\n        let some_vec = vec![(1, 1), (2, 2), (3, 3)];\n        map.extend(some_vec.iter().cloned());\n        \n        assert_eq!(map.len(), initial_length + 3);\n    }\n}\n```", "<map::HashMap<K, V, S, A> as core::iter::FromIterator<(K, V)>>::from_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_from_iter() {\n        let data = vec![(1, \"a\"), (2, \"b\"), (3, \"c\")];\n        let map: HashMap<_, _> = HashMap::from_iter(data.clone());\n        \n        assert_eq!(map.len(), 3);\n        for (k, v) in data {\n            assert_eq!(map.get(&k), Some(&v));\n        }\n    }\n\n    #[test]\n    fn test_from_iter_empty() {\n        let data: Vec<(i32, &str)> = vec![];\n        let map: HashMap<_, _> = HashMap::from_iter(data);\n        \n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_from_iter_with_duplicates() {\n        let data = vec![(1, \"a\"), (1, \"b\"), (2, \"c\")];\n        let map: HashMap<_, _> = HashMap::from_iter(data);\n        \n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&\"b\"));  // Should be \"b\" since it overwrites \"a\"\n        assert_eq!(map.get(&2), Some(&\"c\"));\n    }\n\n    #[test]\n    fn test_from_iter_with_default_hasher() {\n        let data = vec![(1, \"a\"), (2, \"b\")];\n        let map: HashMap<_, _> = HashMap::from_iter(data);\n        \n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&\"a\"));\n        assert_eq!(map.get(&2), Some(&\"b\"));\n    }\n}\n```", "<map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter() {\n        let map: HashMap<_, _> = [(\"a\", 1), (\"b\", 2), (\"c\", 3)].into();\n        \n        let mut vec: Vec<(&str, i32)> = map.into_iter().collect();\n        vec.sort_unstable();\n        \n        assert_eq!(vec, [(\"a\", 1), (\"b\", 2), (\"c\", 3)]);\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let map: HashMap<_, _> = HashMap::new();\n        \n        let vec: Vec<(i32, i32)>: Vec<(i32, i32)> = map.into_iter().collect();\n        \n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_into_iter_with_duplicates() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"a\", 3); // Replacing value for key \"a\"\n\n        let mut vec: Vec<_> = map.into_iter().collect();\n        vec.sort_unstable();\n        \n        assert_eq!(vec, [(\"a\", 3), (\"b\", 2)]);\n    }\n\n    #[test]\n    fn test_into_iter_cannot_use_map() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        map.insert(\"a\", 1);\n        \n        // Call into_iter()\n        let _iter = map.into_iter();\n\n        // Check that the map can no longer be used\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_into_iter_large_data() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        for i in 0..1000 {\n            map.insert(i, i * 2);\n        }\n\n        let mut vec: Vec<(i32, i32)> = map.into_iter().collect();\n        vec.sort_unstable();\n\n        let expected: Vec<(i32, i32)> = (0..1000).map(|i| (i, i * 2)).collect();\n        assert_eq!(vec, expected);\n    }\n}\n```", "<map::HashMap<K, V, S, A> as core::ops::Index<&Q>>::index": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    #[should_panic(expected = \"no entry found for key\")]\n    fn test_index_key_not_present() {\n        let map: HashMap<&str, &str> = HashMap::new();\n        let _ = map[\"key_not_present\"];\n    }\n\n    #[test]\n    fn test_index_key_present() {\n        let mut map: HashMap<&str, &str> = HashMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n\n        assert_eq!(map[\"key1\"], \"value1\");\n        assert_eq!(map[\"key2\"], \"value2\");\n    }\n    \n    #[test]\n    fn test_index_with_uninitialized_key() {\n        let mut map: HashMap<&str, &str> = HashMap::new();\n        map.insert(\"initialized_key\", \"initialized_value\");\n\n        assert_eq!(map[\"initialized_key\"], \"initialized_value\");\n    }\n}\n```", "<map::HashMap<K, V, foldhash::fast::RandomState, A> as core::convert::From<[(K, V); N]>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_hashmap_from_array() {\n        // Test with a simple integer to integer mapping\n        let map: HashMap<i32, i32> = HashMap::from([(1, 2), (3, 4)]);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&2));\n        assert_eq!(map.get(&3), Some(&4));\n\n        // Test with a different set of integers\n        let map2: HashMap<i32, i32> = HashMap::from([(5, 6), (7, 8)]);\n        assert_eq!(map2.len(), 2);\n        assert_eq!(map2.get(&5), Some(&6));\n        assert_eq!(map2.get(&7), Some(&8));\n\n        // Test with empty array\n        let empty_map: HashMap<i32, i32> = HashMap::from([]);\n        assert!(empty_map.is_empty());\n\n        // Test with strings\n        let string_map: HashMap<&str, &str> = HashMap::from([(\"a\", \"apple\"), (\"b\", \"banana\")]);\n        assert_eq!(string_map.get(&\"a\"), Some(&\"apple\"));\n        assert_eq!(string_map.get(&\"b\"), Some(&\"banana\"));\n    }\n}\n```", "<map::IntoIter<K, V, A> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::map::IntoIter;\n\n    #[test]\n    fn test_into_iter_default() {\n        let iter: IntoIter<i32, i32> = IntoIter::default();\n        assert_eq!(iter.len(), 0);\n        assert!(iter.next().is_none());\n    }\n}\n```", "<map::IntoIter<K, V, A> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter_len() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let iter = map.into_iter();\n        let len = iter.len();\n        \n        assert_eq!(len, 3);\n    }\n\n    #[test]\n    fn test_into_iter_len_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        \n        let iter = map.into_iter();\n        let len = iter.len();\n        \n        assert_eq!(len, 0);\n    }\n}\n```", "<map::IntoIter<K, V, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_fold() {\n        let map: HashMap<i32, String> = [(1, \"a\".to_string()), (2, \"b\".to_string()), (3, \"c\".to_string())].into();\n        let iter = map.into_iter();\n\n        let result = iter.fold(String::new(), |acc, (key, value)| {\n            format!(\"{}{}: {}, \", acc, key, value)\n        });\n\n        // Remove the trailing comma and space\n        let trimmed_result = result.trim_end_matches(\", \").to_string();\n        let expected_result = \"1: a, 2: b, 3: c\";\n        assert_eq!(trimmed_result, expected_result);\n    }\n\n    #[test]\n    fn test_fold_with_empty_map() {\n        let map: HashMap<i32, String> = HashMap::new();\n        let iter = map.into_iter();\n\n        let result = iter.fold(String::new(), |acc, (key, value)| {\n            format!(\"{}{}: {}, \", acc, key, value)\n        });\n\n        assert_eq!(result, String::new());\n    }\n\n    #[test]\n    fn test_fold_with_init_value() {\n        let map: HashMap<i32, String> = [(1, \"x\".to_string()), (2, \"y\".to_string())].into();\n        let iter = map.into_iter();\n\n        let result = iter.fold(\"Init: \".to_string(), |acc, (key, value)| {\n            format!(\"{}{}: {}, \", acc, key, value)\n        });\n\n        let trimmed_result = result.trim_end_matches(\", \").to_string();\n        let expected_result = \"Init: 1: x, 2: y\";\n        assert_eq!(trimmed_result, expected_result);\n    }\n}\n```", "<map::IntoIter<K, V, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter_next() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut iter = map.into_iter();\n        let mut vec = vec![iter.next(), iter.next(), iter.next()];\n\n        // The `IntoIter` iterator produces items in arbitrary order, so they must be sorted.\n        vec.sort_unstable();\n        assert_eq!(vec, [Some((1, \"a\")), Some((2, \"b\")), Some((3, \"c\"))]);\n\n        // Check that no more items remain\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_empty_iter() {\n        let map: HashMap<_, _> = HashMap::new();\n        let mut iter = map.into_iter();\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_after_fully_iterating() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let mut iter = map.into_iter();\n        let _ = iter.next();\n        let _ = iter.next();\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None); // Ensure it doesn't panic\n    }\n}\n```", "<map::IntoIter<K, V, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into_iter().collect();\n        let iter = map.into_iter();\n\n        // Check the size_hint when the iterator is created\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 3); // We expect at least 3 elements\n        assert_eq!(upper, Some(3)); // We expect at most 3 elements\n\n        let mut iter = iter; // Re-assign for further tests\n\n        // Check size_hint after consuming some elements\n        iter.next();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 2); // Now we expect at least 2 elements\n        assert_eq!(upper, Some(2)); // Now we expect at most 2 elements\n\n        iter.next();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 1); // Now we expect at least 1 element\n        assert_eq!(upper, Some(1)); // Now we expect at most 1 element\n\n        iter.next();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 0); // Now we expect at least 0 elements\n        assert_eq!(upper, Some(0)); // Now we expect at most 0 elements\n    }\n}\n```", "<map::IntoKeys<K, V, A> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_keys_default() {\n        // Create a HashMap and call into_keys to test default\n        let map: HashMap<i32, &str> = HashMap::new();\n        let keys: IntoKeys<i32, &str> = map.into_keys();\n        \n        // Verify that default creates an empty IntoKeys iterator\n        let keys_default: IntoKeys<i32, &str> = Default::default();\n        let mut vec: Vec<_> = keys_default.collect();\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_into_keys_default_with_elements() {\n        // Create a HashMap and insert elements\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        // Call into_keys and then default\n        let keys: IntoKeys<i32, &str> = map.into_keys();\n        \n        // Verify that default creates an empty IntoKeys iterator\n        let keys_default: IntoKeys<i32, &str> = Default::default();\n        let mut vec_default: Vec<_> = keys_default.collect();\n        assert!(vec_default.is_empty());\n\n        // Collect keys from the original keys iterator\n        let mut vec: Vec<_> = keys.collect();\n        \n        // Check that the keys were collected\n        assert_eq!(vec.len(), 3);\n        vec.sort();\n        assert_eq!(vec, vec![1, 2, 3]);\n    }\n}\n```", "<map::IntoKeys<K, V, A> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_keys_len() {\n        // Create a HashMap and insert some key-value pairs\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        // Create an IntoKeys iterator from the HashMap\n        let keys: IntoKeys<i32, &str> = map.into_keys();\n\n        // Check the length using the len method\n        assert_eq!(keys.len(), 3);\n    }\n\n    #[test]\n    fn test_into_keys_empty_len() {\n        // Create an empty HashMap\n        let map: HashMap<i32, &str> = HashMap::new();\n\n        // Create an IntoKeys iterator from the empty HashMap\n        let keys: IntoKeys<i32, &str> = map.into_keys();\n\n        // Check the length using the len method\n        assert_eq!(keys.len(), 0);\n    }\n\n    #[test]\n    fn test_into_keys_after_consuming() {\n        // Create a HashMap and insert some key-value pairs\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        // Create an IntoKeys iterator\n        let mut keys: IntoKeys<i32, &str> = map.into_keys();\n\n        // Consume some keys\n        keys.next();\n        keys.next();\n\n        // Check the length after consuming\n        assert_eq!(keys.len(), 0);\n    }\n}\n```", "<map::IntoKeys<K, V, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_fold_on_into_keys() {\n        let map: HashMap<u32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        let keys = map.into_keys();\n\n        let sum: u32 = keys.fold(0, |acc, key| acc + key);\n        assert_eq!(sum, 6); // 1 + 2 + 3 = 6\n    }\n\n    #[test]\n    fn test_fold_on_empty_into_keys() {\n        let map: HashMap<u32, &str> = HashMap::new();\n        let keys = map.into_keys();\n\n        let sum: u32 = keys.fold(0, |acc, key| acc + key);\n        assert_eq!(sum, 0); // No keys, sum should be 0\n    }\n\n    #[test]\n    fn test_fold_with_custom_function() {\n        let map: HashMap<u32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\"), (4, \"d\")].into();\n        let keys = map.into_keys();\n\n        let concatenated_keys = keys.fold(String::new(), |acc, key| acc + &format!(\"{}\", key));\n        assert_eq!(concatenated_keys, \"1234\"); // Concatenated string of keys\n    }\n}\n```", "<map::IntoKeys<K, V, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use std::collections::HashSet;\n\n    #[test]\n    fn test_into_keys_next() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut into_keys = map.into_keys();\n        let mut keys = HashSet::new();\n\n        while let Some(key) = into_keys.next() {\n            keys.insert(key);\n        }\n\n        let expected_keys: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        assert_eq!(keys, expected_keys);\n    }\n\n    #[test]\n    fn test_into_keys_next_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let mut into_keys = map.into_keys();\n\n        assert_eq!(into_keys.next(), None);\n    }\n}\n```", "<map::IntoKeys<K, V, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HashMap<u32, u32> = HashMap::new();\n        let keys = map.into_keys();\n        assert_eq!(keys.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut map = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let keys = map.into_keys();\n        \n        // Size hint should reflect the number of keys in the map\n        assert_eq!(keys.size_hint(), (2, Some(2)));\n        \n        // Iterate to exhaust the keys\n        let _ = keys.collect::<Vec<_>>();\n\n        // After collecting, the size hint should still reflect nothing\n        assert_eq!(keys.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_with_fusion() {\n        let mut map = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let mut keys = map.into_keys();\n        \n        // Size hint should reflect the number of keys\n        assert_eq!(keys.size_hint(), (2, Some(2)));\n        assert!(keys.next().is_some());\n        \n        // After consuming one element, size hint should reflect one less\n        assert_eq!(keys.size_hint(), (1, Some(1)));\n        \n        assert!(keys.next().is_some());\n        \n        // After consuming all elements, size hint should reflect nothing\n        assert_eq!(keys.size_hint(), (0, Some(0)));\n        assert!(keys.next().is_none());\n        \n        // After exhausting, confirming the iterator is fused\n        assert_eq!(keys.size_hint(), (0, Some(0)));\n    }\n}\n```", "<map::IntoValues<K, V, A> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_values_default() {\n        let values: IntoValues<i32, &str> = IntoValues::default();\n        assert_eq!(values.len(), 0);\n    }\n\n    #[test]\n    fn test_into_values_default_after_insert() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let values: IntoValues<i32, &str> = map.into_values();\n        let mut collected: Vec<_> = values.collect();\n\n        // The collected values should contain \"a\", \"b\", \"c\" in arbitrary order\n        collected.sort_unstable();\n        assert_eq!(collected, vec![\"a\", \"b\", \"c\"]);\n    }\n}\n```", "<map::IntoValues<K, V, A> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_values_len() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let values: IntoValues<_, _, _> = map.into_values();\n        assert_eq!(values.len(), 3);\n\n        let mut values_empty: IntoValues<_, _, _> = HashMap::new().into_values();\n        assert_eq!(values_empty.len(), 0);\n    }\n}\n```", "<map::IntoValues<K, V, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_fold_with_empty_map() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let result = map.into_values().fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_fold_with_non_empty_map() {\n        let map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        let result = map.into_values().fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 3);\n    }\n\n    #[test]\n    fn test_fold_with_initial_value() {\n        let map: HashMap<i32, i32> = [(1, 10), (2, 20), (3, 30)].into();\n        let result = map.into_values().fold(100, |acc, val| acc + val);\n        assert_eq!(result, 100 + 10 + 20 + 30);\n    }\n\n    #[test]\n    fn test_fold_with_different_operation() {\n        let map: HashMap<i32, i32> = [(1, 1), (2, 2), (3, 3)].into();\n        let result = map.into_values().fold(1, |acc, val| acc * val);\n        assert_eq!(result, 1 * 1 * 2 * 3);\n    }\n\n    #[test]\n    fn test_fold_with_identity_function() {\n        let map: HashMap<i32, i32> = [(1, 5), (2, 10)].into();\n        let result = map.into_values().fold(0, |acc, val| acc + val);\n        assert_eq!(result, 0 + 5 + 10);\n    }\n}\n```", "<map::IntoValues<K, V, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_values_next() {\n        let map: HashMap<_, _> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        let mut values = map.into_values();\n\n        let mut vec = vec![values.next(), values.next(), values.next()];\n\n        // The `IntoValues` iterator produces values in arbitrary order, so\n        // the values must be sorted to test them against a sorted array.\n        vec.sort_unstable();\n        assert_eq!(vec, [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n\n        // It is a fused iterator\n        assert_eq!(values.next(), None);\n        assert_eq!(values.next(), None);\n    }\n}\n```", "<map::IntoValues<K, V, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut into_values = map.into_values();\n        let size_hint = into_values.size_hint();\n\n        // The size hint should reflect the number of elements in the HashMap\n        assert_eq!(size_hint, (3, Some(3)));\n\n        // Consume all elements\n        let _ = into_values.next();\n        let size_hint_after_one = into_values.size_hint();\n\n        // After consuming one element, the size hint should reflect 2 remaining\n        assert_eq!(size_hint_after_one, (2, Some(2)));\n\n        // Consume remaining elements\n        let _ = into_values.next();\n        let _ = into_values.next();\n        let size_hint_after_all = into_values.size_hint();\n\n        // After consuming all elements, the size hint should indicate no remaining elements\n        assert_eq!(size_hint_after_all, (0, Some(0)));\n    }\n}\n```", "<map::Iter<'_, K, V> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_clone_iter() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let iter = map.iter();\n        let cloned_iter = iter.clone();\n        \n        let mut original_values: Vec<_> = iter.collect();\n        let mut cloned_values: Vec<_> = cloned_iter.collect();\n        \n        original_values.sort();\n        cloned_values.sort();\n        \n        assert_eq!(original_values, cloned_values);\n    }\n}\n```", "<map::Iter<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter_default() {\n        // Create an empty HashMap\n        let map: HashMap<i32, i32> = HashMap::new();\n\n        // Create an iterator using the default method\n        let iter: Iter<i32, i32> = Default::default();\n\n        // As the HashMap is empty, the iterator should also be empty\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_default_non_empty() {\n        // Create a HashMap with some values\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        \n        // Create an iterator using the iter method\n        let mut iter = map.iter();\n\n        // Collect the items into a vector\n        let mut items: Vec<_> = iter.collect();\n\n        // Sort the items to ensure consistent order\n        items.sort_unstable();\n\n        // Validate the items in the iterator\n        assert_eq!(items, vec![(&1, &10), (&2, &20), (&3, &30)]);\n    }\n}\n```", "<map::Iter<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_len() {\n        let map: HashMap<u32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        let iter = map.iter();\n\n        assert_eq!(iter.len(), 3);\n\n        let mut iter_clone = iter.clone();\n        assert_eq!(iter_clone.len(), 3);\n\n        // Consume some elements\n        assert!(iter_clone.next().is_some());\n        assert_eq!(iter_clone.len(), 2);\n\n        assert!(iter_clone.next().is_some());\n        assert_eq!(iter_clone.len(), 1);\n\n        // Consume the last element\n        assert!(iter_clone.next().is_some());\n        assert_eq!(iter_clone.len(), 0);\n\n        // No elements left\n        assert!(iter_clone.next().is_none());\n        assert_eq!(iter_clone.len(), 0);\n    }\n\n    #[test]\n    fn test_len_empty() {\n        let map: HashMap<u32, &str> = HashMap::new();\n        let iter = map.iter();\n\n        assert_eq!(iter.len(), 0);\n    }\n}\n```", "<map::Iter<'a, K, V> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter_fold() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        \n        let iter = map.iter();\n        let result = iter.fold(Vec::new(), |mut acc, (&k, &v)| {\n            acc.push((k, v));\n            acc\n        });\n        \n        assert_eq!(result.len(), 3);\n        assert!(result.contains(&(1, \"a\")));\n        assert!(result.contains(&(2, \"b\")));\n        assert!(result.contains(&(3, \"c\")));\n    }\n\n    #[test]\n    fn test_iter_empty_fold() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let iter = map.iter();\n        let result = iter.fold(0, |acc, _| acc + 1);\n        \n        assert_eq!(result, 0);\n    }\n}\n```", "<map::Iter<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_next() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut iter = map.iter();\n        let mut collected = Vec::new();\n\n        while let Some(item) = iter.next() {\n            collected.push(item);\n        }\n\n        // Ensure we collected the correct number of items\n        assert_eq!(collected.len(), 3);\n        // Ensure collected items match original map\n        assert!(collected.contains(&(&1, &\"a\")));\n        assert!(collected.contains(&(&2, &\"b\")));\n        assert!(collected.contains(&(&3, &\"c\")));\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let mut iter = map.iter();\n        \n        assert_eq!(iter.next(), None); // Ensure that calling next on an empty iterator returns None\n    }\n\n    #[test]\n    fn test_next_fused() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n\n        let mut iter = map.iter();\n        assert_eq!(iter.next(), Some((&1, &\"a\"))); // First call returns the item\n        assert_eq!(iter.next(), None); // Second call should return None\n        assert_eq!(iter.next(), None); // Further calls should still return None\n    }\n}\n```", "<map::Iter<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let iter = map.iter();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_single_element() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        let iter = map.iter();\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n    }\n\n    #[test]\n    fn test_size_hint_multiple_elements() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let iter = map.iter();\n        assert_eq!(iter.size_hint(), (2, Some(2)));\n    }\n\n    #[test]\n    fn test_size_hint_after_consuming_elements() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let mut iter = map.iter();\n        iter.next(); // consume one element\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n        iter.next(); // consume another element\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n}\n```", "<map::IterMut<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::marker::PhantomData;\n\n    #[test]\n    fn test_iter_mut_default() {\n        // Create a default instance of IterMut\n        let iter: IterMut<i32, String> = IterMut::default();\n\n        // Check that the inner RawIter is default (should be empty)\n        assert_eq!(iter.inner.len(), 0);\n\n        // Check the marker is set correctly (it should be a marker with the PhantomData)\n        let marker: PhantomData<(&i32, &mut String)> = PhantomData;\n        assert!(std::mem::transmute::<_, &PhantomData<(&i32, &mut String)>>(&iter.marker) == &marker);\n    }\n}\n```", "<map::IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter_mut_len() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        map.insert(1, \"One\".to_owned());\n        map.insert(2, \"Two\".to_owned());\n        map.insert(3, \"Three\".to_owned());\n\n        let mut iter = map.iter_mut();\n        assert_eq!(iter.len(), 3);\n\n        iter.next();\n        assert_eq!(iter.len(), 2);\n\n        iter.next();\n        iter.next();\n        assert_eq!(iter.len(), 0);\n\n        let mut empty_iter: IterMut<i32, String> = IterMut::default();\n        assert_eq!(empty_iter.len(), 0);\n    }\n}\n```", "<map::IterMut<'a, K, V> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap; // adjust the import according to your project's structure\n    \n    #[test]\n    fn test_fold() {\n        let mut map = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let iter = map.iter_mut();\n        let sum = iter.fold(0, |acc, (_, v)| acc + *v);\n        \n        assert_eq!(sum, 60);\n    }\n\n    #[test]\n    fn test_fold_with_empty_map() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let iter = map.iter_mut();\n        let sum = iter.fold(0, |acc, (_, v)| acc + *v);\n        \n        assert_eq!(sum, 0);\n    }\n\n    #[test]\n    fn test_fold_with_custom_function() {\n        let mut map = HashMap::new();\n        map.insert(1, 2);\n        map.insert(2, 3);\n        map.insert(3, 4);\n\n        let iter = map.iter_mut();\n        let product = iter.fold(1, |acc, (_, v)| acc * *v);\n        \n        assert_eq!(product, 24);\n    }\n\n    #[test]\n    fn test_fold_modify_values() {\n        let mut map = HashMap::new();\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.insert(3, 3);\n\n        let iter = map.iter_mut();\n        iter.fold((), |_, (_, v)| {\n            *v += 1; // increment each value\n        });\n\n        assert_eq!(map.get(&1), Some(&2));\n        assert_eq!(map.get(&2), Some(&3));\n        assert_eq!(map.get(&3), Some(&4));\n    }\n}\n```", "<map::IterMut<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter_mut_next() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        map.insert(1, \"One\".to_string());\n        map.insert(2, \"Two\".to_string());\n        \n        let mut iter = map.iter_mut();\n\n        if let Some((k, v)) = iter.next() {\n            assert_eq!(*k, 1);\n            v.push_str(\" Modified\");\n        }\n\n        if let Some((k, v)) = iter.next() {\n            assert_eq!(*k, 2);\n            v.push_str(\" Modified\");\n        }\n\n        assert_eq!(iter.next(), None);\n        assert_eq!(map.get(&1).unwrap(), \"One Modified\");\n        assert_eq!(map.get(&2).unwrap(), \"Two Modified\");\n    }\n\n    #[test]\n    fn test_iter_mut_empty() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        let mut iter = map.iter_mut();\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_mut_fused() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        map.insert(1, \"One\".to_string());\n        let mut iter = map.iter_mut();\n        assert!(iter.next().is_some());\n        assert!(iter.next().is_none());\n        assert!(iter.next().is_none());\n    }\n}\n```", "<map::IterMut<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        map.insert(1, \"One\".to_owned());\n        map.insert(2, \"Two\".into());\n        \n        let mut iter = map.iter_mut();\n        assert_eq!(iter.size_hint(), (2, Some(2)));\n\n        iter.next();\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n\n        iter.next();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n\n        assert_eq!(iter.size_hint(), (0, Some(0))); // Ensure it remains the same after exhausting the iterator\n    }\n\n    #[test]\n    fn test_empty_size_hint() {\n        let map: HashMap<i32, String> = HashMap::new();\n        let iter = map.iter_mut();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n}\n```", "<map::Keys<'_, K, V> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_clone() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let keys = map.keys();\n        let cloned_keys = keys.clone();\n\n        let mut keys_vec: Vec<_> = keys.collect();\n        let mut cloned_keys_vec: Vec<_> = cloned_keys.collect();\n\n        keys_vec.sort_unstable();\n        cloned_keys_vec.sort_unstable();\n\n        assert_eq!(keys_vec, cloned_keys_vec);\n    }\n}\n```", "<map::Keys<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_default() {\n        let default_keys: Keys<i32, i32> = Keys::default();\n        assert_eq!(default_keys.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_default() {\n        let default_iter: Iter<i32, i32> = Iter::default();\n        assert_eq!(default_iter.len(), 0);\n    }\n\n    #[test]\n    fn test_map_keys() {\n        let map: HashMap<i32, i32> = [(1, 10), (2, 20), (3, 30)].iter().cloned().collect();\n        let mut keys = map.keys();\n        let mut collected_keys: Vec<_> = keys.by_ref().collect();\n        collected_keys.sort();\n        assert_eq!(collected_keys, vec![&1, &2, &3]);\n        assert!(keys.next().is_none());\n    }\n\n    #[test]\n    fn test_map_iter() {\n        let map: HashMap<i32, i32> = [(1, 10), (2, 20), (3, 30)].iter().cloned().collect();\n        let mut iter = map.iter();\n        let mut collected_items: Vec<_> = iter.by_ref().collect();\n        collected_items.sort();\n        assert_eq!(collected_items, vec![(&1, &10), (&2, &20), (&3, &30)]);\n        assert!(iter.next().is_none());\n    }\n}\n```", "<map::Keys<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_len() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let keys = map.keys();\n        assert_eq!(keys.len(), 3);\n\n        let empty_map: HashMap<u32, &str> = HashMap::new();\n        let empty_keys = empty_map.keys();\n        assert_eq!(empty_keys.len(), 0);\n    }\n\n    #[test]\n    fn test_keys_len_after_iterating() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let mut keys = map.keys();\n        keys.next(); // Iterate once\n        assert_eq!(keys.len(), 2);\n        keys.next(); // Iterate again\n        assert_eq!(keys.len(), 1);\n        keys.next(); // Iterate again\n        assert_eq!(keys.len(), 0);\n    }\n}\n```", "<map::Keys<'a, K, V> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_fold() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let keys = map.keys();\n        let result = keys.fold(0, |acc, &key| acc + key);\n        \n        assert_eq!(result, 6); // 1 + 2 + 3 = 6\n    }\n\n    #[test]\n    fn test_keys_fold_with_identity() {\n        let map: HashMap<u32, &str> = HashMap::new();\n        let keys = map.keys();\n        \n        let result = keys.fold(10, |acc, &key| acc + key);\n        \n        assert_eq!(result, 10); // no keys, should return the initial value\n    }\n\n    #[test]\n    fn test_keys_fold_with_no_keys() {\n        let map: HashMap<u32, &str> = HashMap::new();\n        \n        let keys = map.keys();\n        let result = keys.fold(100, |acc, &key| acc + key);\n        \n        assert_eq!(result, 100); // no keys, should return the initial value\n    }\n\n    #[test]\n    fn test_keys_fold_with_one_key() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(5, \"a\");\n        \n        let keys = map.keys();\n        let result = keys.fold(0, |acc, &key| acc + key);\n        \n        assert_eq!(result, 5); // only one key, the result should be the key itself\n    }\n}\n```", "<map::Keys<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_next() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut keys = map.keys();\n        let mut vec = vec![keys.next(), keys.next(), keys.next()];\n\n        // The `Keys` iterator produces keys in arbitrary order, so the\n        // keys must be sorted to test them against a sorted array.\n        vec.sort_unstable();\n        assert_eq!(vec, [Some(&1), Some(&2), Some(&3)]);\n    }\n\n    #[test]\n    fn test_keys_next_fused() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        let mut keys = map.keys();\n        \n        // Consuming the keys\n        assert_eq!(keys.next(), Some(&1));\n        assert_eq!(keys.next(), None);\n        assert_eq!(keys.next(), None);\n    }\n\n    #[test]\n    fn test_keys_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let mut keys = map.keys();\n        \n        assert_eq!(keys.next(), None);\n    }\n}\n```", "<map::Keys<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let keys = map.keys();\n        let (lower, upper) = keys.size_hint();\n        \n        assert_eq!(lower, 3);\n        assert_eq!(upper, Some(3));\n    }\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let keys = map.keys();\n        let (lower, upper) = keys.size_hint();\n        \n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```", "<map::Values<'_, K, V> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn clone_values_test() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let values = map.values();\n        let cloned_values = values.clone();\n\n        assert_eq!(values.len(), cloned_values.len());\n        for (v1, v2) in values.zip(cloned_values) {\n            assert_eq!(v1, v2);\n        }\n    }\n}\n```", "<map::Values<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_default() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let values: Values<i32, i32> = Values::default();\n        assert_eq!(values.len(), 0);\n    }\n\n    #[test]\n    fn test_values_iterate_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let values: Values<i32, i32> = map.values();\n\n        let mut collected: Vec<_> = values.collect();\n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_values_iterate_single() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        let values: Values<i32, i32> = map.values();\n\n        let mut collected: Vec<_> = values.collect();\n        collected.sort();\n        assert_eq!(collected, vec![&10]);\n    }\n\n    #[test]\n    fn test_values_iterate_multiple() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        let values: Values<i32, i32> = map.values();\n\n        let mut collected: Vec<_> = values.collect();\n        collected.sort();\n        assert_eq!(collected, vec![&10, &20, &30]);\n    }\n\n    #[test]\n    fn test_values_clone() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        let values: Values<i32, i32> = map.values();\n        let cloned_values = values.clone();\n\n        let mut collected: Vec<_> = cloned_values.collect();\n        collected.sort();\n        assert_eq!(collected, vec![&10]);\n    }\n}\n```", "<map::Values<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_len_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let values: Values<i32, i32> = map.values();\n        assert_eq!(values.len(), 0);\n    }\n\n    #[test]\n    fn test_len_non_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        let values: Values<i32, i32> = map.values();\n        assert_eq!(values.len(), 3);\n    }\n\n    #[test]\n    fn test_len_after_modification() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let mut values: Values<i32, i32> = map.values();\n        assert_eq!(values.len(), 2);\n        map.remove(&1);\n        assert_eq!(values.len(), 2); // Length should not change after modifying the map\n    }\n\n    #[test]\n    fn test_len_clone() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let values: Values<i32, i32> = map.values();\n        let values_clone = values.clone();\n        assert_eq!(values.len(), values_clone.len());\n    }\n\n    #[test]\n    fn test_len_large_map() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        for i in 0..1000 {\n            map.insert(i, i * 10);\n        }\n        let values: Values<i32, i32> = map.values();\n        assert_eq!(values.len(), 1000);\n    }\n}\n```", "<map::Values<'a, K, V> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_fold() {\n        let map: HashMap<i32, i32> = [(1, 1), (2, 2), (3, 3)].iter().cloned().collect();\n        let values = map.values();\n\n        let sum = values.fold(0, |acc, &value| acc + value);\n        assert_eq!(sum, 6);\n    }\n\n    #[test]\n    fn test_fold_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let values = map.values();\n\n        let sum = values.fold(0, |acc, &value| acc + value);\n        assert_eq!(sum, 0);\n    }\n\n    #[test]\n    fn test_fold_with_initial_value() {\n        let map: HashMap<i32, i32> = [(1, 1), (2, 2)].iter().cloned().collect();\n        let values = map.values();\n\n        let sum = values.fold(10, |acc, &value| acc + value);\n        assert_eq!(sum, 13);\n    }\n\n    #[test]\n    fn test_fold_with_identity() {\n        let map: HashMap<i32, i32> = [(1, 1), (2, 2), (3, 3)].iter().cloned().collect();\n        let values = map.values();\n\n        let identity = values.fold(1, |acc, &value| acc * value);\n        assert_eq!(identity, 6);\n    }\n}\n```", "<map::Values<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_next() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut values_iter = map.values();\n        let mut results = vec![values_iter.next(), values_iter.next(), values_iter.next()];\n\n        results.sort_unstable();\n        assert_eq!(results, vec![Some(&\"a\"), Some(&\"b\"), Some(&\"c\")]);\n\n        assert_eq!(values_iter.next(), None);\n        assert_eq!(values_iter.next(), None);\n    }\n\n    #[test]\n    fn test_values_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let mut values_iter = map.values();\n\n        assert_eq!(values_iter.next(), None);\n    }\n}\n```", "<map::Values<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let values = map.values();\n        assert_eq!(values.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        let values = map.values();\n        assert_eq!(values.size_hint(), (3, Some(3)));\n    }\n\n    #[test]\n    fn test_size_hint_after_consuming() {\n        let mut map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].into();\n        let mut values = map.values();\n        assert_eq!(values.size_hint(), (3, Some(3)));\n        values.next(); // Consume one\n        assert_eq!(values.size_hint(), (2, Some(2)));\n        values.next(); // Consume another\n        assert_eq!(values.size_hint(), (1, Some(1)));\n        values.next(); // Consume the last\n        assert_eq!(values.size_hint(), (0, Some(0)));\n    }\n}\n```", "<map::ValuesMut<'_, K, V> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_mut_default() {\n        let default_values: ValuesMut<i32, i32> = ValuesMut::default();\n        assert_eq!(default_values.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_mut_default() {\n        let default_iter_mut: IterMut<i32, i32> = IterMut::default();\n        assert_eq!(default_iter_mut.len(), 0);\n    }\n\n    #[test]\n    fn test_raw_iter_default() {\n        let default_raw_iter: RawIter<i32> = RawIter::default();\n        assert_eq!(default_raw_iter.len(), 0);\n    }\n\n    #[test]\n    fn test_raw_iter_range_default() {\n        let default_raw_iter_range: RawIterRange<i32> = RawIterRange::default();\n        assert_eq!(default_raw_iter_range.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_bucket_clone() {\n        let bucket = Bucket::from_base_index(NonNull::new(0x1 as *mut i32).unwrap(), 0);\n        let cloned_bucket = bucket.clone();\n        assert_eq!(bucket.ptr, cloned_bucket.ptr);\n    }\n\n    #[test]\n    fn test_bitmask_default() {\n        let default_bitmask: BitMask = BitMask(0);\n        assert_eq!(default_bitmask.0, 0);\n    }\n\n    #[test]\n    fn test_bitmask_iter_next() {\n        let bitmask = BitMask(0b1010);\n        let mut iter = BitMaskIter(bitmask);\n        assert_eq!(iter.next(), Some(1));\n        assert_eq!(iter.next(), Some(3));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_bitmask_iter_clone() {\n        let bitmask = BitMask(0b1100);\n        let mut iter = BitMaskIter(bitmask);\n        let cloned_iter = iter.clone();\n        assert_eq!(iter.0.0, cloned_iter.0.0);\n    }\n}\n```", "<map::ValuesMut<'_, K, V> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_mut_len() {\n        let mut map: HashMap<_, _> = [(1, \"One\"), (2, \"Two\"), (3, \"Three\")].iter().cloned().collect();\n\n        let values_mut = map.values_mut();\n        assert_eq!(values_mut.len(), 3);\n\n        let mut values_mut_iter = values_mut;\n        values_mut_iter.next();\n        assert_eq!(values_mut_iter.len(), 2);\n\n        values_mut_iter.next();\n        assert_eq!(values_mut_iter.len(), 1);\n\n        values_mut_iter.next();\n        assert_eq!(values_mut_iter.len(), 0);\n    }\n}\n```", "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n    use crate::control::bitmask::BitMask;\n    use crate::control::bitmask::BitMaskIter;\n    use crate::map::ValuesMut;\n\n    #[test]\n    fn test_fold_values_mut() {\n        let mut map = HashMap::new();\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.insert(3, 3);\n\n        let mut values = ValuesMut {\n            inner: map.iter_mut(),\n        };\n\n        // Fold to sum the values\n        let sum = values.fold(0, |acc, &mut v| acc + v);\n        assert_eq!(sum, 6);\n    }\n\n    #[test]\n    fn test_fold_with_empty_values_mut() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n\n        let values = ValuesMut {\n            inner: map.iter_mut(),\n        };\n\n        // Fold with an empty map\n        let sum = values.fold(0, |acc, &mut _v| acc + 0);\n        assert_eq!(sum, 0);\n    }\n\n    #[test]\n    fn test_fold_with_identity_function() {\n        let mut map = HashMap::new();\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.insert(3, 3);\n\n        let values = ValuesMut {\n            inner: map.iter_mut(),\n        };\n\n        // Folding with an identity function\n        let result = values.fold(1, |acc, &mut v| acc * v);\n        assert_eq!(result, 6);\n    }\n\n    #[test]\n    fn test_fold_with_specific_logic() {\n        let mut map = HashMap::new();\n        map.insert(1, 2);\n        map.insert(2, 3);\n        map.insert(3, 4);\n\n        let values = ValuesMut {\n            inner: map.iter_mut(),\n        };\n\n        // Fold to count number of values that are greater than 2\n        let count = values.fold(0, |acc, &mut v| {\n            if *v > 2 {\n                acc + 1\n            } else {\n                acc\n            }\n        });\n        assert_eq!(count, 2);\n    }\n}\n```", "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_mut_next() {\n        let mut map: HashMap<_, _> = [(1, \"One\".to_owned()), (2, \"Two\".to_owned())].into();\n        let mut values = map.values_mut();\n\n        assert_eq!(values.next().map(|v| *v), Some(\"One\".to_owned()));\n        assert_eq!(values.next().map(|v| *v), Some(\"Two\".to_owned()));\n        assert_eq!(values.next(), None);\n    }\n\n    #[test]\n    fn test_values_mut_next_multiple() {\n        let mut map: HashMap<_, _> = [(1, \"One\".to_owned()), (2, \"Two\".to_owned()), (3, \"Three\".to_owned())].into();\n        let mut values = map.values_mut();\n\n        let first_value = values.next().map(|v| v.push_str(\" Modified\"));\n        let second_value = values.next().map(|v| v.push_str(\" Modified\"));\n        let third_value = values.next().map(|v| v.push_str(\" Modified\"));\n\n        assert!(first_value.is_some());\n        assert!(second_value.is_some());\n        assert!(third_value.is_some());\n\n        assert_eq!(map.get(&1).unwrap(), &\"One Modified\".to_owned());\n        assert_eq!(map.get(&2).unwrap(), &\"Two Modified\".to_owned());\n        assert_eq!(map.get(&3).unwrap(), &\"Three Modified\".to_owned());\n    }\n\n    #[test]\n    fn test_values_mut_next_empty() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        let mut values = map.values_mut();\n\n        assert_eq!(values.next(), None);\n    }\n}\n```", "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_mut_size_hint() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        map.insert(1, \"One\".to_string());\n        map.insert(2, \"Two\".to_string());\n        \n        let values_mut = map.values_mut();\n        \n        // Check initial size_hint\n        let (lower, upper) = values_mut.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n\n        // Consume some values\n        let _ = values_mut.next();\n        \n        // Check size_hint after consuming one value\n        let (lower, upper) = values_mut.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n\n        // Consume all values\n        let _ = values_mut.next();\n        \n        // Check size_hint after consuming all values\n        let (lower, upper) = values_mut.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```", "<raw::Bucket<T> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_clone() {\n        // Create a new Bucket with a dummy pointer\n        let value: i32 = 42;\n        let non_null_ptr = NonNull::new(&value as *const i32 as *mut i32).unwrap();\n        let bucket = Bucket { ptr: non_null_ptr };\n\n        // Clone the bucket\n        let cloned_bucket = bucket.clone();\n\n        // Verify that the cloned bucket points to the same memory\n        assert_eq!(bucket.ptr.as_ptr(), cloned_bucket.ptr.as_ptr());\n    }\n}\n```", "<raw::FullBucketsIndices as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::{BitMask, BitMaskIter};\n\n    #[test]\n    fn test_full_buckets_indices() {\n        // Assuming we have a way to create a `FullBucketsIndices` instance.\n        // Initialize necessary state for `FullBucketsIndices`.\n        let bitmask_word = 0b101101; // Example bitmask\n        let bitmask = BitMask(bitmask_word);\n        let mut bitmask_iter = bitmask.into_iter();\n\n        let mut full_buckets_indices = FullBucketsIndices {\n            current_group: bitmask_iter,\n            group_first_index: 0,\n            ctrl: NonNull::new(0 as *mut u8).unwrap(),\n            items: bitmask.0.count_ones() as usize, // Number of full buckets available\n        };\n\n        // Collect all indices yielded by the iterator\n        let mut indices = Vec::new();\n        while let Some(index) = full_buckets_indices.next() {\n            indices.push(index);\n        }\n\n        // Expected indices based on the provided bitmask.\n        let expected_indices = vec![0, 2, 4]; // Example expected output based on the bitmask\n\n        assert_eq!(indices, expected_indices);\n    }\n\n    #[test]\n    fn test_full_buckets_indices_empty() {\n        let bitmask = BitMask(0); // No bits set\n        let mut bitmask_iter = bitmask.into_iter();\n\n        let mut full_buckets_indices = FullBucketsIndices {\n            current_group: bitmask_iter,\n            group_first_index: 0,\n            ctrl: NonNull::new(0 as *mut u8).unwrap(),\n            items: 0,\n        };\n\n        assert!(full_buckets_indices.next().is_none());\n    }\n\n    #[test]\n    fn test_full_buckets_indices_decrement_items() {\n        let bitmask_word = 0b111; // Example bitmask with all bits set\n        let bitmask = BitMask(bitmask_word);\n        let mut bitmask_iter = bitmask.into_iter();\n\n        let mut full_buckets_indices = FullBucketsIndices {\n            current_group: bitmask_iter,\n            group_first_index: 0,\n            ctrl: NonNull::new(0 as *mut u8).unwrap(),\n            items: 3,\n        };\n\n        full_buckets_indices.next(); // should yield Some\n        assert_eq!(full_buckets_indices.items, 2); // items should be decremented\n        full_buckets_indices.next(); // should yield Some\n        assert_eq!(full_buckets_indices.items, 1); // items should be decremented\n        full_buckets_indices.next(); // should yield Some\n        assert_eq!(full_buckets_indices.items, 0); // items should be decremented\n        assert!(full_buckets_indices.next().is_none()); // No more items\n    }\n}\n```", "<raw::FullBucketsIndices as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_size_hint() {\n        // Create an instance of FullBucketsIndices with a known number of items\n        let items = 10; // Example number of items\n        let bitmask_iter = BitMaskIter(BitMask(0b1111111111)); // Example bitmask with all bits set\n        let group_first_index = 0; // Example index\n        let ctrl = NonNull::new(Box::into_raw(Box::new([0u8; 8]))).unwrap(); // Example pointer\n        let mut full_buckets_indices = FullBucketsIndices {\n            current_group: bitmask_iter,\n            group_first_index,\n            ctrl,\n            items,\n        };\n\n        // Get the size hint\n        let hint = full_buckets_indices.size_hint();\n\n        // Assert that the size hint matches the expected values\n        assert_eq!(hint, (items, Some(items)));\n    }\n}\n```", "<raw::RawDrain<'_, T, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_drain_next() {\n        // Setup\n        let allocator = Global;\n        let mut table = RawTableInner::with_capacity(&allocator, Layout::from_size_align(32, 8).unwrap(), 4);\n        \n        // Simulate inserting elements into table (unsafe to be done directly)\n        let buckets = table.bucket_mask + 1; // Calculate number of buckets\n        for i in 0..buckets {\n            unsafe {\n                let bucket = Bucket::from_base_index(NonNull::new_unchecked(std::ptr::NonNull::dangling().as_ptr().add(i)), i);\n                // Here you would add the bucket into the table (mock insertion)\n            }\n        }\n        \n        // Create RawDrain\n        let orig_table = NonNull::new(&table).unwrap();\n        let drain = RawDrain {\n            iter: RawIter::default(), // This would be set to the appropriate RawIter\n            table, \n            orig_table, \n            marker: PhantomData,\n        };\n\n        // Testing the `next` method of `RawDrain`\n        let mut drain_iter = drain;\n\n        // Check the first next call\n        let first_item = drain_iter.next();\n        assert!(first_item.is_some());\n        // Validate the first item was correctly read (mock check)\n        // let value = first_item.unwrap();\n        // assert_eq!(value, /* expected value */);\n        \n        // Check the next one\n        let second_item = drain_iter.next();\n        assert!(second_item.is_some());\n        // Validate the second item was correctly read (mock check)\n        // let value = second_item.unwrap();\n        // assert_eq!(value, /* expected value */);\n        \n        // Continue until it returns None\n        while let Some(_) = drain_iter.next() {};\n\n        // Final check for None\n        assert!(drain_iter.next().is_none());\n    }\n}\n```", "<raw::RawDrain<'_, T, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_size_hint_with_items() {\n        // Setting up a mock RawDrain\n        let mut raw_drain: RawDrain<i32, Global> = {\n            let table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 8, Fallibility::Infallible).unwrap();\n            let iter = RawIter::default();\n            RawDrain {\n                iter,\n                table,\n                orig_table: NonNull::new(&table).unwrap(),\n                marker: PhantomData\n            }\n        };\n\n        // Assuming some elements have been inserted\n        raw_drain.iter.items = 4; // Simulate 4 items to drain\n        let (lower, upper) = raw_drain.size_hint();\n        \n        // Expect to see the correct size hint\n        assert_eq!(lower, 4);\n        assert_eq!(upper, Some(4));\n    }\n\n    #[test]\n    fn test_size_hint_no_items() {\n        // Setting up a mock RawDrain\n        let mut raw_drain: RawDrain<i32, Global> = {\n            let table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 8, Fallibility::Infallible).unwrap();\n            let iter = RawIter::default();\n            RawDrain {\n                iter,\n                table,\n                orig_table: NonNull::new(&table).unwrap(),\n                marker: PhantomData\n            }\n        };\n\n        // Simulate no items to drain\n        raw_drain.iter.items = 0; // Simulate 0 items to drain\n        let (lower, upper) = raw_drain.size_hint();\n        \n        // Expect to see (0, Some(0)) hint\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```", "<raw::RawDrain<'_, T, A> as core::ops::Drop>::drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n    \n    struct TestAllocator;\n    impl Allocator for TestAllocator {\n        // Implementation of Allocator methods\n    }\n\n    #[test]\n    fn test_raw_drain_drop() {\n        let allocator = TestAllocator;\n        let mut table = unsafe {\n            RawTableInner::new_uninitialized(&allocator, /* table layout */, /* buckets */)\n                .unwrap()\n        };\n\n        let table_ptr = NonNull::new(&mut table).unwrap();\n        let raw_drain = RawDrain {\n            iter: RawIter::default(),\n            table,\n            orig_table: table_ptr,\n            marker: PhantomData,\n        };\n\n        // When `raw_drain` goes out of scope, `drop` should be called\n        // and we can assert that the elements have been dropped correctly.\n        // This can be done by asserting that the table is now empty or\n        // check for specific conditions based on `Drop` implementation.\n    }\n}\n```", "<raw::RawIntoIter<T, A> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_into_iter_default() {\n        let iter: RawIntoIter<i32, Global> = RawIntoIter::default();\n        assert!(iter.allocation.is_none());\n        assert_eq!(iter.marker, PhantomData::<i32>);\n\n        let iter_default = RawIter::<i32>::default();\n        assert_eq!(iter.iter, iter_default);\n    }\n}\n```", "<raw::RawIntoIter<T, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_into_iter_next() {\n        unsafe {\n            // Set up raw table and iter\n            let items = vec![1, 2, 3, 4, 5];\n            let layout = std::alloc::Layout::array::<i32>(items.len()).unwrap();\n            let ptr = NonNull::new(std::alloc::alloc(layout)).unwrap();\n\n            // Initialize the allocated memory\n            for (i, &item) in items.iter().enumerate() {\n                ptr.as_ptr().add(i).write(item);\n            }\n\n            let mut iter = RawIntoIter {\n                iter: RawIter {\n                    iter: RawIterRange::new(ptr.as_ptr() as *const u8, Bucket::<i32>::from_base_index(ptr, items.len()), items.len()),\n                    items: items.len(),\n                },\n                allocation: Some((ptr.cast(), layout, Global)),\n                marker: PhantomData,\n            };\n\n            // Collect all items using next\n            let mut collected: Vec<i32> = Vec::new();\n            while let Some(item) = iter.next() {\n                collected.push(item);\n            }\n\n            // Verify all items were collected\n            assert_eq!(collected, items);\n\n            // Clean up\n            std::alloc::dealloc(ptr.as_ptr(), layout);\n        }\n    }\n}\n```", "<raw::RawIntoIter<T, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_size_hint() {\n        let bitmask = BitMask(0b1100);\n        let iter = BitMaskIter(bitmask);\n        \n        let raw_into_iter: RawIntoIter<u32> = RawIntoIter::default(); // Assuming default initializes a valid RawIntoIter\n\n        // Assuming RawIter has been properly initialized\n        raw_into_iter.iter = RawIter {\n            iter: RawIterRange::new(std::ptr::null(), Bucket { ptr: NonNull::dangling() }, 0), // Replace with real initialization\n            items: 4, // Set a known number of items\n        };\n\n        let (lower, upper) = raw_into_iter.size_hint();\n        assert_eq!(lower, 4);\n        assert_eq!(upper, Some(4));\n    }\n}\n```", "<raw::RawIntoIter<T, A> as core::ops::Drop>::drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_raw_into_iter_drop() {\n        // Create an instance of RawIntoIter\n        let allocator = System;\n        let mut iter: RawIntoIter<i32, System> = RawIntoIter::default();\n        // You would typically populate `iter` with data here, but we are\n        // testing drop, so we will just drop it.\n\n        // Ensure drop doesn't panic and correctly deallocates\n        // Creating and dropping multiple instances to check for proper allocation/deallocation\n        {\n            let mut iter1 = RawIntoIter::default();\n            let mut iter2 = RawIntoIter::default();\n            // We can simulate the iter's lifecycle here\n            std::mem::drop(iter1);\n            std::mem::drop(iter2);\n            // No panic should occur; the deallocation should occur safely\n        }\n    }\n\n    #[test]\n    fn test_raw_into_iter_drop_elements() {\n        // Create an instance of RawIntoIter with elements\n        let allocator = System;\n        let mut iter: RawIntoIter<i32, System> = RawIntoIter::default();\n        \n        // Here we would simulate the process of the iterator containing elements\n        // For testing, just invoke drop_elements method\n        unsafe {\n            iter.iter.drop_elements();\n        }\n        // Drop the iterator to check for potential panics\n        std::mem::drop(iter);\n    }\n}\n```", "<raw::RawIter<T> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_clone() {\n        // Create a dummy bucket\n        let dummy_bucket = unsafe { Bucket::from_base_index(NonNull::dangling(), 0) };\n        \n        // Create a RawIterRange\n        let raw_iter_range = RawIterRange {\n            current_group: BitMaskIter(BitMask(0)), // dummy implementation\n            data: dummy_bucket,\n            next_ctrl: core::ptr::null(),\n            end: core::ptr::null(),\n        };\n        \n        // Create a RawIter\n        let raw_iter = RawIter {\n            iter: raw_iter_range,\n            items: 1,\n        };\n        \n        // Clone the RawIter\n        let cloned_iter = raw_iter.clone();\n\n        // Assert that items are equal\n        assert_eq!(raw_iter.items, cloned_iter.items);\n\n        // Assert that iter's data are equal (for the sake of example, we will compare pointers)\n        assert_eq!(raw_iter.iter.data.as_ptr(), cloned_iter.iter.data.as_ptr());\n    }\n\n    #[test]\n    fn test_raw_iter_range_clone() {\n        // Create a dummy bucket\n        let dummy_bucket = unsafe { Bucket::from_base_index(NonNull::dangling(), 0) };\n        \n        // Create a RawIterRange\n        let raw_iter_range = RawIterRange {\n            current_group: BitMaskIter(BitMask(0)), // dummy implementation\n            data: dummy_bucket,\n            next_ctrl: core::ptr::null(),\n            end: core::ptr::null(),\n        };\n        \n        // Clone the RawIterRange\n        let cloned_range = raw_iter_range.clone();\n\n        // Assert that next_ctrl pointers are equal\n        assert_eq!(raw_iter_range.next_ctrl, cloned_range.next_ctrl);\n\n        // Assert that end pointers are equal\n        assert_eq!(raw_iter_range.end, cloned_range.end);\n\n        // Assert that the data bucket pointers are equal\n        assert_eq!(raw_iter_range.data.as_ptr(), cloned_range.data.as_ptr());\n    }\n}\n```", "<raw::RawIter<T> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_default() {\n        // Create a RawIter for a specific type, for example i32\n        let raw_iter: RawIter<i32> = RawIter::default();\n\n        // Ensure that the iterator is not null, meaning it has been properly initialized\n        // (depending on the internal state of RawTableInner::NEW, this may vary).\n        // This is a placeholder for actual checks, in a real test you would\n        // need to ensure that it is indeed a valid initialized iterator.\n        assert!(unsafe { raw_iter.iter.data.ptr.as_ref() }.is_valid_pointer()); // Placeholder\n\n        // Also you may want to check specific properties of the iterator\n        // for the RawIter that reflects your expected behavior of the iterator.\n        assert_eq!(raw_iter.items, expected_number_of_items()); // Placeholder for actual count check\n    }\n\n    fn expected_number_of_items() -> usize {\n        // This function would return the expected number of items\n        // that the RawIter should contain. This might need to be\n        // determined based on the context of the tested RawTable.\n        0 // Placeholder\n    }\n\n    trait ValidPointer {\n        fn is_valid_pointer(&self) -> bool;\n    }\n\n    impl<T> ValidPointer for Bucket<T> {\n        fn is_valid_pointer(&self) -> bool {\n            // Placeholder method, you may want to implement your logic\n            // for validating the state of the Bucket. For instance, check\n            // that the pointer isn't dangling.\n            true // Placeholder, actual logic should check the pointer\n        }\n    }\n}\n```", "<raw::RawIter<T> as core::iter::Iterator>::fold": "```rust\nuse hashbrown::raw::{RawIter, Bucket};\nuse hashbrown::control::bitmask::{BitMask, BitMaskIter};\nuse std::ptr::NonNull;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_fold_with_empty_iterator() {\n        let bitmask = BitMask(0);\n        let bucket = Bucket { ptr: NonNull::dangling() };\n        let raw_iter = RawIter {\n            iter: RawIterRange {\n                current_group: bitmask.into_iter(),\n                data: bucket,\n                next_ctrl: std::ptr::null(),\n                end: std::ptr::null(),\n            },\n            items: 0,\n        };\n        \n        let result: usize = raw_iter.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_fold_with_single_element() {\n        let mock_bucket = Bucket { ptr: NonNull::from(&0) };\n        let bitmask = BitMask(1);\n        let raw_iter = RawIter {\n            iter: RawIterRange {\n                current_group: bitmask.into_iter(),\n                data: mock_bucket,\n                next_ctrl: std::ptr::null(),\n                end: std::ptr::null(),\n            },\n            items: 1,\n        };\n        \n        let result: usize = raw_iter.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 1);\n    }\n\n    #[test]\n    fn test_fold_with_multiple_elements() {\n        let mock_bucket1 = Bucket { ptr: NonNull::from(&1) };\n        let mock_bucket2 = Bucket { ptr: NonNull::from(&2) };\n        let bitmask = BitMask(0b11); // Two buckets\n        let iter = BitMaskIter(bitmask);\n        \n        let raw_iter = RawIter {\n            iter: RawIterRange {\n                current_group: iter,\n                data: mock_bucket1,\n                next_ctrl: std::ptr::null(),\n                end: std::ptr::null(),\n            },\n            items: 2,\n        };\n        \n        let result: usize = raw_iter.fold(0, |acc, _| acc + 2);\n        assert_eq!(result, 2 + 2); // 2 for each bucket\n    }\n}\n```", "<raw::RawIter<T> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_next() {\n        // Setup a RawIter with known values\n        let items = 3; // Number of items to yield\n        let base_ptr = NonNull::new(Box::into_raw(Box::new(0u8))).unwrap(); // Points to 0u8\n        let bucket = unsafe { Bucket::from_base_index(base_ptr, 0) }; // Create a bucket\n        let iter_range = unsafe { RawIterRange::new(std::ptr::null(), bucket, items) }; // Create RawIterRange\n        let mut raw_iter = RawIter { iter: iter_range, items }; // Create RawIter\n\n        // Test the first call to next\n        let first = raw_iter.next();\n        assert!(first.is_some(), \"Expected some Bucket on the first call to next\");\n\n        // Test the second call to next\n        let second = raw_iter.next();\n        assert!(second.is_some(), \"Expected some Bucket on the second call to next\");\n\n        // Test the third call to next\n        let third = raw_iter.next();\n        assert!(third.is_some(), \"Expected some Bucket on the third call to next\");\n\n        // Test the fourth call to next\n        let fourth = raw_iter.next();\n        assert!(fourth.is_none(), \"Expected None on the fourth call to next\");\n    }\n}\n```", "<raw::RawIter<T> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_size_hint() {\n        // Initialize a test RawIter with some items\n        let bucket = unsafe {\n            // Create a dummy bucket (unsafe for demonstration purposes)\n            let dummy: *mut usize = std::ptr::null_mut();\n            Bucket::<usize>::from_base_index(NonNull::new_unchecked(dummy), 0)\n        };\n\n        let raw_iter = RawIter {\n            iter: RawIterRange::new(std::ptr::null(), bucket, 5), // Assuming 5 items\n            items: 5,\n        };\n\n        let (lower, upper) = raw_iter.size_hint();\n        assert_eq!(lower, 5);\n        assert_eq!(upper, Some(5));\n    }\n\n    #[test]\n    fn test_raw_iter_size_hint_empty() {\n        // Initialize a RawIter with zero items\n        let bucket = unsafe {\n            let dummy: *mut usize = std::ptr::null_mut();\n            Bucket::<usize>::from_base_index(NonNull::new_unchecked(dummy), 0)\n        };\n\n        let raw_iter = RawIter {\n            iter: RawIterRange::new(std::ptr::null(), bucket, 0), // Assuming 0 items\n            items: 0,\n        };\n\n        let (lower, upper) = raw_iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```", "<raw::RawIterHash<T> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{RawIterHash, RawIterHashInner};\n    use crate::control::{bitmask::{BitMask, BitMaskIter}, group::Group, tag::Tag};\n    use std::marker::PhantomData;\n\n    #[test]\n    fn test_raw_iter_hash_clone() {\n        // Create a test instance of RawIterHash\n        let raw_iter = RawIterHash::default();\n\n        // Clone the RawIterHash\n        let cloned_iter = raw_iter.clone();\n\n        // Check that the inner components of the cloned instance are derived\n        // from the original, ensuring that cloning works correctly.\n        assert_eq!(raw_iter.inner.bucket_mask, cloned_iter.inner.bucket_mask);\n        assert_eq!(raw_iter.inner.tag_hash, cloned_iter.inner.tag_hash);\n        assert_eq!(raw_iter.inner.probe_seq.pos, cloned_iter.inner.probe_seq.pos);\n    }\n}\n```", "<raw::RawIterHash<T> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_iter_hash_default() {\n        let default_iter: RawIterHash<u8> = RawIterHash::default();\n        // Check if the inner bucket_mask is initialized correctly (it should be 0 in this case)\n        assert_eq!(default_iter.inner.bucket_mask, 0);\n        // Check if the tag_hash is initialized to the Tag::EMPTY\n        assert_eq!(default_iter.inner.tag_hash, Tag::EMPTY);\n        // Check if the initial position of the probe sequence is 0\n        assert_eq!(default_iter.inner.probe_seq.pos, 0);\n        // It's necessary to guarantee that `bitmask` is initialized correctly\n        assert!(default_iter.inner.bitmask.0.0 == 0);\n    }\n}\n```", "<raw::RawIterHash<T> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{RawIterHash, RawIterHashInner};\n    use crate::control::tag::Tag;\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use crate::control::group::sse2::Group;\n    use crate::raw::ProbeSeq;\n    use std::alloc::Allocator;\n    use std::ptr::NonNull;    \n\n    #[test]\n    fn test_next() {\n        // Assume we have an appropriate setup for RawIterHash\n        unsafe {\n            let tag_hash = Tag::full(1);\n            let table = ...; // Assume table is initialized correctly\n            let mut iter = RawIterHash::new(table, 1);\n            let result = iter.next();\n            assert!(result.is_some(), \"next() should return Some for a valid bucket\");\n            let bucket = result.unwrap();\n            assert_eq!(bucket.tag_hash, tag_hash, \"The returned bucket should have matching tag_hash\");\n        }\n    }\n}\n```", "<raw::RawIterHashInner as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use crate::control::group::sse2::Group;\n    use crate::control::tag::Tag;\n    use crate::raw::{ProbeSeq, RawIterHashInner};\n\n    #[test]\n    fn test_next_with_valid_hash() {\n        // Set up a mock state for RawIterHashInner\n        let bucket_mask = 0b0000_0000_0000_1111; // Example mask\n        let mock_ctrl = NonNull::new(Box::into_raw(Box::new([Tag::EMPTY; Group::WIDTH]))).unwrap();\n        let tag_hash = Tag::full(0b0000_0000_0000_0001);\n        let probe_seq = ProbeSeq { pos: 0, stride: 1 };\n\n        let mut iter = RawIterHashInner {\n            bucket_mask,\n            ctrl: mock_ctrl,\n            tag_hash,\n            probe_seq,\n            group: Group::static_empty(),\n            bitmask: BitMaskIter(BitMask(0b0000_0000_0000_0011)), // Bits for the first two indices\n        };\n\n        let index1 = iter.next();\n        assert_eq!(index1, Some(1)); // Should return first valid index\n        \n        let index2 = iter.next();\n        assert_eq!(index2, Some(0)); // Should return second valid index\n        \n        let index3 = iter.next();\n        assert_eq!(index3, None); // No more valid indices\n    }\n\n    #[test]\n    fn test_next_with_empty_group() {\n        // Set up a mock state for RawIterHashInner with an empty group\n        let bucket_mask = 0b0000_0000_0000_1111; // Example mask\n        let mock_ctrl = NonNull::new(Box::into_raw(Box::new([Tag::EMPTY; Group::WIDTH]))).unwrap();\n        let tag_hash = Tag::full(0b0000_0000_0000_0001);\n        let probe_seq = ProbeSeq { pos: 0, stride: 1 };\n\n        let mut iter = RawIterHashInner {\n            bucket_mask,\n            ctrl: mock_ctrl,\n            tag_hash,\n            probe_seq,\n            group: Group::static_empty(),\n            bitmask: BitMaskIter(BitMask(0)), // No bits set\n        };\n\n        let index = iter.next();\n        assert_eq!(index, None); // Should return None as the group is empty\n    }\n}\n```", "<raw::RawIterRange<T> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use crate::raw::{Bucket, RawIterRange};\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_range_clone() {\n        let bitmask = BitMask(0b1010); // Example bitmask\n        let bitmask_iter = BitMaskIter(bitmask);\n        let bucket = Bucket { ptr: NonNull::dangling() }; // Example bucket\n        let ctrl: *const u8 = std::ptr::null(); // Example control pointer\n        let end: *const u8 = std::ptr::null(); // Example end pointer\n        \n        // Create original RawIterRange\n        let original = RawIterRange {\n            current_group: bitmask_iter,\n            data: bucket,\n            next_ctrl: ctrl,\n            end,\n        };\n\n        // Clone the original RawIterRange\n        let cloned = original.clone();\n\n        // Assert properties to verify the clone\n        assert_eq!(original.data.ptr, cloned.data.ptr);\n        assert_eq!(original.next_ctrl, cloned.next_ctrl);\n        assert_eq!(original.end, cloned.end);\n        // Note: We may need to implement additional equality checks for BitMaskIter depending on implementation\n    }\n}\n```", "<raw::RawIterRange<T> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[derive(Clone, Copy)]\n    struct TestData {\n        value: usize,\n    }\n\n    #[test]\n    fn test_next() {\n        // Setup test data\n        let values = vec![TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];\n        let base = NonNull::new(Box::into_raw(values.into_boxed_slice())).unwrap();\n        let mask = BitMask(0b111); // All bits set for 3 items\n        let ctrl = base.as_ptr() as *const u8;\n\n        // Create RawIterRange instance\n        let mut iter = unsafe { RawIterRange::new(ctrl, Bucket::from_base_index(base, 0), values.len()) };\n\n        // Test next method\n        let mut count = 0;\n        while let Some(bucket) = iter.next() {\n            let data = unsafe { bucket.as_ref() };\n            assert_eq!(data.value, count + 1); // check the value is as expected\n            count += 1;\n        }\n\n        assert_eq!(count, 3); // Ensure we iterated through all elements\n    }\n}\n```", "<raw::RawIterRange<T> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_size_hint() {\n        // Create a mock setup for RawIterRange with the required parameters\n        let mock_control_ptr: *const u8 = NonNull::dangling().as_ptr(); // A mock control pointer\n        let mock_bucket = Bucket::<u32>::from_base_index(NonNull::dangling(), 0); // A mock Bucket\n        let mock_raw_iter = unsafe { RawIterRange::new(mock_control_ptr, mock_bucket, 8) }; // Example length of 8\n\n        // Call the size_hint function\n        let (lower, upper) = mock_raw_iter.size_hint();\n\n        // Validate the expected behavior\n        assert_eq!(lower, 0); // Lower bound should be 0\n        assert!(upper.is_some()); // Upper bound should be Some\n        assert_eq!(upper.unwrap(), Some(Group::WIDTH + 0)); // `Group::WIDTH` plus 0 since remaining_buckets is 0\n    }\n}\n```", "<raw::RawTable<T, A> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Global;\n    use std::alloc::Allocator;\n\n    #[test]\n    fn test_clone_empty_table() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        let cloned_table = table.clone();\n        assert_eq!(table.len(), 0);\n        assert_eq!(cloned_table.len(), 0);\n        assert_eq!(table.buckets(), cloned_table.buckets());\n        assert_eq!(table.alloc, cloned_table.alloc);\n    }\n\n    #[test]\n    fn test_clone_non_empty_table() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        table.insert(1, 42, |x| *x);\n        table.insert(2, 43, |x| *x);\n        assert_eq!(table.len(), 2);\n        \n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), 2);\n        assert_eq!(table.buckets(), cloned_table.buckets());\n        assert_eq!(table.alloc, cloned_table.alloc);\n        \n        let mut item_exists = |value: &i32| {\n            table.get(1, |&x| x == *value).is_some() ||\n            table.get(2, |&x| x == *value).is_some()\n        };\n        assert!(item_exists(&42));\n        assert!(item_exists(&43));\n    }\n\n    #[test]\n    fn test_clone_table_with_dropped_elements() {\n        let mut table: RawTable<String, Global> = RawTable::with_capacity(4);\n        table.insert(1, \"Hello\".to_string(), |x| x.clone());\n        table.insert(2, \"World\".to_string(), |x| x.clone());\n        \n        assert_eq!(table.len(), 2);\n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), 2);\n        assert!(cloned_table.get(1, |x| *x == \"Hello\".to_string()).is_some());\n        assert!(cloned_table.get(2, |x| *x == \"World\".to_string()).is_some());\n    }\n}\n```", "<raw::RawTable<T, A> as core::clone::Clone>::clone_from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clone_from_empty_singleton() {\n        let mut table_a: RawTable<i32, Global> = RawTable::new();\n        let table_b: RawTable<i32, Global> = RawTable::new();\n        \n        table_a.clone_from(&table_b);\n        \n        assert!(table_a.is_empty());\n    }\n    \n    #[test]\n    fn test_clone_from_non_empty() {\n        let mut table_a: RawTable<i32, Global> = RawTable::with_capacity(2);\n        let mut table_b: RawTable<i32, Global> = RawTable::with_capacity(2);\n        \n        unsafe {\n            table_a.insert(1, 10, |&x| x);\n            table_a.insert(2, 20, |&x| x);\n        }\n        \n        table_b.clone_from(&table_a);\n        \n        assert_eq!(table_b.len(), 2);\n        assert_eq!(unsafe { *table_b.bucket(0).as_ref() }, 10);\n        assert_eq!(unsafe { *table_b.bucket(1).as_ref() }, 20);\n    }\n    \n    #[test]\n    fn test_clone_from_with_different_sizes() {\n        let mut table_a: RawTable<i32, Global> = RawTable::with_capacity(2);\n        let mut table_b: RawTable<i32, Global> = RawTable::with_capacity(4);\n        \n        unsafe {\n            table_a.insert(1, 10, |&x| x);\n            table_a.insert(2, 20, |&x| x);\n        }\n        \n        table_b.clone_from(&table_a);\n        \n        assert_eq!(table_b.len(), 2);\n        assert_eq!(unsafe { *table_b.bucket(0).as_ref() }, 10);\n        assert_eq!(unsafe { *table_b.bucket(1).as_ref() }, 20);\n    }\n    \n    #[test]\n    fn test_clone_from_with_panicking_clone() {\n        #[derive(Clone)]\n        struct Panicking {\n            id: i32,\n        }\n        \n        impl Clone for Panicking {\n            fn clone(&self) -> Self {\n                panic!(\"Cloning Panicking struct\");\n            }\n        }\n        \n        let mut table_a: RawTable<Panicking, Global> = RawTable::with_capacity(1);\n        let table_b: RawTable<Panicking, Global> = RawTable::new();\n        \n        unsafe {\n            table_a.insert(1, Panicking { id: 1 }, |&x| x.id);\n        }\n        \n        // should catch panic during clone_from\n        std::panic::catch_unwind(|| {\n            table_a.clone_from(&table_b);\n        }).expect_err(\"Expected panic during clone_from\");\n    }\n}\n```", "<raw::RawTable<T, A> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_table_default() {\n        let table: RawTable<i32, Global> = RawTable::default();\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.buckets(), 1);\n        assert!(table.is_empty());\n    }\n\n    #[test]\n    fn test_raw_table_default_with_different_allocator() {\n        // Assuming you have a custom allocator to test with.\n        // let custom_allocator = MyAllocator::new();\n        // let table: RawTable<i32, MyAllocator> = RawTable::default_in(custom_allocator);\n        // assert_eq!(table.len(), 0);\n        // assert_eq!(table.buckets(), 1);\n        // assert!(table.is_empty());\n    }\n}\n```", "<raw::RawTable<T, A> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::alloc::Global;\n\n    #[test]\n    fn test_into_iter() {\n        // Create a new RawTable\n        let mut table: RawTable<u32, Global> = RawTable::default();\n\n        // Insert some values\n        for i in 0..5 {\n            table.insert(i as u64, i, |x| *x);\n        }\n\n        // Consume the table into an iterator\n        let mut iter: RawIntoIter<u32, Global> = table.into_iter();\n\n        // Collect the items from the iterator\n        let items: Vec<u32> = iter.collect();\n\n        // Verify the items\n        assert_eq!(items, vec![0, 1, 2, 3, 4]);\n        assert_eq!(iter.next(), None); // Check that the iterator is exhausted\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        // Create a new RawTable\n        let table: RawTable<u32, Global> = RawTable::default();\n\n        // Consume the table into an iterator\n        let mut iter: RawIntoIter<u32, Global> = table.into_iter();\n\n        // Check that the iterator is empty\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "<raw::RawTable<T, A> as core::ops::Drop>::drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Global; // or any other allocator\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_drop_empty_table() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        // Ensure the table is empty\n        assert!(table.is_empty());\n        // On drop, it should simply complete without errors\n        drop(table);\n    }\n\n    #[test]\n    fn test_drop_non_empty_table() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(5);\n        unsafe {\n            table.insert(0, 1, |x| x.hash());\n            table.insert(1, 2, |x| x.hash());\n            assert_eq!(table.len(), 2);\n        }\n        // On drop, it should drop all elements without errors\n        drop(table);\n    }\n\n    #[test]\n    #[should_panic(expected = \"expected panic during drop\")]\n    fn test_drop_elements_panic() {\n        struct PanicOnDrop;\n\n        impl Drop for PanicOnDrop {\n            fn drop(&mut self) {\n                panic!(\"expected panic during drop\");\n            }\n        }\n\n        let mut table: RawTable<PanicOnDrop, Global> = RawTable::with_capacity(1);\n        unsafe {\n            table.insert(0, PanicOnDrop, |x| x.hash());\n        }\n        // This should panic during drop\n        drop(table);\n    }\n}\n```", "<raw::RawTable<T, A> as raw::RawTableClone>::clone_from_spec": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clone_from_spec() {\n        // Create a RawTable with some initial elements\n        let mut source: RawTable<i32, Global> = RawTable::with_capacity(2);\n        unsafe {\n            source.insert(1, 10, |&x| x);\n            source.insert(1, 20, |&x| x);\n        }\n\n        // Create a destination RawTable\n        let mut dest: RawTable<i32, Global> = RawTable::with_capacity(2);\n\n        // Clone from source to dest\n        unsafe {\n            dest.clone_from_spec(&source);\n        }\n\n        // Ensure the destination RawTable has the same elements as the source\n        assert_eq!(dest.len(), source.len());\n        assert_eq!(dest.get(1, |&x| x == 10).is_some(), true);\n        assert_eq!(dest.get(1, |&x| x == 20).is_some(), true);\n    }\n\n    #[test]\n    fn test_clone_from_spec_empty() {\n        // Create an empty source RawTable\n        let source: RawTable<i32, Global> = RawTable::new();\n        let mut dest: RawTable<i32, Global> = RawTable::new();\n\n        // Clone from an empty source\n        unsafe {\n            dest.clone_from_spec(&source);\n        }\n\n        // Ensure the destination RawTable is also empty\n        assert!(dest.is_empty());\n    }\n}\n```", "<scopeguard::ScopeGuard<T, F> as core::ops::Deref>::deref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use scopeguard::ScopeGuard;\n\n    #[test]\n    fn test_deref() {\n        let value = 42;\n        let drop_fn = |_: &mut i32| {};\n        let guard = ScopeGuard { dropfn: drop_fn, value };\n\n        // Dereference the guard and check the value\n        assert_eq!(*guard, 42);\n    }\n}\n```", "<scopeguard::ScopeGuard<T, F> as core::ops::DerefMut>::deref_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use scopeguard::ScopeGuard;\n\n    #[test]\n    fn test_deref_mut() {\n        let mut value = 10;\n        let mut guard = ScopeGuard {\n            dropfn: |v: &mut i32| *v = 0,\n            value: value,\n        };\n\n        // Validate the deref_mut functionality\n        let deref_mut_value = guard.deref_mut();\n        *deref_mut_value += 5;\n\n        // Ensure the original value reflects the modification\n        assert_eq!(*deref_mut_value, 15);\n        assert_eq!(guard.value, 15);\n    }\n\n    #[test]\n    fn test_deref_mut_with_drop_fn() {\n        let mut value = 10;\n        {\n            let mut guard = ScopeGuard {\n                dropfn: |v: &mut i32| *v = 0,\n                value: value,\n            };\n\n            // Modify the value using deref_mut\n            *guard.deref_mut() += 5;\n        }\n\n        // Check that the drop function was called\n        assert_eq!(value, 0);\n    }\n}\n```", "<scopeguard::ScopeGuard<T, F> as core::ops::Drop>::drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    #[test]\n    fn test_scope_guard_drop() {\n        let value = RefCell::new(0);\n        let mut dropped = false;\n\n        {\n            let _guard = ScopeGuard {\n                dropfn: |v: &mut RefCell<i32>| {\n                    *v.borrow_mut() += 1;\n                    dropped = true;\n                },\n                value,\n            };\n        }\n\n        assert!(dropped);\n    }\n\n    #[test]\n    fn test_scope_guard_into_inner() {\n        let value = RefCell::new(5);\n        let mut dropped = false;\n\n        let guard = ScopeGuard {\n            dropfn: |v: &mut RefCell<i32>| {\n                *v.borrow_mut() += 1;\n                dropped = true;\n            },\n            value: RefCell::new(10),\n        };\n\n        let inner_value = ScopeGuard::into_inner(guard);\n        assert_eq!(*inner_value.borrow(), 10);\n        assert!(dropped);\n    }\n}\n```", "<set::Difference<'_, T, S, A> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[derive(Debug, Clone, PartialEq, Eq)]\n    struct TestItem {\n        id: usize,\n    }\n\n    #[test]\n    fn test_clone_difference() {\n        let map: HashMap<usize, TestItem> = HashMap::from_iter([\n            (1, TestItem { id: 10 }),\n            (2, TestItem { id: 20 }),\n            (3, TestItem { id: 30 }),\n        ]);\n        \n        let difference_iter = map.iter();\n        let difference = Difference {\n            iter: difference_iter.clone(),\n            // Include all necessary fields for the struct, too\n        };\n\n        let cloned_difference = difference.clone();\n        \n        // Check that clone() has the same elements\n        assert_eq!(cloned_difference.iter.clone().collect::<Vec<_>>(), difference.iter.clone().collect::<Vec<_>>());\n    }\n}\n```", "<set::Difference<'a, T, S, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashMap, HashSet};\n\n    #[test]\n    fn test_fold_with_empty_difference() {\n        let set1: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set2: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let difference = set1.difference(&set2);\n        let result = difference.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_fold_with_non_empty_difference() {\n        let set1: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();\n        let set2: HashSet<i32> = [3, 4].iter().cloned().collect();\n        let difference = set1.difference(&set2);\n        let result = difference.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 2);\n    }\n\n    #[test]\n    fn test_fold_with_custom_function() {\n        let set1: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();\n        let set2: HashSet<i32> = [2, 4].iter().cloned().collect();\n        let difference = set1.difference(&set2);\n        let result = difference.fold(1, |acc, elt| acc * elt);\n        assert_eq!(result, 3); // 1 * 3 = 3\n    }\n\n    #[test]\n    fn test_fold_with_non_existent_elements() {\n        let set1: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set2: HashSet<i32> = HashSet::new();\n        let difference = set1.difference(&set2);\n        let result = difference.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 3);\n    }\n}\n```", "<set::Difference<'a, T, S, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_next_with_unique_elements() {\n        let set_a: HashSet<i32> = HashSet::from([1, 2, 3, 4]);\n        let set_b: HashSet<i32> = HashSet::from([3, 4, 5, 6]);\n        let mut difference = set_a.difference(&set_b);\n\n        assert_eq!(difference.next(), Some(&1));\n        assert_eq!(difference.next(), Some(&2));\n        assert_eq!(difference.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_no_elements_left() {\n        let set_a: HashSet<i32> = HashSet::from([1, 2]);\n        let set_b: HashSet<i32> = HashSet::from([1, 2]);\n        let mut difference = set_a.difference(&set_b);\n\n        assert_eq!(difference.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_empty_first_set() {\n        let set_a: HashSet<i32> = HashSet::new();\n        let set_b: HashSet<i32> = HashSet::from([1, 2, 3]);\n        let mut difference = set_a.difference(&set_b);\n\n        assert_eq!(difference.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_empty_second_set() {\n        let set_a: HashSet<i32> = HashSet::from([1, 2, 3]);\n        let set_b: HashSet<i32> = HashSet::new();\n        let mut difference = set_a.difference(&set_b);\n\n        assert_eq!(difference.next(), Some(&1));\n        assert_eq!(difference.next(), Some(&2));\n        assert_eq!(difference.next(), Some(&3));\n        assert_eq!(difference.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_non_integer_elements() {\n        let set_a: HashSet<String> = HashSet::from([\"a\".to_string(), \"b\".to_string()]);\n        let set_b: HashSet<String> = HashSet::from([\"b\".to_string()]);\n        let mut difference = set_a.difference(&set_b);\n\n        assert_eq!(difference.next(), Some(&\"a\".to_string()));\n        assert_eq!(difference.next(), None);\n    }\n}\n```", "<set::Difference<'a, T, S, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map_a: HashMap<i32, i32> = HashMap::new();\n        map_a.insert(1, 1);\n        map_a.insert(2, 2);\n        let bitmask_a = BitMask(0b00000011); // Both indices 0 and 1 are set\n\n        let mut map_b: HashMap<i32, i32> = HashMap::new();\n        map_b.insert(3, 3);\n        map_b.insert(4, 4);\n        let bitmask_b = BitMask(0b00000001); // Only index 0 is set\n\n        let difference = set::Difference {\n            iter: bitmask_a.into_iter(),  // Simulating our iterator\n            other: bitmask_b.into_iter(),  // Simulating the other set\n        };\n\n        let (lower, upper) = difference.size_hint();\n        assert_eq!(lower, 1);    // 2 (from bitmask_a) - 1 (from bitmask_b) = 1\n        assert_eq!(upper, None);  // Upper bound is None\n    }\n\n    #[test]\n    fn test_empty_difference_size_hint() {\n        let empty_bitmask_a = BitMask(0b00000000); // No bits set\n        let empty_bitmask_b = BitMask(0b00000000); // No bits set\n\n        let difference = set::Difference {\n            iter: empty_bitmask_a.into_iter(),\n            other: empty_bitmask_b.into_iter(),\n        };\n\n        let (lower, upper) = difference.size_hint();\n        assert_eq!(lower, 0);    // 0 - 0 = 0\n        assert_eq!(upper, None);  // Upper bound is None\n    }\n}\n```", "<set::Drain<'_, K, A> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn drain_len_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        let drain_iter = map.drain();\n        assert_eq!(drain_iter.len(), 0);\n    }\n\n    #[test]\n    fn drain_len_non_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.insert(3, 3);\n        let drain_iter = map.drain();\n        assert_eq!(drain_iter.len(), 3);\n    }\n\n    #[test]\n    fn drain_len_after_next() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 1);\n        map.insert(2, 2);\n        let mut drain_iter = map.drain();\n        assert_eq!(drain_iter.len(), 2);\n        drain_iter.next(); // consume one item\n        assert_eq!(drain_iter.len(), 1);\n        drain_iter.next();\n        assert_eq!(drain_iter.len(), 0);\n    }\n\n    #[test]\n    fn drain_len_after_all_items_consumed() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 1);\n        let mut drain_iter = map.drain();\n        drain_iter.next(); // consume item\n        assert_eq!(drain_iter.len(), 0);\n        assert_eq!(drain_iter.next(), None);\n    }\n}\n```", "<set::Drain<'_, K, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_fold() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let result = set.drain().fold(0, |acc, x| acc + x);\n        assert_eq!(result, 6);\n    }\n\n    #[test]\n    fn test_fold_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        let result = set.drain().fold(0, |acc, x| acc + x);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_fold_with_custom_function() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let result = set.drain().fold(1, |acc, x| acc * x);\n        assert_eq!(result, 6); // 1 * 1 * 2 * 3\n    }\n}\n```", "<set::Drain<'_, K, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_next_function() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut drain_iter = map.drain();\n        let mut vec: Vec<_> = vec![];\n\n        vec.push(drain_iter.next());\n        vec.push(drain_iter.next());\n        vec.push(drain_iter.next());\n\n        // Since order isn't guaranteed, sort before comparison\n        vec.sort_unstable();\n        assert_eq!(vec, vec![Some((1, \"a\")), Some((2, \"b\")), Some((3, \"c\"))]);\n\n        // Testing that no more items are left\n        assert_eq!(drain_iter.next(), None);\n    }\n}\n```", "<set::Drain<'_, K, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_drain_size_hint() {\n        let mut map: HashMap<usize, String> = HashMap::new();\n        map.insert(1, \"a\".to_string());\n        map.insert(2, \"b\".to_string());\n        map.insert(3, \"c\".to_string());\n\n        let mut drain = map.drain();\n        let (lower, upper) = drain.size_hint();\n        \n        // Since there are 3 entries in the map, the size hint should reflect that\n        assert_eq!(lower, 3);\n        assert_eq!(upper, Some(3));\n\n        drain.next(); // Consume one element\n        let (lower, upper) = drain.size_hint();\n        \n        // One element has been removed\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n\n        drain.next(); // Consume another element\n        let (lower, upper) = drain.size_hint();\n        \n        // Two elements have been removed\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n\n        drain.next(); // Consume the last element\n        let (lower, upper) = drain.size_hint();\n        \n        // Now all elements have been removed\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```", "<set::ExtractIf<'_, K, F, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use control::bitmask::BitMaskIter;\n    use raw::{Bucket, RawExtractIf, RawIter};\n\n    #[test]\n    fn test_next() {\n        let mut raw_table = RawTable::new_in(Global);\n        // Insert some test data\n        let bucket1 = raw_table.insert(1, \"data1\", |_| 1);\n        let bucket2 = raw_table.insert(2, \"data2\", |_| 2);\n\n        // Prepare the extractor function\n        let iter = RawIter::new(&raw_table);\n        let mut extractor = RawExtractIf {\n            iter,\n            table: &mut raw_table,\n        };\n\n        // Create a filter function\n        let filter = |value: &mut &str| {\n            *value == \"data1\"\n        };\n\n        // Call the `next` function on extractor\n        let result = extractor.next(filter);\n\n        // Check if the result is as expected\n        assert_eq!(result, Some(\"data1\"));\n\n        // Ensure the extractor can no longer find \"data1\" after it has been removed\n        assert_eq!(extractor.next(filter), None);\n    }\n}\n```", "<set::ExtractIf<'_, K, F, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::RawTable;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let raw_table: RawTable<u32> = RawTable::new_in(Global);\n        let mut extract_if = raw_table.extract_if();\n        \n        let (lower, upper) = extract_if.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut raw_table = RawTable::new_in(Global);\n        raw_table.insert(1, 42, |&v| v);\n        let mut extract_if = raw_table.extract_if();\n        \n        let (lower, upper) = extract_if.size_hint();\n        assert!(lower > 0);\n        assert!(upper.is_some());\n    }\n\n    #[test]\n    fn test_size_hint_with_filtered_elements() {\n        let mut raw_table = RawTable::new_in(Global);\n        raw_table.insert(1, 42, |&v| v);\n        raw_table.insert(2, 43, |&v| v);\n        \n        let mut extract_if = raw_table.extract_if();\n        \n        let (lower, upper) = extract_if.size_hint();\n        assert!(lower > 0);\n        assert!(upper.is_some());\n    }\n}\n```", "<set::HashSet<T, S, A> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_clone_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        let cloned_set = set.clone();\n        assert_eq!(set.len(), cloned_set.len());\n        assert_eq!(set, cloned_set);\n    }\n\n    #[test]\n    fn test_clone_with_elements() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        let cloned_set = set.clone();\n        assert_eq!(set.len(), cloned_set.len());\n        assert_eq!(set, cloned_set);\n    }\n\n    #[test]\n    fn test_clone_with_different_elements() {\n        let mut set1: HashSet<i32> = HashSet::new();\n        set1.insert(1);\n        set1.insert(2);\n\n        let mut set2: HashSet<i32> = HashSet::new();\n        set2.insert(3);\n        \n        let cloned_set1 = set1.clone();\n        let cloned_set2 = set2.clone();\n        \n        assert_ne!(set1, set2);\n        assert_eq!(set1, cloned_set1);\n        assert_eq!(set2, cloned_set2);\n    }\n\n    #[test]\n    fn test_clone_after_modification() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        \n        let cloned_set = set.clone();\n        set.insert(2);\n        \n        assert_ne!(set, cloned_set);\n        assert_eq!(cloned_set.len(), 1);\n    }\n}\n```", "<set::HashSet<T, S, A> as core::clone::Clone>::clone_from": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_clone_from() {\n        let mut set_a: HashSet<i32> = HashSet::new();\n        set_a.insert(1);\n        set_a.insert(2);\n        set_a.insert(3);\n\n        let mut set_b: HashSet<i32> = HashSet::new();\n        set_b.insert(4);\n        set_b.insert(5);\n\n        set_b.clone_from(&set_a);\n\n        assert_eq!(set_b.len(), 3);\n        assert!(set_b.contains(&1));\n        assert!(set_b.contains(&2));\n        assert!(set_b.contains(&3));\n    }\n\n    #[test]\n    fn test_clone_from_empty() {\n        let mut set_a: HashSet<i32> = HashSet::new();\n        let mut set_b: HashSet<i32> = HashSet::new();\n        set_b.insert(4);\n\n        set_b.clone_from(&set_a);\n\n        assert_eq!(set_b.len(), 0);\n        assert!(!set_b.contains(&4));\n    }\n\n    #[test]\n    fn test_clone_from_identical() {\n        let mut set_a: HashSet<i32> = HashSet::new();\n        set_a.insert(1);\n        set_a.insert(2);\n\n        let mut set_b = set_a.clone(); // Cloning set_a to set_b\n        set_b.clone_from(&set_a);\n\n        assert_eq!(set_b.len(), 2);\n        assert!(set_b.contains(&1));\n        assert!(set_b.contains(&2));\n    }\n}\n```", "<set::HashSet<T, S, A> as core::cmp::PartialEq>::eq": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_eq_different_sizes() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3, 4]);\n        assert!(!set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_different_elements() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![3, 4, 5]);\n        assert!(!set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_same_elements() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![3, 2, 1]);\n        assert!(set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_empty_sets() {\n        let set1: HashSet<i32> = HashSet::new();\n        let set2: HashSet<i32> = HashSet::new();\n        assert!(set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_subset() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        assert!(!set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_same_single_element() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![1]);\n        assert!(set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_different_single_elements() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![2]);\n        assert!(!set1.eq(&set2));\n    }\n}\n```", "<set::HashSet<T, S, A> as core::convert::From<map::HashMap<T, (), S, A>>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashMap, HashSet};\n\n    #[test]\n    fn test_hashset_from_hashmap() {\n        // Create a HashMap with integer keys and unit values\n        let mut map: HashMap<i32, ()> = HashMap::new();\n        map.insert(1, ());\n        map.insert(2, ());\n        map.insert(3, ());\n\n        // Convert HashMap to HashSet using the From implementation\n        let set: HashSet<i32, _> = HashSet::from(map);\n\n        // Ensure the HashSet contains the correct values\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert_eq!(set.len(), 3);\n    }\n\n    #[test]\n    fn test_empty_hashmap_to_hashset() {\n        // Create an empty HashMap\n        let map: HashMap<i32, ()> = HashMap::new();\n\n        // Convert the empty HashMap to HashSet\n        let set: HashSet<i32, _> = HashSet::from(map);\n\n        // Ensure the HashSet is empty\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_hashset_from_hashmap_with_no_duplicates() {\n        // Create a HashMap with duplicate keys\n        let mut map: HashMap<i32, ()> = HashMap::new();\n        map.insert(1, ());\n        map.insert(1, ()); // Duplicate key, no effect on HashMap\n        map.insert(2, ());\n\n        // Convert HashMap to HashSet\n        let set: HashSet<i32, _> = HashSet::from(map);\n\n        // Ensure the HashSet contains the correct values\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert_eq!(set.len(), 2);\n    }\n}\n```", "<set::HashSet<T, S, A> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_default_hashset() {\n        let set: HashSet<i32> = HashSet::default();\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_default_hashset_non_empty() {\n        let mut set: HashSet<i32> = HashSet::default();\n        set.insert(1);\n        assert!(!set.is_empty());\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n    }\n\n    #[test]\n    fn test_default_hashset_capacity() {\n        let set: HashSet<i32> = HashSet::default();\n        assert_eq!(set.capacity(), 0); // Initially, capacity should be 0\n    }\n}\n```", "<set::HashSet<T, S, A> as core::iter::Extend<&'a T>>::extend": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_extend() {\n        let mut set = HashSet::new();\n        let elements = vec![&1, &2, &3];\n\n        set.extend(elements.iter());\n\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert_eq!(set.len(), 3);\n    }\n\n    #[test]\n    fn test_extend_with_duplicate() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        let elements = vec![&2, &3, &4];\n        set.extend(elements.iter());\n\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert!(set.contains(&4));\n        assert_eq!(set.len(), 4);\n    }\n\n    #[test]\n    fn test_extend_empty() {\n        let mut set = HashSet::new();\n        let elements: Vec<&i32> = Vec::new();\n        \n        set.extend(elements.iter());\n\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_extend_with_empty_set() {\n        let mut set1 = HashSet::new();\n        let mut set2 = HashSet::new();\n        \n        set2.extend(vec![&1, &2, &3].iter());\n        set1.extend(set2.iter());\n\n        assert_eq!(set1.len(), 3);\n        assert_eq!(set2.len(), 3);\n        assert!(set1.contains(&1));\n        assert!(set1.contains(&2));\n        assert!(set1.contains(&3));\n    }\n}\n```", "<set::HashSet<T, S, A> as core::iter::Extend<T>>::extend": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_extend_with_array() {\n        let mut set = HashSet::new();\n        let arr = [1, 2, 3];\n        set.extend(&arr);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n    }\n\n    #[test]\n    fn test_extend_with_vector() {\n        let mut set = HashSet::new();\n        let vec = vec![4, 5, 6];\n        set.extend(vec);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&4));\n        assert!(set.contains(&5));\n        assert!(set.contains(&6));\n    }\n\n    #[test]\n    fn test_extend_with_iterator() {\n        let mut set = HashSet::new();\n        let iter = vec![7, 8, 9].into_iter();\n        set.extend(iter);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&7));\n        assert!(set.contains(&8));\n        assert!(set.contains(&9));\n    }\n\n    #[test]\n    fn test_extend_with_duplicates() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.extend(vec![2, 3, 4]); // 2 is a duplicate\n        assert_eq!(set.len(), 4);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert!(set.contains(&4));\n    }\n\n    #[test]\n    fn test_extend_empty() {\n        let mut set = HashSet::new();\n        set.extend(vec![]);\n        assert_eq!(set.len(), 0);\n    }\n}\n```", "<set::HashSet<T, S, A> as core::iter::FromIterator<T>>::from_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_from_iter_with_bitmask() {\n        use control::bitmask::BitMask;\n\n        let bitmask_values = vec![BitMask(0b00000001), BitMask(0b00000010)];\n        let set: HashSet<BitMask> = HashSet::from_iter(bitmask_values.clone());\n\n        assert_eq!(set.len(), bitmask_values.len());\n        for bm in bitmask_values {\n            assert!(set.contains(&bm));\n        }\n    }\n    \n    #[test]\n    fn test_from_iter_with_hashmap() {\n        use map::HashMap;\n\n        let map_values = vec![(1, \"a\"), (2, \"b\"), (3, \"c\")];\n        let map: HashMap<i32, &str> = HashMap::from_iter(map_values.clone());\n\n        assert_eq!(map.len(), map_values.len());\n        for (key, value) in map_values {\n            assert_eq!(map.get(&key), Some(&value));\n        }\n    }\n\n    #[test]\n    fn test_from_iter_empty() {\n        let empty_set: HashSet<i32> = HashSet::from_iter(Vec::new());\n        assert!(empty_set.is_empty());\n    }\n}\n```", "<set::HashSet<T, S, A> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_into_iter() {\n        // Create a new HashSet and insert elements\n        let mut set = HashSet::new();\n        set.insert(\"a\".to_string());\n        set.insert(\"b\".to_string());\n        set.insert(\"c\".to_string());\n\n        // Convert the HashSet into an iterator\n        let mut iter = set.into_iter();\n\n        // Collect the items into a Vec\n        let collected: Vec<String> = iter.collect();\n\n        // Check the collected items\n        assert_eq!(collected.len(), 3);\n        assert!(collected.contains(&\"a\".to_string()));\n        assert!(collected.contains(&\"b\".to_string()));\n        assert!(collected.contains(&\"c\".to_string()));\n    }\n\n    #[test]\n    fn test_into_iter_empty_set() {\n        // Create an empty HashSet\n        let set: HashSet<String> = HashSet::new();\n\n        // Convert the HashSet into an iterator\n        let iter = set.into_iter();\n\n        // Collect the items into a Vec\n        let collected: Vec<String> = iter.collect();\n\n        // Check that the collected Vec is empty\n        assert!(collected.is_empty());\n    }\n}\n```", "<set::HashSet<T, S, A> as core::ops::BitAndAssign<&set::HashSet<T, S, A>>>::bitand_assign": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitand_assign() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n\n        a &= &b;\n\n        let expected: HashSet<_> = vec![2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_bitand_assign_empty() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![4, 5, 6].into_iter().collect();\n\n        a &= &b;\n\n        let expected: HashSet<_> = HashSet::new();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_bitand_assign_no_change() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n\n        a &= &b;\n\n        let expected: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_bitand_assign_with_duplicates() {\n        let mut a: HashSet<_> = vec![1, 2, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n\n        a &= &b;\n\n        let expected: HashSet<_> = vec![2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n}\n```", "<set::HashSet<T, S, A> as core::ops::BitOrAssign<&set::HashSet<T, S, A>>>::bitor_assign": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitor_assign() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n\n        a |= &b;\n\n        let mut i = 0;\n        let expected = [1, 2, 3, 4, 5];\n        for x in &a {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n}\n```", "<set::HashSet<T, S, A> as core::ops::BitXorAssign<&set::HashSet<T, S, A>>>::bitxor_assign": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitxor_assign() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n        \n        a ^= &b;\n\n        let expected: HashSet<_> = vec![1, 2, 4, 5].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_bitxor_assign_with_empty() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = HashSet::new();\n        \n        a ^= &b;\n\n        let expected: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_bitxor_assign_self() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        \n        a ^= &a;\n\n        let expected: HashSet<_> = HashSet::new();\n        assert_eq!(a, expected);\n    }\n}\n```", "<set::HashSet<T, S, A> as core::ops::SubAssign<&set::HashSet<T, S, A>>>::sub_assign": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_sub_assign() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n\n        a -= &b;\n\n        let expected: HashSet<_> = vec![1, 2].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_sub_assign_no_change() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![4, 5].into_iter().collect();\n\n        a -= &b;\n\n        let expected: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_sub_assign_empty_rhs() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = HashSet::new();\n\n        a -= &b;\n\n        let expected: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_sub_assign_rhs_equal() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n\n        a -= &b;\n\n        let expected: HashSet<_> = HashSet::new();\n        assert_eq!(a, expected);\n    }\n}\n```", "<set::HashSet<T, foldhash::fast::RandomState, A> as core::convert::From<[T; N]>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_from_array() {\n        let set1: HashSet<_> = HashSet::from([1, 2, 3, 4]);\n        let set2: HashSet<_> = [1, 2, 3, 4].into();\n        assert_eq!(set1, set2);\n    }\n\n    #[test]\n    fn test_from_array_empty() {\n        let set: HashSet<i32> = HashSet::from([]);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_from_array_duplicates() {\n        let set: HashSet<_> = HashSet::from([1, 1, 2, 3]);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n    }\n\n    #[test]\n    fn test_from_array_non_copy() {\n        let set: HashSet<String> = HashSet::from([String::from(\"a\"), String::from(\"b\")]);\n        assert_eq!(set.len(), 2);\n        assert!(set.contains(\"a\"));\n        assert!(set.contains(\"b\"));\n    }\n}\n```", "<set::Intersection<'_, T, S, A> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashMap, HashSet};\n\n    #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n    struct TestData {\n        key: usize,\n        value: usize,\n    }\n\n    #[derive(Debug, Clone)]\n    struct TestIntersection<'a, T> {\n        iter: &'a HashSet<T>,\n    }\n\n    impl<'a, T> TestIntersection<'a, T> {\n        fn new(iter: &'a HashSet<T>) -> Self {\n            TestIntersection { iter }\n        }\n    }\n\n    impl<'a, T: Clone + Copy + Eq + Hash> Clone for TestIntersection<'a, T> {\n        fn clone(&self) -> Self {\n            TestIntersection {\n                iter: self.iter,\n            }\n        }\n    }\n\n    #[test]\n    fn test_clone_intersection() {\n        let mut set = HashSet::new();\n        set.insert(TestData { key: 1, value: 10 });\n        set.insert(TestData { key: 2, value: 20 });\n        \n        let intersection = TestIntersection::new(&set);\n        let cloned_intersection = intersection.clone();\n        \n        assert_eq!(cloned_intersection.iter, intersection.iter);\n    }\n}\n```", "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashMap, HashSet};\n\n    #[test]\n    fn test_fold_with_elements_in_common() {\n        let set1: HashSet<usize> = (1..5).collect();\n        let set2: HashSet<usize> = (3..7).collect();\n        let intersection = set1.intersection(&set2);\n        \n        let result = intersection.fold(0, |acc, &x| acc + x);\n        assert_eq!(result, 3 + 4); // Only 3 and 4 are in intersection\n    }\n\n    #[test]\n    fn test_fold_with_no_elements_in_common() {\n        let set1: HashSet<usize> = (1..3).collect();\n        let set2: HashSet<usize> = (4..7).collect();\n        let intersection = set1.intersection(&set2);\n        \n        let result = intersection.fold(10, |acc, _| acc + 1);\n        assert_eq!(result, 10); // No elements in intersection, result should be init\n    }\n\n    #[test]\n    fn test_fold_with_empty_intersection() {\n        let set1: HashSet<usize> = HashSet::new();\n        let set2: HashSet<usize> = HashSet::new();\n        let intersection = set1.intersection(&set2);\n        \n        let result = intersection.fold(5, |acc, _| acc + 1);\n        assert_eq!(result, 5); // No elements in intersection\n    }\n\n    #[test]\n    fn test_fold_with_initial_value() {\n        let set1: HashSet<usize> = (2..5).collect(); // 2, 3, 4\n        let set2: HashSet<usize> = (1..4).collect(); // 1, 2, 3\n        let intersection = set1.intersection(&set2);\n        \n        let result = intersection.fold(1, |acc, &x| acc * x);\n        assert_eq!(result, 1 * 2 * 3); // 2 and 3 are in intersection\n    }\n}\n```", "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashMap, HashSet};\n\n    #[test]\n    fn test_intersection_next() {\n        // Prepare data for testing\n        let set_a: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();\n        let set_b: HashSet<i32> = [3, 4, 5, 6].iter().cloned().collect();\n        \n        // Create an intersection iterator\n        let intersection = set_a.intersection(&set_b);\n        \n        // Collect the results\n        let result: Vec<_> = intersection.collect();\n        \n        // Check if the intersection is correct\n        assert_eq!(result, vec![&3, &4]);\n    }\n}\n```", "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let set: HashSet<usize> = HashSet::new();\n        let intersection = set.intersection(&set); // Self intersection\n        let hint = intersection.size_hint();\n        assert_eq!(hint, (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut set: HashSet<usize> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        let intersection = set.intersection(&set); // Self intersection\n        let hint = intersection.size_hint();\n        assert_eq!(hint, (0, Some(2))); // Expecting (0, Some(2)) because the intersection has 2 elements\n    }\n\n    #[test]\n    fn test_size_hint_partial_elements() {\n        let mut set1: HashSet<usize> = HashSet::new();\n        let mut set2: HashSet<usize> = HashSet::new();\n        set1.insert(1);\n        set1.insert(2);\n        set2.insert(2);\n        set2.insert(3);\n        let intersection = set1.intersection(&set2);\n        let hint = intersection.size_hint();\n        assert_eq!(hint, (0, Some(1))); // Expecting (0, Some(1)) because intersection has 1 element (2)\n    }\n}\n```", "<set::IntoIter<K, A> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_into_iter_default() {\n        let iter: IntoIter<u32> = Default::default();\n        assert_eq!(iter.len(), 0);\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_non_empty() {\n        let set: HashSet<u32> = [(1, ()), (2, ()), (3, ())].iter().cloned().collect();\n        let iter = set.into_iter();\n        let mut collected: Vec<u32> = iter.collect();\n        assert_eq!(collected.len(), 3);\n        collected.sort();\n        assert_eq!(collected, vec![1, 2, 3]);\n    }\n}\n```", "<set::IntoIter<K, A> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_into_iter_len() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.len(), 0);\n\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let iter = set.into_iter();\n        assert_eq!(iter.len(), 3);\n\n        drop(iter); // Drop the iterator\n        assert_eq!(set.len(), 3); // Ensure set still has items\n    }\n\n    #[test]\n    fn test_empty_into_iter_len() {\n        let set: HashSet<i32> = HashSet::new();\n        let iter = set.into_iter();\n        assert_eq!(iter.len(), 0);\n    }\n\n    #[test]\n    fn test_zero_items_into_iter_len() {\n        let mut set: HashSet<i32> = HashSet::new();\n        let iter = set.into_iter();\n        assert_eq!(iter.len(), 0);\n    }\n\n    #[test]\n    fn test_len_after_removal() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        assert_eq!(set.len(), 3);\n        \n        set.remove(&2);\n        let iter = set.into_iter();\n        assert_eq!(iter.len(), 2);\n        \n        drop(iter); // Drop the iterator\n        assert_eq!(set.len(), 2); // Ensure set still has items\n    }\n}\n```", "<set::IntoIter<K, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_fold() {\n        let set: HashSet<i32> = [1, 2, 3, 4, 5].iter().cloned().collect();\n        \n        let sum: i32 = set.into_iter().fold(0, |acc, x| acc + x);\n        assert_eq!(sum, 15);\n    }\n\n    #[test]\n    fn test_fold_with_empty_set() {\n        let set: HashSet<i32> = HashSet::new();\n        \n        let sum: i32 = set.into_iter().fold(0, |acc, x| acc + x);\n        assert_eq!(sum, 0);\n    }\n\n    #[test]\n    fn test_fold_with_initial_value() {\n        let set: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        \n        let product: i32 = set.into_iter().fold(1, |acc, x| acc * x);\n        assert_eq!(product, 6);\n    }\n\n    #[test]\n    fn test_fold_with_custom_function() {\n        let set: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();\n        \n        let result: String = set.into_iter().fold(String::new(), |acc, x| acc + &x.to_string());\n        assert_eq!(result, \"1234\");\n    }\n}\n```", "<set::IntoIter<K, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_into_iter_next() {\n        let set: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let mut iter = set.into_iter();\n\n        let first = iter.next();\n        let second = iter.next();\n        let third = iter.next();\n        let fourth = iter.next();\n\n        assert!(first.is_some());\n        assert!(second.is_some());\n        assert!(third.is_some());\n        assert!(fourth.is_none());\n\n        // Ensure that remaining elements are distinct\n        let unique_elements: HashSet<_> = [first.unwrap(), second.unwrap(), third.unwrap()].iter().cloned().collect();\n        assert_eq!(unique_elements.len(), 3);\n        assert!(unique_elements.contains(&1) || unique_elements.contains(&2) || unique_elements.contains(&3));\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        let mut iter = set.into_iter();\n\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "<set::IntoIter<K, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        let iter = set.into_iter();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let set: HashSet<i32> = [(1,), (2,), (3,)].iter().cloned().collect();\n        let iter = set.into_iter();\n        assert_eq!(iter.size_hint(), (3, Some(3)));\n    }\n\n    #[test]\n    fn test_size_hint_after_iteration() {\n        let set: HashSet<i32> = [(1,), (2,), (3,)].iter().cloned().collect();\n        let mut iter = set.into_iter();\n        let _ = iter.next();\n        assert_eq!(iter.size_hint(), (2, Some(2)));\n        let _ = iter.next();\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n        let _ = iter.next();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n}\n```", "<set::Iter<'_, K> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_clone_iter() {\n        let set: HashSet<i32> = [(1, ()), (2, ()), (3, ())].iter().cloned().collect();\n        let iter = set.iter();\n        let cloned_iter = iter.clone();\n\n        // Collect values from the original and cloned iterators\n        let original_values: Vec<&i32> = iter.collect();\n        let cloned_values: Vec<&i32> = cloned_iter.collect();\n\n        // Verify that the values are the same\n        assert_eq!(original_values, cloned_values);\n    }\n\n    #[test]\n    fn test_clone_iter_iterability() {\n        let set: HashSet<i32> = [(1, ()), (2, ()), (3, ())].iter().cloned().collect();\n        let mut iter = set.iter();\n        let mut cloned_iter = iter.clone();\n\n        // Verify that the first item is the same\n        assert_eq!(iter.next(), cloned_iter.next());\n\n        // Verify that the next item is also the same\n        assert_eq!(iter.next(), cloned_iter.next());\n\n        // Verify remaining items until iter is exhausted\n        assert_eq!(iter.next(), cloned_iter.next());\n        assert_eq!(iter.next(), None);\n        assert_eq!(cloned_iter.next(), None);\n    }\n}\n```", "<set::Iter<'_, K> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_iter_default() {\n        let iter: Iter<i32> = Iter::default();\n        assert_eq!(iter.len(), 0);\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_iter_default_with_elements() {\n        let set: HashSet<i32> = vec![1, 2, 3].into_iter().collect();\n        let iter: Iter<i32> = set.iter();\n        assert_eq!(iter.len(), 3);\n        \n        let mut collected: Vec<_> = iter.collect();\n        collected.sort(); // Sort for comparison, since the order is arbitrary\n        assert_eq!(collected, vec![&1, &2, &3]);\n    }\n}\n```", "<set::Iter<'_, K> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_iter_len() {\n        let set: HashSet<i32> = vec![1, 2, 3].into_iter().collect();\n        let iter = set.iter();\n        assert_eq!(iter.len(), 3);\n\n        let empty_set: HashSet<i32> = HashSet::new();\n        let empty_iter = empty_set.iter();\n        assert_eq!(empty_iter.len(), 0);\n    }\n}\n```", "<set::Iter<'a, K> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_fold_with_sum() {\n        let set: HashSet<i32> = [1, 2, 3, 4, 5].iter().cloned().collect();\n        let sum: i32 = set.iter().fold(0, |acc, &x| acc + x);\n        assert_eq!(sum, 15);\n    }\n\n    #[test]\n    fn test_fold_with_product() {\n        let set: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();\n        let product: i32 = set.iter().fold(1, |acc, &x| acc * x);\n        assert_eq!(product, 24);\n    }\n\n    #[test]\n    fn test_fold_with_concat() {\n        let set: HashSet<&str> = [\"hello\", \" \", \"world\"].iter().cloned().collect();\n        let concatenated: String = set.iter().fold(String::new(), |acc, &x| acc + x);\n        assert_eq!(concatenated, \"hello world\");\n    }\n\n    #[test]\n    fn test_fold_with_empty_set() {\n        let set: HashSet<i32> = HashSet::new();\n        let sum: i32 = set.iter().fold(0, |acc, &x| acc + x);\n        assert_eq!(sum, 0);\n    }\n}\n```", "<set::Iter<'a, K> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_next() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let mut iter = set.iter();\n        let mut collected = Vec::new();\n\n        while let Some(&value) = iter.next() {\n            collected.push(value);\n        }\n\n        collected.sort_unstable();\n        assert_eq!(collected, vec![1, 2, 3]);\n\n        // Verify that the iterator is fused\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_empty_next() {\n        let set: HashSet<i32> = HashSet::new();\n        let mut iter = set.iter();\n\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "<set::Iter<'a, K> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        let iter = set.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_single() {\n        let set: HashSet<i32> = [(1)].iter().cloned().collect();\n        let iter = set.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n    }\n\n    #[test]\n    fn test_size_hint_multiple() {\n        let set: HashSet<i32> = [(1), (2), (3)].iter().cloned().collect();\n        let iter = set.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 3);\n        assert_eq!(upper, Some(3));\n    }\n\n    #[test]\n    fn test_size_hint_after_iteration() {\n        let set: HashSet<i32> = [(1), (2), (3)].iter().cloned().collect();\n        let mut iter = set.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 3);\n        assert_eq!(upper, Some(3));\n        \n        iter.next(); // advance the iterator\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n}\n```", "<set::SymmetricDifference<'_, T, S, A> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_clone_symmetric_difference() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![2, 3, 4]);\n        let symmetric_difference: SymmetricDifference<i32, _> = set1.symmetric_difference(&set2);\n        \n        let cloned_difference = symmetric_difference.clone();\n        \n        assert_eq!(symmetric_difference.collect::<HashSet<_>>(), cloned_difference.collect::<HashSet<_>>());\n    }\n}\n```", "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_set::HashSet;\n    use hashbrown::set::SymmetricDifference;\n\n    #[test]\n    fn test_fold_symmetric_difference() {\n        let set_a: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set_b: HashSet<i32> = [3, 4, 5].iter().cloned().collect();\n        \n        let symmetric_difference: SymmetricDifference<_, _, _> = set_a.symmetric_difference(&set_b);\n\n        let result = symmetric_difference.fold(0, |acc, &x| acc + x);\n\n        assert_eq!(result, 7); // 1 + 2 + 4 + 5 = 12\n    }\n\n    #[test]\n    fn test_fold_symmetric_difference_empty() {\n        let set_a: HashSet<i32> = HashSet::new();\n        let set_b: HashSet<i32> = HashSet::new();\n        \n        let symmetric_difference: SymmetricDifference<_, _, _> = set_a.symmetric_difference(&set_b);\n\n        let result = symmetric_difference.fold(0, |acc, &x| acc + x);\n\n        assert_eq!(result, 0); // Sum is 0 for empty sets\n    }\n}\n```", "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_symmetric_difference_next() {\n        let set_a: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set_b: HashSet<i32> = [2, 3, 4].iter().cloned().collect();\n        let symmetric_diff = set_a.symmetric_difference(&set_b);\n\n        let mut iter = symmetric_diff.iter();\n        \n        assert_eq!(iter.next(), Some(&1));\n        assert_eq!(iter.next(), Some(&4));\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_size_hint_empty_sets() {\n        let set1: HashSet<i32> = HashSet::new();\n        let set2: HashSet<i32> = HashSet::new();\n        let symmetric_difference = set1.symmetric_difference(&set2);\n        assert_eq!(symmetric_difference.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty_sets() {\n        let mut set1: HashSet<i32> = HashSet::new();\n        set1.insert(1);\n        set1.insert(2);\n\n        let mut set2: HashSet<i32> = HashSet::new();\n        set2.insert(2);\n        set2.insert(3);\n\n        let symmetric_difference = set1.symmetric_difference(&set2);\n        assert_eq!(symmetric_difference.size_hint(), (2, Some(2)));\n    }\n\n    #[test]\n    fn test_size_hint_with_clone() {\n        let mut set1: HashSet<i32> = HashSet::new();\n        set1.insert(1);\n        set1.insert(2);\n\n        let mut set2: HashSet<i32> = HashSet::new();\n        set2.insert(2);\n        set2.insert(3);\n\n        let symmetric_difference = set1.symmetric_difference(&set2);\n        let symmetric_difference_clone = symmetric_difference.clone();\n        assert_eq!(symmetric_difference.size_hint(), symmetric_difference_clone.size_hint());\n    }\n}\n```", "<set::Union<'_, T, S, A> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashSet;\n    use std::hash::BuildHasherDefault;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_union_clone() {\n        let set_a: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set_b: HashSet<i32> = [3, 4, 5].iter().cloned().collect();\n        let union: Union<_, _, BuildHasherDefault<core::hash::BuildHasher>> = set_a.union(&set_b);\n        \n        let cloned_union = union.clone();\n        \n        assert_eq!(union.size_hint(), cloned_union.size_hint());\n        assert!(union.eq(&cloned_union));\n    }\n}\n```", "<set::Union<'a, T, S, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_fold_union() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![3, 4, 5]);\n        \n        let union_iter = set1.union(&set2);\n        \n        let result = union_iter.fold(0, |acc, &x| acc + x);\n        \n        assert_eq!(result, 15); // 1 + 2 + 3 + 4 + 5 = 15\n    }\n\n    #[test]\n    fn test_fold_union_with_initial_value() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![2, 3]);\n        \n        let union_iter = set1.union(&set2);\n        \n        let result = union_iter.fold(10, |acc, &x| acc * x);\n        \n        assert_eq!(result, 60); // 10 * 1 * 2 * 3 = 60\n    }\n    \n    #[test]\n    fn test_fold_union_empty() {\n        let set1: HashSet<i32> = HashSet::new();\n        let set2: HashSet<i32> = HashSet::new();\n        \n        let union_iter = set1.union(&set2);\n        \n        let result = union_iter.fold(5, |acc, &x| acc + x);\n        \n        assert_eq!(result, 5); // Initial value is returned as the union is empty\n    }\n}\n```", "<set::Union<'a, T, S, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust import based on your module structure\n    use hashbrown::HashSet; // Ensure you have the correct crate import\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_next() {\n        let set_a: HashSet<i32, RandomState> = [1, 2, 3].iter().cloned().collect();\n        let set_b: HashSet<i32, RandomState> = [3, 4, 5].iter().cloned().collect();\n        \n        let union = set_a.union(&set_b);\n        let mut union_iter = union.into_iter();\n        \n        let first = union_iter.next(); // Should yield Some(&1) or Some(&3) based on the implementation order\n        let second = union_iter.next(); // Should yield Some(&2) or Some(&4) based on the implementation order\n        let third = union_iter.next(); // Should yield Some(&5) or Some(&3) based on the implementation order\n        let fourth = union_iter.next(); // Should yield None\n        \n        assert!(first.is_some());\n        assert!(second.is_some());\n        assert!(third.is_some());\n        assert!(fourth.is_none());\n    }\n}\n```", "<set::Union<'a, T, S, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_size_hint_empty_sets() {\n        let set1: HashSet<i32> = HashSet::new();\n        let set2: HashSet<i32> = HashSet::new();\n        let union = set1.union(&set2);\n        assert_eq!(union.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty_sets() {\n        let set1: HashSet<i32> = HashSet::from([1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from([3, 4, 5]);\n        let union = set1.union(&set2);\n        assert_eq!(union.size_hint(), (5, Some(5))); // Size might be exact\n    }\n\n    #[test]\n    fn test_size_hint_some_empty_and_non_empty_sets() {\n        let set1: HashSet<i32> = HashSet::new();\n        let set2: HashSet<i32> = HashSet::from([3, 4, 5]);\n        let union = set1.union(&set2);\n        assert_eq!(union.size_hint(), (3, Some(3)));\n    }\n    \n    #[test]\n    fn test_size_hint_when_sets_have_common_elements() {\n        let set1: HashSet<i32> = HashSet::from([1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from([2, 3, 4]);\n        let union = set1.union(&set2);\n        assert_eq!(union.size_hint(), (4, Some(4))); // 1, 2, 3, 4 are unique\n    }\n}\n```", "<table::Drain<'_, T, A> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_len_empty() {\n        let raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), 0);\n        let drain = RawDrain {\n            iter: RawIter::default(),\n            table: raw_table,\n            orig_table: NonNull::new_unchecked(&raw_table),\n            marker: PhantomData,\n        };\n        assert_eq!(drain.len(), 0);\n    }\n\n    #[test]\n    fn test_len_after_inserts() {\n        let raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), 10);\n        let drain = RawDrain {\n            iter: RawIter::default(),\n            table: raw_table,\n            orig_table: NonNull::new_unchecked(&raw_table),\n            marker: PhantomData,\n        };\n        assert_eq!(drain.len(), 0); // Assuming that no elements have been inserted\n\n        // Simulate inserting elements into the table.\n        // This is pseudo-code, as inserting elements is outside the scope of the provided context.\n        // Assume handle_insert is a function that inserts a value into the RawTableInner.\n        // handle_insert(&mut raw_table, value);\n        \n        // Assume now 5 elements are inserted.\n        // raw_table.items = 5; // This would directly adjust the simulated item count\n\n        // This requires adjust crown of RawIter or some underlying structure to validate state\n        // assert_eq!(drain.len(), 5); // would check the updated size, if the table count would increase properly\n    }\n\n    #[test]\n    fn test_len_after_removal() {\n        let raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), 10);\n        let drain = RawDrain {\n            iter: RawIter::default(),\n            table: raw_table,\n            orig_table: NonNull::new_unchecked(&raw_table),\n            marker: PhantomData,\n        };\n\n        // Simulate elements are inserted, say 5 elements\n        // raw_table.items = 5; \n\n        // Now assume we remove one\n        // handle_remove(&mut raw_table, value); // This is hypothetical\n\n        // raw_table.items = 4; // would adjust simulated item count after removal\n        // assert_eq!(drain.len(), 4); // checking length after removal\n    }\n}\n```", "<table::Drain<'_, T, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_fold() {\n        let allocator = Global; // Create a global allocator instance\n        let mut raw_table = RawTableInner::with_capacity(&allocator, TableLayout::default(), 8);\n        \n        // Simulate inserting elements in raw_table, ensuring it has elements\n        // This part requires creating valid buckets in raw_table, which depends on your implementation\n        // Assuming a method `insert` which would populate raw_table\n        \n        let init_value = 0; // Starting value\n        let result = raw_table\n            .iter() // Assuming it has an `iter` method to get an iterator\n            .fold(init_value, |acc, bucket| {\n                // Process bucket to get some value, assume bucket has a way to get value, e.g. bucket.as_ref().value\n                acc + 1 // Incrementing for each bucket; replace this with the actual logic needed\n            });\n        \n        let expected = raw_table.items; // Assuming items provides how many buckets are filled\n        assert_eq!(result, expected);\n    }\n}\n```", "<table::Drain<'_, T, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_next() {\n        // Create a mock structure to test the Drain's next function\n        struct MockAllocator;\n\n        // Mock the RawTableInner\n        let raw_table_inner = RawTableInner {\n            bucket_mask: 3, // mock value for testing\n            ctrl: NonNull::new(Box::into_raw(Box::new([0; 4])) as *mut u8).unwrap(),\n            growth_left: 4,\n            items: 0,\n        };\n\n        // Create a RawDrain instance\n        let mut raw_drain = RawDrain {\n            iter: RawIter {\n                iter: RawIterRange {\n                    current_group: BitMaskIter(BitMask(1)),\n                    data: Bucket {\n                        ptr: NonNull::new(Box::into_raw(Box::new(42)).cast()).unwrap(),\n                    },\n                    next_ctrl: std::ptr::null(),\n                    end: std::ptr::null(),\n                },\n                items: 1,\n            },\n            table: raw_table_inner,\n            orig_table: NonNull::new(Box::into_raw(Box::new(raw_table_inner))).unwrap(),\n            marker: PhantomData,\n        };\n\n        // Call the next method and check the result\n        let result = raw_drain.next();\n        assert!(result.is_some());\n        assert_eq!(unsafe { *result.unwrap() }, 42); // Assuming the Bucket contained 42\n\n        // Check if the next call returns None\n        let result = raw_drain.next();\n        assert!(result.is_none());\n    }\n}\n```", "<table::Drain<'_, T, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{RawDrain, RawTableInner, RawIter};\n    \n    #[test]\n    fn test_size_hint_empty() {\n        let empty_table = RawTableInner::with_capacity(&*Global, TableLayout::default(), 8);\n        let drain = RawDrain {\n            iter: RawIter::default(),\n            table: empty_table,\n            orig_table: NonNull::from(&empty_table),\n            marker: PhantomData,\n        };\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut table = RawTableInner::with_capacity(&*Global, TableLayout::default(), 8);\n        // Assuming we insert two items\n        table.items = 2;\n\n        let drain = RawDrain {\n            iter: RawIter::default(),\n            table,\n            orig_table: NonNull::from(&table),\n            marker: PhantomData,\n        };\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n\n    #[test]\n    fn test_size_hint_after_drain() {\n        let mut table = RawTableInner::with_capacity(&*Global, TableLayout::default(), 8);\n        // Inserting some items\n        table.items = 5;\n\n        let mut drain = RawDrain {\n            iter: RawIter::default(),\n            table,\n            orig_table: NonNull::from(&table),\n            marker: PhantomData,\n        };\n\n        // Simulate draining 3 items\n        drain.iter.items = 2; // remaining items\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n}\n```", "<table::ExtractIf<'_, T, F, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_next_function() {\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n        \n        // Insert elements into the table to test next\n        unsafe {\n            table.insert(10, 1, |x| *x);\n            table.insert(20, 2, |x| *x);\n            table.insert(30, 3, |x| *x);\n        }\n\n        let mut count = 0;\n        while let Some(value) = extractor.next(|x| *x > 0) {\n            count += value;\n        }\n\n        // It should sum the values that satisfy the condition\n        assert_eq!(count, 6); // 1 + 2 + 3\n    }\n\n    #[test]\n    fn test_next_function_with_no_elements() {\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n\n        let result = extractor.next(|_x| false);\n        // It should return None as there are no elements\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_next_function_with_condition() {\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n\n        // Insert elements into the table to test next\n        unsafe {\n            table.insert(10, 1, |x| *x);\n            table.insert(20, 2, |x| *x);\n            table.insert(30, 3, |x| *x);\n        }\n\n        let mut count = 0;\n        while let Some(value) = extractor.next(|x| *x == 2) {\n            count += value;\n        }\n\n        // It should find and sum the elements matching the condition\n        assert_eq!(count, 2); // Only the second element matches the condition\n    }\n}\n```", "<table::ExtractIf<'_, T, F, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{RawTable, RawExtractIf, Bucket};\n    use crate::control::bitmask::BitMask;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let table: RawTable<i32, Global> = RawTable::default();\n        let raw_extract_if = RawExtractIf {\n            iter: unsafe { table.iter() },\n            table: &mut table,\n        };\n        let (lower, upper) = raw_extract_if.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut table: RawTable<i32, Global> = RawTable::default();\n        let value = 42;\n        unsafe {\n            let _bucket = table.insert(0, value, |_x| 0);\n        }\n\n        let raw_extract_if = RawExtractIf {\n            iter: unsafe { table.iter() },\n            table: &mut table,\n        };\n        let (lower, upper) = raw_extract_if.size_hint();\n        assert_eq!(lower, 0);\n        assert!(upper.is_some());\n    }\n\n    #[test]\n    fn test_size_hint_with_multiple_elements() {\n        let mut table: RawTable<i32, Global> = RawTable::default();\n        for i in 0..10 {\n            unsafe {\n                table.insert(i as u64, i, |_x| i as u64);\n            }\n        }\n\n        let raw_extract_if = RawExtractIf {\n            iter: unsafe { table.iter() },\n            table: &mut table,\n        };\n        let (lower, upper) = raw_extract_if.size_hint();\n        assert_eq!(lower, 0);\n        assert!(upper.is_some());\n    }\n\n    #[test]\n    fn test_size_hint_with_no_elements() {\n        let table: RawTable<i32, Global> = RawTable::default();\n        let raw_extract_if = RawExtractIf {\n            iter: unsafe { table.iter() },\n            table: &mut table,\n        };\n        let (lower, upper) = raw_extract_if.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```", "<table::HashTable<T, A> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::RawTable; // Assuming the use of the appropriate path to access the RawTable.\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clone_empty_table() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), 0);\n        assert_eq!(cloned_table.buckets(), 1);\n        assert!(cloned_table.is_empty());\n    }\n\n    #[test]\n    fn test_clone_non_empty_table() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        table.insert(1, 10, |x| x);\n        table.insert(2, 20, |x| x);\n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), table.len());\n        assert_eq!(cloned_table.buckets(), table.buckets());\n        assert!(cloned_table.get(1, |x| *x == 10).is_some());\n        assert!(cloned_table.get(2, |x| *x == 20).is_some());\n    }\n\n    #[test]\n    fn test_clone_after_insertions() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        table.insert(1, 10, |x| x);\n        table.insert(2, 20, |x| x);\n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), table.len());\n        assert_eq!(cloned_table.get(1, |x| *x == 10).is_some(), true);\n        assert_eq!(cloned_table.get(2, |x| *x == 20).is_some(), true);\n    }\n\n    #[test]\n    fn test_clone_table_with_multiple_elements() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        table.insert(1, 10, |x| x);\n        table.insert(2, 20, |x| x);\n        table.insert(3, 30, |x| x);\n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), table.len());\n        assert_eq!(cloned_table.get(1, |x| *x == 10).is_some(), true);\n        assert_eq!(cloned_table.get(2, |x| *x == 20).is_some(), true);\n        assert_eq!(cloned_table.get(3, |x| *x == 30).is_some(), true);\n    }\n}\n```", "<table::HashTable<T, A> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_hash_table_default_creation() {\n        // Create a default HashTable\n        let table: HashTable<i32, Global> = HashTable::default();\n\n        // Assert that the table is empty\n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.buckets(), 1); // Default table has 1 bucket\n    }\n}\n```", "<table::HashTable<T, A> as core::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n\n    #[test]\n    fn test_into_iter() {\n        let mut table = RawTable::new_in(Global); // Assuming RawTable is initialized appropriately\n        let value = 42; // Example value to insert\n\n        // Insert a value into the table\n        let bucket = table.insert(0, value, |&x| x as u64); // Using an example hasher\n\n        // Call the into_iter method\n        let mut iter = table.into_iter();\n\n        // Check that the iterator yields the expected value\n        assert_eq!(iter.next().unwrap().as_ref(), &value);\n        assert_eq!(iter.next(), None); // Ensure the iterator is finished\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let table: RawTable<i32> = RawTable::new_in(Global); // Empty table\n\n        // Call the into_iter method\n        let mut iter = table.into_iter();\n\n        // Ensure the iterator is empty\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "<table::IntoIter<T, A> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_into_iter_default() {\n        let iter: IntoIter<u32, Global> = IntoIter::default();\n        assert_eq!(iter.len(), 0);\n    }\n\n    #[test]\n    fn test_into_iter_default_non_empty() {\n        let mut iter: IntoIter<u32, Global> = IntoIter::default();\n        \n        // Assume we have some method to fill iter\n        // fill_iter(&mut iter);\n        \n        // Check the len is still 0 for the newly created default\n        assert_eq!(iter.len(), 0);\n        \n        // After filling, the default iter should still be usable for checking the default method\n        let default_iter: IntoIter<u32, Global> = IntoIter::default();\n        assert_eq!(default_iter.len(), 0);\n    }\n}\n```", "<table::IntoIter<T, A> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use raw::{RawIntoIter, RawIter, RawIterRange, Bucket};\n    use table::IntoIter;\n    \n    #[test]\n    fn test_len() {\n        let mut table: HashTable<u32> = HashTable::new();\n        table.insert(1);\n        table.insert(2);\n        table.insert(3);\n        \n        let iterator: IntoIter<u32> = table.into_iter();\n        let length = iterator.len();\n        \n        assert_eq!(length, 3);\n        \n        table.insert(4);\n        \n        let iterator: IntoIter<u32> = table.into_iter();\n        let length_after_insert = iterator.len();\n        \n        assert_eq!(length_after_insert, 4);\n    }\n\n    #[test]\n    fn test_len_empty() {\n        let table: HashTable<u32> = HashTable::new();\n        let iterator: IntoIter<u32> = table.into_iter();\n        assert_eq!(iterator.len(), 0);\n    }\n\n    #[test]\n    fn test_len_after_removal() {\n        let mut table: HashTable<u32> = HashTable::new();\n        table.insert(1);\n        table.insert(2);\n        table.insert(3);\n        \n        let iterator: IntoIter<u32> = table.into_iter();\n        assert_eq!(iterator.len(), 3);\n        \n        table.remove(&2);\n        \n        let iterator: IntoIter<u32> = table.into_iter();\n        assert_eq!(iterator.len(), 2);\n    }\n}\n```", "<table::IntoIter<T, A> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n\n    #[test]\n    fn test_fold() {\n        let bitmask = BitMask(0b101010); // Example BitMask\n        let into_iter = IntoIter {\n            inner: RawIntoIter {\n                iter: RawIter::default(),\n                allocation: None,\n                marker: PhantomData,\n            },\n        };\n\n        let result = into_iter.fold(0, |acc, _| acc + 1); // Counting the elements\n        assert_eq!(result, 0); // Adjust based on the actual expected count of elements\n    }\n\n    #[test]\n    fn test_fold_with_non_identity_operation() {\n        let bitmask = BitMask(0b110); // Example BitMask\n        let into_iter = IntoIter {\n            inner: RawIntoIter {\n                iter: RawIter::default(),\n                allocation: None,\n                marker: PhantomData,\n            },\n        };\n\n        let result = into_iter.fold(1, |acc, _| acc * 2); // Doubling each time\n        assert_eq!(result, 1); // Adjust based on the actual expected result\n    }\n}\n```", "<table::IntoIter<T, A> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use control::bitmask::BitMaskIter;\n    use raw::Bucket;\n    use raw::RawIntoIter;\n    use raw::RawIter;\n    use raw::RawIterRange;\n    use table::IntoIter;\n\n    #[test]\n    fn test_next_with_empty_iter() {\n        let empty_iter: IntoIter<i32> = IntoIter::default();\n        assert_eq!(empty_iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_single_element() {\n        let mut into_iter = IntoIter {\n            inner: RawIntoIter {\n                iter: RawIter {\n                    iter: RawIterRange::default(), // Assuming default to a single item\n                    items: 1,\n                },\n                allocation: None,\n                marker: PhantomData,\n            },\n        };\n        // Assuming `write` is used to prepare the single element\n        unsafe {\n            into_iter.inner.iter.next().unwrap().write(42);\n        }\n        assert_eq!(into_iter.next(), Some(42));\n        assert_eq!(into_iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_multiple_elements() {\n        let mut into_iter = IntoIter {\n            inner: RawIntoIter {\n                iter: RawIter {\n                    iter: RawIterRange::default(), // Replace with a valid initialization\n                    items: 3, // Assuming we have 3 elements\n                },\n                allocation: None,\n                marker: PhantomData,\n            },\n        };\n        unsafe {\n            into_iter.inner.iter.next().unwrap().write(1);\n            into_iter.inner.iter.next().unwrap().write(2);\n            into_iter.inner.iter.next().unwrap().write(3);\n        }\n\n        assert_eq!(into_iter.next(), Some(1));\n        assert_eq!(into_iter.next(), Some(2));\n        assert_eq!(into_iter.next(), Some(3));\n        assert_eq!(into_iter.next(), None);\n    }\n}\n```", "<table::IntoIter<T, A> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::table::IntoIter;\n    use crate::raw::{RawIntoIter, RawIter, RawIterRange};\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_size_hint() {\n        // Arrange\n        let mut into_iter: IntoIter<i32, Global> = IntoIter::default();\n\n        // Act\n        let (lower, upper) = into_iter.size_hint();\n\n        // Assert\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_with_elements() {\n        // Arrange\n        let mut into_iter: IntoIter<i32, Global> = IntoIter::default();\n        // Assuming you have a way to populate into_iter with elements, add your elements here\n\n        // Act\n        let (lower, upper) = into_iter.size_hint();\n\n        // Assert\n        assert!(lower > 0);\n        assert!(upper.is_some());\n        assert!(upper.unwrap() >= lower);\n    }\n}\n```", "<table::Iter<'_, T> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_iter_default() {\n        let iter: Iter<u8> = Iter::default();\n        assert!(iter.inner.items == 0);\n    }\n\n    #[test]\n    fn test_iter_clone() {\n        let iter: Iter<u8> = Iter::default();\n        let iter_clone = iter.clone();\n        assert!(iter.inner.items == iter_clone.inner.items);\n    }\n\n    #[test]\n    fn test_iter_next() {\n        let mut iter: Iter<u8> = Iter::default();\n        let result = iter.next();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_iter_size_hint() {\n        let iter: Iter<u8> = Iter::default();\n        let (low, high) = iter.size_hint();\n        assert_eq!(low, 0);\n        assert_eq!(high, Some(0));\n    }\n}\n```", "<table::Iter<'_, T> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n    use crate::raw::{Bucket, RawIter, RawIterRange};\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use crate::table::Iter;\n\n    #[test]\n    fn test_iter_len() {\n        let buffer: Vec<usize> = vec![1, 2, 3, 4, 5];\n        let bucket_ptr = NonNull::new(buffer.as_ptr() as *mut usize).unwrap();\n        \n        let bucket = unsafe { Bucket::from_base_index(bucket_ptr, buffer.len() - 1) };\n        let iter = RawIter {\n            iter: RawIterRange::new(std::ptr::null(), bucket, buffer.len()),\n            items: buffer.len(),\n        };\n        \n        let iter_wrapper = Iter {\n            inner: iter,\n            marker: std::marker::PhantomData,\n        };\n\n        assert_eq!(iter_wrapper.len(), buffer.len());\n    }\n}\n```", "<table::Iter<'a, T> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_iter_clone() {\n        // Set up test data\n        let data: Vec<i32> = vec![1, 2, 3, 4, 5];\n        let base = NonNull::new(data.as_ptr() as *mut _).unwrap();\n        let bucket = unsafe { Bucket::from_base_index(base, 0) };\n        let raw_iter = RawIter {\n            iter: RawIterRange::new(std::ptr::null(), bucket, data.len()),\n            items: data.len(),\n        };\n        let iter = Iter {\n            inner: raw_iter,\n            marker: std::marker::PhantomData,\n        };\n\n        // Clone the iterator\n        let cloned_iter = iter.clone();\n\n        // Validate the state of the cloned iterator\n        assert_eq!(iter.len(), cloned_iter.len());\n    }\n}\n```", "<table::Iter<'a, T> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use raw::{Bucket, RawIter};\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_fold_empty_iterator() {\n        let empty_iter: RawIter<u32> = RawIter::default();\n        let result = empty_iter.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_fold_single_element_iterator() {\n        let data = vec![42]; // Example data\n        let bucket = unsafe { Bucket::from_base_index(NonNull::new_unchecked(data.as_ptr() as *mut _), 0) };\n        let mut iter = RawIter {\n            iter: RawIterRange::new(core::ptr::null(), bucket, 1),\n            items: 1,\n        };\n\n        let result = iter.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 1);\n    }\n\n    #[test]\n    fn test_fold_multiple_elements_iterator() {\n        let data = vec![1, 2, 3, 4, 5]; // Example data\n        let mut acc = 0;\n        let mut buckets: Vec<Bucket<u32>> = data.iter()\n            .map(|&value| unsafe { Bucket::from_base_index(NonNull::new_unchecked(data.as_ptr() as *mut _), value as usize) })\n            .collect();\n        let mut iter = RawIter {\n            iter: RawIterRange::new(core::ptr::null(), buckets[0].clone(), buckets.len()),\n            items: buckets.len(),\n        };\n\n        let result = iter.fold(acc, |acc, bucket| acc + unsafe { bucket.as_ref() });\n        assert_eq!(result, 15); // Sum of 1 + 2 + 3 + 4 + 5\n    }\n}\n```", "<table::Iter<'a, T> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    struct TestType {\n        value: i32,\n    }\n\n    #[test]\n    fn test_iter_next() {\n        // Setup: Create a test hashbrown table and populate it\n        let mut table = HashTable::new();\n        table.insert(1, TestType { value: 1 });\n        table.insert(2, TestType { value: 2 });\n        table.insert(3, TestType { value: 3 });\n\n        let mut iter = table.iter();\n\n        // Test: Ensure that calling next returns the correct values\n        assert_eq!(iter.next().map(|item| item.value), Some(1));\n        assert_eq!(iter.next().map(|item| item.value), Some(2));\n        assert_eq!(iter.next().map(|item| item.value), Some(3));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_next_empty() {\n        // Setup: Create an empty hashbrown table\n        let table: HashTable<TestType> = HashTable::new();\n        let mut iter = table.iter();\n\n        // Test: Ensure that next returns None\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_size_hint() {\n        // Setup: Create a test hashbrown table and populate it\n        let mut table = HashTable::new();\n        table.insert(1, TestType { value: 1 });\n        table.insert(2, TestType { value: 2 });\n\n        let iter = table.iter();\n\n        // Test: Ensure size hint is correct\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n}\n```", "<table::Iter<'a, T> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let raw_iter = RawIter::<i32> {\n            iter: RawIterRange {\n                current_group: BitMaskIter(BitMask(0)),\n                data: unsafe { Bucket::from_base_index(NonNull::new_unchecked(0 as *mut i32), 0) },\n                next_ctrl: core::ptr::null(),\n                end: core::ptr::null(),\n            },\n            items: 0,\n        };\n\n        let iter = Iter {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_single_item() {\n        let mut raw_iter = RawIter::<i32> {\n            iter: RawIterRange {\n                current_group: BitMaskIter(BitMask(1)), // 1 means one bucket available\n                data: unsafe { Bucket::from_base_index(NonNull::new_unchecked(0 as *mut i32), 0) },\n                next_ctrl: core::ptr::null(),\n                end: core::ptr::null(),\n            },\n            items: 1,\n        };\n\n        let iter = Iter {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n    }\n\n    #[test]\n    fn test_size_hint_multiple_items() {\n        let mut raw_iter = RawIter::<i32> {\n            iter: RawIterRange {\n                current_group: BitMaskIter(BitMask(0b1111)), // 4 buckets available\n                data: unsafe { Bucket::from_base_index(NonNull::new_unchecked(0 as *mut i32), 0) },\n                next_ctrl: core::ptr::null(),\n                end: core::ptr::null(),\n            },\n            items: 4,\n        };\n\n        let iter = Iter {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 4);\n        assert_eq!(upper, Some(4));\n    }\n}\n```", "<table::IterHash<'_, T> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::table::IterHash;\n\n    #[test]\n    fn test_default_iter_hash() {\n        let iter_hash: IterHash<u8> = IterHash::default();\n        // Assert that the default instance is correctly initialized\n        assert_eq!(iter_hash.inner.inner.bucket_mask, 0); // Change 0 to the expected initial bucket_mask value\n        assert!(iter_hash.inner.bitmask.0.0 == 0); // Assuming the default BitMask value\n    }\n}\n```", "<table::IterHash<'a, T> as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::marker::PhantomData;\n\n    #[test]\n    fn test_iter_hash_clone() {\n        // Setup a RawIterHash with mock data for testing\n        let raw_iter_hash = RawIterHash {\n            inner: RawIterHashInner {\n                bucket_mask: 0xFF,  // example mask\n                ctrl: NonNull::from(&0 as *const u8 as *mut u8),\n                tag_hash: Tag::full(42),  // use an arbitrary hash\n                probe_seq: ProbeSeq { pos: 0, stride: 0 },\n                group: Group::static_empty().to_vec().into_iter().next().unwrap(),\n                bitmask: BitMaskIter(BitMask(0x1)),  // example with one set bit\n            },\n            _marker: PhantomData,\n        };\n\n        let iter_hash = IterHash {\n            inner: raw_iter_hash,\n            marker: PhantomData,\n        };\n\n        // Clone the IterHash\n        let cloned_iter_hash = iter_hash.clone();\n\n        // Verify that the cloned object is not the same as the original\n        assert_ne!(std::ptr::addr_of!(iter_hash), std::ptr::addr_of!(cloned_iter_hash), \"The cloned IterHash should not be the same instance as the original\");\n\n        // Further checks can be added to validate the internal state if necessary\n        // For example: assert_eq!(cloned_iter_hash.inner.bucket_mask, iter_hash.inner.bucket_mask);\n    }\n}\n```", "<table::IterHash<'a, T> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::{BitMask, BitMaskIter};\n    use control::group::sse2::Group;\n    use control::tag::Tag;\n    use raw::{RawIterHash, RawIterHashInner};\n    use table::IterHash;\n    \n    #[test]\n    fn test_iterhash_fold() {\n        // Setup sample test data\n        let tag = Tag::full(12345);\n        let group = Group::static_empty();\n        let bitmask = BitMask(0b0000_0001); // A sample bitmask for one valid entry\n        let mut iter = RawIterHash::<usize> {\n            inner: RawIterHashInner {\n                bucket_mask: 1,\n                ctrl: NonNull::from(group),\n                tag_hash: tag,\n                probe_seq: ProbeSeq { pos: 0, stride: 0 },\n                group: group,\n                bitmask: BitMaskIter(bitmask),\n            },\n            _marker: PhantomData,\n        };\n        \n        let iter_hash = IterHash {\n            inner: iter,\n            marker: PhantomData,\n        };\n        \n        // Fold over the iterator\n        let result = iter_hash.fold(0, |acc, _| acc + 1);\n        \n        // Check if the fold result is as expected\n        assert_eq!(result, 1);\n    }\n}\n```", "<table::IterHash<'a, T> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::table::IterHash;\n    use crate::raw::RawIterHash;\n    use crate::control::tag::Tag;\n    use crate::control::group::sse2::Group;\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use std::marker::PhantomData;\n\n    struct TestHashTable {\n        // Mock struct to simulate a hash table\n        entries: Vec<Option<Tag>>,\n    }\n\n    impl TestHashTable {\n        fn new() -> Self {\n            TestHashTable {\n                entries: vec![Some(Tag::EMPTY); 16], // Initialize with empty tags\n            }\n        }\n\n        fn insert(&mut self, index: usize, tag: Tag) {\n            self.entries[index] = Some(tag); // Set a tag at a specific index\n        }\n\n        fn iter_hash(&self) -> IterHash<Tag> {\n            // Simulating the creation of an IterHash\n            let raw_iter = RawIterHash::default(); // Replace with relevant RawIterHash creation\n            IterHash {\n                inner: raw_iter,\n                marker: PhantomData,\n            }\n        }\n    }\n\n    #[test]\n    fn test_iter_hash_next() {\n        let mut table = TestHashTable::new();\n        table.insert(0, Tag::full(1)); // Insert a full tag\n        table.insert(1, Tag::EMPTY);    // Insert an empty tag\n        table.insert(2, Tag::full(2));   // Insert another full tag\n\n        let mut iter = table.iter_hash();\n\n        // Test the first call to next\n        let first = iter.next();\n        assert!(first.is_some());\n        assert_eq!(first.unwrap(), &Tag::full(1)); // Expect the first full tag\n\n        // Test the second call to next\n        let second = iter.next();\n        assert!(second.is_some());\n        assert_eq!(second.unwrap(), &Tag::full(2)); // Expect the second full tag\n\n        // Test that there are no more tags\n        let third = iter.next();\n        assert!(third.is_none());\n    }\n}\n```", "<table::IterHashMut<'_, T> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::default::Default;\n\n    #[test]\n    fn test_iter_hash_mut_default() {\n        let iter: IterHashMut<u8> = IterHashMut::default();\n        assert_eq!(iter.inner.inner.bucket_mask, 0); // Assuming default initializes bucket_mask to 0\n        assert!(iter.inner.inner.ctrl.as_ptr().is_null()); // Assuming default initializes ctrl as null\n    }\n}\n```", "<table::IterHashMut<'a, T> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::{BitMask, BitMaskIter};\n    use control::group::sse2::Group;\n    use control::tag::Tag;\n    use raw::{RawIterHash, RawIterHashInner};\n    use table::IterHashMut;\n\n    #[test]\n    fn test_fold() {\n        // Prepare a sample hash table and fill it with test values\n        let mut values = vec![1, 2, 3, 4, 5];\n        let mut iter = IterHashMut {\n            inner: RawIterHash::default(), // Normally, this would be a proper iterator\n            marker: PhantomData,\n        };\n\n        // Test folding over the iterator with a sum\n        let sum = iter.fold(0, |acc, &val| acc + val);\n        assert_eq!(sum, 15); // 1 + 2 + 3 + 4 + 5 = 15\n    }\n\n    #[test]\n    fn test_fold_with_empty() {\n        // Test the edge case with an empty iterator\n        let iter: IterHashMut<i32> = IterHashMut {\n            inner: RawIterHash::default(),\n            marker: PhantomData,\n        };\n\n        let sum = iter.fold(0, |acc, _| acc + 1);\n        assert_eq!(sum, 0); // sum should be the initial value\n    }\n}\n```", "<table::IterHashMut<'a, T> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::group::sse2::Group;\n    use control::tag::Tag;\n    use raw::{RawIterHash, RawIterHashInner};\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_iter_hash_mut_next() {\n        // Set up a mock RawIterHash with a valid state.\n        let tag1 = Tag::full(1);\n        let tag2 = Tag::full(2);\n        let group = Group(x86::_mm_set_epi8(0, 0, 0, 0, 0, 0, tag2.0 as i8, tag1.0 as i8));\n        let raw_iter = RawIterHash {\n            inner: RawIterHashInner {\n                bucket_mask: 0b11,\n                ctrl: NonNull::from(&group as *const _ as *mut _),\n                tag_hash: tag1,\n                probe_seq: ProbeSeq { pos: 0, stride: 0 },\n                group,\n                bitmask: BitMaskIter(BitMask(0b11)),\n            },\n            _marker: PhantomData,\n        };\n        let mut iter_hash_mut = IterHashMut {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        // Test that the next method returns mutable references to the expected items.\n        assert!(iter_hash_mut.next().is_some());\n        assert!(iter_hash_mut.next().is_some());\n        assert!(iter_hash_mut.next().is_none());\n    }\n}\n```", "<table::IterMut<'_, T> as core::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_default_iter_mut() {\n        // Create an empty RawIter for testing\n        let raw_iter: RawIter<i32> = Default::default();\n        \n        // Create an instance of IterMut using the default function\n        let iter_mut: IterMut<i32> = Default::default();\n        \n        // Check that the inner RawIter of IterMut is indeed the default RawIter\n        assert_eq!(iter_mut.inner.items, raw_iter.items);\n    }\n}\n```", "<table::IterMut<'_, T> as core::iter::ExactSizeIterator>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use raw::{Bucket, RawIter, RawIterRange};\n    use table::IterMut;\n\n    #[test]\n    fn test_iter_mut_len() {\n        let mut table: HashTable<usize> = HashTable::new();\n        table.insert(1);\n        table.insert(2);\n        table.insert(3);\n\n        let mut iter = table.iter_mut();\n        assert_eq!(iter.len(), 3);\n\n        iter.next();\n        assert_eq!(iter.len(), 2);\n\n        iter.next();\n        iter.next();\n        assert_eq!(iter.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_mut_empty_len() {\n        let table: HashTable<usize> = HashTable::new();\n        let mut iter = table.iter_mut();\n        assert_eq!(iter.len(), 0);\n    }\n}\n```", "<table::IterMut<'a, T> as core::iter::Iterator>::fold": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use raw::{Bucket, RawIter, RawIterRange};\n    use table::IterMut;\n\n    #[test]\n    fn test_fold() {\n        // Setup mock data\n        let bucket_data = vec![1, 2, 3, 4, 5]; // Example data\n        let buckets: Vec<Bucket<i32>> = bucket_data\n            .iter()\n            .map(|&item| unsafe { Bucket::from_base_index(NonNull::from(&bucket_data[0]), item as usize) })\n            .collect();\n\n        // Create a RawIter from buckets\n        let raw_iter = RawIter {\n            iter: RawIterRange::new(...), // Properly initialized RawIterRange\n            items: buckets.len(),\n        };\n\n        // Create an IterMut\n        let iter = IterMut {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        // Fold the iterator\n        let result: i32 = iter.fold(0, |acc, item| acc + item);\n\n        // Assert the result\n        assert_eq!(result, 15); // 1 + 2 + 3 + 4 + 5 = 15\n    }\n}\n```", "<table::IterMut<'a, T> as core::iter::Iterator>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_iter_mut_next() {\n        // Setup test data\n        let mut data = vec![1, 2, 3, 4];\n        let raw_iter = RawIter { items: 4, iter: RawIterRange::new(/* appropriate parameters */) };\n        let mut iter_mut = IterMut {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        // Test the next method\n        let first_item = iter_mut.next();\n        assert_eq!(first_item, Some(unsafe { &mut data[0] }));\n        let second_item = iter_mut.next();\n        assert_eq!(second_item, Some(unsafe { &mut data[1] }));\n        let third_item = iter_mut.next();\n        assert_eq!(third_item, Some(unsafe { &mut data[2] }));\n        let fourth_item = iter_mut.next();\n        assert_eq!(fourth_item, Some(unsafe { &mut data[3] }));\n        let no_item = iter_mut.next();\n        assert_eq!(no_item, None);\n    }\n}\n```", "<table::IterMut<'a, T> as core::iter::Iterator>::size_hint": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import everything necessary from the current module\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_size_hint() {\n        // Set up the initial state of the HashTable or any collection that\n        // utilizes IterMut\n        let mut collection: HashTable<i32> = HashTable::new();\n        \n        // Insert some elements into the collection\n        collection.insert(1);\n        collection.insert(2);\n        collection.insert(3);\n\n        // Create an iterator with the iter_mut() method\n        let mut iter = collection.iter_mut();\n        \n        // Get the size hint\n        let size_hint = iter.size_hint();\n\n        // Assert the size hint\n        assert_eq!(size_hint, (3, Some(3)), \"Expected size hint to match (3, Some(3))\");\n    }\n\n    #[test]\n    fn test_size_hint_empty() {\n        // Set up the initial state of the HashTable \n        let collection: HashTable<i32> = HashTable::new();\n        \n        // Create an iterator with the iter_mut() method\n        let mut iter = collection.iter_mut();\n        \n        // Get the size hint\n        let size_hint = iter.size_hint();\n\n        // Assert the size hint for empty iterator\n        assert_eq!(size_hint, (0, Some(0)), \"Expected size hint to match (0, Some(0))\");\n    }\n\n    #[test]\n    fn test_size_hint_after_removal() {\n        let mut collection: HashTable<i32> = HashTable::new();\n        \n        collection.insert(1);\n        collection.insert(2);\n        collection.insert(3);\n        collection.remove(&1); // Remove an element\n\n        let mut iter = collection.iter_mut();\n        let size_hint = iter.size_hint();\n\n        // Assert the size hint after one removal\n        assert_eq!(size_hint, (2, Some(2)), \"Expected size hint to match (2, Some(2))\");\n    }\n}\n```", "control::bitmask::BitMask::any_bit_set": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_any_bit_set_with_no_bits_set() {\n        let mask = BitMask(0);\n        assert!(!mask.any_bit_set());\n    }\n\n    #[test]\n    fn test_any_bit_set_with_some_bits_set() {\n        let mask = BitMask(0b1010);\n        assert!(mask.any_bit_set());\n    }\n\n    #[test]\n    fn test_any_bit_set_with_all_bits_set() {\n        let mask = BitMask(u64::MAX);\n        assert!(mask.any_bit_set());\n    }\n\n    #[test]\n    fn test_any_bit_set_with_one_bit_set() {\n        let mask = BitMask(0b0001);\n        assert!(mask.any_bit_set());\n    }\n}\n```", "control::bitmask::BitMask::invert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::{BitMask, BITMASK_MASK};\n\n    #[test]\n    fn test_invert() {\n        let original_mask = BitMask(0b00001111); // example input\n        let inverted_mask = original_mask.invert();\n        assert_eq!(inverted_mask.0, !original_mask.0 & BITMASK_MASK);\n    }\n\n    #[test]\n    fn test_invert_all_ones() {\n        let original_mask = BitMask(BITMASK_MASK);\n        let inverted_mask = original_mask.invert();\n        assert_eq!(inverted_mask.0, 0);\n    }\n\n    #[test]\n    fn test_invert_all_zeros() {\n        let original_mask = BitMask(0);\n        let inverted_mask = original_mask.invert();\n        assert_eq!(inverted_mask.0, BITMASK_MASK);\n    }\n\n    #[test]\n    fn test_invert_random() {\n        let original_mask = BitMask(0b10101010); // example input\n        let inverted_mask = original_mask.invert();\n        assert_eq!(inverted_mask.0, !original_mask.0 & BITMASK_MASK);\n    }\n}\n```", "control::bitmask::BitMask::leading_zeros": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_leading_zeros() {\n        // Given test cases for BitMask leading_zeros\n        let mask1 = BitMask(0b00000000_00000000_00000000_00000000); // 32 leading zeros\n        let mask2 = BitMask(0b00000000_00000000_00000000_00000001); // 31 leading zeros\n        let mask3 = BitMask(0b00000000_00000000_00000001_00000000); // 29 leading zeros\n        let mask4 = BitMask(0b11111111_11111111_11111111_11111111); // 0 leading zeros\n        \n        // Expected leading zero counts\n        assert_eq!(mask1.leading_zeros(), 32 / BITMASK_STRIDE); // Replace BITMASK_STRIDE with actual value\n        assert_eq!(mask2.leading_zeros(), 31 / BITMASK_STRIDE); // Replace BITMASK_STRIDE with actual value\n        assert_eq!(mask3.leading_zeros(), 29 / BITMASK_STRIDE); // Replace BITMASK_STRIDE with actual value\n        assert_eq!(mask4.leading_zeros(), 0 / BITMASK_STRIDE);  // Replace BITMASK_STRIDE with actual value\n    }\n}\n```", "control::bitmask::BitMask::lowest_set_bit": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_lowest_set_bit_some() {\n        let mask = BitMask(0b00000010);\n        assert_eq!(mask.lowest_set_bit(), Some(1));\n    }\n\n    #[test]\n    fn test_lowest_set_bit_some_multiple_bits() {\n        let mask = BitMask(0b00001100);\n        assert_eq!(mask.lowest_set_bit(), Some(2));\n    }\n\n    #[test]\n    fn test_lowest_set_bit_none() {\n        let mask = BitMask(0b00000000);\n        assert_eq!(mask.lowest_set_bit(), None);\n    }\n\n    #[test]\n    fn test_lowest_set_bit_some_first_bit() {\n        let mask = BitMask(0b00000001);\n        assert_eq!(mask.lowest_set_bit(), Some(0));\n    }\n}\n```", "control::bitmask::BitMask::nonzero_trailing_zeros": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::control::bitmask::{BitMask, NonZeroBitMaskWord};\n\n    #[test]\n    fn test_nonzero_trailing_zeros() {\n        // BitMask stride assumption, adjust it based on actual crate definition\n        const BITMASK_STRIDE: usize = 8; // Update this according to the actual stride\n        let test_cases = vec![\n            (NonZeroBitMaskWord::new(0b0000_0001).unwrap(), 0), // 1 -> 0 trailing zeros\n            (NonZeroBitMaskWord::new(0b0000_0010).unwrap(), 1), // 2 -> 1 trailing zero\n            (NonZeroBitMaskWord::new(0b0000_1100).unwrap(), 2), // 12 -> 2 trailing zeros\n            (NonZeroBitMaskWord::new(0b0001_0000).unwrap(), 4), // 16 -> 4 trailing zeros\n            (NonZeroBitMaskWord::new(0b0010_0000).unwrap(), 5), // 32 -> 5 trailing zeros\n            (NonZeroBitMaskWord::new(0b1111_1110).unwrap(), 1), // 254 -> 1 trailing zero\n            (NonZeroBitMaskWord::new(0b1000_0000).unwrap(), 7), // 128 -> 7 trailing zeros\n        ];\n\n        for (input, expected) in test_cases {\n            assert_eq!(BitMask::nonzero_trailing_zeros(input), expected);\n        }\n    }\n}\n```", "control::bitmask::BitMask::remove_lowest_bit": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_remove_lowest_bit() {\n        let mask1 = BitMask(0b1010); // Binary: 1010\n        let mask2 = mask1.remove_lowest_bit();\n        assert_eq!(mask2.0, 0b1000); // Should remove the lowest set bit (1 in this case)\n\n        let mask3 = BitMask(0b0000); // Binary: 0000\n        let mask4 = mask3.remove_lowest_bit();\n        assert_eq!(mask4.0, 0b0000); // Should remain unchanged, no bits set\n\n        let mask5 = BitMask(0b0001); // Binary: 0001\n        let mask6 = mask5.remove_lowest_bit();\n        assert_eq!(mask6.0, 0b0000); // Should remove the only set bit\n\n        let mask7 = BitMask(0b1111); // Binary: 1111\n        let mask8 = mask7.remove_lowest_bit();\n        assert_eq!(mask8.0, 0b1110); // Should remove the lowest set bit\n    }\n}\n```", "control::bitmask::BitMask::trailing_zeros": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_trailing_zeros() {\n        let mask_with_trailing_zeros = BitMask(0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001);\n        assert_eq!(mask_with_trailing_zeros.trailing_zeros(), 0);\n\n        let mask_with_two_trailing_zeros = BitMask(0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000011);\n        assert_eq!(mask_with_two_trailing_zeros.trailing_zeros(), 1);\n\n        let mask_with_four_trailing_zeros = BitMask(0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00001111);\n        assert_eq!(mask_with_four_trailing_zeros.trailing_zeros(), 3);\n\n        let mask_with_no_trailing_zeros = BitMask(0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111);\n        assert_eq!(mask_with_no_trailing_zeros.trailing_zeros(), 0);\n    }\n}\n```", "control::group::sse2::Group::convert_special_to_empty_and_full_to_deleted": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::group::sse2::{Group, Tag};\n\n    #[test]\n    fn test_convert_special_to_empty_and_full_to_deleted() {\n        unsafe {\n            // Create a test group where:\n            // - Tag::FULL will be represented by 0x00\n            // - Tag::DELETED will be represented by 0xFF\n            // - Tag::EMPTY will be represented by 0x80\n            \n            let test_tags: [Tag; Group::WIDTH] = [\n                Tag::FULL, Tag::DELETED, Tag::EMPTY, Tag::FULL,\n                Tag::FULL, Tag::EMPTY, Tag::DELETED, Tag::EMPTY,\n                Tag::FULL, Tag::FULL, Tag::DELETED, Tag::EMPTY,\n                Tag::DELETED, Tag::FULL, Tag::FULL, Tag::EMPTY,\n            ];\n            \n            let group = Group::load(test_tags.as_ptr());\n\n            let transformed_group = group.convert_special_to_empty_and_full_to_deleted();\n\n            // Create expected group, where:\n            // - FULL -> DELETED\n            // - DELETED -> EMPTY\n            // - EMPTY -> EMPTY\n            let expected_tags: [Tag; Group::WIDTH] = [\n                Tag::DELETED, Tag::EMPTY, Tag::EMPTY, Tag::DELETED,\n                Tag::DELETED, Tag::EMPTY, Tag::EMPTY, Tag::EMPTY,\n                Tag::DELETED, Tag::DELETED, Tag::EMPTY, Tag::EMPTY,\n                Tag::EMPTY, Tag::DELETED, Tag::DELETED, Tag::EMPTY,\n            ];\n            \n            // Check if transformed group matches expected\n            let expected_group = Group::load(expected_tags.as_ptr());\n            let mask = transformed_group.match_empty_or_deleted();\n\n            assert_eq!(mask.0, expected_group.match_empty_or_deleted().0);\n        }\n    }\n}\n```", "control::group::sse2::Group::load": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem;\n\n    #[test]\n    fn test_load() {\n        // Prepare an array of Tags\n        let tags: [Tag; Group::WIDTH] = [\n            Tag::EMPTY, Tag::DELETED, Tag::full(1), Tag::full(2),\n            Tag::full(3), Tag::full(4), Tag::full(5), Tag::full(6),\n            Tag::full(7), Tag::full(8), Tag::full(9), Tag::full(10),\n            Tag::full(11), Tag::full(12), Tag::full(13), Tag::full(14),\n        ];\n        \n        // Get a pointer to the start of the tags array\n        let tags_ptr = tags.as_ptr();\n\n        // Use unsafe block to call the load function\n        let group: Group;\n\n        unsafe {\n            group = Group::load(tags_ptr);\n        }\n\n        // Verify that the loaded group has the expected first tag\n        let expected_mask = 0b1111_1111; // Corresponds to Tag::EMPTY in this example\n        let tag_mask = group.match_empty_or_deleted().0;\n\n        assert_eq!(tag_mask, expected_mask, \"Loaded group did not match expected tag mask.\");\n    }\n}\n```", "control::group::sse2::Group::load_aligned": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem;\n\n    #[test]\n    fn test_load_aligned() {\n        // Create a vector of Tags that is aligned\n        let mut aligned_tags: Vec<Tag> = vec![Tag::EMPTY; Group::WIDTH];\n        let aligned_ptr: *const Tag = aligned_tags.as_ptr();\n\n        unsafe {\n            // Ensure the pointer is aligned\n            assert_eq!(aligned_ptr.align_offset(mem::align_of::<Group>()), 0);\n            \n            // Load aligned tags into Group\n            let group = Group::load_aligned(aligned_ptr);\n            \n            // Check if the Group takes the expected value (all Tags are EMPTY)\n            let expected = Group::load_aligned(Group::static_empty().as_ptr());\n            assert_eq!(group, expected);\n        }\n    }\n}\n```", "control::group::sse2::Group::match_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use control::group::sse2::Group;\n    use control::tag::Tag;\n\n    #[test]\n    fn test_match_empty() {\n        let empty_group = Group::static_empty();\n        let group = unsafe { Group::load(empty_group.as_ptr()) };\n        let bitmask = group.match_empty();\n        \n        // Check if the BitMask indicates all bits set to EMPTY\n        assert!(bitmask.any_bit_set());\n        assert_eq!(bitmask.trailing_zeros(), 0);\n        assert_eq!(bitmask.leading_zeros(), 0);\n        assert_eq!(bitmask.lowest_set_bit(), Some(0));\n    }\n}\n```", "control::group::sse2::Group::match_empty_or_deleted": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use control::group::sse2::Group;\n    use std::mem;\n\n    #[test]\n    fn test_match_empty_or_deleted() {\n        // Assuming Tag::EMPTY is defined as 0\n        let empty_tag = Tag(0);\n        let deleted_tag = Tag(1 << 7); // Assuming DELETED is defined as high bit set\n        let tags = [empty_tag, deleted_tag, empty_tag, empty_tag, deleted_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag];\n        let group = unsafe { Group::load(tags.as_ptr()) };\n        \n        let mask = group.match_empty_or_deleted();\n        \n        // Here, we expect the mask to have bits set for all empty and deleted tags\n        // Assuming DELETED is the high bit, the expected mask would be 0b1100000000000000\n        let expected_mask = (1 << 15) | (1 << 14); // bits for 0, 1\n        assert_eq!(mask.0, expected_mask as BitMaskWord);\n    }\n}\n```", "control::group::sse2::Group::match_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use control::group::sse2::Group;\n\n    #[test]\n    fn test_match_full() {\n        // Arrange\n        let tags: [Tag; Group::WIDTH] = [Tag::FULL; Group::WIDTH]; // Assume all tags are FULL\n        let group = unsafe { Group::load(tags.as_ptr()) };\n\n        // Act\n        let bitmask = group.match_full();\n\n        // Assert\n        assert!(bitmask.any_bit_set(), \"BitMask should have at least one bit set for FULL tags\");\n        assert_eq!(bitmask, BitMask(BITMASK_MASK), \"BitMask should match expected value for full tags\");\n    }\n\n    #[test]\n    fn test_match_full_empty_tags() {\n        // Arrange\n        let tags: [Tag; Group::WIDTH] = [Tag::EMPTY; Group::WIDTH]; // Assume all tags are EMPTY\n        let group = unsafe { Group::load(tags.as_ptr()) };\n\n        // Act\n        let bitmask = group.match_full();\n\n        // Assert\n        assert!(!bitmask.any_bit_set(), \"BitMask should not have any bits set for EMPTY tags\");\n    }\n\n    #[test]\n    fn test_match_full_deleted_tags() {\n        // Arrange\n        let tags: [Tag; Group::WIDTH] = [Tag::DELETED; Group::WIDTH]; // Assume all tags are DELETED\n        let group = unsafe { Group::load(tags.as_ptr()) };\n\n        // Act\n        let bitmask = group.match_full();\n\n        // Assert\n        assert!(!bitmask.any_bit_set(), \"BitMask should not have any bits set for DELETED tags\");\n    }\n}\n```", "control::group::sse2::Group::match_tag": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::group::sse2::Group;\n    use control::tag::Tag;\n    use control::bitmask::BitMask;\n    use std::mem;\n\n    #[test]\n    fn test_match_tag() {\n        // Create a group of tags\n        let tags: [Tag; Group::WIDTH] = [\n            Tag(1), Tag(2), Tag(3), Tag(1), Tag(4), Tag(1), Tag(5), Tag(2), Tag(6), Tag(1), Tag(3), Tag(4), Tag(5), Tag(1), Tag(6), Tag(1)\n        ];\n        \n        // Group the tags into a Group\n        let group = unsafe { Group::load(tags.as_ptr()) };\n\n        // Test matching tag\n        let tag_to_match = Tag(1);\n        let result_mask = group.match_tag(tag_to_match);\n\n        // Calculate expected result mask\n        let expected_mask = BitMask(0b1010101010101010); // Binary representation of expected result\n\n        assert_eq!(result_mask, expected_mask);\n    }\n\n    #[test]\n    fn test_match_tag_no_match() {\n        // Create a group of tags\n        let tags: [Tag; Group::WIDTH] = [\n            Tag(1), Tag(2), Tag(3), Tag(4), Tag(5), Tag(6), Tag(7), Tag(8), Tag(9), Tag(10), Tag(11), Tag(12), Tag(13), Tag(14), Tag(15), Tag(16)\n        ];\n        \n        // Group the tags into a Group\n        let group = unsafe { Group::load(tags.as_ptr()) };\n\n        // Test matching a tag that does not exist\n        let tag_to_match = Tag(99);\n        let result_mask = group.match_tag(tag_to_match);\n\n        // Expected result mask should be 0 as there are no matches\n        let expected_mask = BitMask(0);\n\n        assert_eq!(result_mask, expected_mask);\n    }\n}\n```", "control::group::sse2::Group::static_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use super::control::group::sse2::Group;\n    use super::control::tag::Tag;\n\n    #[test]\n    fn test_static_empty() {\n        const EMPTY_TAGS: &[Tag; Group::WIDTH] = Group::static_empty();\n\n        // Verify that all tags are EMPTY\n        for tag in EMPTY_TAGS {\n            assert_eq!(*tag, Tag::EMPTY);\n        }\n    }\n}\n```", "control::group::sse2::Group::store_aligned": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem;\n\n    #[test]\n    fn test_store_aligned() {\n        // Create an aligned buffer for storing tags\n        let mut tags: [Tag; Group::WIDTH] = unsafe { std::mem::zeroed() };\n        let aligned_ptr = tags.as_mut_ptr();\n\n        // Create a Group instance with arbitrary tags\n        let group = Group(x86::_mm_set_epi8(1, 2, 3, 4, 5, 6, 7, 8)); // Example tags\n\n        // Store the group aligned\n        unsafe {\n            group.store_aligned(aligned_ptr);\n        }\n\n        // Check that the tags in the buffer are as expected\n        for (i, tag) in tags.iter().enumerate() {\n            assert_eq!(tag.0, (i + 1) as u8);\n        }\n\n        // Ensure the buffer is aligned\n        assert_eq!(aligned_ptr.align_offset(mem::align_of::<Group>()), 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_store_aligned_unaligned_ptr() {\n        // Create an unaligned buffer for storing tags\n        let mut unaligned_tags: [Tag; Group::WIDTH + 1] = unsafe { std::mem::zeroed() };\n        let unaligned_ptr = unaligned_tags.as_mut_ptr().add(1); // Make it unaligned\n\n        // Create a Group instance with arbitrary tags\n        let group = Group(x86::_mm_set_epi8(1, 2, 3, 4, 5, 6, 7, 8)); // Example tags\n\n        // This should panic because unaligned_ptr is not aligned\n        unsafe {\n            group.store_aligned(unaligned_ptr);\n        }\n    }\n}\n```", "control::tag::Tag::full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::tag::Tag;\n\n    #[test]\n    fn test_full() {\n        let hash_values = [\n            (0, Tag(0)),                   // Hash 0 results in Tag(0)\n            (1, Tag(0)),                   // Hash 1 results in Tag(0)\n            (127, Tag(0b0111_1111)),       // Hash 127 results in Tag(0b0111_1111)\n            (128, Tag(0b0000_0000)),       // Hash 128 results in Tag(0b0000_0000)\n            (255, Tag(0b0000_0111)),       // Hash 255 results in Tag(0b0000_0111)\n            (511, Tag(0b0000_1111)),       // Hash 511 results in Tag(0b0000_1111)\n            (1023, Tag(0b0001_1111)),      // Hash 1023 results in Tag(0b0001_1111)\n            (u64::MAX, Tag(0b0111_1111)),  // Hash u64::MAX results in Tag(0b0111_1111)\n        ];\n\n        for (hash, expected_tag) in hash_values.iter() {\n            let tag = Tag::full(*hash);\n            assert_eq!(tag, *expected_tag, \"Expected Tag for hash {} does not match\", hash);\n            assert!(tag.is_full(), \"Tag for hash {} should be full\", hash);\n        }\n    }\n}\n```", "control::tag::Tag::is_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::control::tag::Tag;\n\n    #[test]\n    fn test_is_full() {\n        // Test with a full tag\n        let full_tag = Tag::full(0x7f); // Using a hash that results in 0x7f\n        assert!(full_tag.is_full());\n\n        // Test with an empty tag\n        let empty_tag = Tag::EMPTY;\n        assert!(!empty_tag.is_full());\n\n        // Test with a deleted tag\n        let deleted_tag = Tag::DELETED;\n        assert!(!deleted_tag.is_full());\n\n        // Test with a custom tag that is full\n        let custom_full_tag = Tag(0b0111_1111); // Full tag with top bit clear\n        assert!(custom_full_tag.is_full());\n\n        // Test with a custom tag that is not full\n        let custom_not_full_tag = Tag(0b1111_1111); // Full tag with top bit set\n        assert!(!custom_not_full_tag.is_full());\n    }\n}\n```", "control::tag::Tag::is_special": "```rust\n#[cfg(test)]\nmod tests {\n    use super::control::tag::Tag;\n\n    #[test]\n    fn test_is_special() {\n        assert!(!Tag::EMPTY.is_special());\n        assert!(Tag::DELETED.is_special());\n        assert!(!Tag(0b0111_1111).is_special());\n        assert!(Tag(0b1111_1111).is_special());\n    }\n}\n```", "control::tag::Tag::special_is_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use super::control::tag::Tag;\n\n    #[test]\n    fn test_special_is_empty() {\n        // Test for EMPTY tag\n        let empty_tag = Tag::EMPTY;\n        assert!(empty_tag.is_special());\n        assert!(empty_tag.special_is_empty());\n\n        // Test for DELETED tag\n        let deleted_tag = Tag::DELETED;\n        assert!(deleted_tag.is_special());\n        assert!(!deleted_tag.special_is_empty());\n\n        // Test for another special tag\n        let special_tag = Tag(0b1000_0001); // special and empty\n        assert!(special_tag.is_special());\n        assert!(special_tag.special_is_empty());\n        \n        let another_special_tag = Tag(0b1000_0010); // special and not empty\n        assert!(another_special_tag.is_special());\n        assert!(!another_special_tag.special_is_empty());\n    }\n}\n```", "control::tag::TagSliceExt::fill_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::control::tag::{TagSliceExt, Tag};\n\n    #[test]\n    fn test_fill_empty() {\n        let mut tags = vec![Tag::FILLED, Tag::FILLED, Tag::FILLED];\n        let tags_slice = &mut tags.as_mut_slice();\n        tags_slice.fill_empty();\n        assert_eq!(tags_slice, &[Tag::EMPTY, Tag::EMPTY, Tag::EMPTY]);\n    }\n}\n```", "map::Drain::<'_, K, V, A>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut drain = map.drain();\n        let drain_iter = drain.iter();\n\n        let mut collected: Vec<_> = drain_iter.collect();\n        collected.sort_unstable();\n\n        assert_eq!(collected, vec![Some((&1, &\"a\")), Some((&2, &\"b\")), Some((&3, &\"c\"))]);\n\n        assert_eq!(drain_iter.len(), 0);\n        assert_eq!(drain_iter.next(), None);\n    }\n}\n```", "map::Entry::<'a, K, V, S, A>::and_modify": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_and_modify_on_occupied_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"test\", 1);\n\n        map.entry(\"test\")\n            .and_modify(|e| *e += 1);\n\n        assert_eq!(map[\"test\"], 2);\n    }\n\n    #[test]\n    fn test_and_modify_on_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        let entry = map.entry(\"test\")\n            .and_modify(|e| *e += 1);\n\n        match entry {\n            Entry::Vacant(_) => { /* Correct behavior: Entry is vacant */ }\n            _ => panic!(\"Expected vacant entry, but got occupied.\"),\n        }\n\n        map.entry(\"test\").or_insert(1);\n\n        map.entry(\"test\")\n            .and_modify(|e| *e += 1);\n        assert_eq!(map[\"test\"], 2);\n    }\n\n    #[test]\n    fn test_and_modify_multiple_entries() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"first\", 1);\n        map.insert(\"second\", 2);\n\n        map.entry(\"first\")\n            .and_modify(|e| *e += 1);\n        map.entry(\"second\")\n            .and_modify(|e| *e += 2);\n\n        assert_eq!(map[\"first\"], 2);\n        assert_eq!(map[\"second\"], 4);\n    }\n}\n```", "map::Entry::<'a, K, V, S, A>::and_replace_entry_with": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_and_replace_entry_with_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        let entry = map\n            .entry(\"poneyland\")\n            .and_replace_entry_with(|_k, _v| panic!());\n\n        match entry {\n            Entry::Vacant(e) => {\n                assert_eq!(e.key(), &\"poneyland\");\n            }\n            Entry::Occupied(_) => panic!(),\n        }\n    }\n\n    #[test]\n    fn test_and_replace_entry_with_occupied_entry_replace() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 42);\n\n        let entry = map\n            .entry(\"poneyland\")\n            .and_replace_entry_with(|k, v| {\n                assert_eq!(k, &\"poneyland\");\n                assert_eq!(v, 42);\n                Some(v + 1)\n            });\n\n        match entry {\n            Entry::Occupied(e) => {\n                assert_eq!(e.key(), &\"poneyland\");\n                assert_eq!(e.get(), &43);\n            }\n            Entry::Vacant(_) => panic!(),\n        }\n\n        assert_eq!(map[\"poneyland\"], 43);\n    }\n\n    #[test]\n    fn test_and_replace_entry_with_occupied_entry_remove() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 42);\n\n        let entry = map\n            .entry(\"poneyland\")\n            .and_replace_entry_with(|_k, _v| None);\n\n        match entry {\n            Entry::Vacant(e) => assert_eq!(e.key(), &\"poneyland\"),\n            Entry::Occupied(_) => panic!(),\n        }\n\n        assert!(!map.contains_key(\"poneyland\"));\n    }\n}\n```", "map::Entry::<'a, K, V, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_insert_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"key1\", 10);\n        let entry = map.entry(\"key1\");\n        let occupied_entry = entry.insert(20);\n        assert_eq!(occupied_entry.key(), &\"key1\");\n        assert_eq!(map[\"key1\"], 20);\n    }\n\n    #[test]\n    fn test_insert_new_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry = map.entry(\"key2\");\n        let occupied_entry = entry.insert(30);\n        assert_eq!(occupied_entry.key(), &\"key2\");\n        assert_eq!(map[\"key2\"], 30);\n    }\n\n    #[test]\n    fn test_insert_with_multiple_keys() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"key3\", 40);\n        map.insert(\"key4\", 50);\n\n        let entry1 = map.entry(\"key3\");\n        let occupied_entry1 = entry1.insert(60);\n        assert_eq!(occupied_entry1.key(), &\"key3\");\n        assert_eq!(map[\"key3\"], 60);\n\n        let entry2 = map.entry(\"key4\");\n        let occupied_entry2 = entry2.insert(70);\n        assert_eq!(occupied_entry2.key(), &\"key4\");\n        assert_eq!(map[\"key4\"], 70);\n    }\n\n    #[test]\n    fn test_insert_with_nonexistent_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry = map.entry(\"key5\");\n        let occupied_entry = entry.insert(80);\n        assert_eq!(occupied_entry.key(), &\"key5\");\n        assert_eq!(map[\"key5\"], 80);\n    }\n}\n```", "map::Entry::<'a, K, V, S, A>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_key_occupied_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 3);\n        let entry = map.entry(\"poneyland\");\n        match entry {\n            Entry::Occupied(ref occupied_entry) => {\n                assert_eq!(occupied_entry.key(), &\"poneyland\");\n            }\n            _ => panic!(\"Expected occupied entry\"),\n        }\n    }\n\n    #[test]\n    fn test_key_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry = map.entry(\"horseland\");\n        match entry {\n            Entry::Vacant(ref vacant_entry) => {\n                assert_eq!(vacant_entry.key(), &\"horseland\");\n            }\n            _ => panic!(\"Expected vacant entry\"),\n        }\n    }\n\n    #[test]\n    fn test_key_with_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"existing_key\", 42);\n        assert_eq!(map.entry(\"existing_key\").key(), &\"existing_key\");\n    }\n\n    #[test]\n    fn test_key_with_non_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert_eq!(map.entry(\"non_existing_key\").key(), &\"non_existing_key\");\n    }\n}\n```", "map::Entry::<'a, K, V, S, A>::or_default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_default_nonexistent_key() {\n        let mut map: HashMap<&str, Option<u32>> = HashMap::new();\n        let value = map.entry(\"nonexistent\").or_default();\n        assert_eq!(value, &mut None);\n        assert_eq!(map[\"nonexistent\"], None);\n    }\n\n    #[test]\n    fn test_or_default_existing_key() {\n        let mut map: HashMap<&str, Option<u32>> = HashMap::new();\n        map.insert(\"existing\", Some(42));\n        let value = map.entry(\"existing\").or_default();\n        assert_eq!(value, &mut Some(42));\n        assert_eq!(map[\"existing\"], Some(42));\n    }\n\n    #[test]\n    fn test_or_default_default_value() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        let value = map.entry(\"key\").or_default();\n        assert_eq!(value, &mut 0);\n        assert_eq!(map[\"key\"], 0);\n    }\n\n    #[test]\n    fn test_or_default_multiple_keys() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        map.entry(\"key1\").or_default();\n        map.entry(\"key2\").or_default();\n        assert_eq!(map[\"key1\"], 0);\n        assert_eq!(map[\"key2\"], 0);\n    }\n\n    #[test]\n    fn test_or_default_with_custom_type() {\n        #[derive(Default, PartialEq, Debug)]\n        struct CustomType {\n            value: u32,\n        }\n\n        let mut map: HashMap<&str, CustomType> = HashMap::new();\n        let value = map.entry(\"custom\").or_default();\n        assert_eq!(value, &mut CustomType::default());\n        assert_eq!(map[\"custom\"], CustomType { value: 0 });\n    }\n}\n```", "map::Entry::<'a, K, V, S, A>::or_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_vacant() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert_eq!(map.entry(\"new_key\").or_insert(10), &mut 10);\n        assert_eq!(map[\"new_key\"], 10);\n    }\n\n    #[test]\n    fn test_or_insert_occupied() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"existing_key\", 20);\n        assert_eq!(map.entry(\"existing_key\").or_insert(30), &mut 20);\n        assert_eq!(map[\"existing_key\"], 20);\n    }\n\n    #[test]\n    fn test_or_insert_update() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"update_key\", 5);\n        *map.entry(\"update_key\").or_insert(10) *= 2;\n        assert_eq!(map[\"update_key\"], 10);\n    }\n\n    #[test]\n    fn test_or_insert_multiple() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert_eq!(map.entry(\"a\").or_insert(1), &mut 1);\n        assert_eq!(map.entry(\"b\").or_insert(2), &mut 2);\n        assert_eq!(map.entry(\"a\").or_insert(3), &mut 1);\n        assert_eq!(map.entry(\"b\").or_insert(4), &mut 2);\n        assert_eq!(map[\"a\"], 1);\n        assert_eq!(map[\"b\"], 2);\n    }\n}\n```", "map::Entry::<'a, K, V, S, A>::or_insert_with": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assume the correct module path\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_with_nonexistent_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let value = map.entry(\"poneyland\").or_insert_with(|| 3);\n        assert_eq!(*value, 3);\n        assert_eq!(map[\"poneyland\"], 3);\n    }\n\n    #[test]\n    fn test_or_insert_with_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 3);\n        let value = map.entry(\"poneyland\").or_insert_with(|| 10);\n        *value *= 2;\n        assert_eq!(*value, 6);\n        assert_eq!(map[\"poneyland\"], 6);\n    }\n\n    #[test]\n    fn test_or_insert_with_different_value() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 3);\n        let value = map.entry(\"poneyland\").or_insert_with(|| 10);\n        assert_eq!(*value, 3);\n    }\n\n    #[test]\n    fn test_multiple_or_insert_with() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let value1 = map.entry(\"poneyland\").or_insert_with(|| 3);\n        let value2 = map.entry(\"horseland\").or_insert_with(|| 5);\n        assert_eq!(*value1, 3);\n        assert_eq!(*value2, 5);\n    }\n}\n```", "map::Entry::<'a, K, V, S, A>::or_insert_with_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_with_key_nonexistent_key() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        map.entry(\"poneyland\").or_insert_with_key(|key| key.len());\n        assert_eq!(map[\"poneyland\"], 9);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_existing_key() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        map.insert(\"poneyland\", 9);\n        *map.entry(\"poneyland\").or_insert_with_key(|key| key.len() * 10) *= 2;\n        assert_eq!(map[\"poneyland\"], 18);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_multiple_keys() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        map.entry(\"test1\").or_insert_with_key(|key| key.chars().count());\n        map.entry(\"test2\").or_insert_with_key(|key| key.chars().count());\n        assert_eq!(map[\"test1\"], 5);\n        assert_eq!(map[\"test2\"], 5);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_reference_key() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        let key = \"test_key\";\n        map.entry(key).or_insert_with_key(|k| k.chars().count());\n        assert_eq!(map[key], 8);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_key_derivation() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        map.entry(\"key1\").or_insert_with_key(|key| key.chars().count() * 2);\n        assert_eq!(map[\"key1\"], 8);\n    }\n}\n```", "map::EntryRef::<'a, 'b, K, Q, V, S, A>::and_modify": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_and_modify_on_occupied_entry() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"test\".to_string(), 1);\n\n        map.entry_ref(\"test\")\n            .and_modify(|e| *e += 1)\n            .or_insert(0);\n\n        assert_eq!(map[\"test\"], 2);\n    }\n\n    #[test]\n    fn test_and_modify_on_vacant_entry() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n\n        map.entry_ref(\"test\")\n            .and_modify(|e| *e += 1)\n            .or_insert(42);\n\n        assert_eq!(map[\"test\"], 42);\n    }\n\n    #[test]\n    fn test_and_modify_multiple_times() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"test\".to_string(), 1);\n\n        map.entry_ref(\"test\")\n            .and_modify(|e| *e += 1)\n            .or_insert(0);\n\n        map.entry_ref(\"test\")\n            .and_modify(|e| *e += 1)\n            .or_insert(0);\n\n        assert_eq!(map[\"test\"], 3);\n    }\n\n    #[test]\n    fn test_and_modify_with_different_initial_values() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"test\".to_string(), 5);\n\n        map.entry_ref(\"test\")\n            .and_modify(|e| *e += 10)\n            .or_insert(1);\n\n        assert_eq!(map[\"test\"], 15);\n    }\n\n    #[test]\n    fn test_and_modify_without_insert() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"test\".to_string(), 3);\n\n        let entry_ref = map.entry_ref(\"test\")\n            .and_modify(|e| *e += 2);\n\n        assert!(matches!(entry_ref, EntryRef::Occupied(_)));\n        assert_eq!(map[\"test\"], 5);\n    }\n}\n```", "map::EntryRef::<'a, 'b, K, Q, V, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_insert_occupied_entry() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"test\".to_string(), 10);\n        let entry_ref = map.entry_ref(\"test\");\n        let entry = entry_ref.insert(20);\n        assert_eq!(entry.key(), \"test\");\n        assert_eq!(*entry.get_mut(), 20);\n    }\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let entry_ref = map.entry_ref(\"new_key\");\n        let entry = entry_ref.insert(30);\n        assert_eq!(entry.key(), \"new_key\");\n        assert_eq!(*entry.get_mut(), 30);\n        assert_eq!(map.len(), 1);\n    }\n    \n    #[test]\n    fn test_insert_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"key\".to_string(), 1);\n        let entry_ref = map.entry_ref(\"key\");\n        let entry = entry_ref.insert(5);\n        assert_eq!(entry.key(), \"key\");\n        assert_eq!(map[\"key\"], 5);\n    }\n    \n    #[test]\n    fn test_insert_non_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let entry_ref = map.entry_ref(\"new_key\");\n        let entry = entry_ref.insert(42);\n        assert_eq!(entry.key(), \"new_key\");\n        assert_eq!(map[\"new_key\"], 42);\n    }\n}\n```", "map::EntryRef::<'a, 'b, K, Q, V, S, A>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_map::{EntryRef, HashMap};\n\n    #[test]\n    fn test_key_existing() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref(\"poneyland\").or_insert(3);\n        assert_eq!(map.entry_ref(\"poneyland\").key(), \"poneyland\");\n    }\n\n    #[test]\n    fn test_key_nonexistent() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        assert_eq!(map.entry_ref(\"horseland\").key(), \"horseland\");\n    }\n\n    #[test]\n    fn test_key_insert() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let default_value = 3;\n        map.entry_ref(\"poneyland\").or_insert(default_value);\n        assert_eq!(map.entry_ref(\"poneyland\").key(), \"poneyland\");\n        assert_eq!(map[\"poneyland\"], default_value);\n    }\n\n    #[test]\n    fn test_key_insert_another() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref(\"horseland\").or_insert(5);\n        assert_eq!(map.entry_ref(\"horseland\").key(), \"horseland\");\n        assert_eq!(map[\"horseland\"], 5);\n    }\n\n    #[test]\n    fn test_key_multiple_insertions() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref(\"poneyland\").or_insert(3);\n        map.entry_ref(\"horseland\").or_insert(5);\n        assert_eq!(map.entry_ref(\"poneyland\").key(), \"poneyland\");\n        assert_eq!(map.entry_ref(\"horseland\").key(), \"horseland\");\n        assert_eq!(map[\"poneyland\"], 3);\n        assert_eq!(map[\"horseland\"], 5);\n    }\n}\n```", "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_default_inserts_default_value() {\n        let mut map: HashMap<String, Option<u32>> = HashMap::new();\n\n        // Testing or_default for nonexistent key\n        let entry = map.entry_ref(\"poneyland\");\n        *entry.or_default() = Some(3);\n        assert_eq!(map[\"poneyland\"], Some(3));\n    }\n\n    #[test]\n    fn test_or_default_returns_existing_value() {\n        let mut map: HashMap<String, Option<u32>> = HashMap::new();\n        map.insert(\"horseland\".to_string(), Some(3));\n\n        // Testing or_default for existing key\n        let entry = map.entry_ref(\"horseland\");\n        assert_eq!(entry.or_default(), &mut Some(3));\n    }\n\n    #[test]\n    fn test_or_default_leaves_existing_value_untouched() {\n        let mut map: HashMap<String, Option<u32>> = HashMap::new();\n        map.insert(\"poneyland\".to_string(), Some(5));\n\n        // Testing or_default without mutation\n        let entry = map.entry_ref(\"poneyland\");\n        *entry.or_default() = Some(10);\n        assert_eq!(map[\"poneyland\"], Some(10));\n    }\n\n    #[test]\n    fn test_or_default_inserts_multiple_default_values() {\n        let mut map: HashMap<String, Option<u32>> = HashMap::new();\n\n        map.entry_ref(\"poneyland\").or_default();\n        assert_eq!(map[\"poneyland\"], None);\n\n        map.entry_ref(\"poneyland\").or_default();\n        assert_eq!(map[\"poneyland\"], None);\n    }\n}\n```", "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_nonexistent_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let entry = map.entry_ref(\"poneyland\").or_insert(3);\n        assert_eq!(*entry, 3);\n        assert_eq!(map[\"poneyland\"], 3);\n    }\n\n    #[test]\n    fn test_or_insert_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"poneyland\".to_string(), 3);\n        let entry = map.entry_ref(\"poneyland\").or_insert(10);\n        assert_eq!(*entry, 3);\n        assert_eq!(map[\"poneyland\"], 3);\n    }\n\n    #[test]\n    fn test_or_insert_modify_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"poneyland\".to_string(), 3);\n        *map.entry_ref(\"poneyland\").or_insert(10) *= 2;\n        assert_eq!(map[\"poneyland\"], 6);\n    }\n\n    #[test]\n    fn test_or_insert_with_nonexistent_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let entry = map.entry_ref(\"horseland\").or_insert(5);\n        assert_eq!(*entry, 5);\n        assert_eq!(map[\"horseland\"], 5);\n    }\n\n    #[test]\n    fn test_or_insert_with_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"horseland\".to_string(), 5);\n        let entry = map.entry_ref(\"horseland\").or_insert(10);\n        assert_eq!(*entry, 5);\n        assert_eq!(map[\"horseland\"], 5);\n    }\n}\n```", "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert_with": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_with_nonexistent_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref(\"nonexistent\").or_insert_with(|| 42);\n        assert_eq!(map[\"nonexistent\"], 42);\n    }\n\n    #[test]\n    fn test_or_insert_with_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"existing\".to_string(), 10);\n        *map.entry_ref(\"existing\").or_insert_with(|| 20) += 10;\n        assert_eq!(map[\"existing\"], 20);\n    }\n\n    #[test]\n    fn test_or_insert_with_multiple_entries() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref(\"key1\").or_insert_with(|| 1);\n        map.entry_ref(\"key2\").or_insert_with(|| 2);\n        map.entry_ref(\"key3\").or_insert_with(|| 3);\n        assert_eq!(map[\"key1\"], 1);\n        assert_eq!(map[\"key2\"], 2);\n        assert_eq!(map[\"key3\"], 3);\n    }\n\n    #[test]\n    fn test_or_insert_with_function_execution() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let mut calls = 0;\n        {\n            map.entry_ref(\"key\").or_insert_with(|| {\n                calls += 1;\n                5\n            });\n        }\n        assert_eq!(map[\"key\"], 5);\n        assert_eq!(calls, 1);\n    }\n\n    #[test]\n    fn test_or_insert_with_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref(\"key\").or_insert_with_key(|key| key.len() as u32);\n        assert_eq!(map[\"key\"], 3);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_existing() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"key\".to_string(), 10);\n        *map.entry_ref(\"key\").or_insert_with_key(|key| key.len() as u32) += 5;\n        assert_eq!(map[\"key\"], 15);\n    }\n}\n```", "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert_with_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_with_key_nonexistent_key() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        map.entry_ref(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n        assert_eq!(map[\"poneyland\"], 9);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_existing_key() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        map.entry_ref(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n        assert_eq!(map[\"poneyland\"], 9);\n        *map.entry_ref(\"poneyland\").or_insert_with_key(|key| key.chars().count() * 10) *= 2;\n        assert_eq!(map[\"poneyland\"], 18);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_multiple_entries() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        let keys = vec![\"poneyland\", \"horseland\", \"catland\"];\n        for key in keys {\n            map.entry_ref(key).or_insert_with_key(|k| k.len());\n        }\n        assert_eq!(map[\"poneyland\"], 9);\n        assert_eq!(map[\"horseland\"], 9);\n        assert_eq!(map[\"catland\"], 8);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::allocation_size": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_allocation_size() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        assert_eq!(map.allocation_size(), 0);\n\n        map.insert(1, 100);\n        assert!(map.allocation_size() > 0);\n\n        map.insert(2, 200);\n        assert!(map.allocation_size() >= 2 * std::mem::size_of::<(i32, i32)>());\n\n        for i in 3..100 {\n            map.insert(i, i * 10);\n        }\n        assert!(map.allocation_size() >= 100 * std::mem::size_of::<(i32, i32)>());\n\n        map.clear();\n        assert_eq!(map.allocation_size(), 0);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::allocator": "```rust\nuse hashbrown::HashMap;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_allocator() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        let allocator = map.allocator();\n        assert!(allocator.is_some()); // Check allocator reference is valid\n    }\n}\n```", "map::HashMap::<K, V, S, A>::build_hashes_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_build_hashes_inner() {\n        let mut map: HashMap<&str, i32, RandomState> = HashMap::new();\n        map.insert(\"one\", 1);\n        map.insert(\"two\", 2);\n        map.insert(\"three\", 3);\n        \n        let keys = [\"one\", \"two\", \"three\"];\n        let hashes: [u64; 3] = map.build_hashes_inner(&keys);\n        \n        assert_eq!(hashes.len(), 3);\n        assert!(hashes.iter().all(|&hash| hash != 0));\n    }\n\n    #[test]\n    fn test_build_hashes_inner_empty() {\n        let map: HashMap<&str, i32, RandomState> = HashMap::new();\n        let keys = [\"nonexistent\"];\n        let hashes: [u64; 1] = map.build_hashes_inner(&keys);\n        \n        assert_eq!(hashes.len(), 1);\n        assert!(hashes.iter().all(|&hash| hash != 0));\n    }\n\n    #[test]\n    fn test_build_hashes_inner_with_different_keys() {\n        let mut map: HashMap<&str, i32, RandomState> = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        \n        let keys = [\"key1\", \"key2\", \"nonexistent\"];\n        let hashes: [u64; 3] = map.build_hashes_inner(&keys);\n        \n        assert_eq!(hashes.len(), 3);\n        assert!(hashes[0] != hashes[1]);\n        assert!(hashes[2] != 0);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_capacity_with_initial_capacity() {\n        let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        assert_eq!(map.len(), 0);\n        assert!(map.capacity() >= 100);\n    }\n\n    #[test]\n    fn test_capacity_after_insertion() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(10);\n        map.insert(1, 1);\n        map.insert(2, 2);\n        assert!(map.capacity() >= 10);\n        assert_eq!(map.capacity(), map.len() + 1); // Should be at least the number of elements + 1\n    }\n\n    #[test]\n    fn test_capacity_after_multiple_insertions() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(2);\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.insert(3, 3); // This should trigger a reallocation\n        assert!(map.capacity() >= 3);\n    }\n\n    #[test]\n    fn test_capacity_no_insertions() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_after_clear() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.clear();\n        assert!(map.capacity() >= 100); // Capacity should remain the same after clear\n    }\n\n    #[test]\n    fn test_capacity_shrink_to_fit() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.shrink_to_fit(); // This should lower the capacity to be close to the current usage\n        assert!(map.capacity() >= map.len());\n    }\n\n    #[test]\n    fn test_capacity_with_allocating() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(1);\n        for i in 1..100 {\n            map.insert(i, i);\n            // Capacity should grow as we insert more elements\n            assert!(map.capacity() >= i);\n        }\n    }\n}\n```", "map::HashMap::<K, V, S, A>::clear": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_clear() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        let capacity_before_clear = map.capacity();\n\n        map.clear();\n\n        assert!(map.is_empty());\n        assert_eq!(map.capacity(), capacity_before_clear);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_clear_empty_map() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        let capacity_before_clear = map.capacity();\n\n        map.clear();\n\n        assert!(map.is_empty());\n        assert_eq!(map.capacity(), capacity_before_clear);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_clear_with_capacity() {\n        let mut map: HashMap<i32, &str> = HashMap::with_capacity(5);\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let capacity_before_clear = map.capacity();\n        map.clear();\n\n        assert!(map.is_empty());\n        assert_eq!(map.capacity(), capacity_before_clear);\n        assert_eq!(map.len(), 0);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::contains_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_contains_key() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        \n        assert!(map.contains_key(&1));\n        assert!(map.contains_key(&2));\n        assert!(!map.contains_key(&3));\n    }\n\n    #[test]\n    fn test_contains_key_with_different_types() {\n        let mut map = HashMap::new();\n        map.insert(String::from(\"key1\"), \"value1\");\n        map.insert(String::from(\"key2\"), \"value2\");\n\n        assert!(map.contains_key(&String::from(\"key1\")));\n        assert!(!map.contains_key(&String::from(\"key3\")));\n        assert!(map.contains_key(\"key2\".as_ref()));\n    }\n\n    #[test]\n    fn test_contains_key_empty_map() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        \n        assert!(!map.contains_key(&1));\n        assert!(!map.contains_key(&0));\n    }\n\n    #[test]\n    fn test_contains_key_after_removal() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.remove(&1);\n\n        assert!(!map.contains_key(&1));\n        assert!(map.contains_key(&2));\n    }\n\n    #[test]\n    fn test_contains_key_for_non_hash_types() {\n        #[derive(Debug, PartialEq, Eq, Hash)]\n        struct NonHashType {\n            id: i32,\n        }\n\n        let mut map = HashMap::new();\n        map.insert(NonHashType { id: 1 }, \"value1\");\n\n        assert!(map.contains_key(&NonHashType { id: 1 }));\n        assert!(!map.contains_key(&NonHashType { id: 2 }));\n    }\n}\n```", "map::HashMap::<K, V, S, A>::drain": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn drain_empty_map() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        let drained: Vec<(i32, &str)> = map.drain().collect();\n        assert!(drained.is_empty());\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn drain_non_empty_map() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let drained: Vec<(i32, &str)> = map.drain().collect();\n        \n        assert_eq!(drained.len(), 2);\n        assert!(map.is_empty());\n\n        let keys: Vec<i32> = drained.iter().map(|&(k, _)| k).collect();\n        assert!(keys.contains(&1) || keys.contains(&2));\n        assert!(drained.iter().any(|&(_, v)| v == \"a\") || drained.iter().any(|&(_, v)| v == \"b\");\n    }\n\n    #[test]\n    fn drain_with_partial_consumption() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        let mut drained = map.drain();\n        let first = drained.next().unwrap();\n\n        assert!(map.len() == 1);\n        assert!(drained.count() == 1);\n        assert!(map.is_empty());\n\n        let keys = vec![first.0];\n        assert!(keys.contains(&1) || keys.contains(&2));\n    }\n\n    #[test]\n    fn drain_iterator_dropped() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        {\n            let _drained = map.drain();\n        }\n\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn drain_retains_capacity() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        let capacity_before_drain = map.capacity();\n\n        map.drain().count(); // Fully consume the drain iterator\n\n        assert_eq!(map.capacity(), capacity_before_drain);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::entry": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_entry_insert() {\n        let mut map = HashMap::new();\n        let entry = map.entry(\"key1\");\n        let value = entry.or_insert(10);\n        *value += 5;\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map[\"key1\"], 15);\n    }\n\n    #[test]\n    fn test_entry_or_insert() {\n        let mut map = HashMap::new();\n        let entry = map.entry(\"key2\");\n        assert_eq!(entry.or_insert(20), &mut 20);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map[\"key2\"], 20);\n    }\n\n    #[test]\n    fn test_entry_or_insert_with() {\n        let mut map = HashMap::new();\n        let entry = map.entry(\"key3\");\n        assert_eq!(entry.or_insert_with(|| 30), &mut 30);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map[\"key3\"], 30);\n    }\n\n    #[test]\n    fn test_entry_or_insert_with_key() {\n        let mut map = HashMap::new();\n        let entry = map.entry(\"key4\");\n        assert_eq!(entry.or_insert_with_key(|key| key.len() as i32), &mut 4);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map[\"key4\"], 4);\n    }\n\n    #[test]\n    fn test_entry_and_modify() {\n        let mut map = HashMap::new();\n        map.insert(\"key5\", 100);\n        let entry = map.entry(\"key5\");\n        entry.and_modify(|value| *value += 50);\n        \n        assert_eq!(map[\"key5\"], 150);\n    }\n\n    #[test]\n    fn test_entry_vacant() {\n        let mut map = HashMap::new();\n        let entry = map.entry(\"key6\");\n        assert!(matches!(entry, hashbrown::hash_map::Entry::Vacant(_)));\n        entry.or_insert(60);\n        \n        assert_eq!(map[\"key6\"], 60);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_entry_occupied() {\n        let mut map = HashMap::new();\n        map.insert(\"key7\", 70);\n        let entry = map.entry(\"key7\");\n        \n        assert!(matches!(entry, hashbrown::hash_map::Entry::Occupied(_)));\n        assert_eq!(entry.or_insert(70), &mut 70);\n        assert_eq!(map[\"key7\"], 70);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::entry_ref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_entry_ref_vacant() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n\n        let entry = map.entry_ref(\"test\").or_insert(0);\n        assert_eq!(*entry, 0);\n        assert_eq!(map[\"test\"], 0);\n    }\n\n    #[test]\n    fn test_entry_ref_occupied() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        map.insert(\"test\".to_string(), 5);\n\n        let entry = map.entry_ref(\"test\").or_insert(0);\n        assert_eq!(*entry, 5);\n        assert_eq!(map[\"test\"], 5);\n    }\n\n    #[test]\n    fn test_entry_ref_insert() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        \n        map.entry_ref(\"test\").insert(10);\n        assert_eq!(map[\"test\"], 10);\n        \n        map.entry_ref(\"test\").insert(20);\n        assert_eq!(map[\"test\"], 20);\n    }\n\n    #[test]\n    fn test_entry_ref_or_insert() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        let entry = map.entry_ref(\"test\").or_insert(5);\n        assert_eq!(*entry, 5);\n        assert_eq!(map[\"test\"], 5);\n        \n        let entry = map.entry_ref(\"test\").or_insert(10);\n        assert_eq!(*entry, 5);\n        assert_eq!(map[\"test\"], 5);\n    }\n\n    #[test]\n    fn test_entry_ref_or_insert_with() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        \n        let entry = map.entry_ref(\"test\").or_insert_with(|| 10);\n        assert_eq!(*entry, 10);\n        assert_eq!(map[\"test\"], 10);\n        \n        let entry = map.entry_ref(\"test\").or_insert_with(|| 20);\n        assert_eq!(*entry, 10);\n        assert_eq!(map[\"test\"], 10);\n    }\n\n    #[test]\n    fn test_entry_ref_and_modify() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        map.insert(\"test\".to_string(), 5);\n        \n        map.entry_ref(\"test\").and_modify(|e| *e += 5);\n        assert_eq!(map[\"test\"], 10);\n    }\n\n    #[test]\n    fn test_entry_ref_and_modify_vacant() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        \n        map.entry_ref(\"test\").and_modify(|e| *e += 5).or_insert(0);\n        assert_eq!(map[\"test\"], 0); // initial value\n    }\n}\n```", "map::HashMap::<K, V, S, A>::extract_if": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_extract_if() {\n        let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n\n        let drained: HashMap<i32, i32> = map.extract_if(|k, _v| k % 2 == 0).collect();\n\n        let mut evens = drained.keys().cloned().collect::<Vec<_>>();\n        let mut odds = map.keys().cloned().collect::<Vec<_>>();\n        evens.sort();\n        odds.sort();\n\n        assert_eq!(evens, vec![0, 2, 4, 6]);\n        assert_eq!(odds, vec![1, 3, 5, 7]);\n\n        let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n\n        {   \n            let d = map.extract_if(|k, _v| k % 2 != 0);\n        }\n\n        assert_eq!(map.len(), 8);\n    }\n\n    #[test]\n    fn test_extract_if_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        let drained: HashMap<i32, i32> = map.extract_if(|_k, _v| true).collect();\n        assert!(drained.is_empty());\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_extract_if_partial() {\n        let mut map: HashMap<i32, i32> = (0..5).map(|x| (x, x)).collect();\n        let mut drained_iter = map.extract_if(|k, _v| k % 2 == 0);\n        \n        assert_eq!(drained_iter.next(), Some((0, 0)));\n        assert_eq!(drained_iter.next(), Some((2, 2)));\n\n        // Remaining map\n        let mut remaining_keys = map.keys().cloned().collect::<Vec<_>>();\n        remaining_keys.sort();\n        assert_eq!(remaining_keys, vec![1, 3, 4]);\n        \n        assert!(drained_iter.next().is_none());\n    }\n}\n```", "map::HashMap::<K, V, S, A>::find_or_find_insert_slot": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_find_or_find_insert_slot_existing_key() {\n        let mut map = HashMap::new();\n        map.insert(\"key1\", \"value1\");\n        let hash = map.hasher().build_hasher().finish();\n        let result = map.find_or_find_insert_slot(hash, &\"key1\");\n        assert!(result.is_ok());\n    }\n    \n    #[test]\n    fn test_find_or_find_insert_slot_insert_new_key() {\n        let mut map = HashMap::new();\n        let hash = map.hasher().build_hasher().finish();\n        let result = map.find_or_find_insert_slot(hash, &\"new_key\");\n        assert!(result.is_err());\n        \n        map.insert(\"new_key\", \"new_value\");\n        let result_after_insert = map.find_or_find_insert_slot(hash, &\"new_key\");\n        assert!(result_after_insert.is_ok());\n    }\n    \n    #[test]\n    fn test_find_or_find_insert_slot_collision() {\n        let mut map = HashMap::new();\n        map.insert(\"key1\", \"value1\");\n        map.insert(\"key2\", \"value2\");\n        \n        let hash = map.hasher().build_hasher().finish();\n        let bucket = map.find_or_find_insert_slot(hash, &\"key1\");\n        assert!(bucket.is_ok());\n        \n        let collision_hash = map.hasher().build_hasher().finish();\n        let bucket_collision = map.find_or_find_insert_slot(collision_hash, &\"key2\");\n        assert!(bucket_collision.is_ok());\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_existing_key() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"value1\");\n        assert_eq!(map.get(&1), Some(&\"value1\"));\n    }\n\n    #[test]\n    fn test_get_non_existing_key() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        assert_eq!(map.get(&2), None);\n    }\n\n    #[test]\n    fn test_get_after_insert_multiple() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"value1\");\n        map.insert(2, \"value2\");\n        assert_eq!(map.get(&2), Some(&\"value2\"));\n        assert_eq!(map.get(&1), Some(&\"value1\"));\n    }\n\n    #[test]\n    fn test_get_with_borrowed_key() {\n        let mut map: HashMap<String, &str> = HashMap::new();\n        map.insert(\"key\".to_string(), \"value\");\n        assert_eq!(map.get(&\"key\".to_string()), Some(&\"value\"));\n    }\n\n    #[test]\n    fn test_get_with_different_borrow() {\n        let mut map: HashMap<String, &str> = HashMap::new();\n        map.insert(\"key\".to_string(), \"value\");\n        let borrowed_key: &str = \"key\";\n        assert_eq!(map.get(&borrowed_key), Some(&\"value\"));\n    }\n\n    #[test]\n    fn test_get_with_different_key_type() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"value1\");\n        let borrowed_key: &i32 = &1;\n        assert_eq!(map.get(borrowed_key), Some(&\"value1\"));\n        assert_eq!(map.get(&2), None);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[derive(Debug, PartialEq, Eq, Hash)]\n    struct Key(String);\n\n    #[test]\n    fn test_get_inner_existing_key() {\n        let mut map: HashMap<Key, i32> = HashMap::new();\n        map.insert(Key(\"test\".to_string()), 42);\n        \n        let result = map.get_inner(&Key(\"test\".to_string()));\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), &(Key(\"test\".to_string()), 42));\n    }\n\n    #[test]\n    fn test_get_inner_non_existing_key() {\n        let map: HashMap<Key, i32> = HashMap::new();\n        \n        let result = map.get_inner(&Key(\"non_existing\".to_string()));\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_inner_empty_map() {\n        let map: HashMap<Key, i32> = HashMap::new();\n        \n        let result = map.get_inner(&Key(\"empty\".to_string()));\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_inner_different_key_type() {\n        let mut map: HashMap<Key, i32> = HashMap::new();\n        map.insert(Key(\"test\".to_string()), 42);\n        \n        let result = map.get_inner(&Key(\"test\".to_string()));\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), &(Key(\"test\".to_string()), 42));\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_inner_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[derive(Hash, Eq, PartialEq, Debug)]\n    struct Key {\n        id: usize,\n    }\n\n    #[test]\n    fn test_get_inner_mut_existing_key() {\n        let mut map: HashMap<Key, usize> = HashMap::new();\n        let key = Key { id: 1 };\n        map.insert(key.clone(), 42);\n        \n        if let Some((k, v)) = map.get_inner_mut(&key) {\n            assert_eq!(k, &key);\n            assert_eq!(*v, 42);\n            *v = 50;\n        }\n\n        assert_eq!(map.get(&key), Some(&50));\n    }\n\n    #[test]\n    fn test_get_inner_mut_non_existing_key() {\n        let mut map: HashMap<Key, usize> = HashMap::new();\n        let key = Key { id: 1 };\n\n        assert_eq!(map.get_inner_mut(&key), None);\n    }\n\n    #[test]\n    fn test_get_inner_mut_empty_map() {\n        let mut map: HashMap<Key, usize> = HashMap::new();\n        \n        assert_eq!(map.get_inner_mut(&Key { id: 1 }), None);\n    }\n\n    #[test]\n    fn test_get_inner_mut_multiple_keys() {\n        let mut map: HashMap<Key, usize> = HashMap::new();\n        let key1 = Key { id: 1 };\n        let key2 = Key { id: 2 };\n        map.insert(key1.clone(), 10);\n        map.insert(key2.clone(), 20);\n        \n        if let Some((k, v)) = map.get_inner_mut(&key1) {\n            assert_eq!(k, &key1);\n            assert_eq!(*v, 10);\n            *v = 15;\n        }\n\n        if let Some((k, v)) = map.get_inner_mut(&key2) {\n            assert_eq!(k, &key2);\n            assert_eq!(*v, 20);\n            *v = 25;\n        }\n\n        assert_eq!(map.get(&key1), Some(&15));\n        assert_eq!(map.get(&key2), Some(&25));\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_key_value": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_key_value() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n        assert_eq!(map.get_key_value(&2), Some((&2, &\"b\")));\n        assert_eq!(map.get_key_value(&3), None);\n    }\n\n    #[test]\n    fn test_get_key_value_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        assert_eq!(map.get_key_value(&1), None);\n    }\n\n    #[test]\n    fn test_get_key_value_with_different_borrowed_type() {\n        let mut map = HashMap::new();\n        map.insert(String::from(\"key1\"), \"value1\");\n        \n        let borrowed_key: &str = \"key1\";\n        assert_eq!(map.get_key_value(&borrowed_key), Some((&String::from(\"key1\"), &\"value1\")));\n    }\n\n    #[test]\n    fn test_get_key_value_non_existent_key() {\n        let mut map = HashMap::new();\n        map.insert(10, \"test\");\n        \n        assert_eq!(map.get_key_value(&20), None);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_key_value_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_key_value_mut_existing_key() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        \n        let (k, v) = map.get_key_value_mut(&1).unwrap();\n        assert_eq!(k, &1);\n        assert_eq!(v, &mut \"a\");\n        *v = \"b\";\n        assert_eq!(map.get_key_value_mut(&1).unwrap(), (&1, &mut \"b\"));\n    }\n\n    #[test]\n    fn test_get_key_value_mut_nonexistent_key() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n\n        let result = map.get_key_value_mut(&2);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_key_value_mut_multiple_entries() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n\n        {\n            let (k, v) = map.get_key_value_mut(&1).unwrap();\n            assert_eq!(k, &1);\n            assert_eq!(v, &mut \"a\");\n            *v = \"c\";\n        }\n\n        assert_eq!(map.get_key_value_mut(&1).unwrap(), (&1, &mut \"c\"));\n        assert_eq!(map.get_key_value_mut(&2).unwrap(), (&2, &mut \"b\"));\n    }\n\n    #[test]\n    fn test_get_key_value_mut_with_different_key_type() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n\n        let (k, v) = map.get_key_value_mut(&1).unwrap();\n        assert_eq!(k, &1);\n        assert_eq!(v, &mut \"a\");\n    }\n\n    #[test]\n    fn test_get_key_value_mut_with_mutable_references() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        \n        let (k, v) = map.get_key_value_mut(&1).unwrap();\n        assert_eq!(k, &1);\n        *v = \"changed\";\n        \n        assert_eq!(map.get_key_value_mut(&1).unwrap(), (&1, &mut \"changed\"));\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_many_key_value_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_key_value_mut_existing_keys() {\n        let mut libraries = HashMap::new();\n        libraries.insert(\"Bodleian Library\".to_string(), 1602);\n        libraries.insert(\"Athen\u00e6um\".to_string(), 1807);\n        libraries.insert(\"Herzogin-Anna-Amalia-Bibliothek\".to_string(), 1691);\n        \n        let got = libraries.get_many_key_value_mut([\n            \"Bodleian Library\",\n            \"Herzogin-Anna-Amalia-Bibliothek\",\n        ]);\n\n        assert_eq!(\n            got,\n            [\n                Some((&\"Bodleian Library\".to_string(), &mut 1602)),\n                Some((&\"Herzogin-Anna-Amalia-Bibliothek\".to_string(), &mut 1691)),\n            ],\n        );\n    }\n\n    #[test]\n    fn test_get_many_key_value_mut_some_missing_keys() {\n        let mut libraries = HashMap::new();\n        libraries.insert(\"Bodleian Library\".to_string(), 1602);\n        \n        let got = libraries.get_many_key_value_mut([\n            \"Bodleian Library\",\n            \"Some Nonexistent Library\",\n        ]);\n\n        assert_eq!(got, [Some((&\"Bodleian Library\".to_string(), &mut 1602)), None]);\n    }\n\n    #[test]\n    #[should_panic(expected = \"index out of bounds\")]\n    fn test_get_many_key_value_mut_overlapping_keys() {\n        let mut libraries = HashMap::new();\n        libraries.insert(\"Bodleian Library\".to_string(), 1602);\n        libraries.insert(\"Herzogin-Anna-Amalia-Bibliothek\".to_string(), 1691);\n        \n        libraries.get_many_key_value_mut([\n            \"Bodleian Library\",\n            \"Herzogin-Anna-Amalia-Bibliothek\",\n            \"Herzogin-Anna-Amalia-Bibliothek\",\n        ]);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_many_key_value_unchecked_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_key_value_unchecked_mut() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        map.insert(\"d\", 4);\n\n        unsafe {\n            let keys = [\"a\", \"b\"];\n            let values = map.get_many_key_value_unchecked_mut(&keys);\n            assert_eq!(values, [\n                Some((&\"a\", &mut 1)),\n                Some((&\"b\", &mut 2)),\n            ]);\n\n            let keys_missing = [\"a\", \"e\"];\n            let values_missing = map.get_many_key_value_unchecked_mut(&keys_missing);\n            assert_eq!(values_missing, [\n                Some((&\"a\", &mut 1)),\n                None,\n            ]);\n        }\n    }\n\n    #[test]\n    fn test_get_many_key_value_unchecked_mut_with_overlapping_keys() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n\n        let keys = [\"a\", \"b\"];\n        unsafe {\n            let values = map.get_many_key_value_unchecked_mut(&keys);\n            assert_eq!(values, [\n                Some((&\"a\", &mut 1)),\n                Some((&\"b\", &mut 2)),\n            ]);\n        }\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_many_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_mut() {\n        let mut libraries = HashMap::new();\n        libraries.insert(\"Bodleian Library\".to_string(), 1602);\n        libraries.insert(\"Athen\u00e6um\".to_string(), 1807);\n        libraries.insert(\"Herzogin-Anna-Amalia-Bibliothek\".to_string(), 1691);\n        libraries.insert(\"Library of Congress\".to_string(), 1800);\n\n        let [Some(a), Some(b)] = libraries.get_many_mut([\n            \"Athen\u00e6um\",\n            \"Bodleian Library\",\n        ]) else { panic!() };\n        assert_eq!(*a, 1807);\n        assert_eq!(*b, 1602);\n\n        let got = libraries.get_many_mut([\n            \"Athen\u00e6um\",\n            \"Library of Congress\",\n        ]);\n        assert_eq!(got, [\n            Some(&mut 1807),\n            Some(&mut 1800),\n        ]);\n\n        let got = libraries.get_many_mut([\n            \"Athen\u00e6um\",\n            \"New York Public Library\",\n        ]);\n        assert_eq!(got, [\n            Some(&mut 1807),\n            None\n        ]);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_get_many_mut_panic_on_duplicate_keys() {\n        let mut libraries = HashMap::new();\n        libraries.insert(\"Athen\u00e6um\".to_string(), 1807);\n\n        let _got = libraries.get_many_mut([\n            \"Athen\u00e6um\",\n            \"Athen\u00e6um\",\n        ]);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_many_mut_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_mut_inner() {\n        let mut map = HashMap::new();\n        map.insert(\"A\", 1);\n        map.insert(\"B\", 2);\n        map.insert(\"C\", 3);\n\n        let keys = [\"A\", \"B\"];\n        let result: [Option<&mut (String, i32)>; 2] = map.get_many_mut_inner(&keys);\n\n        assert_eq!(result[0], Some(&mut (\"A\".to_string(), 1)));\n        assert_eq!(result[1], Some(&mut (\"B\".to_string(), 2)));\n    }\n\n    #[test]\n    fn test_get_many_mut_inner_missing_key() {\n        let mut map = HashMap::new();\n        map.insert(\"A\", 1);\n        map.insert(\"B\", 2);\n\n        let keys = [\"A\", \"C\"];\n        let result: [Option<&mut (String, i32)>; 2] = map.get_many_mut_inner(&keys);\n\n        assert_eq!(result[0], Some(&mut (\"A\".to_string(), 1)));\n        assert_eq!(result[1], None);\n    }\n\n    #[test]\n    fn test_get_many_mut_inner_overlap_keys() {\n        let mut map = HashMap::new();\n        map.insert(\"X\", 10);\n        map.insert(\"Y\", 20);\n\n        let keys = [\"X\", \"X\"];\n        let result: [Option<&mut (String, i32)>; 2] = map.get_many_mut_inner(&keys);\n        \n        assert_eq!(result[0], Some(&mut (\"X\".to_string(), 10)));\n        assert_eq!(result[1], None); // Should panic if mutable aliases exist\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_many_unchecked_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_unchecked_mut() {\n        let mut map = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n\n        // SAFETY: Keys do not overlap\n        let [Some(v1), Some(v2)] = unsafe {\n            map.get_many_unchecked_mut([\"key1\", \"key2\"])\n        } else { panic!() };\n\n        assert_eq!(*v1, 1);\n        assert_eq!(*v2, 2);\n\n        // SAFETY: Keys do not overlap\n        let got = unsafe { map.get_many_unchecked_mut([\"key2\", \"key3\"]) };\n        assert_eq!(got, [Some(&mut 2), Some(&mut 3)]);\n\n        // SAFETY: One key does not exist\n        let got = unsafe { map.get_many_unchecked_mut([\"key1\", \"key4\"]) };\n        assert_eq!(got, [Some(&mut 1), None]);\n    }\n\n    #[test]\n    fn test_get_many_unchecked_mut_overlap() {\n        let mut map = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n\n        // SAFETY: Adding overlapping keys should be unsafe and cause undefined behavior\n        let result = std::panic::catch_unwind(|| {\n            unsafe { map.get_many_unchecked_mut([\"key1\", \"key1\"]) };\n        });\n\n        assert!(result.is_err(), \"Expected panic due to overlapping keys\");\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_many_unchecked_mut_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_unchecked_mut_inner() {\n        let mut map = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n\n        let keys = [\"key1\", \"key2\"];\n        let results = unsafe { map.get_many_unchecked_mut_inner(&keys) };\n\n        assert_eq!(results[0], Some(&mut (\"key1\", 1)));\n        assert_eq!(results[1], Some(&mut (\"key2\", 2)));\n\n        let keys_not_in_map = [\"key3\", \"key4\"];\n        let results_not_in_map = unsafe { map.get_many_unchecked_mut_inner(&keys_not_in_map) };\n\n        assert_eq!(results_not_in_map[0], Some(&mut (\"key3\", 3)));\n        assert_eq!(results_not_in_map[1], None);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_get_many_unchecked_mut_inner_overlap() {\n        let mut map = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n\n        let keys = [\"key1\", \"key1\"]; // overlapping keys\n        let _ = unsafe { map.get_many_unchecked_mut_inner(&keys) };\n    }\n\n    #[test]\n    fn test_get_many_unchecked_mut_inner_non_existent() {\n        let mut map = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n\n        let keys = [\"key3\", \"key4\"];\n        let results = unsafe { map.get_many_unchecked_mut_inner(&keys) };\n\n        assert_eq!(results[0], None);\n        assert_eq!(results[1], None);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_mut() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        \n        // Test mutating existing key\n        if let Some(x) = map.get_mut(&1) {\n            *x = \"b\";\n        }\n        assert_eq!(map.get(&1), Some(&\"b\"));\n\n        // Test getting a key that does not exist\n        assert_eq!(map.get_mut(&2), None);\n    }\n\n    #[test]\n    fn test_get_mut_non_existent() {\n        let mut map = HashMap::new();\n        map.insert(2, \"x\");\n        \n        // Test mutating a non-existent key\n        assert_eq!(map.get_mut(&3), None);\n    }\n\n    #[test]\n    fn test_get_mut_multiple() {\n        let mut map = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        // Modify both existing keys\n        if let Some(x) = map.get_mut(&1) {\n            *x += 5; // 10 + 5 = 15\n        }\n        if let Some(x) = map.get_mut(&2) {\n            *x *= 2; // 20 * 2 = 40\n        }\n\n        assert_eq!(map.get(&1), Some(&15));\n        assert_eq!(map.get(&2), Some(&40));\n    }\n}\n```", "map::HashMap::<K, V, S, A>::hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n    use hashbrown::DefaultHashBuilder;\n\n    #[test]\n    fn test_hasher() {\n        let hasher = DefaultHashBuilder::default();\n        let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n        assert!(map.hasher().is_instance_of::<DefaultHashBuilder>());\n    }\n\n    #[test]\n    fn test_hasher_with_custom_builder() {\n        use std::collections::hash_map::RandomState;\n        let hasher = RandomState::new();\n        let map: HashMap<i32, i32, RandomState> = HashMap::with_hasher(hasher);\n        assert!(map.hasher().is_instance_of::<RandomState>());\n    }\n}\n```", "map::HashMap::<K, V, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_insert_new_key() {\n        let mut map = HashMap::new();\n        let result = map.insert(42, \"value\");\n        assert_eq!(result, None);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&42), Some(&\"value\"));\n    }\n\n    #[test]\n    fn test_insert_update_existing_key() {\n        let mut map = HashMap::new();\n        map.insert(42, \"value1\");\n        let result = map.insert(42, \"value2\");\n        assert_eq!(result, Some(\"value1\"));\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&42), Some(&\"value2\"));\n    }\n\n    #[test]\n    fn test_insert_multiple_keys() {\n        let mut map = HashMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n        assert_eq!(map.len(), 3);\n        assert_eq!(map.get(&1), Some(&\"one\"));\n        assert_eq!(map.get(&2), Some(&\"two\"));\n        assert_eq!(map.get(&3), Some(&\"three\"));\n    }\n\n    #[test]\n    fn test_insert_zero_keys() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        let result = map.insert(0, 0);\n        assert_eq!(result, None);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&0), Some(&0));\n    }\n\n    #[test]\n    fn test_insert_overwriting_different_types() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"a\", 2);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(\"a\"), Some(&2));\n    }\n\n    #[test]\n    fn test_insert_and_drop() {\n        let mut map = HashMap::new();\n        map.insert(1, \"value\");\n        drop(map);\n        // map is dropped, the test is to ensure no panic occurs\n    }\n}\n```", "map::HashMap::<K, V, S, A>::insert_unique_unchecked": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_insert_unique_unchecked() {\n        let mut map = HashMap::new();\n        let key = 1;\n        let value = \"value1\";\n\n        unsafe {\n            let (inserted_key_ref, inserted_value_ref) = map.insert_unique_unchecked(key, value);\n            assert_eq!(inserted_key_ref, &key);\n            assert_eq!(*inserted_value_ref, value);\n        }\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&key), Some(&value));\n    }\n\n    #[test]\n    fn test_insert_unique_unchecked_multiple() {\n        let mut map = HashMap::new();\n\n        let keys_values = vec![\n            (1, \"value1\"),\n            (2, \"value2\"),\n            (3, \"value3\"),\n        ];\n\n        for (key, value) in keys_values {\n            unsafe {\n                map.insert_unique_unchecked(key, value);\n            }\n        }\n\n        assert_eq!(map.len(), keys_values.len());\n\n        for (key, value) in keys_values {\n            assert_eq!(map.get(&key), Some(&value));\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_insert_unique_unchecked_duplicate_key() {\n        let mut map = HashMap::new();\n        let key = 1;\n        let value1 = \"value1\";\n        let value2 = \"value2\";\n\n        unsafe {\n            let _ = map.insert_unique_unchecked(key, value1);\n            let _ = map.insert_unique_unchecked(key, value2); // This should panic\n        }\n    }\n\n    #[test]\n    fn test_insert_unique_unchecked_no_panic() {\n        let mut map = HashMap::new();\n        let key1 = 1;\n        let value1 = \"value1\";\n\n        unsafe {\n            map.insert_unique_unchecked(key1, value1);\n        }\n\n        let key2 = 2;\n        let value2 = \"value2\";\n\n        unsafe {\n            let (inserted_key_ref, inserted_value_ref) = map.insert_unique_unchecked(key2, value2);\n            assert_eq!(inserted_key_ref, &key2);\n            assert_eq!(*inserted_value_ref, value2);\n        }\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&key1), Some(&value1));\n        assert_eq!(map.get(&key2), Some(&value2));\n    }\n}\n```", "map::HashMap::<K, V, S, A>::into_keys": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_keys() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut keys: Vec<&str> = map.into_keys().collect();\n        keys.sort_unstable();\n        assert_eq!(keys, [\"a\", \"b\", \"c\"]);\n    }\n\n    #[test]\n    fn test_into_keys_empty() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        let keys: Vec<&str> = map.into_keys().collect();\n        assert!(keys.is_empty());\n    }\n\n    #[test]\n    fn test_into_keys_combined() {\n        let mut map = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n        map.insert(\"key4\", 4);\n\n        let mut keys: Vec<&str> = map.into_keys().collect();\n        keys.sort_unstable();\n        assert_eq!(keys, [\"key1\", \"key2\", \"key3\", \"key4\"]);\n    }\n\n    #[test]\n    fn test_into_keys_with_duplicates() {\n        let mut map = HashMap::new();\n        map.insert(\"duplicate\", 1);\n        map.insert(\"duplicate\", 2); // overwrites previous value\n\n        let mut keys: Vec<&str> = map.into_keys().collect();\n        keys.sort_unstable();\n        assert_eq!(keys, [\"duplicate\"]);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::into_values": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_values() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let mut vec: Vec<i32> = map.into_values().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [1, 2, 3]);\n    }\n\n    #[test]\n    fn test_into_values_empty() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        let vec: Vec<i32> = map.into_values().collect();\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_into_values_single_element() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 42);\n\n        let mut vec: Vec<i32> = map.into_values().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [42]);\n    }\n\n    #[test]\n    fn test_into_values_multiple_same() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 1);\n        map.insert(\"c\", 1);\n\n        let mut vec: Vec<i32> = map.into_values().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [1, 1, 1]);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::is_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_is_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        assert!(map.is_empty());\n\n        let mut map = HashMap::new();\n        map.insert(1, 1);\n        assert!(!map.is_empty());\n\n        map.remove(&1);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_is_empty_with_capacity() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(10);\n        assert!(map.is_empty());\n\n        map.insert(1, 1);\n        assert!(!map.is_empty());\n\n        map.clear();\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_is_empty_after_operations() {\n        let mut map = HashMap::new();\n        assert!(map.is_empty());\n\n        map.insert(2, 2);\n        assert!(!map.is_empty());\n\n        map.insert(3, 3);\n        assert!(!map.is_empty());\n\n        map.remove(&2);\n        assert!(!map.is_empty());\n\n        map.remove(&3);\n        assert!(map.is_empty());\n    }\n}\n```", "map::HashMap::<K, V, S, A>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn iter_empty_map() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let mut vec: Vec<(i32, i32)> = Vec::new();\n\n        for (key, val) in map.iter() {\n            vec.push((*key, *val));\n        }\n\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn iter_non_empty_map() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        map.insert(3, 300);\n        let mut vec: Vec<(i32, i32)> = Vec::new();\n\n        for (key, val) in map.iter() {\n            vec.push((*key, *val));\n        }\n\n        vec.sort_unstable();\n        assert_eq!(vec, [(1, 100), (2, 200), (3, 300)]);\n    }\n\n    #[test]\n    fn iter_with_mutation() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        for (_, val) in map.iter_mut() {\n            *val += 10;\n        }\n\n        let mut vec: Vec<(&str, i32)> = Vec::new();\n        for (key, val) in map.iter() {\n            vec.push((*key, *val));\n        }\n\n        vec.sort_unstable();\n        assert_eq!(vec, [(\"a\", 11), (\"b\", 12), (\"c\", 13)]);\n    }\n\n    #[test]\n    fn iter_with_empty_map_after_mutation() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.clear();\n\n        let mut vec: Vec<(&str, i32)> = Vec::new();\n        for (key, val) in map.iter() {\n            vec.push((*key, *val));\n        }\n\n        assert!(vec.is_empty());\n    }\n}\n```", "map::HashMap::<K, V, S, A>::iter_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::HashMap;\n\n    #[test]\n    fn test_iter_mut() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        for (_, val) in map.iter_mut() {\n            *val *= 2;\n        }\n\n        assert_eq!(map.len(), 3);\n        let mut vec: Vec<(&str, i32)> = Vec::new();\n        for (key, val) in &map {\n            vec.push((*key, *val));\n        }\n\n        vec.sort_unstable();\n        assert_eq!(vec, [(\"a\", 2), (\"b\", 4), (\"c\", 6)]);\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn test_iter_mut_empty() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        {\n            let mut iter = map.iter_mut();\n            let next = iter.next();\n            assert!(next.is_none(), \"Iterator over an empty map should return None\");\n        }\n    }\n\n    #[test]\n    fn test_iter_mut_multiple_updates() {\n        let mut map = HashMap::new();\n        map.insert(\"x\", 1);\n        map.insert(\"y\", 2);\n\n        for (_, val) in map.iter_mut() {\n            *val += 10;\n        }\n\n        assert_eq!(map.get(\"x\"), Some(&11));\n        assert_eq!(map.get(\"y\"), Some(&12));\n    }\n}\n```", "map::HashMap::<K, V, S, A>::keys": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut keys: Vec<&str> = map.keys().cloned().collect();\n        keys.sort_unstable();\n        \n        assert_eq!(keys, [\"a\", \"b\", \"c\"]);\n    }\n\n    #[test]\n    fn test_keys_empty() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        let keys: Vec<&str> = map.keys().collect();\n        assert!(keys.is_empty());\n    }\n\n    #[test]\n    fn test_keys_single_entry() {\n        let mut map = HashMap::new();\n        map.insert(\"x\", 42);\n        \n        let keys: Vec<&str> = map.keys().collect();\n        \n        assert_eq!(keys.len(), 1);\n        assert_eq!(keys[0], &\"x\");\n    }\n\n    #[test]\n    fn test_keys_after_insert() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        map.insert(\"d\", 4);\n        map.insert(\"e\", 5);\n\n        let keys: Vec<&str> = map.keys().collect();\n        assert_eq!(keys.len(), 5);\n    }\n\n    #[test]\n    fn test_keys_after_remove() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        map.remove(\"b\");\n        \n        let keys: Vec<&str> = map.keys().collect();\n        assert_eq!(keys.len(), 2);\n        assert!(!keys.contains(&\"b\"));\n    }\n}\n```", "map::HashMap::<K, V, S, A>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_len() {\n        let mut map = HashMap::new();\n        assert_eq!(map.len(), 0); // Check initial length\n\n        map.insert(1, \"a\");\n        assert_eq!(map.len(), 1); // Check length after one insertion\n\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n        assert_eq!(map.len(), 3); // Check length after multiple insertions\n\n        map.remove(&2);\n        assert_eq!(map.len(), 2); // Check length after removal\n\n        map.clear();\n        assert_eq!(map.len(), 0); // Check length after clearing the map\n    }\n}\n```", "map::HashMap::<K, V, S, A>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_remove_existing_key() {\n        let mut map = HashMap::new();\n        map.insert(1, \"value1\");\n        map.insert(2, \"value2\");\n\n        assert_eq!(map.remove(&1), Some(\"value1\"));\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.remove(&1), None);\n    }\n\n    #[test]\n    fn test_remove_non_existing_key() {\n        let mut map = HashMap::new();\n        map.insert(1, \"value1\");\n\n        assert_eq!(map.remove(&2), None);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_remove_empty_map() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        assert_eq!(map.remove(&1), None);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_remove_after_insert() {\n        let mut map = HashMap::new();\n        map.insert(1, \"value\");\n        assert_eq!(map.remove(&1), Some(\"value\"));\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_remove_and_insert_same_key() {\n        let mut map = HashMap::new();\n        map.insert(1, \"old_value\");\n\n        assert_eq!(map.remove(&1), Some(\"old_value\"));\n        assert_eq!(map.len(), 0);\n\n        map.insert(1, \"new_value\");\n        assert_eq!(map.remove(&1), Some(\"new_value\"));\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_remove_key_when_equivalent() {\n        #[derive(Hash, Eq, PartialEq)]\n        struct Key {\n            id: i32,\n        }\n\n        let mut map = HashMap::new();\n        map.insert(Key { id: 1 }, \"value1\");\n\n        assert_eq!(map.remove(&Key { id: 1 }), Some(\"value1\"));\n        assert!(map.is_empty());\n    }\n}\n```", "map::HashMap::<K, V, S, A>::remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_remove_entry() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        // Test removing an existing entry\n        let removed_entry = map.remove_entry(&2);\n        assert_eq!(removed_entry, Some((2, \"b\")));\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&2).is_none());\n\n        // Test removing another existing entry\n        let removed_entry = map.remove_entry(&1);\n        assert_eq!(removed_entry, Some((1, \"a\")));\n        assert_eq!(map.len(), 1);\n        assert!(map.get(&1).is_none());\n\n        // Test removing a non-existing entry\n        let removed_entry = map.remove_entry(&4);\n        assert_eq!(removed_entry, None);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_remove_entry_empty_map() {\n        let mut map = HashMap::new();\n        let removed_entry = map.remove_entry(&1);\n        assert_eq!(removed_entry, None);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_remove_entry_repeated() {\n        let mut map = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(1, \"c\");\n\n        let removed_entry = map.remove_entry(&1);\n        assert_eq!(removed_entry, Some((1, \"c\")));\n        assert_eq!(map.len(), 1);\n        assert!(map.get(&1).is_none());\n    }\n}\n```", "map::HashMap::<K, V, S, A>::reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_reserve_empty_map() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        assert_eq!(map.capacity(), 0);\n        map.reserve(10);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_reserve_non_empty_map() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert(\"one\", 1);\n        map.insert(\"two\", 2);\n        let initial_capacity = map.capacity();\n        map.reserve(10);\n        assert!(map.capacity() >= initial_capacity);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_reserve_large_capacity() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        let result = std::panic::catch_unwind(|| {\n            map.reserve(usize::MAX);\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_reserve_multiple_times() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.reserve(5);\n        assert!(map.capacity() >= 5);\n        map.reserve(10);\n        assert!(map.capacity() >= 10);\n        \n        map.reserve(5);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_reserve_and_insert() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.reserve(3);\n        assert_eq!(map.len(), 0);\n        map.insert(\"one\", 1);\n        map.insert(\"two\", 2);\n        assert_eq!(map.len(), 2);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::retain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_retain() {\n        let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x * 10)).collect();\n        assert_eq!(map.len(), 8);\n\n        map.retain(|&k, _| k % 2 == 0);\n\n        assert_eq!(map.len(), 4);\n\n        let mut vec: Vec<(i32, i32)> = map.iter().map(|(&k, &v)| (k, v)).collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [(0, 0), (2, 20), (4, 40), (6, 60)]);\n    }\n\n    #[test]\n    fn test_retain_with_no_elements() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.retain(|&k, _| k % 2 == 0);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_retain_with_all_elements_retained() {\n        let mut map: HashMap<i32, i32> = HashMap::from([(1, 10), (2, 20), (3, 30)]);\n        map.retain(|_, _| true);\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn test_retain_with_no_elements_retained() {\n        let mut map: HashMap<i32, i32> = HashMap::from([(1, 10), (2, 20), (3, 30)]);\n        map.retain(|_, _| false);\n        assert_eq!(map.len(), 0);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::shrink_to": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_shrink_to() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        map.insert(1, 2);\n        map.insert(3, 4);\n        assert!(map.capacity() >= 100);\n\n        map.shrink_to(10);\n        assert!(map.capacity() >= 10);\n\n        map.shrink_to(0);\n        assert!(map.capacity() >= 2);\n\n        map.shrink_to(10);\n        assert!(map.capacity() >= 2);\n    }\n\n    #[test]\n    fn test_shrink_to_no_effect() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(20);\n        map.insert(1, 2);\n        map.insert(3, 4);\n        assert!(map.capacity() >= 20);\n\n        map.shrink_to(30);\n        assert!(map.capacity() >= 20);\n    }\n\n    #[test]\n    fn test_shrink_to_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        assert!(map.capacity() == 0);\n\n        map.shrink_to(10);\n        assert!(map.capacity() == 0);\n\n        map.insert(1, 2);\n        map.shrink_to(0);\n        assert!(map.capacity() >= 1);\n    }\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        map.insert(1, 2);\n        map.insert(3, 4);\n\n        assert!(map.capacity() >= 100);\n        map.shrink_to_fit();\n        assert!(map.capacity() >= 2);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::shrink_to_fit": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        map.insert(1, 1);\n        map.insert(2, 2);\n        assert!(map.capacity() >= 100);\n        map.shrink_to_fit();\n        assert!(map.capacity() >= 2);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        assert!(map.capacity() == 0);\n        map.shrink_to_fit();\n        assert!(map.capacity() == 0);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_with_elements() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(50);\n        for i in 0..100 {\n            map.insert(i, i);\n        }\n        assert!(map.capacity() > 50);\n        map.shrink_to_fit();\n        assert!(map.capacity() >= 100); // may not shrink below 100 due to internal resize policy\n    }\n\n    #[test]\n    fn test_shrink_to_fit_after_removal() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        assert!(map.capacity() >= 3);\n        map.remove(&1);\n        map.shrink_to_fit();\n        assert!(map.capacity() >= 2); // after considering the removal, it should manage size\n    }\n}\n```", "map::HashMap::<K, V, S, A>::try_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::OccupiedError;\n\n    #[test]\n    fn test_try_insert_success() {\n        let mut map = HashMap::new();\n        let value = map.try_insert(1, \"first\").unwrap();\n        assert_eq!(value, &\"first\");\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_try_insert_existing_key() {\n        let mut map = HashMap::new();\n        let _ = map.try_insert(1, \"first\").unwrap();\n\n        match map.try_insert(1, \"second\") {\n            Err(OccupiedError { entry, value }) => {\n                assert_eq!(entry.key(), &1);\n                assert_eq!(entry.get(), &\"first\");\n                assert_eq!(value, \"second\");\n            }\n            _ => panic!(\"Expected an error for existing key\"),\n        }\n    }\n\n    #[test]\n    fn test_try_insert_multiple_keys() {\n        let mut map = HashMap::new();\n        assert_eq!(map.try_insert(1, \"one\").unwrap(), &\"one\");\n        assert_eq!(map.try_insert(2, \"two\").unwrap(), &\"two\");\n        assert_eq!(map.len(), 2);\n        \n        match map.try_insert(1, \"one_new\") {\n            Err(OccupiedError { entry, value }) => {\n                assert_eq!(entry.key(), &1);\n                assert_eq!(entry.get(), &\"one\");\n                assert_eq!(value, \"one_new\");\n            }\n            _ => panic!(\"Expected an error for existing key\"),\n        }\n    }\n}\n```", "map::HashMap::<K, V, S, A>::try_reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::TryReserveError;\n\n    #[test]\n    fn test_try_reserve_success() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        assert_eq!(map.capacity(), 0);\n        map.try_reserve(10).expect(\"Failed to reserve capacity\");\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_try_reserve_capacity_overflow() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        match map.try_reserve(usize::MAX) {\n            Err(error) => match error {\n                TryReserveError::CapacityOverflow => {}\n                _ => panic!(\"Unexpected error type\"),\n            },\n            _ => panic!(\"Expected an error, but got success\"),\n        }\n    }\n\n    #[test]\n    fn test_try_reserve_alloc_error() {\n        use std::alloc::System;\n\n        let mut map: HashMap<&str, i32, std::hash::BuildHasherDefault<fnv::FnvHasher>, System> = HashMap::new();\n        let result = map.try_reserve(usize::MAX);\n        assert!(result.is_err());\n    }\n}\n```", "map::HashMap::<K, V, S, A>::values": "```rust\n#[cfg(test)]\nmod tests {\n    use super::HashMap;\n\n    #[test]\n    fn test_values() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let mut vec: Vec<i32> = Vec::new();\n        for val in map.values() {\n            vec.push(*val);\n        }\n\n        vec.sort_unstable();\n        assert_eq!(vec, [1, 2, 3]);\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn test_values_empty() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        let vec: Vec<&i32> = map.values().collect();\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_values_iterate() {\n        let mut map = HashMap::new();\n        map.insert(\"apple\", 10);\n        map.insert(\"banana\", 20);\n        map.insert(\"cherry\", 30);\n        \n        let values: Vec<i32> = map.values().cloned().collect();\n        assert!(values.contains(&10));\n        assert!(values.contains(&20));\n        assert!(values.contains(&30));\n        assert_eq!(values.len(), 3);\n    }\n\n    #[test]\n    fn test_values_arbitrary_order() {\n        let mut map = HashMap::new();\n        map.insert(\"first\", 1);\n        map.insert(\"second\", 2);\n        map.insert(\"third\", 3);\n        \n        let values: Vec<i32> = map.values().cloned().collect();\n        assert!(values.contains(&1));\n        assert!(values.contains(&2));\n        assert!(values.contains(&3));\n        assert_eq!(values.len(), 3);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::values_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_mut() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        for val in map.values_mut() {\n            *val += 10;\n        }\n\n        assert_eq!(map.len(), 3);\n        let mut vec: Vec<i32> = Vec::new();\n        for val in map.values() {\n            vec.push(*val);\n        }\n        \n        vec.sort_unstable();\n        assert_eq!(vec, [11, 12, 13]);\n        assert_eq!(map.len(), 3);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::with_capacity_and_hasher_in": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::DefaultHashBuilder;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_with_capacity_and_hasher_in() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        \n        let mut map = HashMap::with_capacity_and_hasher_in(10, hasher, &bump);\n        \n        // The map should be able to hold at least 10 elements without reallocating\n        assert_eq!(map.capacity(), 10);\n        assert!(map.is_empty());\n        \n        // Inserting some elements\n        map.insert(1, \"One\");\n        map.insert(2, \"Two\");\n        \n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&\"One\"));\n        assert_eq!(map.get(&2), Some(&\"Two\"));\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_in_zero_capacity() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        \n        let mut map = HashMap::with_capacity_and_hasher_in(0, hasher, &bump);\n        \n        // The map should not allocate when capacity is 0\n        assert_eq!(map.capacity(), 0);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_in_reallocation() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        \n        let mut map = HashMap::with_capacity_and_hasher_in(5, hasher, &bump);\n        assert!(map.capacity() >= 5);\n        \n        // Inserting 5 elements to check reallocation\n        for i in 1..=5 {\n            map.insert(i, i.to_string());\n        }\n\n        assert_eq!(map.len(), 5);\n        assert!(map.capacity() >= 5);\n        \n        // Inserting one more element to cause reallocation\n        map.insert(6, \"Six\");\n        assert_eq!(map.len(), 6);\n        assert!(map.capacity() > 5);\n    }\n}\n```", "map::HashMap::<K, V, S, A>::with_hasher_in": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::DefaultHashBuilder;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_with_hasher_in_creates_empty_map() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let map: HashMap<i32, i32, _, _> = HashMap::with_hasher_in(hasher, bump);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_with_hasher_in_does_not_allocate() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let map: HashMap<i32, i32, _, _> = HashMap::with_hasher_in(hasher, bump);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_hasher_in_allows_inserts() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let mut map: HashMap<i32, i32, _, _> = HashMap::with_hasher_in(hasher, bump);\n        \n        map.insert(1, 100);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&1), Some(&100));\n    }\n\n    #[test]\n    fn test_with_hasher_in_allows_multiple_inserts() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let mut map: HashMap<i32, i32, _, _> = HashMap::with_hasher_in(hasher, bump);\n        \n        map.insert(1, 100);\n        map.insert(2, 200);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&100));\n        assert_eq!(map.get(&2), Some(&200));\n    }\n\n    #[test]\n    fn test_with_hasher_in_inserts_do_not_allocate_until_needed() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let mut map: HashMap<i32, i32, _, _> = HashMap::with_hasher_in(hasher, bump);\n        assert_eq!(map.capacity(), 0);\n        \n        map.insert(1, 100);\n        assert!(map.capacity() > 0);\n    }\n}\n```", "map::HashMap::<K, V, S>::with_capacity_and_hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::DefaultHashBuilder;\n\n    #[test]\n    fn test_with_capacity_and_hasher() {\n        let hasher = DefaultHashBuilder::default();\n        let mut map = HashMap::with_capacity_and_hasher(10, hasher);\n        assert_eq!(map.len(), 0);\n        assert!(map.capacity() >= 10);\n\n        map.insert(1, 2);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&1), Some(&2));\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_zero_capacity() {\n        let hasher = DefaultHashBuilder::default();\n        let map = HashMap::with_capacity_and_hasher(0, hasher);\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_non_zero_capacity() {\n        let hasher = DefaultHashBuilder::default();\n        let mut map = HashMap::with_capacity_and_hasher(5, hasher);\n        assert!(map.capacity() >= 5);\n        assert!(map.is_empty());\n\n        map.insert(10, 20);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&10), Some(&20));\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_large_capacity() {\n        let hasher = DefaultHashBuilder::default();\n        let mut map = HashMap::with_capacity_and_hasher(1000, hasher);\n        assert!(map.capacity() >= 1000);\n    }\n}\n```", "map::HashMap::<K, V, S>::with_hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::DefaultHashBuilder;\n\n    #[test]\n    fn test_with_hasher_initialization() {\n        let hasher = DefaultHashBuilder::default();\n        let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_hasher_inserts() {\n        let hasher = DefaultHashBuilder::default();\n        let mut map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&10));\n        assert_eq!(map.get(&2), Some(&20));\n    }\n\n    #[test]\n    fn test_with_different_hashers() {\n        use std::collections::hash_map::RandomState;\n\n        let hasher = RandomState::new();\n        let mut map: HashMap<String, String> = HashMap::with_hasher(hasher);\n\n        map.insert(\"key\".to_string(), \"value\".to_string());\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(\"key\"), Some(&\"value\".to_string()));\n    }\n}\n```", "map::HashMap::<K, V, foldhash::fast::RandomState, A>::new_in": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_new_in_empty() {\n        let bump = Bump::new();\n        let map: HashMap<i32, i32, DefaultHashBuilder, _> = HashMap::new_in(&bump);\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_new_in_insert() {\n        let bump = Bump::new();\n        let mut map: HashMap<&str, i32, DefaultHashBuilder, _> = HashMap::new_in(&bump);\n        map.insert(\"One\", 1);\n        assert_eq!(map.len(), 1);\n        assert!(map.capacity() > 0);\n    }\n\n    #[test]\n    fn test_new_in_multiple_inserts() {\n        let bump = Bump::new();\n        let mut map: HashMap<&str, i32, DefaultHashBuilder, _> = HashMap::new_in(&bump);\n        let entries = [(\"One\", 1), (\"Two\", 2), (\"Three\", 3)];\n        \n        for (key, value) in entries.iter() {\n            map.insert(*key, *value);\n        }\n\n        assert_eq!(map.len(), 3);\n        assert!(map.capacity() > 3); // expecting some reallocation to occur\n    }\n\n    #[test]\n    fn test_new_in_capacity() {\n        let bump = Bump::new();\n        let mut map: HashMap<i32, i32, DefaultHashBuilder, _> = HashMap::new_in(&bump);\n        assert_eq!(map.capacity(), 0);\n\n        for i in 0..10 {\n            map.insert(i, i * 2);\n        }\n\n        assert_eq!(map.len(), 10);\n        assert!(map.capacity() > 10); // expecting some reallocation to occur\n    }\n}\n```", "map::HashMap::<K, V, foldhash::fast::RandomState, A>::with_capacity_in": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_with_capacity_in() {\n        let bump = Bump::new();\n        let mut map = HashMap::with_capacity_in(5, &bump);\n\n        assert_eq!(map.len(), 0);\n        let empty_map_capacity = map.capacity();\n        assert!(empty_map_capacity >= 5);\n\n        map.insert(\"One\", 1);\n        map.insert(\"Two\", 2);\n        map.insert(\"Three\", 3);\n        map.insert(\"Four\", 4);\n        map.insert(\"Five\", 5);\n\n        assert_eq!(map.len(), 5);\n        assert_eq!(map.capacity(), empty_map_capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_in_zero() {\n        let bump = Bump::new();\n        let map = HashMap::<&str, i32>::with_capacity_in(0, &bump);\n\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n}\n```", "map::HashMap::<K, V>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_new_hashmap() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n}\n```", "map::HashMap::<K, V>::with_capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_with_capacity() {\n        let mut map: HashMap<&str, i32> = HashMap::with_capacity(10);\n        assert_eq!(map.len(), 0);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let map: HashMap<&str, i32> = HashMap::with_capacity(0);\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_below_initial_capacity() {\n        let mut map: HashMap<&str, i32> = HashMap::with_capacity(5);\n        assert!(map.capacity() >= 5);\n        map.insert(\"One\", 1);\n        map.insert(\"Two\", 2);\n        assert!(map.capacity() >= 5);\n    }\n\n    #[test]\n    fn test_with_capacity_more_than_initial_insert() {\n        let mut map: HashMap<&str, i32> = HashMap::with_capacity(5);\n        assert_eq!(map.len(), 0);\n        assert!(map.capacity() >= 5);\n        \n        map.insert(\"Three\", 3);\n        map.insert(\"Four\", 4);\n        map.insert(\"Five\", 5);\n        assert_eq!(map.len(), 3);\n        assert!(map.capacity() >= 5);\n    }\n}\n```", "map::IntoIter::<K, V, A>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter() {\n        // Create a HashMap for testing\n        let map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].iter().cloned().collect();\n        let into_iter = map.into_iter();\n\n        // Get an Iter from the into_iter\n        let iter = into_iter.iter();\n\n        // Collect into a Vec to assert\n        let result: Vec<_> = iter.collect();\n        \n        // Sort values since iteration order is not guaranteed\n        let mut expected = vec![(&1, &\"a\"), (&2, &\"b\"), (&3, &\"c\")];\n        expected.sort_unstable();\n\n        // Sort the result for comparison\n        let mut result_sorted = result.into_iter().collect::<Vec<_>>();\n        result_sorted.sort_unstable();\n\n        assert_eq!(expected, result_sorted);\n    }\n\n    #[test]\n    fn test_iter_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let into_iter = map.into_iter();\n        let iter = into_iter.iter();\n        \n        let result: Vec<_> = iter.collect();\n        \n        assert!(result.is_empty());\n    }\n\n    #[test]\n    fn test_iter_fused() {\n        let map: HashMap<i32, &str> = [(1, \"a\"), (2, \"b\")].iter().cloned().collect();\n        let into_iter = map.into_iter();\n        let mut iter = into_iter.iter();\n\n        assert_eq!(iter.next(), Some((&1, &\"a\")));\n        assert_eq!(iter.next(), Some((&2, &\"b\")));\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None); // Should still return None for fused behavior\n    }\n}\n```", "map::IterMut::<'_, K, V>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let mut iter = map.iter();\n        let mut vec: Vec<_> = iter.collect();\n        vec.sort_unstable();  // Ensure the order is consistent for the test\n\n        assert_eq!(vec, vec![Some((&1, &\"a\")), Some((&2, &\"b\")), Some((&3, &\"c\"))]);\n\n        // Check that the iterator is fused\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None);\n    }\n    \n    #[test]\n    fn test_iter_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let mut iter = map.iter();\n        assert_eq!(iter.next(), None);\n    }\n}\n```", "map::OccupiedEntry::<'a, K, V, S, A>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_get_existing_key() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert(\"key1\", 10);\n        map.insert(\"key2\", 20);\n\n        assert_eq!(map.get(&\"key1\"), Some(&10));\n        assert_eq!(map.get(&\"key2\"), Some(&20));\n    }\n\n    #[test]\n    fn test_get_non_existing_key() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        assert_eq!(map.get(&\"non_existing\"), None);\n    }\n\n    #[test]\n    fn test_get_after_insertion() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert(\"key\", 42);\n        \n        assert_eq!(map.get(&\"key\"), Some(&42));\n        map.insert(\"key\", 100);\n        assert_eq!(map.get(&\"key\"), Some(&100));\n    }\n\n    #[test]\n    fn test_get_with_different_key_type() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        assert_eq!(map.get(&1), Some(&\"one\"));\n        assert_eq!(map.get(&2), Some(&\"two\"));\n        assert_eq!(map.get(&3), None);\n    }\n\n    #[test]\n    fn test_get_key_reference() {\n        let mut map: HashMap<String, i32> = HashMap::new();\n        map.insert(\"test\".to_string(), 5);\n        \n        let key = \"test\".to_string();\n        assert_eq!(map.get(&key), Some(&5));\n    }\n\n    #[test]\n    fn test_get_return_type() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert(\"a\", 1);\n\n        let value = map.get(&\"a\").unwrap();\n        assert_eq!(*value, 1);\n    }\n}\n```", "map::OccupiedEntry::<'a, K, V, S, A>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_get_mut() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 12);\n\n        assert_eq!(map[\"poneyland\"], 12);\n        if let Entry::Occupied(mut entry) = map.entry(\"poneyland\") {\n            *entry.get_mut() += 10;\n            assert_eq!(*entry.get(), 22);\n            *entry.get_mut() += 2;\n        }\n\n        assert_eq!(map[\"poneyland\"], 24);\n    }\n\n    #[test]\n    fn test_get_mut_non_existent() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 12);\n\n        if let Entry::Occupied(mut entry) = map.entry(\"poneyland\") {\n            assert_eq!(entry.get_mut(), &mut 12);\n            *entry.get_mut() += 10;\n        }\n\n        assert_eq!(map.get_mut(\"nonexistent\"), None);\n    }\n}\n```", "map::OccupiedEntry::<'a, K, V, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_insert_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 12);\n\n        if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n            assert_eq!(o.insert(15), 12);\n        }\n\n        assert_eq!(map[\"poneyland\"], 15);\n    }\n\n    #[test]\n    fn test_insert_non_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 12);\n\n        if let Entry::Vacant(o) = map.entry(\"newland\") {\n            assert_eq!(o.insert(20), 20);\n        }\n\n        assert_eq!(map[\"newland\"], 20);\n    }\n\n    #[test]\n    fn test_insert_multiple_entries() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 12);\n        map.insert(\"newland\", 20);\n\n        if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n            assert_eq!(o.insert(15), 12);\n        }\n        if let Entry::Occupied(mut o) = map.entry(\"newland\") {\n            assert_eq!(o.insert(25), 20);\n        }\n\n        assert_eq!(map[\"poneyland\"], 15);\n        assert_eq!(map[\"newland\"], 25);\n    }\n\n    #[test]\n    fn test_insert_with_different_types() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n\n        if let Entry::Occupied(mut o) = map.entry(1) {\n            assert_eq!(o.insert(\"uno\"), \"one\");\n        }\n\n        assert_eq!(map[&1], \"uno\");\n    }\n}\n```", "map::OccupiedEntry::<'a, K, V, S, A>::into_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{Entry, HashMap};\n\n    #[test]\n    fn test_into_mut() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 12);\n\n        match map.entry(\"poneyland\") {\n            Entry::Occupied(entry) => {\n                let value = entry.into_mut();\n                *value += 10;\n                assert_eq!(map[\"poneyland\"], 22);\n            }\n            Entry::Vacant(_) => panic!(\"Entry should be occupied\"),\n        }\n    }\n\n    #[test]\n    fn test_into_mut_non_existent() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        match map.entry(\"missing\") {\n            Entry::Occupied(_) => panic!(\"Entry should be vacant\"),\n            Entry::Vacant(entry) => {\n                entry.insert(10);\n                assert_eq!(map[\"missing\"], 10);\n            }\n        }\n        match map.entry(\"missing\") {\n            Entry::Occupied(entry) => {\n                let value = entry.into_mut();\n                *value += 5;\n                assert_eq!(map[\"missing\"], 15);\n            }\n            Entry::Vacant(_) => panic!(\"Entry should be occupied\"),\n        }\n    }\n}\n```", "map::OccupiedEntry::<'a, K, V, S, A>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Ensure we are in the correct scope\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 12);\n\n        match map.entry(\"poneyland\") {\n            Entry::Vacant(_) => panic!(),\n            Entry::Occupied(entry) => assert_eq!(entry.key(), &\"poneyland\"),\n        }\n    }\n}\n```", "map::OccupiedEntry::<'a, K, V, S, A>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_remove() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 12);\n\n        if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n            assert_eq!(o.remove(), 12);\n        }\n\n        assert_eq!(map.contains_key(\"poneyland\"), false);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_remove_non_existent_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"example\", 34);\n\n        {\n            let entry = map.entry(\"example\");\n            if let Entry::Occupied(o) = entry {\n                assert_eq!(o.remove(), 34);\n            }\n        }\n\n        assert!(map.contains_key(\"example\") == false);\n        assert!(map.is_empty());\n    }\n}\n```", "map::OccupiedEntry::<'a, K, V, S, A>::remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_remove_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 12);\n\n        if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n            assert_eq!(o.remove_entry(), (\"poneyland\", 12));\n        }\n\n        assert_eq!(map.contains_key(\"poneyland\"), false);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_remove_entry_empty_map() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert!(map.is_empty());\n\n        let entry_result = map.entry(\"nonexistent\");\n        assert!(matches!(entry_result, Entry::Vacant(_)));\n    }\n\n    #[test]\n    fn test_remove_entry_multiple() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"foo\", 1);\n        map.insert(\"bar\", 2);\n\n        if let Entry::Occupied(o) = map.entry(\"foo\") {\n            assert_eq!(o.remove_entry(), (\"foo\", 1));\n        }\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(\"bar\"), Some(&2));\n    }\n}\n```", "map::OccupiedEntry::<'a, K, V, S, A>::replace_entry_with": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_replace_entry_with() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        \n        map.insert(\"poneyland\", 42);\n        let entry = map.entry(\"poneyland\").or_insert(0);\n        \n        let replaced_entry = map.entry(\"poneyland\").and_modify(|v| *v = 0).or_insert(0);\n        \n        let entry = match map.entry(\"poneyland\") {\n            Entry::Occupied(e) => e.replace_entry_with(|k, v| {\n                assert_eq!(k, &\"poneyland\");\n                assert_eq!(v, 0);\n                Some(v + 1)\n            }),\n            Entry::Vacant(_) => panic!(),\n        };\n\n        match entry {\n            Entry::Occupied(e) => {\n                assert_eq!(e.key(), &\"poneyland\");\n                assert_eq!(e.get(), &1);\n            },\n            Entry::Vacant(_) => panic!(),\n        }\n\n        assert_eq!(map[\"poneyland\"], 1);\n        \n        let entry = match map.entry(\"poneyland\") {\n            Entry::Occupied(e) => e.replace_entry_with(|_k, _v| None),\n            Entry::Vacant(_) => panic!(),\n        };\n\n        match entry {\n            Entry::Vacant(e) => {\n                assert_eq!(e.key(), &\"poneyland\");\n            },\n            Entry::Occupied(_) => panic!(),\n        }\n\n        assert!(!map.contains_key(\"poneyland\"));\n    }\n}\n```", "map::VacantEntry::<'a, K, V, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let Entry::Vacant(o) = map.entry(\"test_key\") {\n            o.insert(42);\n        }\n\n        assert_eq!(map[\"test_key\"], 42);\n    }\n\n    #[test]\n    fn test_insert_vacant_entry_overwrite() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let Entry::Vacant(o) = map.entry(\"key\") {\n            o.insert(10);\n        }\n\n        if let Entry::Vacant(o) = map.entry(\"key\") {\n            o.insert(20);\n        }\n\n        assert_eq!(map[\"key\"], 10);\n    }\n\n    #[test]\n    fn test_insert_multiple_vacant_entries() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        let keys = [\"key1\", \"key2\", \"key3\"];\n        let values = [1, 2, 3];\n\n        for (key, value) in keys.iter().zip(values.iter()) {\n            if let Entry::Vacant(o) = map.entry(key) {\n                o.insert(*value);\n            }\n        }\n\n        assert_eq!(map[\"key1\"], 1);\n        assert_eq!(map[\"key2\"], 2);\n        assert_eq!(map[\"key3\"], 3);\n    }\n\n    #[test]\n    fn test_insert_with_empty_map() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let Entry::Vacant(o) = map.entry(\"new_key\") {\n            o.insert(100);\n        }\n\n        assert_eq!(map[\"new_key\"], 100);\n    }\n}\n```", "map::VacantEntry::<'a, K, V, S, A>::insert_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_insert_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let Entry::Vacant(v) = map.entry(\"test_entry\") {\n            let occupied_entry = v.insert_entry(42);\n            assert_eq!(occupied_entry.get(), &42);\n            assert_eq!(map.get(\"test_entry\"), Some(&42));\n        }\n    }\n    \n    #[test]\n    fn test_insert_entry_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"test_entry\", 42);\n\n        if let Entry::Vacant(v) = map.entry(\"test_entry\") {\n            let occupied_entry = v.insert_entry(100);\n            assert_eq!(occupied_entry.get(), &100);\n            assert_eq!(map.get(\"test_entry\"), Some(&100));\n        }\n    }\n    \n    #[test]\n    fn test_insert_entry_multiple() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let Entry::Vacant(v) = map.entry(\"entry_one\") {\n            v.insert_entry(1);\n        }\n        if let Entry::Vacant(v) = map.entry(\"entry_two\") {\n            v.insert_entry(2);\n        }\n        if let Entry::Vacant(v) = map.entry(\"entry_three\") {\n            v.insert_entry(3);\n        }\n\n        assert_eq!(map.get(\"entry_one\"), Some(&1));\n        assert_eq!(map.get(\"entry_two\"), Some(&2));\n        assert_eq!(map.get(\"entry_three\"), Some(&3));\n    }\n}\n```", "map::VacantEntry::<'a, K, V, S, A>::into_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{Entry, HashMap};\n\n    #[test]\n    fn test_into_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        match map.entry(\"test_key\") {\n            Entry::Occupied(_) => panic!(\"Entry should be vacant\"), \n            Entry::Vacant(v) => {\n                let key = v.into_key(); \n                assert_eq!(key, \"test_key\");\n            },\n        }\n    }\n\n    #[test]\n    fn test_into_key_with_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"existing_key\", 42);\n\n        match map.entry(\"existing_key\") {\n            Entry::Occupied(_) => {\n                panic!(\"Entry should be occupied, not vacant\");\n            },\n            Entry::Vacant(_) => {\n                panic!(\"Entry should not be vacant since key exists\");\n            },\n        }\n    }\n\n    #[test]\n    fn test_multiple_into_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert!(map.is_empty());\n\n        match map.entry(\"another_key\") {\n            Entry::Occupied(_) => panic!(\"Entry should be vacant\"),\n            Entry::Vacant(v) => {\n                let key = v.into_key();\n                assert_eq!(key, \"another_key\");\n            },\n        }\n\n        assert_eq!(map.len(), 1);\n        assert!(map.contains_key(\"another_key\"));\n    }\n}\n```", "map::VacantEntry::<'a, K, V, S, A>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_key_method() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        // Create a vacant entry for the key \"poneyland\"\n        let entry = map.entry(\"poneyland\").or_insert(0);\n        \n        // Assert that the key method returns a reference to the key\n        assert_eq!(entry.key(), &\"poneyland\");\n        \n        // Insert a value into the vacant entry\n        *entry += 42;\n        \n        // Verify the value has been inserted correctly\n        assert_eq!(map.get(\"poneyland\"), Some(&42));\n    }\n\n    #[test]\n    fn test_key_method_with_different_key() {\n        let mut map: HashMap<i32, u32> = HashMap::new();\n\n        // Create a vacant entry for the key 10\n        let entry = map.entry(10).or_insert(0);\n        \n        // Assert that the key method returns a reference to the key\n        assert_eq!(entry.key(), &10);\n        \n        // Insert a value into the vacant entry\n        *entry += 50;\n\n        // Verify the value has been inserted correctly\n        assert_eq!(map.get(&10), Some(&50));\n    }\n}\n```", "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::EntryRef;\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let key: &str = \"poneyland\";\n\n        if let EntryRef::Vacant(entry) = map.entry_ref(key) {\n            let value_ref = entry.insert(37);\n            assert_eq!(*value_ref, 37);\n            assert_eq!(map[key], 37);\n        } else {\n            panic!(\"Expected VacantEntryRef, but entry already exists.\");\n        }\n    }\n\n    #[test]\n    fn test_insert_overwrite_existing() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let key: &str = \"poneyland\";\n\n        map.insert(key.to_string(), 37);\n        if let EntryRef::Vacant(entry) = map.entry_ref(key) {\n            let value_ref = entry.insert(42);\n            assert_eq!(*value_ref, 42);\n            assert_eq!(map[key], 42);\n        } else {\n            panic!(\"Expected VacantEntryRef, but entry already exists.\");\n        }\n    }\n\n    #[test]\n    fn test_insert_multiple_keys() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let keys = vec![\"poneyland\", \"horseyland\", \"unicornland\"];\n\n        for key in keys {\n            if let EntryRef::Vacant(entry) = map.entry_ref(key) {\n                entry.insert(1);\n            }\n        }\n\n        assert_eq!(map[\"poneyland\"], 1);\n        assert_eq!(map[\"horseyland\"], 1);\n        assert_eq!(map[\"unicornland\"], 1);\n    }\n}\n```", "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::insert_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::EntryRef;\n\n    #[test]\n    fn test_insert_entry_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let EntryRef::Vacant(v) = map.entry_ref(\"test_entry\") {\n            let occupied_entry = v.insert_entry(10);\n            assert_eq!(occupied_entry.get(), &10);\n        } else {\n            panic!(\"Expected a VacantEntryRef\");\n        }\n    }\n\n    #[test]\n    fn test_insert_entry_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"test_entry\", 10);\n        \n        if let EntryRef::Occupied(o) = map.entry_ref(\"test_entry\") {\n            let new_entry = o.insert_entry(20);\n            assert_eq!(new_entry.get(), &20);\n            assert_eq!(map.get(\"test_entry\"), Some(&20));\n        } else {\n            panic!(\"Expected an OccupiedEntryRef\");\n        }\n    }\n\n    #[test]\n    fn test_insert_entry_multiple_keys() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let EntryRef::Vacant(v) = map.entry_ref(\"key1\") {\n            v.insert_entry(1);\n        }\n        if let EntryRef::Vacant(v) = map.entry_ref(\"key2\") {\n            v.insert_entry(2);\n        }\n\n        assert_eq!(map.get(\"key1\"), Some(&1));\n        assert_eq!(map.get(\"key2\"), Some(&2));\n    }\n\n    #[test]\n    fn test_insert_entry_capacity() {\n        let mut map: HashMap<&str, u32> = HashMap::with_capacity(10);\n        assert!(map.capacity() >= 10);\n        \n        if let EntryRef::Vacant(v) = map.entry_ref(\"key_capacity\") {\n            v.insert_entry(42);\n        }\n\n        assert_eq!(map.get(\"key_capacity\"), Some(&42));\n    }\n}\n```", "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_key_vacant_entry_ref() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let key: &str = \"poneyland\";\n        let vacant_entry = map.entry_ref(key);\n        assert_eq!(vacant_entry.key(), key);\n    }\n\n    #[test]\n    fn test_key_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key: &str = \"land\";\n        let vacant_entry = map.entry_ref(key);\n        assert_eq!(vacant_entry.key(), key);\n    }\n}\n```", "map::assert_covariance": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::map::{self, Drain, HashMap, IntoIter, Iter, Keys, Values};\n\n    #[test]\n    fn test_assert_covariance() {\n        fn test_map_key() {\n            let map: HashMap<&'static str, u8> = HashMap::new();\n            let _: HashMap<&'static str, u8> = map_key(map);\n        }\n\n        fn test_map_val() {\n            let map: HashMap<u8, &'static str> = HashMap::new();\n            let _: HashMap<u8, &'static str> = map_val(map);\n        }\n\n        fn test_iter_key() {\n            let map: HashMap<&'static str, u8> = HashMap::new();\n            let iter = map.iter();\n            let _: Iter<&'static str, u8> = iter_key(iter);\n        }\n\n        fn test_iter_val() {\n            let map: HashMap<u8, &'static str> = HashMap::new();\n            let iter = map.iter();\n            let _: Iter<u8, &'static str> = iter_val(iter);\n        }\n\n        fn test_into_iter_key() {\n            let map: HashMap<&'static str, u8> = HashMap::new();\n            let iter: IntoIter<&'static str, u8> = map.clone().into_iter();\n            let _: IntoIter<&'static str, u8> = into_iter_key(iter);\n        }\n\n        fn test_into_iter_val() {\n            let map: HashMap<u8, &'static str> = HashMap::new();\n            let iter: IntoIter<u8, &'static str> = map.clone().into_iter();\n            let _: IntoIter<u8, &'static str> = into_iter_val(iter);\n        }\n\n        fn test_keys_key() {\n            let map: HashMap<&'static str, u8> = HashMap::new();\n            let keys: Keys<&'static str, u8> = map.keys();\n            let _: Keys<&'static str, u8> = keys_key(keys);\n        }\n\n        fn test_keys_val() {\n            let map: HashMap<u8, &'static str> = HashMap::new();\n            let keys: Keys<u8, &'static str> = map.keys();\n            let _: Keys<u8, &'static str> = keys_val(keys);\n        }\n\n        fn test_values_key() {\n            let map: HashMap<&'static str, u8> = HashMap::new();\n            let values: Values<&'static str, u8> = map.values();\n            let _: Values<&'static str, u8> = values_key(values);\n        }\n\n        fn test_values_val() {\n            let map: HashMap<u8, &'static str> = HashMap::new();\n            let values: Values<u8, &'static str> = map.values();\n            let _: Values<u8, &'static str> = values_val(values);\n        }\n\n        fn test_drain() {\n            let map: HashMap<&'static str, &'static str> = HashMap::new();\n            let drain: Drain<&'static str, &'static str> = map.drain();\n            let _: Drain<&'static str, &'static str> = drain(drain);\n        }\n\n        test_map_key();\n        test_map_val();\n        test_iter_key();\n        test_iter_val();\n        test_into_iter_key();\n        test_into_iter_val();\n        test_keys_key();\n        test_keys_val();\n        test_values_key();\n        test_values_val();\n        test_drain();\n    }\n}\n```", "map::assert_covariance::drain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::{Drain, assert_covariance::drain};\n\n    #[test]\n    fn test_drain_covariance() {\n        // Create a Drain with static lifetimes\n        let static_key: &'static str = \"key\";\n        let static_value: &'static str = \"value\";\n        let drain_static: Drain<'static, &'static str, &'static str> = Drain {\n            inner: // Initialization of Drain with required parameters\n        };\n\n        // Call the drain function\n        let drain_new: Drain<'_, &'static str, &'static str> = drain(drain_static);\n\n        // Check the types of the returned drain\n        let _: Drain<'_, &'static str, &'static str> = drain_new;\n    }\n}\n```", "map::assert_covariance::into_iter_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::raw::RawIntoIter;\n    \n    #[test]\n    fn test_into_iter_key() {\n        let input: IntoIter<&'static str, u8> = IntoIter::default(); // Replace with actual input initialization as needed\n        let result: IntoIter<&str, u8> = into_iter_key(input);\n        \n        // Ensure that the output type is correct\n        assert!(std::any::type_name::<IntoIter<&str, u8>>() == std::any::type_name::<IntoIter<&str, u8>>());\n        \n        // Test any properties or methods on the result that are important\n        // Add additional assertions based on expected behavior\n    }\n}\n```", "map::assert_covariance::into_iter_val": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{map::IntoIter, Allocator, Global};\n\n    #[test]\n    fn test_into_iter_val() {\n        // Create a dummy IntoIter<u8, &'static str>\n        let data: Vec<(u8, &'static str)> = vec![(1, \"one\"), (2, \"two\"), (3, \"three\")];\n        let mut map: hashbrown::HashMap<u8, &'static str, Global> = hashbrown::HashMap::new();\n        for (k, v) in data {\n            map.insert(k, v);\n        }\n\n        let into_iter: IntoIter<u8, &'static str> = map.into_iter();\n        \n        // Call the into_iter_val function\n        let result_iter: IntoIter<u8, &'static str, Global> = map::assert_covariance::into_iter_val(into_iter);\n\n        // Collect the results into a vector\n        let result: Vec<(u8, &'static str)> = result_iter.collect();\n        \n        // The collected results should match the original data\n        assert_eq!(result.len(), data.len());\n        for (idx, (k, v)) in result.into_iter().enumerate() {\n            assert_eq!(k, data[idx].0);\n            assert_eq!(v, data[idx].1);\n        }\n    }\n}\n```", "map::assert_covariance::iter_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter_key() {\n        let map: HashMap<&'static str, u8> = HashMap::new();\n        let iter = map.iter();\n        let result: Iter<&str, u8> = iter_key(iter);\n        assert_eq!(result.len(), 0); // Check that the result has the length of 0 for an empty HashMap\n    }\n\n    #[test]\n    fn test_iter_key_non_empty() {\n        let mut map: HashMap<&'static str, u8> = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n        \n        let iter = map.iter();\n        let result: Iter<&str, u8> = iter_key(iter);\n        \n        let mut keys: Vec<&str> = result.map(|(&k, &v)| k).collect();\n        keys.sort_unstable(); // Sort the keys since hash map iteration order is not guaranteed\n\n        assert_eq!(keys, vec![\"a\", \"b\", \"c\"]); // Check that keys are as expected\n    }\n}\n```", "map::assert_covariance::iter_val": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use std::iter::Iterator;\n\n    #[test]\n    fn test_iter_val() {\n        let map: HashMap<u8, &'static str> = HashMap::new();\n        let iter = map.iter();\n        \n        let new_iter = iter_val(iter);\n        \n        // Verifying that the new iterator type corresponds correctly\n        assert!(new_iter.next().is_none());\n    }\n\n    #[test]\n    fn test_iter_val_with_items() {\n        let mut map: HashMap<u8, &'static str> = HashMap::new();\n        map.insert(1, \"a\");\n        map.insert(2, \"b\");\n        map.insert(3, \"c\");\n\n        let iter = map.iter();\n        let new_iter = iter_val(iter);\n        \n        let mut vec: Vec<_> = new_iter.collect();\n        vec.sort_unstable();\n        \n        assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n    }\n}\n```", "map::assert_covariance::keys_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_key() {\n        let map: HashMap<&'static str, u8> = [(\"a\", 1), (\"b\", 2), (\"c\", 3)].iter().cloned().collect();\n        let keys: Keys<&'static str, u8> = map.keys();\n        let new_keys: Keys<&str, u8> = keys_key(keys);\n        \n        let expected: Vec<&str> = vec![\"a\", \"b\", \"c\"];\n        let result: Vec<&str> = new_keys.collect();\n        \n        assert_eq!(expected.len(), result.len());\n        for item in expected {\n            assert!(result.contains(&item));\n        }\n    }\n}\n```", "map::assert_covariance::keys_val": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_val() {\n        let map: HashMap<u8, &'static str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].iter().cloned().collect();\n        let keys: Keys<u8, &'static str> = map.keys();\n        let new_keys: Keys<u8, &'static str> = keys_val(keys);\n\n        // Verify all keys are maintained during conversion\n        let mut keys_vec: Vec<_> = new_keys.collect();\n        keys_vec.sort_unstable();\n        assert_eq!(keys_vec, vec![&1, &2, &3]);\n    }\n}\n```", "map::assert_covariance::map_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_map_key() {\n        let mut map: HashMap<&'static str, u8> = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        map.insert(\"key3\", 3);\n\n        let new_map: HashMap<&str, u8> = map_key(map);\n\n        assert_eq!(new_map.get(\"key1\"), Some(&1));\n        assert_eq!(new_map.get(\"key2\"), Some(&2));\n        assert_eq!(new_map.get(\"key3\"), Some(&3));\n    }\n\n    #[test]\n    fn test_map_key_empty() {\n        let map: HashMap<&'static str, u8> = HashMap::new();\n        let new_map: HashMap<&str, u8> = map_key(map);\n        \n        assert!(new_map.is_empty());\n    }\n}\n```", "map::assert_covariance::map_val": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_map_val() {\n        let mut map: HashMap<u8, &'static str> = HashMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        \n        let new_map: HashMap<u8, &str> = map_val(map);\n        \n        assert_eq!(new_map.len(), 2);\n        assert_eq!(new_map[&1], \"one\");\n        assert_eq!(new_map[&2], \"two\");\n    }\n}\n```", "map::assert_covariance::values_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_key() {\n        let mut map: HashMap<&'static str, u8> = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let values = map.values();\n        let result = values_key(values);\n\n        let mut result_vec: Vec<&str> = result.collect();\n        result_vec.sort_unstable(); // sorting for comparison\n\n        assert_eq!(result_vec, vec![\"a\", \"b\", \"c\"]);\n    }\n}\n```", "map::assert_covariance::values_val": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_val() {\n        let mut map: HashMap<u8, &'static str> = HashMap::new();\n        map.insert(1, \"one\");\n        map.insert(2, \"two\");\n        map.insert(3, \"three\");\n\n        let values: Values<u8, &'static str> = map.values();\n        let new_values: Values<u8, &'static str> = values_val(values);\n\n        let mut result: Vec<&str> = new_values.collect();\n        result.sort_unstable();\n        assert_eq!(result, vec![\"one\", \"three\", \"two\"]);\n    }\n}\n```", "map::equivalent": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    struct KeyWrapper {\n        value: i32,\n    }\n\n    impl KeyWrapper {\n        fn new(value: i32) -> Self {\n            KeyWrapper { value }\n        }\n    }\n\n    struct KeyEqual {\n        value: i32,\n    }\n\n    impl KeyEqual {\n        fn new(value: i32) -> Self {\n            KeyEqual { value }\n        }\n    }\n\n    impl Equivalent<KeyWrapper> for KeyEqual {\n        fn equivalent(&self, other: &KeyWrapper) -> bool {\n            self.value == other.value\n        }\n    }\n\n    #[test]\n    fn test_equivalent() {\n        let key_equal = KeyEqual::new(42);\n        let equivalent_fn = equivalent(&key_equal);\n\n        let key_wrapper_equal = KeyWrapper::new(42);\n        let key_wrapper_unequal = KeyWrapper::new(10);\n        \n        assert!(equivalent_fn(&key_wrapper_equal));\n        assert!(!equivalent_fn(&key_wrapper_unequal));\n    }\n}\n```", "map::equivalent_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::raw::Equivalent;\n\n    struct TestKey {\n        value: String,\n    }\n\n    impl Equivalent<TestKey> for TestKey {\n        fn equivalent(&self, other: &TestKey) -> bool {\n            self.value == other.value\n        }\n    }\n\n    #[test]\n    fn test_equivalent_key() {\n        let key1 = TestKey { value: String::from(\"test\") };\n        let key2 = TestKey { value: String::from(\"test\") };\n        let key3 = TestKey { value: String::from(\"different\") };\n        \n        let equivalent_fn = equivalent_key(&key1);\n        \n        assert!(equivalent_fn(&(key2, ())));\n        assert!(!equivalent_fn(&(key3, ())));\n    }\n}\n```", "map::make_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_make_hash() {\n        let hash_builder = DefaultHasher::new();\n        let value = \"test_string\";\n\n        let hash1 = make_hash(&hash_builder, value);\n        let hash2 = make_hash(&hash_builder, value);\n\n        assert_eq!(hash1, hash2, \"Hashes should be equal for the same input\");\n    }\n\n    #[test]\n    fn test_make_hash_different_values() {\n        let hash_builder = DefaultHasher::new();\n        \n        let hash1 = make_hash(&hash_builder, \"test_string1\");\n        let hash2 = make_hash(&hash_builder, \"test_string2\");\n\n        assert_ne!(hash1, hash2, \"Hashes should be different for different inputs\");\n    }\n\n    #[test]\n    fn test_make_hash_empty_string() {\n        let hash_builder = DefaultHasher::new();\n        \n        let hash = make_hash(&hash_builder, \"\");\n\n        assert!(hash != 0, \"Hash of an empty string should not be zero\");\n    }\n\n    #[test]\n    fn test_make_hash_string_slice() {\n        let hash_builder = DefaultHasher::new();\n        let value: &str = \"slice_string\";\n\n        let hash = make_hash(&hash_builder, value);\n\n        assert!(hash != 0, \"Hash of the string slice should not be zero\");\n    }\n}\n```", "map::make_hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::{Hash, Hasher};\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::BuildHasher;\n\n    struct TestHasher;\n\n    impl BuildHasher for TestHasher {\n        type Hasher = DefaultHasher;\n\n        fn build_hasher(&self) -> Self::Hasher {\n            DefaultHasher::new()\n        }\n    }\n\n    #[test]\n    fn test_make_hasher() {\n        let hasher_builder = TestHasher;\n        let hasher = make_hasher::<String, usize, TestHasher>(&hasher_builder);\n\n        let value = (\"test\".to_string(), 42);\n        let hash_one = hasher(&value);\n        let hash_two = hasher(&value);\n        \n        assert_eq!(hash_one, hash_two);\n    }\n\n    #[test]\n    fn test_make_hasher_different_input() {\n        let hasher_builder = TestHasher;\n        let hasher = make_hasher::<String, usize, TestHasher>(&hasher_builder);\n\n        let value_one = (\"test\".to_string(), 42);\n        let value_two = (\"different\".to_string(), 100);\n        \n        let hash_one = hasher(&value_one);\n        let hash_two = hasher(&value_two);\n        \n        assert_ne!(hash_one, hash_two);\n    }\n}\n```", "raw::Bucket::<T>::as_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_as_mut() {\n        let mut value: i32 = 42;\n        let value_ptr = &mut value as *mut _;\n\n        let bucket = Bucket {\n            ptr: NonNull::new(value_ptr).unwrap(),\n        };\n\n        unsafe {\n            let mut_ref = bucket.as_mut();\n            *mut_ref = 100; // Modify the inner value\n        }\n\n        assert_eq!(value, 100);\n    }\n\n    #[test]\n    fn test_as_mut_zero_sized_type() {\n        #[derive(Debug)]\n        struct Zst;\n\n        let mut value = Zst;\n        let value_ptr = &mut value as *mut _;\n\n        let bucket = Bucket {\n            ptr: NonNull::new(value_ptr).unwrap(),\n        };\n\n        unsafe {\n            bucket.as_mut(); // Should not panic or cause an issue\n        }\n    }\n}\n```", "raw::Bucket::<T>::as_non_null": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_as_non_null() {\n        let value = 42;\n        let ptr = NonNull::new(&value as *const _ as *mut _).unwrap();\n        let bucket = Bucket { ptr };\n\n        // Testing as_non_null returns a NonNull pointer\n        let non_null_ptr = bucket.as_non_null();\n        assert!(!non_null_ptr.as_ptr().is_null());\n        assert_eq!(unsafe { *non_null_ptr.as_ptr() }, 42);\n    }\n}\n```", "raw::Bucket::<T>::as_ptr": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_as_ptr_non_zst() {\n        struct NonZST {\n            value: i32,\n        }\n\n        let value = NonZST { value: 42 };\n        let bucket = Bucket {\n            ptr: NonNull::new(&value as *const _ as *mut _).unwrap(),\n        };\n\n        // Pointer obtained should be one less than the ptr\n        let ptr = bucket.as_ptr();\n        assert_eq!(ptr, (bucket.ptr.as_ptr() as usize - 1) as *mut NonZST);\n    }\n\n    #[test]\n    fn test_as_ptr_zst() {\n        struct ZST;\n\n        let bucket = Bucket {\n            ptr: NonNull::new(1 as *mut ZST).unwrap(),\n        };\n\n        // Pointer obtained should be an invalid pointer (alignment for ZST)\n        let ptr = bucket.as_ptr();\n        assert_eq!(ptr as usize, std::mem::align_of::<ZST>());\n    }\n}\n```", "raw::Bucket::<T>::as_ref": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_as_ref() {\n        // Setup\n        let value = 42;\n        let bucket = Bucket {\n            ptr: NonNull::new(&value as *const _ as *mut _).unwrap(),\n        };\n\n        // Unsafe block is required to call as_ref\n        unsafe {\n            // Test that as_ref returns a reference to the original value\n            let ref_value: &i32 = bucket.as_ref();\n            assert_eq!(*ref_value, value);\n        }\n    }\n}\n```", "raw::Bucket::<T>::drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    struct TestData {\n        value: i32,\n    }\n\n    #[test]\n    fn test_drop() {\n        let val = Box::new(TestData { value: 42 });\n        let ptr = NonNull::new(Box::into_raw(val)).expect(\"Non-null pointer expected\");\n        let bucket = Bucket { ptr };\n\n        unsafe {\n            bucket.drop(); // Drop should work without any panic\n        }\n\n        // Ensure that the memory is effectively cleaned up\n        // (this may not always be verifiable without a memory leak detector,\n        // but here we assume normal operation if no panic occurs)\n    }\n\n    #[test]\n    fn test_drop_with_zero_sized_type() {\n        let ptr = NonNull::new(Box::into_raw(Box::new([]))).expect(\"Non-null pointer expected\");\n        let bucket = Bucket { ptr };\n\n        unsafe {\n            bucket.drop(); // Drop should work without any panic\n        }\n\n        // No assertions here, we assume the drop of a ZST has no issues\n    }\n}\n```", "raw::Bucket::<T>::from_base_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    struct TestData {\n        value: i32,\n    }\n\n    #[test]\n    fn test_from_base_index_non_zst() {\n        let test_value = TestData { value: 42 };\n        let base = &test_value as *const _ as *mut TestData;\n        let base_non_null = NonNull::new(base).unwrap();\n        \n        let bucket = unsafe { Bucket::<TestData>::from_base_index(base_non_null, 0) };\n        let ptr = bucket.as_ptr();\n        \n        assert_eq!(ptr, base_non_null.as_ptr());\n    }\n\n    #[test]\n    fn test_from_base_index_zst() {\n        struct Zst;\n        let index = 2;\n        let base = 0 as *mut Zst;\n        let base_non_null = NonNull::new(base).unwrap();\n\n        let bucket = unsafe { Bucket::<Zst>::from_base_index(base_non_null, index) };\n        \n        assert_eq!(bucket.ptr.as_ptr() as usize, (index + 1) as usize);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_from_base_index_out_of_bounds() {\n        let test_value = TestData { value: 42 };\n        let base = &test_value as *const _ as *mut TestData;\n        let base_non_null = NonNull::new(base).unwrap();\n\n        unsafe {\n            Bucket::<TestData>::from_base_index(base_non_null, usize::MAX);\n        }\n    }\n\n    #[test]\n    fn test_from_base_index_with_non_null() {\n        let test_value = TestData { value: 42 };\n        let base = &test_value as *const _ as *mut TestData;\n        let base_non_null = NonNull::new(base).unwrap();\n\n        let bucket = unsafe { Bucket::<TestData>::from_base_index(base_non_null, 1) };\n        let ptr = bucket.as_ptr();\n        \n        assert_eq!(ptr, base_non_null.as_ptr().sub(1));\n    }\n}\n```", "raw::Bucket::<T>::next_n": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_next_n_non_zst() {\n        unsafe {\n            let value = Box::new(42); // Non-ZST\n            let base_ptr = NonNull::new(value.as_mut() as *mut _).unwrap();\n            let bucket = Bucket::from_base_index(base_ptr, 0);\n            let next_bucket = bucket.next_n(1);\n            assert_eq!(next_bucket.as_ptr(), bucket.as_ptr().sub(1));\n        }\n    }\n\n    #[test]\n    fn test_next_n_zst() {\n        #[repr(C)]\n        struct ZST; // Zero-Sized Type\n        unsafe {\n            let base_ptr = NonNull::new(&ZST as *const _ as *mut _).unwrap();\n            let bucket = Bucket::from_base_index(base_ptr, 0);\n            let next_bucket = bucket.next_n(1);\n            assert_eq!(next_bucket.as_ptr() as usize, bucket.as_ptr() as usize + 1);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_next_n_out_of_bounds() {\n        unsafe {\n            let value = Box::new(42);\n            let base_ptr = NonNull::new(value.as_mut() as *mut _).unwrap();\n            let bucket = Bucket::from_base_index(base_ptr, 0);\n            let _next_bucket = bucket.next_n(usize::MAX); // should panic\n        }\n    }\n}\n```", "raw::Bucket::<T>::read": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_read() {\n        // Creating a test structure\n        #[derive(Debug, PartialEq)]\n        struct TestStruct {\n            value: i32,\n        }\n\n        // Create an instance of TestStruct\n        let test_value = TestStruct { value: 42 };\n\n        // Create a NonNull pointer to the test value\n        let non_null_ptr = NonNull::new(Box::into_raw(Box::new(test_value))).unwrap();\n\n        // Create a Bucket instance\n        let bucket = Bucket { ptr: non_null_ptr };\n\n        // Safety block for unsafe read\n        unsafe {\n            let result = bucket.read();\n            assert_eq!(result, TestStruct { value: 42 });\n        }\n    }\n}\n```", "raw::Bucket::<T>::to_base_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_to_base_index_non_zero_sized() {\n        struct TestType {\n            value: u32,\n        }\n\n        let base_ptr = Box::into_raw(Box::new(TestType { value: 0 })) as *mut TestType;\n        let base_non_null = NonNull::new(base_ptr).unwrap();\n\n        let bucket = unsafe { Bucket::from_base_index(base_non_null, 1) };\n        let index = unsafe { bucket.to_base_index(base_non_null) };\n\n        assert_eq!(index, 1);\n    }\n\n    #[test]\n    fn test_to_base_index_zero_sized() {\n        struct ZeroSized;\n\n        let base_ptr = Box::into_raw(Box::new(ZeroSized)) as *mut ZeroSized;\n        let base_non_null = NonNull::new(base_ptr).unwrap();\n\n        let bucket = unsafe { Bucket::from_base_index(base_non_null, 1) };\n        let index = unsafe { bucket.to_base_index(base_non_null) };\n\n        assert_eq!(index, 0);\n    }\n\n    #[test]\n    fn test_to_base_index_multiple_elements() {\n        struct TestType {\n            value: u32,\n        }\n\n        let base_ptr = Box::into_raw(Box::new(TestType { value: 0 })) as *mut TestType;\n        let base_non_null = NonNull::new(base_ptr).unwrap();\n\n        let bucket0 = unsafe { Bucket::from_base_index(base_non_null, 0) };\n        let bucket1 = unsafe { Bucket::from_base_index(base_non_null, 1) };\n\n        let index0 = unsafe { bucket0.to_base_index(base_non_null) };\n        let index1 = unsafe { bucket1.to_base_index(base_non_null) };\n\n        assert_eq!(index0, 0);\n        assert_eq!(index1, 1);\n    }\n}\n```", "raw::Bucket::<T>::write": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_write() {\n        let value = Box::new(42);\n        let ptr = NonNull::new(Box::into_raw(value)).unwrap();\n        let bucket = Bucket { ptr };\n\n        unsafe {\n            bucket.write(100);\n            let result = bucket.read();\n            assert_eq!(result, 100);\n        }\n    }\n\n    #[test]\n    fn test_write_zero_sized() {\n        #[repr(align(1))]\n        struct ZST;\n\n        let ptr = NonNull::new(Box::into_raw(Box::new(ZST))).unwrap();\n        let bucket = Bucket { ptr };\n\n        unsafe {\n            bucket.write(ZST);\n            // Does not crash, just checks if write and read functions work.\n            let result = bucket.read();\n            // ZST reads back to a no-op value\n            assert_eq!(std::mem::size_of_val(&result), 0);\n        }\n    }\n}\n```", "raw::Fallibility::alloc_err": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Layout;\n    \n    #[test]\n    fn test_alloc_err_fallible() {\n        let layout = Layout::from_size_align(1, 1).unwrap();\n        let fallible = Fallibility::Fallible;\n        let error = fallible.alloc_err(layout);\n        \n        match error {\n            TryReserveError::AllocError { layout: err_layout } => {\n                assert_eq!(layout, err_layout);\n            },\n            _ => panic!(\"Expected AllocError\"),\n        }\n    }\n\n    #[test]\n    #[should_panic(expected = \"handle_alloc_error\")]\n    fn test_alloc_err_infallible() {\n        let layout = Layout::from_size_align(1, 1).unwrap();\n        let infallible = Fallibility::Infallible;\n        infallible.alloc_err(layout);\n    }\n}\n```", "raw::Fallibility::capacity_overflow": "```rust\n#[cfg(test)]\nmod tests {\n    use super::raw::Fallibility;\n    use super::TryReserveError;\n\n    #[test]\n    fn test_capacity_overflow_fallible() {\n        let fallibility = Fallibility::Fallible;\n        let error = fallibility.capacity_overflow();\n        match error {\n            TryReserveError::CapacityOverflow => {},\n            _ => panic!(\"Expected CapacityOverflow error\"),\n        }\n    }\n\n    #[test]\n    #[should_panic(expected = \"Hash table capacity overflow\")]\n    fn test_capacity_overflow_infallible() {\n        let fallibility = Fallibility::Infallible;\n        let _ = fallibility.capacity_overflow();\n    }\n}\n```", "raw::FullBucketsIndices::next_impl": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_next_impl() {\n        unsafe {\n            // Setup raw table and FullBucketsIndices\n            let bit_mask = BitMask(0b00001111); // Example bit mask with 4 set bits\n            let bit_mask_iter = BitMaskIter(bit_mask);\n            let control_bytes = vec![0u8; 8]; // Example control bytes\n            let group_first_index = 0; // Starting index\n            let control_ptr = NonNull::new(control_bytes.as_ptr() as *mut u8).unwrap();\n            let mut indices = FullBucketsIndices {\n                current_group: bit_mask_iter,\n                group_first_index,\n                ctrl: control_ptr,\n                items: 4,\n            };\n\n            // Call next_impl and validate results\n            let results: Vec<_> = (0..4).map(|_| indices.next()).collect();\n            let expected: Vec<_> = vec![0, 1, 2, 3]; // Expected index results\n            assert_eq!(results, expected);\n        }\n    }\n}\n```", "raw::ProbeSeq::move_next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::ProbeSeq;\n\n    #[test]\n    fn test_move_next() {\n        let mut probe_seq = ProbeSeq { pos: 0, stride: 0 };\n        let bucket_mask = 0b111; // Example bucket mask for a table size of 8\n\n        // Move next and assert the expected values\n        probe_seq.move_next(bucket_mask);\n        assert!(probe_seq.pos <= bucket_mask, \"Position should be within bucket mask\");\n        assert_eq!(probe_seq.stride, Group::WIDTH, \"Stride should be incremented by Group::WIDTH\");\n        \n        // Move next again and check the updated state\n        probe_seq.move_next(bucket_mask);\n        assert!(probe_seq.pos <= bucket_mask, \"Position should be within bucket mask\");\n        assert_eq!(probe_seq.stride, 2 * Group::WIDTH, \"Stride should be incremented again by Group::WIDTH\");\n    }\n}\n```", "raw::RawDrain::<'_, T, A>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Global;\n    \n    #[test]\n    fn test_raw_drain_iter() {\n        // Create a test instance of RawTableInner\n        let alloc = Global;\n        let mut table = unsafe {\n            RawTableInner::new_uninitialized(&alloc, TableLayout::default(), 16, Fallibility::Infallible).unwrap()\n        };\n\n        // Assume we insert some values into the table here...\n\n        // Create a RawDrain instance\n        let raw_drain = RawDrain {\n            iter: table.iter(),\n            table,\n            orig_table: NonNull::new(&mut table).unwrap(),\n            marker: PhantomData,\n        };\n\n        // Obtain an iterator from RawDrain\n        let iter = raw_drain.iter();\n\n        // Check if the iterator can be cloned\n        let cloned_iter = iter.clone();\n\n        // Check that the cloned iterator is not equal to the original\n        assert!(iter.clone() != cloned_iter);\n\n        // Verify that using the iterator produces the expected results\n        let collected: Vec<_> = iter.collect();\n        assert_eq!(collected.len(), expected_len); // Replace `expected_len` with the expected length\n    }\n}\n```", "raw::RawExtractIf::<'_, T, A>::next": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    struct TestItem {\n        value: i32,\n    }\n\n    #[test]\n    fn test_next_with_matching_item() {\n        let mut table: RawTable<TestItem, System> = RawTable::new_in(System);\n        let item1 = TestItem { value: 1 };\n        let item2 = TestItem { value: 2 };\n        \n        // Insert items into the raw table\n        let bucket1 = table.insert(1, item1, |item| item.value as u64);\n        let bucket2 = table.insert(2, item2, |item| item.value as u64);\n\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n\n        let result = extractor.next(|item| item.value == 1);\n        assert_eq!(result.map(|item| item.value), Some(1));\n        assert_eq!(table.len(), 1);  // One item should be removed\n    }\n\n    #[test]\n    fn test_next_with_no_matching_item() {\n        let mut table: RawTable<TestItem, System> = RawTable::new_in(System);\n        let item1 = TestItem { value: 1 };\n\n        // Insert an item into the raw table\n        let bucket1 = table.insert(1, item1, |item| item.value as u64);\n\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n\n        let result = extractor.next(|item| item.value == 2);\n        assert_eq!(result, None);  // No item should be removed\n        assert_eq!(table.len(), 1);  // Item count should remain the same\n    }\n\n    #[test]\n    fn test_next_with_multiple_matching_items() {\n        let mut table: RawTable<TestItem, System> = RawTable::new_in(System);\n        let item1 = TestItem { value: 1 };\n        let item2 = TestItem { value: 2 };\n        let item3 = TestItem { value: 3 };\n\n        // Insert items into the raw table\n        let bucket1 = table.insert(1, item1, |item| item.value as u64);\n        let bucket2 = table.insert(2, item2, |item| item.value as u64);\n        let bucket3 = table.insert(3, item3, |item| item.value as u64);\n\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n\n        // First matching item\n        let result1 = extractor.next(|item| item.value == 1);\n        assert_eq!(result1.map(|item| item.value), Some(1));\n        \n        // Second matching item\n        let result2 = extractor.next(|item| item.value == 2);\n        assert_eq!(result2.map(|item| item.value), Some(2));\n        \n        assert_eq!(table.len(), 1);  // One item should remain\n    }\n}\n```", "raw::RawIntoIter::<T, A>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_raw_into_iter_iter() {\n        let alloc = System; // Using the global allocator\n        let mut raw_into_iter: RawIntoIter<i32, System> = RawIntoIter::default();\n\n        // Creating some dummy test data\n        let data = vec![1, 2, 3, 4, 5];\n        raw_into_iter.iter = RawIter {\n            iter: RawIterRange::new(\n                std::ptr::null(),\n                Bucket::from_base_index(unsafe { NonNull::new_unchecked(data.as_ptr() as *mut i32) }, data.len()),\n                data.len(),\n            ),\n            items: data.len(),\n        };\n\n        let raw_iter = raw_into_iter.iter();\n\n        // Ensure cloned iterator has the same number of items\n        assert_eq!(raw_iter.items, raw_into_iter.iter.items);\n\n        // Ensure iter can be consumed\n        let mut collected: Vec<i32> = raw_iter.collect();\n        assert_eq!(collected, data);\n    }\n}\n```", "raw::RawIter::<T>::drop_elements": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    struct MockItem {\n        dropped: bool,\n    }\n\n    impl MockItem {\n        fn new() -> Self {\n            MockItem { dropped: false }\n        }\n        unsafe fn drop(&mut self) {\n            self.dropped = true;\n        }\n    }\n\n    #[test]\n    fn test_drop_elements() {\n        unsafe {\n            let mut items = Vec::new();\n            for _ in 0..3 {\n                items.push(Box::new(MockItem::new()));\n            }\n\n            let mut raw_iter: RawIter<MockItem> = RawIter {\n                iter: RawIterRange::new(std::ptr::null(), Bucket::from_base_index(NonNull::new_unchecked(items.as_mut_ptr()), items.len()), items.len()), // Mock RawIterRange\n                items: items.len(),\n            };\n\n            raw_iter.drop_elements();\n            for item in items {\n                assert!(item.dropped);\n            }\n        }\n    }\n}\n```", "raw::RawIterHash::<T>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_iter_hash_new() {\n        unsafe {\n            let table = RawTable::<u8, Global>::new_in(Global);\n            let hash = 12345;\n\n            let iter = RawIterHash::<u8>::new(&table, hash);\n            assert!(iter.inner.tag_hash == Tag::full(hash));\n            assert!(iter.inner.bucket_mask == table.table.bucket_mask);\n        }\n    }\n}\n```", "raw::RawIterHashInner::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_hash_inner_new() {\n        // Prepare test data for RawTableInner\n        let mock_bucket_mask = 0b111; // Example bucket mask\n        let mock_ctrl = NonNull::new(Box::into_raw(Box::new([Tag::EMPTY; 4][..])) as *mut _).unwrap();\n        let raw_table_inner = RawTableInner {\n            bucket_mask: mock_bucket_mask,\n            ctrl: mock_ctrl,\n            growth_left: 10,\n            items: 0,\n        };\n\n        let test_hash = 0b0000_0001; // Example hash\n\n        unsafe {\n            let iter = RawIterHashInner::new(&raw_table_inner, test_hash);\n            assert_eq!(iter.bucket_mask, mock_bucket_mask);\n            assert_eq!(iter.tag_hash, Tag::full(test_hash));\n            assert_eq!(iter.probe_seq.pos, raw_table_inner.probe_seq(test_hash).pos);\n            assert_eq!(iter.ctrl, mock_ctrl);\n\n            // Check if the group is loaded correctly\n            let group = Group::load(raw_table_inner.ctrl.as_ptr().cast());\n            assert_eq!(iter.group, group);\n\n            // Check if the bitmask is correctly initialized\n            let bitmask = group.match_tag(Tag::full(test_hash)).into_iter();\n            assert_eq!(iter.bitmask.next().is_some(), bitmask.next().is_some());\n        }\n    }\n}\n```", "raw::RawIterRange::<T>::fold_impl": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_fold_impl() {\n        struct TestStruct {\n            value: i32,\n        }\n\n        unsafe {\n            // Create an instance of RawIterRange\n            let data: Vec<Bucket<TestStruct>> = (0..5)\n                .map(|x| {\n                    let val = TestStruct { value: x };\n                    let ptr = NonNull::new_unchecked(Box::into_raw(Box::new(val)));\n                    Bucket { ptr }\n                })\n                .collect();\n                \n            let control_ptr: *const u8 = std::ptr::null(); // Stub pointer for control\n            let raw_iter_range = RawIterRange::new(control_ptr, data[0].clone(), data.len());\n\n            // Closure to sum the values\n            let sum = raw_iter_range.fold_impl(data.len(), 0, |acc, bucket| {\n                unsafe { acc + (*bucket.as_ref()).value }\n            });\n\n            // Assert the sum of values (0 + 1 + 2 + 3 + 4 = 10)\n            assert_eq!(sum, 10);\n        }\n    }\n}\n```", "raw::RawIterRange::<T>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_range_new() {\n        unsafe {\n            // Create a mock control pointer, using a buffer aligned to Group::WIDTH\n            let control_buffer = vec![0u8; 32]; // Assuming Group::WIDTH is 32\n            let ctrl = control_buffer.as_ptr();\n            let bucket = Bucket::from_base_index(\n                NonNull::from(&control_buffer[0] as *const _ as *mut _),\n                0\n            ); // Create a Bucket pointing to the first element\n\n            // Test with a valid length\n            let len = 8; // Must be a power of two and valid\n            let iter_range = RawIterRange::new(ctrl, bucket, len);\n\n            // Assertions\n            assert_eq!(iter_range.data.to_base_index(NonNull::from(&control_buffer[0] as *const _ as *mut _)), 0);\n            assert!(iter_range.current_group.any_bit_set());\n            assert!(iter_range.end as usize > ctrl as usize);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_raw_iter_range_new_zero_length() {\n        unsafe {\n            let control_buffer = vec![0u8; 32];\n            let ctrl = control_buffer.as_ptr();\n            let bucket = Bucket::from_base_index(\n                NonNull::from(&control_buffer[0] as *const _ as *mut _),\n                0\n            );\n\n            // Attempt to create with a zero length\n            let _ = RawIterRange::new(ctrl, bucket, 0);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_raw_iter_range_new_invalid_length() {\n        unsafe {\n            let control_buffer = vec![0u8; 32];\n            let ctrl = control_buffer.as_ptr();\n            let bucket = Bucket::from_base_index(\n                NonNull::from(&control_buffer[0] as *const _ as *mut _),\n                0\n            );\n\n            // Attempt to create with an invalid length (not a power of 2)\n            let _ = RawIterRange::new(ctrl, bucket, 5);\n        }\n    }\n}\n```", "raw::RawIterRange::<T>::next_impl": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Make sure to import the necessary items from the module\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_next_impl() {\n        // Define the necessary setup to test `next_impl`\n        let bucket_data: Vec<u32> = vec![1, 2, 3, 4];\n        let bucket_ptr = NonNull::new(bucket_data.as_ptr() as *mut u32).unwrap();\n        let bucket = unsafe { Bucket::from_base_index(bucket_ptr, 0) };\n        \n        // Assume that we have a valid control pointer, aligned properly.\n        let control_ptr = bucket_ptr.as_ptr() as *const u8;\n\n        // Create a RawIterRange for testing, ensuring valid parameters.\n        let mut iter_range: RawIterRange<u32> = unsafe { RawIterRange::new(control_ptr, bucket, 4) };\n\n        // Verify the elements are iterated correctly\n        let mut results = Vec::new();\n        while let Some(bucket) = iter_range.next() {\n            unsafe {\n                results.push(*bucket.as_ref());\n            }\n        }\n        \n        // Check that we got the expected results\n        assert_eq!(results, vec![1, 2, 3, 4]);\n    }\n}\n```", "raw::RawTable::<T, A>::allocation_size": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_allocation_size_empty_table() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        assert_eq!(table.allocation_size(), 0);\n    }\n\n    #[test]\n    fn test_allocation_size_with_capacity() {\n        let capacity = 8; // power of two\n        let table: RawTable<i32, Global> = RawTable::with_capacity(capacity);\n        assert!(table.allocation_size() > 0);\n    }\n\n    #[test]\n    fn test_allocation_size_after_inserts() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(8);\n        for i in 0..4 {\n            // This assumes that RawTable has an `insert` method.\n            table.insert(i as u64, i, |x| *x);\n        }\n        let size_after_inserts = table.allocation_size();\n        assert!(size_after_inserts > 0);\n    }\n\n    #[test]\n    fn test_allocation_size_with_no_allocations() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        assert_eq!(table.allocation_size(), 0);\n    }\n}\n```", "raw::RawTable::<T, A>::allocator": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_allocator() {\n        let alloc = Global;\n        let table: RawTable<i32, Global> = RawTable::new_in(alloc);\n        let allocated = table.allocator();\n        assert_eq!(allocated as *const _, &Global as *const _);\n    }\n}\n```", "raw::RawTable::<T, A>::bucket": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_bucket() {\n        // Setup: Create a RawTable and add a dummy value\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash = 42;\n\n        unsafe {\n            table.insert(hash, 10, |x| x.clone());\n            table.insert(hash, 20, |x| x.clone());\n            let bucket = table.bucket(1); // Access the second bucket (index 1)\n\n            // Validate the bucket's index\n            let bucket_index = table.bucket_index(&bucket);\n            assert_eq!(bucket_index, 1);\n\n            // Access the value\n            assert_eq!(bucket.as_ref(), &20);\n        }\n    }\n\n    #[test]\n    fn test_bucket_out_of_bounds() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        unsafe {\n            // This call should not panic, but the underlying table must be uninitialized\n            // Guarantee it matches the expected behavior for the given index\n            let bucket = table.bucket(0);\n            assert_eq!(bucket.as_ref(), &0); // since no element is inserted\n        }\n    }\n\n    #[test]\n    fn test_bucket_with_index_too_large() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        unsafe {\n            // Validate behavior with an index greater than the bucket count\n            let index = table.buckets(); // Current bucket count\n            let result = std::panic::catch_unwind(|| {\n                table.bucket(index); // Access the bucket at the index\n            });\n            assert!(result.is_err());\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::bucket_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_bucket_index() {\n        // Setup\n        let mut raw_table: RawTable<i32, Global> = RawTable::new();\n        let bucket = unsafe { raw_table.bucket(0) }; // Assuming we have at least one bucket\n        unsafe {\n            // Assuming this bucket is in the table's data\n            let index = raw_table.bucket_index(&bucket);\n            assert_eq!(index, 0); // Since we are using the first bucket\n        }\n\n        // Fill the table\n        // Here we would normally add elements to the raw_table to ensure it has\n        // elements and that the bucket is not just an empty one.\n\n        // Setup to add an element\n        // raw_table.insert(....); // Insert actual test data\n\n        // Check the bucket index again\n        // Assuming the bucket we are now testing is the first one again and the table has data\n        unsafe {\n            let bucket = raw_table.bucket(0);\n            let index = raw_table.bucket_index(&bucket);\n            assert_eq!(index, 0); // Ensure the bucket index is correct\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::buckets": "```rust\nuse hashbrown::raw::{RawTable, RawTableInner};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_buckets() {\n        // Test case 1: Default RawTable has 1 bucket\n        let table: RawTable<i32> = RawTable::new();\n        assert_eq!(table.buckets(), 1);\n\n        // Test case 2: RawTable with 1 capacity should have 1 bucket\n        let table: RawTable<i32> = RawTable::with_capacity(1);\n        assert_eq!(table.buckets(), 1);\n\n        // Test case 3: RawTable with 2 capacity, should have 2 buckets\n        let table: RawTable<i32> = RawTable::with_capacity(2);\n        assert_eq!(table.buckets(), 2);\n\n        // Test case 4: RawTable with 4 capacity should have 4 buckets\n        let table: RawTable<i32> = RawTable::with_capacity(4);\n        assert_eq!(table.buckets(), 4);\n\n        // Test case 5: RawTable with 8 capacity should have 8 buckets\n        let table: RawTable<i32> = RawTable::with_capacity(8);\n        assert_eq!(table.buckets(), 8);\n    }\n}\n```", "raw::RawTable::<T, A>::capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_capacity_empty() {\n        let table: RawTable<u32, Global> = RawTable::new();\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_single() {\n        let mut table = RawTable::with_capacity(1);\n        assert_eq!(table.capacity(), 1);\n        table.insert(0, 42, |x| x);\n        assert_eq!(table.capacity(), 1);\n    }\n\n    #[test]\n    fn test_capacity_multiple() {\n        let mut table = RawTable::with_capacity(4);\n        assert_eq!(table.capacity(), 4);\n        for i in 0..4 {\n            table.insert(i as u64, i, |x| x);\n        }\n        assert_eq!(table.capacity(), 4);\n    }\n\n    #[test]\n    fn test_capacity_growth() {\n        let mut table = RawTable::with_capacity(2);\n        assert_eq!(table.capacity(), 2);\n        table.insert(0, 1, |x| x);\n        table.insert(1, 2, |x| x);\n        table.insert(2, 3, |x| x); // Should trigger growth\n        assert!(table.capacity() > 2);\n    }\n}\n```", "raw::RawTable::<T, A>::clear": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    \n    #[test]\n    fn test_clear() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(5);\n        \n        // Inserting some elements\n        for i in 1..=5 {\n            table.insert(i as u64, i, |&x| x);\n        }\n        \n        // Ensure the table is not empty before clear\n        assert!(!table.is_empty());\n        assert_eq!(table.len(), 5);\n        \n        // Clear the table\n        table.clear();\n        \n        // Check that the table is empty after clear\n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n    }\n    \n    #[test]\n    fn test_clear_empty_table() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Ensure the table is empty\n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n        \n        // Clear the empty table (should not panic)\n        table.clear();\n        \n        // Check that the table is still empty\n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n    }\n}\n```", "raw::RawTable::<T, A>::clear_no_drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clear_no_drop() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        \n        // Insert elements into the table\n        unsafe {\n            table.insert(1, 42, |x| x.hash());\n            table.insert(2, 43, |x| x.hash());\n        }\n\n        // Verify the table is not empty\n        assert!(!table.is_empty());\n        assert_eq!(table.len(), 2);\n\n        // Clear the table without dropping contents\n        table.clear_no_drop();\n\n        // Verify the table is empty, but contents are not dropped\n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n\n        // The contents are still in the table, but we cannot verify\n        // them directly since they are not dropped, and the table\n        // structure is now in an empty state\n    }\n}\n```", "raw::RawTable::<T, A>::clone_from_impl": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clone_from_impl_empty() {\n        let source: RawTable<i32, Global> = RawTable::new();\n        let mut target: RawTable<i32, Global> = RawTable::new();\n        \n        unsafe {\n            target.clone_from_impl(&source);\n        }\n\n        assert_eq!(target.len(), 0);\n        assert_eq!(target.items, source.items);\n    }\n\n    #[test]\n    fn test_clone_from_impl_non_empty() {\n        let mut source: RawTable<i32, Global> = RawTable::with_capacity(4);\n        let mut target: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        unsafe {\n            source.insert(1, 10, |v| *v);\n            source.insert(2, 20, |v| *v);\n            source.insert(3, 30, |v| *v);\n            source.items = 3; // Set items after manual insertion\n            target.clone_from_impl(&source);\n        }\n\n        assert_eq!(target.len(), 3);\n        assert_eq!(target.items, source.items);\n    }\n\n    #[test]\n    fn test_clone_from_impl_with_different_capacity() {\n        let mut source: RawTable<i32, Global> = RawTable::with_capacity(4);\n        let mut target: RawTable<i32, Global> = RawTable::with_capacity(10);\n\n        unsafe {\n            source.insert(1, 10, |v| *v);\n            source.insert(2, 20, |v| *v);\n            source.items = 2; // Set items after manual insertion\n            target.clone_from_impl(&source);\n        }\n\n        assert_eq!(target.len(), 2);\n        assert_eq!(target.items, source.items);\n    }\n\n    #[test]\n    fn test_clone_from_impl_with_drops() {\n        struct DropCounter(i32);\n        impl Drop for DropCounter {\n            fn drop(&mut self) {\n                self.0 += 1;\n            }\n        }\n\n        let mut source: RawTable<DropCounter, Global> = RawTable::with_capacity(4);\n        let mut target: RawTable<DropCounter, Global> = RawTable::new();\n        \n        unsafe {\n            source.insert(1, DropCounter(0), |v| *v);\n            source.items = 1; // Set items after manual insertion\n            target.clone_from_impl(&source);\n        }\n\n        assert_eq!(target.len(), 1);\n        assert_eq!(target.items, source.items);\n    }\n}\n```", "raw::RawTable::<T, A>::data_end": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_data_end() {\n        // Create a new RawTable instance.\n        let table: RawTable<i32> = RawTable::new();\n\n        // Call data_end() and get the result.\n        let data_end_ptr: NonNull<i32> = table.data_end();\n\n        // The result should not be null.\n        assert!(!data_end_ptr.as_ptr().is_null());\n\n        // Since the table is new and has not allocated any elements, we do not know the exact\n        // address it points to, but we do know that it's a valid NonNull pointer.\n    }\n}\n```", "raw::RawTable::<T, A>::drain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Global;\n\n    #[test]\n    fn test_drain_empty() {\n        let mut table: RawTable<i32, Global> = RawTable::default();\n        let drain_iter = table.drain();\n        let collected: Vec<i32> = drain_iter.collect();\n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_drain_non_empty() {\n        let mut table: RawTable<i32, Global> = RawTable::default();\n        table.insert(0, 10, |x| *x); // Assuming you have a way to insert\n        table.insert(1, 20, |x| *x); // Assuming you have a way to insert\n\n        let drain_iter = table.drain();\n        let collected: Vec<i32> = drain_iter.collect();\n        \n        assert_eq!(collected.len(), 2);\n        assert!(collected.contains(&10));\n        assert!(collected.contains(&20));\n    }\n\n    #[test]\n    fn test_drain_drops_elements() {\n        struct DropCounter {\n            count: std::sync::Arc<std::sync::Mutex<usize>>,\n        }\n\n        impl Drop for DropCounter {\n            fn drop(&mut self) {\n                let mut count = self.count.lock().unwrap();\n                *count += 1;\n            }\n        }\n\n        let count = std::sync::Arc::new(std::sync::Mutex::new(0));\n        let counter_1 = DropCounter { count: count.clone() };\n        let counter_2 = DropCounter { count: count.clone() };\n        \n        let mut table: RawTable<DropCounter, Global> = RawTable::default();\n        table.insert(0, counter_1, |x| *x); // Assuming you have a way to insert\n        table.insert(1, counter_2, |x| *x); // Assuming you have a way to insert\n\n        {\n            let drain_iter = table.drain();\n            let _collected: Vec<DropCounter> = drain_iter.collect();\n            // DropCounter elements should drop automatically\n        }\n        \n        assert_eq!(*count.lock().unwrap(), 2);\n    }\n}\n```", "raw::RawTable::<T, A>::drain_iter_from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_drain_iter_from() {\n        // Create a RawTable with some test values\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n\n        // Insert values into the table\n        for i in 0..5 {\n            let _ = table.insert(i as u64, i, |v| *v as u64);\n        }\n\n        // Create an iterator starting from the beginning\n        let iter = table.iter();\n        let mut drain_iter = unsafe { table.drain_iter_from(iter) };\n\n        // Collect the drained items into a vector\n        let drained_items: Vec<i32> = drain_iter.collect();\n\n        // Check the drained items match the expected values\n        assert_eq!(drained_items, vec![0, 1, 2, 3, 4]);\n\n        // Ensure the table is now empty\n        assert_eq!(table.table.items, 0);\n    }\n\n    #[test]\n    fn test_drain_iter_from_empty() {\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n\n        // Create an empty iterator\n        let iter = table.iter();\n        let mut drain_iter = unsafe { table.drain_iter_from(iter) };\n\n        // Collect the drained items into a vector\n        let drained_items: Vec<i32> = drain_iter.collect();\n\n        // Ensure no items were drained\n        assert!(drained_items.is_empty());\n        assert_eq!(table.table.items, 0);\n    }\n}\n```", "raw::RawTable::<T, A>::erase": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_erase() {\n        // Setup a RawTable with a capacity of 4 for testing purposes\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        // Hash a value and insert into the hash table\n        let hash = 42; // Example hash value\n        let bucket = unsafe {\n            table.insert(hash, 10, |&x| x.wrapping_hash()).as_non_null()\n        };\n        \n        // Assert that the table contains a value\n        assert_eq!(unsafe { bucket.as_ref() }, &10);\n        \n        // Erase the value and test if it is removed\n        unsafe { table.erase(bucket) };\n\n        // Attempt to find the erased value, expecting None\n        assert_eq!(table.find(hash, |&x| x == 10), None);\n    }\n\n    #[test]\n    fn test_erase_drop() {\n        // Setup a RawTable with a capacity of 4 for testing purposes\n        let mut table: RawTable<Box<i32>, Global> = RawTable::with_capacity(4);\n        let value = Box::new(20);\n        let hash = 42; // Example hash value\n        let bucket = unsafe {\n            table.insert(hash, value, |x| x.as_ref().hash()).as_non_null()\n        };\n\n        // Erase the value and test if the Box is dropped\n        unsafe { table.erase(bucket) };\n\n        // Check if the box is dropped correctly (after erase, value should be out of scope)\n        // This test is more about ensuring it compiles correctly; manual checking or use of\n        // drop counters would be necessary for more in-depth testing of drop behavior.\n    }\n\n    #[test]\n    fn test_safe_usage() {\n        // Create a RawTable for testing\n        let mut table: RawTable<String, Global> = RawTable::with_capacity(4);\n        let hash_value = 123; // Example hash value\n        let bucket = unsafe {\n            table.insert(hash_value, \"Test\".to_string(), |x| x.hash()).as_non_null()\n        };\n\n        // Ensure the value exists\n        assert_eq!(unsafe { bucket.as_ref() }, \"Test\");\n\n        // Erase the value\n        unsafe { table.erase(bucket) };\n\n        // Ensure the erased value is not found\n        assert!(table.find(hash_value, |x| x == \"Test\").is_none());\n    }\n}\n```", "raw::RawTable::<T, A>::erase_no_drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_erase_no_drop() {\n        // Setup\n        let mut table: RawTable<u32, Global> = RawTable::new();\n        let bucket = unsafe {\n            table.insert(1, 42, |x| *x).as_non_null() // Insert an element\n        };\n\n        // Verify insertion\n        assert_eq!(table.len(), 1);\n\n        // Erase the element without dropping\n        unsafe { table.erase_no_drop(&Bucket { ptr: bucket }) };\n\n        // Verify that the length remains 1 after erasing without dropping\n        assert_eq!(table.len(), 1);\n    }\n\n    #[test]\n    fn test_erase_no_drop_empty_table() {\n        // Setup\n        let mut table: RawTable<u32, Global> = RawTable::new();\n        let bucket = unsafe {\n            table.insert(1, 42, |x| *x).as_non_null() // Insert an element\n        };\n\n        // Erase the element without dropping\n        unsafe { table.erase_no_drop(&Bucket { ptr: bucket }) };\n\n        // Verify the table is unchanged (length remains 1)\n        assert_eq!(table.len(), 1);\n    }\n}\n```", "raw::RawTable::<T, A>::find": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::vec::Vec;\n\n    #[test]\n    fn test_find_existing_element() {\n        let mut table: RawTable<i32> = RawTable::new();\n        let hash = 42; // A dummy hash for testing\n        let value = 100;\n\n        unsafe {\n            table.insert(hash, value, |&v| v as u64); // Insert an element\n        }\n\n        let found = table.find(hash, |&v| *v == value);\n        assert!(found.is_some(), \"Expected to find the element, but found none.\");\n        assert_eq!(unsafe { found.unwrap().as_ref() }, &value);\n    }\n\n    #[test]\n    fn test_find_non_existing_element() {\n        let table: RawTable<i32> = RawTable::new();\n        let hash = 42; // A dummy hash for testing\n        let value = 100;\n\n        let found = table.find(hash, |&v| v == value);\n        assert!(found.is_none(), \"Expected to find no element, but found one.\");\n    }\n\n    #[test]\n    fn test_find_with_custom_equality() {\n        let mut table: RawTable<i32> = RawTable::new();\n        unsafe {\n            table.insert(1, 10, |&v| v as u64);\n            table.insert(2, 20, |&v| v as u64);\n        }\n\n        let found = table.find(1, |&v| *v == 10);\n        assert!(found.is_some(), \"Expected to find the element.\");\n    }\n\n    #[test]\n    fn test_find_on_empty_table() {\n        let table: RawTable<i32> = RawTable::new();\n        let found = table.find(0, |_| false);\n        assert!(found.is_none(), \"Expected to find no element in an empty table.\");\n    }\n\n    #[test]\n    fn test_find_with_collision() {\n        let mut table: RawTable<i32> = RawTable::new();\n        unsafe {\n            table.insert(1, 10, |&v| v as u64); // Insert element with hash 1\n            table.insert(2, 20, |&v| v as u64); // Insert element with hash 2\n        }\n\n        let found = table.find(1, |&v| *v == 10);\n        assert!(found.is_some(), \"Expected to find element with hash 1.\");\n    }\n}\n```", "raw::RawTable::<T, A>::find_or_find_insert_slot": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_find_or_find_insert_slot_found() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash = 42;\n\n        unsafe {\n            table.insert(hash, 100, |x| *x);\n            let bucket_result = table.find_or_find_insert_slot(hash, |&x| x == 100, |x| *x);\n            assert!(bucket_result.is_ok());\n            assert_eq!(unsafe { bucket_result.unwrap().as_ref() }, &100);\n        }\n    }\n\n    #[test]\n    fn test_find_or_find_insert_slot_insert() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash = 42;\n\n        let bucket_result = table.find_or_find_insert_slot(hash, |&x| x == 100, |x| *x);\n        assert!(bucket_result.is_err());\n\n        unsafe {\n            let slot = bucket_result.unwrap_err();\n            let bucket = table.insert_in_slot(hash, slot, 100);\n            assert_eq!(unsafe { bucket.as_ref() }, &100);\n        }\n    }\n\n    #[test]\n    fn test_find_or_find_insert_slot_resize() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(1);\n        let hash = 42;\n\n        unsafe {\n            table.insert(hash, 100, |x| *x);\n            let bucket_result = table.find_or_find_insert_slot(hash + 1, |&x| x == 100, |x| *x);\n            assert!(bucket_result.is_ok());\n            assert_eq!(unsafe { bucket_result.unwrap().as_ref() }, &100);\n        }\n    }\n\n    #[test]\n    fn test_find_or_find_insert_slot_multiple_hashes() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash1 = 42;\n        let hash2 = 43;\n\n        unsafe {\n            table.insert(hash1, 100, |x| *x);\n            table.insert(hash2, 200, |x| *x);\n            let bucket_result1 = table.find_or_find_insert_slot(hash1, |&x| x == 100, |x| *x);\n            let bucket_result2 = table.find_or_find_insert_slot(hash2, |&x| x == 200, |x| *x);\n            assert!(bucket_result1.is_ok());\n            assert!(bucket_result2.is_ok());\n            assert_eq!(unsafe { bucket_result1.unwrap().as_ref() }, &100);\n            assert_eq!(unsafe { bucket_result2.unwrap().as_ref() }, &200);\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_get_existing_item() {\n        let mut table = RawTable::<i32, Global>::with_capacity(4);\n        let hash: u64 = 42; // Example hash\n        table.insert(hash, 100, |x| *x as u64); // Insert an item\n\n        let result = table.get(hash, |item| *item == 100);\n        assert_eq!(result, Some(&100));\n    }\n\n    #[test]\n    fn test_get_non_existing_item() {\n        let table = RawTable::<i32, Global>::with_capacity(4);\n        let hash: u64 = 42; // Example hash\n\n        let result = table.get(hash, |item| *item == 100);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_item_with_different_hash() {\n        let mut table = RawTable::<i32, Global>::with_capacity(4);\n        let hash: u64 = 42; // Example hash\n        table.insert(hash, 100, |x| *x as u64); // Insert an item\n\n        let result = table.get(hash + 1, |item| *item == 100); // Query with a different hash\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_with_custom_equality() {\n        #[derive(PartialEq)]\n        struct MyStruct {\n            value: i32,\n        }\n\n        let mut table = RawTable::<MyStruct, Global>::with_capacity(4);\n        let hash: u64 = 42; // Example hash\n        table.insert(hash, MyStruct { value: 100 }, |x| x.value as u64); // Insert an item\n\n        let result = table.get(hash, |item| item.value == 100);\n        assert_eq!(result, Some(&MyStruct { value: 100 }));\n    }\n}\n```", "raw::RawTable::<T, A>::get_many_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    \n    #[test]\n    fn test_get_many_mut() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Inserting some values into the table\n        table.insert(1, 10, |&x| x as u64);\n        table.insert(2, 20, |&x| x as u64);\n        table.insert(3, 30, |&x| x as u64);\n\n        // Testing distinct hashes\n        let hashes = [1, 2, 3];\n        let result = table.get_many_mut(hashes, |i, k| k == &i);\n        assert_eq!(result, [Some(&mut 10), Some(&mut 20), Some(&mut 30)]);\n\n        // Testing duplicate hashes\n        let hashes_dup = [1, 1];\n        let result_dup = table.get_many_mut(hashes_dup, |i, k| k == &i);\n        assert_eq!(result_dup, [Some(&mut 10), None]);\n\n        // Testing hash that does not exist\n        let hashes_nonexistent = [4];\n        let result_nonexistent = table.get_many_mut(hashes_nonexistent, |i, k| k == &i);\n        assert_eq!(result_nonexistent, [None]);\n    }\n\n    #[test]\n    #[should_panic(expected = \"duplicate keys found\")]\n    fn test_get_many_mut_duplicate_panic() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Inserting some values into the table\n        table.insert(1, 10, |&x| x as u64);\n        table.insert(2, 20, |&x| x as u64);\n\n        // Testing duplicate hashes\n        let hashes_dup = [1, 1];\n        let _ = table.get_many_mut(hashes_dup, |i, k| k == &i);\n    }\n}\n```", "raw::RawTable::<T, A>::get_many_mut_pointers": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_get_many_mut_pointers_unique() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        let keys = [1, 2, 3];\n        let hashes = [1u64, 2, 3];\n        \n        // Insert elements into table\n        for (hash, value) in hashes.iter().zip(keys.iter()) {\n            table.insert(*hash, *value, |&x| x.wrapping_add(1) as u64);\n        }\n\n        // Define equality function\n        let eq = |i: usize, &k: &i32| {\n            keys[i] == k\n        };\n\n        // Call the function\n        let pointers = unsafe {\n            table.get_many_mut_pointers(hashes, eq)\n        };\n\n        // Check if the pointers are correct\n        assert_eq!(pointers.len(), 3);\n        for (i, &hash) in hashes.iter().enumerate() {\n            let result = pointers[i];\n            assert!(result.is_some(), \"Expected a pointer for hash: {}\", hash);\n            let value = unsafe { result.unwrap().as_ref() };\n            assert_eq!(*value, keys[i]);\n        }\n    }\n\n    #[test]\n    fn test_get_many_mut_pointers_duplicates() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        let keys = [1, 1, 2, 3];\n        let hashes = [1u64, 1, 2, 3];\n\n        // Insert elements into table\n        for (hash, value) in hashes.iter().zip(keys.iter()) {\n            table.insert(*hash, *value, |&x| x.wrapping_add(1) as u64);\n        }\n\n        // Define equality function\n        let eq = |i: usize, &k: &i32| {\n            keys[i] == k\n        };\n\n        // Call the function\n        let pointers = unsafe {\n            table.get_many_mut_pointers(hashes, eq)\n        };\n\n        // Check pointers\n        for (i, &result) in pointers.iter().enumerate() {\n            if i == 0 {\n                // First hash (1) should point to the first occurrence\n                assert!(result.is_some(), \"Expected a pointer for hash: {}\", hashes[i]);\n            } else if i == 1 {\n                // Second hash (1) should produce a duplicate\n                assert!(result.is_none(), \"Expected None for duplicate hash: {}\", hashes[i]);\n            } else {\n                assert!(result.is_some(), \"Expected a pointer for hash: {}\", hashes[i]);\n            }\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::get_many_unchecked_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::mem::MaybeUninit;\n\n    #[test]\n    fn test_get_many_unchecked_mut() {\n        let mut table: RawTable<u32, Global> = RawTable::new();\n        \n        // Insert some test data\n        for i in 0..5 {\n            let hash = i as u64;\n            unsafe {\n                table.insert(hash, i, |x| *x);\n            }\n        }\n\n        // Prepare hashes for get_many_unchecked_mut\n        let hashes: [u64; 5] = [0, 1, 2, 3, 4];\n\n        // Get mutable references to multiple elements\n        let mut results: [Option<&mut u32>; 5] = unsafe {\n            table.get_many_unchecked_mut(hashes, |i, &val| {\n                val == i as u32\n            })\n        };\n\n        // Ensure that we got mutable references to correct elements\n        for (i, result) in results.iter_mut().enumerate() {\n            assert!(result.is_some());\n            *result = result.take().map(|val| {\n                *val += 10; // Modify value to check mutability\n                val\n            });\n            assert_eq!(*result.unwrap(), (i as u32) + 10);\n        }\n\n        // Verify that the table's elements have the expected modified values\n        for i in 0..5 {\n            assert_eq!(unsafe { table.get(i as u64, |&val| val == i as u32) }.unwrap(), &((i as u32) + 10));\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_get_mut_existing() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        table.insert(123, 42, |x| *x);\n        let mut result = table.get_mut(123, |x| *x == 42);\n        assert!(result.is_some());\n        *result.as_mut().unwrap() = 50; // Update the value\n        assert_eq!(table.get(123, |x| *x == 50).unwrap(), &50);\n    }\n\n    #[test]\n    fn test_get_mut_non_existing() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        table.insert(123, 42, |x| *x);\n        let result = table.get_mut(999, |x| *x == 50);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_mut_multiple_entries() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        table.insert(123, 42, |x| *x);\n        table.insert(456, 99, |x| *x);\n        \n        let result = table.get_mut(456, |x| *x == 99);\n        assert!(result.is_some());\n        *result.as_mut().unwrap() = 100; // Update the value\n        assert_eq!(table.get(456, |x| *x == 100).unwrap(), &100);\n    }\n\n    #[test]\n    fn test_get_mut_tombstone() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        table.insert(123, 42, |x| *x);\n        \n        // This simulates deleting an entry without actually deleting it\n        unsafe {\n            table.erase_no_drop(&table.find(123, |x| *x == 42).unwrap());\n        }\n\n        let result = table.get_mut(123, |x| *x == 42);\n        assert!(result.is_none());\n    }\n}\n```", "raw::RawTable::<T, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Importing relevant items from the parent module\n    use std::alloc::Global; // Import for default allocator\n    use std::ptr::NonNull; // Import for NonNull\n    use std::mem::size_of; // Import for size_of\n\n    #[test]\n    fn test_raw_table_insert() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hasher = |&value: &i32| value as u64; // A simple hasher\n\n        // Insert elements\n        let bucket1 = table.insert(1, 10, hasher);\n        let bucket2 = table.insert(2, 20, hasher);\n        \n        // Check bucket indices\n        let index1 = unsafe { table.bucket_index(&bucket1) };\n        let index2 = unsafe { table.bucket_index(&bucket2) };\n        \n        // Verify contents\n        assert_eq!(unsafe { bucket1.as_ref() }, &10);\n        assert_eq!(unsafe { bucket2.as_ref() }, &20);\n        \n        // Verify indices range\n        assert!(index1 < table.buckets());\n        assert!(index2 < table.buckets());\n    }\n    \n    #[test]\n    fn test_insert_without_growth() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(2);\n        let hasher = |&value: &i32| value as u64;\n\n        // Insert elements\n        let bucket1 = table.insert(1, 30, hasher);\n        let bucket2 = table.insert(2, 40, hasher);\n        \n        // Verify contents\n        assert_eq!(unsafe { bucket1.as_ref() }, &30);\n        assert_eq!(unsafe { bucket2.as_ref() }, &40);\n        \n        // Initial size should match the number of current insertions\n        assert_eq!(table.len(), 2);\n    }\n\n    #[test]\n    fn test_insert_and_replace() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(2);\n        let hasher = |&value: &i32| value as u64;\n\n        // Insert an element\n        let bucket = table.insert(1, 50, hasher);\n        \n        // Replace value\n        unsafe { bucket.write(60) };\n        \n        // Verify new value\n        assert_eq!(unsafe { bucket.as_ref() }, &60);\n    }\n}\n```", "raw::RawTable::<T, A>::insert_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::allocator::Global;\n\n    #[test]\n    fn test_insert_entry() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hasher = |value: &i32| *value as u64;\n\n        // Insert an element into the table\n        let hash = hasher(&42);\n        let reference = table.insert_entry(hash, 42, hasher);\n        \n        // Check that the reference returned is the same as the inserted value\n        assert_eq!(*reference, 42);\n        \n        // Insert another element into the table\n        let hash2 = hasher(&50);\n        let reference2 = table.insert_entry(hash2, 50, hasher);\n        \n        // Check that the reference returned is the same as the inserted value\n        assert_eq!(*reference2, 50);\n        \n        // Ensure the first value can still be accessed\n        let retrieved_ref = table.get_mut(hash, |&x| x == 42);\n        assert!(retrieved_ref.is_some());\n        assert_eq!(*retrieved_ref.unwrap(), 42);\n        \n        // Ensure the second value can still be accessed\n        let retrieved_ref2 = table.get_mut(hash2, |&x| x == 50);\n        assert!(retrieved_ref2.is_some());\n        assert_eq!(*retrieved_ref2.unwrap(), 50);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_insert_entry_panic() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hasher = |value: &i32| *value as u64;\n        \n        // This should panic as the table is empty and not properly allocated\n        let _ = table.insert_entry(0, 42, hasher);\n    }\n}\n```", "raw::RawTable::<T, A>::insert_in_slot": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_insert_in_slot() {\n        // Create a RawTable with a specific capacity\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        // Insert a value and retrieve the InsertSlot\n        let hash = 42;\n        let value = 10;\n        let insert_slot = unsafe {\n            table.find_or_find_insert_slot(hash, |&x| x == value, |x| x as u64).unwrap_err()\n        };\n\n        // Insert the value in the given insert slot\n        let bucket = unsafe { table.insert_in_slot(hash, insert_slot, value) };\n\n        // Check that the value is correctly inserted\n        assert_eq!(unsafe { bucket.as_ref() }, &value);\n\n        // Check that the bucket index is as expected\n        let index = unsafe { table.bucket_index(&bucket) };\n        assert_eq!(index, insert_slot.index);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_insert_in_slot_invalid_slot() {\n        // Create a RawTable with a specific capacity\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        let invalid_slot = InsertSlot { index: 10 }; // Invalid index\n\n        // Try to insert in an invalid slot, expecting a panic\n        unsafe {\n            table.insert_in_slot(42, invalid_slot, 10);\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::into_allocation": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n    use std::alloc::Layout;\n\n    #[test]\n    fn test_into_allocation_empty() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        let alloc = table.into_allocation();\n        assert!(alloc.is_none());\n    }\n\n    #[test]\n    fn test_into_allocation_singleton() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        table.insert(0, 42, |&x| x); // Insert an element\n        let alloc = table.into_allocation();\n        assert!(alloc.is_none());\n    }\n\n    #[test]\n    fn test_into_allocation_with_data() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        table.insert(0, 42, |&x| x);\n        table.insert(1, 43, |&x| x);\n        let alloc = table.into_allocation();\n        assert!(alloc.is_some());\n        \n        if let Some((ptr, layout, _)) = alloc {\n            assert!(ptr.as_ptr() != std::ptr::null_mut());\n            assert!(layout.size() > 0);\n        }\n    }\n\n    #[test]\n    fn test_into_allocation_multiple() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(8);\n        for i in 0..8 {\n            table.insert(i, i as i32, |&x| x);\n        }\n        let alloc = table.into_allocation();\n        assert!(alloc.is_some());\n        \n        if let Some((ptr, layout, _)) = alloc {\n            assert!(ptr.as_ptr() != std::ptr::null_mut());\n            assert!(layout.size() > 0);\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::into_iter_from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{RawTable, RawIter, RawIntoIter, Bucket};\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_into_iter_from() {\n        unsafe {\n            // Create a new RawTable with a custom allocator.\n            let mut table: RawTable<i32, Global> = RawTable::default();\n            // Insert some values into the table.\n            let items = vec![1, 2, 3, 4, 5];\n            for item in items.iter() {\n                table.insert(0, *item, |x| *x);\n            }\n            // Create a RawIter over the table.\n            let iter = table.iter();\n            // Create a RawIntoIter using into_iter_from.\n            let mut into_iter: RawIntoIter<i32, Global> = table.into_iter_from(iter.clone());\n            \n            // Collect items from the iterator.\n            let mut collected: Vec<i32> = Vec::new();\n            while let Some(item) = into_iter.next() {\n                collected.push(item);\n            }\n            // Check if the collected items match the original items.\n            assert_eq!(collected, items);\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::is_bucket_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_is_bucket_full() {\n        // Create a new RawTable with a known number of buckets\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(8);\n        \n        // Fill the table with the maximum number of elements\n        for i in 0..8 {\n            unsafe {\n                table.insert(0, i, |x| x.hash()); // Insert elements to fill the table\n            }\n        }\n\n        // Check if the buckets are full\n        for i in 0..8 {\n            let is_full = unsafe { table.is_bucket_full(i) };\n            assert!(is_full, \"Bucket {} should be full\", i);\n        }\n        \n        // Insert an additional element to trigger the growth of the table\n        unsafe {\n            table.insert(0, 8, |x| x.hash());\n        }\n\n        // Check if the original buckets remain full\n        for i in 0..8 {\n            let is_full = unsafe { table.is_bucket_full(i) };\n            assert!(is_full, \"Bucket {} should still be full\", i);\n        }\n        \n        // Check if a new bucket is empty\n        let is_full_index = 8;\n        let is_full = unsafe { table.is_bucket_full(is_full_index) };\n        assert!(!is_full, \"Bucket {} should be empty\", is_full_index);\n    }\n}\n```", "raw::RawTable::<T, A>::is_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Global;\n\n    #[test]\n    fn test_raw_table_is_empty() {\n        // Create a new empty RawTable\n        let table: RawTable<i32, Global> = RawTable::new();\n\n        // Assert that the table is empty\n        assert!(table.is_empty());\n\n        // Create a new RawTable with capacity\n        let table_with_capacity = RawTable::with_capacity(10);\n\n        // Assert that the new table with capacity is empty\n        assert!(table_with_capacity.is_empty());\n    }\n    \n    #[test]\n    fn test_raw_table_is_not_empty() {\n        let mut table = RawTable::new();\n\n        // Insert an element\n        unsafe {\n            table.insert(0, 42, |x| x.hash());\n        }\n\n        // Assert that the table is not empty\n        assert!(!table.is_empty());\n    }\n}\n```", "raw::RawTable::<T, A>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_iter() {\n        // Create a new raw table\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n        \n        // Insert elements into the table\n        table.insert(1, 10, |x| *x);\n        table.insert(2, 20, |x| *x);\n        table.insert(3, 30, |x| *x);\n        \n        // Ensure the table has 3 items\n        assert_eq!(table.len(), 3);\n        \n        // Create an unsafe block to call the unsafe iter method\n        unsafe {\n            let iter = table.iter();\n            let mut count = 0;\n\n            // Iterate through items\n            for bucket in iter {\n                assert!(count < table.len());\n                count += 1;\n\n                // Ensure we can read the bucket value\n                let value = bucket.as_ref();\n                assert!(value == &10 || value == &20 || value == &30);\n            }\n            // Ensure we have iterated through all items\n            assert_eq!(count, table.len());\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::iter_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_iter_hash() {\n        unsafe {\n            let mut table: RawTable<i32, Global> = RawTable::new();\n            table.insert(1, 42, |v| *v);\n            table.insert(2, 43, |v| *v);\n            table.insert(3, 44, |v| *v);\n\n            let mut iter = table.iter_hash(3);\n            let mut found = false;\n\n            while let Some(bucket) = iter.next() {\n                let value = bucket.as_ref();\n                if *value == 44 {\n                    found = true;\n                    break;\n                }\n            }\n\n            assert!(found, \"Expected to find value 44 in the iter_hash iterator\");\n        }\n    }\n\n    #[test]\n    fn test_iter_hash_empty() {\n        unsafe {\n            let table: RawTable<i32, Global> = RawTable::new();\n            let iter = table.iter_hash(0);\n            assert!(iter.next().is_none(), \"Expected iter_hash to return None on empty table\");\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_table_len() {\n        let table: RawTable<u32, Global> = RawTable::new(); // Create a new RawTable\n        assert_eq!(table.len(), 0); // Check initial length\n\n        unsafe {\n            // Insert an item\n            table.insert(0, 1, |&val| val); // Assuming the hasher is the identity function\n        }\n        assert_eq!(table.len(), 1); // Check length after inserting one item\n\n        unsafe {\n            // Insert another item\n            table.insert(1, 2, |&val| val);\n        }\n        assert_eq!(table.len(), 2); // Check length after inserting two items\n\n        // Clear the table\n        table.clear();\n        assert_eq!(table.len(), 0); // Check length after clearing\n    }\n}\n```", "raw::RawTable::<T, A>::new_in": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::marker::PhantomData;\n    \n    #[test]\n    fn test_new_in() {\n        // Create a new RawTable with a default allocator\n        let table: RawTable<u32, Global> = RawTable::new_in(Global);\n        \n        // Check that it is initialized correctly\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.buckets(), 1);\n        assert!(table.is_empty());\n        assert_eq!(table.allocation_size(), 0);\n    }\n\n    #[test]\n    fn test_new_in_with_custom_allocator() {\n        // Custom allocator can be replaced with a simple allocator if available\n        struct CustomAllocator;\n        unsafe impl Allocator for CustomAllocator {\n            // Implementation of the allocator methods\n        }\n\n        // Create a new RawTable with a custom allocator\n        let custom: RawTable<u32, CustomAllocator> = RawTable::new_in(CustomAllocator);\n        \n        // Check that it is initialized correctly\n        assert_eq!(custom.len(), 0);\n        assert_eq!(custom.buckets(), 1);\n        assert!(custom.is_empty());\n        assert_eq!(custom.allocation_size(), 0);\n    }\n}\n```", "raw::RawTable::<T, A>::new_uninitialized": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{Fallibility, RawTable};\n    use std::alloc::Global;\n\n    #[test]\n    fn test_new_uninitialized_fallible() {\n        let fallibility = Fallibility::Fallible;\n        let buckets = 16; // Must be a power of two\n        let alloc = Global;\n\n        let result = unsafe { RawTable::<i32, _>::new_uninitialized(alloc, buckets, fallibility) };\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_new_uninitialized_infallible() {\n        let fallibility = Fallibility::Infallible;\n        let buckets = 16; // Must be a power of two\n        let alloc = Global;\n\n        let result = unsafe { RawTable::<i32, _>::new_uninitialized(alloc, buckets, fallibility) };\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_new_uninitialized_infallible_panic_on_overflow() {\n        let fallibility = Fallibility::Infallible;\n        let buckets = 1 << 30; // Large bucket count to cause panic\n        let alloc = Global;\n\n        unsafe { RawTable::<i32, _>::new_uninitialized(alloc, buckets, fallibility) };\n    }\n}\n```", "raw::RawTable::<T, A>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_remove() {\n        // Set up the RawTable\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Insert an item\n        let hash: u64 = 1; // example hash\n        let bucket = table.insert(hash, 42, |x| *x as u64); // insert an item to the table\n\n        unsafe {\n            // Remove the item\n            let (item, insert_slot) = table.remove(bucket);\n            \n            // Verify the removed item\n            assert_eq!(item, 42);\n            \n            // Verify the insert slot index\n            assert_eq!(insert_slot.index, table.bucket_index(&bucket)); // Check the index\n        }\n    }\n\n    #[test]\n    fn test_remove_non_existing() {\n        // Set up the RawTable\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Insert an item\n        let hash: u64 = 1; // example hash\n        let bucket = table.insert(hash, 42, |x| *x as u64); // insert an item to the table\n\n        unsafe {\n            // Remove the item\n            let (item, insert_slot) = table.remove(bucket);\n            assert_eq!(item, 42);\n\n            // Attempt to remove the same item again\n            // The behavior here depends on the state of the table after the first remove\n            // This should ideally return an error or panic, ensure that's properly handled\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_remove_entry() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash = 42;\n\n        // Try to remove from an empty table\n        let result = table.remove_entry(hash, |&x| x == 5);\n        assert!(result.is_none());\n\n        // Insert an element\n        let _bucket = table.insert(hash, 5, |x| *x as u64);\n        // Remove the element\n        let result = table.remove_entry(hash, |&x| x == 5);\n        assert_eq!(result, Some(5));\n\n        // Check that the table is empty now\n        assert!(table.is_empty());\n    }\n\n    #[test]\n    fn test_remove_non_existing_entry() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash1 = 42;\n        let hash2 = 43;\n\n        // Insert an element\n        let _bucket1 = table.insert(hash1, 5, |x| *x as u64);\n        // Try to remove a non-existing element\n        let result = table.remove_entry(hash2, |&x| x == 10);\n        assert!(result.is_none()); // Should return None\n    }\n\n    #[test]\n    fn test_remove_entry_with_custom_eq() {\n        let mut table: RawTable<&str, Global> = RawTable::new();\n        let hash1 = 42;\n\n        // Insert a string\n        let _bucket = table.insert(hash1, \"hello\", |x| hash(x));\n\n        // Remove the string using a custom equality function\n        let result = table.remove_entry(hash1, |&x| x == \"hello\");\n        assert_eq!(result, Some(\"hello\"));\n\n        // Check that the table is empty now\n        assert!(table.is_empty());\n    }\n\n    fn hash<T: std::hash::Hash>(item: &T) -> u64 {\n        use std::hash::{Hasher, BuildHasherDefault};\n        let mut hasher = BuildHasherDefault::<std::collections::hash_map::DefaultHasher>::default();\n        item.hash(&mut hasher);\n        hasher.finish()\n    }\n}\n```", "raw::RawTable::<T, A>::replace_bucket_with": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_replace_bucket_with_function() {\n        // Setup a new raw table\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Insert an element\n        let hash = 42;\n        let bucket = table.insert(hash, 10, |x| x);\n        \n        // Replace the bucket content\n        let result = unsafe {\n            table.replace_bucket_with(bucket.clone(), |value| {\n                Some(value + 1)  // Replace with the incremented value\n            })\n        };\n\n        // Verify the result\n        assert!(result, \"Expected bucket to still contain an element\");\n        assert_eq!(unsafe { *bucket.as_ref() }, 11, \"Expected bucket value to be updated to 11\");\n\n        // Attempt to replace and remove the element\n        let removed = unsafe {\n            table.replace_bucket_with(bucket.clone(), |value| {\n                None  // Replace with None, effectively removing the value\n            })\n        };\n\n        // Verify the result\n        assert!(!removed, \"Expected bucket to be empty after removal\");\n        \n        // Check if the bucket is empty\n        let is_empty = unsafe {\n            !table.is_bucket_full(table.bucket_index(&bucket))\n        };\n        assert!(is_empty, \"Expected bucket to be empty\");\n    }\n}\n```", "raw::RawTable::<T, A>::reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_reserve() {\n        let mut table = RawTable::<usize, Global>::new();\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.capacity(), 0);\n\n        // Reserve space for 5 elements\n        table.reserve(5, |&x| x as u64);\n        assert!(table.capacity() >= 5);\n    }\n\n    #[test]\n    fn test_reserve_exceeds_growth() {\n        let mut table = RawTable::<usize, Global>::new();\n        table.reserve(1, |&x| x as u64);\n\n        // Initially, capacity should be 1 after the reserve call\n        assert!(table.capacity() >= 1);\n        \n        // Reserve space for more elements than the current growth left\n        let initial_capacity = table.capacity();\n        table.reserve(initial_capacity + 1, |&x| x as u64);\n        \n        // Capacity should have increased\n        assert!(table.capacity() > initial_capacity);\n    }\n\n    #[test]\n    fn test_reserve_no_capacity_growth() {\n        let mut table = RawTable::<usize, Global>::new();\n        table.reserve(0, |&x| x as u64);\n        \n        // Reserve 0 should not change the capacity\n        assert_eq!(table.capacity(), 0);\n    }\n}\n```", "raw::RawTable::<T, A>::reserve_rehash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_reserve_rehash_increase_capacity() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(2);\n        let initial_capacity = table.capacity();\n        let additional = 2;\n\n        unsafe {\n            let result = table.reserve_rehash(additional, |&x| x as u64, Fallibility::Infallible);\n            assert!(result.is_ok());\n            assert!(table.capacity() > initial_capacity);\n        }\n    }\n\n    #[test]\n    fn test_reserve_rehash_capacity_overflow() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(1);\n        let additional = usize::MAX; // This will cause a capacity overflow\n\n        unsafe {\n            let result = table.reserve_rehash(additional, |&x| x as u64, Fallibility::Fallible);\n            assert!(result.is_err());\n            if let Err(TryReserveError::CapacityOverflow) = result {\n                // Expected\n            } else {\n                panic!(\"Expected CapacityOverflow error\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_reserve_rehash_alloc_error() {\n        use std::alloc::Layout;\n\n        struct TestAllocator;\n        unsafe impl Allocator for TestAllocator {\n            unsafe fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, AllocError> {\n                Err(AllocError) // Simulating an allocation error\n            }\n\n            unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {\n                // No-op for deallocation\n            }\n        }\n\n        let mut table: RawTable<i32, TestAllocator> = RawTable::with_capacity(1);\n        let additional = 1;\n\n        unsafe {\n            let result = table.reserve_rehash(additional, |&x| x as u64, Fallibility::Fallible);\n            assert!(result.is_err());\n            if let Err(TryReserveError::AllocError { layout }) = result {\n                // Expected: here you could check the layout if needed\n            } else {\n                panic!(\"Expected AllocError\");\n            }\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::resize": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_resize() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        // Inserting data to the table\n        let values = [1, 2, 3, 4];\n        for val in &values {\n            unsafe {\n                let _ = table.insert(0, *val, |&v| v as u64);\n            }\n        }\n\n        // Current size and items in the table\n        let current_capacity = table.capacity();\n        let current_items = table.len();\n\n        // Resizing to a larger capacity\n        unsafe {\n            let result = table.resize(8, |&v| v as u64, Fallibility::Fallible);\n            assert!(result.is_ok());\n        }\n\n        // Check if the items have been preserved and the capacity has changed\n        assert_eq!(table.len(), current_items);\n        assert!(table.capacity() > current_capacity);\n\n        // Resizing to a smaller capacity\n        unsafe {\n            let result = table.resize(2, |&v| v as u64, Fallibility::Fallible);\n            assert!(result.is_ok());\n        }\n\n        // Check if the items have been preserved and the capacity has changed\n        assert_eq!(table.len(), current_items);\n        assert_eq!(table.capacity(), 2);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_resize_to_zero_capacity() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        // Inserting data to the table\n        unsafe {\n            let _ = table.insert(0, 1, |&v| v as u64);\n        }\n\n        // Attempt to resize to zero capacity\n        unsafe {\n            let _ = table.resize(0, |&v| v as u64, Fallibility::Fallible);\n        }\n    }\n\n    #[test]\n    fn test_resize_without_alloc() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(2);\n\n        // Inserting data to the table\n        unsafe {\n            let _ = table.insert(0, 1, |&v| v as u64);\n        }\n\n        // Resize to a larger capacity without allocating\n        unsafe {\n            let result = table.resize(4, |&v| v as u64, Fallibility::Infallible);\n            assert!(result.is_ok());\n            assert_eq!(table.capacity(), 4);\n        }\n    }\n\n    #[test]\n    fn test_resize_with_failures() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        // Check for capacity overflow\n        unsafe {\n            let result = table.resize(usize::MAX, |&v| v as u64, Fallibility::Fallible);\n            assert!(result.is_err());\n        }\n    }\n}\n```", "raw::RawTable::<T, A>::shrink_to": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_shrink_to_empty() {\n        let mut table: RawTable<u64, Global> = RawTable::new();\n        table.shrink_to(0, |x| *x); // should not panic or change state\n        assert_eq!(table.len(), 0);\n        assert!(table.is_empty());\n    }\n\n    #[test]\n    fn test_shrink_to_non_empty() {\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(10);\n        table.insert(1, 10, |x| *x);\n        table.insert(2, 20, |x| *x);\n        table.shrink_to(1, |x| *x); // should shrink and maintain at least one element\n        assert_eq!(table.len(), 2);\n        assert!(table.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_shrink_to_remove_all() {\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(5);\n        table.insert(1, 10, |x| *x);\n        table.insert(2, 20, |x| *x);\n        table.shrink_to(0, |x| *x); // should remove all elements\n        assert_eq!(table.len(), 0);\n        assert!(table.is_empty());\n    }\n\n    #[test]\n    fn test_shrink_to_min_size() {\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(5);\n        table.insert(1, 10, |x| *x);\n        table.insert(2, 20, |x| *x);\n        table.shrink_to(1, |x| *x); // should maintain at least 1 element\n        assert_eq!(table.len(), 2);\n    }\n\n    #[test]\n    fn test_shrink_to_inplace() {\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(10);\n        for i in 0..5 {\n            table.insert(1 + i, i, |x| *x);\n        }\n        table.shrink_to(3, |x| *x); // should not shrink below current size\n        assert_eq!(table.len(), 5);\n    }\n\n    #[test]\n    fn test_shrink_to_below_capacity() {\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(20);\n        for i in 0..10 {\n            table.insert(1 + i, i, |x| *x);\n        }\n        table.shrink_to(5, |x| *x); // should not shrink below current size\n        assert_eq!(table.len(), 10);\n    }\n}\n```", "raw::RawTable::<T, A>::try_reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_try_reserve() {\n        let mut table: RawTable<u64, Global> = RawTable::default();\n\n        // Initially, the table can hold 0 elements, we expect an Ok(()) for 0 reserves\n        let result = table.try_reserve(0, |&x| x);\n        assert!(result.is_ok());\n\n        // Reserve space for 1 item, which should succeed since growth_left is initially >= 1\n        let result = table.try_reserve(1, |&x| x);\n        assert!(result.is_ok());\n\n        // This assumes that the initial growth_left is 0 so we expect an error\n        // Trying to reserve 10 will fail initially if the table does not support it\n        let result = table.try_reserve(10, |&x| x);\n        assert!(result.is_err());\n\n        // After inserting 1 item, growth_left should allow for further inserts\n        table.insert(0, 42, |&x| x);\n        let result = table.try_reserve(5, |&x| x);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_reserve_with_multiple_reserves() {\n        let mut table: RawTable<u64, Global> = RawTable::default();\n\n        // Reserve space for 2 items, which should initially succeed\n        let result = table.try_reserve(2, |&x| x);\n        assert!(result.is_ok());\n\n        // Reserve space for 5 items, which should also succeed\n        let result = table.try_reserve(5, |&x| x);\n        assert!(result.is_ok());\n\n        // Reserve with amount larger than currently available\n        let result = table.try_reserve(10, |&x| x);\n        assert!(result.is_err());\n\n        // Insert elements to ensure growth_left is updated\n        table.insert(0, 42, |&x| x);\n        table.insert(0, 43, |&x| x);\n\n        // After inserting items, we should be able to reserve more space\n        let result = table.try_reserve(3, |&x| x);\n        assert!(result.is_ok());\n    }\n}\n```", "raw::RawTable::<T, A>::with_capacity_in": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_with_capacity_in() {\n        let capacity = 10;\n        let allocator = Global;\n\n        // Create a RawTable with specified capacity\n        let table: RawTable<i32, Global> = RawTable::with_capacity_in(capacity, allocator);\n\n        // Assert that the table has the expected properties\n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= capacity);\n        assert!(table.buckets() >= 1);\n    }\n}\n```", "raw::RawTable::<T>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_raw_table_new() {\n        // Create a new RawTable\n        let table: RawTable<i32> = RawTable::new();\n\n        // Check if the table is empty\n        assert!(table.is_empty());\n        \n        // Check the number of buckets\n        assert_eq!(table.buckets(), 1);\n        \n        // Check the capacity\n        assert_eq!(table.capacity(), 1);\n        \n        // Check the length\n        assert_eq!(table.len(), 0);\n    }\n}\n```", "raw::RawTable::<T>::with_capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_with_capacity() {\n        let capacity = 10;\n        let table: RawTable<u32> = RawTable::with_capacity(capacity);\n\n        // Ensure that the table is initialized with the correct capacity\n        assert_eq!(table.capacity(), 10);\n        assert!(table.len() == 0);\n        assert!(table.buckets() > 0);\n    }\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let capacity = 0;\n        let table: RawTable<u32> = RawTable::with_capacity(capacity);\n\n        // Ensure that the table capacity is 0 and it is empty\n        assert_eq!(table.capacity(), 0);\n        assert!(table.len() == 0);\n    }\n\n    #[test]\n    fn test_with_capacity_non_zero() {\n        let capacity = 15;\n        let table: RawTable<u32> = RawTable::with_capacity(capacity);\n\n        // Ensure that the table is initialized with the correct capacity\n        assert_eq!(table.capacity(), 15);\n        assert!(table.len() == 0);\n        assert!(table.buckets() > 0);\n    }\n}\n```", "raw::RawTableInner::allocation_info": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_allocation_info() {\n        let layout = TableLayout::default(); // Assume a valid default layout\n        let allocator = System; // Using the global allocator\n        let capacity = 8; // Assume a capacity of 8\n        let mut table = unsafe { RawTableInner::fallible_with_capacity(&allocator, layout, capacity, Fallibility::Infallible).unwrap() };\n        \n        // Access the allocation info\n        let (ptr, alloc_layout) = unsafe { table.allocation_info(layout) };\n\n        // Verify the validity of the pointer\n        assert!(!ptr.as_ptr().is_null());\n\n        // Verify the layout (may need specific assertions depending on TableLayout)\n        assert_eq!(alloc_layout.size(), layout.size());\n    }\n}\n```", "raw::RawTableInner::allocation_size_or_zero": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_allocation_size_or_zero_with_empty_singleton() {\n        let table_layout = TableLayout::default(); // Adjust with real default or use appropriate layout\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, table_layout, 2, Fallibility::Infallible)\n                .expect(\"Failed to create RawTableInner\")\n        };\n        \n        // Assuming that newly created tables with 0 elements are empty singletons\n        assert_eq!(unsafe { raw_table.allocation_size_or_zero(table_layout) }, 0);\n    }\n\n    #[test]\n    fn test_allocation_size_or_zero_with_non_empty() {\n        let table_layout = TableLayout::default(); // Adjust with real default or use appropriate layout\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, table_layout, 2, Fallibility::Infallible)\n                .expect(\"Failed to create RawTableInner\")\n        };\n\n        // Manually simulate insertion and state\n        let index = 0; // Use a valid index\n        unsafe {\n            raw_table.set_ctrl(index, Tag::full(0)); // Simulate a full bucket\n            raw_table.items = 1; // Simulate that there's 1 item\n        }\n\n        // Assuming allocation_info method returns a valid size for the non-empty case\n        let allocation_size = unsafe { raw_table.allocation_size_or_zero(table_layout) };\n        assert!(allocation_size > 0, \"Expected non-zero allocation size for non-empty table.\");\n    }\n}\n```", "raw::RawTableInner::bucket": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_bucket_valid_index() {\n        let mut table_inner = RawTableInner {\n            bucket_mask: 3, // four buckets (0-3)\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n\n        // Ensure we can safely call bucket on a valid index\n        let index = 2;\n        let bucket = unsafe { table_inner.bucket::<u32>(index) };\n        assert!(!bucket.as_ptr().is_null());\n    }\n\n    #[test]\n    #[should_panic(expected = \"assertion failed: index < self.buckets()\")]\n    fn test_bucket_index_out_of_bounds() {\n        let table_inner = RawTableInner {\n            bucket_mask: 3, // four buckets (0-3)\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n\n        // This should panic\n        let _ = unsafe { table_inner.bucket::<u32>(4) };\n    }\n\n    #[test]\n    fn test_bucket_zero_index_on_unallocated() {\n        let table_inner = RawTableInner {\n            bucket_mask: 0, // simulating not allocated\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n\n        let index = 0;\n        let bucket = unsafe { table_inner.bucket::<u32>(index) };\n        assert!(!bucket.as_ptr().is_null());\n    }\n}\n```", "raw::RawTableInner::bucket_ptr": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_bucket_ptr_valid() {\n        unsafe {\n            let alloc = &Global;\n            let layout = /* Appropriate layout based on your implementation */;\n            let mut table = RawTableInner::with_capacity(alloc, layout, 4);\n\n            let size_of: usize = std::mem::size_of::<u64>(); // Example type\n            let index = 0;\n            let ptr = table.bucket_ptr(index, size_of);\n            assert!(!ptr.is_null());\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_bucket_ptr_invalid_index() {\n        unsafe {\n            let alloc = &Global;\n            let layout = /* Appropriate layout based on your implementation */;\n            let mut table = RawTableInner::with_capacity(alloc, layout, 4);\n\n            let size_of: usize = std::mem::size_of::<u64>(); // Example type\n            let index = 5; // Invalid index\n            let _ptr = table.bucket_ptr(index, size_of);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_bucket_ptr_unallocated_table() {\n        unsafe {\n            let table = RawTableInner {\n                bucket_mask: 0,\n                // Add other fields with appropriate initial values\n                ctrl: NonNull::dangling(),\n                growth_left: 0,\n                items: 0,\n            };\n\n            let size_of: usize = std::mem::size_of::<u64>(); // Example type\n            let _ptr = table.bucket_ptr(0, size_of);\n        }\n    }\n}\n```", "raw::RawTableInner::buckets": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_buckets() {\n        let raw_table_inner = RawTableInner {\n            bucket_mask: 7, // Example bucket_mask, corresponds to 8 buckets\n            ctrl: NonNull::dangling(), // Dummy non-null pointer for testing\n            growth_left: 0,\n            items: 0,\n        };\n\n        let bucket_count = raw_table_inner.buckets();\n        assert_eq!(bucket_count, 8, \"Expected 8 buckets for bucket_mask 7\");\n        \n        let raw_table_inner_empty = RawTableInner {\n            bucket_mask: 0, // Should correspond to 1 bucket\n            ctrl: NonNull::dangling(), // Dummy non-null pointer for testing\n            growth_left: 0,\n            items: 0,\n        };\n\n        let bucket_count_empty = raw_table_inner_empty.buckets();\n        assert_eq!(bucket_count_empty, 1, \"Expected 1 bucket for bucket_mask 0\");\n    }\n}\n```", "raw::RawTableInner::clear_no_drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clear_no_drop() {\n        // Create an instance of RawTableInner\n        let mut raw_table: RawTableInner = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible).unwrap()\n        };\n\n        // Prepopulate the table with 2 items\n        raw_table.items = 2;\n\n        // Confirm initial state\n        assert_eq!(raw_table.items, 2);\n        \n        // Call the function to clear the table\n        raw_table.clear_no_drop();\n\n        // Confirm the state after clearing\n        assert_eq!(raw_table.items, 0);\n        assert_eq!(raw_table.growth_left, bucket_mask_to_capacity(raw_table.bucket_mask));\n    }\n}\n```", "raw::RawTableInner::ctrl": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_ctrl() {\n        // Setup a RawTableInner with known parameters\n        let bucket_mask = 3; // 4 buckets\n        let buckets = bucket_mask + 1; // 4\n        let ctrl_array: Vec<Tag> = vec![Tag::EMPTY; bucket_mask + 1 + Group::WIDTH];\n        let ctrl_ptr = NonNull::new(ctrl_array.as_ptr() as *mut u8).unwrap();\n\n        let raw_table = RawTableInner {\n            bucket_mask,\n            ctrl: ctrl_ptr,\n            growth_left: 10,\n            items: 0,\n        };\n\n        // Test ctrl with a valid index\n        let index = 0; // valid index\n        unsafe {\n            let ctrl_ptr = raw_table.ctrl(index);\n            assert_eq!(*ctrl_ptr, Tag::EMPTY);\n        }\n\n        // Test ctrl with an index greater than bucket_mask + 1 + Group::WIDTH\n        let invalid_index = bucket_mask + 1 + Group::WIDTH;\n        unsafe {\n            std::panic::catch_unwind(|| {\n                let _ = raw_table.ctrl(invalid_index);\n            })\n            .unwrap_err(); // This should panic\n        }\n\n        // Test with an index equal to bucket_mask + 1 + Group::WIDTH\n        let just_valid_index = bucket_mask + 1 + Group::WIDTH;\n        unsafe {\n            let ctrl_ptr = raw_table.ctrl(just_valid_index);\n            assert_eq!(ctrl_ptr, ctrl_array.as_ptr().add(just_valid_index).cast());\n        }\n    }\n}\n```", "raw::RawTableInner::ctrl_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_ctrl_slice() {\n        let buckets = 8; // Example number of buckets (must be a power of two).\n        \n        // Create a dummy allocator and layout (assuming appropriate types).\n        let allocator = /* Your allocator here */;\n        let layout = /* Your layout here */;\n        \n        // Create a new RawTableInner with specified buckets\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&allocator, layout, buckets, Fallibility::Infallible)\n                .expect(\"Failed to create RawTableInner\")\n        };\n\n        // Fill the control bytes with EMPTY tags\n        unsafe {\n            raw_table.ctrl_slice().fill(Tag::EMPTY);\n        }\n\n        // Get the control slice and verify the contents\n        let ctrl_slice = unsafe { raw_table.ctrl_slice() };\n\n        // Check if the control slice is initialized correctly\n        assert_eq!(ctrl_slice.len(), raw_table.num_ctrl_bytes());\n        assert!(ctrl_slice.iter().all(|&tag| tag == Tag::EMPTY));\n        \n        // Set a control tag to see if it reflects correctly\n        unsafe {\n            raw_table.ctrl(0).write(Tag::full(42)); // Set a control tag\n        }\n\n        assert_eq!(unsafe { *raw_table.ctrl(0) }, Tag::full(42));\n    }\n}\n```", "raw::RawTableInner::data_end": "```rust\n#[cfg(test)]\nmod tests {\n    use std::ptr::NonNull;\n    use super::*;\n\n    #[test]\n    fn test_data_end() {\n        // Setup\n        let buckets = 8; // Example bucket size\n        let alloc = std::alloc::System; // Example allocator (change if necessary)\n        let table_layout = TableLayout::new(); // Set up the table layout based on requirements\n        let mut raw_table_inner = RawTableInner::with_capacity(&alloc, table_layout, buckets);\n\n        // The control pointer must not be null\n        let data_end_ptr: NonNull<u8> = raw_table_inner.data_end::<u8>();\n        assert!(!data_end_ptr.as_ptr().is_null());\n\n        // We can check if the pointer is properly aligned, but there is no guarantee we can access this memory safely\n        // (the internal data structure is not initialized, but we can assume control is set)\n        let control_ptr: *mut u8 = raw_table_inner.ctrl.as_ptr();\n\n        // Validate the pointer arithmetic\n        assert_eq!(data_end_ptr.as_ptr() as usize, control_ptr as usize);\n    }\n}\n```", "raw::RawTableInner::drop_elements": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use crate::layout::TableLayout;\n\n    #[test]\n    fn test_drop_elements_empty() {\n        unsafe {\n            let mut raw_table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible).unwrap();\n            raw_table.items = 0;\n            raw_table.drop_elements::<u32>();\n            // Should not panic, as items is 0\n        }\n    }\n\n    #[test]\n    fn test_drop_elements_non_empty() {\n        unsafe {\n            let mut raw_table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible).unwrap();\n            raw_table.items = 1;\n            // Mock an inserted item\n            raw_table.ctrl = NonNull::new_unchecked(std::ptr::null_mut()); // this would ideally be the memory where your items would be\n            raw_table.drop_elements::<u32>();\n            // Should call the drop for each item, so the test doesn't panic\n        }\n    }\n\n    #[test]\n    fn test_drop_elements_needs_drop() {\n        struct DropMe;\n        impl Drop for DropMe {\n            fn drop(&mut self) {\n                // drop panics\n                panic!(\"Dropped\");\n            }\n        }\n\n        unsafe {\n            let mut raw_table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible).unwrap();\n            raw_table.items = 1;\n            // We need a memory block where the DropMe type is stored\n            // Let's assume we correctly allocated memory for the items\n            raw_table.ctrl = NonNull::new_unchecked(std::ptr::null_mut()); // Mock the control structure\n            // raw_table.items would be 1, we will drop and expect a panic\n            std::panic::set_hook(Box::new(|_| {\n                // We expect a panic here\n            }));\n            raw_table.drop_elements::<DropMe>();\n        }\n    }\n\n    #[test]\n    fn test_drop_elements_no_needs_drop() {\n        unsafe {\n            let mut raw_table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible).unwrap();\n            raw_table.items = 1;\n            raw_table.drop_elements::<u32>(); // Should not panic, as u32 does not need drop\n        }\n    }\n}\n```", "raw::RawTableInner::drop_inner_table": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_drop_inner_table_empty() {\n        let mut raw_table_inner = RawTableInner {\n            bucket_mask: 0,\n            ctrl: NonNull::new(std::ptr::null_mut()).unwrap(),\n            growth_left: 0,\n            items: 0,\n        };\n        let layout = TableLayout::default(); // Replace with actual default layout\n        unsafe {\n            raw_table_inner.drop_inner_table::<u8, Global>(&Global, layout);\n        }\n    }\n\n    #[test]\n    fn test_drop_inner_table_with_elements() {\n        let mut raw_table_inner = RawTableInner {\n            bucket_mask: 3,\n            ctrl: NonNull::new(Box::into_raw(Box::new([0u8; 4]))).unwrap(),\n            growth_left: 1,\n            items: 2,\n        };\n        let layout = TableLayout::default(); // Replace with actual default layout\n        unsafe {\n            raw_table_inner.drop_inner_table::<u8, Global>(&Global, layout);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_drop_inner_table_panic_on_double_drop() {\n        let mut raw_table_inner = RawTableInner {\n            bucket_mask: 3,\n            ctrl: NonNull::new(Box::into_raw(Box::new([0u8; 4]))).unwrap(),\n            growth_left: 1,\n            items: 2,\n        };\n        let layout = TableLayout::default(); // Replace with actual default layout\n        unsafe {\n            raw_table_inner.drop_inner_table::<u8, Global>(&Global, layout);\n            raw_table_inner.drop_inner_table::<u8, Global>(&Global, layout);\n        }\n    }\n}\n```", "raw::RawTableInner::erase": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_erase_bucket() {\n        unsafe {\n            // Create a new RawTableInner with at least one bucket\n            let mut table = RawTableInner::with_capacity(&Global, TableLayout::default(), 4);\n            let index = 0; // Assuming we want to erase the first index\n\n            // Initialize control bytes to FULL\n            table.set_ctrl(index, Tag::FULL);\n            table.items = 1;\n\n            // Ensure the bucket is full before erasing\n            assert!(table.is_bucket_full(index));\n\n            // Perform the erase operation\n            table.erase(index);\n\n            // Assert the control byte at the index is now EMPTY or DELETED\n            assert!(!table.is_bucket_full(index));\n            assert_eq!(table.items, 0);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_erase_invalid_index() {\n        unsafe {\n            let mut table = RawTableInner::with_capacity(&Global, TableLayout::default(), 4);\n            let index = 10; // Invalid index\n\n            // Attempt to erase at an invalid index, should panic\n            table.erase(index);\n        }\n    }\n\n    #[test]\n    fn test_erase_non_full_bucket() {\n        unsafe {\n            let mut table = RawTableInner::with_capacity(&Global, TableLayout::default(), 4);\n            let index = 0;\n\n            // Initialize control byte to EMPTY\n            table.set_ctrl(index, Tag::EMPTY);\n            table.items = 1;\n\n            // Perform erase operation on a non-full bucket\n            table.erase(index);\n\n            // Assert that items is decremented\n            assert_eq!(table.items, 0);\n        }\n    }\n}\n```", "raw::RawTableInner::fallible_with_capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::alloc::Layout;\n    use hashbrown::raw::{Fallibility, TableLayout, RawTableInner};\n    use std::alloc::AllocErr;\n    \n    #[test]\n    fn test_fallible_with_capacity_zero_capacity() {\n        let alloc = &Global;\n        let layout = TableLayout::new::<u8>();\n        let result = RawTableInner::fallible_with_capacity(alloc, layout, 0, Fallibility::Fallible);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_fallible_with_capacity_non_zero_capacity() {\n        let alloc = &Global;\n        let layout = TableLayout::new::<u8>();\n        let capacity = 4; // change this as needed\n        let result = RawTableInner::fallible_with_capacity(alloc, layout, capacity, Fallibility::Fallible);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_fallible_with_capacity_capacity_overflow() {\n        let alloc = &Global;\n        let layout = TableLayout::new::<u8>();\n        let capacity = usize::MAX; // This should trigger a capacity overflow error\n        let result = RawTableInner::fallible_with_capacity(alloc, layout, capacity, Fallibility::Fallible);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_fallible_with_capacity_infallible_capacity_overflow() {\n        let alloc = &Global;\n        let layout = TableLayout::new::<u8>();\n        let capacity = usize::MAX; // This should panic on overflow\n        let _ = RawTableInner::fallible_with_capacity(alloc, layout, capacity, Fallibility::Infallible);\n    }\n}\n```", "raw::RawTableInner::find_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_find_inner() {\n        // Create an allocator and raw table inner instance\n        let allocator = System;\n        let table_layout = TableLayout::default();\n        let mut raw_table = unsafe {\n            RawTableInner::with_capacity(&allocator, table_layout, 4)\n        };\n\n        // Simulate adding items to the raw table\n        let hash = 42; // Arbitrary hash value\n        unsafe {\n            raw_table.set_ctrl_hash(0, Tag::full(hash));\n            raw_table.set_ctrl_hash(1, Tag::full(hash));\n        }\n\n        // Define an equality function\n        let mut eq = |index| {\n            // Match against index for the test\n            index == 0 || index == 1\n        };\n\n        // Test find function\n        unsafe {\n            let found_0 = raw_table.find_inner(hash, &mut eq);\n            assert_eq!(found_0, Some(0));\n            let found_1 = raw_table.find_inner(hash, &mut eq);\n            assert_eq!(found_1, Some(1));\n            let found_none = raw_table.find_inner(99, &mut eq); // Try a hash that isn't present\n            assert_eq!(found_none, None);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_find_inner_panic_on_empty_table() {\n        let allocator = System;\n        let table_layout = TableLayout::default();\n        let raw_table = unsafe {\n            RawTableInner::with_capacity(&allocator, table_layout, 0)\n        };\n\n        // Defining an equality function\n        let mut eq = |_| false;\n\n        // This should panic since there are no empty buckets\n        unsafe {\n            let _ = raw_table.find_inner(0, &mut eq);\n        }\n    }\n}\n```", "raw::RawTableInner::find_insert_slot": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_find_insert_slot() {\n        unsafe {\n            let capacity = 8; // Must be power of two\n            let mut raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), capacity);\n            raw_table.ctrl_slice().fill_empty(); // Initialize with empty control bytes\n\n            // Simulate inserting elements to create an empty slot\n            let hash1 = 1u64; // Any arbitrary hash for testing\n            let hash2 = 2u64;\n\n            let slot1 = raw_table.prepare_insert_slot(hash1);\n            raw_table.ctrl(slot1.0).write(Tag::full(hash1));\n\n            let slot2 = raw_table.prepare_insert_slot(hash2);\n            raw_table.ctrl(slot2.0).write(Tag::full(hash2));\n\n            // Make one slot empty again (simulated deletion)\n            raw_table.ctrl(slot1.0).write(Tag::empty());\n\n            // Now call `find_insert_slot` and expect to find an empty slot where we deleted previously\n            let insert_slot = raw_table.find_insert_slot(0);\n            assert!(insert_slot.index == slot1.index); // Should find the previously empty slot\n        }\n    }\n\n    #[test]\n    fn test_find_insert_slot_empty_table() {\n        unsafe {\n            let capacity = 8; // Must be power of two\n            let mut raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), capacity);\n            raw_table.ctrl_slice().fill_empty(); // Initialize with empty control bytes\n\n            // The table is empty, so we should find an empty slot\n            let insert_slot = raw_table.find_insert_slot(0);\n            assert!(insert_slot.index < raw_table.buckets());\n        }\n    }\n}\n```", "raw::RawTableInner::find_insert_slot_in_group": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_find_insert_slot_in_group() {\n        // Set up a mock `RawTableInner` with a known bucket mask and a group\n        let bucket_mask = 7; // example mask\n        let group = Group::static_empty(); // mock empty group\n        let probe_seq = ProbeSeq { pos: 0, stride: 0 };\n\n        let raw_table_inner = RawTableInner {\n            bucket_mask,\n            ctrl: NonNull::new(std::ptr::null_mut()).unwrap(), // mock ctrl\n            growth_left: 0,\n            items: 0,\n        };\n\n        // Mock the group to return a specific BitMask\n        let bitmask = group.match_empty_or_deleted().lowest_set_bit();\n        let expected_index = (probe_seq.pos + bitmask.unwrap_or(0)) & bucket_mask;\n\n        // Call the target function\n        let result = raw_table_inner.find_insert_slot_in_group(&group, &probe_seq);\n\n        // Check the result\n        assert_eq!(result, Some(expected_index), \"Expected index: {:?}\", expected_index);\n    }\n\n    #[test]\n    fn test_find_insert_slot_in_group_none() {\n        // Set up a mock `RawTableInner` and group with no empty slots\n        let bucket_mask = 7; // example mask with no empty slots\n        let group = Group::static_empty(); // For a full group, no empty sections\n        let probe_seq = ProbeSeq { pos: 0, stride: 0 };\n\n        let raw_table_inner = RawTableInner {\n            bucket_mask,\n            ctrl: NonNull::new(std::ptr::null_mut()).unwrap(), // mock ctrl\n            growth_left: 0,\n            items: 0,\n        };\n\n        // Call the target function\n        let result = raw_table_inner.find_insert_slot_in_group(&group, &probe_seq);\n\n        // Check the result\n        assert_eq!(result, None, \"Expected None when no slots available\");\n    }\n}\n```", "raw::RawTableInner::find_or_find_insert_slot_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_find_or_find_insert_slot_inner() {\n        // Assuming you have a valid instance of RawTableInner\n        // For testing purposes, we will need to create a mock structure\n        // since RawTableInner is not trivially constructible.\n\n        let alloc = &Global; // Using the global allocator\n        let table_layout = TableLayout::default(); // Assuming a default layout\n        let capacity = 8; // A sample capacity\n        let mut table = unsafe {\n            RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Mocking the control bytes and adding elements to simulate the table\n        // (Control bytes should be initialized to a valid state)\n        unsafe {\n            table.ctrl_slice().fill(Tag::EMPTY);\n        }\n\n        let hash = 42; // Some hash value\n        let mut eq = |index: usize| -> bool {\n            index == 0 // Assuming the item we expect is at index 0\n        };\n\n        // Performing the operation\n        let result = unsafe {\n            table.find_or_find_insert_slot_inner(hash, &mut eq)\n        };\n\n        // Check the result\n        match result {\n            Ok(index) => {\n                assert_eq!(index, 0, \"Expected to find element at index 0\");\n            }\n            Err(insert_slot) => {\n                assert!(false, \"Expected to find element, but got insert slot: {:?}\", insert_slot);\n            }\n        }\n    }\n\n    #[test]\n    fn test_find_or_find_insert_slot_inner_with_no_empty_slot() {\n        // Assuming a scenario where there are no empty slots\n        let alloc = &Global;\n        let table_layout = TableLayout::default();\n        let capacity = 8;\n        let mut table = unsafe {\n            RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Fill the table to simulate a full state\n        unsafe {\n            table.ctrl_slice().fill(Tag::FULL);\n        }\n\n        let hash = 42;\n        let mut eq = |index: usize| -> bool {\n            index == 8 // Simulating a case where hash leads to a non-existing index\n        };\n\n        // Performing the operation\n        let result = unsafe {\n            table.find_or_find_insert_slot_inner(hash, &mut eq)\n        };\n\n        // Check the result\n        match result {\n            Ok(_) => {\n                assert!(false, \"Expected no index found, but got a valid index\");\n            }\n            Err(insert_slot) => {\n                assert!(insert_slot.index <= table.buckets(), \"Expected insert slot index to be valid\");\n            }\n        }\n    }\n}\n```", "raw::RawTableInner::fix_insert_slot": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_fix_insert_slot() {\n        unsafe {\n            let table_layout = TableLayout::calculate_layout_for(8).unwrap(); // Example for 8 buckets\n            let mut raw_table = RawTableInner::fallible_with_capacity(&Global, table_layout, 8, Fallibility::Infallible).unwrap();\n\n            // Initializing control bytes\n            raw_table.ctrl_slice().fill_empty();\n\n            // Simulate a situation where the table has some full buckets\n            raw_table.set_ctrl(0, Tag::full(0)); // Mark bucket 0 as full\n            raw_table.set_ctrl(1, Tag::full(1)); // Mark bucket 1 as full\n            raw_table.set_ctrl(2, Tag::full(2)); // Mark bucket 2 as full\n            raw_table.set_ctrl(3, Tag::full(3)); // Mark bucket 3 as full\n\n            // Now let's find an insert slot\n            let probe_seq = raw_table.probe_seq(0); // Simulate a hash\n            let insert_slot = raw_table.find_insert_slot_in_group(&Group::load(raw_table.ctrl(0)), &probe_seq).unwrap();\n\n            // Now call fix_insert_slot on the insert_slot\n            let fixed_slot = raw_table.fix_insert_slot(insert_slot);\n\n            // Check that the fixed slot is valid\n            assert!(fixed_slot.index < raw_table.buckets());\n        }\n    }\n\n    #[test]\n    fn test_fix_insert_slot_with_full_buckets() {\n        unsafe {\n            let table_layout = TableLayout::calculate_layout_for(4).unwrap(); // Example for 4 buckets\n            let mut raw_table = RawTableInner::fallible_with_capacity(&Global, table_layout, 4, Fallibility::Infallible).unwrap();\n\n            // Initializing control bytes for a smaller table\n            raw_table.ctrl_slice().fill_empty();\n\n            // Mark all buckets as full\n            raw_table.set_ctrl(0, Tag::full(0));\n            raw_table.set_ctrl(1, Tag::full(1));\n            raw_table.set_ctrl(2, Tag::full(2));\n            raw_table.set_ctrl(3, Tag::full(3));\n\n            // Find insert slot\n            let probe_seq = raw_table.probe_seq(0);  // Simulate a hash\n            let insert_slot = raw_table.find_insert_slot_in_group(&Group::load(raw_table.ctrl(0)), &probe_seq).unwrap();\n\n            // Call fix_insert_slot\n            let fixed_slot = raw_table.fix_insert_slot(insert_slot);\n\n            // Here fixed_slot.index should return a valid slot, which is 0, 1, 2 or 3 for a case with full buckets\n            assert!(fixed_slot.index < raw_table.buckets());\n        }\n    }\n}\n```", "raw::RawTableInner::free_buckets": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::{GlobalAlloc, Layout, System};\n    use std::ptr::null_mut;\n\n    struct MockAllocator;\n\n    unsafe impl Allocator for MockAllocator {\n        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, std::alloc::AllocErr> {\n            unsafe { NonNull::new(std::alloc::alloc(layout)).ok_or(std::alloc::AllocErr) }\n        }\n\n        unsafe fn deallocate(&self, ptr: *mut u8, layout: Layout) {\n            std::alloc::dealloc(ptr, layout);\n        }\n    }\n\n    #[test]\n    fn test_free_buckets() {\n        unsafe {\n            let alloc = MockAllocator;\n            let table_layout = TableLayout::new(/* parameters */); // Add appropriate parameters\n            let mut inner = RawTableInner::new_uninitialized(&alloc, table_layout, /* buckets */ 8, /* fallibility */ Fallibility::Infallible).unwrap();\n\n            // Ensure the inner is properly allocated\n            assert!(!inner.ctrl.as_ptr().is_null());\n\n            // Perform the free_buckets operation\n            inner.free_buckets(&alloc, table_layout);\n            \n            // Verify that memory is deallocated properly\n            // This part is tricky, it's often hard to verify in tests directly\n            // We would check that the `inner` is in a state that suggests\n            // the memory has been freed, for example by checking that\n            // the control pointer is now invalid or similar rules.\n\n            // Ensure control pointer is now pointing to a deallocated memory\n            assert!(inner.ctrl.as_ptr().is_null()); // Mock behavior, adjust condition\n        }\n    }\n}\n```", "raw::RawTableInner::full_buckets_indices": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_full_buckets_indices() {\n        // Setup phase\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 16, Fallibility::Infallible)\n                .unwrap()\n        };\n\n        // Simulate inserting items\n        unsafe {\n            // Manually set control bytes to simulate full buckets\n            for i in 0..16 {\n                let tag = Tag::full(0);\n                raw_table.set_ctrl(i, tag);\n            }\n            raw_table.items = 16;\n        }\n\n        // Iteration test\n        let mut full_buckets_indices = unsafe { raw_table.full_buckets_indices() };\n\n        // Collect the result for assertion\n        let indices: Vec<usize> = full_buckets_indices.by_ref().collect();\n        \n        // Check the correctness: We expect indices to be 0..15\n        assert_eq!(indices, (0..16).collect::<Vec<_>>());\n        \n        // Check the size hint\n        assert_eq!(full_buckets_indices.size_hint(), (0, Some(0)));\n    }\n}\n```", "raw::RawTableInner::is_bucket_full": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_is_bucket_full() {\n        let alloc = System;\n        let table_layout = TableLayout::default(); // Assume you have this setup\n        let capacity = 4; // A small capacity for testing\n        let mut table = unsafe {\n            RawTableInner::with_capacity(&alloc, table_layout, capacity)\n        };\n\n        // Assume that we fill the table to test is_bucket_full\n        let index_to_test = 0; // Test the first bucket\n        unsafe {\n            table.set_ctrl(index_to_test, Tag::full(0)); // Manually set full\n            assert!(table.is_bucket_full(index_to_test)); // Check that the bucket is full\n        }\n\n        unsafe {\n            table.set_ctrl(index_to_test, Tag::empty()); // Manually set empty\n            assert!(!table.is_bucket_full(index_to_test)); // Check that the bucket is not full\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_is_bucket_full_out_of_bounds() {\n        let alloc = System;\n        let table_layout = TableLayout::default(); // Assume you have this setup\n        let capacity = 4; // A small capacity for testing\n        let table = unsafe {\n            RawTableInner::with_capacity(&alloc, table_layout, capacity)\n        };\n\n        // Test out of bounds index, should panic\n        unsafe {\n            table.is_bucket_full(capacity); // This should panic\n        }\n    }\n}\n```", "raw::RawTableInner::is_empty_singleton": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_is_empty_singleton() {\n        let raw_table = RawTableInner {\n            bucket_mask: 0,\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n        assert!(raw_table.is_empty_singleton());\n\n        let raw_table_non_empty = RawTableInner {\n            bucket_mask: 1,\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n        assert!(!raw_table_non_empty.is_empty_singleton());\n    }\n}\n```", "raw::RawTableInner::is_in_same_group": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_is_in_same_group() {\n        let mut table = RawTableInner {\n            bucket_mask: 15,  // Example: 16 buckets\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n        \n        let hash: u64 = 123456;\n\n        // Mock: Assume `probe_seq()` returns 0 for hash 123456\n        let probe_seq_pos = table.probe_seq(hash).pos;\n\n        // These would be in the same group if their indices were the same modulo `Group::WIDTH`\n        let same_group_i = 0;\n        let same_group_new_i = 4; // Assume `Group::WIDTH` is 4\n        let not_same_group_new_i = 5; // Different group\n\n        // Test for indices in the same group\n        assert!(table.is_in_same_group(same_group_i, same_group_new_i, hash));\n\n        // Test for indices not in the same group\n        assert!(!table.is_in_same_group(same_group_i, not_same_group_new_i, hash));\n    }\n}\n```", "raw::RawTableInner::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_table_iter_empty() {\n        let mut table: RawTableInner = RawTableInner::new_uninitialized(/* allocations and parameters need to be adjusted appropriately */);\n        let iter: RawIter<i32> = unsafe { table.iter() };\n        assert_eq!(iter.count(), 0);\n    }\n\n    #[test]\n    fn test_raw_table_iter_single_element() {\n        let mut table: RawTableInner = RawTableInner::new_uninitialized(/* allocations and parameters need to be adjusted appropriately */);\n        // Insert an element into the table's raw structure appropriately\n        let value = 42; // example value\n        unsafe { table.insert(/* params to insert the value */) };\n\n        let iter: RawIter<i32> = unsafe { table.iter() };\n        let count: usize = iter.count();\n        assert_eq!(count, 1);\n    }\n\n    #[test]\n    fn test_raw_table_iter_multiple_elements() {\n        let mut table: RawTableInner = RawTableInner::new_uninitialized(/* allocations and parameters need to be adjusted appropriately */);\n        let values = vec![1, 2, 3, 4, 5];\n        \n        for &value in &values {\n            unsafe { table.insert(/* params to insert the value */) };\n        }\n\n        let iter: RawIter<i32> = unsafe { table.iter() };\n        let yielded_values: Vec<i32> = iter.map(|bucket| unsafe { bucket.as_ref() }).collect();\n        assert_eq!(yielded_values, values);\n    }\n\n    #[test]\n    fn test_raw_table_iter_with_deletions() {\n        let mut table: RawTableInner = RawTableInner::new_uninitialized(/* allocations and parameters need to be adjusted appropriately */);\n        let values = vec![1, 2, 3];\n        \n        for &value in &values {\n            unsafe { table.insert(/* params to insert the value */) };\n        }\n        \n        unsafe { table.erase(/* params to erase the second element */) };\n\n        let iter: RawIter<i32> = unsafe { table.iter() };\n        let yielded_values: Vec<i32> = iter.map(|bucket| unsafe { bucket.as_ref() }).collect();\n        assert_eq!(yielded_values, vec![/* first value, third value */]);\n    }\n}\n```", "raw::RawTableInner::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_table_inner_new() {\n        let table = RawTableInner::new();\n\n        assert_eq!(table.bucket_mask, 0);\n        assert_eq!(table.items, 0);\n        assert_eq!(table.growth_left, 0);\n        assert!(!table.ctrl.as_ptr().is_null());\n    }\n}\n```", "raw::RawTableInner::new_uninitialized": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_new_uninitialized_valid() {\n        let fallibility = Fallibility::Fallible;\n        let layout = TableLayout::new::<u32>();\n        let buckets = 8; // Must be a power of two\n\n        let result = unsafe {\n            raw::RawTableInner::new_uninitialized(&Global, layout, buckets, fallibility)\n        };\n\n        assert!(result.is_ok());\n        let table = result.unwrap();\n        assert_eq!(table.bucket_mask, buckets - 1);\n        assert_eq!(table.items, 0);\n        // Additional tests can be added to validate table properties\n    }\n\n    #[test]\n    fn test_new_uninitialized_invalid_buckets() {\n        let fallibility = Fallibility::Fallible;\n        let layout = TableLayout::new::<u32>();\n        let buckets = 7; // Not a power of two\n\n        let result = unsafe {\n            raw::RawTableInner::new_uninitialized(&Global, layout, buckets, fallibility)\n        };\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_new_uninitialized_capacity_overflow() {\n        let fallibility = Fallibility::Fallible;\n        let layout = TableLayout::new::<u32>();\n        let buckets = usize::MAX; // Attempting to allocate maximum buckets\n\n        let result = unsafe {\n            raw::RawTableInner::new_uninitialized(&Global, layout, buckets, fallibility)\n        };\n\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);\n    }\n}\n```", "raw::RawTableInner::num_ctrl_bytes": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_num_ctrl_bytes() {\n        let bucket_mask = 3; // Example mask, so buckets = 4 (3 + 1)\n        let group_width = 4;  // Example group width\n        let instance = RawTableInner {\n            bucket_mask,\n            ctrl: NonNull::new(std::ptr::null_mut()).unwrap(),\n            growth_left: 0,\n            items: 0,\n        };\n\n        // Assuming Group::WIDTH = group_width\n        let expected_ctrl_bytes = bucket_mask + 1 + group_width;\n        let actual_ctrl_bytes = instance.num_ctrl_bytes();\n\n        assert_eq!(actual_ctrl_bytes, expected_ctrl_bytes);\n    }\n}\n```", "raw::RawTableInner::prepare_insert_slot": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_prepare_insert_slot() {\n        // Create a mock allocator\n        struct MockAllocator;\n\n        // Define a dummy allocator for testing\n        impl Allocator for MockAllocator {\n            fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n                // Allocate enough space for control bytes\n                let size = layout.size();\n                let ptr = unsafe { core::alloc::alloc(layout) };\n                if ptr.is_null() {\n                    return Err(AllocErr::unable_to_allocate(layout));\n                }\n                Ok(unsafe { NonNull::new_unchecked(ptr) })\n            }\n\n            fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n                unsafe { core::alloc::dealloc(ptr.as_ptr(), layout) }\n            }\n        }\n\n        let allocator = MockAllocator;\n        let layout = TableLayout::default();\n        let capacity = 8; // for testing, 8 buckets\n        let mut raw_table = unsafe {\n            RawTableInner::fallible_with_capacity(&allocator, layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Initialize control bytes with EMPTY\n        unsafe {\n            raw_table.ctrl_slice().fill(Tag::EMPTY);\n        }\n\n        // Test inserting a value\n        for hash in 0..10 {\n            let (index, old_ctrl) = unsafe { raw_table.prepare_insert_slot(hash) };\n\n            // Check that the index returned is within the bounds of the raw_table\n            assert!(index <= raw_table.bucket_mask);\n            assert!(index < raw_table.buckets());\n\n            // Check if the control byte is changed properly\n            if old_ctrl == Tag::EMPTY {\n                assert_eq!(raw_table.ctrl(index), Tag::full(hash));\n            }\n        }\n    }\n\n    #[test]\n    fn test_prepare_insert_slot_with_deleted() {\n        // Same setup as the previous test\n        struct MockAllocator;\n\n        impl Allocator for MockAllocator {\n            fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n                let ptr = unsafe { core::alloc::alloc(layout) };\n                if ptr.is_null() {\n                    return Err(AllocErr::unable_to_allocate(layout));\n                }\n                Ok(unsafe { NonNull::new_unchecked(ptr) })\n            }\n\n            fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n                unsafe { core::alloc::dealloc(ptr.as_ptr(), layout) }\n            }\n        }\n\n        let allocator = MockAllocator;\n        let layout = TableLayout::default();\n        let capacity = 8; // for testing, 8 buckets\n        let mut raw_table = unsafe {\n            RawTableInner::fallible_with_capacity(&allocator, layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Initialize control bytes with EMPTY\n        unsafe {\n            raw_table.ctrl_slice().fill(Tag::EMPTY);\n        }\n\n        // Set a slot to DELETED\n        unsafe {\n            raw_table.set_ctrl(0, Tag::DELETED);\n        }\n        \n        // Test inserting a value after a DELETED slot\n        let (index, old_ctrl) = unsafe { raw_table.prepare_insert_slot(1234) };\n        assert!(index <= raw_table.bucket_mask);\n        assert!(index < raw_table.buckets());\n        assert_eq!(old_ctrl, Tag::DELETED);\n    }\n}\n```", "raw::RawTableInner::prepare_rehash_in_place": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Allocator;\n\n    struct TestAllocator;\n\n    unsafe impl Allocator for TestAllocator {\n        // Implement required methods for the Allocator trait...\n    }\n\n    #[test]\n    fn test_prepare_rehash_in_place() {\n        unsafe {\n            // Arrange\n            let alloc = TestAllocator;\n            let table_layout = /* Initialize your TableLayout here */;\n            let mut raw_table: RawTableInner = RawTableInner::fallible_with_capacity(&alloc, table_layout, 16, Fallibility::Infallible)\n                .expect(\"Failed to create RawTableInner\");\n            \n            // Initialize control bytes to simulate a state with FULL and DELETED entries.\n            for index in 0..16 {\n                // Assume Tag is an enum and FULL and DELETED variants are defined\n                let tag = if index % 2 == 0 { Tag::FULL } else { Tag::DELETED };\n                raw_table.set_ctrl(index, tag);\n            }\n\n            // Act\n            raw_table.prepare_rehash_in_place();\n\n            // Assert\n            for index in 0..16 {\n                let tag = *raw_table.ctrl(index);\n                // Check if FULL was converted to DELETED and DELETED to EMPTY\n                if index % 2 == 0 {\n                    assert_eq!(tag, Tag::DELETED);\n                } else {\n                    assert_eq!(tag, Tag::EMPTY);\n                }\n            }\n        }\n    }\n}\n```", "raw::RawTableInner::prepare_resize": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::mem::ManuallyDrop;\n\n    #[test]\n    fn test_prepare_resize_success() {\n        // Create a raw table inner with some initial capacity\n        let table_layout = TableLayout::default(); // Assuming a default layout\n        let initial_capacity = 4;\n        let alloc = &Global;\n        let mut raw_table = RawTableInner::with_capacity(alloc, table_layout, initial_capacity);\n\n        // Fill with some items\n        raw_table.items = 2; // Assume some items already present\n        \n        // Prepare for resizing\n        let new_capacity = 8;\n        let fallibility = Fallibility::Fallible;\n\n        // Run prepare_resize\n        let result = raw_table.prepare_resize(alloc, table_layout, new_capacity, fallibility);\n\n        // Check that result is Ok\n        assert!(result.is_ok());\n\n        // Check that we have the expected new table\n        let scope_guard = result.unwrap();\n        assert_eq!(scope_guard.new_table.items, 0); // New table should be empty\n    }\n\n    #[test]\n    fn test_prepare_resize_capacity_overflow() {\n        // Create a raw table inner with capacity\n        let table_layout = TableLayout::default();\n        let initial_capacity = 4;\n        let alloc = &Global;\n        let mut raw_table = RawTableInner::with_capacity(alloc, table_layout, initial_capacity);\n\n        // Fill with items\n        raw_table.items = 2; // Assume some items present\n        \n        // Prepare for resizing with a capacity that would cause overflow\n        let new_capacity = usize::MAX; // This is deliberately large\n        let fallibility = Fallibility::Fallible;\n\n        // Run prepare_resize\n        let result = raw_table.prepare_resize(alloc, table_layout, new_capacity, fallibility);\n\n        // Check that result is Err\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_prepare_resize_requirements() {\n        let table_layout = TableLayout::default();\n        let initial_capacity = 4;\n        let alloc = &Global;\n        let raw_table = RawTableInner::with_capacity(alloc, table_layout, initial_capacity);\n\n        // Create a new table layout that is incompatible\n        let incompatible_layout = TableLayout::default(); // Assuming a different layout for test\n\n        let new_capacity = 8;\n        let fallibility = Fallibility::Fallible;\n\n        // Check that prepare_resize is invoked with incompatible layout\n        let result = raw_table.prepare_resize(alloc, incompatible_layout, new_capacity, fallibility);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_prepare_resize_fallible() {\n        let table_layout = TableLayout::default();\n        let initial_capacity = 4;\n        let alloc = &Global;\n        let mut raw_table = RawTableInner::with_capacity(alloc, table_layout, initial_capacity);\n\n        // Fill with some items\n        raw_table.items = 2;\n\n        // Prepare for resizing with a fallible allocation\n        let new_capacity = 8;\n        let fallibility = Fallibility::Fallible;\n\n        // Simulate allocation failure\n        let result = raw_table.prepare_resize(alloc, table_layout, new_capacity, fallibility);\n        \n        // Check that it is an Err\n        assert!(result.is_err());\n    }\n}\n```", "raw::RawTableInner::probe_seq": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_probe_seq() {\n        // Arrange\n        let alloc = &Global;\n        let table_layout = TableLayout::default(); // Use a default layout or appropriate setup\n        let capacity = 4; // Ensure a small initial capacity\n        let mut raw_table = unsafe {\n            RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Assume we have filled the table with data before testing probe_seq\n        // For the purposes of this test, we will use dummy data or just\n        // test the iterator functionality of probe_seq directly.\n\n        let hash = 42; // Arbitrary hash\n        let probe_seq = raw_table.probe_seq(hash);\n\n        // Act\n        let initial_pos = probe_seq.pos;\n\n        // We will call `move_next` a few times based on the width of the group\n        let mut mutable_probe_seq = probe_seq;\n        let bucket_mask = raw_table.bucket_mask;\n\n        for _ in 0..=bucket_mask {\n            mutable_probe_seq.move_next(bucket_mask);\n            // Check the behavior of the position\n            // Expect it to not exceed the bounds\n            assert!(mutable_probe_seq.pos <= bucket_mask);\n        }\n    }\n    \n    #[test]\n    fn test_probe_seq_no_empty_buckets() {\n        // Arrange\n        let alloc = &Global;\n        let table_layout = TableLayout::default(); // Use a default layout or appropriate setup\n        let capacity = 4; // Ensure a small initial capacity\n        let mut raw_table = unsafe {\n            RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Fill the table to have no empty buckets\n        for i in 0..capacity {\n            let hash = i as u64; // Simulating the hash values as the index\n            let index = raw_table.find_insert_slot(hash).index;\n            unsafe {\n                raw_table.set_ctrl_hash(index, hash);\n            }\n        }\n\n        let hash = 42; // Arbitrary hash\n        let mut probe_seq = raw_table.probe_seq(hash);\n\n        // Act: Should continue to move, but we should not expect it to\n        // enter a group with empty buckets.\n        let mut found_empty = false;\n\n        for _ in 0..=raw_table.bucket_mask {\n            unsafe {\n                let group = Group::load(raw_table.ctrl(probe_seq.pos));\n                if group.match_empty().any_bit_set() { \n                    found_empty = true; // We should find empty bucket\n                    break;\n                }\n            }\n            probe_seq.move_next(raw_table.bucket_mask);\n        }\n\n        // Assert\n        assert!(found_empty, \"No empty buckets found in probe sequence.\");\n    }\n}\n```", "raw::RawTableInner::record_item_insert_at": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    unsafe fn test_record_item_insert_at() {\n        let mut table = RawTableInner::with_capacity(&Global, TableLayout::default(), 8);\n        let index = 0;\n        let old_ctrl = Tag::EMPTY;\n        let hash = 12345;\n\n        // Pre-condition: table should have 0 items\n        assert_eq!(table.items, 0);\n        assert_eq!(table.growth_left, table.bucket_mask + 1);\n\n        // Call the function under test\n        table.record_item_insert_at(index, old_ctrl, hash);\n\n        // Post-condition: table should have 1 item\n        assert_eq!(table.items, 1);\n        assert_eq!(table.growth_left, table.bucket_mask);\n        assert!(table.ctrl(index).is_full());\n    }\n}\n```", "raw::RawTableInner::rehash_in_place": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Allocator;\n    use std::ptr::NonNull;\n\n    struct MockAllocator;\n\n    impl Allocator for MockAllocator {\n        fn allocate(&self, layout: std::alloc::Layout) -> std::alloc::AllocResult<NonNull<u8>> {\n            // mock allocation logic\n        }\n        // Implement other allocator methods as needed...\n    }\n  \n    #[test]\n    fn test_rehash_in_place() {\n        let alloc = MockAllocator;\n        let layout = TableLayout::default(); // Assuming a default constructor\n\n        // Initialize RawTableInner\n        let mut table = unsafe {\n            RawTableInner::new_uninitialized(&alloc, layout, 16, Fallibility::Infallible).unwrap()\n        };\n\n        // Insert mock data into table and simulate a filled state\n        // ...\n\n        // Define a mock hasher\n        let hasher: Box<dyn Fn(&mut RawTableInner, usize) -> u64> = Box::new(|table, index| {\n            // mock hashing logic\n            index as u64 // Replace with appropriate hashing\n        });\n\n        unsafe {\n            // Call the rehash_in_place function\n            table.rehash_in_place(&*hasher, std::mem::size_of::<YourDataType>(), None);\n        }\n\n        // Assert the state of the table after rehashing\n        // ...\n    }\n}\n```", "raw::RawTableInner::replace_ctrl_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Layout;\n\n    #[test]\n    fn test_replace_ctrl_hash() {\n        // Define a suitable allocator\n        struct TestAllocator;\n\n        // Define a simple utility function to create a new RawTableInner\n        unsafe fn create_raw_table() -> RawTableInner {\n            let layout = Layout::new::<Tag>();\n            // Assume a safe allocator where allocation is successful\n            let alloc = TestAllocator;\n            let capacity = 8;\n            RawTableInner::with_capacity(&alloc, layout, capacity)\n        }\n\n        unsafe {\n            let mut table = create_raw_table();\n\n            // Set initial control hash for testing\n            let initial_hash = 42;\n            let index = 0;\n            let old_tag = table.replace_ctrl_hash(index, initial_hash);\n\n            // Check that the old control hash is the expected value (should be EMPTY)\n            assert_eq!(old_tag, Tag::EMPTY);\n\n            // Check that the new control hash has been set\n            assert!(table.is_bucket_full(index));\n\n            // Set another hash and check the old value returned\n            let new_hash = 84;\n            let old_tag = table.replace_ctrl_hash(index, new_hash);\n\n            // The old control hash should be the previous hash set (42)\n            assert_eq!(old_tag, Tag::full(initial_hash));\n\n            // Ensure the control hash is now the new hash\n            assert!(table.is_bucket_full(index));\n        }\n    }\n}\n```", "raw::RawTableInner::reserve_rehash_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System; // Assuming System is used as Allocator\n    use std::ptr::null_mut;\n\n    #[test]\n    fn test_reserve_rehash_inner() {\n        let layout = TableLayout::default(); // Assuming a default layout is valid\n        let fallibility = Fallibility::Fallible; // Using fallible allocation\n        let alloc = System; // Using the default system allocator\n        \n        // Create a new RawTableInner with a small capacity to test rehashing\n        let mut table = unsafe {\n            RawTableInner::new_uninitialized(&alloc, layout, 4, fallibility).unwrap()\n        };\n\n        // Populate table (Assuming a method to insert items, omitted here)\n        // table.insert(1);\n        // table.insert(2);\n        \n        // Store the original items count\n        let original_items = table.items;\n\n        // Define a dummy hasher function\n        let hasher: &dyn Fn(&mut RawTableInner, usize) -> u64 = &|_, idx| idx as u64;\n\n        // Reserve with an additional count\n        let result = unsafe {\n            table.reserve_rehash_inner(&alloc, 2, hasher, fallibility, layout, None)\n        };\n\n        // Check if the result was OK\n        assert!(result.is_ok());\n\n        // Verify the items count is correctly updated\n        assert!(table.items > original_items);\n        \n        // Verify the table correctly resized if necessary (Assuming a method to check capacity)\n        // assert!(table.capacity() > 4);\n        \n        // Clean up the table (Assuming a drop method)\n        // unsafe { table.drop_inner_table::<i32>(&alloc, layout) };\n    }\n\n    #[test]\n    fn test_reserve_rehash_inner_overflow() {\n        let layout = TableLayout::default(); // Assuming a default layout is valid\n        let fallibility = Fallibility::Fallible; // Using fallible allocation\n        let alloc = System;\n\n        let mut table = unsafe {\n            RawTableInner::new_uninitialized(&alloc, layout, 4, fallibility).unwrap()\n        };\n\n        // Populate table (Assuming a method to insert items, omitted here)\n        // table.insert(1);\n        // table.insert(2);\n        \n        // Define a dummy hasher function\n        let hasher: &dyn Fn(&mut RawTableInner, usize) -> u64 = &|_, idx| idx as u64;\n\n        // Attempt to reserve an excessive amount\n        let result = unsafe {\n            table.reserve_rehash_inner(&alloc, usize::MAX, hasher, fallibility, layout, None)\n        };\n\n        // Since we're testing overflow, the result should be an Err\n        assert!(result.is_err());\n    }\n\n    // Additional tests can be added to test different edge cases as necessary.\n}\n```", "raw::RawTableInner::resize_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::mem;\n\n    fn dummy_hasher(_: &mut RawTableInner, _: usize) -> u64 {\n        // A simple dummy hasher that always returns a fixed hash value.\n        0\n    }\n\n    #[test]\n    fn test_resize_inner() {\n        // Set up a RawTableInner with dummy data\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible)\n                .expect(\"Failed to create RawTableInner\")\n        };\n\n        raw_table.items = 2; // Simulate 2 items currently in the table\n        raw_table.growth_left = 2; // Set growth_left to allow for growth\n        raw_table.bucket_mask = 3; // 4 buckets (2^2)\n        \n        // Resize the raw table\n        let result = unsafe {\n            raw_table.resize_inner(\n                &Global,\n                8, // Resize to 8 (double the size)\n                &dummy_hasher,\n                Fallibility::Infallible,\n                TableLayout::default(),\n            )\n        };\n\n        // Check result\n        assert!(result.is_ok());\n\n        // Ensure that the items count is correctly transferred\n        assert_eq!(raw_table.items, 2); // Still 2 items after resize\n        assert_eq!(raw_table.growth_left, 2); // Ensure growth_left remains unchanged\n    }\n\n    #[test]\n    fn test_resize_inner_invalid() {\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible)\n                .expect(\"Failed to create RawTableInner\")\n        };\n\n        raw_table.items = 0; // No items currently in the table\n        raw_table.growth_left = 0; // No growth left\n        \n        // Attempt to resize to 0 capacity, should fail\n        let result = unsafe {\n            raw_table.resize_inner(\n                &Global,\n                0,\n                &dummy_hasher,\n                Fallibility::Infallible,\n                TableLayout::default(),\n            )\n        };\n\n        // Check result\n        assert!(result.is_err());\n\n        // Ensure the items count is still 0\n        assert_eq!(raw_table.items, 0);\n    }\n}\n```", "raw::RawTableInner::set_ctrl": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_set_ctrl() {\n        let buckets = 8; // Must be a power of two\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, buckets, Fallibility::Infallible).unwrap()\n        };\n\n        // Safety: raw_table has been allocated and we are within valid index bounds\n        unsafe {\n            // Setting control bytes to EMPTY initially\n            for i in 0..raw_table.num_ctrl_bytes() {\n                raw_table.set_ctrl(i, Tag::EMPTY);\n            }\n        }\n\n        // Sanity check: confirm initial values are EMPTY\n        for i in 0..buckets {\n            unsafe {\n                assert_eq!(*raw_table.ctrl(i), Tag::EMPTY);\n            }\n        }\n\n        let index = 3; // Test index within bounds\n        let control = Tag::full(0x55); // Example control tag\n        \n        unsafe {\n            raw_table.set_ctrl(index, control);\n        }\n\n        // Verify the control has been set correctly\n        unsafe {\n            assert_eq!(*raw_table.ctrl(index), control);\n            assert_eq!(*raw_table.ctrl(((index.wrapping_sub(Group::WIDTH)) & raw_table.bucket_mask) + Group::WIDTH), control);\n        }\n    }\n}\n```", "raw::RawTableInner::set_ctrl_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_set_ctrl_hash() {\n        // Create a new `RawTableInner` instance with a specific capacity\n        let mut table_inner = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 8, Fallibility::Infallible).unwrap()\n        };\n\n        let index = 0;\n        let hash: u64 = 12345;\n\n        unsafe {\n            // Ensure `set_ctrl_hash` does not panic and sets control hash correctly\n            table_inner.set_ctrl_hash(index, hash);\n\n            // Verify that the control hash was set correctly\n            let control_value = *table_inner.ctrl(index);\n            assert_eq!(control_value, Tag::full(hash));\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_ctrl_hash_out_of_bounds() {\n        // Create a new `RawTableInner` instance with a small capacity\n        let mut table_inner = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 1, Fallibility::Infallible).unwrap()\n        };\n\n        let index = 2;  // Index out of bounds\n        let hash: u64 = 12345;\n\n        unsafe {\n            // This should panic as the index is out of bounds\n            table_inner.set_ctrl_hash(index, hash);\n        }\n    }\n\n    #[test]\n    fn test_set_ctrl_hash_empty_table() {\n        // Create a new `RawTableInner` that is empty\n        let mut table_inner = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 0, Fallibility::Infallible).unwrap()\n        };\n\n        let index = 0;\n        let hash: u64 = 12345;\n\n        unsafe {\n            // Should not panic, as we are still within bounds (table is empty)\n            table_inner.set_ctrl_hash(index, hash);\n        }\n    }\n}\n```", "raw::RawTableInner::with_capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::alloc::Layout;\n    \n    #[test]\n    fn test_with_capacity_zero_elements() {\n        let layout = TableLayout::new(Layout::from_size_align(0, 1).unwrap());\n        let table = RawTableInner::with_capacity(&Global, layout, 0);\n        assert_eq!(table.items, 0);\n        assert!(table.bucket_mask == 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_with_capacity_exceeds_max() {\n        let layout = TableLayout::new(Layout::from_size_align(1, 1).unwrap());\n        RawTableInner::with_capacity(&Global, layout, usize::MAX);\n    }\n\n    #[test]\n    fn test_with_capacity_non_zero() {\n        let layout = TableLayout::new(Layout::from_size_align(1, 1).unwrap());\n        let capacity = 10;\n        let table = RawTableInner::with_capacity(&Global, layout, capacity);\n        assert!(table.items == 0);\n        assert!(table.bucket_mask >= capacity);\n    }\n}\n```", "raw::TableLayout::calculate_layout_for": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::alloc::Layout;\n\n    #[test]\n    fn test_calculate_layout_for_valid_power_of_two() {\n        let layout = TableLayout::new::<u8>();\n        let buckets = 8; // Power of two\n        let result = layout.calculate_layout_for(buckets);\n        assert!(result.is_some());\n        let (layout_result, offset) = result.unwrap();\n        assert_eq!(layout_result.size(), (layout.size * buckets) + offset);\n        assert!(layout_result.align() >= layout.ctrl_align);\n    }\n    \n    #[test]\n    fn test_calculate_layout_for_invalid_power_of_two() {\n        let layout = TableLayout::new::<u8>();\n        let buckets = 5; // Not a power of two\n        let result = layout.calculate_layout_for(buckets);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_calculate_layout_for_too_large_buckets() {\n        let layout = TableLayout::new::<u8>();\n        let buckets = (isize::MAX as usize / layout.size) + 1; // Intentional overflow\n        let result = layout.calculate_layout_for(buckets);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_calculate_layout_for_zero_buckets() {\n        let layout = TableLayout::new::<u8>();\n        let buckets = 0; // Zero buckets\n        let result = layout.calculate_layout_for(buckets);\n        assert!(result.is_none());\n    }\n}\n```", "raw::TableLayout::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Layout;\n\n    #[test]\n    fn test_table_layout_new() {\n        // Test for a type with a specific size and alignment\n        let int_layout = TableLayout::new::<i32>();\n        assert_eq!(int_layout.size, Layout::new::<i32>().size());\n        assert_eq!(int_layout.ctrl_align, if Layout::new::<i32>().align() > Group::WIDTH {\n            Layout::new::<i32>().align()\n        } else {\n            Group::WIDTH\n        });\n\n        // Test for a type with a larger size and alignment\n        let double_layout = TableLayout::new::<f64>();\n        assert_eq!(double_layout.size, Layout::new::<f64>().size());\n        assert_eq!(double_layout.ctrl_align, if Layout::new::<f64>().align() > Group::WIDTH {\n            Layout::new::<f64>().align()\n        } else {\n            Group::WIDTH\n        });\n\n        // Test for a type with a different alignment\n        let char_layout = TableLayout::new::<char>();\n        assert_eq!(char_layout.size, Layout::new::<char>().size());\n        assert_eq!(char_layout.ctrl_align, if Layout::new::<char>().align() > Group::WIDTH {\n            Layout::new::<char>().align()\n        } else {\n            Group::WIDTH\n        });\n    }\n}\n```", "raw::alloc::inner::do_alloc": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::{GlobalAlloc, Layout};\n    use std::ptr::NonNull;\n\n    struct MockAllocator;\n\n    impl Allocator for MockAllocator {\n        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, AllocError> {\n            // Simulate successful allocation\n            let ptr = std::alloc::alloc(layout);\n            if ptr.is_null() {\n                Err(AllocError)\n            } else {\n                Ok(NonNull::new(ptr).unwrap())\n            }\n        }\n    }\n    \n    #[test]\n    fn test_do_alloc_success() {\n        let alloc = MockAllocator;\n        let layout = Layout::from_size_align(8, 1).unwrap();\n        let result = do_alloc(&alloc, layout);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_do_alloc_failure() {\n        struct FailingAllocator;\n\n        impl Allocator for FailingAllocator {\n            fn allocate(&self, _: Layout) -> Result<NonNull<u8>, AllocError> {\n                // Simulate allocation failure\n                Err(AllocError)\n            }\n        }\n\n        let alloc = FailingAllocator;\n        let layout = Layout::from_size_align(8, 1).unwrap();\n        let result = do_alloc(&alloc, layout);\n        assert!(result.is_err());\n    }\n}\n```", "raw::bucket_mask_to_capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::raw::bucket_mask_to_capacity;\n\n    #[test]\n    fn test_bucket_mask_to_capacity() {\n        assert_eq!(bucket_mask_to_capacity(0), 0);\n        assert_eq!(bucket_mask_to_capacity(1), 1);\n        assert_eq!(bucket_mask_to_capacity(3), 3);\n        assert_eq!(bucket_mask_to_capacity(7), 7);\n        assert_eq!(bucket_mask_to_capacity(8), 7);\n        assert_eq!(bucket_mask_to_capacity(15), 13);\n        assert_eq!(bucket_mask_to_capacity(16), 14);\n        assert_eq!(bucket_mask_to_capacity(31), 27);\n        assert_eq!(bucket_mask_to_capacity(32), 28);\n    }\n}\n```", "raw::capacity_to_buckets": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{capacity_to_buckets, TableLayout};\n\n    #[test]\n    fn test_capacity_to_buckets_small_capacity() {\n        let layout = TableLayout::new::<u8>();\n        assert_eq!(capacity_to_buckets(3, layout), Some(4));\n        assert_eq!(capacity_to_buckets(7, layout), Some(8));\n        assert_eq!(capacity_to_buckets(14, layout), Some(16));\n    }\n\n    #[test]\n    fn test_capacity_to_buckets_large_capacity() {\n        let layout = TableLayout::new::<u8>();\n        assert_eq!(capacity_to_buckets(15, layout), Some(16));\n        assert_eq!(capacity_to_buckets(16, layout), Some(16));\n        assert_eq!(capacity_to_buckets(32, layout), Some(64));\n        assert_eq!(capacity_to_buckets(64, layout), Some(128));\n    }\n\n    #[test]\n    fn test_capacity_to_buckets_overflow() {\n        let layout = TableLayout::new::<u8>();\n        assert_eq!(capacity_to_buckets(usize::MAX, layout), None);\n    }\n}\n```", "raw::h1": "```rust\n#[cfg(test)]\nmod tests {\n    use super::raw::h1;\n\n    #[test]\n    fn test_h1_on_32_bit() {\n        let hash: u64 = 0x123456789ABCDEF0;\n        let expected: usize = 0x789ABCDEF0 as usize;\n        let result = h1(hash);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_h1_on_64_bit() {\n        let hash: u64 = 0xFFFFFFFFFFFFFFFF;\n        let expected: usize = 0xFFFFFFFFFFFFFFFF as usize;\n        let result = h1(hash);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_h1_zero() {\n        let hash: u64 = 0;\n        let expected: usize = 0;\n        let result = h1(hash);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_h1_boundary() {\n        let hash: u64 = u64::MAX;\n        let expected: usize = u64::MAX as usize;\n        let result = h1(hash);\n        assert_eq!(result, expected);\n    }\n}\n```", "raw::offset_from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_offset_from() {\n        let array = [1, 2, 3, 4];\n        let ptr_from = &array[0] as *const i32;\n        let ptr_to = &array[2] as *const i32;\n\n        // Calculate offset between ptr_to and ptr_from\n        let offset = unsafe { offset_from(ptr_to, ptr_from) };\n        \n        // Check that the offset is correct\n        assert_eq!(offset, 2 * std::mem::size_of::<i32>());\n    }\n\n    #[test]\n    fn test_offset_from_same_pointer() {\n        let array = [1, 2, 3, 4];\n        let ptr = &array[1] as *const i32;\n\n        // Calculate offset between the same pointer\n        let offset = unsafe { offset_from(ptr, ptr) };\n        \n        // Check that the offset is 0\n        assert_eq!(offset, 0);\n    }\n\n    #[test]\n    fn test_offset_from_negative_offset() {\n        let array = [1, 2, 3, 4];\n        let ptr_from = &array[2] as *const i32;\n        let ptr_to = &array[1] as *const i32;\n\n        // Calculate offset between ptr_to and ptr_from\n        let offset = unsafe { offset_from(ptr_to, ptr_from) };\n        \n        // Check that the offset is correct\n        assert_eq!(offset, -1 * std::mem::size_of::<i32>());\n    }\n}\n```", "raw_entry::<impl map::HashMap<K, V, S, A>>::raw_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use core::hash::{BuildHasher, Hash};\n\n    #[test]\n    fn test_raw_entry() {\n        let mut map = HashMap::new();\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n        map.insert(\"c\", 300);\n\n        fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n            use core::hash::Hasher;\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n\n        for k in [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] {\n            let hash = compute_hash(map.hasher(), &k);\n            let v = map.get(&k).cloned();\n            let kv = v.as_ref().map(|v| (&k, v));\n\n            assert_eq!(map.raw_entry().from_key(&k), kv);\n            assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n            assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n        }\n    }\n}\n```", "raw_entry::<impl map::HashMap<K, V, S, A>>::raw_entry_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_map::HashMap;\n    use hashbrown::hash_map::RawEntryMut;\n    use core::hash::{BuildHasher, Hash};\n\n    #[test]\n    fn test_raw_entry_mut() {\n        let mut map = HashMap::new();\n        map.extend([(\"a\", 100), (\"b\", 200), (\"c\", 300)]);\n\n        fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n            use core::hash::Hasher;\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n\n        // Existing key (insert and update)\n        match map.raw_entry_mut().from_key(&\"a\") {\n            RawEntryMut::Vacant(_) => unreachable!(),\n            RawEntryMut::Occupied(mut view) => {\n                assert_eq!(view.get(), &100);\n                let v = view.get_mut();\n                let new_v = (*v) * 10;\n                *v = new_v;\n                assert_eq!(view.insert(1111), 100);\n            }\n        }\n\n        assert_eq!(map[&\"a\"], 1110);\n        assert_eq!(map.len(), 3);\n\n        // Existing key (take)\n        let hash = compute_hash(map.hasher(), &\"c\");\n        match map.raw_entry_mut().from_key_hashed_nocheck(hash, &\"c\") {\n            RawEntryMut::Vacant(_) => unreachable!(),\n            RawEntryMut::Occupied(view) => {\n                assert_eq!(view.remove_entry(), (\"c\", 300));\n            }\n        }\n        assert_eq!(map.raw_entry().from_key(&\"c\"), None);\n        assert_eq!(map.len(), 2);\n\n        // Nonexistent key (insert and update)\n        let key = \"d\";\n        let hash = compute_hash(map.hasher(), &key);\n        match map.raw_entry_mut().from_hash(hash, |q| *q == key) {\n            RawEntryMut::Occupied(_) => unreachable!(),\n            RawEntryMut::Vacant(view) => {\n                let (k, value) = view.insert(\"d\", 4000);\n                assert_eq!((*k, *value), (\"d\", 4000));\n                *value = 40000;\n            }\n        }\n        assert_eq!(map[&\"d\"], 40000);\n        assert_eq!(map.len(), 3);\n\n        match map.raw_entry_mut().from_hash(hash, |q| *q == key) {\n            RawEntryMut::Vacant(_) => unreachable!(),\n            RawEntryMut::Occupied(view) => {\n                assert_eq!(view.remove_entry(), (\"d\", 40000));\n            }\n        }\n        assert_eq!(map.get(&\"d\"), None);\n        assert_eq!(map.len(), 2);\n    }\n}\n```", "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use core::hash::{BuildHasher, Hash};\n\n    fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n        use core::hash::Hasher;\n        let mut state = hash_builder.build_hasher();\n        key.hash(&mut state);\n        state.finish()\n    }\n\n    #[test]\n    fn test_from_hash_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n        \n        let key = \"a\";\n        let hash = compute_hash(map.hasher(), &key);\n        let result = map.raw_entry().from_hash(hash, |k| k == &key);\n        assert_eq!(result, Some((&\"a\", &100)));\n    }\n\n    #[test]\n    fn test_from_hash_non_existing_entry() {\n        let map: HashMap<&str, u32> = HashMap::new();\n        let key = \"x\";\n        let hash = compute_hash(map.hasher(), &key);\n        let result = map.raw_entry().from_hash(hash, |k| k == &key);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_from_hash_with_custom_matcher() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"foo\", 42);\n        \n        let hash = compute_hash(map.hasher(), &\"foo\");\n        let result = map.raw_entry().from_hash(hash, |k| k.starts_with(\"f\"));\n        assert_eq!(result, Some((&\"foo\", &42)));\n    }\n\n    #[test]\n    fn test_from_hash_with_different_hash() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"test\", 1);\n        \n        let hash = compute_hash(map.hasher(), &\"different_key\");\n        let result = map.raw_entry().from_hash(hash, |k| k == &\"test\");\n        assert_eq!(result, None);\n    }\n}\n```", "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_from_key_existing() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n        \n        let key = \"a\";\n        assert_eq!(map.raw_entry().from_key(&key), Some((&\"a\", &100)));\n    }\n\n    #[test]\n    fn test_from_key_non_existing() {\n        let map: HashMap<&str, u32> = HashMap::new();\n        \n        let key = \"c\";\n        assert_eq!(map.raw_entry().from_key(&key), None);\n    }\n\n    #[test]\n    fn test_from_key_empty() {\n        let map: HashMap<&str, u32> = HashMap::new();\n        \n        let key = \"a\";\n        assert_eq!(map.raw_entry().from_key(&key), None);\n    }\n\n    #[test]\n    fn test_from_key_with_different_reference() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"test\".to_string(), 150);\n        \n        let key = String::from(\"test\");\n        assert_eq!(map.raw_entry().from_key(&key), Some((&\"test\".to_string(), &150)));\n    }\n}\n```", "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_key_hashed_nocheck": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use core::hash::{BuildHasher, Hash};\n\n    fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n        let mut state = hash_builder.build_hasher();\n        key.hash(&mut state);\n        state.finish()\n    }\n\n    #[test]\n    fn test_from_key_hashed_nocheck() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n        \n        let key = \"a\";\n        let hash = compute_hash(map.hasher(), &key);\n        \n        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &key), Some((&\"a\", &100)));\n    }\n\n    #[test]\n    fn test_from_key_hashed_nocheck_nonexistent() {\n        let map: HashMap<&str, u32> = HashMap::new();\n        let key = \"nonexistent\";\n        let hash = compute_hash(map.hasher(), &key);\n        \n        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &key), None);\n    }\n}\n```", "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::search": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_search_found() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        let hash = hashbrown::HashMap::default().hasher().build_hasher().finish();\n        \n        let result = map.raw_entry().from_hash(hash, |k| *k == \"key1\");\n        assert!(result.is_some());\n        let (key, value) = result.unwrap();\n        assert_eq!(key, &\"key1\");\n        assert_eq!(value, &1);\n    }\n\n    #[test]\n    fn test_search_not_found() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        let hash = hashbrown::HashMap::default().hasher().build_hasher().finish();\n        \n        let result = map.raw_entry().from_hash(hash, |k| *k == \"key3\");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_search_with_custom_function() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert(\"key1\", 1);\n        map.insert(\"key2\", 2);\n        \n        let result = map.raw_entry().from_key(\"key2\");\n        assert!(result.is_some());\n        let (key, value) = result.unwrap();\n        assert_eq!(key, &\"key2\");\n        assert_eq!(value, &2);\n    }\n\n    #[test]\n    fn test_search_empty_map() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        \n        let result = map.raw_entry().from_key(\"key1\");\n        assert!(result.is_none());\n    }\n}\n```", "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n    use core::hash::{BuildHasher, Hash};\n\n    #[test]\n    fn test_from_hash_insert_and_get() {\n        fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key = \"test_key\";\n        let hash = compute_hash(map.hasher(), &key);\n        \n        let entry = map.raw_entry_mut().from_hash(hash, |k| k == &key);\n        assert!(matches!(entry, RawEntryMut::Vacant(_)));\n        \n        let (k, v) = entry.insert(key, 42);\n        assert_eq!((*k, *v), (key, 42));\n        assert_eq!(map[key], 42);\n    }\n\n    #[test]\n    fn test_from_hash_existing_key() {\n        fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"key1\", 1);\n        let hash = compute_hash(map.hasher(), &\"key1\");\n        \n        let entry = map.raw_entry_mut().from_hash(hash, |k| k == &\"key1\");\n        assert!(matches!(entry, RawEntryMut::Occupied(_)));\n        \n        if let RawEntryMut::Occupied(mut view) = entry {\n            assert_eq!(view.get(), &1);\n            let v = view.get_mut();\n            *v *= 2;\n            assert_eq!(map[\"key1\"], 2);\n        }\n    }\n\n    #[test]\n    fn test_from_hash_non_existing_key() {\n        fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key = \"new_key\";\n        let hash = compute_hash(map.hasher(), &key);\n        \n        let entry = map.raw_entry_mut().from_hash(hash, |k| k == &key);\n        assert!(matches!(entry, RawEntryMut::Vacant(_)));\n\n        let (k, v) = entry.insert(key, 100);\n        assert_eq!((*k, *v), (key, 100));\n        assert_eq!(map[key], 100);\n    }\n}\n```", "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n    use hashbrown::hash_map::RawEntryMut;\n\n    #[test]\n    fn test_from_key_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n\n        let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_key(&\"a\");\n        assert!(matches!(entry, RawEntryMut::Occupied(_)));\n\n        // Update the value\n        let mut view = entry.occupied();\n        let value = view.get_mut();\n        *value += 50;\n\n        assert_eq!(map.get(&\"a\"), Some(&150));\n    }\n\n    #[test]\n    fn test_from_key_non_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_key(&\"b\");\n        assert!(matches!(entry, RawEntryMut::Vacant(_)));\n\n        // Insert new key-value\n        let (key, value) = entry.insert(\"b\", 200);\n        assert_eq!((*key, *value), (\"b\", 200));\n        assert_eq!(map.get(&\"b\"), Some(&200));\n    }\n\n    #[test]\n    fn test_from_key_with_different_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert(\"hello\".to_string(), 1);\n\n        let entry: RawEntryMut<String, u32, _> = map.raw_entry_mut().from_key(&String::from(\"hello\"));\n        assert!(matches!(entry, RawEntryMut::Occupied(_)));\n    }\n\n    #[test]\n    fn test_from_key_with_reference() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let key = \"world\".to_string();\n        map.insert(key.clone(), 3);\n\n        let entry: RawEntryMut<String, u32, _> = map.raw_entry_mut().from_key(&key);\n        assert!(matches!(entry, RawEntryMut::Occupied(_)));\n        assert_eq!(entry.get(), &3);\n    }\n\n    #[test]\n    fn test_from_key_empty_map() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_key(&\"new_key\");\n        assert!(matches!(entry, RawEntryMut::Vacant(_)));\n    }\n}\n```", "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_key_hashed_nocheck": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_from_key_hashed_nocheck() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 1);\n        map.insert(\"b\", 2);\n        map.insert(\"c\", 3);\n\n        let key = \"a\";\n        let hash = {\n            let mut hasher = map.hasher().build_hasher();\n            key.hash(&mut hasher);\n            hasher.finish()\n        };\n        \n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n        match entry {\n            RawEntryMut::Occupied(mut occupied_entry) => {\n                assert_eq!(occupied_entry.get(), &1);\n                occupied_entry.insert(\"a\", 100);\n                assert_eq!(map[key], 100);\n            }\n            RawEntryMut::Vacant(_) => panic!(\"Expected occupied entry, found vacant\"),\n        }\n\n        let hash_non_existent = {\n            let mut hasher = map.hasher().build_hasher();\n            \"d\".hash(&mut hasher);\n            hasher.finish()\n        };\n\n        let entry_non_existent = map.raw_entry_mut().from_key_hashed_nocheck(hash_non_existent, &\"d\");\n        match entry_non_existent {\n            RawEntryMut::Occupied(_) => panic!(\"Expected vacant entry, found occupied\"),\n            RawEntryMut::Vacant(vacant_entry) => {\n                let (key_insert, value_insert) = vacant_entry.insert(\"d\", 4);\n                assert_eq!(*key_insert, \"d\");\n                assert_eq!(*value_insert, 4);\n                assert_eq!(map[\"d\"], 4);\n            }\n        }\n    }\n}\n```", "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::search": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_search_occupied() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        let hash = 1; // hash of key 1\n        let mut builder = map.raw_entry_mut();\n        let entry = builder.search(hash, |&k| k == 1);\n        \n        match entry {\n            RawEntryMut::Occupied(view) => {\n                assert_eq!(view.get(), &10);\n            }\n            _ => panic!(\"Expected an occupied entry\"),\n        }\n    }\n\n    #[test]\n    fn test_search_vacant() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        \n        let hash = 2; // hash of key 2\n        let mut builder = map.raw_entry_mut();\n        let entry = builder.search(hash, |&k| k == 2);\n        \n        match entry {\n            RawEntryMut::Vacant(view) => {\n                let (key, value) = view.insert(2, 20);\n                assert_eq!(*key, 2);\n                assert_eq!(*value, 20);\n            }\n            _ => panic!(\"Expected a vacant entry\"),\n        }\n    }\n\n    #[test]\n    fn test_search_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        \n        let hash = 1; // hash of key 1\n        let mut builder = map.raw_entry_mut();\n        let entry = builder.search(hash, |&k| k == 1);\n        \n        match entry {\n            RawEntryMut::Vacant(_) => assert!(true),\n            _ => panic!(\"Expected a vacant entry\"),\n        }\n    }\n}\n```", "raw_entry::RawEntryMut::<'a, K, V, S, A>::and_modify": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_and_modify_modify_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut()\n            .from_key(\"test_key\")\n            .and_modify(|_k, v| *v += 2)\n            .or_insert(\"test_key\", 10);\n        assert_eq!(map[\"test_key\"], 10);\n\n        map.raw_entry_mut()\n            .from_key(\"test_key\")\n            .and_modify(|_k, v| *v += 2)\n            .or_insert(\"test_key\", 0);\n        assert_eq!(map[\"test_key\"], 12);\n    }\n\n    #[test]\n    fn test_and_modify_insert_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut()\n            .from_key(\"new_key\")\n            .and_modify(|_k, v| *v += 1)\n            .or_insert(\"new_key\", 42);\n        assert_eq!(map[\"new_key\"], 42);\n    }\n\n    #[test]\n    fn test_and_modify_empty_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut()\n            .from_key(\"empty_key\")\n            .and_modify(|_k, v| *v += 1)\n            .or_insert(\"empty_key\", 0);\n        assert_eq!(map[\"empty_key\"], 0);\n    }\n\n    #[test]\n    fn test_and_modify_multiple_keys() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut()\n            .from_key(\"key_a\")\n            .and_modify(|_k, v| *v += 1)\n            .or_insert(\"key_a\", 5);\n        map.raw_entry_mut()\n            .from_key(\"key_b\")\n            .and_modify(|_k, v| *v += 1)\n            .or_insert(\"key_b\", 10);\n        \n        assert_eq!(map[\"key_a\"], 5);\n        assert_eq!(map[\"key_b\"], 10);\n\n        map.raw_entry_mut()\n            .from_key(\"key_a\")\n            .and_modify(|_k, v| *v += 2)\n            .or_insert(\"key_a\", 0);\n        map.raw_entry_mut()\n            .from_key(\"key_b\")\n            .and_modify(|_k, v| *v += 3)\n            .or_insert(\"key_b\", 0);\n        \n        assert_eq!(map[\"key_a\"], 7);\n        assert_eq!(map[\"key_b\"], 13);\n    }\n}\n```", "raw_entry::RawEntryMut::<'a, K, V, S, A>::and_replace_entry_with": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::RawEntryMut;\n\n    #[test]\n    fn test_and_replace_entry_with_replaces_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 42);\n\n        let entry = map\n            .raw_entry_mut()\n            .from_key(\"poneyland\")\n            .and_replace_entry_with(|k, v| {\n                assert_eq!(k, &\"poneyland\");\n                assert_eq!(v, 42);\n                Some(v + 1)\n            });\n\n        match entry {\n            RawEntryMut::Occupied(e) => {\n                assert_eq!(e.key(), &\"poneyland\");\n                assert_eq!(e.get(), &43);\n            },\n            RawEntryMut::Vacant(_) => panic!(),\n        }\n\n        assert_eq!(map[\"poneyland\"], 43);\n    }\n\n    #[test]\n    fn test_and_replace_entry_with_removes_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"poneyland\", 42);\n\n        let entry = map\n            .raw_entry_mut()\n            .from_key(\"poneyland\")\n            .and_replace_entry_with(|_k, _v| None);\n\n        match entry {\n            RawEntryMut::Vacant(_) => {},\n            RawEntryMut::Occupied(_) => panic!(),\n        }\n\n        assert!(!map.contains_key(\"poneyland\"));\n    }\n\n    #[test]\n    fn test_and_replace_entry_with_no_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        let entry = map\n            .raw_entry_mut()\n            .from_key(\"poneyland\")\n            .and_replace_entry_with(|_k, _v| panic!());\n\n        match entry {\n            RawEntryMut::Vacant(_) => {},\n            RawEntryMut::Occupied(_) => panic!(),\n        }\n    }\n}\n```", "raw_entry::RawEntryMut::<'a, K, V, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use std::hash::BuildHasherDefault;\n    use std::collections::hash_map::DefaultHasher;\n\n    #[test]\n    fn test_insert_occupied_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"key1\", 1);\n        let entry = map.raw_entry_mut().from_key(\"key1\").insert(\"key1\", 2);\n        assert_eq!(unsafe { entry.as_mut() }, &mut 2);\n    }\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry = map.raw_entry_mut().from_key(\"key2\").insert(\"key2\", 3);\n        assert_eq!(unsafe { entry.as_ref() }, &3);\n    }\n\n    #[test]\n    fn test_insert_replacing_existing_value() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"key3\", 5);\n        let entry = map.raw_entry_mut().from_key(\"key3\").insert(\"key3\", 10);\n        assert_eq!(entry.remove_entry(), (\"key3\", 10));\n    }\n\n    #[test]\n    fn test_insert_empty_map() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry = map.raw_entry_mut().from_key(\"key4\").insert(\"key4\", 15);\n        assert_eq!(unsafe { entry.as_ref() }, &15);\n    }\n\n    #[test]\n    fn test_insert_and_fetch() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut().from_key(\"key5\").insert(\"key5\", 20);\n        assert_eq!(map.get(\"key5\"), Some(&20));\n    }\n}\n```", "raw_entry::RawEntryMut::<'a, K, V, S, A>::or_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_insert_key_value() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let (key, value) = map.raw_entry_mut().from_key(\"test_key\").or_insert(\"test_key\", 42);\n        assert_eq!(*key, \"test_key\");\n        assert_eq!(*value, 42);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_update_value() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut().from_key(\"test_key\").or_insert(\"test_key\", 42);\n        let (_, value) = map.raw_entry_mut().from_key(\"test_key\").or_insert(\"test_key\", 100);\n        *value *= 2;\n        assert_eq!(map[\"test_key\"], 84);\n    }\n\n    #[test]\n    fn test_or_insert_with_occupied_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let (key, value) = map.raw_entry_mut().from_key(\"key1\").or_insert(\"key1\", 10);\n        assert_eq!(*key, \"key1\");\n        assert_eq!(*value, 10);\n        \n        let (key, value) = map.raw_entry_mut().from_key(\"key1\").or_insert(\"key1\", 20);\n        assert_eq!(*key, \"key1\");\n        assert_eq!(*value, 10); // Value should not change, as entry already occupied\n    }\n\n    #[test]\n    fn test_or_insert_non_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let (key, value) = map.raw_entry_mut().from_key(\"non_existing\").or_insert(\"non_existing\", 100);\n        assert_eq!(*key, \"non_existing\");\n        assert_eq!(*value, 100);\n    }\n\n    #[test]\n    fn test_or_insert_different_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let (key, value) = map.raw_entry_mut().from_key(\"key1\").or_insert(\"key1\", 10);\n        assert_eq!(*key, \"key1\");\n        assert_eq!(*value, 10);\n        \n        let (key2, value2) = map.raw_entry_mut().from_key(\"key2\").or_insert(\"key2\", 20);\n        assert_eq!(*key2, \"key2\");\n        assert_eq!(*value2, 20);\n        assert_eq!(map.len(), 2);\n    }\n}\n```", "raw_entry::RawEntryMut::<'a, K, V, S, A>::or_insert_with": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_with() {\n        let mut map: HashMap<&str, String> = HashMap::new();\n\n        let (key, value) = map.raw_entry_mut().from_key(\"poneyland\").or_insert_with(|| {\n            (\"poneyland\", \"hoho\".to_string())\n        });\n\n        assert_eq!(key, &\"poneyland\");\n        assert_eq!(value, &mut \"hoho\".to_string());\n\n        // Check if the entry is correctly inserted\n        assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n\n        // Test inserting with an existing key\n        let (key, value) = map.raw_entry_mut().from_key(\"poneyland\").or_insert_with(|| {\n            (\"poneyland\", \"new_value\".to_string())\n        });\n\n        assert_eq!(key, &\"poneyland\");\n        assert_eq!(value, &mut \"hoho\".to_string());\n\n        // Check the value has not changed\n        assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_get() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n        \n        // Create a raw entry mutable from key\n        match map.raw_entry_mut().from_key(&\"a\") {\n            RawEntryMut::Vacant(_) => panic!(\"Expected entry to be occupied\"),\n            RawEntryMut::Occupied(o) => {\n                let value = o.get();\n                assert_eq!(value, &100);\n            },\n        }\n\n        match map.raw_entry_mut().from_key(&\"b\") {\n            RawEntryMut::Vacant(_) => panic!(\"Expected entry to be occupied\"),\n            RawEntryMut::Occupied(o) => {\n                let value = o.get();\n                assert_eq!(value, &200);\n            },\n        }\n\n        match map.raw_entry_mut().from_key(&\"c\") {\n            RawEntryMut::Occupied(_) => panic!(\"Expected entry to be vacant\"),\n            RawEntryMut::Vacant(_) => (),\n        }\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_key_value": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use std::alloc::Global;\n\n    #[test]\n    fn test_get_key_value() {\n        // Create a HashMap instance\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        // Insert elements into the map\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n\n        // Use raw_entry_mut() to access the map entry\n        match map.raw_entry_mut().from_key(&\"a\") {\n            RawEntryMut::Vacant(_) => panic!(\"Expected entry to be occupied.\"),\n            RawEntryMut::Occupied(o) => {\n                // Assert the key-value pair is correct\n                assert_eq!(o.get_key_value(), (&\"a\", &100));\n            }\n        }\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_key_value_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use std::rc::Rc;\n\n    #[test]\n    fn test_get_key_value_mut() {\n        let key_one = Rc::new(\"a\");\n        let key_two = Rc::new(\"b\");\n        \n        let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n        map.insert(key_one.clone(), 10);\n        \n        assert_eq!(map[&key_one], 10);\n\n        match map.raw_entry_mut().from_key(&key_one) {\n            RawEntryMut::Vacant(_) => panic!(\"Entry should be occupied\"),\n            RawEntryMut::Occupied(mut occupied) => {\n                let (inside_key, inside_value) = occupied.get_key_value_mut();\n                *inside_key = key_two.clone();\n                *inside_value = 100;\n            }\n        }\n\n        assert_eq!(map[&key_two], 100);\n        assert!(Rc::strong_count(&key_one) == 1);\n        assert!(Rc::strong_count(&key_two) == 2);\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // This assumes that the module where RawOccupiedEntryMut and its methods are defined is in the same scope\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_get_mut() {\n        // Create a new HashMap and insert some values\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n\n        // Access the entry for the key \"a\"\n        match map.raw_entry_mut().from_key(&\"a\") {\n            RawEntryMut::Occupied(mut occupied) => {\n                // Get a mutable reference to the value and modify it\n                let value_mut = occupied.get_mut();\n                *value_mut += 900;\n                \n                // Assert that the value in the map is updated\n                assert_eq!(map[&\"a\"], 1000);\n            },\n            RawEntryMut::Vacant(_) => panic!(\"Entry should be occupied\"),\n        }\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_insert() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n\n        let mut entry = match map.raw_entry_mut().from_key(\"a\") {\n            RawEntryMut::Vacant(_) => panic!(\"Expected occupied entry\"),\n            RawEntryMut::Occupied(o) => o,\n        };\n\n        assert_eq!(entry.insert(1000), 100);\n        assert_eq!(map[\"a\"], 1000);\n    }\n\n    #[test]\n    fn test_insert_empty() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert!(map.raw_entry_mut().from_key(\"a\").is_vacant());\n\n        let mut entry = map.raw_entry_mut().from_key(\"a\").insert(100);\n        assert_eq!(map[\"a\"], 100);\n        assert!(entry.is_occupied());\n    }\n\n    #[test]\n    fn test_insert_multiple() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n\n        let mut entry = match map.raw_entry_mut().from_key(\"b\") {\n            RawEntryMut::Vacant(_) => panic!(\"Expected occupied entry\"),\n            RawEntryMut::Occupied(o) => o,\n        };\n\n        assert_eq!(entry.insert(300), 200);\n        assert_eq!(map[\"b\"], 300);\n    }\n\n    #[test]\n    fn test_insert_overwrite() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"x\", 50);\n\n        let mut entry = match map.raw_entry_mut().from_key(\"x\") {\n            RawEntryMut::Vacant(_) => panic!(\"Expected occupied entry\"),\n            RawEntryMut::Occupied(o) => o,\n        };\n\n        assert_eq!(entry.insert(200), 50);\n        assert_eq!(map[\"x\"], 200);\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::insert_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n    use std::rc::Rc;\n\n    #[test]\n    fn test_insert_key() {\n        let key_one = Rc::new(\"key_one\");\n        let key_two = Rc::new(\"key_two\");\n\n        let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n        map.insert(key_one.clone(), 42);\n\n        assert_eq!(map[&key_one], 42);\n        assert_eq!(Rc::strong_count(&key_one), 2);\n        assert_eq!(Rc::strong_count(&key_two), 1);\n\n        match map.raw_entry_mut().from_key(&key_one) {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(mut occupied) => {\n                let old_key = occupied.insert_key(key_two.clone());\n                assert!(Rc::ptr_eq(&old_key, &key_one));\n            }\n        }\n\n        assert_eq!(map[&key_two], 42);\n        assert_eq!(Rc::strong_count(&key_one), 1);\n        assert_eq!(Rc::strong_count(&key_two), 2);\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use std::rc::Rc;\n\n    #[test]\n    fn test_into_key() {\n        let key_one = Rc::new(\"key_one\");\n        let key_two = Rc::new(\"key_two\");\n\n        let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n        map.insert(key_one.clone(), 10);\n\n        assert_eq!(map[&key_one], 10);\n\n        let inside_key: &mut Rc<&str>;\n        match map.raw_entry_mut().from_key(&key_one) {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(o) => inside_key = o.into_key(),\n        }\n        *inside_key = key_two.clone();\n\n        assert_eq!(map[&key_two], 10);\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_key_value": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use std::rc::Rc;\n\n    #[test]\n    fn test_into_key_value() {\n        let key_one = Rc::new(\"a\");\n        let key_two = Rc::new(\"a\");\n        let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n        map.insert(key_one.clone(), 10);\n\n        let inside_key: &mut Rc<&str>;\n        let inside_value: &mut u32;\n\n        match map.raw_entry_mut().from_key(&key_one) {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(o) => {\n                let tuple = o.into_key_value();\n                inside_key = tuple.0;\n                inside_value = tuple.1;\n            }\n        }\n\n        *inside_key = key_two.clone();\n        *inside_value = 100;\n        \n        assert_eq!(map[&key_two], 100);\n        assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_into_mut() {\n        let mut map: HashMap<&str, u32> = [(\"a\", 100), (\"b\", 200)].into();\n\n        let value: &mut u32;\n\n        match map.raw_entry_mut().from_key(&\"a\") {\n            RawEntryMut::Vacant(_) => panic!(\"Expected occupied entry\"),\n            RawEntryMut::Occupied(o) => {\n                value = o.into_mut();\n            }\n        }\n        *value += 900;\n\n        assert_eq!(map[&\"a\"], 1000);\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::key": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_key_method() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n        \n        match map.raw_entry_mut().from_key(&\"a\") {\n            RawEntryMut::Vacant(_) => panic!(\"Expected entry to be occupied\"),\n            RawEntryMut::Occupied(o) => {\n                assert_eq!(o.key(), &\"a\");\n            },\n        }\n    }\n\n    #[test]\n    fn test_key_method_non_existent() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n        map.insert(\"b\", 200);\n        \n        match map.raw_entry_mut().from_key(&\"c\") {\n            RawEntryMut::Occupied(_) => panic!(\"Expected entry to be vacant\"),\n            RawEntryMut::Vacant(_) => {\n                // Check that looking up a non-existent key does not panic\n            },\n        }\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::key_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use std::rc::Rc;\n\n    #[test]\n    fn test_key_mut() {\n        let key_one = Rc::new(\"a\");\n        let key_two = Rc::new(\"b\");\n        \n        let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n        map.insert(key_one.clone(), 10);\n\n        assert_eq!(map[&key_one], 10);\n        \n        match map.raw_entry_mut().from_key(&key_one) {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(mut occupied) => {\n                assert_eq!(occupied.key(), &key_one);\n                *occupied.key_mut() = key_two.clone();\n            }\n        }\n        assert!(map.get(&key_one).is_none());\n        assert_eq!(map[&key_two], 10);\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_remove() {\n        let mut map: HashMap<&str, u32> = [(\"a\", 100), (\"b\", 200)].into();\n        \n        match map.raw_entry_mut().from_key(&\"a\") {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(o) => {\n                let value = o.remove();\n                assert_eq!(value, 100);\n                assert_eq!(map.get(&\"a\"), None);\n            },\n        }\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::remove_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_remove_entry() {\n        let mut map: HashMap<&str, u32> = [(\"a\", 100), (\"b\", 200)].into();\n\n        match map.raw_entry_mut().from_key(&\"a\") {\n            RawEntryMut::Vacant(_) => panic!(\"Expected occupied entry\"),\n            RawEntryMut::Occupied(o) => {\n                let (key, value) = o.remove_entry();\n                assert_eq!(key, \"a\");\n                assert_eq!(value, 100);\n            }\n        }\n        assert_eq!(map.get(&\"a\"), None);\n        assert_eq!(map.get(&\"b\"), Some(&200));\n    }\n}\n```", "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::replace_entry_with": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_replace_entry_with() {\n        let mut map: HashMap<&str, u32> = HashMap::from([(\"a\", 100), (\"b\", 200)]);\n\n        let raw_entry = match map.raw_entry_mut().from_key(&\"a\") {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(o) => o.replace_entry_with(|k, v| {\n                assert_eq!(k, &\"a\");\n                assert_eq!(v, 100);\n                Some(v + 900)\n            }),\n        };\n        let raw_entry = match raw_entry {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(o) => o.replace_entry_with(|k, v| {\n                assert_eq!(k, &\"a\");\n                assert_eq!(v, 1000);\n                None\n            }),\n        };\n        match raw_entry {\n            RawEntryMut::Vacant(_) => {},\n            RawEntryMut::Occupied(_) => panic!(),\n        };\n        assert_eq!(map.get(&\"a\"), None);\n    }\n}\n```", "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_insert() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        // Insert a new key-value pair\n        let key = \"c\";\n        let value = 300;\n        let entry = map.raw_entry_mut().from_key(key);\n        match entry {\n            RawEntryMut::Occupied(_) => panic!(\"Entry should be vacant\"),\n            RawEntryMut::Vacant(v) => {\n                let (k, v) = v.insert(key, value);\n                assert_eq!(*k, key);\n                assert_eq!(*v, value);\n            }\n        }\n        assert_eq!(map[&key], value);\n    }\n\n    #[test]\n    fn test_insert_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert(\"a\", 100);\n        \n        // Attempting to insert an existing key\n        let entry = map.raw_entry_mut().from_key(\"a\");\n        match entry {\n            RawEntryMut::Occupied(_) => {\n                // Existing entry should be found\n                assert_eq!(map.get_mut(\"a\"), Some(&mut 100));\n            },\n            RawEntryMut::Vacant(_) => panic!(\"Entry should be occupied\"),\n        }\n    }\n\n    #[test]\n    fn test_insert_multiple() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entries = vec![(\"a\", 100), (\"b\", 200), (\"c\", 300)];\n        \n        for (key, value) in entries {\n            let entry = map.raw_entry_mut().from_key(key);\n            match entry {\n                RawEntryMut::Occupied(_) => panic!(\"Entry should be vacant\"),\n                RawEntryMut::Vacant(v) => {\n                    let (k, v) = v.insert(key, value);\n                    assert_eq!(*k, key);\n                    assert_eq!(*v, value);\n                }\n            }\n        }\n        \n        assert_eq!(map[\"a\"], 100);\n        assert_eq!(map[\"b\"], 200);\n        assert_eq!(map[\"c\"], 300);\n    }\n}\n```", "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    #[test]\n    fn test_insert_entry() {\n        let mut table: RawTable<(u32, String)> = RawTable::new();\n        let key = 42;\n        let value = \"Hello\".to_string();\n        let hash = {\n            let mut hasher = DefaultHasher::new();\n            key.hash(&mut hasher);\n            hasher.finish()\n        };\n\n        // Insert an entry\n        let bucket = unsafe {\n            table.insert_entry(hash, (key, value), |x: &(u32, String)| {\n                let mut hasher = DefaultHasher::new();\n                x.0.hash(&mut hasher);\n                hasher.finish()\n            })\n        };\n\n        // Verify that the value was inserted\n        unsafe {\n            assert_eq!(bucket.as_ref(), &(key, \"Hello\".to_string()));\n        }\n    }\n}\n```", "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_hashed_nocheck": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::hash::{BuildHasher, Hash};\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n        use core::hash::Hasher;\n        let mut state = hash_builder.build_hasher();\n        key.hash(&mut state);\n        state.finish()\n    }\n\n    #[test]\n    fn test_insert_hashed_nocheck() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key = \"test_key\";\n        let value = 50;\n        let hash = compute_hash(map.hasher(), &key);\n        \n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n        if let RawEntryMut::Vacant(v) = entry {\n            let (k, v) = v.insert_hashed_nocheck(hash, key, value);\n            assert_eq!(*k, key);\n            assert_eq!(*v, value);\n        } else {\n            panic!(\"Expected a vacant entry, but found occupied.\");\n        }\n\n        assert_eq!(map[&\"test_key\"], 50);\n    }\n\n    #[test]\n    fn test_insert_hashed_nocheck_overwrite() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key = \"test_key\";\n        let initial_value = 50;\n        let new_value = 100;\n        let hash = compute_hash(map.hasher(), &key);\n        \n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n        if let RawEntryMut::Vacant(v) = entry {\n            v.insert_hashed_nocheck(hash, key, initial_value);\n        }\n\n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n        if let RawEntryMut::Occupied(mut v) = entry {\n            let (k, v) = v.insert_hashed_nocheck(hash, key, new_value);\n            assert_eq!(*k, key);\n            assert_eq!(*v, new_value);\n        } else {\n            panic!(\"Expected an occupied entry, but found vacant.\");\n        }\n\n        assert_eq!(map[&\"test_key\"], 100);\n    }\n}\n```", "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_with_hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use core::hash::{BuildHasher, Hash};\n    \n    #[test]\n    fn test_insert_with_hasher() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key = \"test_key\";\n        let hash_builder = map.hasher().clone();\n        let hash = make_hasher(&hash_builder)(&key);\n\n        match map.raw_entry_mut().from_hash(hash, |q| q == &key) {\n            RawEntryMut::Occupied(_) => panic!(\"Entry already exists.\"),\n            RawEntryMut::Vacant(v) => {\n                let (k, v) = v.insert_with_hasher(hash, key, 50, make_hasher(&hash_builder));\n                assert_eq!(k, &mut \"test_key\");\n                assert_eq!(v, &mut 50);\n            },\n        }\n\n        assert_eq!(map[&key], 50);\n    }\n\n    fn make_hasher<K, S>(hash_builder: &S) -> impl Fn(&K) -> u64 + '_\n    where\n        K: Hash + ?Sized,\n        S: BuildHasher,\n    {\n        move |key: &K| {\n            use core::hash::Hasher;\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n    }\n}\n```", "scopeguard::ScopeGuard::<T, F>::into_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem::ManuallyDrop;\n\n    #[test]\n    fn test_into_inner() {\n        let mut value = 42;\n        let drop_fn_called = std::sync::Arc::new(std::sync::Mutex::new(false));\n        let drop_fn = {\n            let drop_fn_called = drop_fn_called.clone();\n            move |val: &mut i32| {\n                *val += 1;\n                let mut called = drop_fn_called.lock().unwrap();\n                *called = true;\n            }\n        };\n\n        let guard = ScopeGuard { dropfn, value };\n\n        let inner_value = ScopeGuard::into_inner(guard);\n\n        assert_eq!(inner_value, 42);\n        assert!(*drop_fn_called.lock().unwrap());\n    }\n}\n```", "scopeguard::guard": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use scopeguard::guard;\n\n    #[test]\n    fn test_guard() {\n        let mut dropped_value = 0;\n        {\n            let _guard = guard(5, |value| {\n                dropped_value = *value;\n                *value = 0;\n            });\n            assert_eq!(*_guard, 5);\n            *_guard += 1; // Mutate the value through the guard\n        }\n        assert_eq!(dropped_value, 5); // Check if dropfn was called\n    }\n\n    #[test]\n    fn test_guard_into_inner() {\n        let mut drop_value = 0;\n        let guard = guard(10, |value| {\n            drop_value = *value;\n            *value = 0;\n        });\n        let inner_value = ScopeGuard::into_inner(guard);\n        assert_eq!(inner_value, 10);\n        assert_eq!(drop_value, 10); // Check if dropfn was called\n    }\n}\n```", "set::Entry::<'a, T, S, A>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_get_occupied_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.insert(\"poneyland\");\n\n        assert_eq!(set.entry(\"poneyland\").get(), &\"poneyland\");\n    }\n\n    #[test]\n    fn test_get_vacant_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        \n        // Should insert and then get\n        assert_eq!(set.entry(\"horseland\").get(), &\"horseland\");\n    }\n\n    #[test]\n    fn test_get_nonexistent_entry_after_insert() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.insert(\"poneyland\");\n        \n        assert_eq!(set.entry(\"horseland\").get(), &\"horseland\");\n        set.insert(\"horseland\");\n        assert_eq!(set.entry(\"horseland\").get(), &\"horseland\");\n    }\n}\n```", "set::Entry::<'a, T, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_insert_occupied_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry(\"horseyland\").insert();\n\n        assert_eq!(entry.get(), &\"horseyland\");\n        assert!(set.contains(\"horseyland\"));\n    }\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry(\"poneyland\").insert();\n\n        assert_eq!(entry.get(), &\"poneyland\");\n        assert!(set.contains(\"poneyland\"));\n    }\n\n    #[test]\n    fn test_insert_overwrite() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry(\"land\").insert();\n        assert_eq!(entry.get(), &\"land\");\n\n        let entry = set.entry(\"land\").insert();\n        assert_eq!(entry.get(), &\"land\");\n        assert!(set.contains(\"land\"));\n    }\n\n    #[test]\n    fn test_insert_multiple_entries() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry1 = set.entry(\"one\").insert();\n        let entry2 = set.entry(\"two\").insert();\n\n        assert_eq!(entry1.get(), &\"one\");\n        assert_eq!(entry2.get(), &\"two\");\n        assert!(set.contains(\"one\"));\n        assert!(set.contains(\"two\"));\n    }\n\n    #[test]\n    fn test_insert_multiple_entries_with_existence_check() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.insert(\"existing\");\n\n        let entry = set.entry(\"existing\").insert();\n\n        assert_eq!(entry.get(), &\"existing\");\n        assert_eq!(set.len(), 1);\n    }\n}\n```", "set::Entry::<'a, T, S, A>::or_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_or_insert_nonexistent_key() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.entry(\"poneyland\").or_insert();\n        assert!(set.contains(\"poneyland\"));\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_existing_key() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.entry(\"poneyland\").or_insert();\n        set.entry(\"poneyland\").or_insert();\n        assert!(set.contains(\"poneyland\"));\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_multiple_keys() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.entry(\"poneyland\").or_insert();\n        set.entry(\"unicornland\").or_insert();\n        assert!(set.contains(\"poneyland\"));\n        assert!(set.contains(\"unicornland\"));\n        assert_eq!(set.len(), 2);\n    }\n}\n```", "set::HashSet::<T, S, A>::allocation_size": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_allocation_size_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.allocation_size(), 0);\n    }\n\n    #[test]\n    fn test_allocation_size_non_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert!(set.allocation_size() > 0);\n    }\n\n    #[test]\n    fn test_allocation_size_after_clear() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let size_before_clear = set.allocation_size();\n        set.clear();\n        assert_eq!(set.allocation_size(), size_before_clear);\n    }\n\n    #[test]\n    fn test_allocation_size_after_reinsert() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let size_before_clear = set.allocation_size();\n        set.clear();\n        set.insert(4);\n        set.insert(5);\n        assert!(set.allocation_size() > 0);\n        assert!(set.allocation_size() < size_before_clear);\n    }\n}\n```", "set::HashSet::<T, S, A>::allocator": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_allocator() {\n        // Create a new HashSet with a specific allocator\n        let allocator = bumpalo::Bump::new(); // Example allocator\n        let set: HashSet<i32, hashbrown::DefaultHashBuilder, _> = HashSet::new_in(&allocator);\n\n        // Assert that the allocator is the one we provided\n        assert_eq!(set.allocator() as *const _, &allocator as *const _);\n    }\n\n    #[test]\n    fn test_allocator_after_insertion() {\n        // Create a new HashSet with a specific allocator\n        let allocator = bumpalo::Bump::new(); // Example allocator\n        let mut set: HashSet<i32, hashbrown::DefaultHashBuilder, _> = HashSet::new_in(&allocator);\n\n        // Insert an element into the set\n        set.insert(10);\n\n        // Assert that the allocator is still the one we provided\n        assert_eq!(set.allocator() as *const _, &allocator as *const _);\n    }\n\n    #[test]\n    fn test_allocator_with_different_allocators() {\n        let allocator1 = bumpalo::Bump::new(); // First allocator\n        let allocator2 = bumpalo::Bump::new(); // Second allocator\n\n        let mut set1: HashSet<i32, hashbrown::DefaultHashBuilder, _> = HashSet::new_in(&allocator1);\n        let mut set2: HashSet<i32, hashbrown::DefaultHashBuilder, _> = HashSet::new_in(&allocator2);\n\n        // Insert elements into both sets\n        set1.insert(1);\n        set2.insert(2);\n\n        // Assert that the allocators are different\n        assert_ne!(set1.allocator() as *const _, set2.allocator() as *const _);\n    }\n}\n```", "set::HashSet::<T, S, A>::capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_capacity() {\n        // Test with initial capacity\n        let set: HashSet<i32> = HashSet::with_capacity(100);\n        assert!(set.capacity() >= 100);\n\n        // Test with zero initial capacity\n        let empty_set: HashSet<i32> = HashSet::with_capacity(0);\n        assert_eq!(empty_set.capacity(), 0);\n        \n        // Test with elements added\n        let mut set_with_elements = HashSet::with_capacity(5);\n        set_with_elements.insert(1);\n        set_with_elements.insert(2);\n        set_with_elements.insert(3);\n        assert!(set_with_elements.capacity() >= 5);\n        \n        // Test capacity after reaching initial capacity\n        set_with_elements.insert(4);\n        set_with_elements.insert(5);\n        assert!(set_with_elements.capacity() >= 5);\n        \n        // Test adding more elements\n        set_with_elements.insert(6);\n        assert!(set_with_elements.capacity() >= 6);\n    }\n}\n```", "set::HashSet::<T, S, A>::clear": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_clear() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.len(), 3);\n        set.clear();\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_clear_on_empty_set() {\n        let mut set = HashSet::new();\n        assert!(set.is_empty());\n        set.clear();\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_clear_after_insert() {\n        let mut set = HashSet::new();\n        set.insert(10);\n        set.insert(20);\n        assert_eq!(set.len(), 2);\n        set.clear();\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_clear_does_not_panic() {\n        let mut set = HashSet::<i32>::new();\n        set.clear(); // Calling clear on an empty set\n        assert!(set.is_empty());\n    }\n}\n```", "set::HashSet::<T, S, A>::contains": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_contains() {\n        let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert!(!set.contains(&4));\n    }\n\n    #[test]\n    fn test_contains_with_nonexistent_element() {\n        let set: HashSet<_> = [5, 6, 7].into_iter().collect();\n        assert!(!set.contains(&8));\n    }\n\n    #[test]\n    fn test_contains_empty_set() {\n        let set: HashSet<i32> = HashSet::new();\n        assert!(!set.contains(&1));\n    }\n\n    #[test]\n    fn test_contains_with_different_types() {\n        let set: HashSet<&str> = [\"a\", \"b\", \"c\"].iter().cloned().collect();\n        assert!(set.contains(&\"a\"));\n        assert!(!set.contains(&\"d\"));\n    }\n}\n```", "set::HashSet::<T, S, A>::difference": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn difference_test() {\n        let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        let b: HashSet<_> = [2, 3, 4].iter().cloned().collect();\n\n        let diff_a_b: HashSet<_> = a.difference(&b).cloned().collect();\n        let diff_b_a: HashSet<_> = b.difference(&a).cloned().collect();\n\n        assert_eq!(diff_a_b, [1].iter().cloned().collect::<HashSet<_>>());\n        assert_eq!(diff_b_a, [4].iter().cloned().collect::<HashSet<_>>());\n    }\n\n    #[test]\n    fn difference_empty_test() {\n        let a: HashSet<_> = HashSet::new();\n        let b: HashSet<_> = HashSet::new();\n\n        let diff_a_b: HashSet<_> = a.difference(&b).cloned().collect();\n        let diff_b_a: HashSet<_> = b.difference(&a).cloned().collect();\n\n        assert!(diff_a_b.is_empty());\n        assert!(diff_b_a.is_empty());\n    }\n\n    #[test]\n    fn difference_no_common_elements_test() {\n        let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        let b: HashSet<_> = [4, 5, 6].iter().cloned().collect();\n\n        let diff_a_b: HashSet<_> = a.difference(&b).cloned().collect();\n        let diff_b_a: HashSet<_> = b.difference(&a).cloned().collect();\n\n        assert_eq!(diff_a_b, a);\n        assert_eq!(diff_b_a, b);\n    }\n\n    #[test]\n    fn difference_same_elements_test() {\n        let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        let b: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n\n        let diff_a_b: HashSet<_> = a.difference(&b).cloned().collect();\n\n        assert!(diff_a_b.is_empty());\n    }\n\n    #[test]\n    fn difference_with_empty_set_test() {\n        let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        let b: HashSet<_> = HashSet::new();\n\n        let diff_a_b: HashSet<_> = a.difference(&b).cloned().collect();\n\n        assert_eq!(diff_a_b, a);\n    }\n}\n```", "set::HashSet::<T, S, A>::drain": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_drain_empty_set() {\n        let mut set: HashSet<i32> = HashSet::new();\n        let drained: Vec<i32> = set.drain().collect();\n        assert!(drained.is_empty());\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_drain_non_empty_set() {\n        let mut set: HashSet<i32> = [1, 2, 3].iter().copied().collect();\n        let drained: Vec<i32> = set.drain().collect();\n\n        assert_eq!(drained.len(), 3);\n        assert!(set.is_empty());\n        for i in drained {\n            assert!(i == 1 || i == 2 || i == 3);\n        }\n    }\n\n    #[test]\n    fn test_drain_partial_iteration() {\n        let mut set: HashSet<i32> = [1, 2, 3, 4].iter().copied().collect();\n        let mut drained_iter = set.drain();\n        \n        assert_eq!(drained_iter.next(), Some(1));\n        assert_eq!(drained_iter.next(), Some(2));\n\n        // Dropping the iterator should still clear the set\n        drop(drained_iter);\n        assert!(set.is_empty());\n    }\n}\n```", "set::HashSet::<T, S, A>::entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use hashbrown::hash_set::Entry::*;\n\n    #[test]\n    fn test_entry_vacant_insert() {\n        let mut set = HashSet::new();\n        let entry = set.entry('a');\n        if let Vacant(vacant_entry) = entry {\n            vacant_entry.insert();\n        }\n        assert!(set.contains(&'a'));\n    }\n\n    #[test]\n    fn test_entry_occupied_replace() {\n        let mut set = HashSet::new();\n        set.insert('b');\n        let entry = set.entry('b');\n        if let Occupied(occupied_entry) = entry {\n            occupied_entry.remove();\n        }\n        assert!(!set.contains(&'b'));\n    }\n\n    #[test]\n    fn test_entry_occupied_insert() {\n        let mut set = HashSet::new();\n        set.insert('c');\n        let entry = set.entry('c');\n        if let Occupied(occupied_entry) = entry {\n            occupied_entry.remove();\n        }\n        assert!(!set.contains(&'c'));\n        let entry = set.entry('c');\n        if let Vacant(vacant_entry) = entry {\n            vacant_entry.insert();\n        }\n        assert!(set.contains(&'c'));\n    }\n\n    #[test]\n    fn test_entry_vacant_insert_existing() {\n        let mut set = HashSet::new();\n        set.insert('d');\n        let entry = set.entry('d');\n        if let Occupied(occupied_entry) = entry {\n            assert!(set.contains(&'d'));\n            occupied_entry.remove();\n        }\n        assert!(!set.contains(&'d'));\n    }\n\n    #[test]\n    fn test_entry_insert_multiple() {\n        let mut set = HashSet::new();\n        let mut seen = HashSet::new();\n        let chars = vec!['e', 'f', 'g', 'e'];\n\n        for ch in chars {\n            match seen.entry(ch) {\n                Vacant(vacant_entry) => {\n                    vacant_entry.insert();\n                }\n                Occupied(_) => {\n                    set.entry(ch).or_insert_with(|| {\n                        set.insert(ch);\n                        set.get(&ch).unwrap()  // To simulate some in-place manipulation\n                    });\n                }\n            }\n        }\n\n        assert!(set.contains(&'e'));\n        assert!(!set.contains(&'f'));\n        assert!(!set.contains(&'g'));\n    }\n}\n```", "set::HashSet::<T, S, A>::extract_if": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_extract_if() {\n        let mut set: HashSet<i32> = HashSet::from_iter(0..8);\n        let drained: HashSet<i32> = set.extract_if(|&v| v % 2 == 0).collect();\n\n        let mut evens = drained.into_iter().collect::<Vec<_>>();\n        let mut odds = set.into_iter().collect::<Vec<_>>();\n        evens.sort();\n        odds.sort();\n\n        assert_eq!(evens, vec![0, 2, 4, 6]);\n        assert_eq!(odds, vec![1, 3, 5, 7]);\n    }\n\n    #[test]\n    fn test_extract_if_not_exhausted() {\n        let mut set: HashSet<i32> = HashSet::from_iter(0..8);\n        {\n            let _drained = set.extract_if(|&v| v % 2 != 0);\n        }\n        assert_eq!(set.len(), 8);\n    }\n\n    #[test]\n    fn test_extract_if_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        let drained: HashSet<i32> = set.extract_if(|&v| v % 2 == 0).collect();\n\n        assert!(drained.is_empty());\n        assert!(set.is_empty());\n    }\n}\n```", "set::HashSet::<T, S, A>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_get_existing_value() {\n        let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        assert_eq!(set.get(&2), Some(&2));\n    }\n\n    #[test]\n    fn test_get_non_existing_value() {\n        let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        assert_eq!(set.get(&4), None);\n    }\n\n    #[test]\n    fn test_get_with_different_reference_type() {\n        let set: HashSet<_> = [String::from(\"hello\"), String::from(\"world\")].iter().cloned().collect();\n        assert_eq!(set.get(&String::from(\"hello\")), Some(&String::from(\"hello\")));\n        assert_eq!(set.get(&String::from(\"notfound\")), None);\n    }\n\n    #[test]\n    fn test_get_with_non_hashable_type() {\n        let set: HashSet<_> = [1.0, 2.0, 3.0].iter().cloned().collect();\n        assert_eq!(set.get(&2.0), Some(&2.0));\n        assert_eq!(set.get(&4.0), None);\n    }\n\n    #[test]\n    fn test_get_on_empty_set() {\n        let set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.get(&1), None);\n    }\n}\n```", "set::HashSet::<T, S, A>::get_or_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_get_or_insert() {\n        let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        assert_eq!(set.len(), 3);\n        assert_eq!(set.get_or_insert(2), &2);\n        assert_eq!(set.get_or_insert(100), &100);\n        assert_eq!(set.len(), 4); // 100 was inserted\n    }\n\n    #[test]\n    fn test_get_or_insert_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.len(), 0);\n        assert_eq!(set.get_or_insert(42), &42);\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_get_or_insert_multiple() {\n        let mut set: HashSet<_> = HashSet::new();\n        assert_eq!(set.get_or_insert(1), &1);\n        assert_eq!(set.get_or_insert(2), &2);\n        assert_eq!(set.len(), 2);\n        assert_eq!(set.get_or_insert(1), &1);  // 1 should not be inserted again\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_get_or_insert_different_types() {\n        let mut set: HashSet<String> = HashSet::new();\n        assert_eq!(set.get_or_insert(\"hello\".to_string()), &\"hello\".to_string());\n        assert_eq!(set.len(), 1);\n        assert_eq!(set.get_or_insert(\"world\".to_string()), &\"world\".to_string());\n        assert_eq!(set.len(), 2);\n    }\n}\n```", "set::HashSet::<T, S, A>::get_or_insert_with": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_get_or_insert_with_insert_new() {\n        let mut set: HashSet<String> = HashSet::new();\n        let value = set.get_or_insert_with(\"fish\", str::to_owned);\n        assert_eq!(value, \"fish\");\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_get_or_insert_with_existing_value() {\n        let mut set: HashSet<String> = [\"cat\", \"dog\"].iter().map(|&pet| pet.to_owned()).collect();\n        let value = set.get_or_insert_with(\"cat\", str::to_owned);\n        assert_eq!(value, \"cat\");\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_get_or_insert_with_insert_existing() {\n        let mut set: HashSet<String> = HashSet::new();\n        set.insert(\"dog\".to_owned());\n        let value = set.get_or_insert_with(\"dog\", str::to_owned);\n        assert_eq!(value, \"dog\");\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_get_or_insert_with_panic_on_non_equivalent() {\n        let mut set: HashSet<String> = HashSet::new();\n        set.get_or_insert_with(\"rust\", |_| String::from(\"not rust\"));\n    }\n\n    #[test]\n    fn test_get_or_insert_with_multiple() {\n        let mut set: HashSet<String> = HashSet::new();\n        let value1 = set.get_or_insert_with(\"pet\", str::to_owned);\n        let value2 = set.get_or_insert_with(\"pet\", str::to_owned);\n        assert_eq!(value1, value2);\n        assert_eq!(set.len(), 1);\n    }\n}\n```", "set::HashSet::<T, S, A>::hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashSet, DefaultHashBuilder};\n\n    #[test]\n    fn test_hasher() {\n        // Create a HashSet with a specified hasher\n        let hasher = DefaultHashBuilder::default();\n        let set: HashSet<i32> = HashSet::with_hasher(hasher);\n        \n        // Retrieve a reference to the hasher\n        let retrieved_hasher: &DefaultHashBuilder = set.hasher();\n        \n        // Ensure the retrieved hasher is the same as the original\n        assert_eq!(retrieved_hasher, &DefaultHashBuilder::default());\n    }\n}\n```", "set::HashSet::<T, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_insert() {\n        let mut set = HashSet::new();\n\n        // Inserting a new element\n        assert_eq!(set.insert(1), true);\n        assert_eq!(set.len(), 1);\n\n        // Inserting the same element again\n        assert_eq!(set.insert(1), false);\n        assert_eq!(set.len(), 1);\n\n        // Inserting a different element\n        assert_eq!(set.insert(2), true);\n        assert_eq!(set.len(), 2);\n\n        // Inserting another new element\n        assert_eq!(set.insert(3), true);\n        assert_eq!(set.len(), 3);\n    }\n}\n```", "set::HashSet::<T, S, A>::insert_unique_unchecked": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_insert_unique_unchecked() {\n        let mut set: HashSet<i32> = HashSet::new();\n        unsafe {\n            let value = 42;\n            set.insert_unique_unchecked(value);\n            assert!(set.contains(&value));\n\n            let another_value = 100;\n            set.insert_unique_unchecked(another_value);\n            assert!(set.contains(&another_value));\n\n            assert_eq!(set.len(), 2);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_insert_unique_unchecked_unsoundness() {\n        let mut set: HashSet<i32> = HashSet::new();\n        unsafe {\n            set.insert_unique_unchecked(42);\n            set.insert_unique_unchecked(42); // This should cause panic or undefined behavior\n        }\n    }\n\n    #[test]\n    fn test_insert_multiple_unique() {\n        let mut set: HashSet<String> = HashSet::new();\n        unsafe {\n            let value1 = String::from(\"hello\");\n            let value2 = String::from(\"world\");\n            set.insert_unique_unchecked(value1);\n            set.insert_unique_unchecked(value2);\n            assert!(set.contains(&\"hello\".to_string()));\n            assert!(set.contains(&\"world\".to_string()));\n            assert_eq!(set.len(), 2);\n        }\n    }\n\n    #[test]\n    fn test_no_duplicates() {\n        let mut set: HashSet<i32> = HashSet::new();\n        unsafe {\n            set.insert_unique_unchecked(1);\n            set.insert_unique_unchecked(2);\n            assert!(set.contains(&1));\n            assert!(set.contains(&2));\n            assert_eq!(set.len(), 2);\n        }\n    }\n}\n```", "set::HashSet::<T, S, A>::intersection": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_intersection_with_different_elements() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n        let intersection: HashSet<_> = a.intersection(&b).collect();\n        assert_eq!(intersection, [2, 3].iter().collect::<HashSet<_>>());\n    }\n\n    #[test]\n    fn test_intersection_with_no_common_elements() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = [4, 5, 6].into_iter().collect();\n        let intersection: HashSet<_> = a.intersection(&b).collect();\n        assert_eq!(intersection.len(), 0);\n    }\n\n    #[test]\n    fn test_intersection_with_identical_sets() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let intersection: HashSet<_> = a.intersection(&a).collect();\n        assert_eq!(intersection, a);\n    }\n\n    #[test]\n    fn test_intersection_with_empty_set() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = HashSet::new();\n        let intersection: HashSet<_> = a.intersection(&b).collect();\n        assert!(intersection.is_empty());\n    }\n\n    #[test]\n    fn test_intersection_empty_with_empty_set() {\n        let a: HashSet<_> = HashSet::new();\n        let b: HashSet<_> = HashSet::new();\n        let intersection: HashSet<_> = a.intersection(&b).collect();\n        assert!(intersection.is_empty());\n    }\n}\n```", "set::HashSet::<T, S, A>::is_disjoint": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_is_disjoint() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let mut b = HashSet::new();\n        \n        assert_eq!(a.is_disjoint(&b), true);\n        \n        b.insert(4);\n        assert_eq!(a.is_disjoint(&b), true);\n        \n        b.insert(1);\n        assert_eq!(a.is_disjoint(&b), false);\n       \n        let c: HashSet<_> = [4, 5, 6].into_iter().collect();\n        assert_eq!(a.is_disjoint(&c), true);\n        \n        b.insert(5);\n        assert_eq!(a.is_disjoint(&b), false);\n        \n        b.clear();\n        b.insert(2);\n        assert_eq!(a.is_disjoint(&b), false);\n    }\n}\n```", "set::HashSet::<T, S, A>::is_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_is_empty() {\n        let mut set = HashSet::new();\n        assert!(set.is_empty());\n        set.insert(1);\n        assert!(!set.is_empty());\n        set.remove(&1);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_is_empty_after_insertions() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert!(set.is_empty());\n        set.insert(1);\n        set.insert(2);\n        assert!(!set.is_empty());\n    }\n    \n    #[test]\n    fn test_is_empty_after_clear() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.clear();\n        assert!(set.is_empty());\n    }\n    \n    #[test]\n    fn test_is_empty_with_multiple_insertions() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        assert!(!set.is_empty());\n        set.insert(3);\n        assert!(!set.is_empty());\n    }\n\n    #[test]\n    fn test_is_empty_with_different_data_types() {\n        let mut set: HashSet<String> = HashSet::new();\n        assert!(set.is_empty());\n        set.insert(\"Hello\".to_string());\n        assert!(!set.is_empty());\n        set.remove(\"Hello\");\n        assert!(set.is_empty());\n    }\n}\n```", "set::HashSet::<T, S, A>::is_subset": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_is_subset() {\n        let sup: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let mut set = HashSet::new();\n\n        assert_eq!(set.is_subset(&sup), true);\n        set.insert(2);\n        assert_eq!(set.is_subset(&sup), true);\n        set.insert(4);\n        assert_eq!(set.is_subset(&sup), false);\n    }\n\n    #[test]\n    fn test_is_subset_empty() {\n        let empty: HashSet<_> = HashSet::new();\n        let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n\n        assert!(empty.is_subset(&set));\n        assert!(set.is_subset(&empty) == false);\n    }\n\n    #[test]\n    fn test_is_subset_equal() {\n        let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let sup = set.clone();\n\n        assert!(set.is_subset(&sup));\n        assert!(sup.is_subset(&set));\n    }\n\n    #[test]\n    fn test_is_subset_with_disjoint_sets() {\n        let set_a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let set_b: HashSet<_> = [4, 5, 6].into_iter().collect();\n\n        assert_eq!(set_a.is_subset(&set_b), false);\n    }\n}\n```", "set::HashSet::<T, S, A>::is_superset": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_is_superset() {\n        let sub: HashSet<_> = [1, 2].into_iter().collect();\n        let mut set = HashSet::new();\n\n        assert_eq!(set.is_superset(&sub), false);\n\n        set.insert(0);\n        set.insert(1);\n        assert_eq!(set.is_superset(&sub), false);\n\n        set.insert(2);\n        assert_eq!(set.is_superset(&sub), true);\n    }\n\n    #[test]\n    fn test_is_superset_empty() {\n        let mut set: HashSet<_> = HashSet::new();\n        let sub: HashSet<_> = HashSet::new();\n\n        assert_eq!(set.is_superset(&sub), true);\n    }\n\n    #[test]\n    fn test_is_superset_not_superset() {\n        let mut set: HashSet<_> = [1, 2].iter().cloned().collect();\n        let sub: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n\n        assert_eq!(set.is_superset(&sub), false);\n    }\n\n    #[test]\n    fn test_is_superset_with_different_elements() {\n        let set: HashSet<_> = [1, 2, 3, 4].iter().cloned().collect();\n        let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n\n        assert_eq!(set.is_superset(&sub), true);\n    }\n}\n```", "set::HashSet::<T, S, A>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust this import as necessary to reference HashSet\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_iter_empty_set() {\n        let set: HashSet<i32> = HashSet::new();\n        let iter: Vec<_> = set.iter().collect();\n        assert!(iter.is_empty());\n    }\n\n    #[test]\n    fn test_iter_single_element() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        let iter: Vec<_> = set.iter().collect();\n        assert_eq!(iter.len(), 1);\n        assert!(iter.contains(&&1));\n    }\n\n    #[test]\n    fn test_iter_multiple_elements() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let iter: Vec<_> = set.iter().collect();\n        assert_eq!(iter.len(), 3);\n        assert!(iter.contains(&&1) || iter.contains(&&2) || iter.contains(&&3));\n    }\n\n    #[test]\n    fn test_iter_no_duplicates() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(1); // Inserting duplicates\n        set.insert(2);\n        let iter: Vec<_> = set.iter().collect();\n        assert_eq!(iter.len(), 2);\n        assert!(iter.contains(&&1));\n        assert!(iter.contains(&&2));\n    }\n\n    #[test]\n    fn test_iter_order() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let iter: Vec<_> = set.iter().collect();\n        assert!(iter.len() == 3);\n        // The order is arbitrary, test contains instead.\n        assert!(iter.contains(&&1) || iter.contains(&&2) || iter.contains(&&3));\n    }\n}\n```", "set::HashSet::<T, S, A>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_len() {\n        let mut set = HashSet::new();\n        assert_eq!(set.len(), 0);\n\n        set.insert(1);\n        assert_eq!(set.len(), 1);\n\n        set.insert(2);\n        assert_eq!(set.len(), 2);\n\n        set.remove(&1);\n        assert_eq!(set.len(), 1);\n        \n        set.clear();\n        assert_eq!(set.len(), 0);\n    }\n}\n```", "set::HashSet::<T, S, A>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn remove_existing_value() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        assert_eq!(set.remove(&1), true);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn remove_non_existing_value() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        assert_eq!(set.remove(&2), false);\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn remove_multiple_values() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        assert_eq!(set.remove(&2), true);\n        assert_eq!(set.len(), 2);\n        assert_eq!(set.remove(&2), false);\n    }\n\n    #[test]\n    fn remove_with_same_reference() {\n        let mut set = HashSet::new();\n        let value = 3;\n        set.insert(value);\n        \n        assert_eq!(set.remove(&value), true);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn remove_non_hashable() {\n        #[derive(Debug, Hash, Eq, PartialEq)]\n        struct NonHashableStruct;\n        \n        let mut set = HashSet::new();\n        set.insert(NonHashableStruct);\n        assert_eq!(set.remove(&NonHashableStruct), true);\n        assert_eq!(set.len(), 0);\n    }\n}\n```", "set::HashSet::<T, S, A>::replace": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_replace_existing_value() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        let replaced = set.replace(1);\n        assert_eq!(replaced, Some(1));\n        assert!(set.contains(&1)); // The value should still exist in the set\n    }\n\n    #[test]\n    fn test_replace_replacing_value() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.replace(1);\n        let replaced = set.replace(2);\n        assert_eq!(replaced, None); // No value was replaced\n        assert!(set.contains(&2)); // The new value should now exist in the set\n        assert!(!set.contains(&1)); // The old value should not exist in the set\n    }\n\n    #[test]\n    fn test_replace_without_existing_value() {\n        let mut set = HashSet::new();\n        let replaced = set.replace(1);\n        assert_eq!(replaced, None); // No value was replaced\n        assert!(set.contains(&1)); // The new value should exist in the set\n    }\n\n    #[test]\n    fn test_replace_multiple_replacements() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.replace(2);\n        let replaced = set.replace(1);\n        assert_eq!(replaced, Some(1)); // The old value 1 is replaced\n        assert!(!set.contains(&1)); // The old value should not exist\n        assert!(set.contains(&2)); // The value 2 should still exist\n    }\n\n    #[test]\n    fn test_replace_vector() {\n        let mut set = HashSet::new();\n        let v1 = vec![1, 2, 3];\n        set.replace(v1.clone());\n        let v2 = vec![4, 5, 6];\n        let replaced = set.replace(v2.clone());\n        assert_eq!(replaced, None); // No value was replaced\n        assert!(set.contains(&v1)); // The original value should exist\n        assert!(set.contains(&v2)); // The new value should exist\n    }\n}\n```", "set::HashSet::<T, S, A>::reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_reserve_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.reserve(10);\n        assert!(set.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_reserve_non_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        let current_capacity = set.capacity();\n        set.reserve(5);\n        assert!(set.capacity() >= current_capacity);\n        assert!(set.capacity() >= 5);\n    }\n\n    #[test]\n    fn test_reserve_large_number() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.reserve(usize::MAX);\n        assert!(set.capacity() >= usize::MAX);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_reserve_panic() {\n        let mut set: HashSet<i32> = HashSet::new();\n        // This should panic as it exceeds isize::MAX\n        set.reserve(usize::MAX);\n    }\n}\n```", "set::HashSet::<T, S, A>::retain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_retain_even_numbers() {\n        let xs = [1, 2, 3, 4, 5, 6];\n        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n        set.retain(|&k| k % 2 == 0);\n        assert_eq!(set.len(), 3);\n        let retained: Vec<i32> = set.iter().cloned().collect();\n        assert_eq!(retained, vec![2, 4, 6]);\n    }\n\n    #[test]\n    fn test_retain_empty_set() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.retain(|&k| k % 2 == 0);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_retain_none() {\n        let xs = [1, 3, 5, 7];\n        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n        set.retain(|&k| k % 2 == 0);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_retain_all() {\n        let xs = [1, 2, 3, 4, 5];\n        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n        set.retain(|&k| true);\n        assert_eq!(set.len(), 5);\n    }\n\n    #[test]\n    fn test_retain_none_condition() {\n        let xs = [1, 2, 3, 4];\n        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n        set.retain(|&k| k == 0);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_retain_conditionally() {\n        let xs = [1, 2, 3, 4, 5];\n        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n        set.retain(|&k| k > 3);\n        assert_eq!(set.len(), 2);\n        let retained: Vec<i32> = set.iter().cloned().collect();\n        assert_eq!(retained, vec![4, 5]);\n    }\n}\n```", "set::HashSet::<T, S, A>::shrink_to": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_shrink_to() {\n        let mut set = HashSet::with_capacity(100);\n        set.insert(1);\n        set.insert(2);\n        assert!(set.capacity() >= 100);\n        \n        set.shrink_to(10);\n        assert!(set.capacity() >= 10);\n        \n        set.shrink_to(0);\n        assert!(set.capacity() >= 2);\n        \n        set.shrink_to(10);\n        assert!(set.capacity() >= 2);\n        \n        let mut empty_set: HashSet<i32> = HashSet::new();\n        assert!(empty_set.capacity() == 0);\n        empty_set.shrink_to(5); // should not panic, and capacity remains 0\n        assert!(empty_set.capacity() == 0);\n    }\n\n    #[test]\n    #[should_panic(expected = \"minimum capacity exceeded\")]\n    fn test_shrink_to_panics() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.shrink_to(3); // should panic since current capacity is 2\n    }\n}\n```", "set::HashSet::<T, S, A>::shrink_to_fit": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut set = HashSet::with_capacity(100);\n        set.insert(1);\n        set.insert(2);\n        assert!(set.capacity() >= 100);\n        set.shrink_to_fit();\n        assert!(set.capacity() >= 2);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.shrink_to_fit();\n        assert!(set.capacity() == 0);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_with_multiple_elements() {\n        let mut set = HashSet::with_capacity(50);\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.insert(4);\n        assert!(set.capacity() >= 50);\n        set.shrink_to_fit();\n        assert!(set.capacity() >= 4);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_after_removal() {\n        let mut set = HashSet::with_capacity(50);\n        set.insert(1);\n        set.insert(2);\n        set.remove(&1);\n        set.shrink_to_fit();\n        assert!(set.capacity() >= 1);\n    }\n}\n```", "set::HashSet::<T, S, A>::symmetric_difference": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_symmetric_difference() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n        \n        let diff: HashSet<_> = a.symmetric_difference(&b).collect();\n        assert_eq!(diff, [1, 4].iter().collect::<HashSet<_>>());\n        \n        let diff2: HashSet<_> = b.symmetric_difference(&a).collect();\n        assert_eq!(diff2, diff);\n        assert_eq!(diff2, [4, 1].iter().collect::<HashSet<_>>());\n        \n        let c: HashSet<_> = [].into_iter().collect();\n        let diff_empty: HashSet<_> = a.symmetric_difference(&c).collect();\n        assert_eq!(diff_empty, a);\n        \n        let diff_empty2: HashSet<_> = c.symmetric_difference(&a).collect();\n        assert_eq!(diff_empty2, a);\n    }\n}\n```", "set::HashSet::<T, S, A>::take": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Use the parent module where `HashSet` is defined\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_take_existing_value() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        assert_eq!(set.take(&2), Some(2));\n        assert_eq!(set.contains(&2), false); // Ensure the value is removed\n    }\n\n    #[test]\n    fn test_take_non_existing_value() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        assert_eq!(set.take(&3), None); // Trying to take a value not present\n        assert_eq!(set.len(), 2); // Set length should not change\n    }\n\n    #[test]\n    fn test_take_borrowed_value() {\n        let mut set: HashSet<String> = HashSet::new();\n        set.insert(\"hello\".to_string());\n        set.insert(\"world\".to_string());\n\n        let borrowed_key = \"hello\";\n        assert_eq!(set.take(&borrowed_key), Some(\"hello\".to_string()));\n        assert_eq!(set.contains(&borrowed_key), false); // Ensure the borrowed value is removed\n    }\n\n    #[test]\n    fn test_take_from_empty_set() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.take(&1), None); // Taking from an empty set should return None\n    }\n}\n```", "set::HashSet::<T, S, A>::try_reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_try_reserve() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.try_reserve(10).is_ok(), true);\n        assert!(set.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_try_reserve_overflow() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.try_reserve(usize::MAX).unwrap_err();\n    }\n\n    #[test]\n    fn test_try_reserve_zero() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.try_reserve(0).is_ok(), true);\n        assert!(set.capacity() >= 0); // Capacity should not change\n    }\n}\n```", "set::HashSet::<T, S, A>::union": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_union_with_no_common_elements() {\n        let a: HashSet<_> = [1, 2, 3].iter().copied().collect();\n        let b: HashSet<_> = [4, 5, 6].iter().copied().collect();\n        let union: HashSet<_> = a.union(&b).collect();\n        assert_eq!(union, [1, 2, 3, 4, 5, 6].iter().copied().collect::<HashSet<_>>());\n    }\n    \n    #[test]\n    fn test_union_with_some_common_elements() {\n        let a: HashSet<_> = [1, 2, 3].iter().copied().collect();\n        let b: HashSet<_> = [3, 4, 5].iter().copied().collect();\n        let union: HashSet<_> = a.union(&b).collect();\n        assert_eq!(union, [1, 2, 3, 4, 5].iter().copied().collect::<HashSet<_>>());\n    }\n\n    #[test]\n    fn test_union_with_identical_sets() {\n        let a: HashSet<_> = [1, 2, 3].iter().copied().collect();\n        let b: HashSet<_> = [1, 2, 3].iter().copied().collect();\n        let union: HashSet<_> = a.union(&b).collect();\n        assert_eq!(union, [1, 2, 3].iter().copied().collect::<HashSet<_>>());\n    }\n\n    #[test]\n    fn test_union_with_empty_set() {\n        let a: HashSet<_> = [1, 2, 3].iter().copied().collect();\n        let b: HashSet<_> = HashSet::new();\n        let union: HashSet<_> = a.union(&b).collect();\n        assert_eq!(union, [1, 2, 3].iter().copied().collect::<HashSet<_>>());\n    }\n\n    #[test]\n    fn test_union_with_two_empty_sets() {\n        let a: HashSet<_> = HashSet::new();\n        let b: HashSet<_> = HashSet::new();\n        let union: HashSet<_> = a.union(&b).collect();\n        assert_eq!(union, HashSet::new());\n    }\n\n    #[test]\n    fn test_union_with_large_sets() {\n        let a: HashSet<_> = (1..=1000).collect();\n        let b: HashSet<_> = (500..=1500).collect();\n        let union: HashSet<_> = a.union(&b).collect();\n        let expected: HashSet<_> = (1..=1500).collect();\n        assert_eq!(union, expected);\n    }\n}\n```", "set::HashSet::<T, S, A>::with_capacity_and_hasher_in": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::DefaultHashBuilder;\n\n    #[test]\n    fn test_with_capacity_and_hasher_in() {\n        let capacity = 10;\n        let hasher = DefaultHashBuilder::default();\n        let allocator = bumpalo::Bump::new();\n\n        let set: HashSet<i32, DefaultHashBuilder, bumpalo::Bump> = HashSet::with_capacity_and_hasher_in(capacity, hasher, allocator);\n\n        assert!(set.is_empty());\n        assert!(set.capacity() >= capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_in_non_zero_capacity() {\n        let capacity = 5;\n        let hasher = DefaultHashBuilder::default();\n        let allocator = bumpalo::Bump::new();\n\n        let mut set: HashSet<i32, DefaultHashBuilder, bumpalo::Bump> = HashSet::with_capacity_and_hasher_in(capacity, hasher, allocator);\n        set.insert(1);\n        set.insert(2);\n\n        assert_eq!(set.len(), 2);\n        assert!(set.capacity() >= capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_in_zero_capacity() {\n        let capacity = 0;\n        let hasher = DefaultHashBuilder::default();\n        let allocator = bumpalo::Bump::new();\n\n        let set: HashSet<i32, DefaultHashBuilder, bumpalo::Bump> = HashSet::with_capacity_and_hasher_in(capacity, hasher, allocator);\n\n        assert!(set.is_empty());\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_in_different_allocators() {\n        let capacity = 10;\n        let hasher = DefaultHashBuilder::default();\n        let allocator = bumpalo::Bump::new();\n\n        let set: HashSet<i32, DefaultHashBuilder, bumpalo::Bump> = HashSet::with_capacity_and_hasher_in(capacity, hasher, allocator);\n        set.insert(1);\n        set.insert(2);\n\n        assert!(set.len() > 0);\n    }\n}\n```", "set::HashSet::<T, S, A>::with_hasher_in": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use hashbrown::DefaultHashBuilder;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_with_hasher_in_empty() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let set: HashSet<i32, DefaultHashBuilder, _> = HashSet::with_hasher_in(hasher, bump);\n\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_with_hasher_in_capacity() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let mut set: HashSet<i32, DefaultHashBuilder, _> = HashSet::with_hasher_in(hasher, bump);\n\n        set.insert(1);\n        set.insert(2);\n\n        assert_eq!(set.len(), 2);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n    }\n\n    #[test]\n    fn test_with_hasher_in_no_allocation() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let set: HashSet<i32, DefaultHashBuilder, _> = HashSet::with_hasher_in(hasher, bump);\n\n        assert_eq!(set.capacity(), 0);\n    }\n}\n```", "set::HashSet::<T, S>::with_capacity_and_hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use hashbrown::DefaultHashBuilder;\n\n    #[test]\n    fn test_with_capacity_and_hasher() {\n        let hasher = DefaultHashBuilder::default();\n        let mut set = HashSet::with_capacity_and_hasher(10, hasher);\n\n        // Check that the set is initially empty.\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n\n        // Insert an element and check the set's state.\n        set.insert(1);\n        assert!(!set.is_empty());\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n\n        // Check the capacity is at least 10\n        assert!(set.raw_capacity() >= 10);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_empty() {\n        let hasher = DefaultHashBuilder::default();\n        let set = HashSet::<i32, DefaultHashBuilder>::with_capacity_and_hasher(0, hasher);\n\n        // Check that the set is initially empty and does not allocate.\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n        assert_eq!(set.raw_capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_multiple_inserts() {\n        let hasher = DefaultHashBuilder::default();\n        let mut set = HashSet::with_capacity_and_hasher(5, hasher);\n\n        // Insert multiple elements\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_no_realloc() {\n        let hasher = DefaultHashBuilder::default();\n        let mut set = HashSet::with_capacity_and_hasher(1, hasher);\n        \n        // Insert an element\n        set.insert(1);\n        assert_eq!(set.len(), 1);\n\n        // Insert without needing to reallocate\n        set.insert(2);\n        assert_eq!(set.len(), 2);\n        assert!(set.contains(&2));\n    }\n}\n```", "set::HashSet::<T, S>::with_hasher": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashSet, DefaultHashBuilder};\n    \n    #[test]\n    fn test_with_hasher() {\n        let hasher = DefaultHashBuilder::default();\n        let set: HashSet<i32, DefaultHashBuilder> = HashSet::with_hasher(hasher);\n        \n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_with_hasher_inserts() {\n        let hasher = DefaultHashBuilder::default();\n        let mut set: HashSet<i32, DefaultHashBuilder> = HashSet::with_hasher(hasher);\n        \n        set.insert(1);\n        set.insert(2);\n        \n        assert_eq!(set.len(), 2);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n    }\n\n    #[test]\n    fn test_with_hasher_unique() {\n        let hasher = DefaultHashBuilder::default();\n        let mut set: HashSet<i32, DefaultHashBuilder> = HashSet::with_hasher(hasher);\n        \n        set.insert(1);\n        set.insert(1); // Inserting duplicate\n        \n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n    }\n\n    #[test]\n    fn test_with_hasher_capacity() {\n        let hasher = DefaultHashBuilder::default();\n        let set: HashSet<i32, DefaultHashBuilder> = HashSet::with_hasher(hasher);\n        \n        // Should have a capacity of 0 at initialization\n        assert_eq!(set.len(), 0);\n        // Inserting elements should change capacity\n        let mut set_with_inserts = set;\n        set_with_inserts.insert(3);\n        assert!(set_with_inserts.len() > 0);\n    }\n}\n```", "set::HashSet::<T, foldhash::fast::RandomState, A>::new_in": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_hashset_new_in_empty() {\n        let bump = Bump::new();\n        let set: HashSet<i32> = HashSet::new_in(&bump);\n        assert_eq!(set.len(), 0);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_hashset_new_in_capacity() {\n        let bump = Bump::new();\n        let set: HashSet<i32> = HashSet::new_in(&bump);\n        assert_eq!(set.len(), 0);\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_hashset_new_in_insert() {\n        let bump = Bump::new();\n        let mut set: HashSet<i32> = HashSet::new_in(&bump);\n        set.insert(1);\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n    }\n\n    #[test]\n    fn test_hashset_new_in_multiple_inserts() {\n        let bump = Bump::new();\n        let mut set: HashSet<i32> = HashSet::new_in(&bump);\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n    }\n}\n```", "set::HashSet::<T, foldhash::fast::RandomState, A>::with_capacity_in": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_with_capacity_in_zero_capacity() {\n        let bump = Bump::new();\n        let set: HashSet<i32> = HashSet::with_capacity_in(0, &bump);\n        assert!(set.is_empty());\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_in_non_zero_capacity() {\n        let bump = Bump::new();\n        let capacity = 10;\n        let set: HashSet<i32> = HashSet::with_capacity_in(capacity, &bump);\n        assert!(set.capacity() >= capacity);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_in_insert_elements() {\n        let bump = Bump::new();\n        let capacity = 5;\n        let mut set: HashSet<i32> = HashSet::with_capacity_in(capacity, &bump);\n        \n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.insert(4);\n        set.insert(5);\n\n        assert_eq!(set.len(), 5);\n        assert!(set.capacity() >= capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_in_preserve_capacity() {\n        let bump = Bump::new();\n        let capacity = 5;\n        let mut set: HashSet<i32> = HashSet::with_capacity_in(capacity, &bump);\n        \n        let initial_capacity = set.capacity();\n        set.insert(1);\n\n        assert_eq!(set.len(), 1);\n        assert_eq!(set.capacity(), initial_capacity);\n    }\n}\n```", "set::HashSet::<T>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_hash_set_new() {\n        // Create a new empty HashSet\n        let set: HashSet<i32> = HashSet::new();\n\n        // Verify that the set is empty\n        assert!(set.is_empty());\n\n        // Verify the length of the set is zero\n        assert_eq!(set.len(), 0);\n\n        // Verify the capacity is zero\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_hash_set_with_capacity() {\n        let mut set: HashSet<i32> = HashSet::new();\n\n        // Insert elements into the set\n        set.insert(1);\n        set.insert(2);\n\n        // Verify that the set contains the elements\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(!set.contains(&3));\n\n        // Verify the length of the set\n        assert_eq!(set.len(), 2);\n    }\n}\n```", "set::HashSet::<T>::with_capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_with_capacity() {\n        let set: HashSet<i32> = HashSet::with_capacity(10);\n        assert!(set.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let set: HashSet<i32> = HashSet::with_capacity(0);\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_greater_than_zero() {\n        let set: HashSet<i32> = HashSet::with_capacity(5);\n        assert!(set.capacity() >= 5);\n    }\n\n    #[test]\n    fn test_with_capacity_non_empty_set() {\n        let mut set: HashSet<i32> = HashSet::with_capacity(10);\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.len(), 3);\n        assert!(set.capacity() >= 10);\n    }\n}\n```", "set::OccupiedEntry::<'_, T, S, A>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_set::{Entry, HashSet};\n\n    #[test]\n    fn test_get_occupied_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.entry(\"poneyland\").or_insert();\n        \n        match set.entry(\"poneyland\") {\n            Entry::Vacant(_) => panic!(),\n            Entry::Occupied(entry) => {\n                assert_eq!(entry.get(), &\"poneyland\");\n            },\n        }\n    }\n\n    #[test]\n    fn test_get_non_existent_entry() {\n        let set: HashSet<&str> = HashSet::new();\n        let entry = set.entry(\"nonexistent\");\n        match entry {\n            Entry::Vacant(_) => assert!(true),\n            Entry::Occupied(_) => panic!(),\n        }\n    }\n}\n```", "set::OccupiedEntry::<'_, T, S, A>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n    use hashbrown::hash_set::Entry;\n\n    #[test]\n    fn test_remove() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.entry(\"poneyland\").or_insert();\n        let capacity_before_remove = set.capacity();\n\n        if let Entry::Occupied(o) = set.entry(\"poneyland\") {\n            assert_eq!(o.remove(), \"poneyland\");\n        }\n\n        assert_eq!(set.contains(\"poneyland\"), false);\n        assert!(set.len() == 0 && set.capacity() == capacity_before_remove);\n    }\n}\n```", "set::VacantEntry::<'a, T, S, A>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_vacant_entry_get() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry(\"poneyland\");\n        assert_eq!(entry.get(), &\"poneyland\");\n    }\n\n    #[test]\n    fn test_vacant_entry_get_empty() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry(\"new_entry\");\n        assert_eq!(entry.get(), &\"new_entry\");\n    }\n\n    #[test]\n    fn test_vacant_entry_get_after_insert() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry(\"test_entry\");\n        let _ = entry.insert();\n        assert_eq!(entry.get(), &\"test_entry\");\n    }\n\n    #[test]\n    fn test_vacant_entry_get_multiple_entries() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry1 = set.entry(\"first_entry\");\n        let entry2 = set.entry(\"second_entry\");\n        assert_eq!(entry1.get(), &\"first_entry\");\n        assert_eq!(entry2.get(), &\"second_entry\");\n    }\n}\n```", "set::VacantEntry::<'a, T, S, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n    use hashbrown::hash_set::Entry;\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        \n        // Check initial state\n        assert!(set.is_empty());\n\n        // Insert a value using VacantEntry\n        if let Entry::Vacant(o) = set.entry(\"poneyland\") {\n            o.insert();\n        }\n\n        // Check if the value was inserted\n        assert!(set.contains(\"poneyland\"));\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_insert_existing_value() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.insert(\"poneyland\");\n\n        // Attempt to insert an existing value\n        if let Entry::Vacant(o) = set.entry(\"poneyland\") {\n            o.insert();\n        }\n\n        // Check the set remains unchanged\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(\"poneyland\"));\n    }\n\n    #[test]\n    fn test_insert_multiple_values() {\n        let mut set: HashSet<&str> = HashSet::new();\n        \n        // Insert multiple values\n        if let Entry::Vacant(o) = set.entry(\"poneyland\") {\n            o.insert();\n        }\n        if let Entry::Vacant(o) = set.entry(\"horse land\") {\n            o.insert();\n        }\n\n        // Check if all values were inserted\n        assert!(set.contains(\"poneyland\"));\n        assert!(set.contains(\"horse land\"));\n        assert_eq!(set.len(), 2);\n    }\n}\n```", "set::VacantEntry::<'a, T, S, A>::into_value": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_set::{Entry, HashSet};\n\n    #[test]\n    fn test_into_value_vacant() {\n        let mut set: HashSet<&str> = HashSet::new();\n        match set.entry(\"poneyland\") {\n            Entry::Occupied(_) => panic!(),\n            Entry::Vacant(v) => {\n                let result = v.into_value();\n                assert_eq!(result, \"poneyland\");\n            }\n        }\n    }\n    \n    #[test]\n    fn test_into_value_multiple_entries() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry1 = set.entry(\"poneyland\");\n        assert!(matches!(entry1, Entry::Vacant(_)));\n\n        let entry2 = set.entry(\"poneyland\");\n        match entry2 {\n            Entry::Occupied(_) => panic!(),\n            Entry::Vacant(v) => {\n                let result = v.into_value();\n                assert_eq!(result, \"poneyland\");\n            }\n        }\n    }\n}\n```", "set::assert_covariance": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use hashbrown::set::{Iter, IntoIter, Difference, SymmetricDifference, Intersection, Union, Drain};\n    use std::alloc::Allocator;\n    use std::collections::hash_map::DefaultHashBuilder;\n\n    #[test]\n    fn test_assert_covariance() {\n        let static_set: HashSet<&'static str> = HashSet::new();\n        let static_iter: Iter<&'static str> = static_set.iter();\n        let static_into_iter: IntoIter<&'static str, DefaultHashBuilder> = static_set.clone().into_iter();\n        let static_difference: Difference<&'static str, DefaultHashBuilder, _> = static_set.difference(&static_set);\n        let static_symmetric_difference: SymmetricDifference<&'static str, DefaultHashBuilder, _> = static_set.symmetric_difference(&static_set);\n        let static_intersection: Intersection<&'static str, DefaultHashBuilder, _> = static_set.intersection(&static_set);\n        let static_union: Union<&'static str, DefaultHashBuilder, _> = static_set.union(&static_set);\n        let static_drain: Drain<'static, &'static str, DefaultHashBuilder> = static_set.drain();\n\n        let _new_set: HashSet<&'new str> = set(static_set);\n        let _new_iter: Iter<'static, &'new str> = iter(static_iter);\n        let _new_into_iter: IntoIter<&'new str, DefaultHashBuilder> = into_iter(static_into_iter);\n        let _new_difference: Difference<'static, &'new str, DefaultHashBuilder, _> = difference(static_difference);\n        let _new_symmetric_difference: SymmetricDifference<'static, &'new str, DefaultHashBuilder, _> = symmetric_difference(static_symmetric_difference);\n        let _new_intersection: Intersection<'static, &'new str, DefaultHashBuilder, _> = intersection(static_intersection);\n        let _new_union: Union<'static, &'new str, DefaultHashBuilder, _> = union(static_union);\n        let _new_drain: Drain<'new, &'new str, DefaultHashBuilder> = drain(static_drain);\n    }\n}\n```", "set::assert_covariance::difference": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_difference() {\n        let bitmask = control::bitmask::BitMask(0b1100); // Example bitmask\n        let difference_result = set::assert_covariance::difference(bitmask.clone());\n\n        // Ensure the output is the same as the input type\n        assert_eq!(difference_result.0, bitmask.0);\n    }\n}\n```", "set::assert_covariance::drain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::Global;\n\n    #[test]\n    fn test_drain_covariance() {\n        let allocator = Global;\n\n        // Create a Drain with static lifetimes\n        let static_key: &'static str = \"static_key\";\n        let static_value: &'static str = \"static_value\";\n        let drain: Drain<'static, &'static str, &'static str, Global> = Drain {\n            inner: RawDrain {\n                // Mock RawDrain initialization as per your use case\n                iter: RawIter::default(),\n                table: RawTableInner::new_uninitialized(&allocator, TableLayout::default(), 1, Fallibility::Infallible).unwrap(),\n                orig_table: NonNull::new_unchecked(ptr::null_mut()),\n                marker: PhantomData,\n            },\n        };\n\n        // Call the drain function\n        let result = drain::drain(drain);\n\n        // Verify the result is a Drain with new lifetimes\n        assert!(result.inner.items == drain.inner.items);\n    }\n}\n```", "set::assert_covariance::intersection": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_intersection() {\n        let first_set: HashMap<&str, &str> = HashMap::from([(\"a\", \"1\"), (\"b\", \"2\"), (\"c\", \"3\")]);\n        let second_set: HashMap<&str, &str> = HashMap::from([(\"b\", \"2\"), (\"c\", \"3\"), (\"d\", \"4\")]);\n        \n        let first_keys: Vec<&str> = first_set.keys().cloned().collect();\n        let second_keys: Vec<&str> = second_set.keys().cloned().collect();\n\n        let intersection_result = intersection(Intersection::new(first_keys, second_keys));\n        \n        let expected_keys: Vec<&str> = vec![\"b\", \"c\"];\n        assert_eq!(intersection_result.collect::<Vec<&str>>(), expected_keys);\n    }\n}\n```", "set::assert_covariance::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::set::IntoIter;\n    use hashbrown::map::IntoIter as MapIntoIter;\n    use hashbrown::Alloc;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_into_iter() {\n        let input = MapIntoIter::default();\n        let result: IntoIter<&str, Global> = super::set::assert_covariance::into_iter(input);\n        \n        assert_eq!(result.len(), input.len());\n    }\n}\n```", "set::assert_covariance::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_iter() {\n        let set: HashSet<&'static str> = HashSet::from_iter(vec![\"a\", \"b\", \"c\"]);\n        let iter = set.iter();\n\n        let collected: Vec<_> = iter.collect();\n\n        assert_eq!(collected.len(), 3);\n        assert!(collected.contains(&&\"a\"));\n        assert!(collected.contains(&&\"b\"));\n        assert!(collected.contains(&&\"c\"));\n    }\n\n    #[test]\n    fn test_iter_empty() {\n        let set: HashSet<&'static str> = HashSet::new();\n        let iter = set.iter();\n\n        let collected: Vec<_> = iter.collect();\n\n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_iter_covariance() {\n        let set: HashSet<&'static str> = HashSet::from_iter(vec![\"x\", \"y\"]);\n        let iter = set.iter();\n\n        let mut new_iter = iter.map(|&s| s.to_string());\n        let collected: Vec<_> = new_iter.collect();\n\n        assert_eq!(collected.len(), 2);\n        assert_eq!(&collected[0], \"x\");\n        assert_eq!(&collected[1], \"y\");\n    }\n}\n```", "set::assert_covariance::set": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_set_with_static_strs() {\n        let mut input_set: HashSet<&'static str> = HashSet::new();\n        input_set.insert(\"Hello\");\n        input_set.insert(\"World\");\n\n        let result: HashSet<&'static str> = set(input_set);\n        let expected: HashSet<&'static str> = [\"Hello\", \"World\"].iter().cloned().collect();\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_set_with_empty_set() {\n        let input_set: HashSet<&'static str> = HashSet::new();\n        let result: HashSet<&'static str> = set(input_set);\n        \n        let expected: HashSet<&'static str> = HashSet::new();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_set_with_repeated_elements() {\n        let mut input_set: HashSet<&'static str> = HashSet::new();\n        input_set.insert(\"Hello\");\n        input_set.insert(\"Hello\"); // Repeated entry\n\n        let result: HashSet<&'static str> = set(input_set);\n        let expected: HashSet<&'static str> = [\"Hello\"].iter().cloned().collect();\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_set_with_different_elements() {\n        let mut input_set: HashSet<&'static str> = HashSet::new();\n        input_set.insert(\"Rust\");\n        input_set.insert(\"is\");\n        input_set.insert(\"awesome\");\n\n        let result: HashSet<&'static str> = set(input_set);\n        let expected: HashSet<&'static str> = [\"Rust\", \"is\", \"awesome\"].iter().cloned().collect();\n\n        assert_eq!(result, expected);\n    }\n}\n```", "set::assert_covariance::symmetric_difference": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use std::alloc::Global;\n    use std::hash::BuildHasherDefault;\n\n    #[test]\n    fn test_symmetric_difference() {\n        let set_a: HashSet<&'static str, BuildHasherDefault<DefaultHasher>> = \n            [('a', ()), ('b', ())].iter().cloned().collect();\n        let set_b: HashSet<&'static str, BuildHasherDefault<DefaultHasher>> = \n            [('b', ()), ('c', ())].iter().cloned().collect();\n\n        let sym_diff: SymmetricDifference<_, _, Global> = set_a.symmetric_difference(&set_b);\n\n        let result: Vec<&str> = sym_diff.collect();\n        let expected: Vec<&str> = vec![\"a\", \"c\"];\n        \n        assert_eq!(result, expected);\n    }\n}\n```", "set::assert_covariance::union": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use std::alloc::Global;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_union() {\n        let set_a: HashSet<&'static str, RandomState> = HashSet::from_iter(vec![\"a\", \"b\", \"c\"]);\n        let set_b: HashSet<&'static str, RandomState> = HashSet::from_iter(vec![\"b\", \"c\", \"d\"]);\n\n        let union_iter = union(Union::new(set_a.iter(), set_b.difference(set_a.iter())));\n        let union_elements: Vec<&'static str> = union_iter.collect();\n\n        assert_eq!(union_elements, vec![\"a\", \"b\", \"c\", \"d\"]);\n    }\n}\n```", "table::AbsentEntry::<'a, T, A>::into_table": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::raw::{RawTable, RawTableInner, Global};\n    use std::alloc::Allocator;\n    use std::mem;\n\n    #[test]\n    fn test_into_table() {\n        // Create a new RawTable\n        let mut raw_table: RawTable<i32, Global> = RawTable::new();\n        let raw_table_inner = raw_table.table;\n\n        // Create an AbsentEntry\n        let absent_entry = AbsentEntry {\n            table: &mut raw_table_inner,\n            // Assuming that appropriate fields for AbsentEntry are set\n        };\n\n        // Convert AbsentEntry into table\n        let table_ref = absent_entry.into_table();\n\n        // Validate that the reference points to the correct table\n        assert_eq!(table_ref, &mut raw_table_inner);\n    }\n}\n```", "table::Entry::<'a, T, A>::and_modify": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_and_modify_existing_entry() {\n        let mut table: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table\n            .entry(\n                hasher(&\"poneyland\"),\n                |&(x, _)| x == \"poneyland\",\n                |(k, _)| hasher(&k),\n            )\n            .or_insert((\"poneyland\", 42));\n\n        table\n            .entry(\n                hasher(&\"poneyland\"),\n                |&(x, _)| x == \"poneyland\",\n                |(k, _)| hasher(&k),\n            )\n            .and_modify(|(_, v)| *v += 1);\n\n        assert_eq!(\n            table.find(hasher(&\"poneyland\"), |&(k, _)| k == \"poneyland\"),\n            Some(&(\"poneyland\", 43))\n        );\n    }\n\n    #[test]\n    fn test_and_modify_new_entry() {\n        let mut table: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        let result = table\n            .entry(\n                hasher(&\"poneyland\"),\n                |&(x, _)| x == \"poneyland\",\n                |(k, _)| hasher(&k),\n            )\n            .and_modify(|(_, v)| *v += 1)\n            .or_insert((\"poneyland\", 42));\n\n        assert_eq!(result, &(\"poneyland\", 42));\n        assert_eq!(\n            table.find(hasher(&\"poneyland\"), |&(k, _)| k == \"poneyland\"),\n            Some(&(\"poneyland\", 42))\n        );\n    }\n}\n```", "table::Entry::<'a, T, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_insert_occupied_entry() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&\"test_key\");\n\n        let _entry = table\n            .entry(hash, |&x| x == \"test_key\", hasher)\n            .insert(\"initial_value\");\n\n        let occupied_entry = table\n            .entry(hash, |&x| x == \"test_key\", hasher)\n            .insert(\"updated_value\");\n\n        assert_eq!(occupied_entry.get(), &\"updated_value\");\n    }\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&\"new_key\");\n\n        let occupied_entry = table\n            .entry(hash, |&x| x == \"new_key\", hasher)\n            .insert(\"new_value\");\n\n        assert_eq!(occupied_entry.get(), &\"new_value\");\n    }\n\n    #[test]\n    fn test_insert_replace_existing_value() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&\"replace_key\");\n\n        table\n            .entry(hash, |&x| x == \"replace_key\", hasher)\n            .insert(\"old_value\");\n\n        let occupied_entry = table\n            .entry(hash, |&x| x == \"replace_key\", hasher)\n            .insert(\"new_value\");\n\n        assert_eq!(occupied_entry.get(), &\"new_value\");\n    }\n}\n```", "table::Entry::<'a, T, A>::or_insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    \n    #[test]\n    fn test_or_insert() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        // Test insertion when key is not present\n        let entry1 = table.entry(hasher(&\"test_key\"), |&x| x == \"test_key\", hasher);\n        let occupied1 = entry1.or_insert(\"default_value\");\n        assert_eq!(unsafe { occupied1.as_ref() }, &\"default_value\");\n        assert!(table.find(hasher(&\"test_key\"), |&x| x == \"test_key\").is_some());\n\n        // Test insertion when the key is already present\n        let entry2 = table.entry(hasher(&\"test_key\"), |&x| x == \"test_key\", hasher);\n        let occupied2 = entry2.or_insert(\"new_value\");\n        assert_eq!(unsafe { occupied2.as_ref() }, &\"default_value\");\n        assert_eq!(table.len(), 1);\n    }\n}\n```", "table::Entry::<'a, T, A>::or_insert_with": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_or_insert_with() {\n        let mut table: HashTable<String> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &_| hasher.hash_one(val);\n\n        let entry = table.entry(hasher_fn(\"test_key\"), |x| x == \"test_key\", |val| hasher_fn(val));\n        let occupied_entry = entry.or_insert_with(|| \"default_value\".to_string());\n\n        assert_eq!(occupied_entry.as_ref(), &\"default_value\".to_string());\n        \n        // Test inserting again to ensure it does not overwrite\n        let entry2 = table.entry(hasher_fn(\"test_key\"), |x| x == \"test_key\", |val| hasher_fn(val));\n        let occupied_entry2 = entry2.or_insert_with(|| \"another_value\".to_string());\n\n        assert_eq!(occupied_entry2.as_ref(), &\"default_value\".to_string());\n    }\n}\n```", "table::HashTable::<T, A>::allocation_size": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_allocation_size() {\n        let table: HashTable<i32, Global> = HashTable::new();\n        assert_eq!(table.allocation_size(), 0); // No memory should be allocated for an empty table.\n\n        let mut table_with_capacity = HashTable::with_capacity_in(1024, Global);\n        assert!(table_with_capacity.allocation_size() > 0); // Should return a non-zero allocation size for a table with capacity.\n\n        // Insert an element and check the allocation size again\n        unsafe {\n            table_with_capacity.insert(0, 42, |_x| 0);\n        }\n        assert!(table_with_capacity.allocation_size() > 0); // Memory should be allocated after inserting an element.\n\n        // Clear the table and check the allocation size\n        table_with_capacity.clear();\n        assert!(table_with_capacity.allocation_size() > 0); // Memory should remain allocated after clearing.\n    }\n}\n```", "table::HashTable::<T, A>::allocator": "```rust\n#[cfg(test)]\nmod tests {\n    use crate::table::HashTable;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_allocator() {\n        // Create an empty HashTable with the global allocator\n        let table: HashTable<i32, Global> = HashTable::new();\n\n        // Retrieve the allocator\n        let allocator = table.allocator();\n\n        // Verify that the allocator is the global allocator\n        assert_eq!(allocator.name(), Global.name());\n    }\n}\n```", "table::HashTable::<T, A>::capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_capacity_with_initial_capacity() {\n        let table: HashTable<i32> = HashTable::with_capacity(100);\n        assert_eq!(table.capacity(), 100);\n    }\n\n    #[test]\n    fn test_capacity_with_increased_capacity() {\n        let mut table: HashTable<i32> = HashTable::with_capacity(100);\n        table.insert(1, 10, |&v| v);\n        table.insert(2, 20, |&v| v);\n        assert!(table.capacity() >= 100);\n    }\n\n    #[test]\n    fn test_capacity_with_default_capacity() {\n        let table: HashTable<i32> = HashTable::default();\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_after_insertion() {\n        let mut table: HashTable<i32> = HashTable::with_capacity(10);\n        for i in 0..10 {\n            table.insert(i, i * 10, |&v| v);\n        }\n        assert!(table.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_capacity_after_growing() {\n        let mut table: HashTable<i32> = HashTable::with_capacity(1);\n        for i in 0..100 {\n            table.insert(i, i, |&v| v);\n            assert!(table.capacity() >= 100);\n        }\n    }\n}\n```", "table::HashTable::<T, A>::clear": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import the HashTable\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_hash_table_clear() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_func = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher_func(&1), 1, hasher_func);\n        table.insert_unique(hasher_func(&2), 2, hasher_func);\n        table.insert_unique(hasher_func(&3), 3, hasher_func);\n        \n        assert!(!table.is_empty());\n        assert_eq!(table.len(), 3);\n\n        table.clear();\n        \n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n    }\n\n    #[test]\n    fn test_clear_on_empty_table() {\n        let mut table = HashTable::new();\n        \n        assert!(table.is_empty());\n        \n        table.clear();\n        \n        assert!(table.is_empty());\n    }\n}\n```", "table::HashTable::<T, A>::drain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n    use std::hash::BuildHasherDefault;\n    use std::hash::Hasher;\n\n    #[test]\n    fn test_drain() {\n        let mut table = HashTable::new();\n        let hasher = BuildHasherDefault::<std::collections::hash_map::RandomState>::default();\n        let hasher_fn = |val: &| hasher.hash_one(val);\n\n        for x in 1..=3 {\n            table.insert_unique(hasher_fn(&x), x, hasher_fn);\n        }\n\n        assert!(!table.is_empty());\n\n        let drained: Vec<_> = table.drain().collect();\n        assert_eq!(drained.len(), 3);\n        assert!(table.is_empty());\n    }\n\n    #[test]\n    fn test_drain_empty_table() {\n        let mut table: HashTable<u32, BuildHasherDefault<std::collections::hash_map::RandomState>> = HashTable::new();\n        let drained: Vec<_> = table.drain().collect();\n        assert!(drained.is_empty());\n    }\n}\n```", "table::HashTable::<T, A>::entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use hashbrown::hash_table::Entry;\n    \n    #[test]\n    fn test_entry_insert() {\n        let mut table: HashTable<u64, _> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &u64| hasher.hash_one(val);\n\n        // Test inserting a new entry\n        let entry_result = table.entry(hasher_fn(&1), |val| *val == 1, |val| hasher_fn(val));\n        assert!(matches!(entry_result, Entry::Vacant(_)));\n        \n        // Now insert the entry\n        if let Entry::Vacant(entry) = entry_result {\n            entry.insert(1);\n        }\n\n        // Verify the entry has been inserted\n        assert_eq!(table.find(hasher_fn(&1), |val| *val == 1), Some(&1));\n    }\n\n    #[test]\n    fn test_entry_remove() {\n        let mut table: HashTable<u64, _> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &u64| hasher.hash_one(val);\n        \n        // Insert an entry\n        table.insert_unique(hasher_fn(&1), 1, |val| hasher.hash_one(val));\n        \n        // Now test the entry remove\n        let entry_result = table.entry(hasher_fn(&1), |val| *val == 1, |val| hasher_fn(val));\n        if let Entry::Occupied(entry) = entry_result {\n            entry.remove();\n        }\n\n        // Verify the entry has been removed\n        assert_eq!(table.find(hasher_fn(&1), |val| *val == 1), None);\n    }\n\n    #[test]\n    fn test_entry_vacant() {\n        let mut table: HashTable<u64, _> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &u64| hasher.hash_one(val);\n        \n        // Attempt to get a vacant entry\n        let entry_result = table.entry(hasher_fn(&2), |val| *val == 2, |val| hasher_fn(val));\n        assert!(matches!(entry_result, Entry::Vacant(_)));\n\n        // Now insert the entry\n        if let Entry::Vacant(entry) = entry_result {\n            entry.insert(2);\n        }\n\n        // Verify the entry has been inserted\n        assert_eq!(table.find(hasher_fn(&2), |val| *val == 2), Some(&2));\n    }\n\n    #[test]\n    fn test_entry_occupied() {\n        let mut table: HashTable<u64, _> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &u64| hasher.hash_one(val);\n        \n        // Insert an entry\n        table.insert_unique(hasher_fn(&3), 3, |val| hasher.hash_one(val));\n        \n        // Now test the entry\n        let entry_result = table.entry(hasher_fn(&3), |val| *val == 3, |val| hasher_fn(val));\n        assert!(matches!(entry_result, Entry::Occupied(_)));\n\n        // Verify the entry has been found\n        if let Entry::Occupied(entry) = entry_result {\n            assert_eq!(entry.get(), &3);\n        }\n    }\n}\n```", "table::HashTable::<T, A>::extract_if": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_extract_if() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        \n        for x in 0..10 {\n            table.insert_unique(hasher(&x), x, hasher);\n        }\n        \n        let drained: Vec<i32> = table.extract_if(|v| v % 2 == 0).collect();\n        \n        let evens: Vec<_> = drained.into_iter().collect();\n        let odds: Vec<_> = table.into_iter().collect();\n        \n        let expected_evens = vec![0, 2, 4, 6, 8];\n        let expected_odds = vec![1, 3, 5, 7, 9];\n        \n        assert_eq!(evens, expected_evens);\n        assert_eq!(odds, expected_odds);\n    }\n}\n```", "table::HashTable::<T, A>::find": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_find_existing_element() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher(&1), 1, hasher);\n        table.insert_unique(hasher(&2), 2, hasher);\n        table.insert_unique(hasher(&3), 3, hasher);\n\n        assert_eq!(table.find(hasher(&2), |&val| val == 2), Some(&2));\n    }\n\n    #[test]\n    fn test_find_non_existing_element() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher(&1), 1, hasher);\n        table.insert_unique(hasher(&2), 2, hasher);\n        table.insert_unique(hasher(&3), 3, hasher);\n\n        assert_eq!(table.find(hasher(&4), |&val| val == 4), None);\n    }\n\n    #[test]\n    fn test_find_with_different_hash() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher(&1), 1, hasher);\n        table.insert_unique(hasher(&2), 2, hasher);\n        table.insert_unique(hasher(&3), 3, hasher);\n\n        assert_eq!(table.find(hasher(&1), |&val| val == 1), Some(&1));\n        assert_eq!(table.find(hasher(&2), |&val| val == 2), Some(&2));\n        assert_eq!(table.find(hasher(&3), |&val| val == 3), Some(&3));\n    }\n}\n```", "table::HashTable::<T, A>::find_entry": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n    use std::hash::BuildHasherDefault;\n    use std::hash::Hasher;\n\n    #[test]\n    fn test_find_entry_existing() {\n        let mut table = HashTable::new();\n        let mut hasher = BuildHasherDefault::default();\n\n        table.insert_unique(hasher.hash_one(&1), (1, \"value1\"), |val| hasher.hash_one(&val.0));\n\n        let entry = table.find_entry(hasher.hash_one(&1), |val| val.0 == 1);\n        assert!(entry.is_ok(), \"Entry should exist\");\n        let occupied_entry = entry.unwrap();\n        assert_eq!(occupied_entry.bucket.as_ref(), &(1, \"value1\"));\n    }\n\n    #[test]\n    fn test_find_entry_non_existing() {\n        let mut table = HashTable::new();\n        let mut hasher = BuildHasherDefault::default();\n\n        let entry = table.find_entry(hasher.hash_one(&2), |val| val.0 == 2);\n        assert!(entry.is_err(), \"Entry should not exist\");\n    }\n\n    #[test]\n    fn test_find_entry_with_different_hash() {\n        let mut table = HashTable::new();\n        let mut hasher = BuildHasherDefault::default();\n\n        table.insert_unique(hasher.hash_one(&1), (1, \"value1\"), |val| hasher.hash_one(&val.0));\n\n        let entry = table.find_entry(hasher.hash_one(&2), |val| val.0 == 1);\n        assert!(entry.is_ok(), \"Entry should exist (hash collision)\");\n        let occupied_entry = entry.unwrap();\n        assert_eq!(occupied_entry.bucket.as_ref(), &(1, \"value1\"));\n    }\n}\n```", "table::HashTable::<T, A>::find_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_find_mut_existing_entry() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&1);\n        table.insert_unique(hash, (1, \"a\"), |val| hasher.hash_one(&val.0));\n        \n        if let Some(val) = table.find_mut(hash, |val| val.0 == 1) {\n            val.1 = \"b\";\n        }\n        \n        assert_eq!(table.find(hash, |val| val.0 == 1), Some(&(1, \"b\")));\n    }\n\n    #[test]\n    fn test_find_mut_non_existing_entry() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&2);\n        table.insert_unique(hasher.hash_one(&1), (1, \"a\"), |val| hasher.hash_one(&val.0));\n        \n        let result = table.find_mut(hash, |val| val.0 == 2);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_find_mut_multiple_entries() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash1 = hasher.hash_one(&1);\n        let hash2 = hasher.hash_one(&2);\n        table.insert_unique(hash1, (1, \"a\"), |val| hasher.hash_one(&val.0));\n        table.insert_unique(hash2, (2, \"b\"), |val| hasher.hash_one(&val.0));\n        \n        if let Some(val) = table.find_mut(hash1, |val| val.0 == 1) {\n            val.1 = \"changed\";\n        }\n        \n        assert_eq!(table.find(hash1, |val| val.0 == 1), Some(&(1, \"changed\")));\n        assert_eq!(table.find(hash2, |val| val.0 == 2), Some(&(2, \"b\")));\n    }\n\n    #[test]\n    fn test_find_mut_no_hash() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher.hash_one(&1), (1, \"a\"), |val| hasher.hash_one(&val.0));\n        \n        if let Some(val) = table.find_mut(hasher.hash_one(&1), |val| val.0 == 1) {\n            val.1 = \"b\";\n        }\n\n        assert_eq!(table.find(hasher.hash_one(&1), |val| val.0 == 1), Some(&(1, \"b\")));\n        assert_eq!(table.find(hasher.hash_one(&2), |val| val.0 == 2), None);\n    }\n}\n```", "table::HashTable::<T, A>::get_many_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_get_many_mut() {\n        let mut libraries: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        for (k, v) in [\n            (\"Bodleian Library\", 1602),\n            (\"Athen\u00e6um\", 1807),\n            (\"Herzogin-Anna-Amalia-Bibliothek\", 1691),\n            (\"Library of Congress\", 1800),\n        ] {\n            libraries.insert_unique(hasher(&k), (k, v), |(k, _)| hasher(&k));\n        }\n\n        let keys = [\"Athen\u00e6um\", \"Library of Congress\"];\n        let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n        assert_eq!(\n            got,\n            [\n                Some(&mut (\"Athen\u00e6um\", 1807)),\n                Some(&mut (\"Library of Congress\", 1800)),\n            ],\n        );\n\n        let keys = [\"Athen\u00e6um\", \"New York Public Library\"];\n        let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n        assert_eq!(got, [Some(&mut (\"Athen\u00e6um\", 1807)), None]);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_get_many_mut_panics_on_duplicate_keys() {\n        let mut libraries: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        for (k, v) in [\n            (\"Athen\u00e6um\", 1807),\n            (\"Library of Congress\", 1800),\n        ] {\n            libraries.insert_unique(hasher(&k), (k, v), |(k, _)| hasher(&k));\n        }\n\n        let keys = [\"Athen\u00e6um\", \"Athen\u00e6um\"];\n        let _got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n    }\n}\n```", "table::HashTable::<T, A>::get_many_unchecked_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_get_many_unchecked_mut() {\n        let mut table: HashTable<(&str, u32)> = HashTable::with_capacity(4);\n        \n        // Hash function simulation for this test\n        let hasher = |val: &str| {\n            let mut hash = 0;\n            for byte in val.as_bytes() {\n                hash = hash.wrapping_add(*byte as u64);\n            }\n            hash\n        };\n\n        // Insert items into the table\n        table.insert(hasher(\"A\"), (\"A\", 1), hasher);\n        table.insert(hasher(\"B\"), (\"B\", 2), hasher);\n        table.insert(hasher(\"C\"), (\"C\", 3), hasher);\n        \n        let hashes: [u64; 3] = [hasher(\"A\"), hasher(\"B\"), hasher(\"C\")];\n        \n        // Using a closure for the `eq` argument\n        let eq = |i: usize, val: &(&str, u32)| {\n            let keys = [\"A\", \"B\", \"C\"];\n            keys[i] == val.0\n        };\n\n        // Safe: Retrieve mutable references\n        let results: [Option<&mut (&str, u32)>; 3] = unsafe {\n            table.get_many_unchecked_mut(hashes, eq)\n        };\n\n        // Check the results\n        assert_eq!(results[0], Some(&mut (\"A\", 1)));\n        assert_eq!(results[1], Some(&mut (\"B\", 2)));\n        assert_eq!(results[2], Some(&mut (\"C\", 3)));\n\n        // Test overlapping keys: this should cause undefined behavior\n        let hashes_overlap: [u64; 2] = [hasher(\"A\"), hasher(\"A\")];\n        let results_overlap: [Option<&mut (&str, u32)>; 2] = unsafe {\n            table.get_many_unchecked_mut(hashes_overlap, eq)\n        };\n\n        assert_eq!(results_overlap[0], Some(&mut (\"A\", 1)));\n        assert_eq!(results_overlap[1], Some(&mut (\"A\", 1)));\n    }\n}\n```", "table::HashTable::<T, A>::insert_unique": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import the parent module\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_insert_unique() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&1);\n\n        // Insert an element\n        let entry = table.insert_unique(hash, 1, |x| hasher.hash_one(x));\n        assert_eq!(unsafe { *entry.as_ref() }, 1);\n\n        // Insert another element\n        let entry2 = table.insert_unique(hasher.hash_one(&2), 2, |x| hasher.hash_one(x));\n        assert_eq!(unsafe { *entry2.as_ref() }, 2);\n        \n        // Assert the hash table has two entries\n        assert_eq!(table.len(), 2);\n    }\n}\n```", "table::HashTable::<T, A>::is_empty": "```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_is_empty() {\n        let hasher = DefaultHashBuilder::default();\n        let mut table: HashTable<i32, DefaultHashBuilder> = HashTable::new();\n        \n        // Initially, the table should be empty\n        assert!(table.is_empty());\n\n        // Insert an element\n        let hash = hasher.hash_one(&1);\n        table.insert_unique(hash, 1, |val: &_| hasher.hash_one(val));\n\n        // Table should not be empty after insertion\n        assert!(!table.is_empty());\n\n        // Clear the table\n        table.clear();\n\n        // Table should be empty again\n        assert!(table.is_empty());\n    }\n}\n```", "table::HashTable::<T, A>::iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    \n    #[test]\n    fn test_iter_empty() {\n        let table: HashTable<i32, DefaultHashBuilder> = HashTable::new();\n        let mut iter = table.iter();\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_single_element() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher.hash_one(&1), 1, hasher);\n        \n        let mut iter = table.iter();\n        assert_eq!(iter.next(), Some(&1));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_multiple_elements() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher.hash_one(&1), 1, hasher);\n        table.insert_unique(hasher.hash_one(&2), 2, hasher);\n        table.insert_unique(hasher.hash_one(&3), 3, hasher);\n        \n        let mut iter = table.iter();\n        let mut elements: Vec<_> = iter.collect();\n        elements.sort(); // Sort elements to ensure order-independent test\n        assert_eq!(elements, vec![&1, &2, &3]);\n    }\n\n    #[test]\n    fn test_iter_after_insertion() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher.hash_one(&1), 1, hasher);\n        table.insert_unique(hasher.hash_one(&2), 2, hasher);\n        \n        let mut iter = table.iter();\n        assert_eq!(iter.next(), Some(&1));\n        table.insert_unique(hasher.hash_one(&3), 3, hasher);\n        assert_eq!(iter.next(), Some(&2));\n        assert_eq!(iter.next(), None);\n        \n        // Collecting after insertion\n        let mut extra_iter = table.iter();\n        assert_eq!(extra_iter.next(), Some(&3));\n    }\n\n    #[test]\n    fn test_iter_unknown_order() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher.hash_one(&1), 1, hasher);\n        table.insert_unique(hasher.hash_one(&3), 3, hasher);\n        table.insert_unique(hasher.hash_one(&2), 2, hasher);\n        \n        let mut iter = table.iter();\n        let mut elements: Vec<_> = iter.collect();\n        elements.sort(); // Sort to ensure order-independent test\n        assert_eq!(elements, vec![&1, &2, &3]);\n    }\n}\n```", "table::HashTable::<T, A>::iter_hash": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_iter_hash() {\n        let mut table = HashTable::new();\n        let hasher = |val: &_| val.hash();\n\n        table.insert_unique(hasher(&\"a\"), \"a\", hasher);\n        table.insert_unique(hasher(&\"a\"), \"b\", hasher);\n        table.insert_unique(hasher(&\"b\"), \"c\", hasher);\n\n        let hash = hasher(&\"a\");\n        let mut results = Vec::new();\n\n        // Collect elements yielded by iter_hash\n        for x in unsafe { table.iter_hash(hash) } {\n            results.push(x);\n        }\n\n        // Check that \"a\" and \"b\" are in the results (and that at least one of them is present)\n        assert!(results.contains(&\"a\"));\n        assert!(results.contains(&\"b\"));\n        assert!(results.len() <= 3); // Ensure we do not have more than possible elements\n    }\n}\n```", "table::HashTable::<T, A>::iter_hash_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_iter_hash_mut() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hash_fn(&1), 2, hash_fn);\n        table.insert_unique(hash_fn(&1), 3, hash_fn);\n        table.insert_unique(hash_fn(&2), 5, hash_fn);\n\n        // Update matching values using iter_hash_mut\n        for val in table.iter_hash_mut(hash_fn(&1)) {\n            *val *= 2;\n        }\n\n        assert_eq!(table.len(), 3);\n        let mut vec: Vec<i32> = Vec::new();\n\n        for val in &table {\n            vec.push(*val);\n        }\n\n        assert!(vec.contains(&4));\n        assert!(vec.contains(&6));\n    }\n\n    #[test]\n    fn test_iter_hash_mut_no_match() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hash_fn(&3), 4, hash_fn);\n        table.insert_unique(hash_fn(&5), 6, hash_fn);\n\n        // Update using a hash that has no matching entry\n        for val in table.iter_hash_mut(hash_fn(&1)) {\n            *val *= 2; // Should not alter anything\n        }\n\n        assert_eq!(table.len(), 2);\n        let mut vec: Vec<i32> = Vec::new();\n\n        for val in &table {\n            vec.push(*val);\n        }\n\n        assert!(vec.contains(&4));\n        assert!(vec.contains(&6));\n    }\n}\n```", "table::HashTable::<T, A>::iter_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_iter_mut() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        table.insert_unique(hasher(&1), 1, hasher);\n        table.insert_unique(hasher(&2), 2, hasher);\n        table.insert_unique(hasher(&3), 3, hasher);\n\n        for val in table.iter_mut() {\n            *val *= 2; // Modify values\n        }\n\n        assert_eq!(table.len(), 3);\n        let mut vec: Vec<i32> = Vec::new();\n\n        for val in &table {\n            vec.push(*val); // Collect values\n        }\n\n        vec.sort_unstable();\n        assert_eq!(vec, [2, 4, 6]);\n    }\n}\n```", "table::HashTable::<T, A>::len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_hash_table_len() {\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &_| hasher.hash_one(val);\n        \n        let mut table = HashTable::new();\n        \n        // Test initial length\n        assert_eq!(table.len(), 0);\n\n        // Insert an element\n        table.insert_unique(hasher_fn(&1), 1, hasher);\n        assert_eq!(table.len(), 1);\n\n        // Insert another element\n        table.insert_unique(hasher_fn(&2), 2, hasher);\n        assert_eq!(table.len(), 2);\n\n        // Remove an element\n        unsafe {\n            let bucket = table.find_or_find_insert_slot(hasher_fn(&1), |_| true, hasher).unwrap();\n            table.remove(bucket);\n        }\n        assert_eq!(table.len(), 1);\n        \n        // Clear the table\n        table.clear();\n        assert_eq!(table.len(), 0);\n    }\n}\n```", "table::HashTable::<T, A>::new_in": "```rust\n#[cfg(test)]\nmod tests {\n    use bumpalo::Bump;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_new_in() {\n        let bump = Bump::new();\n        let table: HashTable<_, _> = HashTable::new_in(&bump);\n\n        // The created HashTable holds no elements\n        assert_eq!(table.len(), 0);\n\n        // The created HashTable also doesn't allocate memory\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_insert_into_new_in() {\n        let bump = Bump::new();\n        let mut table: HashTable<_, _> = HashTable::new_in(&bump);\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        // Insert element into created HashTable\n        table.insert_unique(hasher(&\"One\"), \"One\", hasher);\n\n        // Check that the HashTable now holds 1 element\n        assert_eq!(table.len(), 1);\n        // Check that it has allocated some capacity\n        assert!(table.capacity() > 0);\n    }\n}\n```", "table::HashTable::<T, A>::reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    \n    #[test]\n    fn test_reserve() {\n        let mut table: HashTable<i32> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &i32| hasher.hash_one(val);\n        \n        // Initial capacity check\n        assert_eq!(table.capacity(), 0);\n        \n        // Reserve space for 10 elements\n        table.reserve(10, hash_fn);\n        assert!(table.capacity() >= 10);\n        \n        // Reserve space for more elements\n        table.reserve(20, hash_fn);\n        assert!(table.capacity() >= 30);\n        \n        // Reserve space for 0 elements (should not panic)\n        table.reserve(0, hash_fn);\n        assert!(table.capacity() >= 30);\n\n        // Check the length of the table\n        assert_eq!(table.len(), 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_reserve_panic_on_exceeding_max_capacity() {\n        let mut table: HashTable<i32> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &i32| hasher.hash_one(val);\n\n        // Reserve capacity that exceeds the maximum size\n        let _ = table.reserve(usize::MAX, hash_fn);\n    }\n}\n```", "table::HashTable::<T, A>::retain": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_retain() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        for x in 1..=6 {\n            table.insert_unique(hasher(&x), x, hasher);\n        }\n        table.retain(|&mut x| x % 2 == 0);\n        assert_eq!(table.len(), 3);\n        assert!(table.get(hasher(&2), |&x| x == 2).is_some());\n        assert!(table.get(hasher(&4), |&x| x == 4).is_some());\n        assert!(table.get(hasher(&6), |&x| x == 6).is_some());\n        assert!(table.get(hasher(&1), |&x| x == 1).is_none());\n        assert!(table.get(hasher(&3), |&x| x == 3).is_none());\n        assert!(table.get(hasher(&5), |&x| x == 5).is_none());\n    }\n}\n```", "table::HashTable::<T, A>::shrink_to": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_shrink_to() {\n        let mut table = HashTable::with_capacity(100);\n        let hasher = DefaultHashBuilder::default();\n        let hash_hasher = |val: &_| hasher.hash_one(val);\n        \n        table.insert_unique(hash_hasher(&1), 1, hash_hasher);\n        table.insert_unique(hash_hasher(&2), 2, hash_hasher);\n        assert!(table.capacity() >= 100);\n        \n        table.shrink_to(10, hash_hasher);\n        assert!(table.capacity() >= 10);\n        \n        table.shrink_to(0, hash_hasher);\n        assert!(table.capacity() >= 2);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_shrink_to_panic_due_to_small_capacity() {\n        let mut table = HashTable::with_capacity(5);\n        let hasher = DefaultHashBuilder::default();\n        let hash_hasher = |val: &_| hasher.hash_one(val);\n        \n        table.insert_unique(hash_hasher(&1), 1, hash_hasher);\n        table.shrink_to(10, hash_hasher);\n    }\n}\n```", "table::HashTable::<T, A>::shrink_to_fit": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut table = HashTable::with_capacity(100);\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &_| hasher.hash_one(val);\n        \n        table.insert_unique(hash_fn(&1), 1, hash_fn);\n        table.insert_unique(hash_fn(&2), 2, hash_fn);\n        \n        assert!(table.capacity() >= 100);\n        table.shrink_to_fit(hash_fn);\n        assert!(table.capacity() >= 2);\n        assert_eq!(table.len(), 2);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_empty_table() {\n        let mut table: HashTable<i32, Global> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &_| hasher.hash_one(val);\n\n        table.shrink_to_fit(hash_fn);\n        assert!(table.capacity() >= 0);\n        assert!(table.is_empty());\n    }\n}\n```", "table::HashTable::<T, A>::try_reserve": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_try_reserve_with_enough_capacity() {\n        let mut table: HashTable<i32> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        assert!(table.try_reserve(10, hasher).is_ok());\n        assert_eq!(table.capacity(), 10);\n    }\n\n    #[test]\n    fn test_try_reserve_with_zero_capacity() {\n        let mut table: HashTable<i32> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        assert!(table.try_reserve(0, hasher).is_ok());\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_try_reserve_with_exceeding_capacity() {\n        let mut table: HashTable<i32> = HashTable::with_capacity(1);\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        // Fill the table to the brim\n        table.try_reserve(1, hasher).expect(\"Should succeed\");\n        assert!(table.try_reserve(2, hasher).is_err());\n    }\n\n    #[test]\n    fn test_try_reserve_with_large_capacity() {\n        let mut table: HashTable<i32> = HashTable::with_capacity(1);\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        // Attempt to reserve a large number\n        assert!(table.try_reserve(usize::MAX, hasher).is_err());\n    }\n}\n```", "table::HashTable::<T, A>::with_capacity_in": "```rust\n#[cfg(test)]\nmod tests {\n    use bumpalo::Bump;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_with_capacity_in() {\n        let bump = Bump::new();\n        let mut table = HashTable::with_capacity_in(5, &bump);\n        \n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= 5);\n\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher(&\"One\"), \"One\", hasher);\n        table.insert_unique(hasher(&\"Two\"), \"Two\", hasher);\n        table.insert_unique(hasher(&\"Three\"), \"Three\", hasher);\n        table.insert_unique(hasher(&\"Four\"), \"Four\", hasher);\n        table.insert_unique(hasher(&\"Five\"), \"Five\", hasher);\n\n        assert_eq!(table.len(), 5);\n        assert_eq!(table.capacity(), table.capacity());\n    }\n}\n```", "table::HashTable::<T>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_hash_table_new() {\n        let table: HashTable<&str> = HashTable::new();\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_hash_table_new_with_capacity() {\n        let table: HashTable<i32> = HashTable::with_capacity(10);\n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= 10);\n    }\n}\n```", "table::HashTable::<T>::with_capacity": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable; // Ensure the HashTable is properly imported\n\n    #[test]\n    fn test_with_capacity_non_zero() {\n        let table: HashTable<&str> = HashTable::with_capacity(10);\n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let table: HashTable<&str> = HashTable::with_capacity(0);\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_large_number() {\n        let table: HashTable<i32> = HashTable::with_capacity(1_000_000);\n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= 1_000_000);\n    }\n\n    #[test]\n    fn test_with_capacity_edge_case() {\n        let table: HashTable<u32> = HashTable::with_capacity(1);\n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= 1);\n    }\n}\n```", "table::OccupiedEntry::<'a, T, A>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_occupied_entry_get() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        table.insert_unique(hasher(&\"test\"), \"test\", hasher);\n\n        match table.entry(hasher(&\"test\"), |&x| x == \"test\", hasher) {\n            Entry::Vacant(_) => panic!(\"Expected entry to be occupied\"),\n            Entry::Occupied(entry) => {\n                assert_eq!(entry.get(), &\"test\");\n            },\n        }\n    }\n}\n```", "table::OccupiedEntry::<'a, T, A>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_get_mut() {\n        let mut table: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        \n        table.insert_unique(hasher(&\"poneyland\"), (\"poneyland\", 12), |(k, _)| hasher(&k));\n        \n        // Modify the entry and check the result\n        if let Entry::Occupied(mut o) = table.entry(hasher(&\"poneyland\"), |&(x, _)| x == \"poneyland\", |(k, _)| hasher(&k)) {\n            let value = o.get_mut();\n            value.1 += 10;\n            assert_eq!(o.get().1, 22);\n            \n            // Modify it again\n            o.get_mut().1 += 2;\n        }\n\n        assert_eq!(table.find(hasher(&\"poneyland\"), |&(x, _)| x == \"poneyland\",), Some(&(\"poneyland\", 24)));\n    }\n}\n```", "table::OccupiedEntry::<'a, T, A>::into_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_into_mut() {\n        let mut table: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher(&\"test_key\"), (\"test_key\", 42), |(k, _)| hasher(&k));\n\n        match table.entry(hasher(&\"test_key\"), |&(x, _)| x == \"test_key\", |(k, _)| hasher(&k)) {\n            Entry::Occupied(entry) => {\n                let value: &mut (&str, u32) = entry.into_mut();\n                value.1 += 1;\n                assert_eq!(value.1, 43);\n            },\n            Entry::Vacant(_) => panic!(\"Entry should be occupied.\"),\n        }\n\n        assert_eq!(table.find(hasher(&\"test_key\"), |&(x, _)| x == \"test_key\"), Some(&(\"test_key\", 43)));\n    }\n}\n```", "table::OccupiedEntry::<'a, T, A>::into_table": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{table::{OccupiedEntry, HashTable}}; // Adjust path according to your project structure\n\n    #[test]\n    fn test_into_table() {\n        let mut table: HashTable<i32, Global> = HashTable::with_capacity(10);\n        let entry = table.insert(42);\n        let occupied_entry = entry.entry();\n        \n        let table_ref = occupied_entry.into_table();\n        \n        // Validate that the table reference returned is correct\n        assert_eq!(table_ref.len(), 1);\n        assert_eq!(table_ref.get(42), Some(&42));\n    }\n\n    #[test]\n    fn test_into_table_empty() {\n        let table: HashTable<i32, Global> = HashTable::with_capacity(10);\n        let result = table.get(42); // Entry for non-existent key\n\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_into_table_multiple_entries() {\n        let mut table: HashTable<i32, Global> = HashTable::with_capacity(10);\n        table.insert(10);\n        table.insert(20);\n        \n        let entry = table.get(10).unwrap();\n        let occupied_entry = entry.entry();\n        \n        let table_ref = occupied_entry.into_table();\n        \n        assert_eq!(table_ref.len(), 2); // Two entries in the table\n    }\n}\n```", "table::OccupiedEntry::<'a, T, A>::remove": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_table::Entry;\n    use hashbrown::HashTable;\n    use hashbrown::DefaultHashBuilder;\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_remove() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher(&\"test\"), \"test\", hasher);\n        let capacity_before_remove = table.capacity();\n\n        if let Entry::Occupied(o) = table.entry(hasher(&\"test\"), |&x| x == \"test\", hasher) {\n            let (removed_value, vacant_entry) = o.remove();\n            assert_eq!(removed_value, \"test\");\n            assert!(table.find(hasher(&\"test\"), |&x| x == \"test\").is_none());\n            assert!(table.len() == 0 && table.capacity() == capacity_before_remove);\n        } else {\n            panic!(\"Entry not found\");\n        }\n    }\n}\n```", "table::VacantEntry::<'a, T, A>::insert": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_insert_new_entry() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hash = DefaultHashBuilder::default().hash_one(&\"test_key\");\n        let entry = table.entry(hash, |&x| x == \"test_key\", |val| val);\n\n        if let Entry::Vacant(o) = entry {\n            let occupied_entry = o.insert(\"test_value\");\n            assert_eq!(occupied_entry.as_ref(), &\"test_value\");\n            assert_eq!(table.find(hash, |&x| x == \"test_value\"), Some(occupied_entry.as_ref()));\n        } else {\n            panic!(\"Entry should be vacant\");\n        }\n    }\n    \n    #[test]\n    fn test_insert_replace_existing_entry() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hash = DefaultHashBuilder::default().hash_one(&\"test_key\");\n        \n        // Insert first value\n        {\n            let entry = table.entry(hash, |&x| x == \"test_key\", |val| val);\n            if let Entry::Vacant(o) = entry {\n                let occupied_entry = o.insert(\"value_one\");\n                assert_eq!(occupied_entry.as_ref(), &\"value_one\");\n            } else {\n                panic!(\"Entry should be vacant\");\n            }\n        }\n\n        // Insert second value, replacing the first\n        {\n            let entry = table.entry(hash, |&x| x == \"test_key\", |val| val);\n            if let Entry::Occupied(o) = entry {\n                let occupied_entry = o.insert(\"value_two\");\n                assert_eq!(occupied_entry.as_ref(), &\"value_two\");\n                assert_eq!(table.find(hash, |&x| x == \"value_two\"), Some(occupied_entry.as_ref()));\n                assert_eq!(table.find(hash, |&x| x == \"value_one\"), None);\n            } else {\n                panic!(\"Entry should be occupied\");\n            }\n        }\n    }\n}\n```", "table::VacantEntry::<'a, T, A>::into_table": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::table::{HashTable, VacantEntry};\n\n    #[test]\n    fn test_into_table() {\n        let mut table: HashTable<u32, _> = HashTable::with_capacity(10);\n        let vacant_entry: VacantEntry<u32, _> = table.vacant_entry(42);\n        \n        // Convert VacantEntry into a mutable reference to the underlying HashTable\n        let table_ref: &mut HashTable<u32, _> = vacant_entry.into_table();\n        \n        // Ensure the table reference is still valid\n        assert_eq!(table_ref.len(), 0);\n        \n        // Try inserting a value to the table to ensure it's working\n        table_ref.insert(42, 100);\n        assert_eq!(table_ref.len(), 1);\n        assert_eq!(table_ref.get(&42).unwrap(), &100);\n    }\n}\n```", "util::invalid_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_invalid_mut() {\n        let addr: usize = 0x1 as usize; // Sample invalid address\n        let ptr: *mut i32 = invalid_mut(addr);\n        \n        // Ensure that the pointer is the same as the address we passed\n        assert_eq!(ptr as usize, addr);\n        \n        // Check that the pointer is non-null\n        assert!(!ptr.is_null());\n    }\n\n    #[test]\n    fn test_invalid_mut_different_types() {\n        let addr: usize = 0x2 as usize; // Sample invalid address\n        let ptr: *mut f64 = invalid_mut(addr);\n        \n        // Ensure that the pointer is the same as the address we passed\n        assert_eq!(ptr as usize, addr);\n        \n        // Check that the pointer is non-null\n        assert!(!ptr.is_null());\n    }\n}\n```"}