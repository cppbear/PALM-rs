{
    "<Rng as core::clone::Clone>::clone": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Rng;\n\n    #[test]\n    fn test_clone() {\n        let original_rng = Rng::with_seed(42);\n        let cloned_rng = original_rng.clone();\n\n        assert_eq!(original_rng.get_seed(), cloned_rng.get_seed());\n        assert_eq!(original_rng.bool(), cloned_rng.bool());\n        assert_eq!(original_rng.u32(..), cloned_rng.u32(..));\n    }\n\n    #[test]\n    fn test_clone_different_rng() {\n        let original_rng = Rng::with_seed(42);\n        let cloned_rng = original_rng.clone();\n\n        // Ensure they are separate instances\n        assert_ne!(original_rng as *const Rng, cloned_rng as *const Rng);\n    }\n}\n```",
    "<global_rng::RestoreOnDrop<'_> as core::ops::Drop>::drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::Cell;\n\n    #[test]\n    fn test_restore_on_drop() {\n        let original_rng = Cell::new(Rng::with_seed(42));\n        {\n            let current_rng = Rng::with_seed(100);\n            let _restorer = RestoreOnDrop {\n                rng: &original_rng,\n                current: current_rng,\n            };\n            // Original RNG should remain unchanged temporarily\n            assert_eq!(original_rng.get().get_seed(), 42);\n        }\n        // Dropping RestoreOnDrop should restore the RNG\n        assert_eq!(original_rng.get().get_seed(), 100);\n    }\n\n    #[test]\n    fn test_restore_on_drop_panic() {\n        let original_rng = Cell::new(Rng::with_seed(42));\n        {\n            let current_rng = Rng::with_seed(100);\n            let _restorer = RestoreOnDrop {\n                rng: &original_rng,\n                current: current_rng,\n            };\n            // Original RNG should remain unchanged temporarily\n            assert_eq!(original_rng.get().get_seed(), 42);\n            panic!(\"Intentional panic to test drop\");\n        }\n        // Due to the panic, the original RNG should still be restored\n        assert_eq!(original_rng.get().get_seed(), 100);\n    }\n}\n```",
    "Rng::alphabetic": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust this import if necessary for your module structure\n\n    #[test]\n    fn test_alphabetic() {\n        let mut rng = Rng::default();\n        let char = rng.alphabetic();\n        assert!(char.is_ascii_alphabetic(), \"The generated character is not alphabetic\");\n        assert!(char.is_lowercase() || char.is_uppercase(), \"The generated character is not in the range a-z or A-Z\");\n    }\n}\n```",
    "Rng::alphanumeric": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Rng;\n\n    #[test]\n    fn test_alphanumeric() {\n        let mut rng = Rng::default();\n        let mut alphanumeric_chars = Vec::new();\n        \n        for _ in 0..1000 {\n            let c = rng.alphanumeric();\n            alphanumeric_chars.push(c);\n            assert!(c.is_ascii_alphanumeric(), \"Character is not alphanumeric\");\n        }\n        \n        assert!(alphanumeric_chars.iter().any(|&c| c.is_ascii_lowercase()), \"Should include lowercase letters\");\n        assert!(alphanumeric_chars.iter().any(|&c| c.is_ascii_uppercase()), \"Should include uppercase letters\");\n        assert!(alphanumeric_chars.iter().any(|&c| c.is_ascii_digit()), \"Should include digits\");\n    }\n}\n```",
    "Rng::bool": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_rng_bool() {\n        let mut rng = Rng::new();\n        let results: Vec<bool> = (0..1000).map(|_| rng.bool()).collect();\n        \n        let true_count = results.iter().filter(|&&value| value).count();\n        let false_count = results.iter().filter(|&&value| !value).count();\n        \n        // We expect a roughly equal distribution of true and false\n        assert!(\n            true_count + false_count == 1000, \n            \"Should have 1000 results, got {} true and {} false\", \n            true_count, false_count\n        );\n        assert!((true_count > 400 && true_count < 600), \"Too few true results: {}\", true_count);\n        assert!((false_count > 400 && false_count < 600), \"Too few false results: {}\", false_count);\n    }\n}\n```",
    "Rng::char": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ops::RangeBounds;\n\n    #[test]\n    #[should_panic(expected = \"empty range\")]\n    fn test_char_empty_range() {\n        let mut rng = Rng::new();\n        rng.char(0..0);\n    }\n\n    #[test]\n    fn test_char_valid_range() {\n        let mut rng = Rng::new();\n        let result = rng.char('a'..='z');\n        assert!(result >= 'a' && result <= 'z');\n    }\n\n    #[test]\n    fn test_char_valid_range_exclusive() {\n        let mut rng = Rng::new();\n        let result = rng.char('a'..'z');\n        assert!(result >= 'a' && result < 'z');\n    }\n\n    #[test]\n    #[should_panic(expected = \"empty range\")]\n    fn test_char_invalid_range() {\n        let mut rng = Rng::new();\n        rng.char('z'..='a');\n    }\n\n    #[test]\n    fn test_char_upper_bound_exclusive() {\n        let mut rng = Rng::new();\n        let result = rng.char('a'..'z');\n        assert!(result >= 'a' && result < 'z');\n    }\n\n    #[test]\n    fn test_char_lower_bound_exclusive() {\n        let mut rng = Rng::new();\n        let result = rng.char('a'..='y');\n        assert!(result >= 'a' && result <= 'y');\n    }\n\n    #[test]\n    fn test_char_unbounded_range() {\n        let mut rng = Rng::new();\n        let result = rng.char(..);\n        assert!(result.is_ascii());\n    }\n}\n```",
    "Rng::choice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::Rng;\n\n    #[test]\n    fn test_choice_non_empty() {\n        let mut rng = Rng::with_seed(42);\n        let choices = vec![1, 2, 3, 4, 5];\n        let result = rng.choice(choices.clone()).unwrap();\n        assert!(choices.contains(&result));\n    }\n\n    #[test]\n    fn test_choice_empty() {\n        let mut rng = Rng::with_seed(42);\n        let choices: Vec<i32> = vec![];\n        let result = rng.choice(choices);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_choice_single_element() {\n        let mut rng = Rng::with_seed(42);\n        let choices = vec![42];\n        let result = rng.choice(choices.clone()).unwrap();\n        assert_eq!(result, 42);\n    }\n\n    #[test]\n    fn test_choice_large_vector() {\n        let mut rng = Rng::with_seed(42);\n        let choices: Vec<i32> = (1..=100).collect();\n        let result = rng.choice(choices.clone()).unwrap();\n        assert!(choices.contains(&result));\n    }\n}\n```",
    "Rng::choose_multiple": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::vec;\n\n    #[test]\n    fn test_choose_multiple() {\n        let mut rng = Rng::default();\n        let source = vec![1, 2, 3, 4, 5];\n        \n        let result = rng.choose_multiple(source.clone(), 3);\n        assert_eq!(result.len(), 3);\n        for item in result {\n            assert!(source.contains(&item));\n        }\n\n        let result = rng.choose_multiple(source.clone(), 10);\n        assert_eq!(result.len(), source.len());\n        for item in result {\n            assert!(source.contains(&item));\n        }\n\n        let result = rng.choose_multiple(vec![], 5);\n        assert!(result.is_empty());\n    }\n}\n```",
    "Rng::digit": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::Rng; // Make sure to import Rng from the crate\n\n    #[test]\n    fn test_digit_zero_base() {\n        let mut rng = Rng::default();\n        std::panic::set_hook(Box::new(|_| {})); // Prevent panic message output\n        let result = std::panic::catch_unwind(|| rng.digit(0));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_digit_above_base() {\n        let mut rng = Rng::default();\n        std::panic::set_hook(Box::new(|_| {})); // Prevent panic message output\n        let result = std::panic::catch_unwind(|| rng.digit(37));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_digit_valid_base() {\n        let mut rng = Rng::default();\n        for base in 2..=36 {\n            let digit = rng.digit(base);\n            assert!(if base <= 10 {\n                ('0'..='0' + base as u8 as char).contains(&digit)\n            } else {\n                ('0'..='9').contains(&digit) || ('a'..='a' + (base - 10) as u8 as char).contains(&digit)\n            });\n        }\n    }\n}\n```",
    "Rng::f32": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::Rng;\n\n    #[test]\n    fn test_rng_f32() {\n        let mut rng = Rng::new();\n        let value = rng.f32();\n        assert!(value >= 0.0 && value < 1.0, \"f32 value {} is out of range [0.0, 1.0)\", value);\n    }\n\n    #[test]\n    fn test_rng_f32_multiple() {\n        let mut rng = Rng::new();\n        let values: Vec<f32> = (0..1000).map(|_| rng.f32()).collect();\n\n        for &value in &values {\n            assert!(value >= 0.0 && value < 1.0, \"f32 value {} is out of range [0.0, 1.0)\", value);\n        }\n    }\n}\n```",
    "Rng::f64": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Rng;\n\n    #[test]\n    fn test_f64() {\n        let mut rng = Rng::new();\n        let value = rng.f64();\n        assert!(value >= 0.0 && value < 1.0, \"Expected value in range [0, 1)\");\n    }\n\n    #[test]\n    fn test_f64_multiple() {\n        let mut rng = Rng::new();\n        let values: Vec<f64> = (0..1000).map(|_| rng.f64()).collect();\n        assert!(values.iter().all(|&x| x >= 0.0 && x < 1.0), \"Expected all values in range [0, 1)\");\n    }\n\n    #[test]\n    fn test_f64_repeatability() {\n        let mut rng1 = Rng::with_seed(1);\n        let mut rng2 = Rng::with_seed(1);\n        let value1 = rng1.f64();\n        let value2 = rng2.f64();\n        assert_eq!(value1, value2, \"Expected to generate the same value with the same seed\");\n    }\n}\n```",
    "Rng::fill": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::Rng;\n\n    #[test]\n    fn test_fill() {\n        let mut rng = Rng::with_seed(42);\n        let mut buf = vec![0u8; 16];\n\n        rng.fill(&mut buf);\n        \n        // Check that the buffer has been filled with random data\n        // Assert that the buffer contains random data by checking that\n        // it does not consist entirely of zeroes.\n        assert!(buf.iter().any(|&x| x != 0), \"Buffer should not be all zeroes.\");\n        \n        // Further test the length of the buffer\n        assert_eq!(buf.len(), 16);\n\n        // Check if the data in the buffer appears random by checking\n        // that all of its bytes are not equal (not a definitive check, \n        // but a basic check for randomness).\n        let all_equal = buf.windows(2).all(|w| w[0] != w[1]);\n        assert!(all_equal, \"Buffer bytes should not all be equal.\");\n    }\n}\n```",
    "Rng::fork": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::Rng;\n\n    #[test]\n    fn test_rng_fork() {\n        let mut base_rng = Rng::with_seed(0x4d595df4d0f33173);\n        let mut forked_rng1 = base_rng.fork();\n        let mut forked_rng2 = base_rng.fork();\n\n        // Ensure forked instances do not produce the same sequence\n        let vals1: Vec<u32> = (0..10).map(|_| forked_rng1.u32(..)).collect();\n        let vals2: Vec<u32> = (0..10).map(|_| forked_rng2.u32(..)).collect();\n\n        // Check that the two forked RNGs produce different sequences\n        assert_ne!(vals1, vals2);\n    }\n\n    #[test]\n    fn test_rng_fork_reproducibility() {\n        let mut base_rng = Rng::with_seed(0x4d595df4d0f33173);\n        let mut forked_rng1 = base_rng.fork();\n        let mut forked_rng2 = base_rng.fork();\n\n        // Ensure the same input seed produces the same forked RNG\n        let vals1: Vec<u32> = (0..10).map(|_| forked_rng1.u32(..)).collect();\n        let vals2: Vec<u32> = (0..10).map(|_| forked_rng2.u32(..)).collect();\n\n        // Both should produce the same sequence\n        assert_eq!(vals1, vals2);\n    }\n}\n```",
    "Rng::gen_mod_u128": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_gen_mod_u128() {\n        let mut rng = Rng::with_seed(12345);\n        \n        // Test with small n\n        let n = 10u128;\n        let result = rng.gen_mod_u128(n);\n        assert!(result < n);\n\n        // Test with a larger n\n        let n = 1_000_000_000_000_000_000u128;\n        let result = rng.gen_mod_u128(n);\n        assert!(result < n);\n\n        // Test edge case n = 1\n        let n = 1u128;\n        let result = rng.gen_mod_u128(n);\n        assert_eq!(result, 0);\n\n        // Test with maximum `u128`\n        let n = u128::MAX;\n        let result = rng.gen_mod_u128(n);\n        assert!(result < n);\n    }\n}\n```",
    "Rng::gen_mod_u32": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::Rng;\n\n    #[test]\n    fn test_gen_mod_u32() {\n        let mut rng = Rng::with_seed(12345);\n        \n        const N: u32 = 10;\n\n        // Test that we get a number in the range 0..N\n        for _ in 0..1000 {\n            let result = rng.gen_mod_u32(N);\n            assert!(result < N);\n        }\n\n        // Test edge cases\n        assert_eq!(rng.gen_mod_u32(1), 0); // range [0..1]\n        assert_eq!(rng.gen_mod_u32(0), 0); // should not panic and return 0\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_gen_mod_u32_zero() {\n        let mut rng = Rng::with_seed(12345);\n        rng.gen_mod_u32(0); // This should panic\n    }\n\n    #[test]\n    fn test_gen_mod_u32_large() {\n        let mut rng = Rng::with_seed(54321);\n        \n        const N: u32 = 1_000_000;\n\n        // Test that we get a number in the range 0..N\n        for _ in 0..1000 {\n            let result = rng.gen_mod_u32(N);\n            assert!(result < N);\n        }\n    }\n}\n```",
    "Rng::gen_mod_u64": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::Rng;\n\n    #[test]\n    fn test_gen_mod_u64() {\n        let mut rng = Rng::with_seed(42);\n        let n = 100;\n\n        // Test that we get a result within the expected range\n        for _ in 0..1000 {\n            let result = rng.gen_mod_u64(n);\n            assert!(result < n, \"Result {} is not less than n {}\", result, n);\n        }\n\n        // Test for cases n = 1, should always return 0\n        let result_zero = rng.gen_mod_u64(1);\n        assert_eq!(result_zero, 0, \"Result for n=1 should always be 0\");\n\n        // Test for cases n = 0 should panic (or however the function is allowed to handle that)\n        // Uncomment the following line to test for panic\n        // let result_zero = rng.gen_mod_u64(0); // Expect panic.\n    }\n}\n```",
    "Rng::gen_u128": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::Rng;\n\n    #[test]\n    fn test_gen_u128() {\n        let mut rng = Rng::with_seed(12345);\n        let value = rng.gen_u128();\n        \n        // Ensure the value is within the range of u128\n        assert!(value <= u128::MAX);\n        assert!(value >= 0);\n\n        // Testing the randomness by generating multiple values\n        let mut values = std::collections::HashSet::new();\n        for _ in 0..1000 {\n            values.insert(rng.gen_u128());\n        }\n        \n        // Ensure that we got more than 1 unique value\n        assert!(values.len() > 1);\n    }\n}\n```",
    "Rng::gen_u32": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_gen_u32() {\n        let mut rng = Rng::with_seed(0x4d595df4d0f33173);\n        let value = rng.gen_u32();\n        assert!(value <= u32::MAX);\n    }\n\n    #[test]\n    fn test_gen_u32_multiple() {\n        let mut rng = Rng::with_seed(0x4d595df4d0f33173);\n        let value1 = rng.gen_u32();\n        let value2 = rng.gen_u32();\n        assert!(value1 <= u32::MAX);\n        assert!(value2 <= u32::MAX);\n        assert!(value1 != value2); // Assuming randomness\n    }\n\n    #[test]\n    fn test_gen_u32_consistency() {\n        let mut rng1 = Rng::with_seed(0x4d595df4d0f33173);\n        let mut rng2 = Rng::with_seed(0x4d595df4d0f33173);\n        let value1 = rng1.gen_u32();\n        let value2 = rng2.gen_u32();\n        assert_eq!(value1, value2); // Same seed should yield same results\n    }\n}\n```",
    "Rng::gen_u64": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Rng;\n\n    #[test]\n    fn test_gen_u64() {\n        let mut rng = Rng::with_seed(0x1234_5678_9abc_def0);\n        let value1 = rng.gen_u64();\n        let value2 = rng.gen_u64();\n        \n        // Ensure that the values are different for consecutive calls\n        assert_ne!(value1, value2);\n        \n        // Check that values are within u64 range\n        assert!(value1 <= u64::MAX);\n        assert!(value2 <= u64::MAX);\n    }\n\n    #[test]\n    fn test_gen_u64_with_different_seeds() {\n        let mut rng1 = Rng::with_seed(0x1);\n        let mut rng2 = Rng::with_seed(0x2);\n        \n        let value1 = rng1.gen_u64();\n        let value2 = rng2.gen_u64();\n        \n        // Ensure that the values are different for different seeds\n        assert_ne!(value1, value2);\n    }\n\n    #[test]\n    fn test_gen_u64_reproducibility() {\n        let seed = 0xdeadbeef;\n        let mut rng1 = Rng::with_seed(seed);\n        let mut rng2 = Rng::with_seed(seed);\n        \n        for _ in 0..10 {\n            let value1 = rng1.gen_u64();\n            let value2 = rng2.gen_u64();\n            // Both generators should produce the same value for the same seed\n            assert_eq!(value1, value2);\n        }\n    }\n}\n```",
    "Rng::get_seed": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Rng;\n\n    #[test]\n    fn test_get_seed() {\n        let rng = Rng::with_seed(42);\n        assert_eq!(rng.get_seed(), 42);\n        \n        let rng_clone = rng.clone();\n        assert_eq!(rng_clone.get_seed(), 42);\n        \n        let rng_default = Rng::default();\n        assert_eq!(rng_default.get_seed(), rng_default.get_seed());\n    }\n}\n```",
    "Rng::i128": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Bound;\n\n    #[test]\n    fn test_rng_i128_range_inclusive() {\n        let mut rng = Rng::new();\n        let range = (Bound::Included(-10), Bound::Included(10));\n        let result = rng.i128(range);\n        assert!(result >= -10 && result <= 10);\n    }\n\n    #[test]\n    fn test_rng_i128_range_exclusive() {\n        let mut rng = Rng::new();\n        let range = (Bound::Excluded(-10), Bound::Excluded(10));\n        let result = rng.i128(range);\n        assert!(result > -10 && result < 10);\n    }\n\n    #[test]\n    fn test_rng_i128_unbounded_range() {\n        let mut rng = Rng::new();\n        let range = (Bound::Unbounded, Bound::Unbounded);\n        let result = rng.i128(range);\n        // The result can be any i128 value\n        // This test just asserts that it doesn't panic\n        assert!(true);\n    }\n\n    #[test]\n    fn test_rng_i128_empty_range() {\n        let mut rng = Rng::new();\n        let range = (Bound::Excluded(10), Bound::Included(10));\n        let result = std::panic::catch_unwind(|| {\n            rng.i128(range);\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_rng_i128_inverted_range() {\n        let mut rng = Rng::new();\n        let range = (Bound::Included(10), Bound::Included(-10));\n        let result = std::panic::catch_unwind(|| {\n            rng.i128(range);\n        });\n        assert!(result.is_err());\n    }\n}\n```",
    "Rng::i16": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_rng_i16_in_range() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.i16(0..10);\n        assert!(value >= 0 && value < 10);\n    }\n\n    #[test]\n    fn test_rng_i16_in_negative_range() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.i16(-10..0);\n        assert!(value >= -10 && value < 0);\n    }\n\n    #[test]\n    #[should_panic(expected = \"empty range\")]\n    fn test_rng_i16_empty_range() {\n        let mut rng = Rng::with_seed(42);\n        rng.i16(10..10);\n    }\n\n    #[test]\n    fn test_rng_i16_unbounded_range() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.i16(..);\n        assert!(value >= i16::MIN && value <= i16::MAX);\n    }\n\n    #[test]\n    fn test_rng_i16_negative_unbounded_range() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.i16(..0);\n        assert!(value <= 0);\n    }\n\n    #[test]\n    fn test_rng_i16_inclusive_range() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.i16(0..=5);\n        assert!(value >= 0 && value <= 5);\n    }\n\n    #[test]\n    fn test_rng_i16_exclusive_range() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.i16(0..5);\n        assert!(value >= 0 && value < 5);\n    }\n}\n```",
    "Rng::i32": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::RangeInclusive;\n\n    #[test]\n    fn test_rng_i32_within_range() {\n        let mut rng = Rng::with_seed(42);\n        let result = rng.i32(0..=10);\n        assert!(result >= 0 && result <= 10);\n    }\n\n    #[test]\n    fn test_rng_i32_with_negative_range() {\n        let mut rng = Rng::with_seed(42);\n        let result = rng.i32(-10..=0);\n        assert!(result >= -10 && result <= 0);\n    }\n\n    #[test]\n    #[should_panic(expected = \"empty range: _.._\")]\n    fn test_rng_i32_empty_range() {\n        let mut rng = Rng::with_seed(42);\n        rng.i32(5..5);\n    }\n\n    #[test]\n    fn test_rng_i32_large_range() {\n        let mut rng = Rng::with_seed(42);\n        let result = rng.i32(i32::MIN..=i32::MAX);\n        assert!(result >= i32::MIN && result <= i32::MAX);\n    }\n}\n```",
    "Rng::i64": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_rng_i64_in_range() {\n        let mut rng = Rng::with_seed(42);\n        let range = Range::<i64>::new(10, 20);\n        let result = rng.i64(range);\n        assert!(result >= 10 && result < 20);\n    }\n\n    #[test]\n    fn test_rng_i64_inclusive_range() {\n        let mut rng = Rng::with_seed(42);\n        let range = 10..=20;\n        let result = rng.i64(range);\n        assert!(result >= 10 && result <= 20);\n    }\n\n    #[test]\n    fn test_rng_i64_empty_range() {\n        let mut rng = Rng::with_seed(42);\n        let range = 20..10; // should panic\n        let result = std::panic::catch_unwind(|| rng.i64(range));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_rng_i64_unbounded_range() {\n        let mut rng = Rng::with_seed(42);\n        let range = std::ops::Range::<i64>::from(..);\n        let result = rng.i64(range);\n        // Just ensuring we get an i64\n        assert!(result >= i64::MIN && result <= i64::MAX);\n    }\n}\n```",
    "Rng::i8": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_rng_i8_inclusive_range() {\n        let mut rng = Rng::new();\n        let value = rng.i8(0..=10);\n        assert!(value >= 0 && value <= 10);\n    }\n\n    #[test]\n    fn test_rng_i8_exclusive_range() {\n        let mut rng = Rng::new();\n        let value = rng.i8(0..10);\n        assert!(value >= 0 && value < 10);\n    }\n\n    #[test]\n    fn test_rng_i8_unbounded_range() {\n        let mut rng = Rng::new();\n        let value = rng.i8(..);\n        assert!(value >= i8::MIN && value <= i8::MAX);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_rng_i8_empty_range() {\n        let mut rng = Rng::new();\n        let _value = rng.i8(10..=0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_rng_i8_exclusive_empty_range() {\n        let mut rng = Rng::new();\n        let _value = rng.i8(10..10);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_rng_i8_exclusive_empty_lower_bound() {\n        let mut rng = Rng::new();\n        let _value = rng.i8(..=i8::MIN);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_rng_i8_exclusive_empty_upper_bound() {\n        let mut rng = Rng::new();\n        let _value = rng.i8(0..=i8::MAX);\n    }\n}\n```",
    "Rng::isize": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_rng_isize_with_valid_range() {\n        let mut rng = Rng::with_seed(12345);\n        let result = rng.isize(0..10);\n        assert!(result >= 0 && result < 10, \"The result should be within the range 0..10.\");\n    }\n\n    #[test]\n    fn test_rng_isize_with_inclusive_range() {\n        let mut rng = Rng::with_seed(12345);\n        let result = rng.isize(0..=10);\n        assert!(result >= 0 && result <= 10, \"The result should be within the range 0..=10.\");\n    }\n\n    #[test]\n    fn test_rng_isize_with_commonly_empty_range() {\n        let mut rng = Rng::with_seed(12345);\n        let result = std::panic::catch_unwind(|| {\n            rng.isize(10..0);\n        });\n        assert!(result.is_err(), \"The call should panic with an empty range.\");\n    }\n\n    #[test]\n    fn test_rng_isize_with_unbounded_range() {\n        let mut rng = Rng::with_seed(12345);\n        let result = rng.isize(..);\n        assert_eq!(result, rng.gen_u64() as isize, \"The result should match the generated u64 as isize.\");\n    }\n\n    #[test]\n    fn test_rng_isize_with_exclusive_upper_bound() {\n        let mut rng = Rng::with_seed(12345);\n        let result = rng.isize(0..10);\n        assert!(result < 10, \"The result should be less than the upper bound of the range.\");\n    }\n\n    #[test]\n    fn test_rng_isize_with_inclusive_upper_bound() {\n        let mut rng = Rng::with_seed(12345);\n        let result = rng.isize(0..=10);\n        assert!(result <= 10, \"The result should be less than or equal to the upper bound of the range.\");\n    }\n}\n```",
    "Rng::lowercase": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Rng;\n\n    #[test]\n    fn test_lowercase() {\n        let mut rng = Rng::new();\n        let char = rng.lowercase();\n        assert!(char.is_ascii_lowercase());\n        assert!(char.is_alphabetic());\n    }\n\n    #[test]\n    fn test_lowercase_multiple() {\n        let mut rng = Rng::new();\n        let mut lowercases = vec![];\n        for _ in 0..1000 {\n            lowercases.push(rng.lowercase());\n        }\n        assert!(lowercases.iter().all(|&c| c.is_ascii_lowercase()));\n    }\n}\n```",
    "Rng::seed": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Rng;\n\n    #[test]\n    fn test_seed() {\n        let mut rng = Rng::new();\n        let initial_seed = rng.get_seed();\n        let new_seed = 123456789;\n\n        rng.seed(new_seed);\n        let seeded_value = rng.get_seed();\n\n        assert_eq!(seeded_value, new_seed);\n        assert_ne!(seeded_value, initial_seed);\n    }\n\n    #[test]\n    fn test_seed_reproducibility() {\n        let seed = 987654321;\n        let mut rng1 = Rng::with_seed(seed);\n        let mut rng2 = Rng::with_seed(seed);\n\n        let value1 = rng1.u32(..);\n        let value2 = rng2.u32(..);\n\n        assert_eq!(value1, value2);\n    }\n}\n```",
    "Rng::shuffle": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::Rng;\n\n    #[test]\n    fn test_shuffle() {\n        let mut rng = Rng::with_seed(42);\n        let mut slice = [1, 2, 3, 4, 5];\n        let original = slice.clone();\n        \n        // Shuffle the slice\n        rng.shuffle(&mut slice);\n        \n        // Check that the length is the same\n        assert_eq!(slice.len(), original.len());\n        \n        // Check that all elements are still present\n        for &item in &original {\n            assert!(slice.contains(&item));\n        }\n        \n        // Check that the shuffled slice is not equal to the original\n        assert!(slice != original);\n    }\n\n    #[test]\n    fn test_shuffle_empty() {\n        let mut rng = Rng::with_seed(42);\n        let mut slice: Vec<i32> = Vec::new();\n        rng.shuffle(&mut slice);\n        assert!(slice.is_empty());\n    }\n\n    #[test]\n    fn test_shuffle_single_element() {\n        let mut rng = Rng::with_seed(42);\n        let mut slice = [42];\n        rng.shuffle(&mut slice);\n        assert_eq!(slice, [42]);\n    }\n}\n```",
    "Rng::u128": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assuming the tests are in the same module, otherwise use appropriate path\n    use core::ops::Range;\n\n    #[test]\n    fn test_u128_generation_in_range() {\n        let mut rng = Rng::new();\n        let low = 10;\n        let high = 100;\n        let value = rng.u128(low..=high);\n        assert!(value >= low && value <= high);\n    }\n\n    #[test]\n    #[should_panic(expected = \"empty range: ..10\")]\n    fn test_u128_generation_empty_range_start() {\n        let mut rng = Rng::new();\n        rng.u128(..10);\n    }\n\n    #[test]\n    #[should_panic(expected = \"empty range: 10..10\")]\n    fn test_u128_generation_empty_range_inclusive() {\n        let mut rng = Rng::new();\n        rng.u128(10..10);\n    }\n\n    #[test]\n    fn test_u128_generation_full_range() {\n        let mut rng = Rng::new();\n        let value = rng.u128(..);\n        assert!(value >= 0); // Since u128 is always >= 0\n    }\n\n    #[test]\n    fn test_u128_generation_specific_values() {\n        let mut rng = Rng::with_seed(0xdeadbeef);\n        let value1 = rng.u128(0..=10);\n        let value2 = rng.u128(0..=10);\n        assert_ne!(value1, value2); // Different seeds should produce different values\n    }\n}\n```",
    "Rng::u16": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_u16_within_bounds() {\n        let mut rng = Rng::with_seed(12345);\n        let value = rng.u16(0..100);\n        assert!(value >= 0 && value < 100);\n    }\n\n    #[test]\n    fn test_u16_zero_to_max() {\n        let mut rng = Rng::with_seed(12345);\n        let value = rng.u16(..);\n        assert!(value >= 0 && value <= u16::MAX);\n    }\n\n    #[test]\n    #[should_panic(expected = \"empty range: ..\")]\n    fn test_u16_empty_range() {\n        let mut rng = Rng::with_seed(12345);\n        let _ = rng.u16(0..0);\n    }\n\n    #[test]\n    fn test_u16_inclusive_bounds() {\n        let mut rng = Rng::with_seed(12345);\n        let value = rng.u16(0..=100);\n        assert!(value >= 0 && value <= 100);\n    }\n\n    #[test]\n    fn test_u16_exclusive_bounds() {\n        let mut rng = Rng::with_seed(12345);\n        let value = rng.u16(1..100);\n        assert!(value >= 1 && value < 100);\n    }\n}\n```",
    "Rng::u32": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_rng_u32() {\n        let mut rng = Rng::new();\n\n        // Test to ensure u32 returns values within range\n        let value = rng.u32(..);\n        assert!(value <= u32::MAX);\n\n        // Test specific range\n        let low = 100;\n        let high = 200;\n        let range = low..high;\n\n        let value_in_range = rng.u32(range.clone());\n        assert!(value_in_range >= low && value_in_range < high);\n\n        // Test empty range panic\n        let result = std::panic::catch_unwind(|| {\n            rng.u32(Range {\n                start: 5,\n                end: 5,\n            });\n        });\n        assert!(result.is_err());\n    }\n}\n```",
    "Rng::u64": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Rng;\n\n    #[test]\n    fn test_u64_inclusive_range() {\n        let mut rng = Rng::with_seed(42);\n        let result = rng.u64(1..=10);\n        assert!(result >= 1 && result <= 10);\n    }\n\n    #[test]\n    fn test_u64_exclusive_range() {\n        let mut rng = Rng::with_seed(42);\n        let result = rng.u64(1..10);\n        assert!(result >= 1 && result < 10);\n    }\n\n    #[test]\n    fn test_u64_empty_range() {\n        let mut rng = Rng::with_seed(42);\n        let result = std::panic::catch_unwind(|| {\n            rng.u64(10..10);\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_u64_unbounded_range() {\n        let mut rng = Rng::with_seed(42);\n        let result = rng.u64(..);\n        assert!(result <= std::u64::MAX);\n    }\n}\n```",
    "Rng::u8": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Bound;\n\n    #[test]\n    fn test_rng_u8_within_range() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.u8(0..=255);\n        assert!(value >= 0 && value <= 255);\n    }\n\n    #[test]\n    fn test_rng_u8_exclusive_upper() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.u8(0..255);\n        assert!(value >= 0 && value < 255);\n    }\n\n    #[test]\n    fn test_rng_u8_exclusive_lower() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.u8(1..=255);\n        assert!(value > 1 && value <= 255);\n    }\n\n    #[test]\n    fn test_rng_u8_empty_range() {\n        let mut rng = Rng::with_seed(42);\n        let result = std::panic::catch_unwind(|| {\n            rng.u8(1..1);\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_rng_u8_unbounded() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.u8(..);\n        assert!(value <= 255);\n    }\n}\n```",
    "Rng::uppercase": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_uppercase() {\n        let mut rng = Rng::default();\n        let mut results = Vec::new();\n        for _ in 0..1000 {\n            results.push(rng.uppercase());\n        }\n        // Ensure all results are in the range 'A' to 'Z'\n        for &ch in &results {\n            assert!(ch >= 'A' && ch <= 'Z', \"Character {} is out of range\", ch);\n        }\n    }\n}\n```",
    "Rng::usize": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ops::Range;\n\n    #[test]\n    fn test_usize_inclusive_range() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.usize(1..=10);\n        assert!(value >= 1 && value <= 10);\n    }\n\n    #[test]\n    fn test_usize_exclusive_range() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.usize(1..10);\n        assert!(value >= 1 && value < 10);\n    }\n\n    #[test]\n    fn test_usize_empty_range() {\n        let mut rng = Rng::with_seed(42);\n        std::panic::catch_unwind(|| {\n            rng.usize(10..10);\n        }).unwrap_err(); // should panic\n    }\n\n    #[test]\n    fn test_usize_unbounded_low() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.usize(..);\n        assert!(value <= usize::MAX);\n    }\n\n    #[test]\n    fn test_usize_unbounded_high() {\n        let mut rng = Rng::with_seed(42);\n        let value = rng.usize(0..);\n        assert!(value >= 0);\n    }\n}\n```",
    "Rng::with_seed": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Rng;\n\n    #[test]\n    fn test_with_seed() {\n        let seed: u64 = 12345;\n        let rng = Rng::with_seed(seed);\n        assert_eq!(rng.get_seed(), seed);\n    }\n\n    #[test]\n    fn test_with_seed_clone() {\n        let seed: u64 = 67890;\n        let rng1 = Rng::with_seed(seed);\n        let rng2 = rng1.clone();\n        assert_eq!(rng1.get_seed(), rng2.get_seed());\n        assert_eq!(rng1, rng2);\n    }\n}\n```",
    "global_rng::<impl Rng>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::Rng;\n\n    #[test]\n    fn test_rng_new_creates_rng() {\n        let rng = Rng::new();\n        assert_eq!(rng.get_seed(), 0x4d595df4d0f33173);\n    }\n\n    #[test]\n    fn test_rng_clone_creates_identical_rng() {\n        let rng1 = Rng::new();\n        let rng2 = rng1.clone();\n        assert_eq!(rng1.get_seed(), rng2.get_seed());\n    }\n\n    #[test]\n    fn test_rng_new_is_default() {\n        let rng_default = Rng::default();\n        assert_eq!(rng_default.get_seed(), 0x4d595df4d0f33173);\n    }\n\n    #[test]\n    fn test_rng_fork_creates_different_rng() {\n        let mut rng1 = Rng::new();\n        let mut rng2 = rng1.fork();\n        assert_ne!(rng1.get_seed(), rng2.get_seed());\n    }\n}\n```",
    "global_rng::<impl core::default::Default for Rng>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::Rng;\n\n    #[test]\n    fn test_rng_default() {\n        let rng1 = Rng::default();\n        let rng2 = Rng::new();\n        assert_eq!(rng1.get_seed(), rng2.get_seed());\n    }\n}\n```",
    "global_rng::alphabetic": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::global_rng::alphabetic;\n\n    #[test]\n    fn test_alphabetic() {\n        for _ in 0..1000 {\n            let ch = alphabetic();\n            assert!(ch.is_alphabetic(), \"Generated character {} is not alphabetic\", ch);\n            assert!(ch.is_ascii_alphabetic(), \"Generated character {} is not ASCII alphabetic\", ch);\n        }\n    }\n}\n```",
    "global_rng::alphanumeric": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Ensure to bring `alphanumeric` into scope\n    use fastrand::Rng; // Ensure to bring `Rng` into scope\n\n    #[test]\n    fn test_alphanumeric() {\n        // Generate a set of characters to check\n        let generated_chars: Vec<char> = (0..1000).map(|_| alphanumeric()).collect();\n\n        // Check that all characters are alphanumeric\n        for c in generated_chars {\n            assert!(c.is_alphanumeric(), \"Character {} is not alphanumeric\", c);\n        }\n    }\n}\n```",
    "global_rng::bool": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::global_rng;\n\n    #[test]\n    fn test_random_bool() {\n        let result = global_rng::bool();\n        assert!(result == true || result == false);\n    }\n}\n```",
    "global_rng::char": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    fn test_char_valid_range() {\n        let result = global_rng::char(b'a'..=b'z');\n        assert!(result >= 'a' && result <= 'z');\n    }\n\n    #[test]\n    fn test_char_valid_range_upper() {\n        let result = global_rng::char(b'A'..=b'Z');\n        assert!(result >= 'A' && result <= 'Z');\n    }\n\n    #[test]\n    fn test_char_valid_range_numbers() {\n        let result = global_rng::char(b'0'..=b'9');\n        assert!(result >= '0' && result <= '9');\n    }\n\n    #[should_panic]\n    #[test]\n    fn test_char_empty_range() {\n        global_rng::char(b'z'..=b'a'); // This should panic\n    }\n}\n```",
    "global_rng::choice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    fn test_choice_with_non_empty_iterator() {\n        let items = vec![1, 2, 3, 4, 5];\n        let result = global_rng::choice(items.iter());\n        assert!(result.is_some());\n        let val = result.unwrap();\n        assert!(items.contains(val));\n    }\n\n    #[test]\n    fn test_choice_with_empty_iterator() {\n        let items: Vec<i32> = Vec::new();\n        let result = global_rng::choice(items.iter());\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_choice_with_single_item() {\n        let items = vec![42];\n        let result = global_rng::choice(items.iter());\n        assert_eq!(result, Some(&42));\n    }\n\n    #[test]\n    fn test_choice_with_large_iterator() {\n        let items: Vec<i32> = (1..=1000).collect();\n        let result = global_rng::choice(items.iter());\n        assert!(result.is_some());\n        let val = result.unwrap();\n        assert!(items.contains(val));\n    }\n\n    #[test]\n    fn test_choice_with_repeated_items() {\n        let items = vec![1, 1, 1, 1, 1];\n        let result = global_rng::choice(items.iter());\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), &1);\n    }\n}\n```",
    "global_rng::choose_multiple": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    fn test_choose_multiple() {\n        let items = vec![1, 2, 3, 4, 5];\n        let amount = 3;\n\n        let result = choose_multiple(&items, amount);\n        \n        // Check that result contains exactly 'amount' items\n        assert_eq!(result.len(), amount);\n        \n        // Check that all selected items are from the source\n        for &item in &result {\n            assert!(items.contains(&item));\n        }\n\n        // Check that result may vary since it's random\n        let result2 = choose_multiple(&items, amount);\n        assert!(result != result2);\n    }\n\n    #[test]\n    fn test_choose_multiple_zero_amount() {\n        let items = vec![1, 2, 3, 4, 5];\n        let amount = 0;\n\n        let result = choose_multiple(&items, amount);\n        \n        // Check that result is an empty vector\n        assert!(result.is_empty());\n    }\n\n    #[test]\n    fn test_choose_multiple_more_than_items() {\n        let items = vec![1, 2];\n        let amount = 5;\n\n        let result = choose_multiple(&items, amount);\n        \n        // Check that result contains at most the number of available items\n        assert_eq!(result.len(), items.len());\n    }\n}\n```",
    "global_rng::digit": "```rust\n#[cfg(test)]\nmod tests {\n    use super::global_rng::digit;\n\n    #[test]\n    #[should_panic]\n    fn test_digit_zero_base() {\n        digit(0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_digit_above_max_base() {\n        digit(37);\n    }\n\n    #[test]\n    fn test_digit_valid_bases() {\n        for base in 2..=36 {\n            let result = digit(base);\n            assert!(result.is_digit(base) || (result.is_ascii_alphabetic() && result.to_digit(36).unwrap() < base));\n        }\n    }\n}\n```",
    "global_rng::f32": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import the function to be tested\n    use fastrand; // Import the fastrand crate to use the RNG\n\n    #[test]\n    fn test_f32() {\n        let random_value = f32(); // Call the function\n        assert!(random_value >= 0.0 && random_value < 1.0, \"f32() should return a value in the range [0, 1)\");\n    }\n}\n```",
    "global_rng::f64": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand;\n\n    #[test]\n    fn test_f64_range() {\n        let value = f64();\n        assert!(value >= 0.0 && value < 1.0, \"Value is out of range 0..1: {}\", value);\n    }\n}\n```",
    "global_rng::fill": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand;\n\n    #[test]\n    fn test_fill() {\n        let mut buffer = [0u8; 16]; // 16 bytes buffer\n        fill(&mut buffer);\n        \n        // Check that the buffer is filled with random bytes\n        // It should not be empty\n        assert_ne!(buffer, [0u8; 16]);\n\n        // Check that the bytes are not all the same\n        let all_same = buffer.windows(2).all(|w| w[0] == w[1]);\n        assert!(!all_same);\n    }\n}\n```",
    "global_rng::get_seed": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::global_rng;\n\n    #[test]\n    fn test_get_seed() {\n        let seed = global_rng::get_seed();\n        assert!(seed > 0, \"Seed should be greater than 0\");\n    }\n}\n```",
    "global_rng::i128": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    #[should_panic]\n    fn test_i128_empty_range() {\n        let range = 1..1; // empty range\n        global_rng::i128(range);\n    }\n\n    #[test]\n    fn test_i128_valid_range() {\n        let range = 1..100; // valid range\n        let result = global_rng::i128(range);\n        assert!(result >= 1 && result < 100);\n    }\n\n    #[test]\n    fn test_i128_negative_range() {\n        let range = -100..-1; // valid negative range\n        let result = global_rng::i128(range);\n        assert!(result >= -100 && result < -1);\n    }\n\n    #[test]\n    fn test_i128_large_range() {\n        let range = i128::MIN..i128::MAX; // large range\n        let result = global_rng::i128(range);\n        assert!(result >= i128::MIN && result < i128::MAX);\n    }\n}\n```",
    "global_rng::i16": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    #[should_panic]\n    fn test_i16_empty_range() {\n        let range = 10..10; // Empty range\n        global_rng::i16(range);\n    }\n\n    #[test]\n    fn test_i16_valid_range() {\n        let range = 1..5; // Valid range\n        let value = global_rng::i16(range);\n        assert!(value >= 1 && value < 5);\n    }\n\n    #[test]\n    fn test_i16_negative_range() {\n        let range = -10..-5; // Valid negative range\n        let value = global_rng::i16(range);\n        assert!(value >= -10 && value < -5);\n    }\n\n    #[test]\n    fn test_i16_mixed_range() {\n        let range = -5..5; // Mixed negative and positive range\n        let value = global_rng::i16(range);\n        assert!(value >= -5 && value < 5);\n    }\n}\n```",
    "global_rng::i32": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    fn test_global_rng_i32() {\n        let range = 1..10;\n        let num = global_rng::i32(range);\n        assert!(range.contains(&num));\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_global_rng_i32_empty_range() {\n        let range = 10..10; // Empty range\n        global_rng::i32(range);\n    }\n}\n```",
    "global_rng::i64": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    fn test_i64_with_valid_range() {\n        let result = global_rng::i64(1..10);\n        assert!(result >= 1 && result < 10);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_i64_with_empty_range() {\n        let _ = global_rng::i64(10..10);\n    }\n    \n    #[test]\n    fn test_i64_with_negative_range() {\n        let result = global_rng::i64(-10..0);\n        assert!(result >= -10 && result < 0);\n    }\n\n    #[test]\n    fn test_i64_with_large_range() {\n        let result = global_rng::i64(-1_000_000..1_000_000);\n        assert!(result >= -1_000_000 && result < 1_000_000);\n    }\n}\n```",
    "global_rng::i8": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    #[should_panic]\n    fn test_i8_panic_empty_range() {\n        let range = 0..0; // empty range\n        global_rng::i8(range);\n    }\n\n    #[test]\n    fn test_i8_valid_range() {\n        let range = -10..10; // valid range\n        let value = global_rng::i8(range);\n        assert!(value >= -10 && value < 10);\n    }\n\n    #[test]\n    fn test_i8_single_value_range() {\n        let range = 5..6; // range containing a single value\n        let value = global_rng::i8(range);\n        assert_eq!(value, 5);\n    }\n}\n```",
    "global_rng::isize": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    #[should_panic(expected = \"range is empty\")]\n    fn test_isize_panic_empty_range() {\n        global_rng::isize(0..0);\n    }\n\n    #[test]\n    fn test_isize_non_empty_range() {\n        let result = global_rng::isize(1..10);\n        assert!(result >= 1 && result < 10);\n    }\n\n    #[test]\n    fn test_isize_negative_range() {\n        let result = global_rng::isize(-10..0);\n        assert!(result >= -10 && result < 0);\n    }\n\n    #[test]\n    fn test_isize_large_range() {\n        let result = global_rng::isize(-1_000_000..1_000_000);\n        assert!(result >= -1_000_000 && result < 1_000_000);\n    }\n}\n```",
    "global_rng::lowercase": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::global_rng::lowercase;\n\n    #[test]\n    fn test_lowercase() {\n        let c = lowercase();\n        assert!(c.is_ascii_lowercase(), \"Expected a lowercase ASCII character\");\n        assert!(c >= 'a' && c <= 'z', \"Expected character to be in the range a-z\");\n    }\n}\n```",
    "global_rng::random_seed": "```rust\n#[cfg(test)]\nmod tests {\n    use super::random_seed;\n\n    #[test]\n    fn test_random_seed() {\n        let seed = random_seed();\n        assert!(seed.is_some(), \"random_seed should return Some value\");\n        let seed_value = seed.unwrap();\n        assert!(seed_value > 0, \"random_seed should return a positive value\");\n    }\n}\n```",
    "global_rng::seed": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng; // Adjust the import based on your project structure\n\n    #[test]\n    fn test_seed() {\n        let seed_value: u64 = 12345; // Example seed\n        global_rng::seed(seed_value);\n        // You may want to verify if the random number generator is behaving as expected\n        // after seeding. This could involve inspecting the generator's output.\n        // Example: let result = global_rng::u64(); // Get a value after seeding\n        // assert_eq!(result, expected_value); // Compare with expected output\n    }\n}\n```",
    "global_rng::shuffle": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::self as rng;\n\n    #[test]\n    fn test_shuffle() {\n        let mut arr = [1, 2, 3, 4, 5];\n        let original = arr.clone();\n        shuffle(&mut arr);\n        assert_ne!(arr, original);\n        assert!(arr.iter().all(|&x| original.contains(&x)));\n    }\n\n    #[test]\n    fn test_shuffle_empty() {\n        let mut arr: [i32; 0] = [];\n        let original = arr.to_vec();\n        shuffle(&mut arr);\n        assert_eq!(arr, original);\n    }\n\n    #[test]\n    fn test_shuffle_single_element() {\n        let mut arr = [42];\n        let original = arr.clone();\n        shuffle(&mut arr);\n        assert_eq!(arr, original);\n    }\n\n    #[test]\n    fn test_shuffle_large_array() {\n        let mut arr: Vec<i32> = (1..=100).collect();\n        let original = arr.clone();\n        shuffle(&mut arr);\n        assert_ne!(arr, original);\n        assert!(arr.iter().all(|&x| original.contains(&x)));\n    }\n}\n```",
    "global_rng::try_with_rng": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::Rng; // Adjust the import path as necessary\n    use std::thread;\n\n    #[test]\n    fn test_try_with_rng_success() {\n        let result = try_with_rng(|rng| {\n            rng.rand() // Assuming `rand()` is a method on `Rng`\n        });\n\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_with_rng_access_error() {\n        // Simulate a scenario where accessing the RNG results in an AccessError\n        let result = thread::spawn(|| {\n            try_with_rng(|rng| rng.rand())\n        }).join().unwrap();\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_try_with_rng_operation() {\n        let result = try_with_rng(|rng| {\n            let random_value = rng.rand(); // Assuming a method that generates a random number\n            random_value\n        });\n\n        assert!(result.is_ok());\n        let random_value = result.unwrap();\n        assert!(random_value >= 0); // Assuming the random value is non-negative\n    }\n}\n```",
    "global_rng::u128": "```rust\n#[cfg(test)]\nmod tests {\n    use fastrand::global_rng;\n\n    #[test]\n    fn test_u128_valid_range() {\n        let result = global_rng::u128(10..20);\n        assert!(result >= 10 && result < 20);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_u128_empty_range() {\n        global_rng::u128(20..20);\n    }\n\n    #[test]\n    fn test_u128_large_range() {\n        let result = global_rng::u128(0..u128::MAX);\n        assert!(result >= 0 && result < u128::MAX);\n    }\n\n    #[test]\n    fn test_u128_edge_case() {\n        let result = global_rng::u128(5..5);\n        assert!(result >= 5 && result < 5);\n    }\n}\n```",
    "global_rng::u16": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    #[should_panic]\n    fn test_u16_panics_on_empty_range() {\n        let range = 0..0; // Empty range\n        let _result = global_rng::u16(range);\n    }\n\n    #[test]\n    fn test_u16_with_valid_range() {\n        let range = 1..10; // Valid range\n        let result = global_rng::u16(range);\n        assert!(result >= 1 && result < 10);\n    }\n\n    #[test]\n    fn test_u16_with_range_inclusive() {\n        let range = 0..=5; // Inclusive range\n        let result = global_rng::u16(range);\n        assert!(result >= 0 && result <= 5);\n    }\n}\n```",
    "global_rng::u32": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    fn test_global_rng_u32_valid_range() {\n        let range = 0..100;\n        let result = global_rng::u32(range);\n        assert!(result >= range.start && result < range.end);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_global_rng_u32_empty_range() {\n        let range = 10..10; // Empty range\n        global_rng::u32(range); // This should panic\n    }\n\n    #[test]\n    fn test_global_rng_u32_large_range() {\n        let range = 0..u32::MAX;\n        let result = global_rng::u32(range);\n        assert!(result >= range.start && result < range.end);\n    }\n}\n```",
    "global_rng::u64": "```rust\n#[cfg(test)]\nmod tests {\n    use crate::global_rng;\n\n    #[test]\n    #[should_panic(expected = \"range is empty\")]\n    fn test_u64_panic_empty_range() {\n        let _ = global_rng::u64(0..0);\n    }\n\n    #[test]\n    fn test_u64_valid_range() {\n        let result = global_rng::u64(1..10);\n        assert!(result >= 1 && result < 10);\n    }\n\n    #[test]\n    fn test_u64_large_range() {\n        let result = global_rng::u64(1..u64::MAX);\n        assert!(result >= 1);\n    }\n}\n```",
    "global_rng::u8": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    fn test_u8_range() {\n        let value = global_rng::u8(0..10);\n        assert!(value >= 0 && value < 10);\n    }\n\n    #[test]\n    fn test_u8_empty_range() {\n        let result = std::panic::catch_unwind(|| {\n            global_rng::u8(10..10);\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_u8_full_range() {\n        let value = global_rng::u8(0..=255);\n        assert!(value <= 255);\n    }\n}\n```",
    "global_rng::uppercase": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    fn test_uppercase_generates_valid_character() {\n        let generated_char = global_rng::uppercase();\n        assert!(generated_char.is_ascii_uppercase(), \"The generated character should be an uppercase ASCII letter.\");\n        assert!(('A'..='Z').contains(&generated_char), \"The generated character should be between 'A' and 'Z'.\");\n    }\n}\n```",
    "global_rng::usize": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::global_rng;\n\n    #[test]\n    #[should_panic]\n    fn test_usize_panics_on_empty_range() {\n        let _ = global_rng::usize(1..1); // This should panic due to empty range\n    }\n\n    #[test]\n    fn test_usize_with_valid_range() {\n        let result = global_rng::usize(1..10);\n        assert!(result >= 1 && result < 10);\n    }\n\n    #[test]\n    fn test_usize_with_large_range() {\n        let result = global_rng::usize(100..1000);\n        assert!(result >= 100 && result < 1000);\n    }\n\n    #[test]\n    fn test_usize_with_edge_case() {\n        let result = global_rng::usize(0..1);\n        assert_eq!(result, 0);\n    }\n}\n```",
    "global_rng::with_rng": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastrand::Rng;\n\n    struct RestoreOnDrop {\n        // Assuming RestoreOnDrop is defined similarly to this\n        rng: std::cell::RefCell<Rng>,\n        current: Rng,\n    }\n\n    impl Drop for RestoreOnDrop {\n        fn drop(&mut self) {\n            self.rng.replace(self.current);\n        }\n    }\n\n    #[test]\n    fn test_with_rng() {\n        let result = with_rng(|rng| {\n            rng.random::<u32>()\n        });\n\n        assert!(result <= u32::MAX);\n    }\n\n    #[test]\n    fn test_with_rng_multiple_calls() {\n        let first_result = with_rng(|rng| {\n            rng.random::<u32>()\n        });\n\n        let second_result = with_rng(|rng| {\n            rng.random::<u32>()\n        });\n\n        assert!(first_result <= u32::MAX);\n        assert!(second_result <= u32::MAX);\n        assert_ne!(first_result, second_result);\n    }\n}\n```",
    "mul_high_u128": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_mul_high_u128() {\n        assert_eq!(mul_high_u128(1, 1), 0);\n        assert_eq!(mul_high_u128(1 << 64, 1 << 64), 1);\n        assert_eq!(mul_high_u128(0, 0), 0);\n        assert_eq!(mul_high_u128(0, 1 << 128), 0);\n        assert_eq!(mul_high_u128(u128::MAX, u128::MAX), u128::MAX - 1);\n        assert_eq!(mul_high_u128(2, 3), 0);\n        assert_eq!(mul_high_u128(2 << 64, 3 << 64), 6);\n        assert_eq!(mul_high_u128(u128::MAX - 1, u128::MAX - 1), u128::MAX - 1);\n    }\n}\n```",
    "mul_high_u32": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_mul_high_u32() {\n        assert_eq!(mul_high_u32(0xFFFFFFFF, 0xFFFFFFFF), 0xFFFFFFFF);\n        assert_eq!(mul_high_u32(1, 1), 0);\n        assert_eq!(mul_high_u32(0x00000001, 0x00000002), 0);\n        assert_eq!(mul_high_u32(0x00000002, 0x00000002), 0);\n        assert_eq!(mul_high_u32(0x00000001, 0x00000003), 0);\n        assert_eq!(mul_high_u32(0x00000003, 0x00000003), 0);\n        assert_eq!(mul_high_u32(0x80000000, 0x80000000), 0x40000000);\n        assert_eq!(mul_high_u32(0xFFFFFFFF, 0x1), 0);\n    }\n}\n```",
    "mul_high_u64": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_mul_high_u64() {\n        assert_eq!(mul_high_u64(0, 0), 0);\n        assert_eq!(mul_high_u64(1, 0), 0);\n        assert_eq!(mul_high_u64(0, 1), 0);\n        assert_eq!(mul_high_u64(1, 1), 0);\n        assert_eq!(mul_high_u64(1, 2), 0);\n        assert_eq!(mul_high_u64(2, 1), 0);\n        assert_eq!(mul_high_u64(0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF), 0xFFFFFFFFFFFFFFFF);\n        assert_eq!(mul_high_u64(0x0000000000000001, 0x0000000000000001), 0);\n        assert_eq!(mul_high_u64(0x0000000000000001, 0x0000000000000002), 0);\n        assert_eq!(mul_high_u64(0x0000000000000002, 0x0000000000000002), 0);\n    }\n}\n```"
}