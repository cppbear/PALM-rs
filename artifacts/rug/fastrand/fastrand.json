{
    "dependencies": {
        "<Rng as core::clone::Clone>::clone": [
            "Rng"
        ],
        "<Rng as core::cmp::Eq>::assert_receiver_is_total_eq": [
            "Rng"
        ],
        "<Rng as core::cmp::PartialEq>::eq": [
            "Rng"
        ],
        "<Rng as core::fmt::Debug>::fmt": [
            "Rng",
            "core::fmt::Formatter",
            "core::marker::Sized",
            "core::result::Result"
        ],
        "<global_rng::RestoreOnDrop<'_> as core::ops::Drop>::drop": [
            "Rng",
            "core::cell::Cell",
            "global_rng::RestoreOnDrop"
        ],
        "Rng": [
            "Rng"
        ],
        "Rng::alphabetic": [
            "Rng"
        ],
        "Rng::alphanumeric": [
            "Rng"
        ],
        "Rng::bool": [
            "Rng"
        ],
        "Rng::char": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::choice": [
            "Rng",
            "core::iter::ExactSizeIterator",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "core::option::Option"
        ],
        "Rng::choose_multiple": [
            "Rng",
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::IntoIterator",
            "core::marker::Sized"
        ],
        "Rng::digit": [
            "Rng"
        ],
        "Rng::f32": [
            "Rng"
        ],
        "Rng::f64": [
            "Rng"
        ],
        "Rng::fill": [
            "Rng"
        ],
        "Rng::fork": [
            "Rng"
        ],
        "Rng::gen_mod_u128": [
            "Rng"
        ],
        "Rng::gen_mod_u32": [
            "Rng"
        ],
        "Rng::gen_mod_u64": [
            "Rng"
        ],
        "Rng::gen_u128": [
            "Rng"
        ],
        "Rng::gen_u32": [
            "Rng"
        ],
        "Rng::gen_u64": [
            "Rng"
        ],
        "Rng::get_seed": [
            "Rng"
        ],
        "Rng::i128": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::i16": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::i32": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::i64": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::i8": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::isize": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::lowercase": [
            "Rng"
        ],
        "Rng::seed": [
            "Rng"
        ],
        "Rng::shuffle": [
            "Rng",
            "core::marker::Sized"
        ],
        "Rng::u128": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::u16": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::u32": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::u64": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::u8": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::uppercase": [
            "Rng"
        ],
        "Rng::usize": [
            "Rng",
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "Rng::with_seed": [
            "Rng"
        ],
        "global_rng::<impl Rng>::new": [
            "Rng"
        ],
        "global_rng::<impl core::default::Default for Rng>::default": [
            "Rng"
        ],
        "global_rng::RNG::__init": [
            "core::cell::Cell"
        ],
        "global_rng::RestoreOnDrop": [
            "Rng",
            "core::cell::Cell",
            "global_rng::RestoreOnDrop"
        ],
        "global_rng::alphabetic": [],
        "global_rng::alphanumeric": [],
        "global_rng::bool": [],
        "global_rng::char": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::choice": [
            "core::iter::ExactSizeIterator",
            "core::iter::IntoIterator",
            "core::marker::Sized",
            "core::option::Option"
        ],
        "global_rng::choose_multiple": [
            "alloc::vec::Vec",
            "core::alloc::Allocator",
            "core::iter::IntoIterator",
            "core::marker::Sized"
        ],
        "global_rng::digit": [],
        "global_rng::f32": [],
        "global_rng::f64": [],
        "global_rng::fill": [],
        "global_rng::get_seed": [],
        "global_rng::i128": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::i16": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::i32": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::i64": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::i8": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::isize": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::lowercase": [],
        "global_rng::random_seed": [
            "core::marker::Sized",
            "core::option::Option"
        ],
        "global_rng::seed": [],
        "global_rng::shuffle": [
            "core::marker::Sized"
        ],
        "global_rng::try_with_rng": [
            "core::marker::Sized",
            "core::ops::FnOnce",
            "core::result::Result"
        ],
        "global_rng::u128": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::u16": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::u32": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::u64": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::u8": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::uppercase": [],
        "global_rng::usize": [
            "core::marker::Sized",
            "core::ops::RangeBounds"
        ],
        "global_rng::with_rng": [
            "core::marker::Sized",
            "core::ops::FnOnce"
        ],
        "mul_high_u128": [],
        "mul_high_u32": [],
        "mul_high_u64": []
    },
    "glob_path_import": {
        "global_rng": ""
    },
    "self_to_fn": {
        "Rng": [
            "Debug",
            "Eq",
            "PartialEq",
            "impl Clone for Rng {\n    /// Clones the generator by creating a new generator with the same seed.\n    fn clone(&self) -> Rng {\n        Rng::with_seed(self.0)\n    }\n}",
            "impl Default for Rng {\n    /// Initialize the `Rng` from the system's random number generator.\n    ///\n    /// This is equivalent to [`Rng::new()`].\n    #[inline]\n    fn default() -> Rng {\n        Rng::new()\n    }\n}",
            "impl Rng {\n    /// Creates a new random number generator with the initial seed.\n    #[inline]\n    #[must_use = \"this creates a new instance of `Rng`; if you want to initialize the thread-local generator, use `fastrand::seed()` instead\"]\n    pub fn with_seed(seed: u64) -> Self {\n        Rng(seed)\n    }\n\n    /// Clones the generator by deterministically deriving a new generator based on the initial\n    /// seed.\n    ///\n    /// This function can be used to create a new generator that is a \"spinoff\" of the old\n    /// generator. The new generator will not produce the same sequence of values as the\n    /// old generator.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// // Seed two generators equally, and clone both of them.\n    /// let mut base1 = fastrand::Rng::with_seed(0x4d595df4d0f33173);\n    /// base1.bool(); // Use the generator once.\n    ///\n    /// let mut base2 = fastrand::Rng::with_seed(0x4d595df4d0f33173);\n    /// base2.bool(); // Use the generator once.\n    ///\n    /// let mut rng1 = base1.fork();\n    /// let mut rng2 = base2.fork();\n    ///\n    /// println!(\"rng1 returns {}\", rng1.u32(..));\n    /// println!(\"rng2 returns {}\", rng2.u32(..));\n    /// ```\n    #[inline]\n    #[must_use = \"this creates a new instance of `Rng`\"]\n    pub fn fork(&mut self) -> Self {\n        Rng::with_seed(self.gen_u64())\n    }\n\n    /// Generates a random `char` in ranges a-z and A-Z.\n    #[inline]\n    pub fn alphabetic(&mut self) -> char {\n        const CHARS: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n        *self.choice(CHARS).unwrap() as char\n    }\n\n    /// Generates a random `char` in ranges a-z, A-Z and 0-9.\n    #[inline]\n    pub fn alphanumeric(&mut self) -> char {\n        const CHARS: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        *self.choice(CHARS).unwrap() as char\n    }\n\n    /// Generates a random `bool`.\n    #[inline]\n    pub fn bool(&mut self) -> bool {\n        self.u8(..) % 2 == 0\n    }\n\n    /// Generates a random digit in the given `base`.\n    ///\n    /// Digits are represented by `char`s in ranges 0-9 and a-z.\n    ///\n    /// Panics if the base is zero or greater than 36.\n    #[inline]\n    pub fn digit(&mut self, base: u32) -> char {\n        if base == 0 {\n            panic!(\"base cannot be zero\");\n        }\n        if base > 36 {\n            panic!(\"base cannot be larger than 36\");\n        }\n        let num = self.u8(..base as u8);\n        if num < 10 {\n            (b'0' + num) as char\n        } else {\n            (b'a' + num - 10) as char\n        }\n    }\n\n    /// Generates a random `f32` in range `0..1`.\n    pub fn f32(&mut self) -> f32 {\n        let b = 32;\n        let f = core::f32::MANTISSA_DIGITS - 1;\n        f32::from_bits((1 << (b - 2)) - (1 << f) + (self.u32(..) >> (b - f))) - 1.0\n    }\n\n    /// Generates a random `f64` in range `0..1`.\n    pub fn f64(&mut self) -> f64 {\n        let b = 64;\n        let f = core::f64::MANTISSA_DIGITS - 1;\n        f64::from_bits((1 << (b - 2)) - (1 << f) + (self.u64(..) >> (b - f))) - 1.0\n    }\n\n    /// Collects `amount` values at random from the iterable into a vector.\n    ///\n    /// The length of the returned vector equals `amount` unless the iterable\n    /// contains insufficient elements, in which case it equals the number of\n    /// elements available.\n    ///\n    /// Complexity is `O(n)` where `n` is the length of the iterable.\n    #[cfg(feature = \"alloc\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"alloc\")))]\n    pub fn choose_multiple<I: IntoIterator>(&mut self, source: I, amount: usize) -> Vec<I::Item> {\n        // Adapted from: https://docs.rs/rand/latest/rand/seq/trait.IteratorRandom.html#method.choose_multiple\n        let mut reservoir = Vec::with_capacity(amount);\n        let mut iter = source.into_iter();\n\n        reservoir.extend(iter.by_ref().take(amount));\n\n        // Continue unless the iterator was exhausted\n        //\n        // note: this prevents iterators that \"restart\" from causing problems.\n        // If the iterator stops once, then so do we.\n        if reservoir.len() == amount {\n            for (i, elem) in iter.enumerate() {\n                let end = i + 1 + amount;\n                let k = self.usize(0..end);\n                if let Some(slot) = reservoir.get_mut(k) {\n                    *slot = elem;\n                }\n            }\n        } else {\n            // If less than one third of the `Vec` was used, reallocate\n            // so that the unused space is not wasted. There is a corner\n            // case where `amount` was much less than `self.len()`.\n            if reservoir.capacity() > 3 * reservoir.len() {\n                reservoir.shrink_to_fit();\n            }\n        }\n        reservoir\n    }\n\n    rng_integer!(\n        i8,\n        u8,\n        gen_u32,\n        gen_mod_u32,\n        \"Generates a random `i8` in the given range.\"\n    );\n\n    rng_integer!(\n        i16,\n        u16,\n        gen_u32,\n        gen_mod_u32,\n        \"Generates a random `i16` in the given range.\"\n    );\n\n    rng_integer!(\n        i32,\n        u32,\n        gen_u32,\n        gen_mod_u32,\n        \"Generates a random `i32` in the given range.\"\n    );\n\n    rng_integer!(\n        i64,\n        u64,\n        gen_u64,\n        gen_mod_u64,\n        \"Generates a random `i64` in the given range.\"\n    );\n\n    rng_integer!(\n        i128,\n        u128,\n        gen_u128,\n        gen_mod_u128,\n        \"Generates a random `i128` in the given range.\"\n    );\n\n    #[cfg(target_pointer_width = \"16\")]\n    rng_integer!(\n        isize,\n        usize,\n        gen_u32,\n        gen_mod_u32,\n        \"Generates a random `isize` in the given range.\"\n    );\n    #[cfg(target_pointer_width = \"32\")]\n    rng_integer!(\n        isize,\n        usize,\n        gen_u32,\n        gen_mod_u32,\n        \"Generates a random `isize` in the given range.\"\n    );\n    #[cfg(target_pointer_width = \"64\")]\n    rng_integer!(\n        isize,\n        usize,\n        gen_u64,\n        gen_mod_u64,\n        \"Generates a random `isize` in the given range.\"\n    );\n\n    /// Generates a random `char` in range a-z.\n    #[inline]\n    pub fn lowercase(&mut self) -> char {\n        const CHARS: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";\n        *self.choice(CHARS).unwrap() as char\n    }\n\n    /// Initializes this generator with the given seed.\n    #[inline]\n    pub fn seed(&mut self, seed: u64) {\n        self.0 = seed;\n    }\n\n    /// Gives back **current** seed that is being held by this generator.\n    #[inline]\n    pub fn get_seed(&self) -> u64 {\n        self.0\n    }\n\n    /// Choose an item from an iterator at random.\n    ///\n    /// This function may have an unexpected result if the `len()` property of the\n    /// iterator does not match the actual number of items in the iterator. If\n    /// the iterator is empty, this returns `None`.\n    #[inline]\n    pub fn choice<I>(&mut self, iter: I) -> Option<I::Item>\n    where\n        I: IntoIterator,\n        I::IntoIter: ExactSizeIterator,\n    {\n        let mut iter = iter.into_iter();\n\n        // Get the item at a random index.\n        let len = iter.len();\n        if len == 0 {\n            return None;\n        }\n        let index = self.usize(0..len);\n\n        iter.nth(index)\n    }\n\n    /// Shuffles a slice randomly.\n    #[inline]\n    pub fn shuffle<T>(&mut self, slice: &mut [T]) {\n        for i in 1..slice.len() {\n            slice.swap(i, self.usize(..=i));\n        }\n    }\n\n    /// Fill a byte slice with random data.\n    #[inline]\n    pub fn fill(&mut self, slice: &mut [u8]) {\n        // We fill the slice by chunks of 8 bytes, or one block of\n        // WyRand output per new state.\n        let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());\n        for chunk in chunks.by_ref() {\n            let n = self.gen_u64().to_ne_bytes();\n            // Safe because the chunks are always 8 bytes exactly.\n            chunk.copy_from_slice(&n);\n        }\n\n        let remainder = chunks.into_remainder();\n\n        // Any remainder will always be less than 8 bytes.\n        if !remainder.is_empty() {\n            // Generate one last block of 8 bytes of entropy\n            let n = self.gen_u64().to_ne_bytes();\n\n            // Use the remaining length to copy from block\n            remainder.copy_from_slice(&n[..remainder.len()]);\n        }\n    }\n\n    rng_integer!(\n        u8,\n        u8,\n        gen_u32,\n        gen_mod_u32,\n        \"Generates a random `u8` in the given range.\"\n    );\n\n    rng_integer!(\n        u16,\n        u16,\n        gen_u32,\n        gen_mod_u32,\n        \"Generates a random `u16` in the given range.\"\n    );\n\n    rng_integer!(\n        u32,\n        u32,\n        gen_u32,\n        gen_mod_u32,\n        \"Generates a random `u32` in the given range.\"\n    );\n\n    rng_integer!(\n        u64,\n        u64,\n        gen_u64,\n        gen_mod_u64,\n        \"Generates a random `u64` in the given range.\"\n    );\n\n    rng_integer!(\n        u128,\n        u128,\n        gen_u128,\n        gen_mod_u128,\n        \"Generates a random `u128` in the given range.\"\n    );\n\n    #[cfg(target_pointer_width = \"16\")]\n    rng_integer!(\n        usize,\n        usize,\n        gen_u32,\n        gen_mod_u32,\n        \"Generates a random `usize` in the given range.\"\n    );\n    #[cfg(target_pointer_width = \"32\")]\n    rng_integer!(\n        usize,\n        usize,\n        gen_u32,\n        gen_mod_u32,\n        \"Generates a random `usize` in the given range.\"\n    );\n    #[cfg(target_pointer_width = \"64\")]\n    rng_integer!(\n        usize,\n        usize,\n        gen_u64,\n        gen_mod_u64,\n        \"Generates a random `usize` in the given range.\"\n    );\n\n    /// Generates a random `char` in range A-Z.\n    #[inline]\n    pub fn uppercase(&mut self) -> char {\n        const CHARS: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        *self.choice(CHARS).unwrap() as char\n    }\n\n    /// Generates a random `char` in the given range.\n    ///\n    /// Panics if the range is empty.\n    #[inline]\n    pub fn char(&mut self, range: impl RangeBounds<char>) -> char {\n        let panic_empty_range = || {\n            panic!(\n                \"empty range: {:?}..{:?}\",\n                range.start_bound(),\n                range.end_bound()\n            )\n        };\n\n        let surrogate_start = 0xd800u32;\n        let surrogate_len = 0x800u32;\n\n        let low = match range.start_bound() {\n            Bound::Unbounded => 0u8 as char,\n            Bound::Included(&x) => x,\n            Bound::Excluded(&x) => {\n                let scalar = if x as u32 == surrogate_start - 1 {\n                    surrogate_start + surrogate_len\n                } else {\n                    x as u32 + 1\n                };\n                char::try_from(scalar).unwrap_or_else(|_| panic_empty_range())\n            }\n        };\n\n        let high = match range.end_bound() {\n            Bound::Unbounded => core::char::MAX,\n            Bound::Included(&x) => x,\n            Bound::Excluded(&x) => {\n                let scalar = if x as u32 == surrogate_start + surrogate_len {\n                    surrogate_start - 1\n                } else {\n                    (x as u32).wrapping_sub(1)\n                };\n                char::try_from(scalar).unwrap_or_else(|_| panic_empty_range())\n            }\n        };\n\n        if low > high {\n            panic_empty_range();\n        }\n\n        let gap = if (low as u32) < surrogate_start && (high as u32) >= surrogate_start {\n            surrogate_len\n        } else {\n            0\n        };\n        let range = high as u32 - low as u32 - gap;\n        let mut val = self.u32(0..=range) + low as u32;\n        if val >= surrogate_start {\n            val += gap;\n        }\n        val.try_into().unwrap()\n    }\n}",
            "impl Rng {\n    /// Creates a new random number generator.\n    #[inline]\n    pub fn new() -> Rng {\n        try_with_rng(Rng::fork).unwrap_or_else(|_| Rng::with_seed(0x4d595df4d0f33173))\n    }\n}",
            "impl Rng {\n    /// Generates a random `u32`.\n    #[inline]\n    fn gen_u32(&mut self) -> u32 {\n        self.gen_u64() as u32\n    }\n\n    /// Generates a random `u64`.\n    #[inline]\n    fn gen_u64(&mut self) -> u64 {\n        // Constants for WyRand taken from: https://github.com/wangyi-fudan/wyhash/blob/master/wyhash.h#L151\n        // Updated for the final v4.2 implementation with improved constants for better entropy output.\n        const WY_CONST_0: u64 = 0x2d35_8dcc_aa6c_78a5;\n        const WY_CONST_1: u64 = 0x8bb8_4b93_962e_acc9;\n\n        let s = self.0.wrapping_add(WY_CONST_0);\n        self.0 = s;\n        let t = u128::from(s) * u128::from(s ^ WY_CONST_1);\n        (t as u64) ^ (t >> 64) as u64\n    }\n\n    /// Generates a random `u128`.\n    #[inline]\n    fn gen_u128(&mut self) -> u128 {\n        (u128::from(self.gen_u64()) << 64) | u128::from(self.gen_u64())\n    }\n\n    /// Generates a random `u32` in `0..n`.\n    #[inline]\n    fn gen_mod_u32(&mut self, n: u32) -> u32 {\n        // Adapted from: https://lemire.me/blog/2016/06/30/fast-random-shuffling/\n        let mut r = self.gen_u32();\n        let mut hi = mul_high_u32(r, n);\n        let mut lo = r.wrapping_mul(n);\n        if lo < n {\n            let t = n.wrapping_neg() % n;\n            while lo < t {\n                r = self.gen_u32();\n                hi = mul_high_u32(r, n);\n                lo = r.wrapping_mul(n);\n            }\n        }\n        hi\n    }\n\n    /// Generates a random `u64` in `0..n`.\n    #[inline]\n    fn gen_mod_u64(&mut self, n: u64) -> u64 {\n        // Adapted from: https://lemire.me/blog/2016/06/30/fast-random-shuffling/\n        let mut r = self.gen_u64();\n        let mut hi = mul_high_u64(r, n);\n        let mut lo = r.wrapping_mul(n);\n        if lo < n {\n            let t = n.wrapping_neg() % n;\n            while lo < t {\n                r = self.gen_u64();\n                hi = mul_high_u64(r, n);\n                lo = r.wrapping_mul(n);\n            }\n        }\n        hi\n    }\n\n    /// Generates a random `u128` in `0..n`.\n    #[inline]\n    fn gen_mod_u128(&mut self, n: u128) -> u128 {\n        // Adapted from: https://lemire.me/blog/2016/06/30/fast-random-shuffling/\n        let mut r = self.gen_u128();\n        let mut hi = mul_high_u128(r, n);\n        let mut lo = r.wrapping_mul(n);\n        if lo < n {\n            let t = n.wrapping_neg() % n;\n            while lo < t {\n                r = self.gen_u128();\n                hi = mul_high_u128(r, n);\n                lo = r.wrapping_mul(n);\n            }\n        }\n        hi\n    }\n}"
        ],
        "global_rng::RestoreOnDrop": [
            "impl Drop for RestoreOnDrop<'_> {\n    fn drop(&mut self) {\n        self.rng.set(Rng(self.current.0));\n    }\n}"
        ]
    },
    "single_path_import": {},
    "srcs": {
        "<Rng as core::clone::Clone>::clone": [
            "/// Clones the generator by creating a new generator with the same seed.\nfn clone(&self) -> Rng{\n        Rng::with_seed(self.0)\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "<global_rng::RestoreOnDrop<'_> as core::ops::Drop>::drop": [
            "fn drop(&mut self){\n        self.rng.set(Rng(self.current.0));\n    }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "Rng": [
            "/// A random number generator.\npub struct Rng(u64);",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::alphabetic": [
            "/// Generates a random `char` in ranges a-z and A-Z.\n#[inline]\npub fn alphabetic(&mut self) -> char{\n        const CHARS: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n        *self.choice(CHARS).unwrap() as char\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::alphanumeric": [
            "/// Generates a random `char` in ranges a-z, A-Z and 0-9.\n#[inline]\npub fn alphanumeric(&mut self) -> char{\n        const CHARS: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        *self.choice(CHARS).unwrap() as char\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::bool": [
            "/// Generates a random `bool`.\n#[inline]\npub fn bool(&mut self) -> bool{\n        self.u8(..) % 2 == 0\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::char": [
            "/// Generates a random `char` in the given range.\n///\n/// Panics if the range is empty.\n#[inline]\npub fn char(&mut self, range: impl RangeBounds<char>) -> char{\n        let panic_empty_range = || {\n            panic!(\n                \"empty range: {:?}..{:?}\",\n                range.start_bound(),\n                range.end_bound()\n            )\n        };\n\n        let surrogate_start = 0xd800u32;\n        let surrogate_len = 0x800u32;\n\n        let low = match range.start_bound() {\n            Bound::Unbounded => 0u8 as char,\n            Bound::Included(&x) => x,\n            Bound::Excluded(&x) => {\n                let scalar = if x as u32 == surrogate_start - 1 {\n                    surrogate_start + surrogate_len\n                } else {\n                    x as u32 + 1\n                };\n                char::try_from(scalar).unwrap_or_else(|_| panic_empty_range())\n            }\n        };\n\n        let high = match range.end_bound() {\n            Bound::Unbounded => core::char::MAX,\n            Bound::Included(&x) => x,\n            Bound::Excluded(&x) => {\n                let scalar = if x as u32 == surrogate_start + surrogate_len {\n                    surrogate_start - 1\n                } else {\n                    (x as u32).wrapping_sub(1)\n                };\n                char::try_from(scalar).unwrap_or_else(|_| panic_empty_range())\n            }\n        };\n\n        if low > high {\n            panic_empty_range();\n        }\n\n        let gap = if (low as u32) < surrogate_start && (high as u32) >= surrogate_start {\n            surrogate_len\n        } else {\n            0\n        };\n        let range = high as u32 - low as u32 - gap;\n        let mut val = self.u32(0..=range) + low as u32;\n        if val >= surrogate_start {\n            val += gap;\n        }\n        val.try_into().unwrap()\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::choice": [
            "/// Choose an item from an iterator at random.\n///\n/// This function may have an unexpected result if the `len()` property of the\n/// iterator does not match the actual number of items in the iterator. If\n/// the iterator is empty, this returns `None`.\n#[inline]\npub fn choice<I>(&mut self, iter: I) -> Option<I::Item>\n    where\n        I: IntoIterator,\n        I::IntoIter: ExactSizeIterator,{\n        let mut iter = iter.into_iter();\n\n        // Get the item at a random index.\n        let len = iter.len();\n        if len == 0 {\n            return None;\n        }\n        let index = self.usize(0..len);\n\n        iter.nth(index)\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::choose_multiple": [
            "/// Collects `amount` values at random from the iterable into a vector.\n///\n/// The length of the returned vector equals `amount` unless the iterable\n/// contains insufficient elements, in which case it equals the number of\n/// elements available.\n///\n/// Complexity is `O(n)` where `n` is the length of the iterable.\n#[cfg(feature = \"alloc\")]\npub fn choose_multiple<I: IntoIterator>(&mut self, source: I, amount: usize) -> Vec<I::Item>{\n        // Adapted from: https://docs.rs/rand/latest/rand/seq/trait.IteratorRandom.html#method.choose_multiple\n        let mut reservoir = Vec::with_capacity(amount);\n        let mut iter = source.into_iter();\n\n        reservoir.extend(iter.by_ref().take(amount));\n\n        // Continue unless the iterator was exhausted\n        //\n        // note: this prevents iterators that \"restart\" from causing problems.\n        // If the iterator stops once, then so do we.\n        if reservoir.len() == amount {\n            for (i, elem) in iter.enumerate() {\n                let end = i + 1 + amount;\n                let k = self.usize(0..end);\n                if let Some(slot) = reservoir.get_mut(k) {\n                    *slot = elem;\n                }\n            }\n        } else {\n            // If less than one third of the `Vec` was used, reallocate\n            // so that the unused space is not wasted. There is a corner\n            // case where `amount` was much less than `self.len()`.\n            if reservoir.capacity() > 3 * reservoir.len() {\n                reservoir.shrink_to_fit();\n            }\n        }\n        reservoir\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::digit": [
            "/// Generates a random digit in the given `base`.\n///\n/// Digits are represented by `char`s in ranges 0-9 and a-z.\n///\n/// Panics if the base is zero or greater than 36.\n#[inline]\npub fn digit(&mut self, base: u32) -> char{\n        if base == 0 {\n            panic!(\"base cannot be zero\");\n        }\n        if base > 36 {\n            panic!(\"base cannot be larger than 36\");\n        }\n        let num = self.u8(..base as u8);\n        if num < 10 {\n            (b'0' + num) as char\n        } else {\n            (b'a' + num - 10) as char\n        }\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::f32": [
            "/// Generates a random `f32` in range `0..1`.\npub fn f32(&mut self) -> f32{\n        let b = 32;\n        let f = core::f32::MANTISSA_DIGITS - 1;\n        f32::from_bits((1 << (b - 2)) - (1 << f) + (self.u32(..) >> (b - f))) - 1.0\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::f64": [
            "/// Generates a random `f64` in range `0..1`.\npub fn f64(&mut self) -> f64{\n        let b = 64;\n        let f = core::f64::MANTISSA_DIGITS - 1;\n        f64::from_bits((1 << (b - 2)) - (1 << f) + (self.u64(..) >> (b - f))) - 1.0\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::fill": [
            "/// Fill a byte slice with random data.\n#[inline]\npub fn fill(&mut self, slice: &mut [u8]){\n        // We fill the slice by chunks of 8 bytes, or one block of\n        // WyRand output per new state.\n        let mut chunks = slice.chunks_exact_mut(core::mem::size_of::<u64>());\n        for chunk in chunks.by_ref() {\n            let n = self.gen_u64().to_ne_bytes();\n            // Safe because the chunks are always 8 bytes exactly.\n            chunk.copy_from_slice(&n);\n        }\n\n        let remainder = chunks.into_remainder();\n\n        // Any remainder will always be less than 8 bytes.\n        if !remainder.is_empty() {\n            // Generate one last block of 8 bytes of entropy\n            let n = self.gen_u64().to_ne_bytes();\n\n            // Use the remaining length to copy from block\n            remainder.copy_from_slice(&n[..remainder.len()]);\n        }\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::fork": [
            "/// Clones the generator by deterministically deriving a new generator based on the initial\n/// seed.\n///\n/// This function can be used to create a new generator that is a \"spinoff\" of the old\n/// generator. The new generator will not produce the same sequence of values as the\n/// old generator.\n///\n/// # Example\n///\n/// ```\n/// // Seed two generators equally, and clone both of them.\n/// let mut base1 = fastrand::Rng::with_seed(0x4d595df4d0f33173);\n/// base1.bool(); // Use the generator once.\n///\n/// let mut base2 = fastrand::Rng::with_seed(0x4d595df4d0f33173);\n/// base2.bool(); // Use the generator once.\n///\n/// let mut rng1 = base1.fork();\n/// let mut rng2 = base2.fork();\n///\n/// println!(\"rng1 returns {}\", rng1.u32(..));\n/// println!(\"rng2 returns {}\", rng2.u32(..));\n/// ```\n#[inline]\n#[must_use = \"this creates a new instance of `Rng`\"]\npub fn fork(&mut self) -> Self{\n        Rng::with_seed(self.gen_u64())\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::gen_mod_u128": [
            "/// Generates a random `u128` in `0..n`.\n#[inline]\nfn gen_mod_u128(&mut self, n: u128) -> u128{\n        // Adapted from: https://lemire.me/blog/2016/06/30/fast-random-shuffling/\n        let mut r = self.gen_u128();\n        let mut hi = mul_high_u128(r, n);\n        let mut lo = r.wrapping_mul(n);\n        if lo < n {\n            let t = n.wrapping_neg() % n;\n            while lo < t {\n                r = self.gen_u128();\n                hi = mul_high_u128(r, n);\n                lo = r.wrapping_mul(n);\n            }\n        }\n        hi\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::gen_mod_u32": [
            "/// Generates a random `u32` in `0..n`.\n#[inline]\nfn gen_mod_u32(&mut self, n: u32) -> u32{\n        // Adapted from: https://lemire.me/blog/2016/06/30/fast-random-shuffling/\n        let mut r = self.gen_u32();\n        let mut hi = mul_high_u32(r, n);\n        let mut lo = r.wrapping_mul(n);\n        if lo < n {\n            let t = n.wrapping_neg() % n;\n            while lo < t {\n                r = self.gen_u32();\n                hi = mul_high_u32(r, n);\n                lo = r.wrapping_mul(n);\n            }\n        }\n        hi\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::gen_mod_u64": [
            "/// Generates a random `u64` in `0..n`.\n#[inline]\nfn gen_mod_u64(&mut self, n: u64) -> u64{\n        // Adapted from: https://lemire.me/blog/2016/06/30/fast-random-shuffling/\n        let mut r = self.gen_u64();\n        let mut hi = mul_high_u64(r, n);\n        let mut lo = r.wrapping_mul(n);\n        if lo < n {\n            let t = n.wrapping_neg() % n;\n            while lo < t {\n                r = self.gen_u64();\n                hi = mul_high_u64(r, n);\n                lo = r.wrapping_mul(n);\n            }\n        }\n        hi\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::gen_u128": [
            "/// Generates a random `u128`.\n#[inline]\nfn gen_u128(&mut self) -> u128{\n        (u128::from(self.gen_u64()) << 64) | u128::from(self.gen_u64())\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::gen_u32": [
            "/// Generates a random `u32`.\n#[inline]\nfn gen_u32(&mut self) -> u32{\n        self.gen_u64() as u32\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::gen_u64": [
            "/// Generates a random `u64`.\n#[inline]\nfn gen_u64(&mut self) -> u64{\n        // Constants for WyRand taken from: https://github.com/wangyi-fudan/wyhash/blob/master/wyhash.h#L151\n        // Updated for the final v4.2 implementation with improved constants for better entropy output.\n        const WY_CONST_0: u64 = 0x2d35_8dcc_aa6c_78a5;\n        const WY_CONST_1: u64 = 0x8bb8_4b93_962e_acc9;\n\n        let s = self.0.wrapping_add(WY_CONST_0);\n        self.0 = s;\n        let t = u128::from(s) * u128::from(s ^ WY_CONST_1);\n        (t as u64) ^ (t >> 64) as u64\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::get_seed": [
            "/// Gives back **current** seed that is being held by this generator.\n#[inline]\npub fn get_seed(&self) -> u64{\n        self.0\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::i128": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::i16": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::i32": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::i64": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::i8": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub fn $t(&mut self, range: impl RangeBounds<$t>) -> $t{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::isize": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::lowercase": [
            "/// Generates a random `char` in range a-z.\n#[inline]\npub fn lowercase(&mut self) -> char{\n        const CHARS: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";\n        *self.choice(CHARS).unwrap() as char\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::seed": [
            "/// Initializes this generator with the given seed.\n#[inline]\npub fn seed(&mut self, seed: u64){\n        self.0 = seed;\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::shuffle": [
            "/// Shuffles a slice randomly.\n#[inline]\npub fn shuffle<T>(&mut self, slice: &mut [T]){\n        for i in 1..slice.len() {\n            slice.swap(i, self.usize(..=i));\n        }\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::u128": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::u16": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::u32": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::u64": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::u8": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::uppercase": [
            "/// Generates a random `char` in range A-Z.\n#[inline]\npub fn uppercase(&mut self) -> char{\n        const CHARS: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        *self.choice(CHARS).unwrap() as char\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::usize": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            let panic_empty_range = || {\n                panic!(\n                    \"empty range: {:?}..{:?}\",\n                    range.start_bound(),\n                    range.end_bound()\n                )\n            };\n\n            let low = match range.start_bound() {\n                Bound::Unbounded => core::$t::MIN,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_add(1).unwrap_or_else(panic_empty_range),\n            };\n\n            let high = match range.end_bound() {\n                Bound::Unbounded => core::$t::MAX,\n                Bound::Included(&x) => x,\n                Bound::Excluded(&x) => x.checked_sub(1).unwrap_or_else(panic_empty_range),\n            };\n\n            if low > high {\n                panic_empty_range();\n            }\n\n            if low == core::$t::MIN && high == core::$t::MAX {\n                self.$gen() as $t\n            } else {\n                let len = high.wrapping_sub(low).wrapping_add(1);\n                low.wrapping_add(self.$mod(len as $unsigned_t as _) as $t)\n            }\n        }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "Rng::with_seed": [
            "/// Creates a new random number generator with the initial seed.\n#[inline]\n#[must_use = \"this creates a new instance of `Rng`; if you want to initialize the thread-local generator, use `fastrand::seed()` instead\"]\npub fn with_seed(seed: u64) -> Self{\n        Rng(seed)\n    }",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "global_rng::<impl Rng>::new": [
            "/// Creates a new random number generator.\n#[inline]\npub fn new() -> Rng{\n        try_with_rng(Rng::fork).unwrap_or_else(|_| Rng::with_seed(0x4d595df4d0f33173))\n    }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::<impl core::default::Default for Rng>::default": [
            "/// Initialize the `Rng` from the system's random number generator.\n///\n/// This is equivalent to [`Rng::new()`].\n#[inline]\nfn default() -> Rng{\n        Rng::new()\n    }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::RNG::__init": [
            "#[inline]\nfn __init() -> $t{\n            $init\n        }",
            "Real(Remapped { local_path: Some(\"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/native/mod.rs\"), virtual_name: \"/rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/sys/thread_local/native/mod.rs\" })"
        ],
        "global_rng::RestoreOnDrop": [
            "/// Make sure the original RNG is restored even on panic.\nstruct RestoreOnDrop<'a> {\n    rng: &'a Cell<Rng>,\n    current: Rng,\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::alphabetic": [
            "/// Generates a random `char` in ranges a-z and A-Z.\n#[inline]\npub fn alphabetic() -> char{\n    with_rng(|r| r.alphabetic())\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::alphanumeric": [
            "/// Generates a random `char` in ranges a-z, A-Z and 0-9.\n#[inline]\npub fn alphanumeric() -> char{\n    with_rng(|r| r.alphanumeric())\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::bool": [
            "/// Generates a random `bool`.\n#[inline]\npub fn bool() -> bool{\n    with_rng(|r| r.bool())\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::char": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::choice": [
            "/// Choose an item from an iterator at random.\n///\n/// This function may have an unexpected result if the `len()` property of the\n/// iterator does not match the actual number of items in the iterator. If\n/// the iterator is empty, this returns `None`.\n#[inline]\npub fn choice<I>(iter: I) -> Option<I::Item>\nwhere\n    I: IntoIterator,\n    I::IntoIter: ExactSizeIterator,{\n    with_rng(|r| r.choice(iter))\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::choose_multiple": [
            "/// Collects `amount` values at random from the iterable into a vector.\npub fn choose_multiple<I: IntoIterator>(source: I, amount: usize) -> Vec<I::Item>{\n    with_rng(|rng| rng.choose_multiple(source, amount))\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::digit": [
            "/// Generates a random digit in the given `base`.\n///\n/// Digits are represented by `char`s in ranges 0-9 and a-z.\n///\n/// Panics if the base is zero or greater than 36.\n#[inline]\npub fn digit(base: u32) -> char{\n    with_rng(|r| r.digit(base))\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::f32": [
            "/// Generates a random `f32` in range `0..1`.\npub fn f32() -> f32{\n    with_rng(|r| r.f32())\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::f64": [
            "/// Generates a random `f64` in range `0..1`.\npub fn f64() -> f64{\n    with_rng(|r| r.f64())\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::fill": [
            "/// Fill a byte slice with random data.\n#[inline]\npub fn fill(slice: &mut [u8]){\n    with_rng(|r| r.fill(slice))\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::get_seed": [
            "/// Gives back **current** seed that is being held by the thread-local generator.\n#[inline]\npub fn get_seed() -> u64{\n    with_rng(|r| r.get_seed())\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::i128": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::i16": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::i32": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::i64": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::i8": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::isize": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::lowercase": [
            "/// Generates a random `char` in range a-z.\n#[inline]\npub fn lowercase() -> char{\n    with_rng(|r| r.lowercase())\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::random_seed": [
            "#[cfg(not(all(\n    any(target_arch = \"wasm32\", target_arch = \"wasm64\"),\n    target_os = \"unknown\"\n)))]\nfn random_seed() -> Option<u64>{\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n    use std::thread;\n    use std::time::Instant;\n\n    let mut hasher = DefaultHasher::new();\n    Instant::now().hash(&mut hasher);\n    thread::current().id().hash(&mut hasher);\n    Some(hasher.finish())\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::seed": [
            "/// Initializes the thread-local generator with the given seed.\n#[inline]\npub fn seed(seed: u64){\n    with_rng(|r| r.seed(seed));\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::shuffle": [
            "/// Shuffles a slice randomly.\n#[inline]\npub fn shuffle<T>(slice: &mut [T]){\n    with_rng(|r| r.shuffle(slice))\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::try_with_rng": [
            "/// Try to run an operation with the current thread-local generator.\n#[inline]\nfn try_with_rng<R>(f: impl FnOnce(&mut Rng) -> R) -> Result<R, std::thread::AccessError>{\n    RNG.try_with(|rng| {\n        let current = rng.replace(Rng(0));\n\n        let mut restore = RestoreOnDrop { rng, current };\n\n        f(&mut restore.current)\n    })\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::u128": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::u16": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::u32": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::u64": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::u8": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub fn $t(range: impl RangeBounds<$t>) -> $t{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::uppercase": [
            "/// Generates a random `char` in range A-Z.\n#[inline]\npub fn uppercase() -> char{\n    with_rng(|r| r.uppercase())\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::usize": [
            "#[doc = $doc]\n///\n/// Panics if the range is empty.\n#[inline]\npub{\n            with_rng(|r| r.$t(range))\n        }",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "global_rng::with_rng": [
            "/// Run an operation with the current thread-local generator.\n#[inline]\nfn with_rng<R>(f: impl FnOnce(&mut Rng) -> R) -> R{\n    RNG.with(|rng| {\n        let current = rng.replace(Rng(0));\n\n        let mut restore = RestoreOnDrop { rng, current };\n\n        f(&mut restore.current)\n    })\n}",
            "Real(LocalPath(\"src/global_rng.rs\"))"
        ],
        "mul_high_u128": [
            "/// Computes `(a * b) >> 128`.\n#[inline]\nfn mul_high_u128(a: u128, b: u128) -> u128{\n    // Adapted from: https://stackoverflow.com/a/28904636\n    let a_lo = a as u64 as u128;\n    let a_hi = (a >> 64) as u64 as u128;\n    let b_lo = b as u64 as u128;\n    let b_hi = (b >> 64) as u64 as u128;\n    let carry = (a_lo * b_lo) >> 64;\n    let carry = ((a_hi * b_lo) as u64 as u128 + (a_lo * b_hi) as u64 as u128 + carry) >> 64;\n    a_hi * b_hi + ((a_hi * b_lo) >> 64) + ((a_lo * b_hi) >> 64) + carry\n}",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "mul_high_u32": [
            "/// Computes `(a * b) >> 32`.\n#[inline]\nfn mul_high_u32(a: u32, b: u32) -> u32{\n    (((a as u64) * (b as u64)) >> 32) as u32\n}",
            "Real(LocalPath(\"src/lib.rs\"))"
        ],
        "mul_high_u64": [
            "/// Computes `(a * b) >> 64`.\n#[inline]\nfn mul_high_u64(a: u64, b: u64) -> u64{\n    (((a as u128) * (b as u128)) >> 64) as u64\n}",
            "Real(LocalPath(\"src/lib.rs\"))"
        ]
    },
    "struct_constructor": {
        "Rng": [
            "clone",
            "default",
            "fork",
            "new",
            "with_seed"
        ],
        "alloc::vec::Vec": [
            "choose_multiple"
        ],
        "bool": [
            "bool",
            "eq"
        ],
        "char": [
            "alphabetic",
            "alphanumeric",
            "char",
            "digit",
            "lowercase",
            "uppercase"
        ],
        "core::cell::Cell": [
            "__init"
        ],
        "core::option::Option": [
            "choice",
            "random_seed"
        ],
        "core::result::Result": [
            "fmt",
            "try_with_rng"
        ],
        "f32": [
            "f32"
        ],
        "f64": [
            "f64"
        ],
        "i128": [
            "i128"
        ],
        "i16": [
            "i16"
        ],
        "i32": [
            "i32"
        ],
        "i64": [
            "i64"
        ],
        "i8": [
            "i8"
        ],
        "isize": [
            "isize"
        ],
        "u128": [
            "gen_u128",
            "u128"
        ],
        "u16": [
            "u16"
        ],
        "u32": [
            "gen_u32",
            "u32"
        ],
        "u64": [
            "gen_u64",
            "get_seed",
            "u64"
        ],
        "u8": [
            "u8"
        ],
        "usize": [
            "usize"
        ]
    },
    "struct_to_trait": {
        "Rng": [
            "core::clone::Clone",
            "core::cmp::Eq",
            "core::cmp::PartialEq",
            "core::default::Default",
            "core::fmt::Debug",
            "core::marker::StructuralPartialEq"
        ],
        "global_rng::RestoreOnDrop": [
            "core::ops::Drop"
        ]
    },
    "targets": {
        "<Rng as core::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/lib.rs\"))",
            "core::clone::Clone"
        ],
        "<global_rng::RestoreOnDrop<'_> as core::ops::Drop>::drop": [
            "drop",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            "core::ops::Drop"
        ],
        "Rng::alphabetic": [
            "alphabetic",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::alphanumeric": [
            "alphanumeric",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::bool": [
            "bool",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::char": [
            "char",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::choice": [
            "choice",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::choose_multiple": [
            "choose_multiple",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::digit": [
            "digit",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::f32": [
            "f32",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::f64": [
            "f64",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::fill": [
            "fill",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::fork": [
            "fork",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::gen_mod_u128": [
            "gen_mod_u128",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::gen_mod_u32": [
            "gen_mod_u32",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::gen_mod_u64": [
            "gen_mod_u64",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::gen_u128": [
            "gen_u128",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::gen_u32": [
            "gen_u32",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::gen_u64": [
            "gen_u64",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::get_seed": [
            "get_seed",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::i128": [
            "i128",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::i16": [
            "i16",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::i32": [
            "i32",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::i64": [
            "i64",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::i8": [
            "i8",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::isize": [
            "isize",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::lowercase": [
            "lowercase",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::seed": [
            "seed",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::shuffle": [
            "shuffle",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::u128": [
            "u128",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::u16": [
            "u16",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::u32": [
            "u32",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::u64": [
            "u64",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::u8": [
            "u8",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::uppercase": [
            "uppercase",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::usize": [
            "usize",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "Rng::with_seed": [
            "with_seed",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "global_rng::<impl Rng>::new": [
            "new",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::<impl core::default::Default for Rng>::default": [
            "default",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            "core::default::Default"
        ],
        "global_rng::RNG::__init": [
            "__init",
            "Real(Remapped { local_path: Some(\"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/native/mod.rs\"), virtual_name: \"/rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/sys/thread_local/native/mod.rs\" })",
            ""
        ],
        "global_rng::alphabetic": [
            "alphabetic",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::alphanumeric": [
            "alphanumeric",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::bool": [
            "bool",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::char": [
            "char",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::choice": [
            "choice",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::choose_multiple": [
            "choose_multiple",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::digit": [
            "digit",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::f32": [
            "f32",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::f64": [
            "f64",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::fill": [
            "fill",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::get_seed": [
            "get_seed",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::i128": [
            "i128",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::i16": [
            "i16",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::i32": [
            "i32",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::i64": [
            "i64",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::i8": [
            "i8",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::isize": [
            "isize",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::lowercase": [
            "lowercase",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::random_seed": [
            "random_seed",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::seed": [
            "seed",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::shuffle": [
            "shuffle",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::try_with_rng": [
            "try_with_rng",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::u128": [
            "u128",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::u16": [
            "u16",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::u32": [
            "u32",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::u64": [
            "u64",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::u8": [
            "u8",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::uppercase": [
            "uppercase",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::usize": [
            "usize",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "global_rng::with_rng": [
            "with_rng",
            "Real(LocalPath(\"src/global_rng.rs\"))",
            ""
        ],
        "mul_high_u128": [
            "mul_high_u128",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "mul_high_u32": [
            "mul_high_u32",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ],
        "mul_high_u64": [
            "mul_high_u64",
            "Real(LocalPath(\"src/lib.rs\"))",
            ""
        ]
    },
    "trait_to_struct": {
        "core::clone::Clone": [
            "Rng"
        ],
        "core::cmp::Eq": [
            "Rng"
        ],
        "core::cmp::PartialEq": [
            "Rng"
        ],
        "core::default::Default": [
            "Rng"
        ],
        "core::fmt::Debug": [
            "Rng"
        ],
        "core::marker::StructuralPartialEq": [
            "Rng"
        ],
        "core::ops::Drop": [
            "global_rng::RestoreOnDrop"
        ]
    },
    "type_to_def_path": {
        "Rng": "Rng",
        "global_rng::RestoreOnDrop<'a>": "global_rng::RestoreOnDrop"
    }
}