ChatCompletion(id='chatcmpl-BclZNmVuwuW0OCaUkIhLtfjxyaIkE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let vec: Vec<_> = map.into_iter().collect();\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_into_iter() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        map.insert(3, 300);\n        \n        let mut vec: Vec<_> = map.into_iter().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, vec![(1, 100), (2, 200), (3, 300)]);\n    }\n\n    #[test]\n    fn test_into_iter_random_order() {\n        let mut map = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        map.insert(4, 40);\n\n        let mut vec: Vec<_> = map.into_iter().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, vec![(1, 10), (2, 20), (3, 30), (4, 40)]);\n    }\n\n    #[test]\n    fn test_into_iter_modified_map() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        \n        let mut iter = map.clone().into_iter();\n        assert_eq!(iter.next(), Some(("a", 1)));\n        assert_eq!(iter.next(), Some(("b", 2)));\n        assert_eq!(iter.next(), None);\n        \n        map.insert("c", 3);\n        \n        let mut iter2 = map.into_iter();\n        let mut count = 0;\n        while let Some((_, _)) = iter2.next() {\n            count += 1;\n        }\n        assert_eq!(count, 3);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579021, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=441, prompt_tokens=16361, total_tokens=16802, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZYQIAHxfm2KqiIYIkXp59fYiiM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter() {\n        let mut map: HashMap<_, _> = [("a", 1), ("b", 2), ("c", 3)].into();\n\n        for (key, value) in map.iter_mut() {\n            *value *= 2;\n        }\n\n        let mut vec = map.iter().collect::<Vec<_>>();\n        vec.sort_unstable();\n        assert_eq!(vec, [(&"a", &2), (&"b", &4), (&"c", &6)]);\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        let mut entries = map.iter_mut();\n\n        assert!(entries.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_single_entry() {\n        let mut map = HashMap::new();\n        map.insert("key", 1);\n\n        for (key, value) in map.iter_mut() {\n            assert_eq!(key, &"key");\n            *value += 1;\n        }\n\n        let mut vec = map.iter().collect::<Vec<_>>();\n        vec.sort_unstable();\n        assert_eq!(vec, [(&"key", &2)]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579032, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=285, prompt_tokens=16361, total_tokens=16646, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZgwDyZcxesYEDwu41vSf3PxIlh', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_into_iter() {\n        let mut table: HashTable<i32> = HashTable::default();\n        table.insert(1, 10);\n        table.insert(2, 20);\n        table.insert(3, 30);\n        \n        let iter = table.into_iter();\n        let mut collected: Vec<(i32, i32)> = iter.collect();\n\n        collected.sort_by_key(|(k, _)| *k); // Sort to compare keys\n\n        assert_eq!(collected, vec![(1, 10), (2, 20), (3, 30)]);\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let mut table: HashTable<i32> = HashTable::default();\n        let iter = table.into_iter();\n        let collected: Vec<(i32, i32)>: Vec<(i32, i32)> = iter.collect();\n        assert!(collected.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579040, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=224, prompt_tokens=16361, total_tokens=16585, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZoC6xMgghd05EyVoyRLbmu4IpE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        map.insert(3, 300);\n\n        let mut vec: Vec<(i32, i32)> = map.into_iter().collect();\n        vec.sort_unstable(); // Ensure a stable order for comparison\n\n        assert_eq!(vec.len(), 3);\n        assert!(vec.contains(&(1, 100)));\n        assert!(vec.contains(&(2, 200)));\n        assert!(vec.contains(&(3, 300)));\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let vec: Vec<(i32, i32)>: Vec<(i32, i32)> = map.into_iter().collect();\n\n        assert!(vec.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579048, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=227, prompt_tokens=16361, total_tokens=16588, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclZv1qy7N7G9TAahSir4bzP45WrU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::RawTable;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_into_iter() {\n        let mut table: RawTable<i32> = RawTable::default();\n\n        // Insert some values into the table\n        let hashes = vec![1, 2, 3, 4, 5];\n        for &v in &hashes {\n            unsafe {\n                table.insert(v as u64, v, |v: &i32| *v as u64);\n            }\n        }\n\n        let iter = table.into_iter();\n\n        // Prepare to collect values\n        let collected: Vec<i32> = iter.collect();\n\n        // Check that the collected values match the inserted values\n        assert_eq!(collected.len(), hashes.len());\n        for &v in &hashes {\n            assert!(collected.contains(&v));\n        }\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let table: RawTable<i32> = RawTable::default();\n\n        let iter = table.into_iter();\n\n        // Collect values from the empty iterator\n        let collected: Vec<i32> = iter.collect();\n\n        // Check that the collected values are empty\n        assert!(collected.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579055, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=280, prompt_tokens=16361, total_tokens=16641, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcla36mG2RXtr7ibmM3qjTXLO5SrU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitand() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n\n        let intersected_set = &a & &b;\n\n        let expected: HashSet<_> = vec![2, 3].into_iter().collect();\n        assert_eq!(intersected_set, expected);\n    }\n\n    #[test]\n    fn test_bitand_empty_set() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = HashSet::new();\n\n        let intersected_set = &a & &b;\n\n        assert!(intersected_set.is_empty());\n    }\n\n    #[test]\n    fn test_bitand_no_common_elements() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![4, 5, 6].into_iter().collect();\n\n        let intersected_set = &a & &b;\n\n        assert!(intersected_set.is_empty());\n    }\n\n    #[test]\n    fn test_bitand_self() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n\n        let intersected_set = &a & &a;\n\n        assert_eq!(intersected_set, a);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579063, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=351, prompt_tokens=16361, total_tokens=16712, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaCIyIjoEmQf0Gna55FRjCmVaVG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitor() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n        \n        let set = &a | &b;\n        \n        let mut i = 0;\n        let expected = [1, 2, 3, 4, 5];\n        for x in &set {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579072, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=155, prompt_tokens=16361, total_tokens=16516, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaK6tLv1zk94CZnSSgDEQRnI9VG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitxor_symmetric_difference() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n\n        let set = &a ^ &b;\n\n        let expected = [1, 2, 4, 5];\n        let mut i = 0;\n        for x in &set {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n\n    #[test]\n    fn test_bitxor_empty_set() {\n        let a: HashSet<i32> = HashSet::new();\n        let b: HashSet<i32> = HashSet::new();\n\n        let set = &a ^ &b;\n\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_bitxor_no_overlap() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![4, 5, 6].into_iter().collect();\n\n        let set = &a ^ &b;\n\n        let expected = [1, 2, 3, 4, 5, 6];\n        let mut i = 0;\n        for x in &set {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n\n    #[test]\n    fn test_bitxor_partial_overlap() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n\n        let set = &a ^ &b;\n\n        let expected = [1, 4];\n        let mut i = 0;\n        for x in &set {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579080, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=471, prompt_tokens=16361, total_tokens=16832, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclaXVXlJrgNPcfvMRINW2biIsrsb', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_subtraction() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n        let result: HashSet<_> = a - &b;\n\n        let expected: HashSet<_> = vec![1, 2].into_iter().collect();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_subtraction_empty() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = HashSet::new();\n        let result: HashSet<_> = a - &b;\n\n        assert_eq!(result, a);\n    }\n\n    #[test]\n    fn test_subtraction_all_elements() {\n        let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = a.clone();\n        let result: HashSet<_> = a - &b;\n\n        let expected: HashSet<_> = HashSet::new();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_subtraction_no_common_elements() {\n        let a: HashSet<_> = vec![1, 2].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4].into_iter().collect();\n        let result: HashSet<_> = a - &b;\n\n        assert_eq!(result, a);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579093, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=369, prompt_tokens=16361, total_tokens=16730, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclalgcIT4ZFpxUNodsrKpuJjAN2i', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::tag::{Tag, TagSliceExt}; // Adjust the import path as necessary\n\n    #[test]\n    fn test_fill_tag() {\n        let mut tags: [Tag; 5] = [Tag::EMPTY; 5];\n        let new_tag = Tag::full(42); // Replace 42 with an actual hash you want to test\n        tags.fill_tag(new_tag);\n        \n        for tag in &tags {\n            assert_eq!(*tag, new_tag);\n        }\n    }\n    \n    #[test]\n    fn test_fill_tag_with_different_tag() {\n        let mut tags: [Tag; 3] = [Tag::EMPTY; 3];\n        let new_tag = Tag::DELETED;\n        tags.fill_tag(new_tag);\n\n        for tag in &tags {\n            assert_eq!(*tag, new_tag);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579107, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=194, prompt_tokens=839, total_tokens=1033, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclarTH9wFcTVqs57LBK1LCu1JVMQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n\n    #[test]\n    fn test_into_iter_empty() {\n        let bitmask = BitMask(0);\n        let mut iter = bitmask.into_iter();\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_single_bit() {\n        let bitmask = BitMask(1); // Only the first bit is set\n        let mut iter = bitmask.into_iter();\n        assert_eq!(iter.next(), Some(0));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_multiple_bits() {\n        let bitmask = BitMask(0b101); // Bits at positions 0 and 2 are set\n        let mut iter = bitmask.into_iter();\n        assert_eq!(iter.next(), Some(0));\n        assert_eq!(iter.next(), Some(2));\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_non_consecutive_bits() {\n        let bitmask = BitMask(0b100010); // Bits at positions 1 and 5 are set\n        let mut iter = bitmask.into_iter();\n        assert_eq!(iter.next(), Some(1));\n        assert_eq!(iter.next(), Some(5));\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579113, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=301, prompt_tokens=1326, total_tokens=1627, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclaz4vLNAuOqe0VA4Dr9HjgBIrjY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_next() {\n        let mut bitmask = BitMask(0b10100); // Example bitmask with bits 2 and 4 set\n        let mut iter = bitmask.into_iter();\n\n        // First call to next should return the lowest set bit (2)\n        assert_eq!(iter.next(), Some(2));\n        // Next call should return the next lowest set bit (4)\n        assert_eq!(iter.next(), Some(4));\n        // After all set bits are iterated, next should return None\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_no_bits_set() {\n        let mut bitmask = BitMask(0b00000); // Bitmask with no bits set\n        let mut iter = bitmask.into_iter();\n\n        // Should return None since there are no set bits\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_single_bit_set() {\n        let mut bitmask = BitMask(0b00010); // Bitmask with a single bit set (bit 1)\n        let mut iter = bitmask.into_iter();\n\n        // First call to next should return the only set bit (1)\n        assert_eq!(iter.next(), Some(1));\n        // Next call should return None\n        assert_eq!(iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579121, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=317, prompt_tokens=1305, total_tokens=1622, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclb7NYV7lGsM9SBRDamk0Gg4Vpht', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_drain_len() {\n        let mut map: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n        let drain = map.drain();\n        let length = drain.len();\n        assert_eq!(length, 3, "The length of the drain should be 3 after initializing with 3 elements");\n        \n        // Consume some elements\n        let _ = drain.next();\n        let length_after_one = drain.len();\n        assert_eq!(length_after_one, 2, "The length of the drain should be 2 after consuming one element");\n        \n        // Consume remaining elements\n        let _ = drain.next();\n        let _ = drain.next();\n        let length_after_all = drain.len();\n        assert_eq!(length_after_all, 0, "The length of the drain should be 0 after consuming all elements");\n    }\n\n    #[test]\n    fn test_drain_empty() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        let drain = map.drain();\n        let length = drain.len();\n        assert_eq!(length, 0, "The length of the drain should be 0 for an empty map");\n    }\n\n    #[test]\n    fn test_drain_fused() {\n        let mut map: HashMap<_, _> = [(1, "a"), (2, "b")].into();\n        let mut drain = map.drain();\n        let _ = drain.next();\n        let _ = drain.next();\n        \n        // Ensure that the drain is fused\n        assert_eq!(drain.next(), None, "After consuming all elements, drain should yield None");\n        assert_eq!(drain.next(), None, "Subsequent calls should still yield None");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579129, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=403, prompt_tokens=16361, total_tokens=16764, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbIZvyifbUKqysjC292Kf7cdQmk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_fold() {\n        // Create a HashMap to test\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        // Drain the hash map to iterate over its entries\n        let mut drain_iter = map.drain();\n\n        // Use fold to sum the values in the map, starting from an initial sum of 0\n        let sum = drain_iter.fold(0, |acc, (_key, value)| acc + value);\n\n        // Since the values are 10, 20, and 30, the sum should be 60\n        assert_eq!(sum, 60);\n    }\n\n    #[test]\n    fn test_fold_empty() {\n        // Create an empty HashMap\n        let map: HashMap<i32, i32> = HashMap::new();\n\n        // Drain the hash map to iterate over its entries\n        let drain_iter = map.drain();\n\n        // Use fold to sum the values in the empty map, starting from an initial sum of 0\n        let sum = drain_iter.fold(0, |acc, (_key, value)| acc + value);\n\n        // Since the map is empty, the sum should remain 0\n        assert_eq!(sum, 0);\n    }\n\n    #[test]\n    fn test_fold_with_mutation() {\n        // Create a HashMap\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        // Drain the hash map to iterate over its entries\n        let mut drain_iter = map.drain();\n\n        // Initial sum\n        let initial_sum = 5;\n\n        // Use fold and add to the initial sum\n        let total_sum = drain_iter.fold(initial_sum, |acc, (_key, value)| acc + value);\n\n        // The sum should be 5 + 10 + 20 = 35\n        assert_eq!(total_sum, 35);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579140, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=472, prompt_tokens=16361, total_tokens=16833, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbZwvqJyPcGYA23uIaMSwoaDe8v', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_drain_next() {\n        let mut map: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n\n        let mut drain_iter = map.drain();\n\n        let item1 = drain_iter.next();\n        let item2 = drain_iter.next();\n        let item3 = drain_iter.next();\n\n        // Ensure all items are present, regardless of order\n        let mut items: Vec<_> = vec![item1, item2, item3];\n        items.retain(Option::is_some); // Filter None values\n        items.sort(); // Sort items to check equality\n\n        let expected: Vec<_> = vec![Some((1, "a")), Some((2, "b")), Some((3, "c"))];\n        assert_eq!(items, expected);\n\n        // Ensure that after consuming all items, next returns None\n        assert_eq!(drain_iter.next(), None);\n    }\n\n    #[test]\n    fn test_drain_fused() {\n        let mut map: HashMap<_, _> = [(1, "a")].into();\n        let mut drain_iter = map.drain();\n\n        assert_eq!(drain_iter.next(), Some((1, "a")));\n        assert_eq!(drain_iter.next(), None);\n        assert_eq!(drain_iter.next(), None); // Fused iterator should consistently return None\n    }\n\n    #[test]\n    fn test_drain_empty() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        let mut drain_iter = map.drain();\n\n        assert_eq!(drain_iter.next(), None); // Nothing to drain\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579157, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=380, prompt_tokens=16361, total_tokens=16741, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclbpFcarZuRJoXaZFYa4hb63rDgj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n        \n        let mut drain = map.drain();\n        \n        // Since the map has 3 elements, the size hint should be (3, Some(3)).\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 3);\n        assert_eq!(upper, Some(3));\n\n        drain.next(); // Draining one element\n\n        // After draining one element, the size hint should be (2, Some(2)).\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n\n        drain.next(); // Draining another element\n\n        // After draining another element, the size hint should be (1, Some(1)).\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n\n        drain.next(); // Draining the last element\n\n        // After draining the last element, the size hint should be (0, Some(0)).\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n\n        // Check that the drain is fused\n        assert_eq!(drain.next(), None);\n        assert_eq!(drain.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579173, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=358, prompt_tokens=16361, total_tokens=16719, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclbxhb47u2oOzvimdifFxgDisJ9U', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_extract_if_next() {\n        let mut map: HashMap<i32, &str> = [(1, "a"), (2, "b"), (3, "c")].into();\n        \n        {\n            let mut extract_if = map.extract_if(|&k, _| k % 2 != 0);\n            let mut results = vec![extract_if.next(), extract_if.next()];\n\n            results.sort_unstable();\n            assert_eq!(results, vec![Some((1, "a")), Some((3, "c"))]);\n        }\n        \n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_extract_if_next_none() {\n        let mut map: HashMap<i32, &str> = [(2, "b")].into();\n        \n        {\n            let mut extract_if = map.extract_if(|&k, _| k % 2 != 0);\n            assert_eq!(extract_if.next(), None);\n        }\n        \n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_extract_if_fused() {\n        let mut map: HashMap<i32, &str> = [(1, "a"), (2, "b")].into();\n        \n        let mut extract_if = map.extract_if(|&k, _| k % 2 != 0);\n        assert_eq!(extract_if.next(), Some((1, "a")));\n        assert_eq!(extract_if.next(), None);\n        assert_eq!(extract_if.next(), None); // should still return None\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579181, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=353, prompt_tokens=16361, total_tokens=16714, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcBAOwqdjaBDnBgakM1adjGq3iy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        let extract_if = map.extract_if(|_, _| false);\n        assert_eq!(extract_if.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_some_elements() {\n        let mut map: HashMap<i32, &str> = [(1, "a"), (2, "b"), (3, "c")].into();\n        let extract_if = map.extract_if(|_, _| false);\n        assert_eq!(extract_if.size_hint(), (0, Some(3))); // 3 elements exist\n    }\n\n    #[test]\n    fn test_size_hint_after_extraction() {\n        let mut map: HashMap<i32, &str> = [(1, "a"), (2, "b"), (3, "c")].into();\n        let mut extract_if = map.extract_if(|k, _| k % 2 != 0); // extract odd keys\n        extract_if.next(); // extract one\n        assert_eq!(extract_if.size_hint(), (0, Some(2))); // 2 elements remain\n    }\n\n    #[test]\n    fn test_size_hint_after_extraction_empty() {\n        let mut map: HashMap<i32, &str> = [(1, "a"), (2, "b"), (3, "c")].into();\n        let mut extract_if = map.extract_if(|k, _| k % 2 != 0); // extract odd keys\n        extract_if.next(); // extract one\n        extract_if.next(); // extract another\n        let _ = extract_if.next(); // extract last\n        assert_eq!(extract_if.size_hint(), (0, Some(0))); // no elements remain\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579195, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=412, prompt_tokens=16361, total_tokens=16773, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclcPqxq6EB2lfSaW5g9DQOcqwWIi', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_clone_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let cloned_map = map.clone();\n        assert_eq!(map.len(), 0);\n        assert_eq!(cloned_map.len(), 0);\n        assert_eq!(cloned_map, map);\n    }\n\n    #[test]\n    fn test_clone_single_entry() {\n        let mut map = HashMap::new();\n        map.insert(1, 2);\n        let cloned_map = map.clone();\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(cloned_map.len(), 1);\n        assert_eq!(cloned_map, map);\n        assert_eq!(cloned_map.get(&1), Some(&2));\n    }\n\n    #[test]\n    fn test_clone_multiple_entries() {\n        let mut map = HashMap::new();\n        map.insert(1, 2);\n        map.insert(3, 4);\n        map.insert(5, 6);\n        let cloned_map = map.clone();\n\n        assert_eq!(map.len(), 3);\n        assert_eq!(cloned_map.len(), 3);\n        assert_eq!(cloned_map, map);\n        assert_eq!(cloned_map.get(&3), Some(&4));\n    }\n\n    #[test]\n    fn test_clone_non_empty_map() {\n        let mut map = HashMap::new();\n        map.insert("foo", "bar");\n        map.insert("baz", "qux");\n        \n        let cloned_map = map.clone();\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(cloned_map.len(), 2);\n        assert_eq!(cloned_map.get("foo"), Some(&"bar"));\n        assert_eq!(cloned_map.get("baz"), Some(&"qux"));\n        assert_eq!(cloned_map, map);\n    }\n\n    #[test]\n    fn test_clone_and_modify() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        let cloned_map = map.clone();\n\n        map.insert(2, "b");\n        \n        assert_eq!(map.len(), 2);\n        assert_eq!(cloned_map.len(), 1);\n        assert_eq!(cloned_map.get(&1), Some(&"a"));\n        assert!(cloned_map.get(&2).is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579209, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=505, prompt_tokens=16361, total_tokens=16866, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclcdig7oBHyhm98X3q9okr6E2Quq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_clone_from_different_maps() {\n        let mut source_map: HashMap<i32, &str> = HashMap::new();\n        source_map.insert(1, "one");\n        source_map.insert(2, "two");\n        \n        let mut target_map: HashMap<i32, &str> = HashMap::new();\n\n        // Clone from source_map to target_map\n        target_map.clone_from(&source_map);\n\n        assert_eq!(target_map.get(&1), Some(&"one"));\n        assert_eq!(target_map.get(&2), Some(&"two"));\n        assert_eq!(target_map.len(), 2);\n    }\n\n    #[test]\n    fn test_clone_from_empty_map() {\n        let source_map: HashMap<i32, &str> = HashMap::new();\n        let mut target_map: HashMap<i32, &str> = HashMap::new();\n\n        // Clone from empty source_map to target_map\n        target_map.clone_from(&source_map);\n\n        assert!(target_map.is_empty());\n    }\n\n    #[test]\n    fn test_clone_from_map_with_clashing_keys() {\n        let mut source_map: HashMap<i32, &str> = HashMap::new();\n        source_map.insert(1, "one");\n        \n        let mut target_map: HashMap<i32, &str> = HashMap::new();\n        target_map.insert(1, "old_value");\n\n        // Clone from source_map to target_map\n        target_map.clone_from(&source_map);\n\n        assert_eq!(target_map.get(&1), Some(&"one")); // It should overwrite "old_value"\n    }\n\n    #[test]\n    fn test_clone_from_map_with_different_sizes() {\n        let mut source_map: HashMap<i32, &str> = HashMap::new();\n        source_map.insert(1, "one");\n        source_map.insert(2, "two");\n        source_map.insert(3, "three");\n\n        let mut target_map: HashMap<i32, &str> = HashMap::new();\n        target_map.insert(1, "old_value");\n\n        // Clone from source_map to target_map\n        target_map.clone_from(&source_map);\n\n        assert_eq!(target_map.get(&1), Some(&"one"));    // should overwrite\n        assert_eq!(target_map.get(&2), Some(&"two"));    // should insert new\n        assert_eq!(target_map.get(&3), Some(&"three"));  // should insert new\n        assert_eq!(target_map.len(), 3);                  // should have 3 elements now\n    }\n\n    #[test]\n    fn test_clone_from_with_same_map() {\n        let mut source_map: HashMap<i32, &str> = HashMap::new();\n        source_map.insert(1, "one");\n        source_map.insert(2, "two");\n\n        // Clone from itself\n        source_map.clone_from(&source_map);\n\n        assert_eq!(source_map.len(), 2);\n        assert_eq!(source_map.get(&1), Some(&"one"));\n        assert_eq!(source_map.get(&2), Some(&"two"));\n    }\n\n    #[test]\n    fn test_clone_from_with_different_key_value_types() {\n        let mut source_map: HashMap<i32, &str> = HashMap::new();\n        source_map.insert(1, "one");\n        source_map.insert(2, "two");\n\n        let mut target_map: HashMap<i32, String> = HashMap::new();\n\n        // Clone from source_map to target_map\n        target_map.clone_from(&source_map);\n\n        assert_eq!(target_map.get(&1), Some(&"one".to_string())); // Assert with String comparison\n        assert_eq!(target_map.get(&2), Some(&"two".to_string())); // Assert with String comparison\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579223, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=825, prompt_tokens=16361, total_tokens=17186, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcld1d1abMnzmXz6C5kZNLyFQjyQf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_eq_different_length() {\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        map1.insert(1, "a");\n        map2.insert(1, "a");\n        map2.insert(2, "b");\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_different_keys() {\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        map1.insert(1, "a");\n        map2.insert(2, "a");\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_different_values() {\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        map1.insert(1, "a");\n        map2.insert(1, "b");\n        assert!(!map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_same() {\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        map1.insert(1, "a");\n        map1.insert(2, "b");\n        map2.insert(1, "a");\n        map2.insert(2, "b");\n        assert!(map1.eq(&map2));\n    }\n\n    #[test]\n    fn test_eq_with_different_order() {\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        map1.insert(1, "a");\n        map1.insert(2, "b");\n        map2.insert(2, "b");\n        map2.insert(1, "a");\n        assert!(map1.eq(&map2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579247, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=411, prompt_tokens=16361, total_tokens=16772, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldBGkd1Ip2rDLotyrLKr7ltvCAH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_default_empty_hashmap() {\n        // Test default creation of HashMap\n        let map: HashMap<u32, String> = HashMap::default();\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_default_with_random_state() {\n        use std::collections::hash_map::RandomState;\n\n        // Test default creation of HashMap with RandomState hasher\n        let map: HashMap<u32, String, RandomState> = HashMap::default();\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_default_hashmap_with_elements() {\n        let mut map: HashMap<u32, String> = HashMap::default();\n        map.insert(1, "one".to_string());\n        map.insert(2, "two".to_string());\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&"one".to_string()));\n        assert_eq!(map.get(&2), Some(&"two".to_string()));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579257, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=268, prompt_tokens=16361, total_tokens=16629, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldJ6GseOJ6Fai6APDGZ5zPUEVgU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_extend_with_tuple_array() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n\n        let arr = [(1, 1), (2, 2)];\n        map.extend(arr.iter());\n        assert_eq!(map.get(&1), Some(&1));\n        \n        let some_vec: Vec<_> = vec![(3, 3), (4, 4)];\n        map.extend(&some_vec);\n\n        let some_arr = [(5, 5), (6, 6)];\n        map.extend(&some_arr);\n\n        let mut vec: Vec<_> = map.into_iter().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]);\n    }\n\n    #[test]\n    fn test_extend_with_another_hashmap() {\n        let mut map1 = HashMap::new();\n        map1.insert(1, 1);\n        map1.insert(2, 2);\n\n        let mut map2 = HashMap::new();\n        map2.extend(map1.clone());\n\n        let mut vec: Vec<_> = map2.into_iter().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [(1, 1), (2, 2)]);\n    }\n\n    #[test]\n    fn test_extend_empty_iterator() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        \n        let empty_vec: Vec<(&usize, &usize)> = Vec::new();\n        map.extend(empty_vec.iter());\n        assert_eq!(map.get(&1), Some(&100));\n    }\n\n    #[test]\n    fn test_replace_existing_values() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n\n        let arr = [(1, 200), (2, 2)];\n        map.extend(arr.iter());\n        assert_eq!(map.get(&1), Some(&200));\n        assert_eq!(map.get(&2), Some(&2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579265, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=470, prompt_tokens=16361, total_tokens=16831, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldVLlLgry8nOqq9PcAMRogRp3lB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_extend_with_array() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        \n        let arr = [(1, 1), (2, 2)];\n        map.extend(arr.iter()); // Extending with an array reference\n        \n        assert_eq!(map.get(&1), Some(&1)); // Check if value 1 is updated\n        assert_eq!(map.get(&2), Some(&2)); // Check if new value is added\n    }\n\n    #[test]\n    fn test_extend_with_vec() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        \n        let vec = vec![(3, 3), (4, 4)];\n        map.extend(vec.iter()); // Extending with a vector\n        \n        assert_eq!(map.get(&3), Some(&3)); // Check if new value is added\n        assert_eq!(map.get(&4), Some(&4)); // Check if new value is added\n    }\n\n    #[test]\n    fn test_extend_with_other_hashmap() {\n        let mut map1 = HashMap::new();\n        map1.insert(1, 100);\n        \n        let mut map2 = HashMap::new();\n        map2.insert(2, 200);\n        \n        map1.extend(&map2);\n        \n        assert_eq!(map1.get(&1), Some(&100)); // Ensure map1 still contains original value\n        assert_eq!(map1.get(&2), Some(&200)); // Ensure new value is added\n    }\n\n    #[test]\n    fn test_extend_overriding_values() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        \n        let arr = [(1, 111), (2, 222)];\n        map.extend(arr.iter()); // Overriding values\n        \n        assert_eq!(map.get(&1), Some(&111)); // Ensure value is updated\n        assert_eq!(map.get(&2), Some(&222)); // Ensure value is updated\n    }\n\n    #[test]\n    fn test_extend_with_empty() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        \n        let empty_vec: Vec<(&i32, &i32)> = vec![];\n        map.extend(empty_vec.iter()); // Extending with an empty vector\n        \n        assert_eq!(map.get(&1), Some(&100)); // Ensure original value is still there\n    }\n\n    #[test]\n    fn test_extend_into_keys() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        \n        let keys: [(i32, i32); 2] = [(2, 200), (3, 300)];\n        map.extend(keys.iter()); // Extending with an array of tuples\n        \n        assert_eq!(map.get(&2), Some(&200)); // Ensure new values are added\n        assert_eq!(map.get(&3), Some(&300)); // Ensure new values are added\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579277, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=666, prompt_tokens=16361, total_tokens=17027, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcldkPrycJtcJYHFoHEwQR6LUGMSv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_extend_with_array() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n\n        let some_arr = [(1, 1), (2, 2)];\n        map.extend(some_arr.iter().cloned());\n        assert_eq!(map.get(&1), Some(&1));\n        assert_eq!(map.get(&2), Some(&2));\n    }\n\n    #[test]\n    fn test_extend_with_vec() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n\n        let some_vec = vec![(1, 1), (2, 2)];\n        map.extend(some_vec.iter().cloned());\n        assert_eq!(map.get(&1), Some(&1));\n        assert_eq!(map.get(&2), Some(&2));\n    }\n\n    #[test]\n    fn test_extend_from_another_hashmap() {\n        let mut map1 = HashMap::new();\n        map1.insert(1, 100);\n        map1.insert(2, 200);\n\n        let mut map2 = HashMap::new();\n        map2.extend(map1);\n        assert_eq!(map2.get(&1), Some(&100));\n        assert_eq!(map2.get(&2), Some(&200));\n    }\n\n    #[test]\n    fn test_extend_with_mixed_types() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n\n        let mixed_iter = vec![(1, 150), (3, 300)];\n        map.extend(mixed_iter.iter().cloned());\n        assert_eq!(map.get(&1), Some(&150));\n        assert_eq!(map.get(&2), Some(&200));\n        assert_eq!(map.get(&3), Some(&300));\n    }\n\n    #[test]\n    fn test_extend_does_not_change_unrelated_keys() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n\n        let some_iter = [(3, 300), (4, 400)];\n        map.extend(some_iter.iter().cloned());\n        \n        assert_eq!(map.get(&1), Some(&100));\n        assert_eq!(map.get(&2), Some(&200));\n        assert_eq!(map.get(&3), Some(&300));\n        assert_eq!(map.get(&4), Some(&400));\n    }\n\n    #[test]\n    fn test_extend_and_check_final_length() {\n        let mut map = HashMap::new();\n        let initial_length = map.len();\n\n        let some_vec = vec![(1, 1), (2, 2), (3, 3)];\n        map.extend(some_vec.iter().cloned());\n        \n        assert_eq!(map.len(), initial_length + 3);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579292, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=622, prompt_tokens=16361, total_tokens=16983, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcle4MyPk9F7PoEzhYO7YcmUWrLYP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_from_iter() {\n        let data = vec![(1, "a"), (2, "b"), (3, "c")];\n        let map: HashMap<_, _> = HashMap::from_iter(data.clone());\n        \n        assert_eq!(map.len(), 3);\n        for (k, v) in data {\n            assert_eq!(map.get(&k), Some(&v));\n        }\n    }\n\n    #[test]\n    fn test_from_iter_empty() {\n        let data: Vec<(i32, &str)> = vec![];\n        let map: HashMap<_, _> = HashMap::from_iter(data);\n        \n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_from_iter_with_duplicates() {\n        let data = vec![(1, "a"), (1, "b"), (2, "c")];\n        let map: HashMap<_, _> = HashMap::from_iter(data);\n        \n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&"b"));  // Should be "b" since it overwrites "a"\n        assert_eq!(map.get(&2), Some(&"c"));\n    }\n\n    #[test]\n    fn test_from_iter_with_default_hasher() {\n        let data = vec![(1, "a"), (2, "b")];\n        let map: HashMap<_, _> = HashMap::from_iter(data);\n        \n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&"a"));\n        assert_eq!(map.get(&2), Some(&"b"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579312, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=377, prompt_tokens=16361, total_tokens=16738, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcleIgisllvvc6r0Y1nPTpogrmnPL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter() {\n        let map: HashMap<_, _> = [("a", 1), ("b", 2), ("c", 3)].into();\n        \n        let mut vec: Vec<(&str, i32)> = map.into_iter().collect();\n        vec.sort_unstable();\n        \n        assert_eq!(vec, [("a", 1), ("b", 2), ("c", 3)]);\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let map: HashMap<_, _> = HashMap::new();\n        \n        let vec: Vec<(i32, i32)>: Vec<(i32, i32)> = map.into_iter().collect();\n        \n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_into_iter_with_duplicates() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("a", 3); // Replacing value for key "a"\n\n        let mut vec: Vec<_> = map.into_iter().collect();\n        vec.sort_unstable();\n        \n        assert_eq!(vec, [("a", 3), ("b", 2)]);\n    }\n\n    #[test]\n    fn test_into_iter_cannot_use_map() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        map.insert("a", 1);\n        \n        // Call into_iter()\n        let _iter = map.into_iter();\n\n        // Check that the map can no longer be used\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_into_iter_large_data() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        for i in 0..1000 {\n            map.insert(i, i * 2);\n        }\n\n        let mut vec: Vec<(i32, i32)> = map.into_iter().collect();\n        vec.sort_unstable();\n\n        let expected: Vec<(i32, i32)> = (0..1000).map(|i| (i, i * 2)).collect();\n        assert_eq!(vec, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579326, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=497, prompt_tokens=16361, total_tokens=16858, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcleWO5UkbzrLQkx5PgS2uFKkktQa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    #[should_panic(expected = "no entry found for key")]\n    fn test_index_key_not_present() {\n        let map: HashMap<&str, &str> = HashMap::new();\n        let _ = map["key_not_present"];\n    }\n\n    #[test]\n    fn test_index_key_present() {\n        let mut map: HashMap<&str, &str> = HashMap::new();\n        map.insert("key1", "value1");\n        map.insert("key2", "value2");\n\n        assert_eq!(map["key1"], "value1");\n        assert_eq!(map["key2"], "value2");\n    }\n    \n    #[test]\n    fn test_index_with_uninitialized_key() {\n        let mut map: HashMap<&str, &str> = HashMap::new();\n        map.insert("initialized_key", "initialized_value");\n\n        assert_eq!(map["initialized_key"], "initialized_value");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579340, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=218, prompt_tokens=16361, total_tokens=16579, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclehA8RU00dBtHW8SEVtuXKjgdfg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_hashmap_from_array() {\n        // Test with a simple integer to integer mapping\n        let map: HashMap<i32, i32> = HashMap::from([(1, 2), (3, 4)]);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&2));\n        assert_eq!(map.get(&3), Some(&4));\n\n        // Test with a different set of integers\n        let map2: HashMap<i32, i32> = HashMap::from([(5, 6), (7, 8)]);\n        assert_eq!(map2.len(), 2);\n        assert_eq!(map2.get(&5), Some(&6));\n        assert_eq!(map2.get(&7), Some(&8));\n\n        // Test with empty array\n        let empty_map: HashMap<i32, i32> = HashMap::from([]);\n        assert!(empty_map.is_empty());\n\n        // Test with strings\n        let string_map: HashMap<&str, &str> = HashMap::from([("a", "apple"), ("b", "banana")]);\n        assert_eq!(string_map.get(&"a"), Some(&"apple"));\n        assert_eq!(string_map.get(&"b"), Some(&"banana"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579351, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=298, prompt_tokens=16361, total_tokens=16659, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclerzvEaSN6CFMy2b3E3UZHbzgPz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::map::IntoIter;\n\n    #[test]\n    fn test_into_iter_default() {\n        let iter: IntoIter<i32, i32> = IntoIter::default();\n        assert_eq!(iter.len(), 0);\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579361, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=77, prompt_tokens=10232, total_tokens=10309, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclexcOFKwa0rayHaMZ7cziwr4iha', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter_len() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n        \n        let iter = map.into_iter();\n        let len = iter.len();\n        \n        assert_eq!(len, 3);\n    }\n\n    #[test]\n    fn test_into_iter_len_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        \n        let iter = map.into_iter();\n        let len = iter.len();\n        \n        assert_eq!(len, 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579367, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=160, prompt_tokens=10229, total_tokens=10389, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclf3tJ536MKA3RyjfJ14Vlqdmqxu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_fold() {\n        let map: HashMap<i32, String> = [(1, "a".to_string()), (2, "b".to_string()), (3, "c".to_string())].into();\n        let iter = map.into_iter();\n\n        let result = iter.fold(String::new(), |acc, (key, value)| {\n            format!("{}{}: {}, ", acc, key, value)\n        });\n\n        // Remove the trailing comma and space\n        let trimmed_result = result.trim_end_matches(", ").to_string();\n        let expected_result = "1: a, 2: b, 3: c";\n        assert_eq!(trimmed_result, expected_result);\n    }\n\n    #[test]\n    fn test_fold_with_empty_map() {\n        let map: HashMap<i32, String> = HashMap::new();\n        let iter = map.into_iter();\n\n        let result = iter.fold(String::new(), |acc, (key, value)| {\n            format!("{}{}: {}, ", acc, key, value)\n        });\n\n        assert_eq!(result, String::new());\n    }\n\n    #[test]\n    fn test_fold_with_init_value() {\n        let map: HashMap<i32, String> = [(1, "x".to_string()), (2, "y".to_string())].into();\n        let iter = map.into_iter();\n\n        let result = iter.fold("Init: ".to_string(), |acc, (key, value)| {\n            format!("{}{}: {}, ", acc, key, value)\n        });\n\n        let trimmed_result = result.trim_end_matches(", ").to_string();\n        let expected_result = "Init: 1: x, 2: y";\n        assert_eq!(trimmed_result, expected_result);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579373, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=397, prompt_tokens=10263, total_tokens=10660, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfEyMagfK2Q7YkEDWNy2KHfrZ8W', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_iter_next() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let mut iter = map.into_iter();\n        let mut vec = vec![iter.next(), iter.next(), iter.next()];\n\n        // The `IntoIter` iterator produces items in arbitrary order, so they must be sorted.\n        vec.sort_unstable();\n        assert_eq!(vec, [Some((1, "a")), Some((2, "b")), Some((3, "c"))]);\n\n        // Check that no more items remain\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_empty_iter() {\n        let map: HashMap<_, _> = HashMap::new();\n        let mut iter = map.into_iter();\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_after_fully_iterating() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n\n        let mut iter = map.into_iter();\n        let _ = iter.next();\n        let _ = iter.next();\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None); // Ensure it doesn\'t panic\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579384, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=322, prompt_tokens=10233, total_tokens=10555, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfRYOZRQBzM7r0iEm7KZ5DjdufQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let map: HashMap<i32, &str> = [(1, "a"), (2, "b"), (3, "c")].into_iter().collect();\n        let iter = map.into_iter();\n\n        // Check the size_hint when the iterator is created\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 3); // We expect at least 3 elements\n        assert_eq!(upper, Some(3)); // We expect at most 3 elements\n\n        let mut iter = iter; // Re-assign for further tests\n\n        // Check size_hint after consuming some elements\n        iter.next();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 2); // Now we expect at least 2 elements\n        assert_eq!(upper, Some(2)); // Now we expect at most 2 elements\n\n        iter.next();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 1); // Now we expect at least 1 element\n        assert_eq!(upper, Some(1)); // Now we expect at most 1 element\n\n        iter.next();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 0); // Now we expect at least 0 elements\n        assert_eq!(upper, Some(0)); // Now we expect at most 0 elements\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579397, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=333, prompt_tokens=10237, total_tokens=10570, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclfaATJLkIBuvkAaGyuM6NjRaRUf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_keys_default() {\n        // Create a HashMap and call into_keys to test default\n        let map: HashMap<i32, &str> = HashMap::new();\n        let keys: IntoKeys<i32, &str> = map.into_keys();\n        \n        // Verify that default creates an empty IntoKeys iterator\n        let keys_default: IntoKeys<i32, &str> = Default::default();\n        let mut vec: Vec<_> = keys_default.collect();\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_into_keys_default_with_elements() {\n        // Create a HashMap and insert elements\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        // Call into_keys and then default\n        let keys: IntoKeys<i32, &str> = map.into_keys();\n        \n        // Verify that default creates an empty IntoKeys iterator\n        let keys_default: IntoKeys<i32, &str> = Default::default();\n        let mut vec_default: Vec<_> = keys_default.collect();\n        assert!(vec_default.is_empty());\n\n        // Collect keys from the original keys iterator\n        let mut vec: Vec<_> = keys.collect();\n        \n        // Check that the keys were collected\n        assert_eq!(vec.len(), 3);\n        vec.sort();\n        assert_eq!(vec, vec![1, 2, 3]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579406, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=351, prompt_tokens=10924, total_tokens=11275, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclgKtMpzWGADRop3smaRUsImxsHP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_keys_len() {\n        // Create a HashMap and insert some key-value pairs\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        // Create an IntoKeys iterator from the HashMap\n        let keys: IntoKeys<i32, &str> = map.into_keys();\n\n        // Check the length using the len method\n        assert_eq!(keys.len(), 3);\n    }\n\n    #[test]\n    fn test_into_keys_empty_len() {\n        // Create an empty HashMap\n        let map: HashMap<i32, &str> = HashMap::new();\n\n        // Create an IntoKeys iterator from the empty HashMap\n        let keys: IntoKeys<i32, &str> = map.into_keys();\n\n        // Check the length using the len method\n        assert_eq!(keys.len(), 0);\n    }\n\n    #[test]\n    fn test_into_keys_after_consuming() {\n        // Create a HashMap and insert some key-value pairs\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n\n        // Create an IntoKeys iterator\n        let mut keys: IntoKeys<i32, &str> = map.into_keys();\n\n        // Consume some keys\n        keys.next();\n        keys.next();\n\n        // Check the length after consuming\n        assert_eq!(keys.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579452, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=361, prompt_tokens=10922, total_tokens=11283, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclgUOUXkaHbDOoMCd4hmDXUCxdrV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_fold_on_into_keys() {\n        let map: HashMap<u32, &str> = [(1, "a"), (2, "b"), (3, "c")].into();\n        let keys = map.into_keys();\n\n        let sum: u32 = keys.fold(0, |acc, key| acc + key);\n        assert_eq!(sum, 6); // 1 + 2 + 3 = 6\n    }\n\n    #[test]\n    fn test_fold_on_empty_into_keys() {\n        let map: HashMap<u32, &str> = HashMap::new();\n        let keys = map.into_keys();\n\n        let sum: u32 = keys.fold(0, |acc, key| acc + key);\n        assert_eq!(sum, 0); // No keys, sum should be 0\n    }\n\n    #[test]\n    fn test_fold_with_custom_function() {\n        let map: HashMap<u32, &str> = [(1, "a"), (2, "b"), (3, "c"), (4, "d")].into();\n        let keys = map.into_keys();\n\n        let concatenated_keys = keys.fold(String::new(), |acc, key| acc + &format!("{}", key));\n        assert_eq!(concatenated_keys, "1234"); // Concatenated string of keys\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579462, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=314, prompt_tokens=10968, total_tokens=11282, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclgegcpSf42M1U2jRCxhU10EbHZd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use std::collections::HashSet;\n\n    #[test]\n    fn test_into_keys_next() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let mut into_keys = map.into_keys();\n        let mut keys = HashSet::new();\n\n        while let Some(key) = into_keys.next() {\n            keys.insert(key);\n        }\n\n        let expected_keys: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        assert_eq!(keys, expected_keys);\n    }\n\n    #[test]\n    fn test_into_keys_next_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let mut into_keys = map.into_keys();\n\n        assert_eq!(into_keys.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579472, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=220, prompt_tokens=10931, total_tokens=11151, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclgm7ohVWjQqOZhwBXrksuawHtiF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HashMap<u32, u32> = HashMap::new();\n        let keys = map.into_keys();\n        assert_eq!(keys.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut map = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let keys = map.into_keys();\n        \n        // Size hint should reflect the number of keys in the map\n        assert_eq!(keys.size_hint(), (2, Some(2)));\n        \n        // Iterate to exhaust the keys\n        let _ = keys.collect::<Vec<_>>();\n\n        // After collecting, the size hint should still reflect nothing\n        assert_eq!(keys.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_with_fusion() {\n        let mut map = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let mut keys = map.into_keys();\n        \n        // Size hint should reflect the number of keys\n        assert_eq!(keys.size_hint(), (2, Some(2)));\n        assert!(keys.next().is_some());\n        \n        // After consuming one element, size hint should reflect one less\n        assert_eq!(keys.size_hint(), (1, Some(1)));\n        \n        assert!(keys.next().is_some());\n        \n        // After consuming all elements, size hint should reflect nothing\n        assert_eq!(keys.size_hint(), (0, Some(0)));\n        assert!(keys.next().is_none());\n        \n        // After exhausting, confirming the iterator is fused\n        assert_eq!(keys.size_hint(), (0, Some(0)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579480, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=401, prompt_tokens=10930, total_tokens=11331, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclgv8VPcT1V6aI0gcLUBqP1qeixH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_values_default() {\n        let values: IntoValues<i32, &str> = IntoValues::default();\n        assert_eq!(values.len(), 0);\n    }\n\n    #[test]\n    fn test_into_values_default_after_insert() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let values: IntoValues<i32, &str> = map.into_values();\n        let mut collected: Vec<_> = values.collect();\n\n        // The collected values should contain "a", "b", "c" in arbitrary order\n        collected.sort_unstable();\n        assert_eq!(collected, vec!["a", "b", "c"]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579489, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=201, prompt_tokens=10917, total_tokens=11118, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclh1GcC8xBxfRJNvqNZtpw8SJU3x', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_values_len() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let values: IntoValues<_, _, _> = map.into_values();\n        assert_eq!(values.len(), 3);\n\n        let mut values_empty: IntoValues<_, _, _> = HashMap::new().into_values();\n        assert_eq!(values_empty.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579495, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=134, prompt_tokens=10915, total_tokens=11049, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclh6WZz5yZVsZ1JEDS4PbsLECdgc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_fold_with_empty_map() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let result = map.into_values().fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_fold_with_non_empty_map() {\n        let map: HashMap<i32, &str> = [(1, "a"), (2, "b"), (3, "c")].into();\n        let result = map.into_values().fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 3);\n    }\n\n    #[test]\n    fn test_fold_with_initial_value() {\n        let map: HashMap<i32, i32> = [(1, 10), (2, 20), (3, 30)].into();\n        let result = map.into_values().fold(100, |acc, val| acc + val);\n        assert_eq!(result, 100 + 10 + 20 + 30);\n    }\n\n    #[test]\n    fn test_fold_with_different_operation() {\n        let map: HashMap<i32, i32> = [(1, 1), (2, 2), (3, 3)].into();\n        let result = map.into_values().fold(1, |acc, val| acc * val);\n        assert_eq!(result, 1 * 1 * 2 * 3);\n    }\n\n    #[test]\n    fn test_fold_with_identity_function() {\n        let map: HashMap<i32, i32> = [(1, 5), (2, 10)].into();\n        let result = map.into_values().fold(0, |acc, val| acc + val);\n        assert_eq!(result, 0 + 5 + 10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579500, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=422, prompt_tokens=10959, total_tokens=11381, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclhHNp8R5ZwEMI3WWVsxFVKlVMta', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_values_next() {\n        let map: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n        let mut values = map.into_values();\n\n        let mut vec = vec![values.next(), values.next(), values.next()];\n\n        // The `IntoValues` iterator produces values in arbitrary order, so\n        // the values must be sorted to test them against a sorted array.\n        vec.sort_unstable();\n        assert_eq!(vec, [Some("a"), Some("b"), Some("c")]);\n\n        // It is a fused iterator\n        assert_eq!(values.next(), None);\n        assert_eq!(values.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579511, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=179, prompt_tokens=10922, total_tokens=11101, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclhOz3Z7eQOxeVT5vgqDrBZFi2tz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let mut into_values = map.into_values();\n        let size_hint = into_values.size_hint();\n\n        // The size hint should reflect the number of elements in the HashMap\n        assert_eq!(size_hint, (3, Some(3)));\n\n        // Consume all elements\n        let _ = into_values.next();\n        let size_hint_after_one = into_values.size_hint();\n\n        // After consuming one element, the size hint should reflect 2 remaining\n        assert_eq!(size_hint_after_one, (2, Some(2)));\n\n        // Consume remaining elements\n        let _ = into_values.next();\n        let _ = into_values.next();\n        let size_hint_after_all = into_values.size_hint();\n\n        // After consuming all elements, the size hint should indicate no remaining elements\n        assert_eq!(size_hint_after_all, (0, Some(0)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579518, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=248, prompt_tokens=10923, total_tokens=11171, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclhW8502DGh9rUyollCnTFlD6SXV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_clone_iter() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let iter = map.iter();\n        let cloned_iter = iter.clone();\n        \n        let mut original_values: Vec<_> = iter.collect();\n        let mut cloned_values: Vec<_> = cloned_iter.collect();\n        \n        original_values.sort();\n        cloned_values.sort();\n        \n        assert_eq!(original_values, cloned_values);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579526, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=148, prompt_tokens=9735, total_tokens=9883, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclhcqNCBqFvTmaLW3srGD2UD8HdV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter_default() {\n        // Create an empty HashMap\n        let map: HashMap<i32, i32> = HashMap::new();\n\n        // Create an iterator using the default method\n        let iter: Iter<i32, i32> = Default::default();\n\n        // As the HashMap is empty, the iterator should also be empty\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_default_non_empty() {\n        // Create a HashMap with some values\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        \n        // Create an iterator using the iter method\n        let mut iter = map.iter();\n\n        // Collect the items into a vector\n        let mut items: Vec<_> = iter.collect();\n\n        // Sort the items to ensure consistent order\n        items.sort_unstable();\n\n        // Validate the items in the iterator\n        assert_eq!(items, vec![(&1, &10), (&2, &20), (&3, &30)]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579532, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=276, prompt_tokens=9733, total_tokens=10009, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclhmQDTGb1q0wC6AD6QOnwXvT4Oq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_len() {\n        let map: HashMap<u32, &str> = [(1, "a"), (2, "b"), (3, "c")].into();\n        let iter = map.iter();\n\n        assert_eq!(iter.len(), 3);\n\n        let mut iter_clone = iter.clone();\n        assert_eq!(iter_clone.len(), 3);\n\n        // Consume some elements\n        assert!(iter_clone.next().is_some());\n        assert_eq!(iter_clone.len(), 2);\n\n        assert!(iter_clone.next().is_some());\n        assert_eq!(iter_clone.len(), 1);\n\n        // Consume the last element\n        assert!(iter_clone.next().is_some());\n        assert_eq!(iter_clone.len(), 0);\n\n        // No elements left\n        assert!(iter_clone.next().is_none());\n        assert_eq!(iter_clone.len(), 0);\n    }\n\n    #[test]\n    fn test_len_empty() {\n        let map: HashMap<u32, &str> = HashMap::new();\n        let iter = map.iter();\n\n        assert_eq!(iter.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579542, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=258, prompt_tokens=9724, total_tokens=9982, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclhuj1ekqFBIkSJMVNcjU7rX6HTN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter_fold() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n        \n        let iter = map.iter();\n        let result = iter.fold(Vec::new(), |mut acc, (&k, &v)| {\n            acc.push((k, v));\n            acc\n        });\n        \n        assert_eq!(result.len(), 3);\n        assert!(result.contains(&(1, "a")));\n        assert!(result.contains(&(2, "b")));\n        assert!(result.contains(&(3, "c")));\n    }\n\n    #[test]\n    fn test_iter_empty_fold() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let iter = map.iter();\n        let result = iter.fold(0, |acc, _| acc + 1);\n        \n        assert_eq!(result, 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579550, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=228, prompt_tokens=9788, total_tokens=10016, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcli3upu81eUJGEdQXQaZpyLJDx7S', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_next() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let mut iter = map.iter();\n        let mut collected = Vec::new();\n\n        while let Some(item) = iter.next() {\n            collected.push(item);\n        }\n\n        // Ensure we collected the correct number of items\n        assert_eq!(collected.len(), 3);\n        // Ensure collected items match original map\n        assert!(collected.contains(&(&1, &"a")));\n        assert!(collected.contains(&(&2, &"b")));\n        assert!(collected.contains(&(&3, &"c")));\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let mut iter = map.iter();\n        \n        assert_eq!(iter.next(), None); // Ensure that calling next on an empty iterator returns None\n    }\n\n    #[test]\n    fn test_next_fused() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n\n        let mut iter = map.iter();\n        assert_eq!(iter.next(), Some((&1, &"a"))); // First call returns the item\n        assert_eq!(iter.next(), None); // Second call should return None\n        assert_eq!(iter.next(), None); // Further calls should still return None\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579559, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=356, prompt_tokens=9787, total_tokens=10143, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcliBbK5D6n4sMtyZM7X1VQIz6AJz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let iter = map.iter();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_single_element() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        let iter = map.iter();\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n    }\n\n    #[test]\n    fn test_size_hint_multiple_elements() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let iter = map.iter();\n        assert_eq!(iter.size_hint(), (2, Some(2)));\n    }\n\n    #[test]\n    fn test_size_hint_after_consuming_elements() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let mut iter = map.iter();\n        iter.next(); // consume one element\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n        iter.next(); // consume another element\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579567, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=327, prompt_tokens=9733, total_tokens=10060, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcliLckWVtjmaALEd0BIQ7LtUuirU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::marker::PhantomData;\n\n    #[test]\n    fn test_iter_mut_default() {\n        // Create a default instance of IterMut\n        let iter: IterMut<i32, String> = IterMut::default();\n\n        // Check that the inner RawIter is default (should be empty)\n        assert_eq!(iter.inner.len(), 0);\n\n        // Check the marker is set correctly (it should be a marker with the PhantomData)\n        let marker: PhantomData<(&i32, &mut String)> = PhantomData;\n        assert!(std::mem::transmute::<_, &PhantomData<(&i32, &mut String)>>(&iter.marker) == &marker);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579577, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=163, prompt_tokens=9801, total_tokens=9964, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcliTIwzZYZm18JMtbAH3dCmRwu1N', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter_mut_len() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        map.insert(1, "One".to_owned());\n        map.insert(2, "Two".to_owned());\n        map.insert(3, "Three".to_owned());\n\n        let mut iter = map.iter_mut();\n        assert_eq!(iter.len(), 3);\n\n        iter.next();\n        assert_eq!(iter.len(), 2);\n\n        iter.next();\n        iter.next();\n        assert_eq!(iter.len(), 0);\n\n        let mut empty_iter: IterMut<i32, String> = IterMut::default();\n        assert_eq!(empty_iter.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579585, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=173, prompt_tokens=9792, total_tokens=9965, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcliZw4XaNrtBHyXVd4f3GlPKXcOZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap; // adjust the import according to your project's structure\n    \n    #[test]\n    fn test_fold() {\n        let mut map = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let iter = map.iter_mut();\n        let sum = iter.fold(0, |acc, (_, v)| acc + *v);\n        \n        assert_eq!(sum, 60);\n    }\n\n    #[test]\n    fn test_fold_with_empty_map() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let iter = map.iter_mut();\n        let sum = iter.fold(0, |acc, (_, v)| acc + *v);\n        \n        assert_eq!(sum, 0);\n    }\n\n    #[test]\n    fn test_fold_with_custom_function() {\n        let mut map = HashMap::new();\n        map.insert(1, 2);\n        map.insert(2, 3);\n        map.insert(3, 4);\n\n        let iter = map.iter_mut();\n        let product = iter.fold(1, |acc, (_, v)| acc * *v);\n        \n        assert_eq!(product, 24);\n    }\n\n    #[test]\n    fn test_fold_modify_values() {\n        let mut map = HashMap::new();\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.insert(3, 3);\n\n        let iter = map.iter_mut();\n        iter.fold((), |_, (_, v)| {\n            *v += 1; // increment each value\n        });\n\n        assert_eq!(map.get(&1), Some(&2));\n        assert_eq!(map.get(&2), Some(&3));\n        assert_eq!(map.get(&3), Some(&4));\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579591, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=405, prompt_tokens=9856, total_tokens=10261, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcliiVU17fds0V45iGE1WWHT0nXjE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter_mut_next() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        map.insert(1, "One".to_string());\n        map.insert(2, "Two".to_string());\n        \n        let mut iter = map.iter_mut();\n\n        if let Some((k, v)) = iter.next() {\n            assert_eq!(*k, 1);\n            v.push_str(" Modified");\n        }\n\n        if let Some((k, v)) = iter.next() {\n            assert_eq!(*k, 2);\n            v.push_str(" Modified");\n        }\n\n        assert_eq!(iter.next(), None);\n        assert_eq!(map.get(&1).unwrap(), "One Modified");\n        assert_eq!(map.get(&2).unwrap(), "Two Modified");\n    }\n\n    #[test]\n    fn test_iter_mut_empty() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        let mut iter = map.iter_mut();\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_mut_fused() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        map.insert(1, "One".to_string());\n        let mut iter = map.iter_mut();\n        assert!(iter.next().is_some());\n        assert!(iter.next().is_none());\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579600, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=326, prompt_tokens=9857, total_tokens=10183, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclirpP85MPE8jEZMCKDdnKGedrXn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        map.insert(1, "One".to_owned());\n        map.insert(2, "Two".into());\n        \n        let mut iter = map.iter_mut();\n        assert_eq!(iter.size_hint(), (2, Some(2)));\n\n        iter.next();\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n\n        iter.next();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n\n        assert_eq!(iter.size_hint(), (0, Some(0))); // Ensure it remains the same after exhausting the iterator\n    }\n\n    #[test]\n    fn test_empty_size_hint() {\n        let map: HashMap<i32, String> = HashMap::new();\n        let iter = map.iter_mut();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579609, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=221, prompt_tokens=9801, total_tokens=10022, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcliypVtMABXwHYtlM5gl2aAn8UF3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_clone() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let keys = map.keys();\n        let cloned_keys = keys.clone();\n\n        let mut keys_vec: Vec<_> = keys.collect();\n        let mut cloned_keys_vec: Vec<_> = cloned_keys.collect();\n\n        keys_vec.sort_unstable();\n        cloned_keys_vec.sort_unstable();\n\n        assert_eq!(keys_vec, cloned_keys_vec);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579616, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=152, prompt_tokens=10480, total_tokens=10632, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclj6bl25OsAZ1e7WadP9xJNohXIA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_default() {\n        let default_keys: Keys<i32, i32> = Keys::default();\n        assert_eq!(default_keys.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_default() {\n        let default_iter: Iter<i32, i32> = Iter::default();\n        assert_eq!(default_iter.len(), 0);\n    }\n\n    #[test]\n    fn test_map_keys() {\n        let map: HashMap<i32, i32> = [(1, 10), (2, 20), (3, 30)].iter().cloned().collect();\n        let mut keys = map.keys();\n        let mut collected_keys: Vec<_> = keys.by_ref().collect();\n        collected_keys.sort();\n        assert_eq!(collected_keys, vec![&1, &2, &3]);\n        assert!(keys.next().is_none());\n    }\n\n    #[test]\n    fn test_map_iter() {\n        let map: HashMap<i32, i32> = [(1, 10), (2, 20), (3, 30)].iter().cloned().collect();\n        let mut iter = map.iter();\n        let mut collected_items: Vec<_> = iter.by_ref().collect();\n        collected_items.sort();\n        assert_eq!(collected_items, vec![(&1, &10), (&2, &20), (&3, &30)]);\n        assert!(iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579624, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=331, prompt_tokens=10478, total_tokens=10809, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcljGQNfwT8ALLtH2gm949peiGpqv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_len() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let keys = map.keys();\n        assert_eq!(keys.len(), 3);\n\n        let empty_map: HashMap<u32, &str> = HashMap::new();\n        let empty_keys = empty_map.keys();\n        assert_eq!(empty_keys.len(), 0);\n    }\n\n    #[test]\n    fn test_keys_len_after_iterating() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n\n        let mut keys = map.keys();\n        keys.next(); // Iterate once\n        assert_eq!(keys.len(), 2);\n        keys.next(); // Iterate again\n        assert_eq!(keys.len(), 1);\n        keys.next(); // Iterate again\n        assert_eq!(keys.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579634, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=250, prompt_tokens=10475, total_tokens=10725, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcljNlrGT02DWjOKkikiiyawAVNtj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_fold() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let keys = map.keys();\n        let result = keys.fold(0, |acc, &key| acc + key);\n        \n        assert_eq!(result, 6); // 1 + 2 + 3 = 6\n    }\n\n    #[test]\n    fn test_keys_fold_with_identity() {\n        let map: HashMap<u32, &str> = HashMap::new();\n        let keys = map.keys();\n        \n        let result = keys.fold(10, |acc, &key| acc + key);\n        \n        assert_eq!(result, 10); // no keys, should return the initial value\n    }\n\n    #[test]\n    fn test_keys_fold_with_no_keys() {\n        let map: HashMap<u32, &str> = HashMap::new();\n        \n        let keys = map.keys();\n        let result = keys.fold(100, |acc, &key| acc + key);\n        \n        assert_eq!(result, 100); // no keys, should return the initial value\n    }\n\n    #[test]\n    fn test_keys_fold_with_one_key() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(5, "a");\n        \n        let keys = map.keys();\n        let result = keys.fold(0, |acc, &key| acc + key);\n        \n        assert_eq!(result, 5); // only one key, the result should be the key itself\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579641, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=387, prompt_tokens=10522, total_tokens=10909, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcljW1Cjt1hgfB0wIPP38ZBooOTDT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_next() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let mut keys = map.keys();\n        let mut vec = vec![keys.next(), keys.next(), keys.next()];\n\n        // The `Keys` iterator produces keys in arbitrary order, so the\n        // keys must be sorted to test them against a sorted array.\n        vec.sort_unstable();\n        assert_eq!(vec, [Some(&1), Some(&2), Some(&3)]);\n    }\n\n    #[test]\n    fn test_keys_next_fused() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        let mut keys = map.keys();\n        \n        // Consuming the keys\n        assert_eq!(keys.next(), Some(&1));\n        assert_eq!(keys.next(), None);\n        assert_eq!(keys.next(), None);\n    }\n\n    #[test]\n    fn test_keys_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let mut keys = map.keys();\n        \n        assert_eq!(keys.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579650, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=300, prompt_tokens=10514, total_tokens=10814, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcljfHxERp4ybzudO6F41mDCx0QGU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let keys = map.keys();\n        let (lower, upper) = keys.size_hint();\n        \n        assert_eq!(lower, 3);\n        assert_eq!(upper, Some(3));\n    }\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let keys = map.keys();\n        let (lower, upper) = keys.size_hint();\n        \n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579659, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=193, prompt_tokens=10484, total_tokens=10677, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcljn3MgsP8B4gwygGVkp6DBPIxZn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn clone_values_test() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n\n        let values = map.values();\n        let cloned_values = values.clone();\n\n        assert_eq!(values.len(), cloned_values.len());\n        for (v1, v2) in values.zip(cloned_values) {\n            assert_eq!(v1, v2);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579667, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=138, prompt_tokens=10481, total_tokens=10619, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcljtD686xw8DnxutqHG6G8lR5qj2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_default() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let values: Values<i32, i32> = Values::default();\n        assert_eq!(values.len(), 0);\n    }\n\n    #[test]\n    fn test_values_iterate_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let values: Values<i32, i32> = map.values();\n\n        let mut collected: Vec<_> = values.collect();\n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_values_iterate_single() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        let values: Values<i32, i32> = map.values();\n\n        let mut collected: Vec<_> = values.collect();\n        collected.sort();\n        assert_eq!(collected, vec![&10]);\n    }\n\n    #[test]\n    fn test_values_iterate_multiple() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        let values: Values<i32, i32> = map.values();\n\n        let mut collected: Vec<_> = values.collect();\n        collected.sort();\n        assert_eq!(collected, vec![&10, &20, &30]);\n    }\n\n    #[test]\n    fn test_values_clone() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        let values: Values<i32, i32> = map.values();\n        let cloned_values = values.clone();\n\n        let mut collected: Vec<_> = cloned_values.collect();\n        collected.sort();\n        assert_eq!(collected, vec![&10]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579673, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=438, prompt_tokens=10479, total_tokens=10917, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclk3qhx5bSxMO6Dja61KU56E41Hp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_len_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let values: Values<i32, i32> = map.values();\n        assert_eq!(values.len(), 0);\n    }\n\n    #[test]\n    fn test_len_non_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        let values: Values<i32, i32> = map.values();\n        assert_eq!(values.len(), 3);\n    }\n\n    #[test]\n    fn test_len_after_modification() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let mut values: Values<i32, i32> = map.values();\n        assert_eq!(values.len(), 2);\n        map.remove(&1);\n        assert_eq!(values.len(), 2); // Length should not change after modifying the map\n    }\n\n    #[test]\n    fn test_len_clone() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        let values: Values<i32, i32> = map.values();\n        let values_clone = values.clone();\n        assert_eq!(values.len(), values_clone.len());\n    }\n\n    #[test]\n    fn test_len_large_map() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        for i in 0..1000 {\n            map.insert(i, i * 10);\n        }\n        let values: Values<i32, i32> = map.values();\n        assert_eq!(values.len(), 1000);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579683, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=434, prompt_tokens=10476, total_tokens=10910, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclkFUybZ25QQ7G9QPMrzegMUEOog', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_fold() {\n        let map: HashMap<i32, i32> = [(1, 1), (2, 2), (3, 3)].iter().cloned().collect();\n        let values = map.values();\n\n        let sum = values.fold(0, |acc, &value| acc + value);\n        assert_eq!(sum, 6);\n    }\n\n    #[test]\n    fn test_fold_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let values = map.values();\n\n        let sum = values.fold(0, |acc, &value| acc + value);\n        assert_eq!(sum, 0);\n    }\n\n    #[test]\n    fn test_fold_with_initial_value() {\n        let map: HashMap<i32, i32> = [(1, 1), (2, 2)].iter().cloned().collect();\n        let values = map.values();\n\n        let sum = values.fold(10, |acc, &value| acc + value);\n        assert_eq!(sum, 13);\n    }\n\n    #[test]\n    fn test_fold_with_identity() {\n        let map: HashMap<i32, i32> = [(1, 1), (2, 2), (3, 3)].iter().cloned().collect();\n        let values = map.values();\n\n        let identity = values.fold(1, |acc, &value| acc * value);\n        assert_eq!(identity, 6);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579695, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=344, prompt_tokens=10521, total_tokens=10865, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclkksf70i3M03cmVDKSSrkLPvfcr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_next() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let mut values_iter = map.values();\n        let mut results = vec![values_iter.next(), values_iter.next(), values_iter.next()];\n\n        results.sort_unstable();\n        assert_eq!(results, vec![Some(&"a"), Some(&"b"), Some(&"c")]);\n\n        assert_eq!(values_iter.next(), None);\n        assert_eq!(values_iter.next(), None);\n    }\n\n    #[test]\n    fn test_values_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let mut values_iter = map.values();\n\n        assert_eq!(values_iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579726, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=212, prompt_tokens=10514, total_tokens=10726, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclkqz6KgD9kntjQy6CR2KlXma3a1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let values = map.values();\n        assert_eq!(values.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let map: HashMap<i32, &str> = [(1, "a"), (2, "b"), (3, "c")].into();\n        let values = map.values();\n        assert_eq!(values.size_hint(), (3, Some(3)));\n    }\n\n    #[test]\n    fn test_size_hint_after_consuming() {\n        let mut map: HashMap<i32, &str> = [(1, "a"), (2, "b"), (3, "c")].into();\n        let mut values = map.values();\n        assert_eq!(values.size_hint(), (3, Some(3)));\n        values.next(); // Consume one\n        assert_eq!(values.size_hint(), (2, Some(2)));\n        values.next(); // Consume another\n        assert_eq!(values.size_hint(), (1, Some(1)));\n        values.next(); // Consume the last\n        assert_eq!(values.size_hint(), (0, Some(0)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579732, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=293, prompt_tokens=10485, total_tokens=10778, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclkyYwvPqA8bLeehy8i09ye8nTfm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_mut_default() {\n        let default_values: ValuesMut<i32, i32> = ValuesMut::default();\n        assert_eq!(default_values.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_mut_default() {\n        let default_iter_mut: IterMut<i32, i32> = IterMut::default();\n        assert_eq!(default_iter_mut.len(), 0);\n    }\n\n    #[test]\n    fn test_raw_iter_default() {\n        let default_raw_iter: RawIter<i32> = RawIter::default();\n        assert_eq!(default_raw_iter.len(), 0);\n    }\n\n    #[test]\n    fn test_raw_iter_range_default() {\n        let default_raw_iter_range: RawIterRange<i32> = RawIterRange::default();\n        assert_eq!(default_raw_iter_range.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_bucket_clone() {\n        let bucket = Bucket::from_base_index(NonNull::new(0x1 as *mut i32).unwrap(), 0);\n        let cloned_bucket = bucket.clone();\n        assert_eq!(bucket.ptr, cloned_bucket.ptr);\n    }\n\n    #[test]\n    fn test_bitmask_default() {\n        let default_bitmask: BitMask = BitMask(0);\n        assert_eq!(default_bitmask.0, 0);\n    }\n\n    #[test]\n    fn test_bitmask_iter_next() {\n        let bitmask = BitMask(0b1010);\n        let mut iter = BitMaskIter(bitmask);\n        assert_eq!(iter.next(), Some(1));\n        assert_eq!(iter.next(), Some(3));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_bitmask_iter_clone() {\n        let bitmask = BitMask(0b1100);\n        let mut iter = BitMaskIter(bitmask);\n        let cloned_iter = iter.clone();\n        assert_eq!(iter.0.0, cloned_iter.0.0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579740, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=446, prompt_tokens=10511, total_tokens=10957, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllB8AziU91FPrUQ3BVIGzALIIrX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_mut_len() {\n        let mut map: HashMap<_, _> = [(1, "One"), (2, "Two"), (3, "Three")].iter().cloned().collect();\n\n        let values_mut = map.values_mut();\n        assert_eq!(values_mut.len(), 3);\n\n        let mut values_mut_iter = values_mut;\n        values_mut_iter.next();\n        assert_eq!(values_mut_iter.len(), 2);\n\n        values_mut_iter.next();\n        assert_eq!(values_mut_iter.len(), 1);\n\n        values_mut_iter.next();\n        assert_eq!(values_mut_iter.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579753, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=160, prompt_tokens=10508, total_tokens=10668, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllHfarDb90E02Ml9BqYo0iGbTR2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n    use crate::control::bitmask::BitMask;\n    use crate::control::bitmask::BitMaskIter;\n    use crate::map::ValuesMut;\n\n    #[test]\n    fn test_fold_values_mut() {\n        let mut map = HashMap::new();\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.insert(3, 3);\n\n        let mut values = ValuesMut {\n            inner: map.iter_mut(),\n        };\n\n        // Fold to sum the values\n        let sum = values.fold(0, |acc, &mut v| acc + v);\n        assert_eq!(sum, 6);\n    }\n\n    #[test]\n    fn test_fold_with_empty_values_mut() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n\n        let values = ValuesMut {\n            inner: map.iter_mut(),\n        };\n\n        // Fold with an empty map\n        let sum = values.fold(0, |acc, &mut _v| acc + 0);\n        assert_eq!(sum, 0);\n    }\n\n    #[test]\n    fn test_fold_with_identity_function() {\n        let mut map = HashMap::new();\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.insert(3, 3);\n\n        let values = ValuesMut {\n            inner: map.iter_mut(),\n        };\n\n        // Folding with an identity function\n        let result = values.fold(1, |acc, &mut v| acc * v);\n        assert_eq!(result, 6);\n    }\n\n    #[test]\n    fn test_fold_with_specific_logic() {\n        let mut map = HashMap::new();\n        map.insert(1, 2);\n        map.insert(2, 3);\n        map.insert(3, 4);\n\n        let values = ValuesMut {\n            inner: map.iter_mut(),\n        };\n\n        // Fold to count number of values that are greater than 2\n        let count = values.fold(0, |acc, &mut v| {\n            if *v > 2 {\n                acc + 1\n            } else {\n                acc\n            }\n        });\n        assert_eq!(count, 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579759, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=488, prompt_tokens=10553, total_tokens=11041, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllTEckLAvEUoGH0N00OMrmmXRMi', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_mut_next() {\n        let mut map: HashMap<_, _> = [(1, "One".to_owned()), (2, "Two".to_owned())].into();\n        let mut values = map.values_mut();\n\n        assert_eq!(values.next().map(|v| *v), Some("One".to_owned()));\n        assert_eq!(values.next().map(|v| *v), Some("Two".to_owned()));\n        assert_eq!(values.next(), None);\n    }\n\n    #[test]\n    fn test_values_mut_next_multiple() {\n        let mut map: HashMap<_, _> = [(1, "One".to_owned()), (2, "Two".to_owned()), (3, "Three".to_owned())].into();\n        let mut values = map.values_mut();\n\n        let first_value = values.next().map(|v| v.push_str(" Modified"));\n        let second_value = values.next().map(|v| v.push_str(" Modified"));\n        let third_value = values.next().map(|v| v.push_str(" Modified"));\n\n        assert!(first_value.is_some());\n        assert!(second_value.is_some());\n        assert!(third_value.is_some());\n\n        assert_eq!(map.get(&1).unwrap(), &"One Modified".to_owned());\n        assert_eq!(map.get(&2).unwrap(), &"Two Modified".to_owned());\n        assert_eq!(map.get(&3).unwrap(), &"Three Modified".to_owned());\n    }\n\n    #[test]\n    fn test_values_mut_next_empty() {\n        let mut map: HashMap<_, _> = HashMap::new();\n        let mut values = map.values_mut();\n\n        assert_eq!(values.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579771, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=378, prompt_tokens=10547, total_tokens=10925, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllecsifL6fZJ2hZ65Nm1tLF9SW6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_mut_size_hint() {\n        let mut map: HashMap<i32, String> = HashMap::new();\n        map.insert(1, "One".to_string());\n        map.insert(2, "Two".to_string());\n        \n        let values_mut = map.values_mut();\n        \n        // Check initial size_hint\n        let (lower, upper) = values_mut.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n\n        // Consume some values\n        let _ = values_mut.next();\n        \n        // Check size_hint after consuming one value\n        let (lower, upper) = values_mut.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n\n        // Consume all values\n        let _ = values_mut.next();\n        \n        // Check size_hint after consuming all values\n        let (lower, upper) = values_mut.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579782, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=245, prompt_tokens=10517, total_tokens=10762, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllmCBWMyRkms40aVLmnFaE6YJFE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_clone() {\n        // Create a new Bucket with a dummy pointer\n        let value: i32 = 42;\n        let non_null_ptr = NonNull::new(&value as *const i32 as *mut i32).unwrap();\n        let bucket = Bucket { ptr: non_null_ptr };\n\n        // Clone the bucket\n        let cloned_bucket = bucket.clone();\n\n        // Verify that the cloned bucket points to the same memory\n        assert_eq!(bucket.ptr.as_ptr(), cloned_bucket.ptr.as_ptr());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579790, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=137, prompt_tokens=4569, total_tokens=4706, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcllqdL6yKu8uMN5NTlhm738JzYLA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::{BitMask, BitMaskIter};\n\n    #[test]\n    fn test_full_buckets_indices() {\n        // Assuming we have a way to create a `FullBucketsIndices` instance.\n        // Initialize necessary state for `FullBucketsIndices`.\n        let bitmask_word = 0b101101; // Example bitmask\n        let bitmask = BitMask(bitmask_word);\n        let mut bitmask_iter = bitmask.into_iter();\n\n        let mut full_buckets_indices = FullBucketsIndices {\n            current_group: bitmask_iter,\n            group_first_index: 0,\n            ctrl: NonNull::new(0 as *mut u8).unwrap(),\n            items: bitmask.0.count_ones() as usize, // Number of full buckets available\n        };\n\n        // Collect all indices yielded by the iterator\n        let mut indices = Vec::new();\n        while let Some(index) = full_buckets_indices.next() {\n            indices.push(index);\n        }\n\n        // Expected indices based on the provided bitmask.\n        let expected_indices = vec![0, 2, 4]; // Example expected output based on the bitmask\n\n        assert_eq!(indices, expected_indices);\n    }\n\n    #[test]\n    fn test_full_buckets_indices_empty() {\n        let bitmask = BitMask(0); // No bits set\n        let mut bitmask_iter = bitmask.into_iter();\n\n        let mut full_buckets_indices = FullBucketsIndices {\n            current_group: bitmask_iter,\n            group_first_index: 0,\n            ctrl: NonNull::new(0 as *mut u8).unwrap(),\n            items: 0,\n        };\n\n        assert!(full_buckets_indices.next().is_none());\n    }\n\n    #[test]\n    fn test_full_buckets_indices_decrement_items() {\n        let bitmask_word = 0b111; // Example bitmask with all bits set\n        let bitmask = BitMask(bitmask_word);\n        let mut bitmask_iter = bitmask.into_iter();\n\n        let mut full_buckets_indices = FullBucketsIndices {\n            current_group: bitmask_iter,\n            group_first_index: 0,\n            ctrl: NonNull::new(0 as *mut u8).unwrap(),\n            items: 3,\n        };\n\n        full_buckets_indices.next(); // should yield Some\n        assert_eq!(full_buckets_indices.items, 2); // items should be decremented\n        full_buckets_indices.next(); // should yield Some\n        assert_eq!(full_buckets_indices.items, 1); // items should be decremented\n        full_buckets_indices.next(); // should yield Some\n        assert_eq!(full_buckets_indices.items, 0); // items should be decremented\n        assert!(full_buckets_indices.next().is_none()); // No more items\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579794, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=601, prompt_tokens=2589, total_tokens=3190, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclm2H0Myy9caMpiSPrX8QzcAdIr4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_size_hint() {\n        // Create an instance of FullBucketsIndices with a known number of items\n        let items = 10; // Example number of items\n        let bitmask_iter = BitMaskIter(BitMask(0b1111111111)); // Example bitmask with all bits set\n        let group_first_index = 0; // Example index\n        let ctrl = NonNull::new(Box::into_raw(Box::new([0u8; 8]))).unwrap(); // Example pointer\n        let mut full_buckets_indices = FullBucketsIndices {\n            current_group: bitmask_iter,\n            group_first_index,\n            ctrl,\n            items,\n        };\n\n        // Get the size hint\n        let hint = full_buckets_indices.size_hint();\n\n        // Assert that the size hint matches the expected values\n        assert_eq!(hint, (items, Some(items)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579806, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=204, prompt_tokens=2460, total_tokens=2664, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclmAKk5I1K8ak84X9ugzKpu3nEIz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_drain_next() {\n        // Setup\n        let allocator = Global;\n        let mut table = RawTableInner::with_capacity(&allocator, Layout::from_size_align(32, 8).unwrap(), 4);\n        \n        // Simulate inserting elements into table (unsafe to be done directly)\n        let buckets = table.bucket_mask + 1; // Calculate number of buckets\n        for i in 0..buckets {\n            unsafe {\n                let bucket = Bucket::from_base_index(NonNull::new_unchecked(std::ptr::NonNull::dangling().as_ptr().add(i)), i);\n                // Here you would add the bucket into the table (mock insertion)\n            }\n        }\n        \n        // Create RawDrain\n        let orig_table = NonNull::new(&table).unwrap();\n        let drain = RawDrain {\n            iter: RawIter::default(), // This would be set to the appropriate RawIter\n            table, \n            orig_table, \n            marker: PhantomData,\n        };\n\n        // Testing the `next` method of `RawDrain`\n        let mut drain_iter = drain;\n\n        // Check the first next call\n        let first_item = drain_iter.next();\n        assert!(first_item.is_some());\n        // Validate the first item was correctly read (mock check)\n        // let value = first_item.unwrap();\n        // assert_eq!(value, /* expected value */);\n        \n        // Check the next one\n        let second_item = drain_iter.next();\n        assert!(second_item.is_some());\n        // Validate the second item was correctly read (mock check)\n        // let value = second_item.unwrap();\n        // assert_eq!(value, /* expected value */);\n        \n        // Continue until it returns None\n        while let Some(_) = drain_iter.next() {};\n\n        // Final check for None\n        assert!(drain_iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579814, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=419, prompt_tokens=16361, total_tokens=16780, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclmJWZ4TUlaNKkeoQ9Tu6mYwbP9X', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_size_hint_with_items() {\n        // Setting up a mock RawDrain\n        let mut raw_drain: RawDrain<i32, Global> = {\n            let table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 8, Fallibility::Infallible).unwrap();\n            let iter = RawIter::default();\n            RawDrain {\n                iter,\n                table,\n                orig_table: NonNull::new(&table).unwrap(),\n                marker: PhantomData\n            }\n        };\n\n        // Assuming some elements have been inserted\n        raw_drain.iter.items = 4; // Simulate 4 items to drain\n        let (lower, upper) = raw_drain.size_hint();\n        \n        // Expect to see the correct size hint\n        assert_eq!(lower, 4);\n        assert_eq!(upper, Some(4));\n    }\n\n    #[test]\n    fn test_size_hint_no_items() {\n        // Setting up a mock RawDrain\n        let mut raw_drain: RawDrain<i32, Global> = {\n            let table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 8, Fallibility::Infallible).unwrap();\n            let iter = RawIter::default();\n            RawDrain {\n                iter,\n                table,\n                orig_table: NonNull::new(&table).unwrap(),\n                marker: PhantomData\n            }\n        };\n\n        // Simulate no items to drain\n        raw_drain.iter.items = 0; // Simulate 0 items to drain\n        let (lower, upper) = raw_drain.size_hint();\n        \n        // Expect to see (0, Some(0)) hint\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579823, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=398, prompt_tokens=16361, total_tokens=16759, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclmVr0NY8oxCvyTBOORei4UwWH2E', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n    \n    struct TestAllocator;\n    impl Allocator for TestAllocator {\n        // Implementation of Allocator methods\n    }\n\n    #[test]\n    fn test_raw_drain_drop() {\n        let allocator = TestAllocator;\n        let mut table = unsafe {\n            RawTableInner::new_uninitialized(&allocator, /* table layout */, /* buckets */)\n                .unwrap()\n        };\n\n        let table_ptr = NonNull::new(&mut table).unwrap();\n        let raw_drain = RawDrain {\n            iter: RawIter::default(),\n            table,\n            orig_table: table_ptr,\n            marker: PhantomData,\n        };\n\n        // When `raw_drain` goes out of scope, `drop` should be called\n        // and we can assert that the elements have been dropped correctly.\n        // This can be done by asserting that the table is now empty or\n        // check for specific conditions based on `Drop` implementation.\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579835, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=216, prompt_tokens=16361, total_tokens=16577, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclmc4yAq0FevuGzGH9YCmm4YBEca', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_into_iter_default() {\n        let iter: RawIntoIter<i32, Global> = RawIntoIter::default();\n        assert!(iter.allocation.is_none());\n        assert_eq!(iter.marker, PhantomData::<i32>);\n\n        let iter_default = RawIter::<i32>::default();\n        assert_eq!(iter.iter, iter_default);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579842, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=104, prompt_tokens=9416, total_tokens=9520, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclmktvyTVqRMG1UlF2X5CJdbr8IJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_into_iter_next() {\n        unsafe {\n            // Set up raw table and iter\n            let items = vec![1, 2, 3, 4, 5];\n            let layout = std::alloc::Layout::array::<i32>(items.len()).unwrap();\n            let ptr = NonNull::new(std::alloc::alloc(layout)).unwrap();\n\n            // Initialize the allocated memory\n            for (i, &item) in items.iter().enumerate() {\n                ptr.as_ptr().add(i).write(item);\n            }\n\n            let mut iter = RawIntoIter {\n                iter: RawIter {\n                    iter: RawIterRange::new(ptr.as_ptr() as *const u8, Bucket::<i32>::from_base_index(ptr, items.len()), items.len()),\n                    items: items.len(),\n                },\n                allocation: Some((ptr.cast(), layout, Global)),\n                marker: PhantomData,\n            };\n\n            // Collect all items using next\n            let mut collected: Vec<i32> = Vec::new();\n            while let Some(item) = iter.next() {\n                collected.push(item);\n            }\n\n            // Verify all items were collected\n            assert_eq!(collected, items);\n\n            // Clean up\n            std::alloc::dealloc(ptr.as_ptr(), layout);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579850, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=307, prompt_tokens=9410, total_tokens=9717, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclmrxiyEdJ4ma4RhbaQZN2eMwqAD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_size_hint() {\n        let bitmask = BitMask(0b1100);\n        let iter = BitMaskIter(bitmask);\n        \n        let raw_into_iter: RawIntoIter<u32> = RawIntoIter::default(); // Assuming default initializes a valid RawIntoIter\n\n        // Assuming RawIter has been properly initialized\n        raw_into_iter.iter = RawIter {\n            iter: RawIterRange::new(std::ptr::null(), Bucket { ptr: NonNull::dangling() }, 0), // Replace with real initialization\n            items: 4, // Set a known number of items\n        };\n\n        let (lower, upper) = raw_into_iter.size_hint();\n        assert_eq!(lower, 4);\n        assert_eq!(upper, Some(4));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579857, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=193, prompt_tokens=9413, total_tokens=9606, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclmx7gnJQiQmZSa1ZthuIBcyKdls', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_raw_into_iter_drop() {\n        // Create an instance of RawIntoIter\n        let allocator = System;\n        let mut iter: RawIntoIter<i32, System> = RawIntoIter::default();\n        // You would typically populate `iter` with data here, but we are\n        // testing drop, so we will just drop it.\n\n        // Ensure drop doesn't panic and correctly deallocates\n        // Creating and dropping multiple instances to check for proper allocation/deallocation\n        {\n            let mut iter1 = RawIntoIter::default();\n            let mut iter2 = RawIntoIter::default();\n            // We can simulate the iter's lifecycle here\n            std::mem::drop(iter1);\n            std::mem::drop(iter2);\n            // No panic should occur; the deallocation should occur safely\n        }\n    }\n\n    #[test]\n    fn test_raw_into_iter_drop_elements() {\n        // Create an instance of RawIntoIter with elements\n        let allocator = System;\n        let mut iter: RawIntoIter<i32, System> = RawIntoIter::default();\n        \n        // Here we would simulate the process of the iterator containing elements\n        // For testing, just invoke drop_elements method\n        unsafe {\n            iter.iter.drop_elements();\n        }\n        // Drop the iterator to check for potential panics\n        std::mem::drop(iter);\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579863, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=313, prompt_tokens=9446, total_tokens=9759, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcln6zdA219P9trZjl6YTYQFi03ru', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_clone() {\n        // Create a dummy bucket\n        let dummy_bucket = unsafe { Bucket::from_base_index(NonNull::dangling(), 0) };\n        \n        // Create a RawIterRange\n        let raw_iter_range = RawIterRange {\n            current_group: BitMaskIter(BitMask(0)), // dummy implementation\n            data: dummy_bucket,\n            next_ctrl: core::ptr::null(),\n            end: core::ptr::null(),\n        };\n        \n        // Create a RawIter\n        let raw_iter = RawIter {\n            iter: raw_iter_range,\n            items: 1,\n        };\n        \n        // Clone the RawIter\n        let cloned_iter = raw_iter.clone();\n\n        // Assert that items are equal\n        assert_eq!(raw_iter.items, cloned_iter.items);\n\n        // Assert that iter's data are equal (for the sake of example, we will compare pointers)\n        assert_eq!(raw_iter.iter.data.as_ptr(), cloned_iter.iter.data.as_ptr());\n    }\n\n    #[test]\n    fn test_raw_iter_range_clone() {\n        // Create a dummy bucket\n        let dummy_bucket = unsafe { Bucket::from_base_index(NonNull::dangling(), 0) };\n        \n        // Create a RawIterRange\n        let raw_iter_range = RawIterRange {\n            current_group: BitMaskIter(BitMask(0)), // dummy implementation\n            data: dummy_bucket,\n            next_ctrl: core::ptr::null(),\n            end: core::ptr::null(),\n        };\n        \n        // Clone the RawIterRange\n        let cloned_range = raw_iter_range.clone();\n\n        // Assert that next_ctrl pointers are equal\n        assert_eq!(raw_iter_range.next_ctrl, cloned_range.next_ctrl);\n\n        // Assert that end pointers are equal\n        assert_eq!(raw_iter_range.end, cloned_range.end);\n\n        // Assert that the data bucket pointers are equal\n        assert_eq!(raw_iter_range.data.as_ptr(), cloned_range.data.as_ptr());\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579872, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=439, prompt_tokens=8889, total_tokens=9328, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclnI3v8ZcZxD6sR4qFAHP0zd1jqH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_default() {\n        // Create a RawIter for a specific type, for example i32\n        let raw_iter: RawIter<i32> = RawIter::default();\n\n        // Ensure that the iterator is not null, meaning it has been properly initialized\n        // (depending on the internal state of RawTableInner::NEW, this may vary).\n        // This is a placeholder for actual checks, in a real test you would\n        // need to ensure that it is indeed a valid initialized iterator.\n        assert!(unsafe { raw_iter.iter.data.ptr.as_ref() }.is_valid_pointer()); // Placeholder\n\n        // Also you may want to check specific properties of the iterator\n        // for the RawIter that reflects your expected behavior of the iterator.\n        assert_eq!(raw_iter.items, expected_number_of_items()); // Placeholder for actual count check\n    }\n\n    fn expected_number_of_items() -> usize {\n        // This function would return the expected number of items\n        // that the RawIter should contain. This might need to be\n        // determined based on the context of the tested RawTable.\n        0 // Placeholder\n    }\n\n    trait ValidPointer {\n        fn is_valid_pointer(&self) -> bool;\n    }\n\n    impl<T> ValidPointer for Bucket<T> {\n        fn is_valid_pointer(&self) -> bool {\n            // Placeholder method, you may want to implement your logic\n            // for validating the state of the Bucket. For instance, check\n            // that the pointer isn't dangling.\n            true // Placeholder, actual logic should check the pointer\n        }\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579884, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=358, prompt_tokens=8899, total_tokens=9257, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclnSQ5ZPPaFTYCCHn71PzHgCydYM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\nuse hashbrown::raw::{RawIter, Bucket};\nuse hashbrown::control::bitmask::{BitMask, BitMaskIter};\nuse std::ptr::NonNull;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_fold_with_empty_iterator() {\n        let bitmask = BitMask(0);\n        let bucket = Bucket { ptr: NonNull::dangling() };\n        let raw_iter = RawIter {\n            iter: RawIterRange {\n                current_group: bitmask.into_iter(),\n                data: bucket,\n                next_ctrl: std::ptr::null(),\n                end: std::ptr::null(),\n            },\n            items: 0,\n        };\n        \n        let result: usize = raw_iter.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_fold_with_single_element() {\n        let mock_bucket = Bucket { ptr: NonNull::from(&0) };\n        let bitmask = BitMask(1);\n        let raw_iter = RawIter {\n            iter: RawIterRange {\n                current_group: bitmask.into_iter(),\n                data: mock_bucket,\n                next_ctrl: std::ptr::null(),\n                end: std::ptr::null(),\n            },\n            items: 1,\n        };\n        \n        let result: usize = raw_iter.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 1);\n    }\n\n    #[test]\n    fn test_fold_with_multiple_elements() {\n        let mock_bucket1 = Bucket { ptr: NonNull::from(&1) };\n        let mock_bucket2 = Bucket { ptr: NonNull::from(&2) };\n        let bitmask = BitMask(0b11); // Two buckets\n        let iter = BitMaskIter(bitmask);\n        \n        let raw_iter = RawIter {\n            iter: RawIterRange {\n                current_group: iter,\n                data: mock_bucket1,\n                next_ctrl: std::ptr::null(),\n                end: std::ptr::null(),\n            },\n            items: 2,\n        };\n        \n        let result: usize = raw_iter.fold(0, |acc, _| acc + 2);\n        assert_eq!(result, 2 + 2); // 2 for each bucket\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579894, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=492, prompt_tokens=8920, total_tokens=9412, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclnbiQQCZTrCfjgPaBk9JAfrUPIU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_next() {\n        // Setup a RawIter with known values\n        let items = 3; // Number of items to yield\n        let base_ptr = NonNull::new(Box::into_raw(Box::new(0u8))).unwrap(); // Points to 0u8\n        let bucket = unsafe { Bucket::from_base_index(base_ptr, 0) }; // Create a bucket\n        let iter_range = unsafe { RawIterRange::new(std::ptr::null(), bucket, items) }; // Create RawIterRange\n        let mut raw_iter = RawIter { iter: iter_range, items }; // Create RawIter\n\n        // Test the first call to next\n        let first = raw_iter.next();\n        assert!(first.is_some(), "Expected some Bucket on the first call to next");\n\n        // Test the second call to next\n        let second = raw_iter.next();\n        assert!(second.is_some(), "Expected some Bucket on the second call to next");\n\n        // Test the third call to next\n        let third = raw_iter.next();\n        assert!(third.is_some(), "Expected some Bucket on the third call to next");\n\n        // Test the fourth call to next\n        let fourth = raw_iter.next();\n        assert!(fourth.is_none(), "Expected None on the fourth call to next");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579903, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=305, prompt_tokens=8967, total_tokens=9272, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclnmxth8oA37Wtmfafx9psq9wQjQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_size_hint() {\n        // Initialize a test RawIter with some items\n        let bucket = unsafe {\n            // Create a dummy bucket (unsafe for demonstration purposes)\n            let dummy: *mut usize = std::ptr::null_mut();\n            Bucket::<usize>::from_base_index(NonNull::new_unchecked(dummy), 0)\n        };\n\n        let raw_iter = RawIter {\n            iter: RawIterRange::new(std::ptr::null(), bucket, 5), // Assuming 5 items\n            items: 5,\n        };\n\n        let (lower, upper) = raw_iter.size_hint();\n        assert_eq!(lower, 5);\n        assert_eq!(upper, Some(5));\n    }\n\n    #[test]\n    fn test_raw_iter_size_hint_empty() {\n        // Initialize a RawIter with zero items\n        let bucket = unsafe {\n            let dummy: *mut usize = std::ptr::null_mut();\n            Bucket::<usize>::from_base_index(NonNull::new_unchecked(dummy), 0)\n        };\n\n        let raw_iter = RawIter {\n            iter: RawIterRange::new(std::ptr::null(), bucket, 0), // Assuming 0 items\n            items: 0,\n        };\n\n        let (lower, upper) = raw_iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579914, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=321, prompt_tokens=8890, total_tokens=9211, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclnuxMusu9KeFRUX3RibT2IqydrV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{RawIterHash, RawIterHashInner};\n    use crate::control::{bitmask::{BitMask, BitMaskIter}, group::Group, tag::Tag};\n    use std::marker::PhantomData;\n\n    #[test]\n    fn test_raw_iter_hash_clone() {\n        // Create a test instance of RawIterHash\n        let raw_iter = RawIterHash::default();\n\n        // Clone the RawIterHash\n        let cloned_iter = raw_iter.clone();\n\n        // Check that the inner components of the cloned instance are derived\n        // from the original, ensuring that cloning works correctly.\n        assert_eq!(raw_iter.inner.bucket_mask, cloned_iter.inner.bucket_mask);\n        assert_eq!(raw_iter.inner.tag_hash, cloned_iter.inner.tag_hash);\n        assert_eq!(raw_iter.inner.probe_seq.pos, cloned_iter.inner.probe_seq.pos);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579922, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=197, prompt_tokens=4610, total_tokens=4807, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclo10Tuj2L68u0GyJmeKIhZMPxR1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_iter_hash_default() {\n        let default_iter: RawIterHash<u8> = RawIterHash::default();\n        // Check if the inner bucket_mask is initialized correctly (it should be 0 in this case)\n        assert_eq!(default_iter.inner.bucket_mask, 0);\n        // Check if the tag_hash is initialized to the Tag::EMPTY\n        assert_eq!(default_iter.inner.tag_hash, Tag::EMPTY);\n        // Check if the initial position of the probe sequence is 0\n        assert_eq!(default_iter.inner.probe_seq.pos, 0);\n        // It's necessary to guarantee that `bitmask` is initialized correctly\n        assert!(default_iter.inner.bitmask.0.0 == 0);\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579929, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=181, prompt_tokens=4642, total_tokens=4823, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclo6uswCzu6hPnET80cbOhXLmwdK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{RawIterHash, RawIterHashInner};\n    use crate::control::tag::Tag;\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use crate::control::group::sse2::Group;\n    use crate::raw::ProbeSeq;\n    use std::alloc::Allocator;\n    use std::ptr::NonNull;    \n\n    #[test]\n    fn test_next() {\n        // Assume we have an appropriate setup for RawIterHash\n        unsafe {\n            let tag_hash = Tag::full(1);\n            let table = ...; // Assume table is initialized correctly\n            let mut iter = RawIterHash::new(table, 1);\n            let result = iter.next();\n            assert!(result.is_some(), "next() should return Some for a valid bucket");\n            let bucket = result.unwrap();\n            assert_eq!(bucket.tag_hash, tag_hash, "The returned bucket should have matching tag_hash");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579934, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=220, prompt_tokens=4680, total_tokens=4900, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcloDBpLgkPe0fr7NyQcOT3Kw6zGH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use crate::control::group::sse2::Group;\n    use crate::control::tag::Tag;\n    use crate::raw::{ProbeSeq, RawIterHashInner};\n\n    #[test]\n    fn test_next_with_valid_hash() {\n        // Set up a mock state for RawIterHashInner\n        let bucket_mask = 0b0000_0000_0000_1111; // Example mask\n        let mock_ctrl = NonNull::new(Box::into_raw(Box::new([Tag::EMPTY; Group::WIDTH]))).unwrap();\n        let tag_hash = Tag::full(0b0000_0000_0000_0001);\n        let probe_seq = ProbeSeq { pos: 0, stride: 1 };\n\n        let mut iter = RawIterHashInner {\n            bucket_mask,\n            ctrl: mock_ctrl,\n            tag_hash,\n            probe_seq,\n            group: Group::static_empty(),\n            bitmask: BitMaskIter(BitMask(0b0000_0000_0000_0011)), // Bits for the first two indices\n        };\n\n        let index1 = iter.next();\n        assert_eq!(index1, Some(1)); // Should return first valid index\n        \n        let index2 = iter.next();\n        assert_eq!(index2, Some(0)); // Should return second valid index\n        \n        let index3 = iter.next();\n        assert_eq!(index3, None); // No more valid indices\n    }\n\n    #[test]\n    fn test_next_with_empty_group() {\n        // Set up a mock state for RawIterHashInner with an empty group\n        let bucket_mask = 0b0000_0000_0000_1111; // Example mask\n        let mock_ctrl = NonNull::new(Box::into_raw(Box::new([Tag::EMPTY; Group::WIDTH]))).unwrap();\n        let tag_hash = Tag::full(0b0000_0000_0000_0001);\n        let probe_seq = ProbeSeq { pos: 0, stride: 1 };\n\n        let mut iter = RawIterHashInner {\n            bucket_mask,\n            ctrl: mock_ctrl,\n            tag_hash,\n            probe_seq,\n            group: Group::static_empty(),\n            bitmask: BitMaskIter(BitMask(0)), // No bits set\n        };\n\n        let index = iter.next();\n        assert_eq!(index, None); // Should return None as the group is empty\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579941, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=541, prompt_tokens=4159, total_tokens=4700, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcloVrEy24Id1Oc0imA1WrdiaI00x', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use crate::raw::{Bucket, RawIterRange};\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_range_clone() {\n        let bitmask = BitMask(0b1010); // Example bitmask\n        let bitmask_iter = BitMaskIter(bitmask);\n        let bucket = Bucket { ptr: NonNull::dangling() }; // Example bucket\n        let ctrl: *const u8 = std::ptr::null(); // Example control pointer\n        let end: *const u8 = std::ptr::null(); // Example end pointer\n        \n        // Create original RawIterRange\n        let original = RawIterRange {\n            current_group: bitmask_iter,\n            data: bucket,\n            next_ctrl: ctrl,\n            end,\n        };\n\n        // Clone the original RawIterRange\n        let cloned = original.clone();\n\n        // Assert properties to verify the clone\n        assert_eq!(original.data.ptr, cloned.data.ptr);\n        assert_eq!(original.next_ctrl, cloned.next_ctrl);\n        assert_eq!(original.end, cloned.end);\n        // Note: We may need to implement additional equality checks for BitMaskIter depending on implementation\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579959, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=276, prompt_tokens=8230, total_tokens=8506, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclofuN3uMCTjjRPuG3CnJ8ZImXnz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[derive(Clone, Copy)]\n    struct TestData {\n        value: usize,\n    }\n\n    #[test]\n    fn test_next() {\n        // Setup test data\n        let values = vec![TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];\n        let base = NonNull::new(Box::into_raw(values.into_boxed_slice())).unwrap();\n        let mask = BitMask(0b111); // All bits set for 3 items\n        let ctrl = base.as_ptr() as *const u8;\n\n        // Create RawIterRange instance\n        let mut iter = unsafe { RawIterRange::new(ctrl, Bucket::from_base_index(base, 0), values.len()) };\n\n        // Test next method\n        let mut count = 0;\n        while let Some(bucket) = iter.next() {\n            let data = unsafe { bucket.as_ref() };\n            assert_eq!(data.value, count + 1); // check the value is as expected\n            count += 1;\n        }\n\n        assert_eq!(count, 3); // Ensure we iterated through all elements\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579969, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=264, prompt_tokens=8224, total_tokens=8488, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclom3QjvQYviwtLuCpxamdh3RkVy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_size_hint() {\n        // Create a mock setup for RawIterRange with the required parameters\n        let mock_control_ptr: *const u8 = NonNull::dangling().as_ptr(); // A mock control pointer\n        let mock_bucket = Bucket::<u32>::from_base_index(NonNull::dangling(), 0); // A mock Bucket\n        let mock_raw_iter = unsafe { RawIterRange::new(mock_control_ptr, mock_bucket, 8) }; // Example length of 8\n\n        // Call the size_hint function\n        let (lower, upper) = mock_raw_iter.size_hint();\n\n        // Validate the expected behavior\n        assert_eq!(lower, 0); // Lower bound should be 0\n        assert!(upper.is_some()); // Upper bound should be Some\n        assert_eq!(upper.unwrap(), Some(Group::WIDTH + 0)); // `Group::WIDTH` plus 0 since remaining_buckets is 0\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579976, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=230, prompt_tokens=8288, total_tokens=8518, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclovGFm9etKX6X3cFnAiE0EpaX7D', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Global;\n    use std::alloc::Allocator;\n\n    #[test]\n    fn test_clone_empty_table() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        let cloned_table = table.clone();\n        assert_eq!(table.len(), 0);\n        assert_eq!(cloned_table.len(), 0);\n        assert_eq!(table.buckets(), cloned_table.buckets());\n        assert_eq!(table.alloc, cloned_table.alloc);\n    }\n\n    #[test]\n    fn test_clone_non_empty_table() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        table.insert(1, 42, |x| *x);\n        table.insert(2, 43, |x| *x);\n        assert_eq!(table.len(), 2);\n        \n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), 2);\n        assert_eq!(table.buckets(), cloned_table.buckets());\n        assert_eq!(table.alloc, cloned_table.alloc);\n        \n        let mut item_exists = |value: &i32| {\n            table.get(1, |&x| x == *value).is_some() ||\n            table.get(2, |&x| x == *value).is_some()\n        };\n        assert!(item_exists(&42));\n        assert!(item_exists(&43));\n    }\n\n    #[test]\n    fn test_clone_table_with_dropped_elements() {\n        let mut table: RawTable<String, Global> = RawTable::with_capacity(4);\n        table.insert(1, "Hello".to_string(), |x| x.clone());\n        table.insert(2, "World".to_string(), |x| x.clone());\n        \n        assert_eq!(table.len(), 2);\n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), 2);\n        assert!(cloned_table.get(1, |x| *x == "Hello".to_string()).is_some());\n        assert!(cloned_table.get(2, |x| *x == "World".to_string()).is_some());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579985, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=462, prompt_tokens=16361, total_tokens=16823, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclp8J9nJzByyrxjYA3hM31v8RX19', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clone_from_empty_singleton() {\n        let mut table_a: RawTable<i32, Global> = RawTable::new();\n        let table_b: RawTable<i32, Global> = RawTable::new();\n        \n        table_a.clone_from(&table_b);\n        \n        assert!(table_a.is_empty());\n    }\n    \n    #[test]\n    fn test_clone_from_non_empty() {\n        let mut table_a: RawTable<i32, Global> = RawTable::with_capacity(2);\n        let mut table_b: RawTable<i32, Global> = RawTable::with_capacity(2);\n        \n        unsafe {\n            table_a.insert(1, 10, |&x| x);\n            table_a.insert(2, 20, |&x| x);\n        }\n        \n        table_b.clone_from(&table_a);\n        \n        assert_eq!(table_b.len(), 2);\n        assert_eq!(unsafe { *table_b.bucket(0).as_ref() }, 10);\n        assert_eq!(unsafe { *table_b.bucket(1).as_ref() }, 20);\n    }\n    \n    #[test]\n    fn test_clone_from_with_different_sizes() {\n        let mut table_a: RawTable<i32, Global> = RawTable::with_capacity(2);\n        let mut table_b: RawTable<i32, Global> = RawTable::with_capacity(4);\n        \n        unsafe {\n            table_a.insert(1, 10, |&x| x);\n            table_a.insert(2, 20, |&x| x);\n        }\n        \n        table_b.clone_from(&table_a);\n        \n        assert_eq!(table_b.len(), 2);\n        assert_eq!(unsafe { *table_b.bucket(0).as_ref() }, 10);\n        assert_eq!(unsafe { *table_b.bucket(1).as_ref() }, 20);\n    }\n    \n    #[test]\n    fn test_clone_from_with_panicking_clone() {\n        #[derive(Clone)]\n        struct Panicking {\n            id: i32,\n        }\n        \n        impl Clone for Panicking {\n            fn clone(&self) -> Self {\n                panic!("Cloning Panicking struct");\n            }\n        }\n        \n        let mut table_a: RawTable<Panicking, Global> = RawTable::with_capacity(1);\n        let table_b: RawTable<Panicking, Global> = RawTable::new();\n        \n        unsafe {\n            table_a.insert(1, Panicking { id: 1 }, |&x| x.id);\n        }\n        \n        // should catch panic during clone_from\n        std::panic::catch_unwind(|| {\n            table_a.clone_from(&table_b);\n        }).expect_err("Expected panic during clone_from");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748579998, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=595, prompt_tokens=16361, total_tokens=16956, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclpL367F25wMWzBpwh8wxNuckRlA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_table_default() {\n        let table: RawTable<i32, Global> = RawTable::default();\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.buckets(), 1);\n        assert!(table.is_empty());\n    }\n\n    #[test]\n    fn test_raw_table_default_with_different_allocator() {\n        // Assuming you have a custom allocator to test with.\n        // let custom_allocator = MyAllocator::new();\n        // let table: RawTable<i32, MyAllocator> = RawTable::default_in(custom_allocator);\n        // assert_eq!(table.len(), 0);\n        // assert_eq!(table.buckets(), 1);\n        // assert!(table.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580011, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=177, prompt_tokens=16361, total_tokens=16538, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclpRsy6Hksj55NYQJ1qMUvL9faqe', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::alloc::Global;\n\n    #[test]\n    fn test_into_iter() {\n        // Create a new RawTable\n        let mut table: RawTable<u32, Global> = RawTable::default();\n\n        // Insert some values\n        for i in 0..5 {\n            table.insert(i as u64, i, |x| *x);\n        }\n\n        // Consume the table into an iterator\n        let mut iter: RawIntoIter<u32, Global> = table.into_iter();\n\n        // Collect the items from the iterator\n        let items: Vec<u32> = iter.collect();\n\n        // Verify the items\n        assert_eq!(items, vec![0, 1, 2, 3, 4]);\n        assert_eq!(iter.next(), None); // Check that the iterator is exhausted\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        // Create a new RawTable\n        let table: RawTable<u32, Global> = RawTable::default();\n\n        // Consume the table into an iterator\n        let mut iter: RawIntoIter<u32, Global> = table.into_iter();\n\n        // Check that the iterator is empty\n        assert_eq!(iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580017, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=273, prompt_tokens=16361, total_tokens=16634, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclpa6bmtsGyE3dsNsM5RiAJWF8M7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Global; // or any other allocator\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_drop_empty_table() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        // Ensure the table is empty\n        assert!(table.is_empty());\n        // On drop, it should simply complete without errors\n        drop(table);\n    }\n\n    #[test]\n    fn test_drop_non_empty_table() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(5);\n        unsafe {\n            table.insert(0, 1, |x| x.hash());\n            table.insert(1, 2, |x| x.hash());\n            assert_eq!(table.len(), 2);\n        }\n        // On drop, it should drop all elements without errors\n        drop(table);\n    }\n\n    #[test]\n    #[should_panic(expected = "expected panic during drop")]\n    fn test_drop_elements_panic() {\n        struct PanicOnDrop;\n\n        impl Drop for PanicOnDrop {\n            fn drop(&mut self) {\n                panic!("expected panic during drop");\n            }\n        }\n\n        let mut table: RawTable<PanicOnDrop, Global> = RawTable::with_capacity(1);\n        unsafe {\n            table.insert(0, PanicOnDrop, |x| x.hash());\n        }\n        // This should panic during drop\n        drop(table);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580026, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=318, prompt_tokens=16361, total_tokens=16679, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclpzWDOdOkOpyE9Fqq1ZA32KXXhR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clone_from_spec() {\n        // Create a RawTable with some initial elements\n        let mut source: RawTable<i32, Global> = RawTable::with_capacity(2);\n        unsafe {\n            source.insert(1, 10, |&x| x);\n            source.insert(1, 20, |&x| x);\n        }\n\n        // Create a destination RawTable\n        let mut dest: RawTable<i32, Global> = RawTable::with_capacity(2);\n\n        // Clone from source to dest\n        unsafe {\n            dest.clone_from_spec(&source);\n        }\n\n        // Ensure the destination RawTable has the same elements as the source\n        assert_eq!(dest.len(), source.len());\n        assert_eq!(dest.get(1, |&x| x == 10).is_some(), true);\n        assert_eq!(dest.get(1, |&x| x == 20).is_some(), true);\n    }\n\n    #[test]\n    fn test_clone_from_spec_empty() {\n        // Create an empty source RawTable\n        let source: RawTable<i32, Global> = RawTable::new();\n        let mut dest: RawTable<i32, Global> = RawTable::new();\n\n        // Clone from an empty source\n        unsafe {\n            dest.clone_from_spec(&source);\n        }\n\n        // Ensure the destination RawTable is also empty\n        assert!(dest.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580051, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=324, prompt_tokens=16361, total_tokens=16685, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclqAxZpdotR1tuDTrzMgMZWMoVkg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use scopeguard::ScopeGuard;\n\n    #[test]\n    fn test_deref() {\n        let value = 42;\n        let drop_fn = |_: &mut i32| {};\n        let guard = ScopeGuard { dropfn: drop_fn, value };\n\n        // Dereference the guard and check the value\n        assert_eq!(*guard, 42);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580062, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=93, prompt_tokens=551, total_tokens=644, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclqEiP2Dr4fbmUWm6vgOv4nz1l3B', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use scopeguard::ScopeGuard;\n\n    #[test]\n    fn test_deref_mut() {\n        let mut value = 10;\n        let mut guard = ScopeGuard {\n            dropfn: |v: &mut i32| *v = 0,\n            value: value,\n        };\n\n        // Validate the deref_mut functionality\n        let deref_mut_value = guard.deref_mut();\n        *deref_mut_value += 5;\n\n        // Ensure the original value reflects the modification\n        assert_eq!(*deref_mut_value, 15);\n        assert_eq!(guard.value, 15);\n    }\n\n    #[test]\n    fn test_deref_mut_with_drop_fn() {\n        let mut value = 10;\n        {\n            let mut guard = ScopeGuard {\n                dropfn: |v: &mut i32| *v = 0,\n                value: value,\n            };\n\n            // Modify the value using deref_mut\n            *guard.deref_mut() += 5;\n        }\n\n        // Check that the drop function was called\n        assert_eq!(value, 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580066, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=245, prompt_tokens=558, total_tokens=803, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclqLOgJkIVL9WbHum9qKmLZQwQZJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    #[test]\n    fn test_scope_guard_drop() {\n        let value = RefCell::new(0);\n        let mut dropped = false;\n\n        {\n            let _guard = ScopeGuard {\n                dropfn: |v: &mut RefCell<i32>| {\n                    *v.borrow_mut() += 1;\n                    dropped = true;\n                },\n                value,\n            };\n        }\n\n        assert!(dropped);\n    }\n\n    #[test]\n    fn test_scope_guard_into_inner() {\n        let value = RefCell::new(5);\n        let mut dropped = false;\n\n        let guard = ScopeGuard {\n            dropfn: |v: &mut RefCell<i32>| {\n                *v.borrow_mut() += 1;\n                dropped = true;\n            },\n            value: RefCell::new(10),\n        };\n\n        let inner_value = ScopeGuard::into_inner(guard);\n        assert_eq!(*inner_value.borrow(), 10);\n        assert!(dropped);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580073, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=227, prompt_tokens=550, total_tokens=777, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclqTs7Kyb51FB9KechdE3IQi4RBO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[derive(Debug, Clone, PartialEq, Eq)]\n    struct TestItem {\n        id: usize,\n    }\n\n    #[test]\n    fn test_clone_difference() {\n        let map: HashMap<usize, TestItem> = HashMap::from_iter([\n            (1, TestItem { id: 10 }),\n            (2, TestItem { id: 20 }),\n            (3, TestItem { id: 30 }),\n        ]);\n        \n        let difference_iter = map.iter();\n        let difference = Difference {\n            iter: difference_iter.clone(),\n            // Include all necessary fields for the struct, too\n        };\n\n        let cloned_difference = difference.clone();\n        \n        // Check that clone() has the same elements\n        assert_eq!(cloned_difference.iter.clone().collect::<Vec<_>>(), difference.iter.clone().collect::<Vec<_>>());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580081, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=200, prompt_tokens=16361, total_tokens=16561, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclqaDKghLoO7ZfjM0KTh85xYdGsI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashMap, HashSet};\n\n    #[test]\n    fn test_fold_with_empty_difference() {\n        let set1: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set2: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let difference = set1.difference(&set2);\n        let result = difference.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_fold_with_non_empty_difference() {\n        let set1: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();\n        let set2: HashSet<i32> = [3, 4].iter().cloned().collect();\n        let difference = set1.difference(&set2);\n        let result = difference.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 2);\n    }\n\n    #[test]\n    fn test_fold_with_custom_function() {\n        let set1: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();\n        let set2: HashSet<i32> = [2, 4].iter().cloned().collect();\n        let difference = set1.difference(&set2);\n        let result = difference.fold(1, |acc, elt| acc * elt);\n        assert_eq!(result, 3); // 1 * 3 = 3\n    }\n\n    #[test]\n    fn test_fold_with_non_existent_elements() {\n        let set1: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set2: HashSet<i32> = HashSet::new();\n        let difference = set1.difference(&set2);\n        let result = difference.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 3);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580088, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=464, prompt_tokens=16361, total_tokens=16825, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclqmb06sIqDaCQuk1poniMfID94O', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_next_with_unique_elements() {\n        let set_a: HashSet<i32> = HashSet::from([1, 2, 3, 4]);\n        let set_b: HashSet<i32> = HashSet::from([3, 4, 5, 6]);\n        let mut difference = set_a.difference(&set_b);\n\n        assert_eq!(difference.next(), Some(&1));\n        assert_eq!(difference.next(), Some(&2));\n        assert_eq!(difference.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_no_elements_left() {\n        let set_a: HashSet<i32> = HashSet::from([1, 2]);\n        let set_b: HashSet<i32> = HashSet::from([1, 2]);\n        let mut difference = set_a.difference(&set_b);\n\n        assert_eq!(difference.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_empty_first_set() {\n        let set_a: HashSet<i32> = HashSet::new();\n        let set_b: HashSet<i32> = HashSet::from([1, 2, 3]);\n        let mut difference = set_a.difference(&set_b);\n\n        assert_eq!(difference.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_empty_second_set() {\n        let set_a: HashSet<i32> = HashSet::from([1, 2, 3]);\n        let set_b: HashSet<i32> = HashSet::new();\n        let mut difference = set_a.difference(&set_b);\n\n        assert_eq!(difference.next(), Some(&1));\n        assert_eq!(difference.next(), Some(&2));\n        assert_eq!(difference.next(), Some(&3));\n        assert_eq!(difference.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_non_integer_elements() {\n        let set_a: HashSet<String> = HashSet::from(["a".to_string(), "b".to_string()]);\n        let set_b: HashSet<String> = HashSet::from(["b".to_string()]);\n        let mut difference = set_a.difference(&set_b);\n\n        assert_eq!(difference.next(), Some(&"a".to_string()));\n        assert_eq!(difference.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580100, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=505, prompt_tokens=16361, total_tokens=16866, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclqyckeDqwIVkQBErOXvcw2DYzww', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_size_hint() {\n        let mut map_a: HashMap<i32, i32> = HashMap::new();\n        map_a.insert(1, 1);\n        map_a.insert(2, 2);\n        let bitmask_a = BitMask(0b00000011); // Both indices 0 and 1 are set\n\n        let mut map_b: HashMap<i32, i32> = HashMap::new();\n        map_b.insert(3, 3);\n        map_b.insert(4, 4);\n        let bitmask_b = BitMask(0b00000001); // Only index 0 is set\n\n        let difference = set::Difference {\n            iter: bitmask_a.into_iter(),  // Simulating our iterator\n            other: bitmask_b.into_iter(),  // Simulating the other set\n        };\n\n        let (lower, upper) = difference.size_hint();\n        assert_eq!(lower, 1);    // 2 (from bitmask_a) - 1 (from bitmask_b) = 1\n        assert_eq!(upper, None);  // Upper bound is None\n    }\n\n    #[test]\n    fn test_empty_difference_size_hint() {\n        let empty_bitmask_a = BitMask(0b00000000); // No bits set\n        let empty_bitmask_b = BitMask(0b00000000); // No bits set\n\n        let difference = set::Difference {\n            iter: empty_bitmask_a.into_iter(),\n            other: empty_bitmask_b.into_iter(),\n        };\n\n        let (lower, upper) = difference.size_hint();\n        assert_eq!(lower, 0);    // 0 - 0 = 0\n        assert_eq!(upper, None);  // Upper bound is None\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580112, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=402, prompt_tokens=16361, total_tokens=16763, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclr7jUOMGTKRyICM4uOfcL7nq0ws', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn drain_len_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        let drain_iter = map.drain();\n        assert_eq!(drain_iter.len(), 0);\n    }\n\n    #[test]\n    fn drain_len_non_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.insert(3, 3);\n        let drain_iter = map.drain();\n        assert_eq!(drain_iter.len(), 3);\n    }\n\n    #[test]\n    fn drain_len_after_next() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 1);\n        map.insert(2, 2);\n        let mut drain_iter = map.drain();\n        assert_eq!(drain_iter.len(), 2);\n        drain_iter.next(); // consume one item\n        assert_eq!(drain_iter.len(), 1);\n        drain_iter.next();\n        assert_eq!(drain_iter.len(), 0);\n    }\n\n    #[test]\n    fn drain_len_after_all_items_consumed() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 1);\n        let mut drain_iter = map.drain();\n        drain_iter.next(); // consume item\n        assert_eq!(drain_iter.len(), 0);\n        assert_eq!(drain_iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580121, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=357, prompt_tokens=16361, total_tokens=16718, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclrLL31Pee2JhwIW6rWtb6SJmeYF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_fold() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let result = set.drain().fold(0, |acc, x| acc + x);\n        assert_eq!(result, 6);\n    }\n\n    #[test]\n    fn test_fold_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        let result = set.drain().fold(0, |acc, x| acc + x);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_fold_with_custom_function() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let result = set.drain().fold(1, |acc, x| acc * x);\n        assert_eq!(result, 6); // 1 * 1 * 2 * 3\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580135, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=238, prompt_tokens=16361, total_tokens=16599, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclrUKBlPfUJ7gXu7YRNQXIFYM5hQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_next_function() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let mut drain_iter = map.drain();\n        let mut vec: Vec<_> = vec![];\n\n        vec.push(drain_iter.next());\n        vec.push(drain_iter.next());\n        vec.push(drain_iter.next());\n\n        // Since order isn\'t guaranteed, sort before comparison\n        vec.sort_unstable();\n        assert_eq!(vec, vec![Some((1, "a")), Some((2, "b")), Some((3, "c"))]);\n\n        // Testing that no more items are left\n        assert_eq!(drain_iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580144, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=197, prompt_tokens=16361, total_tokens=16558, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclrm7HglXwaJLC1vmsl5tvGuWbYI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_drain_size_hint() {\n        let mut map: HashMap<usize, String> = HashMap::new();\n        map.insert(1, "a".to_string());\n        map.insert(2, "b".to_string());\n        map.insert(3, "c".to_string());\n\n        let mut drain = map.drain();\n        let (lower, upper) = drain.size_hint();\n        \n        // Since there are 3 entries in the map, the size hint should reflect that\n        assert_eq!(lower, 3);\n        assert_eq!(upper, Some(3));\n\n        drain.next(); // Consume one element\n        let (lower, upper) = drain.size_hint();\n        \n        // One element has been removed\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n\n        drain.next(); // Consume another element\n        let (lower, upper) = drain.size_hint();\n        \n        // Two elements have been removed\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n\n        drain.next(); // Consume the last element\n        let (lower, upper) = drain.size_hint();\n        \n        // Now all elements have been removed\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580162, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=302, prompt_tokens=16361, total_tokens=16663, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclruNF957nZ4QUKHos9WkvVJAkiT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use control::bitmask::BitMaskIter;\n    use raw::{Bucket, RawExtractIf, RawIter};\n\n    #[test]\n    fn test_next() {\n        let mut raw_table = RawTable::new_in(Global);\n        // Insert some test data\n        let bucket1 = raw_table.insert(1, "data1", |_| 1);\n        let bucket2 = raw_table.insert(2, "data2", |_| 2);\n\n        // Prepare the extractor function\n        let iter = RawIter::new(&raw_table);\n        let mut extractor = RawExtractIf {\n            iter,\n            table: &mut raw_table,\n        };\n\n        // Create a filter function\n        let filter = |value: &mut &str| {\n            *value == "data1"\n        };\n\n        // Call the `next` function on extractor\n        let result = extractor.next(filter);\n\n        // Check if the result is as expected\n        assert_eq!(result, Some("data1"));\n\n        // Ensure the extractor can no longer find "data1" after it has been removed\n        assert_eq!(extractor.next(filter), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580170, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=261, prompt_tokens=16361, total_tokens=16622, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcls37UALVUPbbfJfrx13yct2oEIU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::RawTable;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let raw_table: RawTable<u32> = RawTable::new_in(Global);\n        let mut extract_if = raw_table.extract_if();\n        \n        let (lower, upper) = extract_if.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut raw_table = RawTable::new_in(Global);\n        raw_table.insert(1, 42, |&v| v);\n        let mut extract_if = raw_table.extract_if();\n        \n        let (lower, upper) = extract_if.size_hint();\n        assert!(lower > 0);\n        assert!(upper.is_some());\n    }\n\n    #[test]\n    fn test_size_hint_with_filtered_elements() {\n        let mut raw_table = RawTable::new_in(Global);\n        raw_table.insert(1, 42, |&v| v);\n        raw_table.insert(2, 43, |&v| v);\n        \n        let mut extract_if = raw_table.extract_if();\n        \n        let (lower, upper) = extract_if.size_hint();\n        assert!(lower > 0);\n        assert!(upper.is_some());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580179, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=287, prompt_tokens=16361, total_tokens=16648, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclsPrR8w5hkdATZykRREH4GeXd0C', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_clone_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        let cloned_set = set.clone();\n        assert_eq!(set.len(), cloned_set.len());\n        assert_eq!(set, cloned_set);\n    }\n\n    #[test]\n    fn test_clone_with_elements() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        let cloned_set = set.clone();\n        assert_eq!(set.len(), cloned_set.len());\n        assert_eq!(set, cloned_set);\n    }\n\n    #[test]\n    fn test_clone_with_different_elements() {\n        let mut set1: HashSet<i32> = HashSet::new();\n        set1.insert(1);\n        set1.insert(2);\n\n        let mut set2: HashSet<i32> = HashSet::new();\n        set2.insert(3);\n        \n        let cloned_set1 = set1.clone();\n        let cloned_set2 = set2.clone();\n        \n        assert_ne!(set1, set2);\n        assert_eq!(set1, cloned_set1);\n        assert_eq!(set2, cloned_set2);\n    }\n\n    #[test]\n    fn test_clone_after_modification() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        \n        let cloned_set = set.clone();\n        set.insert(2);\n        \n        assert_ne!(set, cloned_set);\n        assert_eq!(cloned_set.len(), 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580201, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=356, prompt_tokens=16361, total_tokens=16717, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclscRQrL7idY7YHDx8sJne8rvZo5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_clone_from() {\n        let mut set_a: HashSet<i32> = HashSet::new();\n        set_a.insert(1);\n        set_a.insert(2);\n        set_a.insert(3);\n\n        let mut set_b: HashSet<i32> = HashSet::new();\n        set_b.insert(4);\n        set_b.insert(5);\n\n        set_b.clone_from(&set_a);\n\n        assert_eq!(set_b.len(), 3);\n        assert!(set_b.contains(&1));\n        assert!(set_b.contains(&2));\n        assert!(set_b.contains(&3));\n    }\n\n    #[test]\n    fn test_clone_from_empty() {\n        let mut set_a: HashSet<i32> = HashSet::new();\n        let mut set_b: HashSet<i32> = HashSet::new();\n        set_b.insert(4);\n\n        set_b.clone_from(&set_a);\n\n        assert_eq!(set_b.len(), 0);\n        assert!(!set_b.contains(&4));\n    }\n\n    #[test]\n    fn test_clone_from_identical() {\n        let mut set_a: HashSet<i32> = HashSet::new();\n        set_a.insert(1);\n        set_a.insert(2);\n\n        let mut set_b = set_a.clone(); // Cloning set_a to set_b\n        set_b.clone_from(&set_a);\n\n        assert_eq!(set_b.len(), 2);\n        assert!(set_b.contains(&1));\n        assert!(set_b.contains(&2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580214, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=337, prompt_tokens=16361, total_tokens=16698, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclsle9DF7WduWDHGBJ1FZzLGw8fY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_eq_different_sizes() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3, 4]);\n        assert!(!set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_different_elements() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![3, 4, 5]);\n        assert!(!set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_same_elements() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![3, 2, 1]);\n        assert!(set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_empty_sets() {\n        let set1: HashSet<i32> = HashSet::new();\n        let set2: HashSet<i32> = HashSet::new();\n        assert!(set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_subset() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        assert!(!set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_same_single_element() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![1]);\n        assert!(set1.eq(&set2));\n    }\n\n    #[test]\n    fn test_eq_different_single_elements() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![2]);\n        assert!(!set1.eq(&set2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580223, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=516, prompt_tokens=16361, total_tokens=16877, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclszBC6u5sO0vrAzSDeEoxDmVWb0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashMap, HashSet};\n\n    #[test]\n    fn test_hashset_from_hashmap() {\n        // Create a HashMap with integer keys and unit values\n        let mut map: HashMap<i32, ()> = HashMap::new();\n        map.insert(1, ());\n        map.insert(2, ());\n        map.insert(3, ());\n\n        // Convert HashMap to HashSet using the From implementation\n        let set: HashSet<i32, _> = HashSet::from(map);\n\n        // Ensure the HashSet contains the correct values\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert_eq!(set.len(), 3);\n    }\n\n    #[test]\n    fn test_empty_hashmap_to_hashset() {\n        // Create an empty HashMap\n        let map: HashMap<i32, ()> = HashMap::new();\n\n        // Convert the empty HashMap to HashSet\n        let set: HashSet<i32, _> = HashSet::from(map);\n\n        // Ensure the HashSet is empty\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_hashset_from_hashmap_with_no_duplicates() {\n        // Create a HashMap with duplicate keys\n        let mut map: HashMap<i32, ()> = HashMap::new();\n        map.insert(1, ());\n        map.insert(1, ()); // Duplicate key, no effect on HashMap\n        map.insert(2, ());\n\n        // Convert HashMap to HashSet\n        let set: HashSet<i32, _> = HashSet::from(map);\n\n        // Ensure the HashSet contains the correct values\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert_eq!(set.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580237, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=399, prompt_tokens=16361, total_tokens=16760, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclt9Mo5xr0wDHKA25VqNj3LSX6L3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_default_hashset() {\n        let set: HashSet<i32> = HashSet::default();\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_default_hashset_non_empty() {\n        let mut set: HashSet<i32> = HashSet::default();\n        set.insert(1);\n        assert!(!set.is_empty());\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n    }\n\n    #[test]\n    fn test_default_hashset_capacity() {\n        let set: HashSet<i32> = HashSet::default();\n        assert_eq!(set.capacity(), 0); // Initially, capacity should be 0\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580247, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=179, prompt_tokens=16361, total_tokens=16540, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcltHtX0kD0NGzRRVR7CNJf5Uvtco', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_extend() {\n        let mut set = HashSet::new();\n        let elements = vec![&1, &2, &3];\n\n        set.extend(elements.iter());\n\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert_eq!(set.len(), 3);\n    }\n\n    #[test]\n    fn test_extend_with_duplicate() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        let elements = vec![&2, &3, &4];\n        set.extend(elements.iter());\n\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert!(set.contains(&4));\n        assert_eq!(set.len(), 4);\n    }\n\n    #[test]\n    fn test_extend_empty() {\n        let mut set = HashSet::new();\n        let elements: Vec<&i32> = Vec::new();\n        \n        set.extend(elements.iter());\n\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_extend_with_empty_set() {\n        let mut set1 = HashSet::new();\n        let mut set2 = HashSet::new();\n        \n        set2.extend(vec![&1, &2, &3].iter());\n        set1.extend(set2.iter());\n\n        assert_eq!(set1.len(), 3);\n        assert_eq!(set2.len(), 3);\n        assert!(set1.contains(&1));\n        assert!(set1.contains(&2));\n        assert!(set1.contains(&3));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580255, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=363, prompt_tokens=16361, total_tokens=16724, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcltQtaFkjL64ky29qggg7dQPjaxr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_extend_with_array() {\n        let mut set = HashSet::new();\n        let arr = [1, 2, 3];\n        set.extend(&arr);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n    }\n\n    #[test]\n    fn test_extend_with_vector() {\n        let mut set = HashSet::new();\n        let vec = vec![4, 5, 6];\n        set.extend(vec);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&4));\n        assert!(set.contains(&5));\n        assert!(set.contains(&6));\n    }\n\n    #[test]\n    fn test_extend_with_iterator() {\n        let mut set = HashSet::new();\n        let iter = vec![7, 8, 9].into_iter();\n        set.extend(iter);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&7));\n        assert!(set.contains(&8));\n        assert!(set.contains(&9));\n    }\n\n    #[test]\n    fn test_extend_with_duplicates() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.extend(vec![2, 3, 4]); // 2 is a duplicate\n        assert_eq!(set.len(), 4);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert!(set.contains(&4));\n    }\n\n    #[test]\n    fn test_extend_empty() {\n        let mut set = HashSet::new();\n        set.extend(vec![]);\n        assert_eq!(set.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580264, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=395, prompt_tokens=16361, total_tokens=16756, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcltbuY12DulcwY57GkWEGlHMVLZc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_from_iter_with_bitmask() {\n        use control::bitmask::BitMask;\n\n        let bitmask_values = vec![BitMask(0b00000001), BitMask(0b00000010)];\n        let set: HashSet<BitMask> = HashSet::from_iter(bitmask_values.clone());\n\n        assert_eq!(set.len(), bitmask_values.len());\n        for bm in bitmask_values {\n            assert!(set.contains(&bm));\n        }\n    }\n    \n    #[test]\n    fn test_from_iter_with_hashmap() {\n        use map::HashMap;\n\n        let map_values = vec![(1, "a"), (2, "b"), (3, "c")];\n        let map: HashMap<i32, &str> = HashMap::from_iter(map_values.clone());\n\n        assert_eq!(map.len(), map_values.len());\n        for (key, value) in map_values {\n            assert_eq!(map.get(&key), Some(&value));\n        }\n    }\n\n    #[test]\n    fn test_from_iter_empty() {\n        let empty_set: HashSet<i32> = HashSet::from_iter(Vec::new());\n        assert!(empty_set.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580275, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=278, prompt_tokens=16361, total_tokens=16639, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcltkCx1WF99GlFIenWBhdF6u5CXE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_into_iter() {\n        // Create a new HashSet and insert elements\n        let mut set = HashSet::new();\n        set.insert("a".to_string());\n        set.insert("b".to_string());\n        set.insert("c".to_string());\n\n        // Convert the HashSet into an iterator\n        let mut iter = set.into_iter();\n\n        // Collect the items into a Vec\n        let collected: Vec<String> = iter.collect();\n\n        // Check the collected items\n        assert_eq!(collected.len(), 3);\n        assert!(collected.contains(&"a".to_string()));\n        assert!(collected.contains(&"b".to_string()));\n        assert!(collected.contains(&"c".to_string()));\n    }\n\n    #[test]\n    fn test_into_iter_empty_set() {\n        // Create an empty HashSet\n        let set: HashSet<String> = HashSet::new();\n\n        // Convert the HashSet into an iterator\n        let iter = set.into_iter();\n\n        // Collect the items into a Vec\n        let collected: Vec<String> = iter.collect();\n\n        // Check that the collected Vec is empty\n        assert!(collected.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580284, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=274, prompt_tokens=16361, total_tokens=16635, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcltu4ZKZFXXmdHEwEWq3bqbcY7ib', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitand_assign() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n\n        a &= &b;\n\n        let expected: HashSet<_> = vec![2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_bitand_assign_empty() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![4, 5, 6].into_iter().collect();\n\n        a &= &b;\n\n        let expected: HashSet<_> = HashSet::new();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_bitand_assign_no_change() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n\n        a &= &b;\n\n        let expected: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_bitand_assign_with_duplicates() {\n        let mut a: HashSet<_> = vec![1, 2, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n\n        a &= &b;\n\n        let expected: HashSet<_> = vec![2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580294, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=420, prompt_tokens=16361, total_tokens=16781, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclu77etaTAKjZNWH2ZPuYzJYpvlD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitor_assign() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n\n        a |= &b;\n\n        let mut i = 0;\n        let expected = [1, 2, 3, 4, 5];\n        for x in &a {\n            assert!(expected.contains(x));\n            i += 1;\n        }\n        assert_eq!(i, expected.len());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580307, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=151, prompt_tokens=16361, total_tokens=16512, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcluFLtyoUpy9yohSxKUZVt2puDsq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_bitxor_assign() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n        \n        a ^= &b;\n\n        let expected: HashSet<_> = vec![1, 2, 4, 5].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_bitxor_assign_with_empty() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = HashSet::new();\n        \n        a ^= &b;\n\n        let expected: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_bitxor_assign_self() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        \n        a ^= &a;\n\n        let expected: HashSet<_> = HashSet::new();\n        assert_eq!(a, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580315, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=288, prompt_tokens=16361, total_tokens=16649, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcluPd2BDTLfw3flfnTdepoTFW14d', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_sub_assign() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n\n        a -= &b;\n\n        let expected: HashSet<_> = vec![1, 2].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_sub_assign_no_change() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![4, 5].into_iter().collect();\n\n        a -= &b;\n\n        let expected: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_sub_assign_empty_rhs() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = HashSet::new();\n\n        a -= &b;\n\n        let expected: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        assert_eq!(a, expected);\n    }\n\n    #[test]\n    fn test_sub_assign_rhs_equal() {\n        let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n\n        a -= &b;\n\n        let expected: HashSet<_> = HashSet::new();\n        assert_eq!(a, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580325, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=404, prompt_tokens=16361, total_tokens=16765, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcluaQLPznzGNebWEpmVlPvCwP55l', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_from_array() {\n        let set1: HashSet<_> = HashSet::from([1, 2, 3, 4]);\n        let set2: HashSet<_> = [1, 2, 3, 4].into();\n        assert_eq!(set1, set2);\n    }\n\n    #[test]\n    fn test_from_array_empty() {\n        let set: HashSet<i32> = HashSet::from([]);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_from_array_duplicates() {\n        let set: HashSet<_> = HashSet::from([1, 1, 2, 3]);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n    }\n\n    #[test]\n    fn test_from_array_non_copy() {\n        let set: HashSet<String> = HashSet::from([String::from("a"), String::from("b")]);\n        assert_eq!(set.len(), 2);\n        assert!(set.contains("a"));\n        assert!(set.contains("b"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580336, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=270, prompt_tokens=16361, total_tokens=16631, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclujjq0XvtM2r3eQ3cUaY0yqzXRD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashMap, HashSet};\n\n    #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n    struct TestData {\n        key: usize,\n        value: usize,\n    }\n\n    #[derive(Debug, Clone)]\n    struct TestIntersection<'a, T> {\n        iter: &'a HashSet<T>,\n    }\n\n    impl<'a, T> TestIntersection<'a, T> {\n        fn new(iter: &'a HashSet<T>) -> Self {\n            TestIntersection { iter }\n        }\n    }\n\n    impl<'a, T: Clone + Copy + Eq + Hash> Clone for TestIntersection<'a, T> {\n        fn clone(&self) -> Self {\n            TestIntersection {\n                iter: self.iter,\n            }\n        }\n    }\n\n    #[test]\n    fn test_clone_intersection() {\n        let mut set = HashSet::new();\n        set.insert(TestData { key: 1, value: 10 });\n        set.insert(TestData { key: 2, value: 20 });\n        \n        let intersection = TestIntersection::new(&set);\n        let cloned_intersection = intersection.clone();\n        \n        assert_eq!(cloned_intersection.iter, intersection.iter);\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580345, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=266, prompt_tokens=16361, total_tokens=16627, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclutLwuVrSy6EDxgtak9v3HRaegA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashMap, HashSet};\n\n    #[test]\n    fn test_fold_with_elements_in_common() {\n        let set1: HashSet<usize> = (1..5).collect();\n        let set2: HashSet<usize> = (3..7).collect();\n        let intersection = set1.intersection(&set2);\n        \n        let result = intersection.fold(0, |acc, &x| acc + x);\n        assert_eq!(result, 3 + 4); // Only 3 and 4 are in intersection\n    }\n\n    #[test]\n    fn test_fold_with_no_elements_in_common() {\n        let set1: HashSet<usize> = (1..3).collect();\n        let set2: HashSet<usize> = (4..7).collect();\n        let intersection = set1.intersection(&set2);\n        \n        let result = intersection.fold(10, |acc, _| acc + 1);\n        assert_eq!(result, 10); // No elements in intersection, result should be init\n    }\n\n    #[test]\n    fn test_fold_with_empty_intersection() {\n        let set1: HashSet<usize> = HashSet::new();\n        let set2: HashSet<usize> = HashSet::new();\n        let intersection = set1.intersection(&set2);\n        \n        let result = intersection.fold(5, |acc, _| acc + 1);\n        assert_eq!(result, 5); // No elements in intersection\n    }\n\n    #[test]\n    fn test_fold_with_initial_value() {\n        let set1: HashSet<usize> = (2..5).collect(); // 2, 3, 4\n        let set2: HashSet<usize> = (1..4).collect(); // 1, 2, 3\n        let intersection = set1.intersection(&set2);\n        \n        let result = intersection.fold(1, |acc, &x| acc * x);\n        assert_eq!(result, 1 * 2 * 3); // 2 and 3 are in intersection\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580355, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=462, prompt_tokens=16361, total_tokens=16823, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclv6oXvbczihcHsa40iy3rEhfvYo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashMap, HashSet};\n\n    #[test]\n    fn test_intersection_next() {\n        // Prepare data for testing\n        let set_a: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();\n        let set_b: HashSet<i32> = [3, 4, 5, 6].iter().cloned().collect();\n        \n        // Create an intersection iterator\n        let intersection = set_a.intersection(&set_b);\n        \n        // Collect the results\n        let result: Vec<_> = intersection.collect();\n        \n        // Check if the intersection is correct\n        assert_eq!(result, vec![&3, &4]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580368, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=170, prompt_tokens=16361, total_tokens=16531, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclvESjUKYLuGwkWzpYKdpRuBu5To', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let set: HashSet<usize> = HashSet::new();\n        let intersection = set.intersection(&set); // Self intersection\n        let hint = intersection.size_hint();\n        assert_eq!(hint, (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut set: HashSet<usize> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        let intersection = set.intersection(&set); // Self intersection\n        let hint = intersection.size_hint();\n        assert_eq!(hint, (0, Some(2))); // Expecting (0, Some(2)) because the intersection has 2 elements\n    }\n\n    #[test]\n    fn test_size_hint_partial_elements() {\n        let mut set1: HashSet<usize> = HashSet::new();\n        let mut set2: HashSet<usize> = HashSet::new();\n        set1.insert(1);\n        set1.insert(2);\n        set2.insert(2);\n        set2.insert(3);\n        let intersection = set1.intersection(&set2);\n        let hint = intersection.size_hint();\n        assert_eq!(hint, (0, Some(1))); // Expecting (0, Some(1)) because intersection has 1 element (2)\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580376, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=313, prompt_tokens=16361, total_tokens=16674, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclvN0em9bRUudV7gubxNrQtesCbO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_into_iter_default() {\n        let iter: IntoIter<u32> = Default::default();\n        assert_eq!(iter.len(), 0);\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_into_iter_non_empty() {\n        let set: HashSet<u32> = [(1, ()), (2, ()), (3, ())].iter().cloned().collect();\n        let iter = set.into_iter();\n        let mut collected: Vec<u32> = iter.collect();\n        assert_eq!(collected.len(), 3);\n        collected.sort();\n        assert_eq!(collected, vec![1, 2, 3]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580385, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=171, prompt_tokens=10800, total_tokens=10971, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclvT2eKLGfKAzxRvcmCwqtGTlSny', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_into_iter_len() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.len(), 0);\n\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let iter = set.into_iter();\n        assert_eq!(iter.len(), 3);\n\n        drop(iter); // Drop the iterator\n        assert_eq!(set.len(), 3); // Ensure set still has items\n    }\n\n    #[test]\n    fn test_empty_into_iter_len() {\n        let set: HashSet<i32> = HashSet::new();\n        let iter = set.into_iter();\n        assert_eq!(iter.len(), 0);\n    }\n\n    #[test]\n    fn test_zero_items_into_iter_len() {\n        let mut set: HashSet<i32> = HashSet::new();\n        let iter = set.into_iter();\n        assert_eq!(iter.len(), 0);\n    }\n\n    #[test]\n    fn test_len_after_removal() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        assert_eq!(set.len(), 3);\n        \n        set.remove(&2);\n        let iter = set.into_iter();\n        assert_eq!(iter.len(), 2);\n        \n        drop(iter); // Drop the iterator\n        assert_eq!(set.len(), 2); // Ensure set still has items\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580391, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=336, prompt_tokens=10796, total_tokens=11132, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclvcB6WgCeVnTa0YL4kUTCFOogSY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_fold() {\n        let set: HashSet<i32> = [1, 2, 3, 4, 5].iter().cloned().collect();\n        \n        let sum: i32 = set.into_iter().fold(0, |acc, x| acc + x);\n        assert_eq!(sum, 15);\n    }\n\n    #[test]\n    fn test_fold_with_empty_set() {\n        let set: HashSet<i32> = HashSet::new();\n        \n        let sum: i32 = set.into_iter().fold(0, |acc, x| acc + x);\n        assert_eq!(sum, 0);\n    }\n\n    #[test]\n    fn test_fold_with_initial_value() {\n        let set: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        \n        let product: i32 = set.into_iter().fold(1, |acc, x| acc * x);\n        assert_eq!(product, 6);\n    }\n\n    #[test]\n    fn test_fold_with_custom_function() {\n        let set: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();\n        \n        let result: String = set.into_iter().fold(String::new(), |acc, x| acc + &x.to_string());\n        assert_eq!(result, "1234");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580400, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=323, prompt_tokens=10842, total_tokens=11165, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclvlU2rR8uEqbmUgQOaUtMpf6viD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_into_iter_next() {\n        let set: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let mut iter = set.into_iter();\n\n        let first = iter.next();\n        let second = iter.next();\n        let third = iter.next();\n        let fourth = iter.next();\n\n        assert!(first.is_some());\n        assert!(second.is_some());\n        assert!(third.is_some());\n        assert!(fourth.is_none());\n\n        // Ensure that remaining elements are distinct\n        let unique_elements: HashSet<_> = [first.unwrap(), second.unwrap(), third.unwrap()].iter().cloned().collect();\n        assert_eq!(unique_elements.len(), 3);\n        assert!(unique_elements.contains(&1) || unique_elements.contains(&2) || unique_elements.contains(&3));\n    }\n\n    #[test]\n    fn test_next_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        let mut iter = set.into_iter();\n\n        assert_eq!(iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580409, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=245, prompt_tokens=10831, total_tokens=11076, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclvsM1rnlJE27ZFCp9Pk6Q06azMY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        let iter = set.into_iter();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let set: HashSet<i32> = [(1,), (2,), (3,)].iter().cloned().collect();\n        let iter = set.into_iter();\n        assert_eq!(iter.size_hint(), (3, Some(3)));\n    }\n\n    #[test]\n    fn test_size_hint_after_iteration() {\n        let set: HashSet<i32> = [(1,), (2,), (3,)].iter().cloned().collect();\n        let mut iter = set.into_iter();\n        let _ = iter.next();\n        assert_eq!(iter.size_hint(), (2, Some(2)));\n        let _ = iter.next();\n        assert_eq!(iter.size_hint(), (1, Some(1)));\n        let _ = iter.next();\n        assert_eq!(iter.size_hint(), (0, Some(0)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580416, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=258, prompt_tokens=10804, total_tokens=11062, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclw2J8sbzValAwuESk9is7CI3uQR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_clone_iter() {\n        let set: HashSet<i32> = [(1, ()), (2, ()), (3, ())].iter().cloned().collect();\n        let iter = set.iter();\n        let cloned_iter = iter.clone();\n\n        // Collect values from the original and cloned iterators\n        let original_values: Vec<&i32> = iter.collect();\n        let cloned_values: Vec<&i32> = cloned_iter.collect();\n\n        // Verify that the values are the same\n        assert_eq!(original_values, cloned_values);\n    }\n\n    #[test]\n    fn test_clone_iter_iterability() {\n        let set: HashSet<i32> = [(1, ()), (2, ()), (3, ())].iter().cloned().collect();\n        let mut iter = set.iter();\n        let mut cloned_iter = iter.clone();\n\n        // Verify that the first item is the same\n        assert_eq!(iter.next(), cloned_iter.next());\n\n        // Verify that the next item is also the same\n        assert_eq!(iter.next(), cloned_iter.next());\n\n        // Verify remaining items until iter is exhausted\n        assert_eq!(iter.next(), cloned_iter.next());\n        assert_eq!(iter.next(), None);\n        assert_eq!(cloned_iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580426, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=295, prompt_tokens=10991, total_tokens=11286, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwAgVtzNT5Dh4u2srYMtYIiHWET', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_iter_default() {\n        let iter: Iter<i32> = Iter::default();\n        assert_eq!(iter.len(), 0);\n        assert!(iter.next().is_none());\n    }\n\n    #[test]\n    fn test_iter_default_with_elements() {\n        let set: HashSet<i32> = vec![1, 2, 3].into_iter().collect();\n        let iter: Iter<i32> = set.iter();\n        assert_eq!(iter.len(), 3);\n        \n        let mut collected: Vec<_> = iter.collect();\n        collected.sort(); // Sort for comparison, since the order is arbitrary\n        assert_eq!(collected, vec![&1, &2, &3]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580434, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=177, prompt_tokens=10989, total_tokens=11166, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwHiniW9z4ZtjdeyyOvf3c7wdKS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_iter_len() {\n        let set: HashSet<i32> = vec![1, 2, 3].into_iter().collect();\n        let iter = set.iter();\n        assert_eq!(iter.len(), 3);\n\n        let empty_set: HashSet<i32> = HashSet::new();\n        let empty_iter = empty_set.iter();\n        assert_eq!(empty_iter.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580441, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=115, prompt_tokens=10986, total_tokens=11101, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwNZdhOpKFcsntt4lwUTz1CQ3wj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_fold_with_sum() {\n        let set: HashSet<i32> = [1, 2, 3, 4, 5].iter().cloned().collect();\n        let sum: i32 = set.iter().fold(0, |acc, &x| acc + x);\n        assert_eq!(sum, 15);\n    }\n\n    #[test]\n    fn test_fold_with_product() {\n        let set: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();\n        let product: i32 = set.iter().fold(1, |acc, &x| acc * x);\n        assert_eq!(product, 24);\n    }\n\n    #[test]\n    fn test_fold_with_concat() {\n        let set: HashSet<&str> = ["hello", " ", "world"].iter().cloned().collect();\n        let concatenated: String = set.iter().fold(String::new(), |acc, &x| acc + x);\n        assert_eq!(concatenated, "hello world");\n    }\n\n    #[test]\n    fn test_fold_with_empty_set() {\n        let set: HashSet<i32> = HashSet::new();\n        let sum: i32 = set.iter().fold(0, |acc, &x| acc + x);\n        assert_eq!(sum, 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580447, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=318, prompt_tokens=11021, total_tokens=11339, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwWQz5RAQUClfxupMsZz3DmNAZx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_next() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        let mut iter = set.iter();\n        let mut collected = Vec::new();\n\n        while let Some(&value) = iter.next() {\n            collected.push(value);\n        }\n\n        collected.sort_unstable();\n        assert_eq!(collected, vec![1, 2, 3]);\n\n        // Verify that the iterator is fused\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_empty_next() {\n        let set: HashSet<i32> = HashSet::new();\n        let mut iter = set.iter();\n\n        assert_eq!(iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580456, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=195, prompt_tokens=10990, total_tokens=11185, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwelWytYuvCDFGnEgXYq7OB2Uab', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        let iter = set.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_single() {\n        let set: HashSet<i32> = [(1)].iter().cloned().collect();\n        let iter = set.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n    }\n\n    #[test]\n    fn test_size_hint_multiple() {\n        let set: HashSet<i32> = [(1), (2), (3)].iter().cloned().collect();\n        let iter = set.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 3);\n        assert_eq!(upper, Some(3));\n    }\n\n    #[test]\n    fn test_size_hint_after_iteration() {\n        let set: HashSet<i32> = [(1), (2), (3)].iter().cloned().collect();\n        let mut iter = set.iter();\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 3);\n        assert_eq!(upper, Some(3));\n        \n        iter.next(); // advance the iterator\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580464, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=362, prompt_tokens=10995, total_tokens=11357, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwsnYVS05omjG5qhfDqhPE6Gdon', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_clone_symmetric_difference() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![2, 3, 4]);\n        let symmetric_difference: SymmetricDifference<i32, _> = set1.symmetric_difference(&set2);\n        \n        let cloned_difference = symmetric_difference.clone();\n        \n        assert_eq!(symmetric_difference.collect::<HashSet<_>>(), cloned_difference.collect::<HashSet<_>>());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580478, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=147, prompt_tokens=727, total_tokens=874, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclwztWI68toZkNR873Qw15jB6jws', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_set::HashSet;\n    use hashbrown::set::SymmetricDifference;\n\n    #[test]\n    fn test_fold_symmetric_difference() {\n        let set_a: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set_b: HashSet<i32> = [3, 4, 5].iter().cloned().collect();\n        \n        let symmetric_difference: SymmetricDifference<_, _, _> = set_a.symmetric_difference(&set_b);\n\n        let result = symmetric_difference.fold(0, |acc, &x| acc + x);\n\n        assert_eq!(result, 7); // 1 + 2 + 4 + 5 = 12\n    }\n\n    #[test]\n    fn test_fold_symmetric_difference_empty() {\n        let set_a: HashSet<i32> = HashSet::new();\n        let set_b: HashSet<i32> = HashSet::new();\n        \n        let symmetric_difference: SymmetricDifference<_, _, _> = set_a.symmetric_difference(&set_b);\n\n        let result = symmetric_difference.fold(0, |acc, &x| acc + x);\n\n        assert_eq!(result, 0); // Sum is 0 for empty sets\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580485, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=280, prompt_tokens=755, total_tokens=1035, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclx5Atm6RFIhpPLBX8vsGv1l3uef', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_symmetric_difference_next() {\n        let set_a: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set_b: HashSet<i32> = [2, 3, 4].iter().cloned().collect();\n        let symmetric_diff = set_a.symmetric_difference(&set_b);\n\n        let mut iter = symmetric_diff.iter();\n        \n        assert_eq!(iter.next(), Some(&1));\n        assert_eq!(iter.next(), Some(&4));\n        assert_eq!(iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580491, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=147, prompt_tokens=724, total_tokens=871, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxAyL8dJEw0TDddjykFJ30YpChv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_size_hint_empty_sets() {\n        let set1: HashSet<i32> = HashSet::new();\n        let set2: HashSet<i32> = HashSet::new();\n        let symmetric_difference = set1.symmetric_difference(&set2);\n        assert_eq!(symmetric_difference.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty_sets() {\n        let mut set1: HashSet<i32> = HashSet::new();\n        set1.insert(1);\n        set1.insert(2);\n\n        let mut set2: HashSet<i32> = HashSet::new();\n        set2.insert(2);\n        set2.insert(3);\n\n        let symmetric_difference = set1.symmetric_difference(&set2);\n        assert_eq!(symmetric_difference.size_hint(), (2, Some(2)));\n    }\n\n    #[test]\n    fn test_size_hint_with_clone() {\n        let mut set1: HashSet<i32> = HashSet::new();\n        set1.insert(1);\n        set1.insert(2);\n\n        let mut set2: HashSet<i32> = HashSet::new();\n        set2.insert(2);\n        set2.insert(3);\n\n        let symmetric_difference = set1.symmetric_difference(&set2);\n        let symmetric_difference_clone = symmetric_difference.clone();\n        assert_eq!(symmetric_difference.size_hint(), symmetric_difference_clone.size_hint());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580496, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=325, prompt_tokens=729, total_tokens=1054, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxH8ujYhx2jKulVHk92bDYyfQA5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashSet;\n    use std::hash::BuildHasherDefault;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_union_clone() {\n        let set_a: HashSet<i32> = [1, 2, 3].iter().cloned().collect();\n        let set_b: HashSet<i32> = [3, 4, 5].iter().cloned().collect();\n        let union: Union<_, _, BuildHasherDefault<core::hash::BuildHasher>> = set_a.union(&set_b);\n        \n        let cloned_union = union.clone();\n        \n        assert_eq!(union.size_hint(), cloned_union.size_hint());\n        assert!(union.eq(&cloned_union));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580503, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=170, prompt_tokens=696, total_tokens=866, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxMRBv3blGgNqys11NiuTyPkBAT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_fold_union() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![3, 4, 5]);\n        \n        let union_iter = set1.union(&set2);\n        \n        let result = union_iter.fold(0, |acc, &x| acc + x);\n        \n        assert_eq!(result, 15); // 1 + 2 + 3 + 4 + 5 = 15\n    }\n\n    #[test]\n    fn test_fold_union_with_initial_value() {\n        let set1: HashSet<i32> = HashSet::from_iter(vec![1, 2]);\n        let set2: HashSet<i32> = HashSet::from_iter(vec![2, 3]);\n        \n        let union_iter = set1.union(&set2);\n        \n        let result = union_iter.fold(10, |acc, &x| acc * x);\n        \n        assert_eq!(result, 60); // 10 * 1 * 2 * 3 = 60\n    }\n    \n    #[test]\n    fn test_fold_union_empty() {\n        let set1: HashSet<i32> = HashSet::new();\n        let set2: HashSet<i32> = HashSet::new();\n        \n        let union_iter = set1.union(&set2);\n        \n        let result = union_iter.fold(5, |acc, &x| acc + x);\n        \n        assert_eq!(result, 5); // Initial value is returned as the union is empty\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580508, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=376, prompt_tokens=726, total_tokens=1102, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxXz30lhZ0s5YT8JEXOVoYtiGSd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust import based on your module structure\n    use hashbrown::HashSet; // Ensure you have the correct crate import\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_next() {\n        let set_a: HashSet<i32, RandomState> = [1, 2, 3].iter().cloned().collect();\n        let set_b: HashSet<i32, RandomState> = [3, 4, 5].iter().cloned().collect();\n        \n        let union = set_a.union(&set_b);\n        let mut union_iter = union.into_iter();\n        \n        let first = union_iter.next(); // Should yield Some(&1) or Some(&3) based on the implementation order\n        let second = union_iter.next(); // Should yield Some(&2) or Some(&4) based on the implementation order\n        let third = union_iter.next(); // Should yield Some(&5) or Some(&3) based on the implementation order\n        let fourth = union_iter.next(); // Should yield None\n        \n        assert!(first.is_some());\n        assert!(second.is_some());\n        assert!(third.is_some());\n        assert!(fourth.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580519, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=270, prompt_tokens=695, total_tokens=965, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxfmA8M1Cw4NS546kp6M9xuHxNf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_size_hint_empty_sets() {\n        let set1: HashSet<i32> = HashSet::new();\n        let set2: HashSet<i32> = HashSet::new();\n        let union = set1.union(&set2);\n        assert_eq!(union.size_hint(), (0, Some(0)));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty_sets() {\n        let set1: HashSet<i32> = HashSet::from([1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from([3, 4, 5]);\n        let union = set1.union(&set2);\n        assert_eq!(union.size_hint(), (5, Some(5))); // Size might be exact\n    }\n\n    #[test]\n    fn test_size_hint_some_empty_and_non_empty_sets() {\n        let set1: HashSet<i32> = HashSet::new();\n        let set2: HashSet<i32> = HashSet::from([3, 4, 5]);\n        let union = set1.union(&set2);\n        assert_eq!(union.size_hint(), (3, Some(3)));\n    }\n    \n    #[test]\n    fn test_size_hint_when_sets_have_common_elements() {\n        let set1: HashSet<i32> = HashSet::from([1, 2, 3]);\n        let set2: HashSet<i32> = HashSet::from([2, 3, 4]);\n        let union = set1.union(&set2);\n        assert_eq!(union.size_hint(), (4, Some(4))); // 1, 2, 3, 4 are unique\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580527, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=386, prompt_tokens=700, total_tokens=1086, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclxpCBqoqzPXWk2XytmBkmfSlEXj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_len_empty() {\n        let raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), 0);\n        let drain = RawDrain {\n            iter: RawIter::default(),\n            table: raw_table,\n            orig_table: NonNull::new_unchecked(&raw_table),\n            marker: PhantomData,\n        };\n        assert_eq!(drain.len(), 0);\n    }\n\n    #[test]\n    fn test_len_after_inserts() {\n        let raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), 10);\n        let drain = RawDrain {\n            iter: RawIter::default(),\n            table: raw_table,\n            orig_table: NonNull::new_unchecked(&raw_table),\n            marker: PhantomData,\n        };\n        assert_eq!(drain.len(), 0); // Assuming that no elements have been inserted\n\n        // Simulate inserting elements into the table.\n        // This is pseudo-code, as inserting elements is outside the scope of the provided context.\n        // Assume handle_insert is a function that inserts a value into the RawTableInner.\n        // handle_insert(&mut raw_table, value);\n        \n        // Assume now 5 elements are inserted.\n        // raw_table.items = 5; // This would directly adjust the simulated item count\n\n        // This requires adjust crown of RawIter or some underlying structure to validate state\n        // assert_eq!(drain.len(), 5); // would check the updated size, if the table count would increase properly\n    }\n\n    #[test]\n    fn test_len_after_removal() {\n        let raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), 10);\n        let drain = RawDrain {\n            iter: RawIter::default(),\n            table: raw_table,\n            orig_table: NonNull::new_unchecked(&raw_table),\n            marker: PhantomData,\n        };\n\n        // Simulate elements are inserted, say 5 elements\n        // raw_table.items = 5; \n\n        // Now assume we remove one\n        // handle_remove(&mut raw_table, value); // This is hypothetical\n\n        // raw_table.items = 4; // would adjust simulated item count after removal\n        // assert_eq!(drain.len(), 4); // checking length after removal\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580537, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=508, prompt_tokens=16361, total_tokens=16869, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcly2m4rabCGK1ad1xI3KDNvkwYzz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_fold() {\n        let allocator = Global; // Create a global allocator instance\n        let mut raw_table = RawTableInner::with_capacity(&allocator, TableLayout::default(), 8);\n        \n        // Simulate inserting elements in raw_table, ensuring it has elements\n        // This part requires creating valid buckets in raw_table, which depends on your implementation\n        // Assuming a method `insert` which would populate raw_table\n        \n        let init_value = 0; // Starting value\n        let result = raw_table\n            .iter() // Assuming it has an `iter` method to get an iterator\n            .fold(init_value, |acc, bucket| {\n                // Process bucket to get some value, assume bucket has a way to get value, e.g. bucket.as_ref().value\n                acc + 1 // Incrementing for each bucket; replace this with the actual logic needed\n            });\n        \n        let expected = raw_table.items; // Assuming items provides how many buckets are filled\n        assert_eq!(result, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580550, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=245, prompt_tokens=16361, total_tokens=16606, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclyAhXihAvcJUX7l5x4NeZDPLarp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_next() {\n        // Create a mock structure to test the Drain's next function\n        struct MockAllocator;\n\n        // Mock the RawTableInner\n        let raw_table_inner = RawTableInner {\n            bucket_mask: 3, // mock value for testing\n            ctrl: NonNull::new(Box::into_raw(Box::new([0; 4])) as *mut u8).unwrap(),\n            growth_left: 4,\n            items: 0,\n        };\n\n        // Create a RawDrain instance\n        let mut raw_drain = RawDrain {\n            iter: RawIter {\n                iter: RawIterRange {\n                    current_group: BitMaskIter(BitMask(1)),\n                    data: Bucket {\n                        ptr: NonNull::new(Box::into_raw(Box::new(42)).cast()).unwrap(),\n                    },\n                    next_ctrl: std::ptr::null(),\n                    end: std::ptr::null(),\n                },\n                items: 1,\n            },\n            table: raw_table_inner,\n            orig_table: NonNull::new(Box::into_raw(Box::new(raw_table_inner))).unwrap(),\n            marker: PhantomData,\n        };\n\n        // Call the next method and check the result\n        let result = raw_drain.next();\n        assert!(result.is_some());\n        assert_eq!(unsafe { *result.unwrap() }, 42); // Assuming the Bucket contained 42\n\n        // Check if the next call returns None\n        let result = raw_drain.next();\n        assert!(result.is_none());\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580558, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=341, prompt_tokens=16361, total_tokens=16702, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclyJjUtbRvC3jkBbb1qxIc3xzb0a', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{RawDrain, RawTableInner, RawIter};\n    \n    #[test]\n    fn test_size_hint_empty() {\n        let empty_table = RawTableInner::with_capacity(&*Global, TableLayout::default(), 8);\n        let drain = RawDrain {\n            iter: RawIter::default(),\n            table: empty_table,\n            orig_table: NonNull::from(&empty_table),\n            marker: PhantomData,\n        };\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut table = RawTableInner::with_capacity(&*Global, TableLayout::default(), 8);\n        // Assuming we insert two items\n        table.items = 2;\n\n        let drain = RawDrain {\n            iter: RawIter::default(),\n            table,\n            orig_table: NonNull::from(&table),\n            marker: PhantomData,\n        };\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n\n    #[test]\n    fn test_size_hint_after_drain() {\n        let mut table = RawTableInner::with_capacity(&*Global, TableLayout::default(), 8);\n        // Inserting some items\n        table.items = 5;\n\n        let mut drain = RawDrain {\n            iter: RawIter::default(),\n            table,\n            orig_table: NonNull::from(&table),\n            marker: PhantomData,\n        };\n\n        // Simulate draining 3 items\n        drain.iter.items = 2; // remaining items\n        let (lower, upper) = drain.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580567, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=406, prompt_tokens=16361, total_tokens=16767, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclyUaaIE5CxdXv9qkjzyKq6OB6Qc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_next_function() {\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n        \n        // Insert elements into the table to test next\n        unsafe {\n            table.insert(10, 1, |x| *x);\n            table.insert(20, 2, |x| *x);\n            table.insert(30, 3, |x| *x);\n        }\n\n        let mut count = 0;\n        while let Some(value) = extractor.next(|x| *x > 0) {\n            count += value;\n        }\n\n        // It should sum the values that satisfy the condition\n        assert_eq!(count, 6); // 1 + 2 + 3\n    }\n\n    #[test]\n    fn test_next_function_with_no_elements() {\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n\n        let result = extractor.next(|_x| false);\n        // It should return None as there are no elements\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_next_function_with_condition() {\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n\n        // Insert elements into the table to test next\n        unsafe {\n            table.insert(10, 1, |x| *x);\n            table.insert(20, 2, |x| *x);\n            table.insert(30, 3, |x| *x);\n        }\n\n        let mut count = 0;\n        while let Some(value) = extractor.next(|x| *x == 2) {\n            count += value;\n        }\n\n        // It should find and sum the elements matching the condition\n        assert_eq!(count, 2); // Only the second element matches the condition\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580578, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=484, prompt_tokens=16361, total_tokens=16845, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclyexZ30wYwEuepwepv3bY3EsiaK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{RawTable, RawExtractIf, Bucket};\n    use crate::control::bitmask::BitMask;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let table: RawTable<i32, Global> = RawTable::default();\n        let raw_extract_if = RawExtractIf {\n            iter: unsafe { table.iter() },\n            table: &mut table,\n        };\n        let (lower, upper) = raw_extract_if.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_non_empty() {\n        let mut table: RawTable<i32, Global> = RawTable::default();\n        let value = 42;\n        unsafe {\n            let _bucket = table.insert(0, value, |_x| 0);\n        }\n\n        let raw_extract_if = RawExtractIf {\n            iter: unsafe { table.iter() },\n            table: &mut table,\n        };\n        let (lower, upper) = raw_extract_if.size_hint();\n        assert_eq!(lower, 0);\n        assert!(upper.is_some());\n    }\n\n    #[test]\n    fn test_size_hint_with_multiple_elements() {\n        let mut table: RawTable<i32, Global> = RawTable::default();\n        for i in 0..10 {\n            unsafe {\n                table.insert(i as u64, i, |_x| i as u64);\n            }\n        }\n\n        let raw_extract_if = RawExtractIf {\n            iter: unsafe { table.iter() },\n            table: &mut table,\n        };\n        let (lower, upper) = raw_extract_if.size_hint();\n        assert_eq!(lower, 0);\n        assert!(upper.is_some());\n    }\n\n    #[test]\n    fn test_size_hint_with_no_elements() {\n        let table: RawTable<i32, Global> = RawTable::default();\n        let raw_extract_if = RawExtractIf {\n            iter: unsafe { table.iter() },\n            table: &mut table,\n        };\n        let (lower, upper) = raw_extract_if.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580588, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=484, prompt_tokens=16361, total_tokens=16845, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclyszfKv4e6Zzgl5uU2FvTsk2rMl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::RawTable; // Assuming the use of the appropriate path to access the RawTable.\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clone_empty_table() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), 0);\n        assert_eq!(cloned_table.buckets(), 1);\n        assert!(cloned_table.is_empty());\n    }\n\n    #[test]\n    fn test_clone_non_empty_table() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        table.insert(1, 10, |x| x);\n        table.insert(2, 20, |x| x);\n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), table.len());\n        assert_eq!(cloned_table.buckets(), table.buckets());\n        assert!(cloned_table.get(1, |x| *x == 10).is_some());\n        assert!(cloned_table.get(2, |x| *x == 20).is_some());\n    }\n\n    #[test]\n    fn test_clone_after_insertions() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        table.insert(1, 10, |x| x);\n        table.insert(2, 20, |x| x);\n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), table.len());\n        assert_eq!(cloned_table.get(1, |x| *x == 10).is_some(), true);\n        assert_eq!(cloned_table.get(2, |x| *x == 20).is_some(), true);\n    }\n\n    #[test]\n    fn test_clone_table_with_multiple_elements() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        table.insert(1, 10, |x| x);\n        table.insert(2, 20, |x| x);\n        table.insert(3, 30, |x| x);\n        let cloned_table = table.clone();\n        assert_eq!(cloned_table.len(), table.len());\n        assert_eq!(cloned_table.get(1, |x| *x == 10).is_some(), true);\n        assert_eq!(cloned_table.get(2, |x| *x == 20).is_some(), true);\n        assert_eq!(cloned_table.get(3, |x| *x == 30).is_some(), true);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580602, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=570, prompt_tokens=16361, total_tokens=16931, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bclz61EOlb9TOLP1Ry78Y4qn9nWJA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_hash_table_default_creation() {\n        // Create a default HashTable\n        let table: HashTable<i32, Global> = HashTable::default();\n\n        // Assert that the table is empty\n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.buckets(), 1); // Default table has 1 bucket\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580616, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=109, prompt_tokens=16361, total_tokens=16470, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzDCQpqxXnnXjq9ZNdMsbttpND3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n\n    #[test]\n    fn test_into_iter() {\n        let mut table = RawTable::new_in(Global); // Assuming RawTable is initialized appropriately\n        let value = 42; // Example value to insert\n\n        // Insert a value into the table\n        let bucket = table.insert(0, value, |&x| x as u64); // Using an example hasher\n\n        // Call the into_iter method\n        let mut iter = table.into_iter();\n\n        // Check that the iterator yields the expected value\n        assert_eq!(iter.next().unwrap().as_ref(), &value);\n        assert_eq!(iter.next(), None); // Ensure the iterator is finished\n    }\n\n    #[test]\n    fn test_into_iter_empty() {\n        let table: RawTable<i32> = RawTable::new_in(Global); // Empty table\n\n        // Call the into_iter method\n        let mut iter = table.into_iter();\n\n        // Ensure the iterator is empty\n        assert_eq!(iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580623, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=236, prompt_tokens=16361, total_tokens=16597, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzL4JlPpeXkLEqWJxCmkTvzUOJG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_into_iter_default() {\n        let iter: IntoIter<u32, Global> = IntoIter::default();\n        assert_eq!(iter.len(), 0);\n    }\n\n    #[test]\n    fn test_into_iter_default_non_empty() {\n        let mut iter: IntoIter<u32, Global> = IntoIter::default();\n        \n        // Assume we have some method to fill iter\n        // fill_iter(&mut iter);\n        \n        // Check the len is still 0 for the newly created default\n        assert_eq!(iter.len(), 0);\n        \n        // After filling, the default iter should still be usable for checking the default method\n        let default_iter: IntoIter<u32, Global> = IntoIter::default();\n        assert_eq!(default_iter.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580631, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=193, prompt_tokens=9951, total_tokens=10144, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzSuOdilbFGui9XyPUI8m3R0hed', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use raw::{RawIntoIter, RawIter, RawIterRange, Bucket};\n    use table::IntoIter;\n    \n    #[test]\n    fn test_len() {\n        let mut table: HashTable<u32> = HashTable::new();\n        table.insert(1);\n        table.insert(2);\n        table.insert(3);\n        \n        let iterator: IntoIter<u32> = table.into_iter();\n        let length = iterator.len();\n        \n        assert_eq!(length, 3);\n        \n        table.insert(4);\n        \n        let iterator: IntoIter<u32> = table.into_iter();\n        let length_after_insert = iterator.len();\n        \n        assert_eq!(length_after_insert, 4);\n    }\n\n    #[test]\n    fn test_len_empty() {\n        let table: HashTable<u32> = HashTable::new();\n        let iterator: IntoIter<u32> = table.into_iter();\n        assert_eq!(iterator.len(), 0);\n    }\n\n    #[test]\n    fn test_len_after_removal() {\n        let mut table: HashTable<u32> = HashTable::new();\n        table.insert(1);\n        table.insert(2);\n        table.insert(3);\n        \n        let iterator: IntoIter<u32> = table.into_iter();\n        assert_eq!(iterator.len(), 3);\n        \n        table.remove(&2);\n        \n        let iterator: IntoIter<u32> = table.into_iter();\n        assert_eq!(iterator.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580638, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=330, prompt_tokens=9945, total_tokens=10275, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzbSlxIUUNOKqtlcxwUuwXxofdO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n\n    #[test]\n    fn test_fold() {\n        let bitmask = BitMask(0b101010); // Example BitMask\n        let into_iter = IntoIter {\n            inner: RawIntoIter {\n                iter: RawIter::default(),\n                allocation: None,\n                marker: PhantomData,\n            },\n        };\n\n        let result = into_iter.fold(0, |acc, _| acc + 1); // Counting the elements\n        assert_eq!(result, 0); // Adjust based on the actual expected count of elements\n    }\n\n    #[test]\n    fn test_fold_with_non_identity_operation() {\n        let bitmask = BitMask(0b110); // Example BitMask\n        let into_iter = IntoIter {\n            inner: RawIntoIter {\n                iter: RawIter::default(),\n                allocation: None,\n                marker: PhantomData,\n            },\n        };\n\n        let result = into_iter.fold(1, |acc, _| acc * 2); // Doubling each time\n        assert_eq!(result, 1); // Adjust based on the actual expected result\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580647, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=254, prompt_tokens=9979, total_tokens=10233, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzlwAPS8t9Wp1NoeGIujhwO8YEZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use control::bitmask::BitMaskIter;\n    use raw::Bucket;\n    use raw::RawIntoIter;\n    use raw::RawIter;\n    use raw::RawIterRange;\n    use table::IntoIter;\n\n    #[test]\n    fn test_next_with_empty_iter() {\n        let empty_iter: IntoIter<i32> = IntoIter::default();\n        assert_eq!(empty_iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_single_element() {\n        let mut into_iter = IntoIter {\n            inner: RawIntoIter {\n                iter: RawIter {\n                    iter: RawIterRange::default(), // Assuming default to a single item\n                    items: 1,\n                },\n                allocation: None,\n                marker: PhantomData,\n            },\n        };\n        // Assuming `write` is used to prepare the single element\n        unsafe {\n            into_iter.inner.iter.next().unwrap().write(42);\n        }\n        assert_eq!(into_iter.next(), Some(42));\n        assert_eq!(into_iter.next(), None);\n    }\n\n    #[test]\n    fn test_next_with_multiple_elements() {\n        let mut into_iter = IntoIter {\n            inner: RawIntoIter {\n                iter: RawIter {\n                    iter: RawIterRange::default(), // Replace with a valid initialization\n                    items: 3, // Assuming we have 3 elements\n                },\n                allocation: None,\n                marker: PhantomData,\n            },\n        };\n        unsafe {\n            into_iter.inner.iter.next().unwrap().write(1);\n            into_iter.inner.iter.next().unwrap().write(2);\n            into_iter.inner.iter.next().unwrap().write(3);\n        }\n\n        assert_eq!(into_iter.next(), Some(1));\n        assert_eq!(into_iter.next(), Some(2));\n        assert_eq!(into_iter.next(), Some(3));\n        assert_eq!(into_iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580657, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=419, prompt_tokens=9947, total_tokens=10366, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BclzvaO4G2SELnetC3PVKAxGs7UW2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::table::IntoIter;\n    use crate::raw::{RawIntoIter, RawIter, RawIterRange};\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_size_hint() {\n        // Arrange\n        let mut into_iter: IntoIter<i32, Global> = IntoIter::default();\n\n        // Act\n        let (lower, upper) = into_iter.size_hint();\n\n        // Assert\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_with_elements() {\n        // Arrange\n        let mut into_iter: IntoIter<i32, Global> = IntoIter::default();\n        // Assuming you have a way to populate into_iter with elements, add your elements here\n\n        // Act\n        let (lower, upper) = into_iter.size_hint();\n\n        // Assert\n        assert!(lower > 0);\n        assert!(upper.is_some());\n        assert!(upper.unwrap() >= lower);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580667, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=253, prompt_tokens=9953, total_tokens=10206, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm04oxBvWhvoKTikiOw6e1tWlnol', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_iter_default() {\n        let iter: Iter<u8> = Iter::default();\n        assert!(iter.inner.items == 0);\n    }\n\n    #[test]\n    fn test_iter_clone() {\n        let iter: Iter<u8> = Iter::default();\n        let iter_clone = iter.clone();\n        assert!(iter.inner.items == iter_clone.inner.items);\n    }\n\n    #[test]\n    fn test_iter_next() {\n        let mut iter: Iter<u8> = Iter::default();\n        let result = iter.next();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_iter_size_hint() {\n        let iter: Iter<u8> = Iter::default();\n        let (low, high) = iter.size_hint();\n        assert_eq!(low, 0);\n        assert_eq!(high, Some(0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580676, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=206, prompt_tokens=9449, total_tokens=9655, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0CqVXYUaQm7CxAonWXTBDur2eK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n    use crate::raw::{Bucket, RawIter, RawIterRange};\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use crate::table::Iter;\n\n    #[test]\n    fn test_iter_len() {\n        let buffer: Vec<usize> = vec![1, 2, 3, 4, 5];\n        let bucket_ptr = NonNull::new(buffer.as_ptr() as *mut usize).unwrap();\n        \n        let bucket = unsafe { Bucket::from_base_index(bucket_ptr, buffer.len() - 1) };\n        let iter = RawIter {\n            iter: RawIterRange::new(std::ptr::null(), bucket, buffer.len()),\n            items: buffer.len(),\n        };\n        \n        let iter_wrapper = Iter {\n            inner: iter,\n            marker: std::marker::PhantomData,\n        };\n\n        assert_eq!(iter_wrapper.len(), buffer.len());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580684, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=216, prompt_tokens=9438, total_tokens=9654, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0OJjcHtHTFGM4nDe8Bdk17X630', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_iter_clone() {\n        // Set up test data\n        let data: Vec<i32> = vec![1, 2, 3, 4, 5];\n        let base = NonNull::new(data.as_ptr() as *mut _).unwrap();\n        let bucket = unsafe { Bucket::from_base_index(base, 0) };\n        let raw_iter = RawIter {\n            iter: RawIterRange::new(std::ptr::null(), bucket, data.len()),\n            items: data.len(),\n        };\n        let iter = Iter {\n            inner: raw_iter,\n            marker: std::marker::PhantomData,\n        };\n\n        // Clone the iterator\n        let cloned_iter = iter.clone();\n\n        // Validate the state of the cloned iterator\n        assert_eq!(iter.len(), cloned_iter.len());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580696, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=201, prompt_tokens=9456, total_tokens=9657, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0VGsXniTXDTmbbZxN3Rag0R5CF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use raw::{Bucket, RawIter};\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_fold_empty_iterator() {\n        let empty_iter: RawIter<u32> = RawIter::default();\n        let result = empty_iter.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    fn test_fold_single_element_iterator() {\n        let data = vec![42]; // Example data\n        let bucket = unsafe { Bucket::from_base_index(NonNull::new_unchecked(data.as_ptr() as *mut _), 0) };\n        let mut iter = RawIter {\n            iter: RawIterRange::new(core::ptr::null(), bucket, 1),\n            items: 1,\n        };\n\n        let result = iter.fold(0, |acc, _| acc + 1);\n        assert_eq!(result, 1);\n    }\n\n    #[test]\n    fn test_fold_multiple_elements_iterator() {\n        let data = vec![1, 2, 3, 4, 5]; // Example data\n        let mut acc = 0;\n        let mut buckets: Vec<Bucket<u32>> = data.iter()\n            .map(|&value| unsafe { Bucket::from_base_index(NonNull::new_unchecked(data.as_ptr() as *mut _), value as usize) })\n            .collect();\n        let mut iter = RawIter {\n            iter: RawIterRange::new(core::ptr::null(), buckets[0].clone(), buckets.len()),\n            items: buckets.len(),\n        };\n\n        let result = iter.fold(acc, |acc, bucket| acc + unsafe { bucket.as_ref() });\n        assert_eq!(result, 15); // Sum of 1 + 2 + 3 + 4 + 5\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580703, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=413, prompt_tokens=9490, total_tokens=9903, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0frudJVxdDHPixALAdVuk8OsL1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    struct TestType {\n        value: i32,\n    }\n\n    #[test]\n    fn test_iter_next() {\n        // Setup: Create a test hashbrown table and populate it\n        let mut table = HashTable::new();\n        table.insert(1, TestType { value: 1 });\n        table.insert(2, TestType { value: 2 });\n        table.insert(3, TestType { value: 3 });\n\n        let mut iter = table.iter();\n\n        // Test: Ensure that calling next returns the correct values\n        assert_eq!(iter.next().map(|item| item.value), Some(1));\n        assert_eq!(iter.next().map(|item| item.value), Some(2));\n        assert_eq!(iter.next().map(|item| item.value), Some(3));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_next_empty() {\n        // Setup: Create an empty hashbrown table\n        let table: HashTable<TestType> = HashTable::new();\n        let mut iter = table.iter();\n\n        // Test: Ensure that next returns None\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_size_hint() {\n        // Setup: Create a test hashbrown table and populate it\n        let mut table = HashTable::new();\n        table.insert(1, TestType { value: 1 });\n        table.insert(2, TestType { value: 2 });\n\n        let iter = table.iter();\n\n        // Test: Ensure size hint is correct\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 2);\n        assert_eq!(upper, Some(2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580713, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=382, prompt_tokens=9479, total_tokens=9861, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0n0uqpw6DWgq7DkQj5kWewNOAU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_size_hint_empty() {\n        let raw_iter = RawIter::<i32> {\n            iter: RawIterRange {\n                current_group: BitMaskIter(BitMask(0)),\n                data: unsafe { Bucket::from_base_index(NonNull::new_unchecked(0 as *mut i32), 0) },\n                next_ctrl: core::ptr::null(),\n                end: core::ptr::null(),\n            },\n            items: 0,\n        };\n\n        let iter = Iter {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 0);\n        assert_eq!(upper, Some(0));\n    }\n\n    #[test]\n    fn test_size_hint_single_item() {\n        let mut raw_iter = RawIter::<i32> {\n            iter: RawIterRange {\n                current_group: BitMaskIter(BitMask(1)), // 1 means one bucket available\n                data: unsafe { Bucket::from_base_index(NonNull::new_unchecked(0 as *mut i32), 0) },\n                next_ctrl: core::ptr::null(),\n                end: core::ptr::null(),\n            },\n            items: 1,\n        };\n\n        let iter = Iter {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 1);\n        assert_eq!(upper, Some(1));\n    }\n\n    #[test]\n    fn test_size_hint_multiple_items() {\n        let mut raw_iter = RawIter::<i32> {\n            iter: RawIterRange {\n                current_group: BitMaskIter(BitMask(0b1111)), // 4 buckets available\n                data: unsafe { Bucket::from_base_index(NonNull::new_unchecked(0 as *mut i32), 0) },\n                next_ctrl: core::ptr::null(),\n                end: core::ptr::null(),\n            },\n            items: 4,\n        };\n\n        let iter = Iter {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        let (lower, upper) = iter.size_hint();\n        assert_eq!(lower, 4);\n        assert_eq!(upper, Some(4));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580721, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=508, prompt_tokens=9447, total_tokens=9955, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm0y15mQ5At5X4VerXc6QwyYNd2s', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::table::IterHash;\n\n    #[test]\n    fn test_default_iter_hash() {\n        let iter_hash: IterHash<u8> = IterHash::default();\n        // Assert that the default instance is correctly initialized\n        assert_eq!(iter_hash.inner.inner.bucket_mask, 0); // Change 0 to the expected initial bucket_mask value\n        assert!(iter_hash.inner.bitmask.0.0 == 0); // Assuming the default BitMask value\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580732, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=116, prompt_tokens=5131, total_tokens=5247, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm13CReXnR2klyOWHnNUYRpbpj6U', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::marker::PhantomData;\n\n    #[test]\n    fn test_iter_hash_clone() {\n        // Setup a RawIterHash with mock data for testing\n        let raw_iter_hash = RawIterHash {\n            inner: RawIterHashInner {\n                bucket_mask: 0xFF,  // example mask\n                ctrl: NonNull::from(&0 as *const u8 as *mut u8),\n                tag_hash: Tag::full(42),  // use an arbitrary hash\n                probe_seq: ProbeSeq { pos: 0, stride: 0 },\n                group: Group::static_empty().to_vec().into_iter().next().unwrap(),\n                bitmask: BitMaskIter(BitMask(0x1)),  // example with one set bit\n            },\n            _marker: PhantomData,\n        };\n\n        let iter_hash = IterHash {\n            inner: raw_iter_hash,\n            marker: PhantomData,\n        };\n\n        // Clone the IterHash\n        let cloned_iter_hash = iter_hash.clone();\n\n        // Verify that the cloned object is not the same as the original\n        assert_ne!(std::ptr::addr_of!(iter_hash), std::ptr::addr_of!(cloned_iter_hash), "The cloned IterHash should not be the same instance as the original");\n\n        // Further checks can be added to validate the internal state if necessary\n        // For example: assert_eq!(cloned_iter_hash.inner.bucket_mask, iter_hash.inner.bucket_mask);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580737, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=323, prompt_tokens=5139, total_tokens=5462, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1Bx2dj4puqQgGsoszIQdlFoCL9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::{BitMask, BitMaskIter};\n    use control::group::sse2::Group;\n    use control::tag::Tag;\n    use raw::{RawIterHash, RawIterHashInner};\n    use table::IterHash;\n    \n    #[test]\n    fn test_iterhash_fold() {\n        // Setup sample test data\n        let tag = Tag::full(12345);\n        let group = Group::static_empty();\n        let bitmask = BitMask(0b0000_0001); // A sample bitmask for one valid entry\n        let mut iter = RawIterHash::<usize> {\n            inner: RawIterHashInner {\n                bucket_mask: 1,\n                ctrl: NonNull::from(group),\n                tag_hash: tag,\n                probe_seq: ProbeSeq { pos: 0, stride: 0 },\n                group: group,\n                bitmask: BitMaskIter(bitmask),\n            },\n            _marker: PhantomData,\n        };\n        \n        let iter_hash = IterHash {\n            inner: iter,\n            marker: PhantomData,\n        };\n        \n        // Fold over the iterator\n        let result = iter_hash.fold(0, |acc, _| acc + 1);\n        \n        // Check if the fold result is as expected\n        assert_eq!(result, 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580745, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=294, prompt_tokens=5171, total_tokens=5465, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1Kyylyny2zAkj8KWrcL9F6LwHH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::table::IterHash;\n    use crate::raw::RawIterHash;\n    use crate::control::tag::Tag;\n    use crate::control::group::sse2::Group;\n    use crate::control::bitmask::{BitMask, BitMaskIter};\n    use std::marker::PhantomData;\n\n    struct TestHashTable {\n        // Mock struct to simulate a hash table\n        entries: Vec<Option<Tag>>,\n    }\n\n    impl TestHashTable {\n        fn new() -> Self {\n            TestHashTable {\n                entries: vec![Some(Tag::EMPTY); 16], // Initialize with empty tags\n            }\n        }\n\n        fn insert(&mut self, index: usize, tag: Tag) {\n            self.entries[index] = Some(tag); // Set a tag at a specific index\n        }\n\n        fn iter_hash(&self) -> IterHash<Tag> {\n            // Simulating the creation of an IterHash\n            let raw_iter = RawIterHash::default(); // Replace with relevant RawIterHash creation\n            IterHash {\n                inner: raw_iter,\n                marker: PhantomData,\n            }\n        }\n    }\n\n    #[test]\n    fn test_iter_hash_next() {\n        let mut table = TestHashTable::new();\n        table.insert(0, Tag::full(1)); // Insert a full tag\n        table.insert(1, Tag::EMPTY);    // Insert an empty tag\n        table.insert(2, Tag::full(2));   // Insert another full tag\n\n        let mut iter = table.iter_hash();\n\n        // Test the first call to next\n        let first = iter.next();\n        assert!(first.is_some());\n        assert_eq!(first.unwrap(), &Tag::full(1)); // Expect the first full tag\n\n        // Test the second call to next\n        let second = iter.next();\n        assert!(second.is_some());\n        assert_eq!(second.unwrap(), &Tag::full(2)); // Expect the second full tag\n\n        // Test that there are no more tags\n        let third = iter.next();\n        assert!(third.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580754, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=453, prompt_tokens=5160, total_tokens=5613, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1UlHJMQ5zHxIpBsUgNuFi1a80F', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::default::Default;\n\n    #[test]\n    fn test_iter_hash_mut_default() {\n        let iter: IterHashMut<u8> = IterHashMut::default();\n        assert_eq!(iter.inner.inner.bucket_mask, 0); // Assuming default initializes bucket_mask to 0\n        assert!(iter.inner.inner.ctrl.as_ptr().is_null()); // Assuming default initializes ctrl as null\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580764, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=100, prompt_tokens=5097, total_tokens=5197, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1YTh6RjaF1i9TyJMOy140K01Sb', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::{BitMask, BitMaskIter};\n    use control::group::sse2::Group;\n    use control::tag::Tag;\n    use raw::{RawIterHash, RawIterHashInner};\n    use table::IterHashMut;\n\n    #[test]\n    fn test_fold() {\n        // Prepare a sample hash table and fill it with test values\n        let mut values = vec![1, 2, 3, 4, 5];\n        let mut iter = IterHashMut {\n            inner: RawIterHash::default(), // Normally, this would be a proper iterator\n            marker: PhantomData,\n        };\n\n        // Test folding over the iterator with a sum\n        let sum = iter.fold(0, |acc, &val| acc + val);\n        assert_eq!(sum, 15); // 1 + 2 + 3 + 4 + 5 = 15\n    }\n\n    #[test]\n    fn test_fold_with_empty() {\n        // Test the edge case with an empty iterator\n        let iter: IterHashMut<i32> = IterHashMut {\n            inner: RawIterHash::default(),\n            marker: PhantomData,\n        };\n\n        let sum = iter.fold(0, |acc, _| acc + 1);\n        assert_eq!(sum, 0); // sum should be the initial value\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580768, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=305, prompt_tokens=5136, total_tokens=5441, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1ha1lXB3tHwfMRciCgww1nAeg3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::group::sse2::Group;\n    use control::tag::Tag;\n    use raw::{RawIterHash, RawIterHashInner};\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_iter_hash_mut_next() {\n        // Set up a mock RawIterHash with a valid state.\n        let tag1 = Tag::full(1);\n        let tag2 = Tag::full(2);\n        let group = Group(x86::_mm_set_epi8(0, 0, 0, 0, 0, 0, tag2.0 as i8, tag1.0 as i8));\n        let raw_iter = RawIterHash {\n            inner: RawIterHashInner {\n                bucket_mask: 0b11,\n                ctrl: NonNull::from(&group as *const _ as *mut _),\n                tag_hash: tag1,\n                probe_seq: ProbeSeq { pos: 0, stride: 0 },\n                group,\n                bitmask: BitMaskIter(BitMask(0b11)),\n            },\n            _marker: PhantomData,\n        };\n        let mut iter_hash_mut = IterHashMut {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        // Test that the next method returns mutable references to the expected items.\n        assert!(iter_hash_mut.next().is_some());\n        assert!(iter_hash_mut.next().is_some());\n        assert!(iter_hash_mut.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580777, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=324, prompt_tokens=5125, total_tokens=5449, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1qlmmAtBkZGskga8TDo7vjKtss', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_default_iter_mut() {\n        // Create an empty RawIter for testing\n        let raw_iter: RawIter<i32> = Default::default();\n        \n        // Create an instance of IterMut using the default function\n        let iter_mut: IterMut<i32> = Default::default();\n        \n        // Check that the inner RawIter of IterMut is indeed the default RawIter\n        assert_eq!(iter_mut.inner.items, raw_iter.items);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580786, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=125, prompt_tokens=9423, total_tokens=9548, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm1v2S7Q6okzUOJmwLXAxD1RjQLM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use raw::{Bucket, RawIter, RawIterRange};\n    use table::IterMut;\n\n    #[test]\n    fn test_iter_mut_len() {\n        let mut table: HashTable<usize> = HashTable::new();\n        table.insert(1);\n        table.insert(2);\n        table.insert(3);\n\n        let mut iter = table.iter_mut();\n        assert_eq!(iter.len(), 3);\n\n        iter.next();\n        assert_eq!(iter.len(), 2);\n\n        iter.next();\n        iter.next();\n        assert_eq!(iter.len(), 0);\n    }\n\n    #[test]\n    fn test_iter_mut_empty_len() {\n        let table: HashTable<usize> = HashTable::new();\n        let mut iter = table.iter_mut();\n        assert_eq!(iter.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580791, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=194, prompt_tokens=9411, total_tokens=9605, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm22CcvFxXbt1TerfzrsknbFl03S', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use raw::{Bucket, RawIter, RawIterRange};\n    use table::IterMut;\n\n    #[test]\n    fn test_fold() {\n        // Setup mock data\n        let bucket_data = vec![1, 2, 3, 4, 5]; // Example data\n        let buckets: Vec<Bucket<i32>> = bucket_data\n            .iter()\n            .map(|&item| unsafe { Bucket::from_base_index(NonNull::from(&bucket_data[0]), item as usize) })\n            .collect();\n\n        // Create a RawIter from buckets\n        let raw_iter = RawIter {\n            iter: RawIterRange::new(...), // Properly initialized RawIterRange\n            items: buckets.len(),\n        };\n\n        // Create an IterMut\n        let iter = IterMut {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        // Fold the iterator\n        let result: i32 = iter.fold(0, |acc, item| acc + item);\n\n        // Assert the result\n        assert_eq!(result, 15); // 1 + 2 + 3 + 4 + 5 = 15\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580798, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=273, prompt_tokens=9463, total_tokens=9736, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm29XOHslwkdWuTMsC6s4TiVIMTY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_iter_mut_next() {\n        // Setup test data\n        let mut data = vec![1, 2, 3, 4];\n        let raw_iter = RawIter { items: 4, iter: RawIterRange::new(/* appropriate parameters */) };\n        let mut iter_mut = IterMut {\n            inner: raw_iter,\n            marker: PhantomData,\n        };\n\n        // Test the next method\n        let first_item = iter_mut.next();\n        assert_eq!(first_item, Some(unsafe { &mut data[0] }));\n        let second_item = iter_mut.next();\n        assert_eq!(second_item, Some(unsafe { &mut data[1] }));\n        let third_item = iter_mut.next();\n        assert_eq!(third_item, Some(unsafe { &mut data[2] }));\n        let fourth_item = iter_mut.next();\n        assert_eq!(fourth_item, Some(unsafe { &mut data[3] }));\n        let no_item = iter_mut.next();\n        assert_eq!(no_item, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580805, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=246, prompt_tokens=9452, total_tokens=9698, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2G5sFsHE7bGvTQHBvypOv128zc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import everything necessary from the current module\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_size_hint() {\n        // Set up the initial state of the HashTable or any collection that\n        // utilizes IterMut\n        let mut collection: HashTable<i32> = HashTable::new();\n        \n        // Insert some elements into the collection\n        collection.insert(1);\n        collection.insert(2);\n        collection.insert(3);\n\n        // Create an iterator with the iter_mut() method\n        let mut iter = collection.iter_mut();\n        \n        // Get the size hint\n        let size_hint = iter.size_hint();\n\n        // Assert the size hint\n        assert_eq!(size_hint, (3, Some(3)), "Expected size hint to match (3, Some(3))");\n    }\n\n    #[test]\n    fn test_size_hint_empty() {\n        // Set up the initial state of the HashTable \n        let collection: HashTable<i32> = HashTable::new();\n        \n        // Create an iterator with the iter_mut() method\n        let mut iter = collection.iter_mut();\n        \n        // Get the size hint\n        let size_hint = iter.size_hint();\n\n        // Assert the size hint for empty iterator\n        assert_eq!(size_hint, (0, Some(0)), "Expected size hint to match (0, Some(0))");\n    }\n\n    #[test]\n    fn test_size_hint_after_removal() {\n        let mut collection: HashTable<i32> = HashTable::new();\n        \n        collection.insert(1);\n        collection.insert(2);\n        collection.insert(3);\n        collection.remove(&1); // Remove an element\n\n        let mut iter = collection.iter_mut();\n        let size_hint = iter.size_hint();\n\n        // Assert the size hint after one removal\n        assert_eq!(size_hint, (2, Some(2)), "Expected size hint to match (2, Some(2))");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580812, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=423, prompt_tokens=9420, total_tokens=9843, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2PC7JMrjUuJJFRgrezpd8g4pEF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_any_bit_set_with_no_bits_set() {\n        let mask = BitMask(0);\n        assert!(!mask.any_bit_set());\n    }\n\n    #[test]\n    fn test_any_bit_set_with_some_bits_set() {\n        let mask = BitMask(0b1010);\n        assert!(mask.any_bit_set());\n    }\n\n    #[test]\n    fn test_any_bit_set_with_all_bits_set() {\n        let mask = BitMask(u64::MAX);\n        assert!(mask.any_bit_set());\n    }\n\n    #[test]\n    fn test_any_bit_set_with_one_bit_set() {\n        let mask = BitMask(0b0001);\n        assert!(mask.any_bit_set());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580821, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=166, prompt_tokens=1146, total_tokens=1312, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2UFdeJRScI6pBHJMtDO7eyKo90', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::{BitMask, BITMASK_MASK};\n\n    #[test]\n    fn test_invert() {\n        let original_mask = BitMask(0b00001111); // example input\n        let inverted_mask = original_mask.invert();\n        assert_eq!(inverted_mask.0, !original_mask.0 & BITMASK_MASK);\n    }\n\n    #[test]\n    fn test_invert_all_ones() {\n        let original_mask = BitMask(BITMASK_MASK);\n        let inverted_mask = original_mask.invert();\n        assert_eq!(inverted_mask.0, 0);\n    }\n\n    #[test]\n    fn test_invert_all_zeros() {\n        let original_mask = BitMask(0);\n        let inverted_mask = original_mask.invert();\n        assert_eq!(inverted_mask.0, BITMASK_MASK);\n    }\n\n    #[test]\n    fn test_invert_random() {\n        let original_mask = BitMask(0b10101010); // example input\n        let inverted_mask = original_mask.invert();\n        assert_eq!(inverted_mask.0, !original_mask.0 & BITMASK_MASK);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580826, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=247, prompt_tokens=1150, total_tokens=1397, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2bpHs4fAOoUMt31IQCwaqvkcsg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_leading_zeros() {\n        // Given test cases for BitMask leading_zeros\n        let mask1 = BitMask(0b00000000_00000000_00000000_00000000); // 32 leading zeros\n        let mask2 = BitMask(0b00000000_00000000_00000000_00000001); // 31 leading zeros\n        let mask3 = BitMask(0b00000000_00000000_00000001_00000000); // 29 leading zeros\n        let mask4 = BitMask(0b11111111_11111111_11111111_11111111); // 0 leading zeros\n        \n        // Expected leading zero counts\n        assert_eq!(mask1.leading_zeros(), 32 / BITMASK_STRIDE); // Replace BITMASK_STRIDE with actual value\n        assert_eq!(mask2.leading_zeros(), 31 / BITMASK_STRIDE); // Replace BITMASK_STRIDE with actual value\n        assert_eq!(mask3.leading_zeros(), 29 / BITMASK_STRIDE); // Replace BITMASK_STRIDE with actual value\n        assert_eq!(mask4.leading_zeros(), 0 / BITMASK_STRIDE);  // Replace BITMASK_STRIDE with actual value\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580833, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=303, prompt_tokens=1153, total_tokens=1456, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2irPo1bTMaG0SQCjrVV4zT0Wpf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_lowest_set_bit_some() {\n        let mask = BitMask(0b00000010);\n        assert_eq!(mask.lowest_set_bit(), Some(1));\n    }\n\n    #[test]\n    fn test_lowest_set_bit_some_multiple_bits() {\n        let mask = BitMask(0b00001100);\n        assert_eq!(mask.lowest_set_bit(), Some(2));\n    }\n\n    #[test]\n    fn test_lowest_set_bit_none() {\n        let mask = BitMask(0b00000000);\n        assert_eq!(mask.lowest_set_bit(), None);\n    }\n\n    #[test]\n    fn test_lowest_set_bit_some_first_bit() {\n        let mask = BitMask(0b00000001);\n        assert_eq!(mask.lowest_set_bit(), Some(0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580840, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=202, prompt_tokens=1184, total_tokens=1386, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2pDTqoMFB7Fk8ERfi7jV5wyBEy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::control::bitmask::{BitMask, NonZeroBitMaskWord};\n\n    #[test]\n    fn test_nonzero_trailing_zeros() {\n        // BitMask stride assumption, adjust it based on actual crate definition\n        const BITMASK_STRIDE: usize = 8; // Update this according to the actual stride\n        let test_cases = vec![\n            (NonZeroBitMaskWord::new(0b0000_0001).unwrap(), 0), // 1 -> 0 trailing zeros\n            (NonZeroBitMaskWord::new(0b0000_0010).unwrap(), 1), // 2 -> 1 trailing zero\n            (NonZeroBitMaskWord::new(0b0000_1100).unwrap(), 2), // 12 -> 2 trailing zeros\n            (NonZeroBitMaskWord::new(0b0001_0000).unwrap(), 4), // 16 -> 4 trailing zeros\n            (NonZeroBitMaskWord::new(0b0010_0000).unwrap(), 5), // 32 -> 5 trailing zeros\n            (NonZeroBitMaskWord::new(0b1111_1110).unwrap(), 1), // 254 -> 1 trailing zero\n            (NonZeroBitMaskWord::new(0b1000_0000).unwrap(), 7), // 128 -> 7 trailing zeros\n        ];\n\n        for (input, expected) in test_cases {\n            assert_eq!(BitMask::nonzero_trailing_zeros(input), expected);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580847, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=352, prompt_tokens=278, total_tokens=630, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm2x2KUmhasM9Va9J2bNbtiIt9qR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_remove_lowest_bit() {\n        let mask1 = BitMask(0b1010); // Binary: 1010\n        let mask2 = mask1.remove_lowest_bit();\n        assert_eq!(mask2.0, 0b1000); // Should remove the lowest set bit (1 in this case)\n\n        let mask3 = BitMask(0b0000); // Binary: 0000\n        let mask4 = mask3.remove_lowest_bit();\n        assert_eq!(mask4.0, 0b0000); // Should remain unchanged, no bits set\n\n        let mask5 = BitMask(0b0001); // Binary: 0001\n        let mask6 = mask5.remove_lowest_bit();\n        assert_eq!(mask6.0, 0b0000); // Should remove the only set bit\n\n        let mask7 = BitMask(0b1111); // Binary: 1111\n        let mask8 = mask7.remove_lowest_bit();\n        assert_eq!(mask8.0, 0b1110); // Should remove the lowest set bit\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580855, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=269, prompt_tokens=1156, total_tokens=1425, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm33oiQ6a9Z9mrs95oz98mqSyShS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::bitmask::BitMask;\n\n    #[test]\n    fn test_trailing_zeros() {\n        let mask_with_trailing_zeros = BitMask(0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001);\n        assert_eq!(mask_with_trailing_zeros.trailing_zeros(), 0);\n\n        let mask_with_two_trailing_zeros = BitMask(0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000011);\n        assert_eq!(mask_with_two_trailing_zeros.trailing_zeros(), 1);\n\n        let mask_with_four_trailing_zeros = BitMask(0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00001111);\n        assert_eq!(mask_with_four_trailing_zeros.trailing_zeros(), 3);\n\n        let mask_with_no_trailing_zeros = BitMask(0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111);\n        assert_eq!(mask_with_no_trailing_zeros.trailing_zeros(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580861, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=301, prompt_tokens=1292, total_tokens=1593, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3ANUW9F00YysUw0QczxoslWVEo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::control::group::sse2::{Group, Tag};\n\n    #[test]\n    fn test_convert_special_to_empty_and_full_to_deleted() {\n        unsafe {\n            // Create a test group where:\n            // - Tag::FULL will be represented by 0x00\n            // - Tag::DELETED will be represented by 0xFF\n            // - Tag::EMPTY will be represented by 0x80\n            \n            let test_tags: [Tag; Group::WIDTH] = [\n                Tag::FULL, Tag::DELETED, Tag::EMPTY, Tag::FULL,\n                Tag::FULL, Tag::EMPTY, Tag::DELETED, Tag::EMPTY,\n                Tag::FULL, Tag::FULL, Tag::DELETED, Tag::EMPTY,\n                Tag::DELETED, Tag::FULL, Tag::FULL, Tag::EMPTY,\n            ];\n            \n            let group = Group::load(test_tags.as_ptr());\n\n            let transformed_group = group.convert_special_to_empty_and_full_to_deleted();\n\n            // Create expected group, where:\n            // - FULL -> DELETED\n            // - DELETED -> EMPTY\n            // - EMPTY -> EMPTY\n            let expected_tags: [Tag; Group::WIDTH] = [\n                Tag::DELETED, Tag::EMPTY, Tag::EMPTY, Tag::DELETED,\n                Tag::DELETED, Tag::EMPTY, Tag::EMPTY, Tag::EMPTY,\n                Tag::DELETED, Tag::DELETED, Tag::EMPTY, Tag::EMPTY,\n                Tag::EMPTY, Tag::DELETED, Tag::DELETED, Tag::EMPTY,\n            ];\n            \n            // Check if transformed group matches expected\n            let expected_group = Group::load(expected_tags.as_ptr());\n            let mask = transformed_group.match_empty_or_deleted();\n\n            assert_eq!(mask.0, expected_group.match_empty_or_deleted().0);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580868, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=399, prompt_tokens=1715, total_tokens=2114, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3IaCq0u8XmA7dFW6pv8NYCFz9z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem;\n\n    #[test]\n    fn test_load() {\n        // Prepare an array of Tags\n        let tags: [Tag; Group::WIDTH] = [\n            Tag::EMPTY, Tag::DELETED, Tag::full(1), Tag::full(2),\n            Tag::full(3), Tag::full(4), Tag::full(5), Tag::full(6),\n            Tag::full(7), Tag::full(8), Tag::full(9), Tag::full(10),\n            Tag::full(11), Tag::full(12), Tag::full(13), Tag::full(14),\n        ];\n        \n        // Get a pointer to the start of the tags array\n        let tags_ptr = tags.as_ptr();\n\n        // Use unsafe block to call the load function\n        let group: Group;\n\n        unsafe {\n            group = Group::load(tags_ptr);\n        }\n\n        // Verify that the loaded group has the expected first tag\n        let expected_mask = 0b1111_1111; // Corresponds to Tag::EMPTY in this example\n        let tag_mask = group.match_empty_or_deleted().0;\n\n        assert_eq!(tag_mask, expected_mask, "Loaded group did not match expected tag mask.");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580876, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=279, prompt_tokens=2109, total_tokens=2388, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3RNYlWLGeWUharvgG6ne5MvHdB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem;\n\n    #[test]\n    fn test_load_aligned() {\n        // Create a vector of Tags that is aligned\n        let mut aligned_tags: Vec<Tag> = vec![Tag::EMPTY; Group::WIDTH];\n        let aligned_ptr: *const Tag = aligned_tags.as_ptr();\n\n        unsafe {\n            // Ensure the pointer is aligned\n            assert_eq!(aligned_ptr.align_offset(mem::align_of::<Group>()), 0);\n            \n            // Load aligned tags into Group\n            let group = Group::load_aligned(aligned_ptr);\n            \n            // Check if the Group takes the expected value (all Tags are EMPTY)\n            let expected = Group::load_aligned(Group::static_empty().as_ptr());\n            assert_eq!(group, expected);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580885, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=177, prompt_tokens=2149, total_tokens=2326, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3XzN6bZtETlepIEwbNAkgE6vVz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use control::group::sse2::Group;\n    use control::tag::Tag;\n\n    #[test]\n    fn test_match_empty() {\n        let empty_group = Group::static_empty();\n        let group = unsafe { Group::load(empty_group.as_ptr()) };\n        let bitmask = group.match_empty();\n        \n        // Check if the BitMask indicates all bits set to EMPTY\n        assert!(bitmask.any_bit_set());\n        assert_eq!(bitmask.trailing_zeros(), 0);\n        assert_eq!(bitmask.leading_zeros(), 0);\n        assert_eq!(bitmask.lowest_set_bit(), Some(0));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580891, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=158, prompt_tokens=2430, total_tokens=2588, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3d8NKKKWyITOdeZ53VLENI1Tsw', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use control::group::sse2::Group;\n    use std::mem;\n\n    #[test]\n    fn test_match_empty_or_deleted() {\n        // Assuming Tag::EMPTY is defined as 0\n        let empty_tag = Tag(0);\n        let deleted_tag = Tag(1 << 7); // Assuming DELETED is defined as high bit set\n        let tags = [empty_tag, deleted_tag, empty_tag, empty_tag, deleted_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag, empty_tag];\n        let group = unsafe { Group::load(tags.as_ptr()) };\n        \n        let mask = group.match_empty_or_deleted();\n        \n        // Here, we expect the mask to have bits set for all empty and deleted tags\n        // Assuming DELETED is the high bit, the expected mask would be 0b1100000000000000\n        let expected_mask = (1 << 15) | (1 << 14); // bits for 0, 1\n        assert_eq!(mask.0, expected_mask as BitMaskWord);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580897, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=268, prompt_tokens=2548, total_tokens=2816, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3lVLnsmVrPGAYFySPFhDCrPvsd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::bitmask::BitMask;\n    use control::group::sse2::Group;\n\n    #[test]\n    fn test_match_full() {\n        // Arrange\n        let tags: [Tag; Group::WIDTH] = [Tag::FULL; Group::WIDTH]; // Assume all tags are FULL\n        let group = unsafe { Group::load(tags.as_ptr()) };\n\n        // Act\n        let bitmask = group.match_full();\n\n        // Assert\n        assert!(bitmask.any_bit_set(), "BitMask should have at least one bit set for FULL tags");\n        assert_eq!(bitmask, BitMask(BITMASK_MASK), "BitMask should match expected value for full tags");\n    }\n\n    #[test]\n    fn test_match_full_empty_tags() {\n        // Arrange\n        let tags: [Tag; Group::WIDTH] = [Tag::EMPTY; Group::WIDTH]; // Assume all tags are EMPTY\n        let group = unsafe { Group::load(tags.as_ptr()) };\n\n        // Act\n        let bitmask = group.match_full();\n\n        // Assert\n        assert!(!bitmask.any_bit_set(), "BitMask should not have any bits set for EMPTY tags");\n    }\n\n    #[test]\n    fn test_match_full_deleted_tags() {\n        // Arrange\n        let tags: [Tag; Group::WIDTH] = [Tag::DELETED; Group::WIDTH]; // Assume all tags are DELETED\n        let group = unsafe { Group::load(tags.as_ptr()) };\n\n        // Act\n        let bitmask = group.match_full();\n\n        // Assert\n        assert!(!bitmask.any_bit_set(), "BitMask should not have any bits set for DELETED tags");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580905, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=367, prompt_tokens=2429, total_tokens=2796, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm3uj5sgPKXN2yKqu02ZedGLmoxP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::group::sse2::Group;\n    use control::tag::Tag;\n    use control::bitmask::BitMask;\n    use std::mem;\n\n    #[test]\n    fn test_match_tag() {\n        // Create a group of tags\n        let tags: [Tag; Group::WIDTH] = [\n            Tag(1), Tag(2), Tag(3), Tag(1), Tag(4), Tag(1), Tag(5), Tag(2), Tag(6), Tag(1), Tag(3), Tag(4), Tag(5), Tag(1), Tag(6), Tag(1)\n        ];\n        \n        // Group the tags into a Group\n        let group = unsafe { Group::load(tags.as_ptr()) };\n\n        // Test matching tag\n        let tag_to_match = Tag(1);\n        let result_mask = group.match_tag(tag_to_match);\n\n        // Calculate expected result mask\n        let expected_mask = BitMask(0b1010101010101010); // Binary representation of expected result\n\n        assert_eq!(result_mask, expected_mask);\n    }\n\n    #[test]\n    fn test_match_tag_no_match() {\n        // Create a group of tags\n        let tags: [Tag; Group::WIDTH] = [\n            Tag(1), Tag(2), Tag(3), Tag(4), Tag(5), Tag(6), Tag(7), Tag(8), Tag(9), Tag(10), Tag(11), Tag(12), Tag(13), Tag(14), Tag(15), Tag(16)\n        ];\n        \n        // Group the tags into a Group\n        let group = unsafe { Group::load(tags.as_ptr()) };\n\n        // Test matching a tag that does not exist\n        let tag_to_match = Tag(99);\n        let result_mask = group.match_tag(tag_to_match);\n\n        // Expected result mask should be 0 as there are no matches\n        let expected_mask = BitMask(0);\n\n        assert_eq!(result_mask, expected_mask);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580914, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=441, prompt_tokens=3215, total_tokens=3656, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm45hASIxVjNULPtOz6LUTnWsuTa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::control::group::sse2::Group;\n    use super::control::tag::Tag;\n\n    #[test]\n    fn test_static_empty() {\n        const EMPTY_TAGS: &[Tag; Group::WIDTH] = Group::static_empty();\n\n        // Verify that all tags are EMPTY\n        for tag in EMPTY_TAGS {\n            assert_eq!(*tag, Tag::EMPTY);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580925, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=98, prompt_tokens=923, total_tokens=1021, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm49AwRLOYS6glko3k5AIr8gxPTj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem;\n\n    #[test]\n    fn test_store_aligned() {\n        // Create an aligned buffer for storing tags\n        let mut tags: [Tag; Group::WIDTH] = unsafe { std::mem::zeroed() };\n        let aligned_ptr = tags.as_mut_ptr();\n\n        // Create a Group instance with arbitrary tags\n        let group = Group(x86::_mm_set_epi8(1, 2, 3, 4, 5, 6, 7, 8)); // Example tags\n\n        // Store the group aligned\n        unsafe {\n            group.store_aligned(aligned_ptr);\n        }\n\n        // Check that the tags in the buffer are as expected\n        for (i, tag) in tags.iter().enumerate() {\n            assert_eq!(tag.0, (i + 1) as u8);\n        }\n\n        // Ensure the buffer is aligned\n        assert_eq!(aligned_ptr.align_offset(mem::align_of::<Group>()), 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_store_aligned_unaligned_ptr() {\n        // Create an unaligned buffer for storing tags\n        let mut unaligned_tags: [Tag; Group::WIDTH + 1] = unsafe { std::mem::zeroed() };\n        let unaligned_ptr = unaligned_tags.as_mut_ptr().add(1); // Make it unaligned\n\n        // Create a Group instance with arbitrary tags\n        let group = Group(x86::_mm_set_epi8(1, 2, 3, 4, 5, 6, 7, 8)); // Example tags\n\n        // This should panic because unaligned_ptr is not aligned\n        unsafe {\n            group.store_aligned(unaligned_ptr);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580929, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=388, prompt_tokens=2150, total_tokens=2538, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4HLozFR32b9s89TraYjws2ffT4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use control::tag::Tag;\n\n    #[test]\n    fn test_full() {\n        let hash_values = [\n            (0, Tag(0)),                   // Hash 0 results in Tag(0)\n            (1, Tag(0)),                   // Hash 1 results in Tag(0)\n            (127, Tag(0b0111_1111)),       // Hash 127 results in Tag(0b0111_1111)\n            (128, Tag(0b0000_0000)),       // Hash 128 results in Tag(0b0000_0000)\n            (255, Tag(0b0000_0111)),       // Hash 255 results in Tag(0b0000_0111)\n            (511, Tag(0b0000_1111)),       // Hash 511 results in Tag(0b0000_1111)\n            (1023, Tag(0b0001_1111)),      // Hash 1023 results in Tag(0b0001_1111)\n            (u64::MAX, Tag(0b0111_1111)),  // Hash u64::MAX results in Tag(0b0111_1111)\n        ];\n\n        for (hash, expected_tag) in hash_values.iter() {\n            let tag = Tag::full(*hash);\n            assert_eq!(tag, *expected_tag, "Expected Tag for hash {} does not match", hash);\n            assert!(tag.is_full(), "Tag for hash {} should be full", hash);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580937, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=341, prompt_tokens=992, total_tokens=1333, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4PfW7YDiyJcukKEAq7Vd0ZEAlv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::control::tag::Tag;\n\n    #[test]\n    fn test_is_full() {\n        // Test with a full tag\n        let full_tag = Tag::full(0x7f); // Using a hash that results in 0x7f\n        assert!(full_tag.is_full());\n\n        // Test with an empty tag\n        let empty_tag = Tag::EMPTY;\n        assert!(!empty_tag.is_full());\n\n        // Test with a deleted tag\n        let deleted_tag = Tag::DELETED;\n        assert!(!deleted_tag.is_full());\n\n        // Test with a custom tag that is full\n        let custom_full_tag = Tag(0b0111_1111); // Full tag with top bit clear\n        assert!(custom_full_tag.is_full());\n\n        // Test with a custom tag that is not full\n        let custom_not_full_tag = Tag(0b1111_1111); // Full tag with top bit set\n        assert!(!custom_not_full_tag.is_full());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580945, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=223, prompt_tokens=818, total_tokens=1041, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4WTpQrxtmLtNvYJBwuJmpntOAL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::control::tag::Tag;\n\n    #[test]\n    fn test_is_special() {\n        assert!(!Tag::EMPTY.is_special());\n        assert!(Tag::DELETED.is_special());\n        assert!(!Tag(0b0111_1111).is_special());\n        assert!(Tag(0b1111_1111).is_special());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580952, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=88, prompt_tokens=818, total_tokens=906, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4ZFA5KxgPZatZd4JDzUQhnnC0A', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::control::tag::Tag;\n\n    #[test]\n    fn test_special_is_empty() {\n        // Test for EMPTY tag\n        let empty_tag = Tag::EMPTY;\n        assert!(empty_tag.is_special());\n        assert!(empty_tag.special_is_empty());\n\n        // Test for DELETED tag\n        let deleted_tag = Tag::DELETED;\n        assert!(deleted_tag.is_special());\n        assert!(!deleted_tag.special_is_empty());\n\n        // Test for another special tag\n        let special_tag = Tag(0b1000_0001); // special and empty\n        assert!(special_tag.is_special());\n        assert!(special_tag.special_is_empty());\n        \n        let another_special_tag = Tag(0b1000_0010); // special and not empty\n        assert!(another_special_tag.is_special());\n        assert!(!another_special_tag.special_is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580955, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=193, prompt_tokens=829, total_tokens=1022, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4ggVmBLTn9HIM2mgsbQ4OeZNjl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::control::tag::{TagSliceExt, Tag};\n\n    #[test]\n    fn test_fill_empty() {\n        let mut tags = vec![Tag::FILLED, Tag::FILLED, Tag::FILLED];\n        let tags_slice = &mut tags.as_mut_slice();\n        tags_slice.fill_empty();\n        assert_eq!(tags_slice, &[Tag::EMPTY, Tag::EMPTY, Tag::EMPTY]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580962, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=104, prompt_tokens=159, total_tokens=263, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4k7unKCz463KJshyCRjHmDYtSa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let mut drain = map.drain();\n        let drain_iter = drain.iter();\n\n        let mut collected: Vec<_> = drain_iter.collect();\n        collected.sort_unstable();\n\n        assert_eq!(collected, vec![Some((&1, &"a")), Some((&2, &"b")), Some((&3, &"c"))]);\n\n        assert_eq!(drain_iter.len(), 0);\n        assert_eq!(drain_iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580966, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=175, prompt_tokens=16361, total_tokens=16536, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4q1xbW6TjqSxb4ra5u4oHrpm6J', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_and_modify_on_occupied_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("test", 1);\n\n        map.entry("test")\n            .and_modify(|e| *e += 1);\n\n        assert_eq!(map["test"], 2);\n    }\n\n    #[test]\n    fn test_and_modify_on_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        let entry = map.entry("test")\n            .and_modify(|e| *e += 1);\n\n        match entry {\n            Entry::Vacant(_) => { /* Correct behavior: Entry is vacant */ }\n            _ => panic!("Expected vacant entry, but got occupied."),\n        }\n\n        map.entry("test").or_insert(1);\n\n        map.entry("test")\n            .and_modify(|e| *e += 1);\n        assert_eq!(map["test"], 2);\n    }\n\n    #[test]\n    fn test_and_modify_multiple_entries() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("first", 1);\n        map.insert("second", 2);\n\n        map.entry("first")\n            .and_modify(|e| *e += 1);\n        map.entry("second")\n            .and_modify(|e| *e += 2);\n\n        assert_eq!(map["first"], 2);\n        assert_eq!(map["second"], 4);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580972, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=347, prompt_tokens=16361, total_tokens=16708, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm4yUUauFR3Y8frCqn9xth5if22p', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_and_replace_entry_with_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        let entry = map\n            .entry("poneyland")\n            .and_replace_entry_with(|_k, _v| panic!());\n\n        match entry {\n            Entry::Vacant(e) => {\n                assert_eq!(e.key(), &"poneyland");\n            }\n            Entry::Occupied(_) => panic!(),\n        }\n    }\n\n    #[test]\n    fn test_and_replace_entry_with_occupied_entry_replace() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 42);\n\n        let entry = map\n            .entry("poneyland")\n            .and_replace_entry_with(|k, v| {\n                assert_eq!(k, &"poneyland");\n                assert_eq!(v, 42);\n                Some(v + 1)\n            });\n\n        match entry {\n            Entry::Occupied(e) => {\n                assert_eq!(e.key(), &"poneyland");\n                assert_eq!(e.get(), &43);\n            }\n            Entry::Vacant(_) => panic!(),\n        }\n\n        assert_eq!(map["poneyland"], 43);\n    }\n\n    #[test]\n    fn test_and_replace_entry_with_occupied_entry_remove() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 42);\n\n        let entry = map\n            .entry("poneyland")\n            .and_replace_entry_with(|_k, _v| None);\n\n        match entry {\n            Entry::Vacant(e) => assert_eq!(e.key(), &"poneyland"),\n            Entry::Occupied(_) => panic!(),\n        }\n\n        assert!(!map.contains_key("poneyland"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580980, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=433, prompt_tokens=16361, total_tokens=16794, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5Eotp256UYm5RIf7BJgIvYvFdv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_insert_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("key1", 10);\n        let entry = map.entry("key1");\n        let occupied_entry = entry.insert(20);\n        assert_eq!(occupied_entry.key(), &"key1");\n        assert_eq!(map["key1"], 20);\n    }\n\n    #[test]\n    fn test_insert_new_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry = map.entry("key2");\n        let occupied_entry = entry.insert(30);\n        assert_eq!(occupied_entry.key(), &"key2");\n        assert_eq!(map["key2"], 30);\n    }\n\n    #[test]\n    fn test_insert_with_multiple_keys() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("key3", 40);\n        map.insert("key4", 50);\n\n        let entry1 = map.entry("key3");\n        let occupied_entry1 = entry1.insert(60);\n        assert_eq!(occupied_entry1.key(), &"key3");\n        assert_eq!(map["key3"], 60);\n\n        let entry2 = map.entry("key4");\n        let occupied_entry2 = entry2.insert(70);\n        assert_eq!(occupied_entry2.key(), &"key4");\n        assert_eq!(map["key4"], 70);\n    }\n\n    #[test]\n    fn test_insert_with_nonexistent_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry = map.entry("key5");\n        let occupied_entry = entry.insert(80);\n        assert_eq!(occupied_entry.key(), &"key5");\n        assert_eq!(map["key5"], 80);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748580996, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=422, prompt_tokens=16361, total_tokens=16783, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5OPhJSk4p6cTTH8aF55EpcfUZ8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_key_occupied_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 3);\n        let entry = map.entry("poneyland");\n        match entry {\n            Entry::Occupied(ref occupied_entry) => {\n                assert_eq!(occupied_entry.key(), &"poneyland");\n            }\n            _ => panic!("Expected occupied entry"),\n        }\n    }\n\n    #[test]\n    fn test_key_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry = map.entry("horseland");\n        match entry {\n            Entry::Vacant(ref vacant_entry) => {\n                assert_eq!(vacant_entry.key(), &"horseland");\n            }\n            _ => panic!("Expected vacant entry"),\n        }\n    }\n\n    #[test]\n    fn test_key_with_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("existing_key", 42);\n        assert_eq!(map.entry("existing_key").key(), &"existing_key");\n    }\n\n    #[test]\n    fn test_key_with_non_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert_eq!(map.entry("non_existing_key").key(), &"non_existing_key");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581006, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=323, prompt_tokens=16361, total_tokens=16684, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5X4PRB6wpF00eC0r767vgDg0kJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_default_nonexistent_key() {\n        let mut map: HashMap<&str, Option<u32>> = HashMap::new();\n        let value = map.entry("nonexistent").or_default();\n        assert_eq!(value, &mut None);\n        assert_eq!(map["nonexistent"], None);\n    }\n\n    #[test]\n    fn test_or_default_existing_key() {\n        let mut map: HashMap<&str, Option<u32>> = HashMap::new();\n        map.insert("existing", Some(42));\n        let value = map.entry("existing").or_default();\n        assert_eq!(value, &mut Some(42));\n        assert_eq!(map["existing"], Some(42));\n    }\n\n    #[test]\n    fn test_or_default_default_value() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        let value = map.entry("key").or_default();\n        assert_eq!(value, &mut 0);\n        assert_eq!(map["key"], 0);\n    }\n\n    #[test]\n    fn test_or_default_multiple_keys() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        map.entry("key1").or_default();\n        map.entry("key2").or_default();\n        assert_eq!(map["key1"], 0);\n        assert_eq!(map["key2"], 0);\n    }\n\n    #[test]\n    fn test_or_default_with_custom_type() {\n        #[derive(Default, PartialEq, Debug)]\n        struct CustomType {\n            value: u32,\n        }\n\n        let mut map: HashMap<&str, CustomType> = HashMap::new();\n        let value = map.entry("custom").or_default();\n        assert_eq!(value, &mut CustomType::default());\n        assert_eq!(map["custom"], CustomType { value: 0 });\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581015, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=418, prompt_tokens=16361, total_tokens=16779, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5jW9hjVQB6Ss75DuPwbfE3cX4e', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_vacant() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert_eq!(map.entry("new_key").or_insert(10), &mut 10);\n        assert_eq!(map["new_key"], 10);\n    }\n\n    #[test]\n    fn test_or_insert_occupied() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("existing_key", 20);\n        assert_eq!(map.entry("existing_key").or_insert(30), &mut 20);\n        assert_eq!(map["existing_key"], 20);\n    }\n\n    #[test]\n    fn test_or_insert_update() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("update_key", 5);\n        *map.entry("update_key").or_insert(10) *= 2;\n        assert_eq!(map["update_key"], 10);\n    }\n\n    #[test]\n    fn test_or_insert_multiple() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert_eq!(map.entry("a").or_insert(1), &mut 1);\n        assert_eq!(map.entry("b").or_insert(2), &mut 2);\n        assert_eq!(map.entry("a").or_insert(3), &mut 1);\n        assert_eq!(map.entry("b").or_insert(4), &mut 2);\n        assert_eq!(map["a"], 1);\n        assert_eq!(map["b"], 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581027, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=366, prompt_tokens=16361, total_tokens=16727, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm5sZKeTyXHbUj2AYUpFi5DlgTMa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Assume the correct module path\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_with_nonexistent_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let value = map.entry("poneyland").or_insert_with(|| 3);\n        assert_eq!(*value, 3);\n        assert_eq!(map["poneyland"], 3);\n    }\n\n    #[test]\n    fn test_or_insert_with_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 3);\n        let value = map.entry("poneyland").or_insert_with(|| 10);\n        *value *= 2;\n        assert_eq!(*value, 6);\n        assert_eq!(map["poneyland"], 6);\n    }\n\n    #[test]\n    fn test_or_insert_with_different_value() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 3);\n        let value = map.entry("poneyland").or_insert_with(|| 10);\n        assert_eq!(*value, 3);\n    }\n\n    #[test]\n    fn test_multiple_or_insert_with() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let value1 = map.entry("poneyland").or_insert_with(|| 3);\n        let value2 = map.entry("horseland").or_insert_with(|| 5);\n        assert_eq!(*value1, 3);\n        assert_eq!(*value2, 5);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581036, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=371, prompt_tokens=16361, total_tokens=16732, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm62YyRKgQtQKpH8kdCEfXPpJ8Pz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_with_key_nonexistent_key() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        map.entry("poneyland").or_insert_with_key(|key| key.len());\n        assert_eq!(map["poneyland"], 9);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_existing_key() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        map.insert("poneyland", 9);\n        *map.entry("poneyland").or_insert_with_key(|key| key.len() * 10) *= 2;\n        assert_eq!(map["poneyland"], 18);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_multiple_keys() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        map.entry("test1").or_insert_with_key(|key| key.chars().count());\n        map.entry("test2").or_insert_with_key(|key| key.chars().count());\n        assert_eq!(map["test1"], 5);\n        assert_eq!(map["test2"], 5);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_reference_key() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        let key = "test_key";\n        map.entry(key).or_insert_with_key(|k| k.chars().count());\n        assert_eq!(map[key], 8);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_key_derivation() {\n        let mut map: HashMap<&str, usize> = HashMap::new();\n        map.entry("key1").or_insert_with_key(|key| key.chars().count() * 2);\n        assert_eq!(map["key1"], 8);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581046, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=419, prompt_tokens=16361, total_tokens=16780, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm6DYW4krutSWwADPJOcr3qGxiOn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_and_modify_on_occupied_entry() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("test".to_string(), 1);\n\n        map.entry_ref("test")\n            .and_modify(|e| *e += 1)\n            .or_insert(0);\n\n        assert_eq!(map["test"], 2);\n    }\n\n    #[test]\n    fn test_and_modify_on_vacant_entry() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n\n        map.entry_ref("test")\n            .and_modify(|e| *e += 1)\n            .or_insert(42);\n\n        assert_eq!(map["test"], 42);\n    }\n\n    #[test]\n    fn test_and_modify_multiple_times() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("test".to_string(), 1);\n\n        map.entry_ref("test")\n            .and_modify(|e| *e += 1)\n            .or_insert(0);\n\n        map.entry_ref("test")\n            .and_modify(|e| *e += 1)\n            .or_insert(0);\n\n        assert_eq!(map["test"], 3);\n    }\n\n    #[test]\n    fn test_and_modify_with_different_initial_values() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("test".to_string(), 5);\n\n        map.entry_ref("test")\n            .and_modify(|e| *e += 10)\n            .or_insert(1);\n\n        assert_eq!(map["test"], 15);\n    }\n\n    #[test]\n    fn test_and_modify_without_insert() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("test".to_string(), 3);\n\n        let entry_ref = map.entry_ref("test")\n            .and_modify(|e| *e += 2);\n\n        assert!(matches!(entry_ref, EntryRef::Occupied(_)));\n        assert_eq!(map["test"], 5);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581057, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=473, prompt_tokens=16361, total_tokens=16834, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm6Q2gNqaIWYgzEnPgZbKAuo4lND', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_insert_occupied_entry() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("test".to_string(), 10);\n        let entry_ref = map.entry_ref("test");\n        let entry = entry_ref.insert(20);\n        assert_eq!(entry.key(), "test");\n        assert_eq!(*entry.get_mut(), 20);\n    }\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let entry_ref = map.entry_ref("new_key");\n        let entry = entry_ref.insert(30);\n        assert_eq!(entry.key(), "new_key");\n        assert_eq!(*entry.get_mut(), 30);\n        assert_eq!(map.len(), 1);\n    }\n    \n    #[test]\n    fn test_insert_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("key".to_string(), 1);\n        let entry_ref = map.entry_ref("key");\n        let entry = entry_ref.insert(5);\n        assert_eq!(entry.key(), "key");\n        assert_eq!(map["key"], 5);\n    }\n    \n    #[test]\n    fn test_insert_non_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let entry_ref = map.entry_ref("new_key");\n        let entry = entry_ref.insert(42);\n        assert_eq!(entry.key(), "new_key");\n        assert_eq!(map["new_key"], 42);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581070, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=367, prompt_tokens=16361, total_tokens=16728, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm6aoMkkZvT6nDOGLYQY249qMJvm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_map::{EntryRef, HashMap};\n\n    #[test]\n    fn test_key_existing() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref("poneyland").or_insert(3);\n        assert_eq!(map.entry_ref("poneyland").key(), "poneyland");\n    }\n\n    #[test]\n    fn test_key_nonexistent() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        assert_eq!(map.entry_ref("horseland").key(), "horseland");\n    }\n\n    #[test]\n    fn test_key_insert() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let default_value = 3;\n        map.entry_ref("poneyland").or_insert(default_value);\n        assert_eq!(map.entry_ref("poneyland").key(), "poneyland");\n        assert_eq!(map["poneyland"], default_value);\n    }\n\n    #[test]\n    fn test_key_insert_another() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref("horseland").or_insert(5);\n        assert_eq!(map.entry_ref("horseland").key(), "horseland");\n        assert_eq!(map["horseland"], 5);\n    }\n\n    #[test]\n    fn test_key_multiple_insertions() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref("poneyland").or_insert(3);\n        map.entry_ref("horseland").or_insert(5);\n        assert_eq!(map.entry_ref("poneyland").key(), "poneyland");\n        assert_eq!(map.entry_ref("horseland").key(), "horseland");\n        assert_eq!(map["poneyland"], 3);\n        assert_eq!(map["horseland"], 5);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581080, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=420, prompt_tokens=16361, total_tokens=16781, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm6k87uRztChizpRQakccXvPdxmL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_default_inserts_default_value() {\n        let mut map: HashMap<String, Option<u32>> = HashMap::new();\n\n        // Testing or_default for nonexistent key\n        let entry = map.entry_ref("poneyland");\n        *entry.or_default() = Some(3);\n        assert_eq!(map["poneyland"], Some(3));\n    }\n\n    #[test]\n    fn test_or_default_returns_existing_value() {\n        let mut map: HashMap<String, Option<u32>> = HashMap::new();\n        map.insert("horseland".to_string(), Some(3));\n\n        // Testing or_default for existing key\n        let entry = map.entry_ref("horseland");\n        assert_eq!(entry.or_default(), &mut Some(3));\n    }\n\n    #[test]\n    fn test_or_default_leaves_existing_value_untouched() {\n        let mut map: HashMap<String, Option<u32>> = HashMap::new();\n        map.insert("poneyland".to_string(), Some(5));\n\n        // Testing or_default without mutation\n        let entry = map.entry_ref("poneyland");\n        *entry.or_default() = Some(10);\n        assert_eq!(map["poneyland"], Some(10));\n    }\n\n    #[test]\n    fn test_or_default_inserts_multiple_default_values() {\n        let mut map: HashMap<String, Option<u32>> = HashMap::new();\n\n        map.entry_ref("poneyland").or_default();\n        assert_eq!(map["poneyland"], None);\n\n        map.entry_ref("poneyland").or_default();\n        assert_eq!(map["poneyland"], None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581090, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=373, prompt_tokens=16361, total_tokens=16734, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm75OGNII2wkvCu4BFVP9LYmvaJ7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_nonexistent_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let entry = map.entry_ref("poneyland").or_insert(3);\n        assert_eq!(*entry, 3);\n        assert_eq!(map["poneyland"], 3);\n    }\n\n    #[test]\n    fn test_or_insert_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("poneyland".to_string(), 3);\n        let entry = map.entry_ref("poneyland").or_insert(10);\n        assert_eq!(*entry, 3);\n        assert_eq!(map["poneyland"], 3);\n    }\n\n    #[test]\n    fn test_or_insert_modify_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("poneyland".to_string(), 3);\n        *map.entry_ref("poneyland").or_insert(10) *= 2;\n        assert_eq!(map["poneyland"], 6);\n    }\n\n    #[test]\n    fn test_or_insert_with_nonexistent_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let entry = map.entry_ref("horseland").or_insert(5);\n        assert_eq!(*entry, 5);\n        assert_eq!(map["horseland"], 5);\n    }\n\n    #[test]\n    fn test_or_insert_with_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("horseland".to_string(), 5);\n        let entry = map.entry_ref("horseland").or_insert(10);\n        assert_eq!(*entry, 5);\n        assert_eq!(map["horseland"], 5);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581111, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=419, prompt_tokens=16361, total_tokens=16780, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7Jwp0HasEacJDiGjDCcwy5Bu6z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_with_nonexistent_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref("nonexistent").or_insert_with(|| 42);\n        assert_eq!(map["nonexistent"], 42);\n    }\n\n    #[test]\n    fn test_or_insert_with_existing_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("existing".to_string(), 10);\n        *map.entry_ref("existing").or_insert_with(|| 20) += 10;\n        assert_eq!(map["existing"], 20);\n    }\n\n    #[test]\n    fn test_or_insert_with_multiple_entries() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref("key1").or_insert_with(|| 1);\n        map.entry_ref("key2").or_insert_with(|| 2);\n        map.entry_ref("key3").or_insert_with(|| 3);\n        assert_eq!(map["key1"], 1);\n        assert_eq!(map["key2"], 2);\n        assert_eq!(map["key3"], 3);\n    }\n\n    #[test]\n    fn test_or_insert_with_function_execution() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let mut calls = 0;\n        {\n            map.entry_ref("key").or_insert_with(|| {\n                calls += 1;\n                5\n            });\n        }\n        assert_eq!(map["key"], 5);\n        assert_eq!(calls, 1);\n    }\n\n    #[test]\n    fn test_or_insert_with_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.entry_ref("key").or_insert_with_key(|key| key.len() as u32);\n        assert_eq!(map["key"], 3);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_existing() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("key".to_string(), 10);\n        *map.entry_ref("key").or_insert_with_key(|key| key.len() as u32) += 5;\n        assert_eq!(map["key"], 15);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581125, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=511, prompt_tokens=16361, total_tokens=16872, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7UwJvmNrlHrXdXbDI8dGttbEAV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_with_key_nonexistent_key() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        map.entry_ref("poneyland").or_insert_with_key(|key| key.chars().count());\n        assert_eq!(map["poneyland"], 9);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_existing_key() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        map.entry_ref("poneyland").or_insert_with_key(|key| key.chars().count());\n        assert_eq!(map["poneyland"], 9);\n        *map.entry_ref("poneyland").or_insert_with_key(|key| key.chars().count() * 10) *= 2;\n        assert_eq!(map["poneyland"], 18);\n    }\n\n    #[test]\n    fn test_or_insert_with_key_multiple_entries() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        let keys = vec!["poneyland", "horseland", "catland"];\n        for key in keys {\n            map.entry_ref(key).or_insert_with_key(|k| k.len());\n        }\n        assert_eq!(map["poneyland"], 9);\n        assert_eq!(map["horseland"], 9);\n        assert_eq!(map["catland"], 8);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581136, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=321, prompt_tokens=16361, total_tokens=16682, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7ek0BcIbKAcwccuFRI3IBnUAs7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_allocation_size() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        assert_eq!(map.allocation_size(), 0);\n\n        map.insert(1, 100);\n        assert!(map.allocation_size() > 0);\n\n        map.insert(2, 200);\n        assert!(map.allocation_size() >= 2 * std::mem::size_of::<(i32, i32)>());\n\n        for i in 3..100 {\n            map.insert(i, i * 10);\n        }\n        assert!(map.allocation_size() >= 100 * std::mem::size_of::<(i32, i32)>());\n\n        map.clear();\n        assert_eq!(map.allocation_size(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581146, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=190, prompt_tokens=16361, total_tokens=16551, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7mcPXiohN92mzPv7LzensiAmo9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\nuse hashbrown::HashMap;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_allocator() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        let allocator = map.allocator();\n        assert!(allocator.is_some()); // Check allocator reference is valid\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581154, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=76, prompt_tokens=16361, total_tokens=16437, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm7v0PFEIKbUp4najYdKGH91oEzu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_build_hashes_inner() {\n        let mut map: HashMap<&str, i32, RandomState> = HashMap::new();\n        map.insert("one", 1);\n        map.insert("two", 2);\n        map.insert("three", 3);\n        \n        let keys = ["one", "two", "three"];\n        let hashes: [u64; 3] = map.build_hashes_inner(&keys);\n        \n        assert_eq!(hashes.len(), 3);\n        assert!(hashes.iter().all(|&hash| hash != 0));\n    }\n\n    #[test]\n    fn test_build_hashes_inner_empty() {\n        let map: HashMap<&str, i32, RandomState> = HashMap::new();\n        let keys = ["nonexistent"];\n        let hashes: [u64; 1] = map.build_hashes_inner(&keys);\n        \n        assert_eq!(hashes.len(), 1);\n        assert!(hashes.iter().all(|&hash| hash != 0));\n    }\n\n    #[test]\n    fn test_build_hashes_inner_with_different_keys() {\n        let mut map: HashMap<&str, i32, RandomState> = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n        \n        let keys = ["key1", "key2", "nonexistent"];\n        let hashes: [u64; 3] = map.build_hashes_inner(&keys);\n        \n        assert_eq!(hashes.len(), 3);\n        assert!(hashes[0] != hashes[1]);\n        assert!(hashes[2] != 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581163, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=384, prompt_tokens=16361, total_tokens=16745, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm88DHO9hKajW3R6dA4TmGnnKEdu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_capacity_with_initial_capacity() {\n        let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        assert_eq!(map.len(), 0);\n        assert!(map.capacity() >= 100);\n    }\n\n    #[test]\n    fn test_capacity_after_insertion() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(10);\n        map.insert(1, 1);\n        map.insert(2, 2);\n        assert!(map.capacity() >= 10);\n        assert_eq!(map.capacity(), map.len() + 1); // Should be at least the number of elements + 1\n    }\n\n    #[test]\n    fn test_capacity_after_multiple_insertions() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(2);\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.insert(3, 3); // This should trigger a reallocation\n        assert!(map.capacity() >= 3);\n    }\n\n    #[test]\n    fn test_capacity_no_insertions() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_after_clear() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.clear();\n        assert!(map.capacity() >= 100); // Capacity should remain the same after clear\n    }\n\n    #[test]\n    fn test_capacity_shrink_to_fit() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        map.insert(1, 1);\n        map.insert(2, 2);\n        map.shrink_to_fit(); // This should lower the capacity to be close to the current usage\n        assert!(map.capacity() >= map.len());\n    }\n\n    #[test]\n    fn test_capacity_with_allocating() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(1);\n        for i in 1..100 {\n            map.insert(i, i);\n            // Capacity should grow as we insert more elements\n            assert!(map.capacity() >= i);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581176, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=538, prompt_tokens=16361, total_tokens=16899, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm8OG8Fj4FzOO3JJ8f4ms4QKaAns', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_clear() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        let capacity_before_clear = map.capacity();\n\n        map.clear();\n\n        assert!(map.is_empty());\n        assert_eq!(map.capacity(), capacity_before_clear);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_clear_empty_map() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        let capacity_before_clear = map.capacity();\n\n        map.clear();\n\n        assert!(map.is_empty());\n        assert_eq!(map.capacity(), capacity_before_clear);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_clear_with_capacity() {\n        let mut map: HashMap<i32, &str> = HashMap::with_capacity(5);\n        map.insert(1, "a");\n        map.insert(2, "b");\n\n        let capacity_before_clear = map.capacity();\n        map.clear();\n\n        assert!(map.is_empty());\n        assert_eq!(map.capacity(), capacity_before_clear);\n        assert_eq!(map.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581192, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=274, prompt_tokens=16361, total_tokens=16635, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm8VIeZmUdfU3e98hj2xSyTo1Ygj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_contains_key() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        \n        assert!(map.contains_key(&1));\n        assert!(map.contains_key(&2));\n        assert!(!map.contains_key(&3));\n    }\n\n    #[test]\n    fn test_contains_key_with_different_types() {\n        let mut map = HashMap::new();\n        map.insert(String::from("key1"), "value1");\n        map.insert(String::from("key2"), "value2");\n\n        assert!(map.contains_key(&String::from("key1")));\n        assert!(!map.contains_key(&String::from("key3")));\n        assert!(map.contains_key("key2".as_ref()));\n    }\n\n    #[test]\n    fn test_contains_key_empty_map() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        \n        assert!(!map.contains_key(&1));\n        assert!(!map.contains_key(&0));\n    }\n\n    #[test]\n    fn test_contains_key_after_removal() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.remove(&1);\n\n        assert!(!map.contains_key(&1));\n        assert!(map.contains_key(&2));\n    }\n\n    #[test]\n    fn test_contains_key_for_non_hash_types() {\n        #[derive(Debug, PartialEq, Eq, Hash)]\n        struct NonHashType {\n            id: i32,\n        }\n\n        let mut map = HashMap::new();\n        map.insert(NonHashType { id: 1 }, "value1");\n\n        assert!(map.contains_key(&NonHashType { id: 1 }));\n        assert!(!map.contains_key(&NonHashType { id: 2 }));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581199, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=417, prompt_tokens=16361, total_tokens=16778, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm8i71Q2sAdI7YvSe6fpe92VhrGr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn drain_empty_map() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        let drained: Vec<(i32, &str)> = map.drain().collect();\n        assert!(drained.is_empty());\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn drain_non_empty_map() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n\n        let drained: Vec<(i32, &str)> = map.drain().collect();\n        \n        assert_eq!(drained.len(), 2);\n        assert!(map.is_empty());\n\n        let keys: Vec<i32> = drained.iter().map(|&(k, _)| k).collect();\n        assert!(keys.contains(&1) || keys.contains(&2));\n        assert!(drained.iter().any(|&(_, v)| v == "a") || drained.iter().any(|&(_, v)| v == "b");\n    }\n\n    #[test]\n    fn drain_with_partial_consumption() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n\n        let mut drained = map.drain();\n        let first = drained.next().unwrap();\n\n        assert!(map.len() == 1);\n        assert!(drained.count() == 1);\n        assert!(map.is_empty());\n\n        let keys = vec![first.0];\n        assert!(keys.contains(&1) || keys.contains(&2));\n    }\n\n    #[test]\n    fn drain_iterator_dropped() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n\n        {\n            let _drained = map.drain();\n        }\n\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn drain_retains_capacity() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        let capacity_before_drain = map.capacity();\n\n        map.drain().count(); // Fully consume the drain iterator\n\n        assert_eq!(map.capacity(), capacity_before_drain);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581212, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=526, prompt_tokens=16361, total_tokens=16887, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm8wUKfyecLKOMO3yi3u7qWhxjDd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_entry_insert() {\n        let mut map = HashMap::new();\n        let entry = map.entry("key1");\n        let value = entry.or_insert(10);\n        *value += 5;\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map["key1"], 15);\n    }\n\n    #[test]\n    fn test_entry_or_insert() {\n        let mut map = HashMap::new();\n        let entry = map.entry("key2");\n        assert_eq!(entry.or_insert(20), &mut 20);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map["key2"], 20);\n    }\n\n    #[test]\n    fn test_entry_or_insert_with() {\n        let mut map = HashMap::new();\n        let entry = map.entry("key3");\n        assert_eq!(entry.or_insert_with(|| 30), &mut 30);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map["key3"], 30);\n    }\n\n    #[test]\n    fn test_entry_or_insert_with_key() {\n        let mut map = HashMap::new();\n        let entry = map.entry("key4");\n        assert_eq!(entry.or_insert_with_key(|key| key.len() as i32), &mut 4);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map["key4"], 4);\n    }\n\n    #[test]\n    fn test_entry_and_modify() {\n        let mut map = HashMap::new();\n        map.insert("key5", 100);\n        let entry = map.entry("key5");\n        entry.and_modify(|value| *value += 50);\n        \n        assert_eq!(map["key5"], 150);\n    }\n\n    #[test]\n    fn test_entry_vacant() {\n        let mut map = HashMap::new();\n        let entry = map.entry("key6");\n        assert!(matches!(entry, hashbrown::hash_map::Entry::Vacant(_)));\n        entry.or_insert(60);\n        \n        assert_eq!(map["key6"], 60);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_entry_occupied() {\n        let mut map = HashMap::new();\n        map.insert("key7", 70);\n        let entry = map.entry("key7");\n        \n        assert!(matches!(entry, hashbrown::hash_map::Entry::Occupied(_)));\n        assert_eq!(entry.or_insert(70), &mut 70);\n        assert_eq!(map["key7"], 70);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581226, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=566, prompt_tokens=16361, total_tokens=16927, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm9D9teUKIe4kkPheOU593LzZaYv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_entry_ref_vacant() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n\n        let entry = map.entry_ref("test").or_insert(0);\n        assert_eq!(*entry, 0);\n        assert_eq!(map["test"], 0);\n    }\n\n    #[test]\n    fn test_entry_ref_occupied() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        map.insert("test".to_string(), 5);\n\n        let entry = map.entry_ref("test").or_insert(0);\n        assert_eq!(*entry, 5);\n        assert_eq!(map["test"], 5);\n    }\n\n    #[test]\n    fn test_entry_ref_insert() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        \n        map.entry_ref("test").insert(10);\n        assert_eq!(map["test"], 10);\n        \n        map.entry_ref("test").insert(20);\n        assert_eq!(map["test"], 20);\n    }\n\n    #[test]\n    fn test_entry_ref_or_insert() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        let entry = map.entry_ref("test").or_insert(5);\n        assert_eq!(*entry, 5);\n        assert_eq!(map["test"], 5);\n        \n        let entry = map.entry_ref("test").or_insert(10);\n        assert_eq!(*entry, 5);\n        assert_eq!(map["test"], 5);\n    }\n\n    #[test]\n    fn test_entry_ref_or_insert_with() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        \n        let entry = map.entry_ref("test").or_insert_with(|| 10);\n        assert_eq!(*entry, 10);\n        assert_eq!(map["test"], 10);\n        \n        let entry = map.entry_ref("test").or_insert_with(|| 20);\n        assert_eq!(*entry, 10);\n        assert_eq!(map["test"], 10);\n    }\n\n    #[test]\n    fn test_entry_ref_and_modify() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        map.insert("test".to_string(), 5);\n        \n        map.entry_ref("test").and_modify(|e| *e += 5);\n        assert_eq!(map["test"], 10);\n    }\n\n    #[test]\n    fn test_entry_ref_and_modify_vacant() {\n        let mut map: HashMap<String, usize> = HashMap::new();\n        \n        map.entry_ref("test").and_modify(|e| *e += 5).or_insert(0);\n        assert_eq!(map["test"], 0); // initial value\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581243, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=614, prompt_tokens=16361, total_tokens=16975, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm9URi7VBzFqstND4YWtIKQB68Qv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_extract_if() {\n        let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n\n        let drained: HashMap<i32, i32> = map.extract_if(|k, _v| k % 2 == 0).collect();\n\n        let mut evens = drained.keys().cloned().collect::<Vec<_>>();\n        let mut odds = map.keys().cloned().collect::<Vec<_>>();\n        evens.sort();\n        odds.sort();\n\n        assert_eq!(evens, vec![0, 2, 4, 6]);\n        assert_eq!(odds, vec![1, 3, 5, 7]);\n\n        let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n\n        {   \n            let d = map.extract_if(|k, _v| k % 2 != 0);\n        }\n\n        assert_eq!(map.len(), 8);\n    }\n\n    #[test]\n    fn test_extract_if_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        let drained: HashMap<i32, i32> = map.extract_if(|_k, _v| true).collect();\n        assert!(drained.is_empty());\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_extract_if_partial() {\n        let mut map: HashMap<i32, i32> = (0..5).map(|x| (x, x)).collect();\n        let mut drained_iter = map.extract_if(|k, _v| k % 2 == 0);\n        \n        assert_eq!(drained_iter.next(), Some((0, 0)));\n        assert_eq!(drained_iter.next(), Some((2, 2)));\n\n        // Remaining map\n        let mut remaining_keys = map.keys().cloned().collect::<Vec<_>>();\n        remaining_keys.sort();\n        assert_eq!(remaining_keys, vec![1, 3, 4]);\n        \n        assert!(drained_iter.next().is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581260, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=478, prompt_tokens=16361, total_tokens=16839, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm9gEZCDeTTWPVpxQxK2krFXrmeq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_find_or_find_insert_slot_existing_key() {\n        let mut map = HashMap::new();\n        map.insert("key1", "value1");\n        let hash = map.hasher().build_hasher().finish();\n        let result = map.find_or_find_insert_slot(hash, &"key1");\n        assert!(result.is_ok());\n    }\n    \n    #[test]\n    fn test_find_or_find_insert_slot_insert_new_key() {\n        let mut map = HashMap::new();\n        let hash = map.hasher().build_hasher().finish();\n        let result = map.find_or_find_insert_slot(hash, &"new_key");\n        assert!(result.is_err());\n        \n        map.insert("new_key", "new_value");\n        let result_after_insert = map.find_or_find_insert_slot(hash, &"new_key");\n        assert!(result_after_insert.is_ok());\n    }\n    \n    #[test]\n    fn test_find_or_find_insert_slot_collision() {\n        let mut map = HashMap::new();\n        map.insert("key1", "value1");\n        map.insert("key2", "value2");\n        \n        let hash = map.hasher().build_hasher().finish();\n        let bucket = map.find_or_find_insert_slot(hash, &"key1");\n        assert!(bucket.is_ok());\n        \n        let collision_hash = map.hasher().build_hasher().finish();\n        let bucket_collision = map.find_or_find_insert_slot(collision_hash, &"key2");\n        assert!(bucket_collision.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581272, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=342, prompt_tokens=16361, total_tokens=16703, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcm9qEd787NkbZDV4SLdslTwlPFIH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_existing_key() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "value1");\n        assert_eq!(map.get(&1), Some(&"value1"));\n    }\n\n    #[test]\n    fn test_get_non_existing_key() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        assert_eq!(map.get(&2), None);\n    }\n\n    #[test]\n    fn test_get_after_insert_multiple() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "value1");\n        map.insert(2, "value2");\n        assert_eq!(map.get(&2), Some(&"value2"));\n        assert_eq!(map.get(&1), Some(&"value1"));\n    }\n\n    #[test]\n    fn test_get_with_borrowed_key() {\n        let mut map: HashMap<String, &str> = HashMap::new();\n        map.insert("key".to_string(), "value");\n        assert_eq!(map.get(&"key".to_string()), Some(&"value"));\n    }\n\n    #[test]\n    fn test_get_with_different_borrow() {\n        let mut map: HashMap<String, &str> = HashMap::new();\n        map.insert("key".to_string(), "value");\n        let borrowed_key: &str = "key";\n        assert_eq!(map.get(&borrowed_key), Some(&"value"));\n    }\n\n    #[test]\n    fn test_get_with_different_key_type() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "value1");\n        let borrowed_key: &i32 = &1;\n        assert_eq!(map.get(borrowed_key), Some(&"value1"));\n        assert_eq!(map.get(&2), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581282, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=435, prompt_tokens=16361, total_tokens=16796, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmA1Zmz3L1q85vohW073UpL6he3e', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[derive(Debug, PartialEq, Eq, Hash)]\n    struct Key(String);\n\n    #[test]\n    fn test_get_inner_existing_key() {\n        let mut map: HashMap<Key, i32> = HashMap::new();\n        map.insert(Key("test".to_string()), 42);\n        \n        let result = map.get_inner(&Key("test".to_string()));\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), &(Key("test".to_string()), 42));\n    }\n\n    #[test]\n    fn test_get_inner_non_existing_key() {\n        let map: HashMap<Key, i32> = HashMap::new();\n        \n        let result = map.get_inner(&Key("non_existing".to_string()));\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_inner_empty_map() {\n        let map: HashMap<Key, i32> = HashMap::new();\n        \n        let result = map.get_inner(&Key("empty".to_string()));\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_inner_different_key_type() {\n        let mut map: HashMap<Key, i32> = HashMap::new();\n        map.insert(Key("test".to_string()), 42);\n        \n        let result = map.get_inner(&Key("test".to_string()));\n        assert!(result.is_some());\n        assert_eq!(result.unwrap(), &(Key("test".to_string()), 42));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581293, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=329, prompt_tokens=16361, total_tokens=16690, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmAE1Acv3OxJY8oojGcApLKrYBuq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[derive(Hash, Eq, PartialEq, Debug)]\n    struct Key {\n        id: usize,\n    }\n\n    #[test]\n    fn test_get_inner_mut_existing_key() {\n        let mut map: HashMap<Key, usize> = HashMap::new();\n        let key = Key { id: 1 };\n        map.insert(key.clone(), 42);\n        \n        if let Some((k, v)) = map.get_inner_mut(&key) {\n            assert_eq!(k, &key);\n            assert_eq!(*v, 42);\n            *v = 50;\n        }\n\n        assert_eq!(map.get(&key), Some(&50));\n    }\n\n    #[test]\n    fn test_get_inner_mut_non_existing_key() {\n        let mut map: HashMap<Key, usize> = HashMap::new();\n        let key = Key { id: 1 };\n\n        assert_eq!(map.get_inner_mut(&key), None);\n    }\n\n    #[test]\n    fn test_get_inner_mut_empty_map() {\n        let mut map: HashMap<Key, usize> = HashMap::new();\n        \n        assert_eq!(map.get_inner_mut(&Key { id: 1 }), None);\n    }\n\n    #[test]\n    fn test_get_inner_mut_multiple_keys() {\n        let mut map: HashMap<Key, usize> = HashMap::new();\n        let key1 = Key { id: 1 };\n        let key2 = Key { id: 2 };\n        map.insert(key1.clone(), 10);\n        map.insert(key2.clone(), 20);\n        \n        if let Some((k, v)) = map.get_inner_mut(&key1) {\n            assert_eq!(k, &key1);\n            assert_eq!(*v, 10);\n            *v = 15;\n        }\n\n        if let Some((k, v)) = map.get_inner_mut(&key2) {\n            assert_eq!(k, &key2);\n            assert_eq!(*v, 20);\n            *v = 25;\n        }\n\n        assert_eq!(map.get(&key1), Some(&15));\n        assert_eq!(map.get(&key2), Some(&25));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581306, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=472, prompt_tokens=16361, total_tokens=16833, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmARrfvIngLUn0FvyPU2NBPh809c', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_key_value() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n\n        assert_eq!(map.get_key_value(&1), Some((&1, &"a")));\n        assert_eq!(map.get_key_value(&2), Some((&2, &"b")));\n        assert_eq!(map.get_key_value(&3), None);\n    }\n\n    #[test]\n    fn test_get_key_value_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        assert_eq!(map.get_key_value(&1), None);\n    }\n\n    #[test]\n    fn test_get_key_value_with_different_borrowed_type() {\n        let mut map = HashMap::new();\n        map.insert(String::from("key1"), "value1");\n        \n        let borrowed_key: &str = "key1";\n        assert_eq!(map.get_key_value(&borrowed_key), Some((&String::from("key1"), &"value1")));\n    }\n\n    #[test]\n    fn test_get_key_value_non_existent_key() {\n        let mut map = HashMap::new();\n        map.insert(10, "test");\n        \n        assert_eq!(map.get_key_value(&20), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581319, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=299, prompt_tokens=16361, total_tokens=16660, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmAaTKfrdFngpHPwms4JGuzf9seC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_key_value_mut_existing_key() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        \n        let (k, v) = map.get_key_value_mut(&1).unwrap();\n        assert_eq!(k, &1);\n        assert_eq!(v, &mut "a");\n        *v = "b";\n        assert_eq!(map.get_key_value_mut(&1).unwrap(), (&1, &mut "b"));\n    }\n\n    #[test]\n    fn test_get_key_value_mut_nonexistent_key() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n\n        let result = map.get_key_value_mut(&2);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_key_value_mut_multiple_entries() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n\n        {\n            let (k, v) = map.get_key_value_mut(&1).unwrap();\n            assert_eq!(k, &1);\n            assert_eq!(v, &mut "a");\n            *v = "c";\n        }\n\n        assert_eq!(map.get_key_value_mut(&1).unwrap(), (&1, &mut "c"));\n        assert_eq!(map.get_key_value_mut(&2).unwrap(), (&2, &mut "b"));\n    }\n\n    #[test]\n    fn test_get_key_value_mut_with_different_key_type() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n\n        let (k, v) = map.get_key_value_mut(&1).unwrap();\n        assert_eq!(k, &1);\n        assert_eq!(v, &mut "a");\n    }\n\n    #[test]\n    fn test_get_key_value_mut_with_mutable_references() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        \n        let (k, v) = map.get_key_value_mut(&1).unwrap();\n        assert_eq!(k, &1);\n        *v = "changed";\n        \n        assert_eq!(map.get_key_value_mut(&1).unwrap(), (&1, &mut "changed"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581328, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=497, prompt_tokens=16361, total_tokens=16858, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmAodtX0vtZBTtATjvI9GoKoxxn0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_key_value_mut_existing_keys() {\n        let mut libraries = HashMap::new();\n        libraries.insert("Bodleian Library".to_string(), 1602);\n        libraries.insert("Athenum".to_string(), 1807);\n        libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n        \n        let got = libraries.get_many_key_value_mut([\n            "Bodleian Library",\n            "Herzogin-Anna-Amalia-Bibliothek",\n        ]);\n\n        assert_eq!(\n            got,\n            [\n                Some((&"Bodleian Library".to_string(), &mut 1602)),\n                Some((&"Herzogin-Anna-Amalia-Bibliothek".to_string(), &mut 1691)),\n            ],\n        );\n    }\n\n    #[test]\n    fn test_get_many_key_value_mut_some_missing_keys() {\n        let mut libraries = HashMap::new();\n        libraries.insert("Bodleian Library".to_string(), 1602);\n        \n        let got = libraries.get_many_key_value_mut([\n            "Bodleian Library",\n            "Some Nonexistent Library",\n        ]);\n\n        assert_eq!(got, [Some((&"Bodleian Library".to_string(), &mut 1602)), None]);\n    }\n\n    #[test]\n    #[should_panic(expected = "index out of bounds")]\n    fn test_get_many_key_value_mut_overlapping_keys() {\n        let mut libraries = HashMap::new();\n        libraries.insert("Bodleian Library".to_string(), 1602);\n        libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n        \n        libraries.get_many_key_value_mut([\n            "Bodleian Library",\n            "Herzogin-Anna-Amalia-Bibliothek",\n            "Herzogin-Anna-Amalia-Bibliothek",\n        ]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581342, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=424, prompt_tokens=16361, total_tokens=16785, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmB3Mbu2g8uiP65Q5d6X39ghCMLd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_key_value_unchecked_mut() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n        map.insert("d", 4);\n\n        unsafe {\n            let keys = ["a", "b"];\n            let values = map.get_many_key_value_unchecked_mut(&keys);\n            assert_eq!(values, [\n                Some((&"a", &mut 1)),\n                Some((&"b", &mut 2)),\n            ]);\n\n            let keys_missing = ["a", "e"];\n            let values_missing = map.get_many_key_value_unchecked_mut(&keys_missing);\n            assert_eq!(values_missing, [\n                Some((&"a", &mut 1)),\n                None,\n            ]);\n        }\n    }\n\n    #[test]\n    fn test_get_many_key_value_unchecked_mut_with_overlapping_keys() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n\n        let keys = ["a", "b"];\n        unsafe {\n            let values = map.get_many_key_value_unchecked_mut(&keys);\n            assert_eq!(values, [\n                Some((&"a", &mut 1)),\n                Some((&"b", &mut 2)),\n            ]);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581357, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=312, prompt_tokens=16361, total_tokens=16673, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmBCFKMlB4TmGhuxscjUyBjo0Jl3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_mut() {\n        let mut libraries = HashMap::new();\n        libraries.insert("Bodleian Library".to_string(), 1602);\n        libraries.insert("Athenum".to_string(), 1807);\n        libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n        libraries.insert("Library of Congress".to_string(), 1800);\n\n        let [Some(a), Some(b)] = libraries.get_many_mut([\n            "Athenum",\n            "Bodleian Library",\n        ]) else { panic!() };\n        assert_eq!(*a, 1807);\n        assert_eq!(*b, 1602);\n\n        let got = libraries.get_many_mut([\n            "Athenum",\n            "Library of Congress",\n        ]);\n        assert_eq!(got, [\n            Some(&mut 1807),\n            Some(&mut 1800),\n        ]);\n\n        let got = libraries.get_many_mut([\n            "Athenum",\n            "New York Public Library",\n        ]);\n        assert_eq!(got, [\n            Some(&mut 1807),\n            None\n        ]);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_get_many_mut_panic_on_duplicate_keys() {\n        let mut libraries = HashMap::new();\n        libraries.insert("Athenum".to_string(), 1807);\n\n        let _got = libraries.get_many_mut([\n            "Athenum",\n            "Athenum",\n        ]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581366, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=348, prompt_tokens=16361, total_tokens=16709, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmBOtdsQIoEfVx1NyX5lPmCRjJLR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_mut_inner() {\n        let mut map = HashMap::new();\n        map.insert("A", 1);\n        map.insert("B", 2);\n        map.insert("C", 3);\n\n        let keys = ["A", "B"];\n        let result: [Option<&mut (String, i32)>; 2] = map.get_many_mut_inner(&keys);\n\n        assert_eq!(result[0], Some(&mut ("A".to_string(), 1)));\n        assert_eq!(result[1], Some(&mut ("B".to_string(), 2)));\n    }\n\n    #[test]\n    fn test_get_many_mut_inner_missing_key() {\n        let mut map = HashMap::new();\n        map.insert("A", 1);\n        map.insert("B", 2);\n\n        let keys = ["A", "C"];\n        let result: [Option<&mut (String, i32)>; 2] = map.get_many_mut_inner(&keys);\n\n        assert_eq!(result[0], Some(&mut ("A".to_string(), 1)));\n        assert_eq!(result[1], None);\n    }\n\n    #[test]\n    fn test_get_many_mut_inner_overlap_keys() {\n        let mut map = HashMap::new();\n        map.insert("X", 10);\n        map.insert("Y", 20);\n\n        let keys = ["X", "X"];\n        let result: [Option<&mut (String, i32)>; 2] = map.get_many_mut_inner(&keys);\n        \n        assert_eq!(result[0], Some(&mut ("X".to_string(), 10)));\n        assert_eq!(result[1], None); // Should panic if mutable aliases exist\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581378, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=386, prompt_tokens=16361, total_tokens=16747, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmBYNaoo0vFo7YjiKqruQo7rEYSI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_unchecked_mut() {\n        let mut map = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n        map.insert("key3", 3);\n\n        // SAFETY: Keys do not overlap\n        let [Some(v1), Some(v2)] = unsafe {\n            map.get_many_unchecked_mut(["key1", "key2"])\n        } else { panic!() };\n\n        assert_eq!(*v1, 1);\n        assert_eq!(*v2, 2);\n\n        // SAFETY: Keys do not overlap\n        let got = unsafe { map.get_many_unchecked_mut(["key2", "key3"]) };\n        assert_eq!(got, [Some(&mut 2), Some(&mut 3)]);\n\n        // SAFETY: One key does not exist\n        let got = unsafe { map.get_many_unchecked_mut(["key1", "key4"]) };\n        assert_eq!(got, [Some(&mut 1), None]);\n    }\n\n    #[test]\n    fn test_get_many_unchecked_mut_overlap() {\n        let mut map = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n\n        // SAFETY: Adding overlapping keys should be unsafe and cause undefined behavior\n        let result = std::panic::catch_unwind(|| {\n            unsafe { map.get_many_unchecked_mut(["key1", "key1"]) };\n        });\n\n        assert!(result.is_err(), "Expected panic due to overlapping keys");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581388, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=358, prompt_tokens=16361, total_tokens=16719, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmBlf4AkGkDvYOMa8b1AjIoyOvHD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_many_unchecked_mut_inner() {\n        let mut map = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n        map.insert("key3", 3);\n\n        let keys = ["key1", "key2"];\n        let results = unsafe { map.get_many_unchecked_mut_inner(&keys) };\n\n        assert_eq!(results[0], Some(&mut ("key1", 1)));\n        assert_eq!(results[1], Some(&mut ("key2", 2)));\n\n        let keys_not_in_map = ["key3", "key4"];\n        let results_not_in_map = unsafe { map.get_many_unchecked_mut_inner(&keys_not_in_map) };\n\n        assert_eq!(results_not_in_map[0], Some(&mut ("key3", 3)));\n        assert_eq!(results_not_in_map[1], None);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_get_many_unchecked_mut_inner_overlap() {\n        let mut map = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n\n        let keys = ["key1", "key1"]; // overlapping keys\n        let _ = unsafe { map.get_many_unchecked_mut_inner(&keys) };\n    }\n\n    #[test]\n    fn test_get_many_unchecked_mut_inner_non_existent() {\n        let mut map = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n\n        let keys = ["key3", "key4"];\n        let results = unsafe { map.get_many_unchecked_mut_inner(&keys) };\n\n        assert_eq!(results[0], None);\n        assert_eq!(results[1], None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581401, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=404, prompt_tokens=16361, total_tokens=16765, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmBxfGlyFYJ1Mu7gBzBQyjbTwpFX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_get_mut() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        \n        // Test mutating existing key\n        if let Some(x) = map.get_mut(&1) {\n            *x = "b";\n        }\n        assert_eq!(map.get(&1), Some(&"b"));\n\n        // Test getting a key that does not exist\n        assert_eq!(map.get_mut(&2), None);\n    }\n\n    #[test]\n    fn test_get_mut_non_existent() {\n        let mut map = HashMap::new();\n        map.insert(2, "x");\n        \n        // Test mutating a non-existent key\n        assert_eq!(map.get_mut(&3), None);\n    }\n\n    #[test]\n    fn test_get_mut_multiple() {\n        let mut map = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        // Modify both existing keys\n        if let Some(x) = map.get_mut(&1) {\n            *x += 5; // 10 + 5 = 15\n        }\n        if let Some(x) = map.get_mut(&2) {\n            *x *= 2; // 20 * 2 = 40\n        }\n\n        assert_eq!(map.get(&1), Some(&15));\n        assert_eq!(map.get(&2), Some(&40));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581413, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=321, prompt_tokens=16361, total_tokens=16682, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmC8zTpYqXN21YumfqvwnFwCEm9i', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n    use hashbrown::DefaultHashBuilder;\n\n    #[test]\n    fn test_hasher() {\n        let hasher = DefaultHashBuilder::default();\n        let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n        assert!(map.hasher().is_instance_of::<DefaultHashBuilder>());\n    }\n\n    #[test]\n    fn test_hasher_with_custom_builder() {\n        use std::collections::hash_map::RandomState;\n        let hasher = RandomState::new();\n        let map: HashMap<i32, i32, RandomState> = HashMap::with_hasher(hasher);\n        assert!(map.hasher().is_instance_of::<RandomState>());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581424, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=167, prompt_tokens=16361, total_tokens=16528, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmCGcwb8nWFLvWeJvzUnw5vlM584', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_insert_new_key() {\n        let mut map = HashMap::new();\n        let result = map.insert(42, "value");\n        assert_eq!(result, None);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&42), Some(&"value"));\n    }\n\n    #[test]\n    fn test_insert_update_existing_key() {\n        let mut map = HashMap::new();\n        map.insert(42, "value1");\n        let result = map.insert(42, "value2");\n        assert_eq!(result, Some("value1"));\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&42), Some(&"value2"));\n    }\n\n    #[test]\n    fn test_insert_multiple_keys() {\n        let mut map = HashMap::new();\n        map.insert(1, "one");\n        map.insert(2, "two");\n        map.insert(3, "three");\n        assert_eq!(map.len(), 3);\n        assert_eq!(map.get(&1), Some(&"one"));\n        assert_eq!(map.get(&2), Some(&"two"));\n        assert_eq!(map.get(&3), Some(&"three"));\n    }\n\n    #[test]\n    fn test_insert_zero_keys() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        let result = map.insert(0, 0);\n        assert_eq!(result, None);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&0), Some(&0));\n    }\n\n    #[test]\n    fn test_insert_overwriting_different_types() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("a", 2);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get("a"), Some(&2));\n    }\n\n    #[test]\n    fn test_insert_and_drop() {\n        let mut map = HashMap::new();\n        map.insert(1, "value");\n        drop(map);\n        // map is dropped, the test is to ensure no panic occurs\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581432, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=475, prompt_tokens=16361, total_tokens=16836, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmCTfAnINMrMCrmmYfuTn0tUFVQU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_insert_unique_unchecked() {\n        let mut map = HashMap::new();\n        let key = 1;\n        let value = "value1";\n\n        unsafe {\n            let (inserted_key_ref, inserted_value_ref) = map.insert_unique_unchecked(key, value);\n            assert_eq!(inserted_key_ref, &key);\n            assert_eq!(*inserted_value_ref, value);\n        }\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&key), Some(&value));\n    }\n\n    #[test]\n    fn test_insert_unique_unchecked_multiple() {\n        let mut map = HashMap::new();\n\n        let keys_values = vec![\n            (1, "value1"),\n            (2, "value2"),\n            (3, "value3"),\n        ];\n\n        for (key, value) in keys_values {\n            unsafe {\n                map.insert_unique_unchecked(key, value);\n            }\n        }\n\n        assert_eq!(map.len(), keys_values.len());\n\n        for (key, value) in keys_values {\n            assert_eq!(map.get(&key), Some(&value));\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_insert_unique_unchecked_duplicate_key() {\n        let mut map = HashMap::new();\n        let key = 1;\n        let value1 = "value1";\n        let value2 = "value2";\n\n        unsafe {\n            let _ = map.insert_unique_unchecked(key, value1);\n            let _ = map.insert_unique_unchecked(key, value2); // This should panic\n        }\n    }\n\n    #[test]\n    fn test_insert_unique_unchecked_no_panic() {\n        let mut map = HashMap::new();\n        let key1 = 1;\n        let value1 = "value1";\n\n        unsafe {\n            map.insert_unique_unchecked(key1, value1);\n        }\n\n        let key2 = 2;\n        let value2 = "value2";\n\n        unsafe {\n            let (inserted_key_ref, inserted_value_ref) = map.insert_unique_unchecked(key2, value2);\n            assert_eq!(inserted_key_ref, &key2);\n            assert_eq!(*inserted_value_ref, value2);\n        }\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&key1), Some(&value1));\n        assert_eq!(map.get(&key2), Some(&value2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581445, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=533, prompt_tokens=16361, total_tokens=16894, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmDEsdzDfMqAx2VfqzkusM46dZ3l', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_keys() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n\n        let mut keys: Vec<&str> = map.into_keys().collect();\n        keys.sort_unstable();\n        assert_eq!(keys, ["a", "b", "c"]);\n    }\n\n    #[test]\n    fn test_into_keys_empty() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        let keys: Vec<&str> = map.into_keys().collect();\n        assert!(keys.is_empty());\n    }\n\n    #[test]\n    fn test_into_keys_combined() {\n        let mut map = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n        map.insert("key3", 3);\n        map.insert("key4", 4);\n\n        let mut keys: Vec<&str> = map.into_keys().collect();\n        keys.sort_unstable();\n        assert_eq!(keys, ["key1", "key2", "key3", "key4"]);\n    }\n\n    #[test]\n    fn test_into_keys_with_duplicates() {\n        let mut map = HashMap::new();\n        map.insert("duplicate", 1);\n        map.insert("duplicate", 2); // overwrites previous value\n\n        let mut keys: Vec<&str> = map.into_keys().collect();\n        keys.sort_unstable();\n        assert_eq!(keys, ["duplicate"]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581492, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=354, prompt_tokens=16361, total_tokens=16715, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmDQVfwvepVOUUF9Q6mxSdzEXGiV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_into_values() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n\n        let mut vec: Vec<i32> = map.into_values().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [1, 2, 3]);\n    }\n\n    #[test]\n    fn test_into_values_empty() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        let vec: Vec<i32> = map.into_values().collect();\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_into_values_single_element() {\n        let mut map = HashMap::new();\n        map.insert("a", 42);\n\n        let mut vec: Vec<i32> = map.into_values().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [42]);\n    }\n\n    #[test]\n    fn test_into_values_multiple_same() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 1);\n        map.insert("c", 1);\n\n        let mut vec: Vec<i32> = map.into_values().collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [1, 1, 1]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581504, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=319, prompt_tokens=16361, total_tokens=16680, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmDdD7LwSJtJhPgzsjvd0D9Ce5BA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_is_empty() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        assert!(map.is_empty());\n\n        let mut map = HashMap::new();\n        map.insert(1, 1);\n        assert!(!map.is_empty());\n\n        map.remove(&1);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_is_empty_with_capacity() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(10);\n        assert!(map.is_empty());\n\n        map.insert(1, 1);\n        assert!(!map.is_empty());\n\n        map.clear();\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_is_empty_after_operations() {\n        let mut map = HashMap::new();\n        assert!(map.is_empty());\n\n        map.insert(2, 2);\n        assert!(!map.is_empty());\n\n        map.insert(3, 3);\n        assert!(!map.is_empty());\n\n        map.remove(&2);\n        assert!(!map.is_empty());\n\n        map.remove(&3);\n        assert!(map.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581517, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=267, prompt_tokens=16361, total_tokens=16628, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmDn4eivg7ZS3IuBNEANexauyopG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn iter_empty_map() {\n        let map: HashMap<i32, i32> = HashMap::new();\n        let mut vec: Vec<(i32, i32)> = Vec::new();\n\n        for (key, val) in map.iter() {\n            vec.push((*key, *val));\n        }\n\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn iter_non_empty_map() {\n        let mut map = HashMap::new();\n        map.insert(1, 100);\n        map.insert(2, 200);\n        map.insert(3, 300);\n        let mut vec: Vec<(i32, i32)> = Vec::new();\n\n        for (key, val) in map.iter() {\n            vec.push((*key, *val));\n        }\n\n        vec.sort_unstable();\n        assert_eq!(vec, [(1, 100), (2, 200), (3, 300)]);\n    }\n\n    #[test]\n    fn iter_with_mutation() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n\n        for (_, val) in map.iter_mut() {\n            *val += 10;\n        }\n\n        let mut vec: Vec<(&str, i32)> = Vec::new();\n        for (key, val) in map.iter() {\n            vec.push((*key, *val));\n        }\n\n        vec.sort_unstable();\n        assert_eq!(vec, [("a", 11), ("b", 12), ("c", 13)]);\n    }\n\n    #[test]\n    fn iter_with_empty_map_after_mutation() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.clear();\n\n        let mut vec: Vec<(&str, i32)> = Vec::new();\n        for (key, val) in map.iter() {\n            vec.push((*key, *val));\n        }\n\n        assert!(vec.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581527, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=465, prompt_tokens=16361, total_tokens=16826, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmE1hWQPdjJUTVaukAJXidAV0P9P', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::HashMap;\n\n    #[test]\n    fn test_iter_mut() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n\n        for (_, val) in map.iter_mut() {\n            *val *= 2;\n        }\n\n        assert_eq!(map.len(), 3);\n        let mut vec: Vec<(&str, i32)> = Vec::new();\n        for (key, val) in &map {\n            vec.push((*key, *val));\n        }\n\n        vec.sort_unstable();\n        assert_eq!(vec, [("a", 2), ("b", 4), ("c", 6)]);\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn test_iter_mut_empty() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        {\n            let mut iter = map.iter_mut();\n            let next = iter.next();\n            assert!(next.is_none(), "Iterator over an empty map should return None");\n        }\n    }\n\n    #[test]\n    fn test_iter_mut_multiple_updates() {\n        let mut map = HashMap::new();\n        map.insert("x", 1);\n        map.insert("y", 2);\n\n        for (_, val) in map.iter_mut() {\n            *val += 10;\n        }\n\n        assert_eq!(map.get("x"), Some(&11));\n        assert_eq!(map.get("y"), Some(&12));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581541, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=339, prompt_tokens=16361, total_tokens=16700, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEFpmTkzBOf5KKjlkVFAOORKJ8b', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n        \n        let mut keys: Vec<&str> = map.keys().cloned().collect();\n        keys.sort_unstable();\n        \n        assert_eq!(keys, ["a", "b", "c"]);\n    }\n\n    #[test]\n    fn test_keys_empty() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        let keys: Vec<&str> = map.keys().collect();\n        assert!(keys.is_empty());\n    }\n\n    #[test]\n    fn test_keys_single_entry() {\n        let mut map = HashMap::new();\n        map.insert("x", 42);\n        \n        let keys: Vec<&str> = map.keys().collect();\n        \n        assert_eq!(keys.len(), 1);\n        assert_eq!(keys[0], &"x");\n    }\n\n    #[test]\n    fn test_keys_after_insert() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n        map.insert("d", 4);\n        map.insert("e", 5);\n\n        let keys: Vec<&str> = map.keys().collect();\n        assert_eq!(keys.len(), 5);\n    }\n\n    #[test]\n    fn test_keys_after_remove() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n        map.remove("b");\n        \n        let keys: Vec<&str> = map.keys().collect();\n        assert_eq!(keys.len(), 2);\n        assert!(!keys.contains(&"b"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581555, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=418, prompt_tokens=16361, total_tokens=16779, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEUVeuDU11bo1KFTBaWRN8Zvcbk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_len() {\n        let mut map = HashMap::new();\n        assert_eq!(map.len(), 0); // Check initial length\n\n        map.insert(1, "a");\n        assert_eq!(map.len(), 1); // Check length after one insertion\n\n        map.insert(2, "b");\n        map.insert(3, "c");\n        assert_eq!(map.len(), 3); // Check length after multiple insertions\n\n        map.remove(&2);\n        assert_eq!(map.len(), 2); // Check length after removal\n\n        map.clear();\n        assert_eq!(map.len(), 0); // Check length after clearing the map\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581570, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=163, prompt_tokens=16361, total_tokens=16524, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEdIEbpFq43xWZ0uo6OerxEP5Qn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_remove_existing_key() {\n        let mut map = HashMap::new();\n        map.insert(1, "value1");\n        map.insert(2, "value2");\n\n        assert_eq!(map.remove(&1), Some("value1"));\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.remove(&1), None);\n    }\n\n    #[test]\n    fn test_remove_non_existing_key() {\n        let mut map = HashMap::new();\n        map.insert(1, "value1");\n\n        assert_eq!(map.remove(&2), None);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_remove_empty_map() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        assert_eq!(map.remove(&1), None);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_remove_after_insert() {\n        let mut map = HashMap::new();\n        map.insert(1, "value");\n        assert_eq!(map.remove(&1), Some("value"));\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_remove_and_insert_same_key() {\n        let mut map = HashMap::new();\n        map.insert(1, "old_value");\n\n        assert_eq!(map.remove(&1), Some("old_value"));\n        assert_eq!(map.len(), 0);\n\n        map.insert(1, "new_value");\n        assert_eq!(map.remove(&1), Some("new_value"));\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_remove_key_when_equivalent() {\n        #[derive(Hash, Eq, PartialEq)]\n        struct Key {\n            id: i32,\n        }\n\n        let mut map = HashMap::new();\n        map.insert(Key { id: 1 }, "value1");\n\n        assert_eq!(map.remove(&Key { id: 1 }), Some("value1"));\n        assert!(map.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581579, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=442, prompt_tokens=16361, total_tokens=16803, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEqU1D0Hq6sYdJxDohTowAJMozS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_remove_entry() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        // Test removing an existing entry\n        let removed_entry = map.remove_entry(&2);\n        assert_eq!(removed_entry, Some((2, "b")));\n        assert_eq!(map.len(), 2);\n        assert!(map.get(&2).is_none());\n\n        // Test removing another existing entry\n        let removed_entry = map.remove_entry(&1);\n        assert_eq!(removed_entry, Some((1, "a")));\n        assert_eq!(map.len(), 1);\n        assert!(map.get(&1).is_none());\n\n        // Test removing a non-existing entry\n        let removed_entry = map.remove_entry(&4);\n        assert_eq!(removed_entry, None);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_remove_entry_empty_map() {\n        let mut map = HashMap::new();\n        let removed_entry = map.remove_entry(&1);\n        assert_eq!(removed_entry, None);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_remove_entry_repeated() {\n        let mut map = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(1, "c");\n\n        let removed_entry = map.remove_entry(&1);\n        assert_eq!(removed_entry, Some((1, "c")));\n        assert_eq!(map.len(), 1);\n        assert!(map.get(&1).is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581592, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=374, prompt_tokens=16361, total_tokens=16735, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmEzmzgRCYFJcHd7PIesJqp0uzpq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_reserve_empty_map() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        assert_eq!(map.capacity(), 0);\n        map.reserve(10);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_reserve_non_empty_map() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert("one", 1);\n        map.insert("two", 2);\n        let initial_capacity = map.capacity();\n        map.reserve(10);\n        assert!(map.capacity() >= initial_capacity);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_reserve_large_capacity() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        let result = std::panic::catch_unwind(|| {\n            map.reserve(usize::MAX);\n        });\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_reserve_multiple_times() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.reserve(5);\n        assert!(map.capacity() >= 5);\n        map.reserve(10);\n        assert!(map.capacity() >= 10);\n        \n        map.reserve(5);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_reserve_and_insert() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.reserve(3);\n        assert_eq!(map.len(), 0);\n        map.insert("one", 1);\n        map.insert("two", 2);\n        assert_eq!(map.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581601, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=396, prompt_tokens=16361, total_tokens=16757, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmFDQyJQX7nNeJXGQBWRVXUH7Sj5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_retain() {\n        let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x * 10)).collect();\n        assert_eq!(map.len(), 8);\n\n        map.retain(|&k, _| k % 2 == 0);\n\n        assert_eq!(map.len(), 4);\n\n        let mut vec: Vec<(i32, i32)> = map.iter().map(|(&k, &v)| (k, v)).collect();\n        vec.sort_unstable();\n        assert_eq!(vec, [(0, 0), (2, 20), (4, 40), (6, 60)]);\n    }\n\n    #[test]\n    fn test_retain_with_no_elements() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.retain(|&k, _| k % 2 == 0);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_retain_with_all_elements_retained() {\n        let mut map: HashMap<i32, i32> = HashMap::from([(1, 10), (2, 20), (3, 30)]);\n        map.retain(|_, _| true);\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn test_retain_with_no_elements_retained() {\n        let mut map: HashMap<i32, i32> = HashMap::from([(1, 10), (2, 20), (3, 30)]);\n        map.retain(|_, _| false);\n        assert_eq!(map.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581615, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=387, prompt_tokens=16361, total_tokens=16748, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmFPpoGxGCrBW6M4LcIgrwz7b62N', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_shrink_to() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        map.insert(1, 2);\n        map.insert(3, 4);\n        assert!(map.capacity() >= 100);\n\n        map.shrink_to(10);\n        assert!(map.capacity() >= 10);\n\n        map.shrink_to(0);\n        assert!(map.capacity() >= 2);\n\n        map.shrink_to(10);\n        assert!(map.capacity() >= 2);\n    }\n\n    #[test]\n    fn test_shrink_to_no_effect() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(20);\n        map.insert(1, 2);\n        map.insert(3, 4);\n        assert!(map.capacity() >= 20);\n\n        map.shrink_to(30);\n        assert!(map.capacity() >= 20);\n    }\n\n    #[test]\n    fn test_shrink_to_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        assert!(map.capacity() == 0);\n\n        map.shrink_to(10);\n        assert!(map.capacity() == 0);\n\n        map.insert(1, 2);\n        map.shrink_to(0);\n        assert!(map.capacity() >= 1);\n    }\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        map.insert(1, 2);\n        map.insert(3, 4);\n\n        assert!(map.capacity() >= 100);\n        map.shrink_to_fit();\n        assert!(map.capacity() >= 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581627, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=400, prompt_tokens=16361, total_tokens=16761, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmFZ40B0zyCfoOrjjFqonH29ZGkd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n        map.insert(1, 1);\n        map.insert(2, 2);\n        assert!(map.capacity() >= 100);\n        map.shrink_to_fit();\n        assert!(map.capacity() >= 2);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        assert!(map.capacity() == 0);\n        map.shrink_to_fit();\n        assert!(map.capacity() == 0);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_with_elements() {\n        let mut map: HashMap<i32, i32> = HashMap::with_capacity(50);\n        for i in 0..100 {\n            map.insert(i, i);\n        }\n        assert!(map.capacity() > 50);\n        map.shrink_to_fit();\n        assert!(map.capacity() >= 100); // may not shrink below 100 due to internal resize policy\n    }\n\n    #[test]\n    fn test_shrink_to_fit_after_removal() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        map.insert(3, 30);\n        assert!(map.capacity() >= 3);\n        map.remove(&1);\n        map.shrink_to_fit();\n        assert!(map.capacity() >= 2); // after considering the removal, it should manage size\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581637, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=377, prompt_tokens=16361, total_tokens=16738, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmFmyi6jjcyktwFno2EUTscMCaCk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::OccupiedError;\n\n    #[test]\n    fn test_try_insert_success() {\n        let mut map = HashMap::new();\n        let value = map.try_insert(1, "first").unwrap();\n        assert_eq!(value, &"first");\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_try_insert_existing_key() {\n        let mut map = HashMap::new();\n        let _ = map.try_insert(1, "first").unwrap();\n\n        match map.try_insert(1, "second") {\n            Err(OccupiedError { entry, value }) => {\n                assert_eq!(entry.key(), &1);\n                assert_eq!(entry.get(), &"first");\n                assert_eq!(value, "second");\n            }\n            _ => panic!("Expected an error for existing key"),\n        }\n    }\n\n    #[test]\n    fn test_try_insert_multiple_keys() {\n        let mut map = HashMap::new();\n        assert_eq!(map.try_insert(1, "one").unwrap(), &"one");\n        assert_eq!(map.try_insert(2, "two").unwrap(), &"two");\n        assert_eq!(map.len(), 2);\n        \n        match map.try_insert(1, "one_new") {\n            Err(OccupiedError { entry, value }) => {\n                assert_eq!(entry.key(), &1);\n                assert_eq!(entry.get(), &"one");\n                assert_eq!(value, "one_new");\n            }\n            _ => panic!("Expected an error for existing key"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581650, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=342, prompt_tokens=16361, total_tokens=16703, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmFxEu5itS6rfLgxCDXY5UHlK9jz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::TryReserveError;\n\n    #[test]\n    fn test_try_reserve_success() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        assert_eq!(map.capacity(), 0);\n        map.try_reserve(10).expect("Failed to reserve capacity");\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_try_reserve_capacity_overflow() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        match map.try_reserve(usize::MAX) {\n            Err(error) => match error {\n                TryReserveError::CapacityOverflow => {}\n                _ => panic!("Unexpected error type"),\n            },\n            _ => panic!("Expected an error, but got success"),\n        }\n    }\n\n    #[test]\n    fn test_try_reserve_alloc_error() {\n        use std::alloc::System;\n\n        let mut map: HashMap<&str, i32, std::hash::BuildHasherDefault<fnv::FnvHasher>, System> = HashMap::new();\n        let result = map.try_reserve(usize::MAX);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581661, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=265, prompt_tokens=16361, total_tokens=16626, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmG6nvk77b0jeQ9J5wFx5gPl24Ao', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::HashMap;\n\n    #[test]\n    fn test_values() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n        \n        let mut vec: Vec<i32> = Vec::new();\n        for val in map.values() {\n            vec.push(*val);\n        }\n\n        vec.sort_unstable();\n        assert_eq!(vec, [1, 2, 3]);\n        assert_eq!(map.len(), 3);\n    }\n\n    #[test]\n    fn test_values_empty() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        let vec: Vec<&i32> = map.values().collect();\n        assert!(vec.is_empty());\n    }\n\n    #[test]\n    fn test_values_iterate() {\n        let mut map = HashMap::new();\n        map.insert("apple", 10);\n        map.insert("banana", 20);\n        map.insert("cherry", 30);\n        \n        let values: Vec<i32> = map.values().cloned().collect();\n        assert!(values.contains(&10));\n        assert!(values.contains(&20));\n        assert!(values.contains(&30));\n        assert_eq!(values.len(), 3);\n    }\n\n    #[test]\n    fn test_values_arbitrary_order() {\n        let mut map = HashMap::new();\n        map.insert("first", 1);\n        map.insert("second", 2);\n        map.insert("third", 3);\n        \n        let values: Vec<i32> = map.values().cloned().collect();\n        assert!(values.contains(&1));\n        assert!(values.contains(&2));\n        assert!(values.contains(&3));\n        assert_eq!(values.len(), 3);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581670, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=391, prompt_tokens=16361, total_tokens=16752, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmGHzRMGwPou1jeNuVDHe2ePVRjk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_mut() {\n        let mut map = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n\n        for val in map.values_mut() {\n            *val += 10;\n        }\n\n        assert_eq!(map.len(), 3);\n        let mut vec: Vec<i32> = Vec::new();\n        for val in map.values() {\n            vec.push(*val);\n        }\n        \n        vec.sort_unstable();\n        assert_eq!(vec, [11, 12, 13]);\n        assert_eq!(map.len(), 3);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581681, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=164, prompt_tokens=16361, total_tokens=16525, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmGOi1Y7FzXnRl5zOVNzYhzBfwem', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::DefaultHashBuilder;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_with_capacity_and_hasher_in() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        \n        let mut map = HashMap::with_capacity_and_hasher_in(10, hasher, &bump);\n        \n        // The map should be able to hold at least 10 elements without reallocating\n        assert_eq!(map.capacity(), 10);\n        assert!(map.is_empty());\n        \n        // Inserting some elements\n        map.insert(1, "One");\n        map.insert(2, "Two");\n        \n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&"One"));\n        assert_eq!(map.get(&2), Some(&"Two"));\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_in_zero_capacity() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        \n        let mut map = HashMap::with_capacity_and_hasher_in(0, hasher, &bump);\n        \n        // The map should not allocate when capacity is 0\n        assert_eq!(map.capacity(), 0);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_in_reallocation() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        \n        let mut map = HashMap::with_capacity_and_hasher_in(5, hasher, &bump);\n        assert!(map.capacity() >= 5);\n        \n        // Inserting 5 elements to check reallocation\n        for i in 1..=5 {\n            map.insert(i, i.to_string());\n        }\n\n        assert_eq!(map.len(), 5);\n        assert!(map.capacity() >= 5);\n        \n        // Inserting one more element to cause reallocation\n        map.insert(6, "Six");\n        assert_eq!(map.len(), 6);\n        assert!(map.capacity() > 5);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581688, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=469, prompt_tokens=16361, total_tokens=16830, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmGagJq1uHOrMivyopvGShVJozsE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::DefaultHashBuilder;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_with_hasher_in_creates_empty_map() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let map: HashMap<i32, i32, _, _> = HashMap::with_hasher_in(hasher, bump);\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn test_with_hasher_in_does_not_allocate() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let map: HashMap<i32, i32, _, _> = HashMap::with_hasher_in(hasher, bump);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_hasher_in_allows_inserts() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let mut map: HashMap<i32, i32, _, _> = HashMap::with_hasher_in(hasher, bump);\n        \n        map.insert(1, 100);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&1), Some(&100));\n    }\n\n    #[test]\n    fn test_with_hasher_in_allows_multiple_inserts() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let mut map: HashMap<i32, i32, _, _> = HashMap::with_hasher_in(hasher, bump);\n        \n        map.insert(1, 100);\n        map.insert(2, 200);\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&100));\n        assert_eq!(map.get(&2), Some(&200));\n    }\n\n    #[test]\n    fn test_with_hasher_in_inserts_do_not_allocate_until_needed() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let mut map: HashMap<i32, i32, _, _> = HashMap::with_hasher_in(hasher, bump);\n        assert_eq!(map.capacity(), 0);\n        \n        map.insert(1, 100);\n        assert!(map.capacity() > 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581700, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=513, prompt_tokens=16361, total_tokens=16874, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmGpuwGzWs0AxxiMly18IfQDUiPT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::DefaultHashBuilder;\n\n    #[test]\n    fn test_with_capacity_and_hasher() {\n        let hasher = DefaultHashBuilder::default();\n        let mut map = HashMap::with_capacity_and_hasher(10, hasher);\n        assert_eq!(map.len(), 0);\n        assert!(map.capacity() >= 10);\n\n        map.insert(1, 2);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&1), Some(&2));\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_zero_capacity() {\n        let hasher = DefaultHashBuilder::default();\n        let map = HashMap::with_capacity_and_hasher(0, hasher);\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_non_zero_capacity() {\n        let hasher = DefaultHashBuilder::default();\n        let mut map = HashMap::with_capacity_and_hasher(5, hasher);\n        assert!(map.capacity() >= 5);\n        assert!(map.is_empty());\n\n        map.insert(10, 20);\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(&10), Some(&20));\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_large_capacity() {\n        let hasher = DefaultHashBuilder::default();\n        let mut map = HashMap::with_capacity_and_hasher(1000, hasher);\n        assert!(map.capacity() >= 1000);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581715, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=348, prompt_tokens=16361, total_tokens=16709, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmH22o1E1O0RKFFsEU6mYxhduzXv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::DefaultHashBuilder;\n\n    #[test]\n    fn test_with_hasher_initialization() {\n        let hasher = DefaultHashBuilder::default();\n        let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_hasher_inserts() {\n        let hasher = DefaultHashBuilder::default();\n        let mut map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n\n        map.insert(1, 10);\n        map.insert(2, 20);\n\n        assert_eq!(map.len(), 2);\n        assert_eq!(map.get(&1), Some(&10));\n        assert_eq!(map.get(&2), Some(&20));\n    }\n\n    #[test]\n    fn test_with_different_hashers() {\n        use std::collections::hash_map::RandomState;\n\n        let hasher = RandomState::new();\n        let mut map: HashMap<String, String> = HashMap::with_hasher(hasher);\n\n        map.insert("key".to_string(), "value".to_string());\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get("key"), Some(&"value".to_string()));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581728, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=299, prompt_tokens=16361, total_tokens=16660, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHBQJ4sZseQmBt8s4SXIAdZv648', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_new_in_empty() {\n        let bump = Bump::new();\n        let map: HashMap<i32, i32, DefaultHashBuilder, _> = HashMap::new_in(&bump);\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_new_in_insert() {\n        let bump = Bump::new();\n        let mut map: HashMap<&str, i32, DefaultHashBuilder, _> = HashMap::new_in(&bump);\n        map.insert("One", 1);\n        assert_eq!(map.len(), 1);\n        assert!(map.capacity() > 0);\n    }\n\n    #[test]\n    fn test_new_in_multiple_inserts() {\n        let bump = Bump::new();\n        let mut map: HashMap<&str, i32, DefaultHashBuilder, _> = HashMap::new_in(&bump);\n        let entries = [("One", 1), ("Two", 2), ("Three", 3)];\n        \n        for (key, value) in entries.iter() {\n            map.insert(*key, *value);\n        }\n\n        assert_eq!(map.len(), 3);\n        assert!(map.capacity() > 3); // expecting some reallocation to occur\n    }\n\n    #[test]\n    fn test_new_in_capacity() {\n        let bump = Bump::new();\n        let mut map: HashMap<i32, i32, DefaultHashBuilder, _> = HashMap::new_in(&bump);\n        assert_eq!(map.capacity(), 0);\n\n        for i in 0..10 {\n            map.insert(i, i * 2);\n        }\n\n        assert_eq!(map.len(), 10);\n        assert!(map.capacity() > 10); // expecting some reallocation to occur\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581737, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=416, prompt_tokens=16361, total_tokens=16777, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHMSW7lD2iYRyzxNzhYbGd0U7Zo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_with_capacity_in() {\n        let bump = Bump::new();\n        let mut map = HashMap::with_capacity_in(5, &bump);\n\n        assert_eq!(map.len(), 0);\n        let empty_map_capacity = map.capacity();\n        assert!(empty_map_capacity >= 5);\n\n        map.insert("One", 1);\n        map.insert("Two", 2);\n        map.insert("Three", 3);\n        map.insert("Four", 4);\n        map.insert("Five", 5);\n\n        assert_eq!(map.len(), 5);\n        assert_eq!(map.capacity(), empty_map_capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_in_zero() {\n        let bump = Bump::new();\n        let map = HashMap::<&str, i32>::with_capacity_in(0, &bump);\n\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581748, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=227, prompt_tokens=16361, total_tokens=16588, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHT4cHmqPYx0T4p5kuvTUvzgGV1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_new_hashmap() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581755, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=76, prompt_tokens=16361, total_tokens=16437, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHYCHxlrohQUREEERXZn3Jlgjiv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_with_capacity() {\n        let mut map: HashMap<&str, i32> = HashMap::with_capacity(10);\n        assert_eq!(map.len(), 0);\n        assert!(map.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let map: HashMap<&str, i32> = HashMap::with_capacity(0);\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_below_initial_capacity() {\n        let mut map: HashMap<&str, i32> = HashMap::with_capacity(5);\n        assert!(map.capacity() >= 5);\n        map.insert("One", 1);\n        map.insert("Two", 2);\n        assert!(map.capacity() >= 5);\n    }\n\n    #[test]\n    fn test_with_capacity_more_than_initial_insert() {\n        let mut map: HashMap<&str, i32> = HashMap::with_capacity(5);\n        assert_eq!(map.len(), 0);\n        assert!(map.capacity() >= 5);\n        \n        map.insert("Three", 3);\n        map.insert("Four", 4);\n        map.insert("Five", 5);\n        assert_eq!(map.len(), 3);\n        assert!(map.capacity() >= 5);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581760, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=318, prompt_tokens=16361, total_tokens=16679, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmHkq8blzRKZybY1q1IKhncLbOOW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter() {\n        // Create a HashMap for testing\n        let map: HashMap<i32, &str> = [(1, "a"), (2, "b"), (3, "c")].iter().cloned().collect();\n        let into_iter = map.into_iter();\n\n        // Get an Iter from the into_iter\n        let iter = into_iter.iter();\n\n        // Collect into a Vec to assert\n        let result: Vec<_> = iter.collect();\n        \n        // Sort values since iteration order is not guaranteed\n        let mut expected = vec![(&1, &"a"), (&2, &"b"), (&3, &"c")];\n        expected.sort_unstable();\n\n        // Sort the result for comparison\n        let mut result_sorted = result.into_iter().collect::<Vec<_>>();\n        result_sorted.sort_unstable();\n\n        assert_eq!(expected, result_sorted);\n    }\n\n    #[test]\n    fn test_iter_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let into_iter = map.into_iter();\n        let iter = into_iter.iter();\n        \n        let result: Vec<_> = iter.collect();\n        \n        assert!(result.is_empty());\n    }\n\n    #[test]\n    fn test_iter_fused() {\n        let map: HashMap<i32, &str> = [(1, "a"), (2, "b")].iter().cloned().collect();\n        let into_iter = map.into_iter();\n        let mut iter = into_iter.iter();\n\n        assert_eq!(iter.next(), Some((&1, &"a")));\n        assert_eq!(iter.next(), Some((&2, &"b")));\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None); // Should still return None for fused behavior\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581772, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=407, prompt_tokens=11097, total_tokens=11504, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmI544kWO1XUU1gvKm8GFJ5tzuCO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let mut iter = map.iter();\n        let mut vec: Vec<_> = iter.collect();\n        vec.sort_unstable();  // Ensure the order is consistent for the test\n\n        assert_eq!(vec, vec![Some((&1, &"a")), Some((&2, &"b")), Some((&3, &"c"))]);\n\n        // Check that the iterator is fused\n        assert_eq!(iter.next(), None);\n        assert_eq!(iter.next(), None);\n    }\n    \n    #[test]\n    fn test_iter_empty() {\n        let map: HashMap<i32, &str> = HashMap::new();\n        let mut iter = map.iter();\n        assert_eq!(iter.next(), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581793, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=228, prompt_tokens=10660, total_tokens=10888, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmID1RM4W4Y6BAlV2PKchFkYfbQ4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_get_existing_key() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert("key1", 10);\n        map.insert("key2", 20);\n\n        assert_eq!(map.get(&"key1"), Some(&10));\n        assert_eq!(map.get(&"key2"), Some(&20));\n    }\n\n    #[test]\n    fn test_get_non_existing_key() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        assert_eq!(map.get(&"non_existing"), None);\n    }\n\n    #[test]\n    fn test_get_after_insertion() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert("key", 42);\n        \n        assert_eq!(map.get(&"key"), Some(&42));\n        map.insert("key", 100);\n        assert_eq!(map.get(&"key"), Some(&100));\n    }\n\n    #[test]\n    fn test_get_with_different_key_type() {\n        let mut map: HashMap<i32, &str> = HashMap::new();\n        map.insert(1, "one");\n        map.insert(2, "two");\n\n        assert_eq!(map.get(&1), Some(&"one"));\n        assert_eq!(map.get(&2), Some(&"two"));\n        assert_eq!(map.get(&3), None);\n    }\n\n    #[test]\n    fn test_get_key_reference() {\n        let mut map: HashMap<String, i32> = HashMap::new();\n        map.insert("test".to_string(), 5);\n        \n        let key = "test".to_string();\n        assert_eq!(map.get(&key), Some(&5));\n    }\n\n    #[test]\n    fn test_get_return_type() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert("a", 1);\n\n        let value = map.get(&"a").unwrap();\n        assert_eq!(*value, 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581801, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=469, prompt_tokens=16361, total_tokens=16830, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmINqTofK0hXPN09kSuPdLbk2QeN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_get_mut() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 12);\n\n        assert_eq!(map["poneyland"], 12);\n        if let Entry::Occupied(mut entry) = map.entry("poneyland") {\n            *entry.get_mut() += 10;\n            assert_eq!(*entry.get(), 22);\n            *entry.get_mut() += 2;\n        }\n\n        assert_eq!(map["poneyland"], 24);\n    }\n\n    #[test]\n    fn test_get_mut_non_existent() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 12);\n\n        if let Entry::Occupied(mut entry) = map.entry("poneyland") {\n            assert_eq!(entry.get_mut(), &mut 12);\n            *entry.get_mut() += 10;\n        }\n\n        assert_eq!(map.get_mut("nonexistent"), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581811, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=256, prompt_tokens=16361, total_tokens=16617, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmIXqBNJYz7p9X9PZDjheQVkH4wT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_insert_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 12);\n\n        if let Entry::Occupied(mut o) = map.entry("poneyland") {\n            assert_eq!(o.insert(15), 12);\n        }\n\n        assert_eq!(map["poneyland"], 15);\n    }\n\n    #[test]\n    fn test_insert_non_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 12);\n\n        if let Entry::Vacant(o) = map.entry("newland") {\n            assert_eq!(o.insert(20), 20);\n        }\n\n        assert_eq!(map["newland"], 20);\n    }\n\n    #[test]\n    fn test_insert_multiple_entries() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 12);\n        map.insert("newland", 20);\n\n        if let Entry::Occupied(mut o) = map.entry("poneyland") {\n            assert_eq!(o.insert(15), 12);\n        }\n        if let Entry::Occupied(mut o) = map.entry("newland") {\n            assert_eq!(o.insert(25), 20);\n        }\n\n        assert_eq!(map["poneyland"], 15);\n        assert_eq!(map["newland"], 25);\n    }\n\n    #[test]\n    fn test_insert_with_different_types() {\n        let mut map: HashMap<u32, &str> = HashMap::new();\n        map.insert(1, "one");\n        map.insert(2, "two");\n\n        if let Entry::Occupied(mut o) = map.entry(1) {\n            assert_eq!(o.insert("uno"), "one");\n        }\n\n        assert_eq!(map[&1], "uno");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581821, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=444, prompt_tokens=16361, total_tokens=16805, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmIikTUCxA1Mpp4rT2e24stbIRmO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{Entry, HashMap};\n\n    #[test]\n    fn test_into_mut() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 12);\n\n        match map.entry("poneyland") {\n            Entry::Occupied(entry) => {\n                let value = entry.into_mut();\n                *value += 10;\n                assert_eq!(map["poneyland"], 22);\n            }\n            Entry::Vacant(_) => panic!("Entry should be occupied"),\n        }\n    }\n\n    #[test]\n    fn test_into_mut_non_existent() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        match map.entry("missing") {\n            Entry::Occupied(_) => panic!("Entry should be vacant"),\n            Entry::Vacant(entry) => {\n                entry.insert(10);\n                assert_eq!(map["missing"], 10);\n            }\n        }\n        match map.entry("missing") {\n            Entry::Occupied(entry) => {\n                let value = entry.into_mut();\n                *value += 5;\n                assert_eq!(map["missing"], 15);\n            }\n            Entry::Vacant(_) => panic!("Entry should be occupied"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581832, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=282, prompt_tokens=16361, total_tokens=16643, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmIsAVLMqMopgi64dzZHBqzfd4Xf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Ensure we are in the correct scope\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 12);\n\n        match map.entry("poneyland") {\n            Entry::Vacant(_) => panic!(),\n            Entry::Occupied(entry) => assert_eq!(entry.key(), &"poneyland"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581842, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=120, prompt_tokens=16361, total_tokens=16481, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJ1cVeMkZ3hkIMdq0SZMMfhWzNS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_remove() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 12);\n\n        if let Entry::Occupied(o) = map.entry("poneyland") {\n            assert_eq!(o.remove(), 12);\n        }\n\n        assert_eq!(map.contains_key("poneyland"), false);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_remove_non_existent_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("example", 34);\n\n        {\n            let entry = map.entry("example");\n            if let Entry::Occupied(o) = entry {\n                assert_eq!(o.remove(), 34);\n            }\n        }\n\n        assert!(map.contains_key("example") == false);\n        assert!(map.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581851, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=221, prompt_tokens=16361, total_tokens=16582, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJDbVGwrWRVIy6blkdv5NNo3npS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_remove_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 12);\n\n        if let Entry::Occupied(o) = map.entry("poneyland") {\n            assert_eq!(o.remove_entry(), ("poneyland", 12));\n        }\n\n        assert_eq!(map.contains_key("poneyland"), false);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn test_remove_entry_empty_map() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert!(map.is_empty());\n\n        let entry_result = map.entry("nonexistent");\n        assert!(matches!(entry_result, Entry::Vacant(_)));\n    }\n\n    #[test]\n    fn test_remove_entry_multiple() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("foo", 1);\n        map.insert("bar", 2);\n\n        if let Entry::Occupied(o) = map.entry("foo") {\n            assert_eq!(o.remove_entry(), ("foo", 1));\n        }\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get("bar"), Some(&2));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581863, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=304, prompt_tokens=16361, total_tokens=16665, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJN3HnJiVrosIl2lkxGIkfQwbNo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_replace_entry_with() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        \n        map.insert("poneyland", 42);\n        let entry = map.entry("poneyland").or_insert(0);\n        \n        let replaced_entry = map.entry("poneyland").and_modify(|v| *v = 0).or_insert(0);\n        \n        let entry = match map.entry("poneyland") {\n            Entry::Occupied(e) => e.replace_entry_with(|k, v| {\n                assert_eq!(k, &"poneyland");\n                assert_eq!(v, 0);\n                Some(v + 1)\n            }),\n            Entry::Vacant(_) => panic!(),\n        };\n\n        match entry {\n            Entry::Occupied(e) => {\n                assert_eq!(e.key(), &"poneyland");\n                assert_eq!(e.get(), &1);\n            },\n            Entry::Vacant(_) => panic!(),\n        }\n\n        assert_eq!(map["poneyland"], 1);\n        \n        let entry = match map.entry("poneyland") {\n            Entry::Occupied(e) => e.replace_entry_with(|_k, _v| None),\n            Entry::Vacant(_) => panic!(),\n        };\n\n        match entry {\n            Entry::Vacant(e) => {\n                assert_eq!(e.key(), &"poneyland");\n            },\n            Entry::Occupied(_) => panic!(),\n        }\n\n        assert!(!map.contains_key("poneyland"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581873, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=356, prompt_tokens=16361, total_tokens=16717, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJXCT4y01n3RCtreHWWFbtXIJc3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let Entry::Vacant(o) = map.entry("test_key") {\n            o.insert(42);\n        }\n\n        assert_eq!(map["test_key"], 42);\n    }\n\n    #[test]\n    fn test_insert_vacant_entry_overwrite() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let Entry::Vacant(o) = map.entry("key") {\n            o.insert(10);\n        }\n\n        if let Entry::Vacant(o) = map.entry("key") {\n            o.insert(20);\n        }\n\n        assert_eq!(map["key"], 10);\n    }\n\n    #[test]\n    fn test_insert_multiple_vacant_entries() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        let keys = ["key1", "key2", "key3"];\n        let values = [1, 2, 3];\n\n        for (key, value) in keys.iter().zip(values.iter()) {\n            if let Entry::Vacant(o) = map.entry(key) {\n                o.insert(*value);\n            }\n        }\n\n        assert_eq!(map["key1"], 1);\n        assert_eq!(map["key2"], 2);\n        assert_eq!(map["key3"], 3);\n    }\n\n    #[test]\n    fn test_insert_with_empty_map() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let Entry::Vacant(o) = map.entry("new_key") {\n            o.insert(100);\n        }\n\n        assert_eq!(map["new_key"], 100);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581883, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=415, prompt_tokens=16361, total_tokens=16776, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJj15txEtgoj7ScviilG5IIjCgd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::Entry;\n\n    #[test]\n    fn test_insert_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let Entry::Vacant(v) = map.entry("test_entry") {\n            let occupied_entry = v.insert_entry(42);\n            assert_eq!(occupied_entry.get(), &42);\n            assert_eq!(map.get("test_entry"), Some(&42));\n        }\n    }\n    \n    #[test]\n    fn test_insert_entry_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("test_entry", 42);\n\n        if let Entry::Vacant(v) = map.entry("test_entry") {\n            let occupied_entry = v.insert_entry(100);\n            assert_eq!(occupied_entry.get(), &100);\n            assert_eq!(map.get("test_entry"), Some(&100));\n        }\n    }\n    \n    #[test]\n    fn test_insert_entry_multiple() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let Entry::Vacant(v) = map.entry("entry_one") {\n            v.insert_entry(1);\n        }\n        if let Entry::Vacant(v) = map.entry("entry_two") {\n            v.insert_entry(2);\n        }\n        if let Entry::Vacant(v) = map.entry("entry_three") {\n            v.insert_entry(3);\n        }\n\n        assert_eq!(map.get("entry_one"), Some(&1));\n        assert_eq!(map.get("entry_two"), Some(&2));\n        assert_eq!(map.get("entry_three"), Some(&3));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581895, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=375, prompt_tokens=16361, total_tokens=16736, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmJspU1YGve31kRCPzwRvyykQ3sf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{Entry, HashMap};\n\n    #[test]\n    fn test_into_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        match map.entry("test_key") {\n            Entry::Occupied(_) => panic!("Entry should be vacant"), \n            Entry::Vacant(v) => {\n                let key = v.into_key(); \n                assert_eq!(key, "test_key");\n            },\n        }\n    }\n\n    #[test]\n    fn test_into_key_with_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("existing_key", 42);\n\n        match map.entry("existing_key") {\n            Entry::Occupied(_) => {\n                panic!("Entry should be occupied, not vacant");\n            },\n            Entry::Vacant(_) => {\n                panic!("Entry should not be vacant since key exists");\n            },\n        }\n    }\n\n    #[test]\n    fn test_multiple_into_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert!(map.is_empty());\n\n        match map.entry("another_key") {\n            Entry::Occupied(_) => panic!("Entry should be vacant"),\n            Entry::Vacant(v) => {\n                let key = v.into_key();\n                assert_eq!(key, "another_key");\n            },\n        }\n\n        assert_eq!(map.len(), 1);\n        assert!(map.contains_key("another_key"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581904, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=327, prompt_tokens=16361, total_tokens=16688, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmK4tum4dYSx0mMWi7xWAAdDPCmg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_key_method() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        // Create a vacant entry for the key "poneyland"\n        let entry = map.entry("poneyland").or_insert(0);\n        \n        // Assert that the key method returns a reference to the key\n        assert_eq!(entry.key(), &"poneyland");\n        \n        // Insert a value into the vacant entry\n        *entry += 42;\n        \n        // Verify the value has been inserted correctly\n        assert_eq!(map.get("poneyland"), Some(&42));\n    }\n\n    #[test]\n    fn test_key_method_with_different_key() {\n        let mut map: HashMap<i32, u32> = HashMap::new();\n\n        // Create a vacant entry for the key 10\n        let entry = map.entry(10).or_insert(0);\n        \n        // Assert that the key method returns a reference to the key\n        assert_eq!(entry.key(), &10);\n        \n        // Insert a value into the vacant entry\n        *entry += 50;\n\n        // Verify the value has been inserted correctly\n        assert_eq!(map.get(&10), Some(&50));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581916, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=286, prompt_tokens=16361, total_tokens=16647, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKDCuUnq6Zg2K96XVn6o5UOAHVd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::EntryRef;\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let key: &str = "poneyland";\n\n        if let EntryRef::Vacant(entry) = map.entry_ref(key) {\n            let value_ref = entry.insert(37);\n            assert_eq!(*value_ref, 37);\n            assert_eq!(map[key], 37);\n        } else {\n            panic!("Expected VacantEntryRef, but entry already exists.");\n        }\n    }\n\n    #[test]\n    fn test_insert_overwrite_existing() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let key: &str = "poneyland";\n\n        map.insert(key.to_string(), 37);\n        if let EntryRef::Vacant(entry) = map.entry_ref(key) {\n            let value_ref = entry.insert(42);\n            assert_eq!(*value_ref, 42);\n            assert_eq!(map[key], 42);\n        } else {\n            panic!("Expected VacantEntryRef, but entry already exists.");\n        }\n    }\n\n    #[test]\n    fn test_insert_multiple_keys() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let keys = vec!["poneyland", "horseyland", "unicornland"];\n\n        for key in keys {\n            if let EntryRef::Vacant(entry) = map.entry_ref(key) {\n                entry.insert(1);\n            }\n        }\n\n        assert_eq!(map["poneyland"], 1);\n        assert_eq!(map["horseyland"], 1);\n        assert_eq!(map["unicornland"], 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581925, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=397, prompt_tokens=16361, total_tokens=16758, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKPggcA8FsptM5NG1ahyyBpMoE2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::EntryRef;\n\n    #[test]\n    fn test_insert_entry_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let EntryRef::Vacant(v) = map.entry_ref("test_entry") {\n            let occupied_entry = v.insert_entry(10);\n            assert_eq!(occupied_entry.get(), &10);\n        } else {\n            panic!("Expected a VacantEntryRef");\n        }\n    }\n\n    #[test]\n    fn test_insert_entry_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("test_entry", 10);\n        \n        if let EntryRef::Occupied(o) = map.entry_ref("test_entry") {\n            let new_entry = o.insert_entry(20);\n            assert_eq!(new_entry.get(), &20);\n            assert_eq!(map.get("test_entry"), Some(&20));\n        } else {\n            panic!("Expected an OccupiedEntryRef");\n        }\n    }\n\n    #[test]\n    fn test_insert_entry_multiple_keys() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        if let EntryRef::Vacant(v) = map.entry_ref("key1") {\n            v.insert_entry(1);\n        }\n        if let EntryRef::Vacant(v) = map.entry_ref("key2") {\n            v.insert_entry(2);\n        }\n\n        assert_eq!(map.get("key1"), Some(&1));\n        assert_eq!(map.get("key2"), Some(&2));\n    }\n\n    #[test]\n    fn test_insert_entry_capacity() {\n        let mut map: HashMap<&str, u32> = HashMap::with_capacity(10);\n        assert!(map.capacity() >= 10);\n        \n        if let EntryRef::Vacant(v) = map.entry_ref("key_capacity") {\n            v.insert_entry(42);\n        }\n\n        assert_eq!(map.get("key_capacity"), Some(&42));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581937, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=450, prompt_tokens=16361, total_tokens=16811, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKbdJzLaWFsNaozE0cgN4DsjOsz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_key_vacant_entry_ref() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let key: &str = "poneyland";\n        let vacant_entry = map.entry_ref(key);\n        assert_eq!(vacant_entry.key(), key);\n    }\n\n    #[test]\n    fn test_key_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key: &str = "land";\n        let vacant_entry = map.entry_ref(key);\n        assert_eq!(vacant_entry.key(), key);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581949, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=154, prompt_tokens=16361, total_tokens=16515, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKgMn5Dm3lesELmZ2eAwWDw56Mu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::map::{self, Drain, HashMap, IntoIter, Iter, Keys, Values};\n\n    #[test]\n    fn test_assert_covariance() {\n        fn test_map_key() {\n            let map: HashMap<&'static str, u8> = HashMap::new();\n            let _: HashMap<&'static str, u8> = map_key(map);\n        }\n\n        fn test_map_val() {\n            let map: HashMap<u8, &'static str> = HashMap::new();\n            let _: HashMap<u8, &'static str> = map_val(map);\n        }\n\n        fn test_iter_key() {\n            let map: HashMap<&'static str, u8> = HashMap::new();\n            let iter = map.iter();\n            let _: Iter<&'static str, u8> = iter_key(iter);\n        }\n\n        fn test_iter_val() {\n            let map: HashMap<u8, &'static str> = HashMap::new();\n            let iter = map.iter();\n            let _: Iter<u8, &'static str> = iter_val(iter);\n        }\n\n        fn test_into_iter_key() {\n            let map: HashMap<&'static str, u8> = HashMap::new();\n            let iter: IntoIter<&'static str, u8> = map.clone().into_iter();\n            let _: IntoIter<&'static str, u8> = into_iter_key(iter);\n        }\n\n        fn test_into_iter_val() {\n            let map: HashMap<u8, &'static str> = HashMap::new();\n            let iter: IntoIter<u8, &'static str> = map.clone().into_iter();\n            let _: IntoIter<u8, &'static str> = into_iter_val(iter);\n        }\n\n        fn test_keys_key() {\n            let map: HashMap<&'static str, u8> = HashMap::new();\n            let keys: Keys<&'static str, u8> = map.keys();\n            let _: Keys<&'static str, u8> = keys_key(keys);\n        }\n\n        fn test_keys_val() {\n            let map: HashMap<u8, &'static str> = HashMap::new();\n            let keys: Keys<u8, &'static str> = map.keys();\n            let _: Keys<u8, &'static str> = keys_val(keys);\n        }\n\n        fn test_values_key() {\n            let map: HashMap<&'static str, u8> = HashMap::new();\n            let values: Values<&'static str, u8> = map.values();\n            let _: Values<&'static str, u8> = values_key(values);\n        }\n\n        fn test_values_val() {\n            let map: HashMap<u8, &'static str> = HashMap::new();\n            let values: Values<u8, &'static str> = map.values();\n            let _: Values<u8, &'static str> = values_val(values);\n        }\n\n        fn test_drain() {\n            let map: HashMap<&'static str, &'static str> = HashMap::new();\n            let drain: Drain<&'static str, &'static str> = map.drain();\n            let _: Drain<&'static str, &'static str> = drain(drain);\n        }\n\n        test_map_key();\n        test_map_val();\n        test_iter_key();\n        test_iter_val();\n        test_into_iter_key();\n        test_into_iter_val();\n        test_keys_key();\n        test_keys_val();\n        test_values_key();\n        test_values_val();\n        test_drain();\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581954, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=752, prompt_tokens=593, total_tokens=1345, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmKyvWFiQ3qnPq5CE7gYb3O6GzRT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::map::{Drain, assert_covariance::drain};\n\n    #[test]\n    fn test_drain_covariance() {\n        // Create a Drain with static lifetimes\n        let static_key: &\'static str = "key";\n        let static_value: &\'static str = "value";\n        let drain_static: Drain<\'static, &\'static str, &\'static str> = Drain {\n            inner: // Initialization of Drain with required parameters\n        };\n\n        // Call the drain function\n        let drain_new: Drain<\'_, &\'static str, &\'static str> = drain(drain_static);\n\n        // Check the types of the returned drain\n        let _: Drain<\'_, &\'static str, &\'static str> = drain_new;\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581972, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=170, prompt_tokens=16361, total_tokens=16531, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmL5qkgy0oCsw12uGhP0o5i7d4EK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::raw::RawIntoIter;\n    \n    #[test]\n    fn test_into_iter_key() {\n        let input: IntoIter<&'static str, u8> = IntoIter::default(); // Replace with actual input initialization as needed\n        let result: IntoIter<&str, u8> = into_iter_key(input);\n        \n        // Ensure that the output type is correct\n        assert!(std::any::type_name::<IntoIter<&str, u8>>() == std::any::type_name::<IntoIter<&str, u8>>());\n        \n        // Test any properties or methods on the result that are important\n        // Add additional assertions based on expected behavior\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581979, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=160, prompt_tokens=10250, total_tokens=10410, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLBUli9vyfZ8Q0uSNPM0PwlHXjy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{map::IntoIter, Allocator, Global};\n\n    #[test]\n    fn test_into_iter_val() {\n        // Create a dummy IntoIter<u8, &\'static str>\n        let data: Vec<(u8, &\'static str)> = vec![(1, "one"), (2, "two"), (3, "three")];\n        let mut map: hashbrown::HashMap<u8, &\'static str, Global> = hashbrown::HashMap::new();\n        for (k, v) in data {\n            map.insert(k, v);\n        }\n\n        let into_iter: IntoIter<u8, &\'static str> = map.into_iter();\n        \n        // Call the into_iter_val function\n        let result_iter: IntoIter<u8, &\'static str, Global> = map::assert_covariance::into_iter_val(into_iter);\n\n        // Collect the results into a vector\n        let result: Vec<(u8, &\'static str)> = result_iter.collect();\n        \n        // The collected results should match the original data\n        assert_eq!(result.len(), data.len());\n        for (idx, (k, v)) in result.into_iter().enumerate() {\n            assert_eq!(k, data[idx].0);\n            assert_eq!(v, data[idx].1);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581985, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=288, prompt_tokens=10248, total_tokens=10536, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLN3V3cRAqToeB5djnSurOZtWoT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_iter_key() {\n        let map: HashMap<&\'static str, u8> = HashMap::new();\n        let iter = map.iter();\n        let result: Iter<&str, u8> = iter_key(iter);\n        assert_eq!(result.len(), 0); // Check that the result has the length of 0 for an empty HashMap\n    }\n\n    #[test]\n    fn test_iter_key_non_empty() {\n        let mut map: HashMap<&\'static str, u8> = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n        \n        let iter = map.iter();\n        let result: Iter<&str, u8> = iter_key(iter);\n        \n        let mut keys: Vec<&str> = result.map(|(&k, &v)| k).collect();\n        keys.sort_unstable(); // Sort the keys since hash map iteration order is not guaranteed\n\n        assert_eq!(keys, vec!["a", "b", "c"]); // Check that keys are as expected\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748581997, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=262, prompt_tokens=9736, total_tokens=9998, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLYBIBUpuPzOyQM07qR6XeX78Q5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use std::iter::Iterator;\n\n    #[test]\n    fn test_iter_val() {\n        let map: HashMap<u8, &\'static str> = HashMap::new();\n        let iter = map.iter();\n        \n        let new_iter = iter_val(iter);\n        \n        // Verifying that the new iterator type corresponds correctly\n        assert!(new_iter.next().is_none());\n    }\n\n    #[test]\n    fn test_iter_val_with_items() {\n        let mut map: HashMap<u8, &\'static str> = HashMap::new();\n        map.insert(1, "a");\n        map.insert(2, "b");\n        map.insert(3, "c");\n\n        let iter = map.iter();\n        let new_iter = iter_val(iter);\n        \n        let mut vec: Vec<_> = new_iter.collect();\n        vec.sort_unstable();\n        \n        assert_eq!(vec, [(1, "a"), (2, "b"), (3, "c")]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582008, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=228, prompt_tokens=9736, total_tokens=9964, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLefid4IJLYYQ8YdeWftOl57WeD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_key() {\n        let map: HashMap<&\'static str, u8> = [("a", 1), ("b", 2), ("c", 3)].iter().cloned().collect();\n        let keys: Keys<&\'static str, u8> = map.keys();\n        let new_keys: Keys<&str, u8> = keys_key(keys);\n        \n        let expected: Vec<&str> = vec!["a", "b", "c"];\n        let result: Vec<&str> = new_keys.collect();\n        \n        assert_eq!(expected.len(), result.len());\n        for item in expected {\n            assert!(result.contains(&item));\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582014, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=173, prompt_tokens=10487, total_tokens=10660, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLkFJ7vBF4UuQFA6fGBUdkfBHGJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_keys_val() {\n        let map: HashMap<u8, &\'static str> = [(1, "a"), (2, "b"), (3, "c")].iter().cloned().collect();\n        let keys: Keys<u8, &\'static str> = map.keys();\n        let new_keys: Keys<u8, &\'static str> = keys_val(keys);\n\n        // Verify all keys are maintained during conversion\n        let mut keys_vec: Vec<_> = new_keys.collect();\n        keys_vec.sort_unstable();\n        assert_eq!(keys_vec, vec![&1, &2, &3]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582020, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=160, prompt_tokens=10487, total_tokens=10647, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLqJCcSXDHVxDryosSHqsZGZy16', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_map_key() {\n        let mut map: HashMap<&\'static str, u8> = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n        map.insert("key3", 3);\n\n        let new_map: HashMap<&str, u8> = map_key(map);\n\n        assert_eq!(new_map.get("key1"), Some(&1));\n        assert_eq!(new_map.get("key2"), Some(&2));\n        assert_eq!(new_map.get("key3"), Some(&3));\n    }\n\n    #[test]\n    fn test_map_key_empty() {\n        let map: HashMap<&\'static str, u8> = HashMap::new();\n        let new_map: HashMap<&str, u8> = map_key(map);\n        \n        assert!(new_map.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582026, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=212, prompt_tokens=16361, total_tokens=16573, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmLxMtTVGnhTyueHkTl5jSnIqLTv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_map_val() {\n        let mut map: HashMap<u8, &\'static str> = HashMap::new();\n        map.insert(1, "one");\n        map.insert(2, "two");\n        \n        let new_map: HashMap<u8, &str> = map_val(map);\n        \n        assert_eq!(new_map.len(), 2);\n        assert_eq!(new_map[&1], "one");\n        assert_eq!(new_map[&2], "two");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582033, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=132, prompt_tokens=16361, total_tokens=16493, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmM5vl9MwiMTYQZoTxKasJzIU1Gm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_key() {\n        let mut map: HashMap<&\'static str, u8> = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n\n        let values = map.values();\n        let result = values_key(values);\n\n        let mut result_vec: Vec<&str> = result.collect();\n        result_vec.sort_unstable(); // sorting for comparison\n\n        assert_eq!(result_vec, vec!["a", "b", "c"]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582041, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=144, prompt_tokens=10488, total_tokens=10632, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMB2oBWfJ7qoSIm2i3kgPd6lDjJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_values_val() {\n        let mut map: HashMap<u8, &\'static str> = HashMap::new();\n        map.insert(1, "one");\n        map.insert(2, "two");\n        map.insert(3, "three");\n\n        let values: Values<u8, &\'static str> = map.values();\n        let new_values: Values<u8, &\'static str> = values_val(values);\n\n        let mut result: Vec<&str> = new_values.collect();\n        result.sort_unstable();\n        assert_eq!(result, vec!["one", "three", "two"]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582047, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=155, prompt_tokens=10488, total_tokens=10643, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMI8BqIntEbni71BJh0AvsOIUbX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    struct KeyWrapper {\n        value: i32,\n    }\n\n    impl KeyWrapper {\n        fn new(value: i32) -> Self {\n            KeyWrapper { value }\n        }\n    }\n\n    struct KeyEqual {\n        value: i32,\n    }\n\n    impl KeyEqual {\n        fn new(value: i32) -> Self {\n            KeyEqual { value }\n        }\n    }\n\n    impl Equivalent<KeyWrapper> for KeyEqual {\n        fn equivalent(&self, other: &KeyWrapper) -> bool {\n            self.value == other.value\n        }\n    }\n\n    #[test]\n    fn test_equivalent() {\n        let key_equal = KeyEqual::new(42);\n        let equivalent_fn = equivalent(&key_equal);\n\n        let key_wrapper_equal = KeyWrapper::new(42);\n        let key_wrapper_unequal = KeyWrapper::new(10);\n        \n        assert!(equivalent_fn(&key_wrapper_equal));\n        assert!(!equivalent_fn(&key_wrapper_unequal));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582054, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=227, prompt_tokens=217, total_tokens=444, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMSWtf7ZRPicKMPlr7q9kj8KKdR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::raw::Equivalent;\n\n    struct TestKey {\n        value: String,\n    }\n\n    impl Equivalent<TestKey> for TestKey {\n        fn equivalent(&self, other: &TestKey) -> bool {\n            self.value == other.value\n        }\n    }\n\n    #[test]\n    fn test_equivalent_key() {\n        let key1 = TestKey { value: String::from("test") };\n        let key2 = TestKey { value: String::from("test") };\n        let key3 = TestKey { value: String::from("different") };\n        \n        let equivalent_fn = equivalent_key(&key1);\n        \n        assert!(equivalent_fn(&(key2, ())));\n        assert!(!equivalent_fn(&(key3, ())));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582064, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=176, prompt_tokens=222, total_tokens=398, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMYTL2yeuYKCuRW0GPgfh4dkSUr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_make_hash() {\n        let hash_builder = DefaultHasher::new();\n        let value = "test_string";\n\n        let hash1 = make_hash(&hash_builder, value);\n        let hash2 = make_hash(&hash_builder, value);\n\n        assert_eq!(hash1, hash2, "Hashes should be equal for the same input");\n    }\n\n    #[test]\n    fn test_make_hash_different_values() {\n        let hash_builder = DefaultHasher::new();\n        \n        let hash1 = make_hash(&hash_builder, "test_string1");\n        let hash2 = make_hash(&hash_builder, "test_string2");\n\n        assert_ne!(hash1, hash2, "Hashes should be different for different inputs");\n    }\n\n    #[test]\n    fn test_make_hash_empty_string() {\n        let hash_builder = DefaultHasher::new();\n        \n        let hash = make_hash(&hash_builder, "");\n\n        assert!(hash != 0, "Hash of an empty string should not be zero");\n    }\n\n    #[test]\n    fn test_make_hash_string_slice() {\n        let hash_builder = DefaultHasher::new();\n        let value: &str = "slice_string";\n\n        let hash = make_hash(&hash_builder, value);\n\n        assert!(hash != 0, "Hash of the string slice should not be zero");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582070, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=325, prompt_tokens=210, total_tokens=535, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMgJKbMoSb9Ynrctfvshm0CGQGS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::hash::{Hash, Hasher};\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::BuildHasher;\n\n    struct TestHasher;\n\n    impl BuildHasher for TestHasher {\n        type Hasher = DefaultHasher;\n\n        fn build_hasher(&self) -> Self::Hasher {\n            DefaultHasher::new()\n        }\n    }\n\n    #[test]\n    fn test_make_hasher() {\n        let hasher_builder = TestHasher;\n        let hasher = make_hasher::<String, usize, TestHasher>(&hasher_builder);\n\n        let value = ("test".to_string(), 42);\n        let hash_one = hasher(&value);\n        let hash_two = hasher(&value);\n        \n        assert_eq!(hash_one, hash_two);\n    }\n\n    #[test]\n    fn test_make_hasher_different_input() {\n        let hasher_builder = TestHasher;\n        let hasher = make_hasher::<String, usize, TestHasher>(&hasher_builder);\n\n        let value_one = ("test".to_string(), 42);\n        let value_two = ("different".to_string(), 100);\n        \n        let hash_one = hasher(&value_one);\n        let hash_two = hasher(&value_two);\n        \n        assert_ne!(hash_one, hash_two);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582078, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=287, prompt_tokens=232, total_tokens=519, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmModqOiwPjZwMdzrp5qRtDZ0yIe', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_as_mut() {\n        let mut value: i32 = 42;\n        let value_ptr = &mut value as *mut _;\n\n        let bucket = Bucket {\n            ptr: NonNull::new(value_ptr).unwrap(),\n        };\n\n        unsafe {\n            let mut_ref = bucket.as_mut();\n            *mut_ref = 100; // Modify the inner value\n        }\n\n        assert_eq!(value, 100);\n    }\n\n    #[test]\n    fn test_as_mut_zero_sized_type() {\n        #[derive(Debug)]\n        struct Zst;\n\n        let mut value = Zst;\n        let value_ptr = &mut value as *mut _;\n\n        let bucket = Bucket {\n            ptr: NonNull::new(value_ptr).unwrap(),\n        };\n\n        unsafe {\n            bucket.as_mut(); // Should not panic or cause an issue\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582086, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=206, prompt_tokens=4742, total_tokens=4948, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmMyeEu9ESBtQUx6fUkB94ynz1bw', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_as_non_null() {\n        let value = 42;\n        let ptr = NonNull::new(&value as *const _ as *mut _).unwrap();\n        let bucket = Bucket { ptr };\n\n        // Testing as_non_null returns a NonNull pointer\n        let non_null_ptr = bucket.as_non_null();\n        assert!(!non_null_ptr.as_ptr().is_null());\n        assert_eq!(unsafe { *non_null_ptr.as_ptr() }, 42);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582096, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=128, prompt_tokens=4610, total_tokens=4738, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmN7a2CQhE7vxGh3Oey7p0WYNaOS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_as_ptr_non_zst() {\n        struct NonZST {\n            value: i32,\n        }\n\n        let value = NonZST { value: 42 };\n        let bucket = Bucket {\n            ptr: NonNull::new(&value as *const _ as *mut _).unwrap(),\n        };\n\n        // Pointer obtained should be one less than the ptr\n        let ptr = bucket.as_ptr();\n        assert_eq!(ptr, (bucket.ptr.as_ptr() as usize - 1) as *mut NonZST);\n    }\n\n    #[test]\n    fn test_as_ptr_zst() {\n        struct ZST;\n\n        let bucket = Bucket {\n            ptr: NonNull::new(1 as *mut ZST).unwrap(),\n        };\n\n        // Pointer obtained should be an invalid pointer (alignment for ZST)\n        let ptr = bucket.as_ptr();\n        assert_eq!(ptr as usize, std::mem::align_of::<ZST>());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582105, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=227, prompt_tokens=4905, total_tokens=5132, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNEbaFbEk1zOVI1gNZ9cgP3uuSS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_as_ref() {\n        // Setup\n        let value = 42;\n        let bucket = Bucket {\n            ptr: NonNull::new(&value as *const _ as *mut _).unwrap(),\n        };\n\n        // Unsafe block is required to call as_ref\n        unsafe {\n            // Test that as_ref returns a reference to the original value\n            let ref_value: &i32 = bucket.as_ref();\n            assert_eq!(*ref_value, value);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582112, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=130, prompt_tokens=4627, total_tokens=4757, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNJ2o8uILbu5X7ePOUydJ2lxAZG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    struct TestData {\n        value: i32,\n    }\n\n    #[test]\n    fn test_drop() {\n        let val = Box::new(TestData { value: 42 });\n        let ptr = NonNull::new(Box::into_raw(val)).expect("Non-null pointer expected");\n        let bucket = Bucket { ptr };\n\n        unsafe {\n            bucket.drop(); // Drop should work without any panic\n        }\n\n        // Ensure that the memory is effectively cleaned up\n        // (this may not always be verifiable without a memory leak detector,\n        // but here we assume normal operation if no panic occurs)\n    }\n\n    #[test]\n    fn test_drop_with_zero_sized_type() {\n        let ptr = NonNull::new(Box::into_raw(Box::new([]))).expect("Non-null pointer expected");\n        let bucket = Bucket { ptr };\n\n        unsafe {\n            bucket.drop(); // Drop should work without any panic\n        }\n\n        // No assertions here, we assume the drop of a ZST has no issues\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582117, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=235, prompt_tokens=4724, total_tokens=4959, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNRi9c0dmV10T3VXCMKTCULpYFg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    struct TestData {\n        value: i32,\n    }\n\n    #[test]\n    fn test_from_base_index_non_zst() {\n        let test_value = TestData { value: 42 };\n        let base = &test_value as *const _ as *mut TestData;\n        let base_non_null = NonNull::new(base).unwrap();\n        \n        let bucket = unsafe { Bucket::<TestData>::from_base_index(base_non_null, 0) };\n        let ptr = bucket.as_ptr();\n        \n        assert_eq!(ptr, base_non_null.as_ptr());\n    }\n\n    #[test]\n    fn test_from_base_index_zst() {\n        struct Zst;\n        let index = 2;\n        let base = 0 as *mut Zst;\n        let base_non_null = NonNull::new(base).unwrap();\n\n        let bucket = unsafe { Bucket::<Zst>::from_base_index(base_non_null, index) };\n        \n        assert_eq!(bucket.ptr.as_ptr() as usize, (index + 1) as usize);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_from_base_index_out_of_bounds() {\n        let test_value = TestData { value: 42 };\n        let base = &test_value as *const _ as *mut TestData;\n        let base_non_null = NonNull::new(base).unwrap();\n\n        unsafe {\n            Bucket::<TestData>::from_base_index(base_non_null, usize::MAX);\n        }\n    }\n\n    #[test]\n    fn test_from_base_index_with_non_null() {\n        let test_value = TestData { value: 42 };\n        let base = &test_value as *const _ as *mut TestData;\n        let base_non_null = NonNull::new(base).unwrap();\n\n        let bucket = unsafe { Bucket::<TestData>::from_base_index(base_non_null, 1) };\n        let ptr = bucket.as_ptr();\n        \n        assert_eq!(ptr, base_non_null.as_ptr().sub(1));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582125, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=437, prompt_tokens=5594, total_tokens=6031, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNdRrCt0jPek4pNHzpGEzlFpRoK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_next_n_non_zst() {\n        unsafe {\n            let value = Box::new(42); // Non-ZST\n            let base_ptr = NonNull::new(value.as_mut() as *mut _).unwrap();\n            let bucket = Bucket::from_base_index(base_ptr, 0);\n            let next_bucket = bucket.next_n(1);\n            assert_eq!(next_bucket.as_ptr(), bucket.as_ptr().sub(1));\n        }\n    }\n\n    #[test]\n    fn test_next_n_zst() {\n        #[repr(C)]\n        struct ZST; // Zero-Sized Type\n        unsafe {\n            let base_ptr = NonNull::new(&ZST as *const _ as *mut _).unwrap();\n            let bucket = Bucket::from_base_index(base_ptr, 0);\n            let next_bucket = bucket.next_n(1);\n            assert_eq!(next_bucket.as_ptr() as usize, bucket.as_ptr() as usize + 1);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_next_n_out_of_bounds() {\n        unsafe {\n            let value = Box::new(42);\n            let base_ptr = NonNull::new(value.as_mut() as *mut _).unwrap();\n            let bucket = Bucket::from_base_index(base_ptr, 0);\n            let _next_bucket = bucket.next_n(usize::MAX); // should panic\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582137, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=321, prompt_tokens=5182, total_tokens=5503, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNreuekeF07Um7fb3jvLYTU7YFa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_read() {\n        // Creating a test structure\n        #[derive(Debug, PartialEq)]\n        struct TestStruct {\n            value: i32,\n        }\n\n        // Create an instance of TestStruct\n        let test_value = TestStruct { value: 42 };\n\n        // Create a NonNull pointer to the test value\n        let non_null_ptr = NonNull::new(Box::into_raw(Box::new(test_value))).unwrap();\n\n        // Create a Bucket instance\n        let bucket = Bucket { ptr: non_null_ptr };\n\n        // Safety block for unsafe read\n        unsafe {\n            let result = bucket.read();\n            assert_eq!(result, TestStruct { value: 42 });\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582151, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=174, prompt_tokens=4727, total_tokens=4901, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmNyaYfeH9mgRTpmul5UAat9X0Wn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_to_base_index_non_zero_sized() {\n        struct TestType {\n            value: u32,\n        }\n\n        let base_ptr = Box::into_raw(Box::new(TestType { value: 0 })) as *mut TestType;\n        let base_non_null = NonNull::new(base_ptr).unwrap();\n\n        let bucket = unsafe { Bucket::from_base_index(base_non_null, 1) };\n        let index = unsafe { bucket.to_base_index(base_non_null) };\n\n        assert_eq!(index, 1);\n    }\n\n    #[test]\n    fn test_to_base_index_zero_sized() {\n        struct ZeroSized;\n\n        let base_ptr = Box::into_raw(Box::new(ZeroSized)) as *mut ZeroSized;\n        let base_non_null = NonNull::new(base_ptr).unwrap();\n\n        let bucket = unsafe { Bucket::from_base_index(base_non_null, 1) };\n        let index = unsafe { bucket.to_base_index(base_non_null) };\n\n        assert_eq!(index, 0);\n    }\n\n    #[test]\n    fn test_to_base_index_multiple_elements() {\n        struct TestType {\n            value: u32,\n        }\n\n        let base_ptr = Box::into_raw(Box::new(TestType { value: 0 })) as *mut TestType;\n        let base_non_null = NonNull::new(base_ptr).unwrap();\n\n        let bucket0 = unsafe { Bucket::from_base_index(base_non_null, 0) };\n        let bucket1 = unsafe { Bucket::from_base_index(base_non_null, 1) };\n\n        let index0 = unsafe { bucket0.to_base_index(base_non_null) };\n        let index1 = unsafe { bucket1.to_base_index(base_non_null) };\n\n        assert_eq!(index0, 0);\n        assert_eq!(index1, 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582158, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=406, prompt_tokens=5459, total_tokens=5865, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmO7cc3qgNXpvF8IpTS5JMIUgyE4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_write() {\n        let value = Box::new(42);\n        let ptr = NonNull::new(Box::into_raw(value)).unwrap();\n        let bucket = Bucket { ptr };\n\n        unsafe {\n            bucket.write(100);\n            let result = bucket.read();\n            assert_eq!(result, 100);\n        }\n    }\n\n    #[test]\n    fn test_write_zero_sized() {\n        #[repr(align(1))]\n        struct ZST;\n\n        let ptr = NonNull::new(Box::into_raw(Box::new(ZST))).unwrap();\n        let bucket = Bucket { ptr };\n\n        unsafe {\n            bucket.write(ZST);\n            // Does not crash, just checks if write and read functions work.\n            let result = bucket.read();\n            // ZST reads back to a no-op value\n            assert_eq!(std::mem::size_of_val(&result), 0);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582167, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=216, prompt_tokens=4747, total_tokens=4963, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmOE4x3CYkVynwZRsRKOnT43PiGo', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Layout;\n    \n    #[test]\n    fn test_alloc_err_fallible() {\n        let layout = Layout::from_size_align(1, 1).unwrap();\n        let fallible = Fallibility::Fallible;\n        let error = fallible.alloc_err(layout);\n        \n        match error {\n            TryReserveError::AllocError { layout: err_layout } => {\n                assert_eq!(layout, err_layout);\n            },\n            _ => panic!("Expected AllocError"),\n        }\n    }\n\n    #[test]\n    #[should_panic(expected = "handle_alloc_error")]\n    fn test_alloc_err_infallible() {\n        let layout = Layout::from_size_align(1, 1).unwrap();\n        let infallible = Fallibility::Infallible;\n        infallible.alloc_err(layout);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582174, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=187, prompt_tokens=565, total_tokens=752, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmOMnT0IfHXsf8sCRYmni0iG6MeJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::raw::Fallibility;\n    use super::TryReserveError;\n\n    #[test]\n    fn test_capacity_overflow_fallible() {\n        let fallibility = Fallibility::Fallible;\n        let error = fallibility.capacity_overflow();\n        match error {\n            TryReserveError::CapacityOverflow => {},\n            _ => panic!("Expected CapacityOverflow error"),\n        }\n    }\n\n    #[test]\n    #[should_panic(expected = "Hash table capacity overflow")]\n    fn test_capacity_overflow_infallible() {\n        let fallibility = Fallibility::Infallible;\n        let _ = fallibility.capacity_overflow();\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582182, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=144, prompt_tokens=564, total_tokens=708, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmOSMUnI9cbsEGu4QvF0aZen3kev', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_next_impl() {\n        unsafe {\n            // Setup raw table and FullBucketsIndices\n            let bit_mask = BitMask(0b00001111); // Example bit mask with 4 set bits\n            let bit_mask_iter = BitMaskIter(bit_mask);\n            let control_bytes = vec![0u8; 8]; // Example control bytes\n            let group_first_index = 0; // Starting index\n            let control_ptr = NonNull::new(control_bytes.as_ptr() as *mut u8).unwrap();\n            let mut indices = FullBucketsIndices {\n                current_group: bit_mask_iter,\n                group_first_index,\n                ctrl: control_ptr,\n                items: 4,\n            };\n\n            // Call next_impl and validate results\n            let results: Vec<_> = (0..4).map(|_| indices.next()).collect();\n            let expected: Vec<_> = vec![0, 1, 2, 3]; // Expected index results\n            assert_eq!(results, expected);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582188, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=243, prompt_tokens=3005, total_tokens=3248, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmOc9Cfz53bY2T9QMw2EdDake2FW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::ProbeSeq;\n\n    #[test]\n    fn test_move_next() {\n        let mut probe_seq = ProbeSeq { pos: 0, stride: 0 };\n        let bucket_mask = 0b111; // Example bucket mask for a table size of 8\n\n        // Move next and assert the expected values\n        probe_seq.move_next(bucket_mask);\n        assert!(probe_seq.pos <= bucket_mask, "Position should be within bucket mask");\n        assert_eq!(probe_seq.stride, Group::WIDTH, "Stride should be incremented by Group::WIDTH");\n        \n        // Move next again and check the updated state\n        probe_seq.move_next(bucket_mask);\n        assert!(probe_seq.pos <= bucket_mask, "Position should be within bucket mask");\n        assert_eq!(probe_seq.stride, 2 * Group::WIDTH, "Stride should be incremented again by Group::WIDTH");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582198, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=205, prompt_tokens=486, total_tokens=691, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmOi1kFu0fqlTiZblolcw00jrdFe', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Global;\n    \n    #[test]\n    fn test_raw_drain_iter() {\n        // Create a test instance of RawTableInner\n        let alloc = Global;\n        let mut table = unsafe {\n            RawTableInner::new_uninitialized(&alloc, TableLayout::default(), 16, Fallibility::Infallible).unwrap()\n        };\n\n        // Assume we insert some values into the table here...\n\n        // Create a RawDrain instance\n        let raw_drain = RawDrain {\n            iter: table.iter(),\n            table,\n            orig_table: NonNull::new(&mut table).unwrap(),\n            marker: PhantomData,\n        };\n\n        // Obtain an iterator from RawDrain\n        let iter = raw_drain.iter();\n\n        // Check if the iterator can be cloned\n        let cloned_iter = iter.clone();\n\n        // Check that the cloned iterator is not equal to the original\n        assert!(iter.clone() != cloned_iter);\n\n        // Verify that using the iterator produces the expected results\n        let collected: Vec<_> = iter.collect();\n        assert_eq!(collected.len(), expected_len); // Replace `expected_len` with the expected length\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582204, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=259, prompt_tokens=16361, total_tokens=16620, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmOrvqQ4ydn7kBphpvlBKtBIFwzT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    struct TestItem {\n        value: i32,\n    }\n\n    #[test]\n    fn test_next_with_matching_item() {\n        let mut table: RawTable<TestItem, System> = RawTable::new_in(System);\n        let item1 = TestItem { value: 1 };\n        let item2 = TestItem { value: 2 };\n        \n        // Insert items into the raw table\n        let bucket1 = table.insert(1, item1, |item| item.value as u64);\n        let bucket2 = table.insert(2, item2, |item| item.value as u64);\n\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n\n        let result = extractor.next(|item| item.value == 1);\n        assert_eq!(result.map(|item| item.value), Some(1));\n        assert_eq!(table.len(), 1);  // One item should be removed\n    }\n\n    #[test]\n    fn test_next_with_no_matching_item() {\n        let mut table: RawTable<TestItem, System> = RawTable::new_in(System);\n        let item1 = TestItem { value: 1 };\n\n        // Insert an item into the raw table\n        let bucket1 = table.insert(1, item1, |item| item.value as u64);\n\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n\n        let result = extractor.next(|item| item.value == 2);\n        assert_eq!(result, None);  // No item should be removed\n        assert_eq!(table.len(), 1);  // Item count should remain the same\n    }\n\n    #[test]\n    fn test_next_with_multiple_matching_items() {\n        let mut table: RawTable<TestItem, System> = RawTable::new_in(System);\n        let item1 = TestItem { value: 1 };\n        let item2 = TestItem { value: 2 };\n        let item3 = TestItem { value: 3 };\n\n        // Insert items into the raw table\n        let bucket1 = table.insert(1, item1, |item| item.value as u64);\n        let bucket2 = table.insert(2, item2, |item| item.value as u64);\n        let bucket3 = table.insert(3, item3, |item| item.value as u64);\n\n        let mut extractor = RawExtractIf {\n            iter: table.iter(),\n            table: &mut table,\n        };\n\n        // First matching item\n        let result1 = extractor.next(|item| item.value == 1);\n        assert_eq!(result1.map(|item| item.value), Some(1));\n        \n        // Second matching item\n        let result2 = extractor.next(|item| item.value == 2);\n        assert_eq!(result2.map(|item| item.value), Some(2));\n        \n        assert_eq!(table.len(), 1);  // One item should remain\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582213, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=651, prompt_tokens=16361, total_tokens=17012, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPFGq39So5kQvB7pH9ZA92QmK0I', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_raw_into_iter_iter() {\n        let alloc = System; // Using the global allocator\n        let mut raw_into_iter: RawIntoIter<i32, System> = RawIntoIter::default();\n\n        // Creating some dummy test data\n        let data = vec![1, 2, 3, 4, 5];\n        raw_into_iter.iter = RawIter {\n            iter: RawIterRange::new(\n                std::ptr::null(),\n                Bucket::from_base_index(unsafe { NonNull::new_unchecked(data.as_ptr() as *mut i32) }, data.len()),\n                data.len(),\n            ),\n            items: data.len(),\n        };\n\n        let raw_iter = raw_into_iter.iter();\n\n        // Ensure cloned iterator has the same number of items\n        assert_eq!(raw_iter.items, raw_into_iter.iter.items);\n\n        // Ensure iter can be consumed\n        let mut collected: Vec<i32> = raw_iter.collect();\n        assert_eq!(collected, data);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582237, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=236, prompt_tokens=9399, total_tokens=9635, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPOFBx5AjLutewnkDWWdS1fVhBP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    struct MockItem {\n        dropped: bool,\n    }\n\n    impl MockItem {\n        fn new() -> Self {\n            MockItem { dropped: false }\n        }\n        unsafe fn drop(&mut self) {\n            self.dropped = true;\n        }\n    }\n\n    #[test]\n    fn test_drop_elements() {\n        unsafe {\n            let mut items = Vec::new();\n            for _ in 0..3 {\n                items.push(Box::new(MockItem::new()));\n            }\n\n            let mut raw_iter: RawIter<MockItem> = RawIter {\n                iter: RawIterRange::new(std::ptr::null(), Bucket::from_base_index(NonNull::new_unchecked(items.as_mut_ptr()), items.len()), items.len()), // Mock RawIterRange\n                items: items.len(),\n            };\n\n            raw_iter.drop_elements();\n            for item in items {\n                assert!(item.dropped);\n            }\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582246, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=216, prompt_tokens=8893, total_tokens=9109, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPWTrlWrM0KhWxHlZXGkwMSehLi', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_iter_hash_new() {\n        unsafe {\n            let table = RawTable::<u8, Global>::new_in(Global);\n            let hash = 12345;\n\n            let iter = RawIterHash::<u8>::new(&table, hash);\n            assert!(iter.inner.tag_hash == Tag::full(hash));\n            assert!(iter.inner.bucket_mask == table.table.bucket_mask);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582254, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=111, prompt_tokens=16361, total_tokens=16472, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPccfJ3bK0d0uKdWlvyTgDcMIBZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_hash_inner_new() {\n        // Prepare test data for RawTableInner\n        let mock_bucket_mask = 0b111; // Example bucket mask\n        let mock_ctrl = NonNull::new(Box::into_raw(Box::new([Tag::EMPTY; 4][..])) as *mut _).unwrap();\n        let raw_table_inner = RawTableInner {\n            bucket_mask: mock_bucket_mask,\n            ctrl: mock_ctrl,\n            growth_left: 10,\n            items: 0,\n        };\n\n        let test_hash = 0b0000_0001; // Example hash\n\n        unsafe {\n            let iter = RawIterHashInner::new(&raw_table_inner, test_hash);\n            assert_eq!(iter.bucket_mask, mock_bucket_mask);\n            assert_eq!(iter.tag_hash, Tag::full(test_hash));\n            assert_eq!(iter.probe_seq.pos, raw_table_inner.probe_seq(test_hash).pos);\n            assert_eq!(iter.ctrl, mock_ctrl);\n\n            // Check if the group is loaded correctly\n            let group = Group::load(raw_table_inner.ctrl.as_ptr().cast());\n            assert_eq!(iter.group, group);\n\n            // Check if the bitmask is correctly initialized\n            let bitmask = group.match_tag(Tag::full(test_hash)).into_iter();\n            assert_eq!(iter.bitmask.next().is_some(), bitmask.next().is_some());\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582260, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=319, prompt_tokens=16361, total_tokens=16680, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPjn5zcR2knxinEAE18XhwLb60Q', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_fold_impl() {\n        struct TestStruct {\n            value: i32,\n        }\n\n        unsafe {\n            // Create an instance of RawIterRange\n            let data: Vec<Bucket<TestStruct>> = (0..5)\n                .map(|x| {\n                    let val = TestStruct { value: x };\n                    let ptr = NonNull::new_unchecked(Box::into_raw(Box::new(val)));\n                    Bucket { ptr }\n                })\n                .collect();\n                \n            let control_ptr: *const u8 = std::ptr::null(); // Stub pointer for control\n            let raw_iter_range = RawIterRange::new(control_ptr, data[0].clone(), data.len());\n\n            // Closure to sum the values\n            let sum = raw_iter_range.fold_impl(data.len(), 0, |acc, bucket| {\n                unsafe { acc + (*bucket.as_ref()).value }\n            });\n\n            // Assert the sum of values (0 + 1 + 2 + 3 + 4 = 10)\n            assert_eq!(sum, 10);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582267, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=253, prompt_tokens=9027, total_tokens=9280, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmPvoJerrzdoc0FHJgWqANYjXYb6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_iter_range_new() {\n        unsafe {\n            // Create a mock control pointer, using a buffer aligned to Group::WIDTH\n            let control_buffer = vec![0u8; 32]; // Assuming Group::WIDTH is 32\n            let ctrl = control_buffer.as_ptr();\n            let bucket = Bucket::from_base_index(\n                NonNull::from(&control_buffer[0] as *const _ as *mut _),\n                0\n            ); // Create a Bucket pointing to the first element\n\n            // Test with a valid length\n            let len = 8; // Must be a power of two and valid\n            let iter_range = RawIterRange::new(ctrl, bucket, len);\n\n            // Assertions\n            assert_eq!(iter_range.data.to_base_index(NonNull::from(&control_buffer[0] as *const _ as *mut _)), 0);\n            assert!(iter_range.current_group.any_bit_set());\n            assert!(iter_range.end as usize > ctrl as usize);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_raw_iter_range_new_zero_length() {\n        unsafe {\n            let control_buffer = vec![0u8; 32];\n            let ctrl = control_buffer.as_ptr();\n            let bucket = Bucket::from_base_index(\n                NonNull::from(&control_buffer[0] as *const _ as *mut _),\n                0\n            );\n\n            // Attempt to create with a zero length\n            let _ = RawIterRange::new(ctrl, bucket, 0);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_raw_iter_range_new_invalid_length() {\n        unsafe {\n            let control_buffer = vec![0u8; 32];\n            let ctrl = control_buffer.as_ptr();\n            let bucket = Bucket::from_base_index(\n                NonNull::from(&control_buffer[0] as *const _ as *mut _),\n                0\n            );\n\n            // Attempt to create with an invalid length (not a power of 2)\n            let _ = RawIterRange::new(ctrl, bucket, 5);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582279, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=475, prompt_tokens=8599, total_tokens=9074, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQADX1NBxIULFUAGUX7QDC4ijr5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Make sure to import the necessary items from the module\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_next_impl() {\n        // Define the necessary setup to test `next_impl`\n        let bucket_data: Vec<u32> = vec![1, 2, 3, 4];\n        let bucket_ptr = NonNull::new(bucket_data.as_ptr() as *mut u32).unwrap();\n        let bucket = unsafe { Bucket::from_base_index(bucket_ptr, 0) };\n        \n        // Assume that we have a valid control pointer, aligned properly.\n        let control_ptr = bucket_ptr.as_ptr() as *const u8;\n\n        // Create a RawIterRange for testing, ensuring valid parameters.\n        let mut iter_range: RawIterRange<u32> = unsafe { RawIterRange::new(control_ptr, bucket, 4) };\n\n        // Verify the elements are iterated correctly\n        let mut results = Vec::new();\n        while let Some(bucket) = iter_range.next() {\n            unsafe {\n                results.push(*bucket.as_ref());\n            }\n        }\n        \n        // Check that we got the expected results\n        assert_eq!(results, vec![1, 2, 3, 4]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582294, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=276, prompt_tokens=8408, total_tokens=8684, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQKAc0VFcUTXivzk1WI0c7migyx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_allocation_size_empty_table() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        assert_eq!(table.allocation_size(), 0);\n    }\n\n    #[test]\n    fn test_allocation_size_with_capacity() {\n        let capacity = 8; // power of two\n        let table: RawTable<i32, Global> = RawTable::with_capacity(capacity);\n        assert!(table.allocation_size() > 0);\n    }\n\n    #[test]\n    fn test_allocation_size_after_inserts() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(8);\n        for i in 0..4 {\n            // This assumes that RawTable has an `insert` method.\n            table.insert(i as u64, i, |x| *x);\n        }\n        let size_after_inserts = table.allocation_size();\n        assert!(size_after_inserts > 0);\n    }\n\n    #[test]\n    fn test_allocation_size_with_no_allocations() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        assert_eq!(table.allocation_size(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582304, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=278, prompt_tokens=16361, total_tokens=16639, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQqpNleduNSMb7Y4wuZS67UX2jQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_allocator() {\n        let alloc = Global;\n        let table: RawTable<i32, Global> = RawTable::new_in(alloc);\n        let allocated = table.allocator();\n        assert_eq!(allocated as *const _, &Global as *const _);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582336, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=86, prompt_tokens=16361, total_tokens=16447, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmQw7tYqcp8q60BuepEDvZ1SqxeO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_bucket() {\n        // Setup: Create a RawTable and add a dummy value\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash = 42;\n\n        unsafe {\n            table.insert(hash, 10, |x| x.clone());\n            table.insert(hash, 20, |x| x.clone());\n            let bucket = table.bucket(1); // Access the second bucket (index 1)\n\n            // Validate the bucket's index\n            let bucket_index = table.bucket_index(&bucket);\n            assert_eq!(bucket_index, 1);\n\n            // Access the value\n            assert_eq!(bucket.as_ref(), &20);\n        }\n    }\n\n    #[test]\n    fn test_bucket_out_of_bounds() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        unsafe {\n            // This call should not panic, but the underlying table must be uninitialized\n            // Guarantee it matches the expected behavior for the given index\n            let bucket = table.bucket(0);\n            assert_eq!(bucket.as_ref(), &0); // since no element is inserted\n        }\n    }\n\n    #[test]\n    fn test_bucket_with_index_too_large() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        unsafe {\n            // Validate behavior with an index greater than the bucket count\n            let index = table.buckets(); // Current bucket count\n            let result = std::panic::catch_unwind(|| {\n                table.bucket(index); // Access the bucket at the index\n            });\n            assert!(result.is_err());\n        }\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582342, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=367, prompt_tokens=16361, total_tokens=16728, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmR4GRRrEKvr6i40e5UrfCdpZwDF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_bucket_index() {\n        // Setup\n        let mut raw_table: RawTable<i32, Global> = RawTable::new();\n        let bucket = unsafe { raw_table.bucket(0) }; // Assuming we have at least one bucket\n        unsafe {\n            // Assuming this bucket is in the table's data\n            let index = raw_table.bucket_index(&bucket);\n            assert_eq!(index, 0); // Since we are using the first bucket\n        }\n\n        // Fill the table\n        // Here we would normally add elements to the raw_table to ensure it has\n        // elements and that the bucket is not just an empty one.\n\n        // Setup to add an element\n        // raw_table.insert(....); // Insert actual test data\n\n        // Check the bucket index again\n        // Assuming the bucket we are now testing is the first one again and the table has data\n        unsafe {\n            let bucket = raw_table.bucket(0);\n            let index = raw_table.bucket_index(&bucket);\n            assert_eq!(index, 0); // Ensure the bucket index is correct\n        }\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582350, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=267, prompt_tokens=16361, total_tokens=16628, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRD0EKAEbjqtSL0Vuxl7KiwnaGC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\nuse hashbrown::raw::{RawTable, RawTableInner};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_buckets() {\n        // Test case 1: Default RawTable has 1 bucket\n        let table: RawTable<i32> = RawTable::new();\n        assert_eq!(table.buckets(), 1);\n\n        // Test case 2: RawTable with 1 capacity should have 1 bucket\n        let table: RawTable<i32> = RawTable::with_capacity(1);\n        assert_eq!(table.buckets(), 1);\n\n        // Test case 3: RawTable with 2 capacity, should have 2 buckets\n        let table: RawTable<i32> = RawTable::with_capacity(2);\n        assert_eq!(table.buckets(), 2);\n\n        // Test case 4: RawTable with 4 capacity should have 4 buckets\n        let table: RawTable<i32> = RawTable::with_capacity(4);\n        assert_eq!(table.buckets(), 4);\n\n        // Test case 5: RawTable with 8 capacity should have 8 buckets\n        let table: RawTable<i32> = RawTable::with_capacity(8);\n        assert_eq!(table.buckets(), 8);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582359, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=276, prompt_tokens=16361, total_tokens=16637, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRMmENU8DymGJ6WEgzv6TtkLM8l', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_capacity_empty() {\n        let table: RawTable<u32, Global> = RawTable::new();\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_single() {\n        let mut table = RawTable::with_capacity(1);\n        assert_eq!(table.capacity(), 1);\n        table.insert(0, 42, |x| x);\n        assert_eq!(table.capacity(), 1);\n    }\n\n    #[test]\n    fn test_capacity_multiple() {\n        let mut table = RawTable::with_capacity(4);\n        assert_eq!(table.capacity(), 4);\n        for i in 0..4 {\n            table.insert(i as u64, i, |x| x);\n        }\n        assert_eq!(table.capacity(), 4);\n    }\n\n    #[test]\n    fn test_capacity_growth() {\n        let mut table = RawTable::with_capacity(2);\n        assert_eq!(table.capacity(), 2);\n        table.insert(0, 1, |x| x);\n        table.insert(1, 2, |x| x);\n        table.insert(2, 3, |x| x); // Should trigger growth\n        assert!(table.capacity() > 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582368, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=289, prompt_tokens=16361, total_tokens=16650, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRVloaGa02B3YeP090cnVxa6PsQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    \n    #[test]\n    fn test_clear() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(5);\n        \n        // Inserting some elements\n        for i in 1..=5 {\n            table.insert(i as u64, i, |&x| x);\n        }\n        \n        // Ensure the table is not empty before clear\n        assert!(!table.is_empty());\n        assert_eq!(table.len(), 5);\n        \n        // Clear the table\n        table.clear();\n        \n        // Check that the table is empty after clear\n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n    }\n    \n    #[test]\n    fn test_clear_empty_table() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Ensure the table is empty\n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n        \n        // Clear the empty table (should not panic)\n        table.clear();\n        \n        // Check that the table is still empty\n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582377, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=267, prompt_tokens=16361, total_tokens=16628, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRh9qV9z6Lzmb81NOTRgQiTeDGu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clear_no_drop() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        \n        // Insert elements into the table\n        unsafe {\n            table.insert(1, 42, |x| x.hash());\n            table.insert(2, 43, |x| x.hash());\n        }\n\n        // Verify the table is not empty\n        assert!(!table.is_empty());\n        assert_eq!(table.len(), 2);\n\n        // Clear the table without dropping contents\n        table.clear_no_drop();\n\n        // Verify the table is empty, but contents are not dropped\n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n\n        // The contents are still in the table, but we cannot verify\n        // them directly since they are not dropped, and the table\n        // structure is now in an empty state\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582389, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=215, prompt_tokens=16361, total_tokens=16576, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmRpKuP1hGTxadPgeMwILfHvTjZU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clone_from_impl_empty() {\n        let source: RawTable<i32, Global> = RawTable::new();\n        let mut target: RawTable<i32, Global> = RawTable::new();\n        \n        unsafe {\n            target.clone_from_impl(&source);\n        }\n\n        assert_eq!(target.len(), 0);\n        assert_eq!(target.items, source.items);\n    }\n\n    #[test]\n    fn test_clone_from_impl_non_empty() {\n        let mut source: RawTable<i32, Global> = RawTable::with_capacity(4);\n        let mut target: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        unsafe {\n            source.insert(1, 10, |v| *v);\n            source.insert(2, 20, |v| *v);\n            source.insert(3, 30, |v| *v);\n            source.items = 3; // Set items after manual insertion\n            target.clone_from_impl(&source);\n        }\n\n        assert_eq!(target.len(), 3);\n        assert_eq!(target.items, source.items);\n    }\n\n    #[test]\n    fn test_clone_from_impl_with_different_capacity() {\n        let mut source: RawTable<i32, Global> = RawTable::with_capacity(4);\n        let mut target: RawTable<i32, Global> = RawTable::with_capacity(10);\n\n        unsafe {\n            source.insert(1, 10, |v| *v);\n            source.insert(2, 20, |v| *v);\n            source.items = 2; // Set items after manual insertion\n            target.clone_from_impl(&source);\n        }\n\n        assert_eq!(target.len(), 2);\n        assert_eq!(target.items, source.items);\n    }\n\n    #[test]\n    fn test_clone_from_impl_with_drops() {\n        struct DropCounter(i32);\n        impl Drop for DropCounter {\n            fn drop(&mut self) {\n                self.0 += 1;\n            }\n        }\n\n        let mut source: RawTable<DropCounter, Global> = RawTable::with_capacity(4);\n        let mut target: RawTable<DropCounter, Global> = RawTable::new();\n        \n        unsafe {\n            source.insert(1, DropCounter(0), |v| *v);\n            source.items = 1; // Set items after manual insertion\n            target.clone_from_impl(&source);\n        }\n\n        assert_eq!(target.len(), 1);\n        assert_eq!(target.items, source.items);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582397, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=552, prompt_tokens=16361, total_tokens=16913, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmS4oRR3KUmBWI7HasLvITbWoGvL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_data_end() {\n        // Create a new RawTable instance.\n        let table: RawTable<i32> = RawTable::new();\n\n        // Call data_end() and get the result.\n        let data_end_ptr: NonNull<i32> = table.data_end();\n\n        // The result should not be null.\n        assert!(!data_end_ptr.as_ptr().is_null());\n\n        // Since the table is new and has not allocated any elements, we do not know the exact\n        // address it points to, but we do know that it's a valid NonNull pointer.\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582412, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=151, prompt_tokens=16361, total_tokens=16512, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmSJP7JV4WREVaD0EyaOXb9xTPaO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Global;\n\n    #[test]\n    fn test_drain_empty() {\n        let mut table: RawTable<i32, Global> = RawTable::default();\n        let drain_iter = table.drain();\n        let collected: Vec<i32> = drain_iter.collect();\n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_drain_non_empty() {\n        let mut table: RawTable<i32, Global> = RawTable::default();\n        table.insert(0, 10, |x| *x); // Assuming you have a way to insert\n        table.insert(1, 20, |x| *x); // Assuming you have a way to insert\n\n        let drain_iter = table.drain();\n        let collected: Vec<i32> = drain_iter.collect();\n        \n        assert_eq!(collected.len(), 2);\n        assert!(collected.contains(&10));\n        assert!(collected.contains(&20));\n    }\n\n    #[test]\n    fn test_drain_drops_elements() {\n        struct DropCounter {\n            count: std::sync::Arc<std::sync::Mutex<usize>>,\n        }\n\n        impl Drop for DropCounter {\n            fn drop(&mut self) {\n                let mut count = self.count.lock().unwrap();\n                *count += 1;\n            }\n        }\n\n        let count = std::sync::Arc::new(std::sync::Mutex::new(0));\n        let counter_1 = DropCounter { count: count.clone() };\n        let counter_2 = DropCounter { count: count.clone() };\n        \n        let mut table: RawTable<DropCounter, Global> = RawTable::default();\n        table.insert(0, counter_1, |x| *x); // Assuming you have a way to insert\n        table.insert(1, counter_2, |x| *x); // Assuming you have a way to insert\n\n        {\n            let drain_iter = table.drain();\n            let _collected: Vec<DropCounter> = drain_iter.collect();\n            // DropCounter elements should drop automatically\n        }\n        \n        assert_eq!(*count.lock().unwrap(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582427, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=468, prompt_tokens=16361, total_tokens=16829, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmSW2pTYHVZcj28GE0tsMyrXrKb5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_drain_iter_from() {\n        // Create a RawTable with some test values\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n\n        // Insert values into the table\n        for i in 0..5 {\n            let _ = table.insert(i as u64, i, |v| *v as u64);\n        }\n\n        // Create an iterator starting from the beginning\n        let iter = table.iter();\n        let mut drain_iter = unsafe { table.drain_iter_from(iter) };\n\n        // Collect the drained items into a vector\n        let drained_items: Vec<i32> = drain_iter.collect();\n\n        // Check the drained items match the expected values\n        assert_eq!(drained_items, vec![0, 1, 2, 3, 4]);\n\n        // Ensure the table is now empty\n        assert_eq!(table.table.items, 0);\n    }\n\n    #[test]\n    fn test_drain_iter_from_empty() {\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n\n        // Create an empty iterator\n        let iter = table.iter();\n        let mut drain_iter = unsafe { table.drain_iter_from(iter) };\n\n        // Collect the drained items into a vector\n        let drained_items: Vec<i32> = drain_iter.collect();\n\n        // Ensure no items were drained\n        assert!(drained_items.is_empty());\n        assert_eq!(table.table.items, 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582440, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=341, prompt_tokens=16361, total_tokens=16702, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmSg0ywkymFT2y4eunpuTd5YTpTl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_erase() {\n        // Setup a RawTable with a capacity of 4 for testing purposes\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        // Hash a value and insert into the hash table\n        let hash = 42; // Example hash value\n        let bucket = unsafe {\n            table.insert(hash, 10, |&x| x.wrapping_hash()).as_non_null()\n        };\n        \n        // Assert that the table contains a value\n        assert_eq!(unsafe { bucket.as_ref() }, &10);\n        \n        // Erase the value and test if it is removed\n        unsafe { table.erase(bucket) };\n\n        // Attempt to find the erased value, expecting None\n        assert_eq!(table.find(hash, |&x| x == 10), None);\n    }\n\n    #[test]\n    fn test_erase_drop() {\n        // Setup a RawTable with a capacity of 4 for testing purposes\n        let mut table: RawTable<Box<i32>, Global> = RawTable::with_capacity(4);\n        let value = Box::new(20);\n        let hash = 42; // Example hash value\n        let bucket = unsafe {\n            table.insert(hash, value, |x| x.as_ref().hash()).as_non_null()\n        };\n\n        // Erase the value and test if the Box is dropped\n        unsafe { table.erase(bucket) };\n\n        // Check if the box is dropped correctly (after erase, value should be out of scope)\n        // This test is more about ensuring it compiles correctly; manual checking or use of\n        // drop counters would be necessary for more in-depth testing of drop behavior.\n    }\n\n    #[test]\n    fn test_safe_usage() {\n        // Create a RawTable for testing\n        let mut table: RawTable<String, Global> = RawTable::with_capacity(4);\n        let hash_value = 123; // Example hash value\n        let bucket = unsafe {\n            table.insert(hash_value, "Test".to_string(), |x| x.hash()).as_non_null()\n        };\n\n        // Ensure the value exists\n        assert_eq!(unsafe { bucket.as_ref() }, "Test");\n\n        // Erase the value\n        unsafe { table.erase(bucket) };\n\n        // Ensure the erased value is not found\n        assert!(table.find(hash_value, |x| x == "Test").is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582450, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=535, prompt_tokens=16361, total_tokens=16896, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmSxKKj3x5s3w1QfX8jRn4Ogl1jE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_erase_no_drop() {\n        // Setup\n        let mut table: RawTable<u32, Global> = RawTable::new();\n        let bucket = unsafe {\n            table.insert(1, 42, |x| *x).as_non_null() // Insert an element\n        };\n\n        // Verify insertion\n        assert_eq!(table.len(), 1);\n\n        // Erase the element without dropping\n        unsafe { table.erase_no_drop(&Bucket { ptr: bucket }) };\n\n        // Verify that the length remains 1 after erasing without dropping\n        assert_eq!(table.len(), 1);\n    }\n\n    #[test]\n    fn test_erase_no_drop_empty_table() {\n        // Setup\n        let mut table: RawTable<u32, Global> = RawTable::new();\n        let bucket = unsafe {\n            table.insert(1, 42, |x| *x).as_non_null() // Insert an element\n        };\n\n        // Erase the element without dropping\n        unsafe { table.erase_no_drop(&Bucket { ptr: bucket }) };\n\n        // Verify the table is unchanged (length remains 1)\n        assert_eq!(table.len(), 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582467, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=275, prompt_tokens=16361, total_tokens=16636, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmTIlVF34fj283P32uL5gzKqso6j', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::vec::Vec;\n\n    #[test]\n    fn test_find_existing_element() {\n        let mut table: RawTable<i32> = RawTable::new();\n        let hash = 42; // A dummy hash for testing\n        let value = 100;\n\n        unsafe {\n            table.insert(hash, value, |&v| v as u64); // Insert an element\n        }\n\n        let found = table.find(hash, |&v| *v == value);\n        assert!(found.is_some(), "Expected to find the element, but found none.");\n        assert_eq!(unsafe { found.unwrap().as_ref() }, &value);\n    }\n\n    #[test]\n    fn test_find_non_existing_element() {\n        let table: RawTable<i32> = RawTable::new();\n        let hash = 42; // A dummy hash for testing\n        let value = 100;\n\n        let found = table.find(hash, |&v| v == value);\n        assert!(found.is_none(), "Expected to find no element, but found one.");\n    }\n\n    #[test]\n    fn test_find_with_custom_equality() {\n        let mut table: RawTable<i32> = RawTable::new();\n        unsafe {\n            table.insert(1, 10, |&v| v as u64);\n            table.insert(2, 20, |&v| v as u64);\n        }\n\n        let found = table.find(1, |&v| *v == 10);\n        assert!(found.is_some(), "Expected to find the element.");\n    }\n\n    #[test]\n    fn test_find_on_empty_table() {\n        let table: RawTable<i32> = RawTable::new();\n        let found = table.find(0, |_| false);\n        assert!(found.is_none(), "Expected to find no element in an empty table.");\n    }\n\n    #[test]\n    fn test_find_with_collision() {\n        let mut table: RawTable<i32> = RawTable::new();\n        unsafe {\n            table.insert(1, 10, |&v| v as u64); // Insert element with hash 1\n            table.insert(2, 20, |&v| v as u64); // Insert element with hash 2\n        }\n\n        let found = table.find(1, |&v| *v == 10);\n        assert!(found.is_some(), "Expected to find element with hash 1.");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582488, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=526, prompt_tokens=16361, total_tokens=16887, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmTWksDjooiMVSszqVtHHsgKFx8l', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_find_or_find_insert_slot_found() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash = 42;\n\n        unsafe {\n            table.insert(hash, 100, |x| *x);\n            let bucket_result = table.find_or_find_insert_slot(hash, |&x| x == 100, |x| *x);\n            assert!(bucket_result.is_ok());\n            assert_eq!(unsafe { bucket_result.unwrap().as_ref() }, &100);\n        }\n    }\n\n    #[test]\n    fn test_find_or_find_insert_slot_insert() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash = 42;\n\n        let bucket_result = table.find_or_find_insert_slot(hash, |&x| x == 100, |x| *x);\n        assert!(bucket_result.is_err());\n\n        unsafe {\n            let slot = bucket_result.unwrap_err();\n            let bucket = table.insert_in_slot(hash, slot, 100);\n            assert_eq!(unsafe { bucket.as_ref() }, &100);\n        }\n    }\n\n    #[test]\n    fn test_find_or_find_insert_slot_resize() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(1);\n        let hash = 42;\n\n        unsafe {\n            table.insert(hash, 100, |x| *x);\n            let bucket_result = table.find_or_find_insert_slot(hash + 1, |&x| x == 100, |x| *x);\n            assert!(bucket_result.is_ok());\n            assert_eq!(unsafe { bucket_result.unwrap().as_ref() }, &100);\n        }\n    }\n\n    #[test]\n    fn test_find_or_find_insert_slot_multiple_hashes() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash1 = 42;\n        let hash2 = 43;\n\n        unsafe {\n            table.insert(hash1, 100, |x| *x);\n            table.insert(hash2, 200, |x| *x);\n            let bucket_result1 = table.find_or_find_insert_slot(hash1, |&x| x == 100, |x| *x);\n            let bucket_result2 = table.find_or_find_insert_slot(hash2, |&x| x == 200, |x| *x);\n            assert!(bucket_result1.is_ok());\n            assert!(bucket_result2.is_ok());\n            assert_eq!(unsafe { bucket_result1.unwrap().as_ref() }, &100);\n            assert_eq!(unsafe { bucket_result2.unwrap().as_ref() }, &200);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582502, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=581, prompt_tokens=16361, total_tokens=16942, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmTjw16iJpMyGgitOpLdvFqxMQd0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_get_existing_item() {\n        let mut table = RawTable::<i32, Global>::with_capacity(4);\n        let hash: u64 = 42; // Example hash\n        table.insert(hash, 100, |x| *x as u64); // Insert an item\n\n        let result = table.get(hash, |item| *item == 100);\n        assert_eq!(result, Some(&100));\n    }\n\n    #[test]\n    fn test_get_non_existing_item() {\n        let table = RawTable::<i32, Global>::with_capacity(4);\n        let hash: u64 = 42; // Example hash\n\n        let result = table.get(hash, |item| *item == 100);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_item_with_different_hash() {\n        let mut table = RawTable::<i32, Global>::with_capacity(4);\n        let hash: u64 = 42; // Example hash\n        table.insert(hash, 100, |x| *x as u64); // Insert an item\n\n        let result = table.get(hash + 1, |item| *item == 100); // Query with a different hash\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_get_with_custom_equality() {\n        #[derive(PartialEq)]\n        struct MyStruct {\n            value: i32,\n        }\n\n        let mut table = RawTable::<MyStruct, Global>::with_capacity(4);\n        let hash: u64 = 42; // Example hash\n        table.insert(hash, MyStruct { value: 100 }, |x| x.value as u64); // Insert an item\n\n        let result = table.get(hash, |item| item.value == 100);\n        assert_eq!(result, Some(&MyStruct { value: 100 }));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582515, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=424, prompt_tokens=16361, total_tokens=16785, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmTua3TFwabH5kxRfn5zVOkpOCc9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    \n    #[test]\n    fn test_get_many_mut() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Inserting some values into the table\n        table.insert(1, 10, |&x| x as u64);\n        table.insert(2, 20, |&x| x as u64);\n        table.insert(3, 30, |&x| x as u64);\n\n        // Testing distinct hashes\n        let hashes = [1, 2, 3];\n        let result = table.get_many_mut(hashes, |i, k| k == &i);\n        assert_eq!(result, [Some(&mut 10), Some(&mut 20), Some(&mut 30)]);\n\n        // Testing duplicate hashes\n        let hashes_dup = [1, 1];\n        let result_dup = table.get_many_mut(hashes_dup, |i, k| k == &i);\n        assert_eq!(result_dup, [Some(&mut 10), None]);\n\n        // Testing hash that does not exist\n        let hashes_nonexistent = [4];\n        let result_nonexistent = table.get_many_mut(hashes_nonexistent, |i, k| k == &i);\n        assert_eq!(result_nonexistent, [None]);\n    }\n\n    #[test]\n    #[should_panic(expected = "duplicate keys found")]\n    fn test_get_many_mut_duplicate_panic() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Inserting some values into the table\n        table.insert(1, 10, |&x| x as u64);\n        table.insert(2, 20, |&x| x as u64);\n\n        // Testing duplicate hashes\n        let hashes_dup = [1, 1];\n        let _ = table.get_many_mut(hashes_dup, |i, k| k == &i);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582526, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=431, prompt_tokens=16361, total_tokens=16792, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmU8EaFJMgm0VWyvUOoz0OR9B9Ds', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_get_many_mut_pointers_unique() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        let keys = [1, 2, 3];\n        let hashes = [1u64, 2, 3];\n        \n        // Insert elements into table\n        for (hash, value) in hashes.iter().zip(keys.iter()) {\n            table.insert(*hash, *value, |&x| x.wrapping_add(1) as u64);\n        }\n\n        // Define equality function\n        let eq = |i: usize, &k: &i32| {\n            keys[i] == k\n        };\n\n        // Call the function\n        let pointers = unsafe {\n            table.get_many_mut_pointers(hashes, eq)\n        };\n\n        // Check if the pointers are correct\n        assert_eq!(pointers.len(), 3);\n        for (i, &hash) in hashes.iter().enumerate() {\n            let result = pointers[i];\n            assert!(result.is_some(), "Expected a pointer for hash: {}", hash);\n            let value = unsafe { result.unwrap().as_ref() };\n            assert_eq!(*value, keys[i]);\n        }\n    }\n\n    #[test]\n    fn test_get_many_mut_pointers_duplicates() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        let keys = [1, 1, 2, 3];\n        let hashes = [1u64, 1, 2, 3];\n\n        // Insert elements into table\n        for (hash, value) in hashes.iter().zip(keys.iter()) {\n            table.insert(*hash, *value, |&x| x.wrapping_add(1) as u64);\n        }\n\n        // Define equality function\n        let eq = |i: usize, &k: &i32| {\n            keys[i] == k\n        };\n\n        // Call the function\n        let pointers = unsafe {\n            table.get_many_mut_pointers(hashes, eq)\n        };\n\n        // Check pointers\n        for (i, &result) in pointers.iter().enumerate() {\n            if i == 0 {\n                // First hash (1) should point to the first occurrence\n                assert!(result.is_some(), "Expected a pointer for hash: {}", hashes[i]);\n            } else if i == 1 {\n                // Second hash (1) should produce a duplicate\n                assert!(result.is_none(), "Expected None for duplicate hash: {}", hashes[i]);\n            } else {\n                assert!(result.is_some(), "Expected a pointer for hash: {}", hashes[i]);\n            }\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582540, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=589, prompt_tokens=16361, total_tokens=16950, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmUMK8P9Zoofg3cYp8tuXvVT3fZu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::mem::MaybeUninit;\n\n    #[test]\n    fn test_get_many_unchecked_mut() {\n        let mut table: RawTable<u32, Global> = RawTable::new();\n        \n        // Insert some test data\n        for i in 0..5 {\n            let hash = i as u64;\n            unsafe {\n                table.insert(hash, i, |x| *x);\n            }\n        }\n\n        // Prepare hashes for get_many_unchecked_mut\n        let hashes: [u64; 5] = [0, 1, 2, 3, 4];\n\n        // Get mutable references to multiple elements\n        let mut results: [Option<&mut u32>; 5] = unsafe {\n            table.get_many_unchecked_mut(hashes, |i, &val| {\n                val == i as u32\n            })\n        };\n\n        // Ensure that we got mutable references to correct elements\n        for (i, result) in results.iter_mut().enumerate() {\n            assert!(result.is_some());\n            *result = result.take().map(|val| {\n                *val += 10; // Modify value to check mutability\n                val\n            });\n            assert_eq!(*result.unwrap(), (i as u32) + 10);\n        }\n\n        // Verify that the table's elements have the expected modified values\n        for i in 0..5 {\n            assert_eq!(unsafe { table.get(i as u64, |&val| val == i as u32) }.unwrap(), &((i as u32) + 10));\n        }\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582554, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=358, prompt_tokens=16361, total_tokens=16719, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmUY7jrEoGexrsvTyEy6n66fG4Jl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_get_mut_existing() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        table.insert(123, 42, |x| *x);\n        let mut result = table.get_mut(123, |x| *x == 42);\n        assert!(result.is_some());\n        *result.as_mut().unwrap() = 50; // Update the value\n        assert_eq!(table.get(123, |x| *x == 50).unwrap(), &50);\n    }\n\n    #[test]\n    fn test_get_mut_non_existing() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        table.insert(123, 42, |x| *x);\n        let result = table.get_mut(999, |x| *x == 50);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_get_mut_multiple_entries() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        table.insert(123, 42, |x| *x);\n        table.insert(456, 99, |x| *x);\n        \n        let result = table.get_mut(456, |x| *x == 99);\n        assert!(result.is_some());\n        *result.as_mut().unwrap() = 100; // Update the value\n        assert_eq!(table.get(456, |x| *x == 100).unwrap(), &100);\n    }\n\n    #[test]\n    fn test_get_mut_tombstone() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        table.insert(123, 42, |x| *x);\n        \n        // This simulates deleting an entry without actually deleting it\n        unsafe {\n            table.erase_no_drop(&table.find(123, |x| *x == 42).unwrap());\n        }\n\n        let result = table.get_mut(123, |x| *x == 42);\n        assert!(result.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582566, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=458, prompt_tokens=16361, total_tokens=16819, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmUiWYDVNUYq5eg9dAPZNDIAyQBq', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Importing relevant items from the parent module\n    use std::alloc::Global; // Import for default allocator\n    use std::ptr::NonNull; // Import for NonNull\n    use std::mem::size_of; // Import for size_of\n\n    #[test]\n    fn test_raw_table_insert() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hasher = |&value: &i32| value as u64; // A simple hasher\n\n        // Insert elements\n        let bucket1 = table.insert(1, 10, hasher);\n        let bucket2 = table.insert(2, 20, hasher);\n        \n        // Check bucket indices\n        let index1 = unsafe { table.bucket_index(&bucket1) };\n        let index2 = unsafe { table.bucket_index(&bucket2) };\n        \n        // Verify contents\n        assert_eq!(unsafe { bucket1.as_ref() }, &10);\n        assert_eq!(unsafe { bucket2.as_ref() }, &20);\n        \n        // Verify indices range\n        assert!(index1 < table.buckets());\n        assert!(index2 < table.buckets());\n    }\n    \n    #[test]\n    fn test_insert_without_growth() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(2);\n        let hasher = |&value: &i32| value as u64;\n\n        // Insert elements\n        let bucket1 = table.insert(1, 30, hasher);\n        let bucket2 = table.insert(2, 40, hasher);\n        \n        // Verify contents\n        assert_eq!(unsafe { bucket1.as_ref() }, &30);\n        assert_eq!(unsafe { bucket2.as_ref() }, &40);\n        \n        // Initial size should match the number of current insertions\n        assert_eq!(table.len(), 2);\n    }\n\n    #[test]\n    fn test_insert_and_replace() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(2);\n        let hasher = |&value: &i32| value as u64;\n\n        // Insert an element\n        let bucket = table.insert(1, 50, hasher);\n        \n        // Replace value\n        unsafe { bucket.write(60) };\n        \n        // Verify new value\n        assert_eq!(unsafe { bucket.as_ref() }, &60);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582576, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=525, prompt_tokens=16361, total_tokens=16886, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmV05Lz6t5Uw9g4eFqUgCdglDscA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::allocator::Global;\n\n    #[test]\n    fn test_insert_entry() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hasher = |value: &i32| *value as u64;\n\n        // Insert an element into the table\n        let hash = hasher(&42);\n        let reference = table.insert_entry(hash, 42, hasher);\n        \n        // Check that the reference returned is the same as the inserted value\n        assert_eq!(*reference, 42);\n        \n        // Insert another element into the table\n        let hash2 = hasher(&50);\n        let reference2 = table.insert_entry(hash2, 50, hasher);\n        \n        // Check that the reference returned is the same as the inserted value\n        assert_eq!(*reference2, 50);\n        \n        // Ensure the first value can still be accessed\n        let retrieved_ref = table.get_mut(hash, |&x| x == 42);\n        assert!(retrieved_ref.is_some());\n        assert_eq!(*retrieved_ref.unwrap(), 42);\n        \n        // Ensure the second value can still be accessed\n        let retrieved_ref2 = table.get_mut(hash2, |&x| x == 50);\n        assert!(retrieved_ref2.is_some());\n        assert_eq!(*retrieved_ref2.unwrap(), 50);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_insert_entry_panic() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hasher = |value: &i32| *value as u64;\n        \n        // This should panic as the table is empty and not properly allocated\n        let _ = table.insert_entry(0, 42, hasher);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582594, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=395, prompt_tokens=16361, total_tokens=16756, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVBABuL0HcP5txD703RYNB8UFhO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_insert_in_slot() {\n        // Create a RawTable with a specific capacity\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        // Insert a value and retrieve the InsertSlot\n        let hash = 42;\n        let value = 10;\n        let insert_slot = unsafe {\n            table.find_or_find_insert_slot(hash, |&x| x == value, |x| x as u64).unwrap_err()\n        };\n\n        // Insert the value in the given insert slot\n        let bucket = unsafe { table.insert_in_slot(hash, insert_slot, value) };\n\n        // Check that the value is correctly inserted\n        assert_eq!(unsafe { bucket.as_ref() }, &value);\n\n        // Check that the bucket index is as expected\n        let index = unsafe { table.bucket_index(&bucket) };\n        assert_eq!(index, insert_slot.index);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_insert_in_slot_invalid_slot() {\n        // Create a RawTable with a specific capacity\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        let invalid_slot = InsertSlot { index: 10 }; // Invalid index\n\n        // Try to insert in an invalid slot, expecting a panic\n        unsafe {\n            table.insert_in_slot(42, invalid_slot, 10);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582605, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=323, prompt_tokens=16361, total_tokens=16684, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVPO7fyz3PFEbFmflI2arZhoOhK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n    use std::alloc::Layout;\n\n    #[test]\n    fn test_into_allocation_empty() {\n        let table: RawTable<i32, Global> = RawTable::new();\n        let alloc = table.into_allocation();\n        assert!(alloc.is_none());\n    }\n\n    #[test]\n    fn test_into_allocation_singleton() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        table.insert(0, 42, |&x| x); // Insert an element\n        let alloc = table.into_allocation();\n        assert!(alloc.is_none());\n    }\n\n    #[test]\n    fn test_into_allocation_with_data() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n        table.insert(0, 42, |&x| x);\n        table.insert(1, 43, |&x| x);\n        let alloc = table.into_allocation();\n        assert!(alloc.is_some());\n        \n        if let Some((ptr, layout, _)) = alloc {\n            assert!(ptr.as_ptr() != std::ptr::null_mut());\n            assert!(layout.size() > 0);\n        }\n    }\n\n    #[test]\n    fn test_into_allocation_multiple() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(8);\n        for i in 0..8 {\n            table.insert(i, i as i32, |&x| x);\n        }\n        let alloc = table.into_allocation();\n        assert!(alloc.is_some());\n        \n        if let Some((ptr, layout, _)) = alloc {\n            assert!(ptr.as_ptr() != std::ptr::null_mut());\n            assert!(layout.size() > 0);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582619, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=405, prompt_tokens=16361, total_tokens=16766, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVVZ80BumhyamVsYuFuV4uu9FJ1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{RawTable, RawIter, RawIntoIter, Bucket};\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_into_iter_from() {\n        unsafe {\n            // Create a new RawTable with a custom allocator.\n            let mut table: RawTable<i32, Global> = RawTable::default();\n            // Insert some values into the table.\n            let items = vec![1, 2, 3, 4, 5];\n            for item in items.iter() {\n                table.insert(0, *item, |x| *x);\n            }\n            // Create a RawIter over the table.\n            let iter = table.iter();\n            // Create a RawIntoIter using into_iter_from.\n            let mut into_iter: RawIntoIter<i32, Global> = table.into_iter_from(iter.clone());\n            \n            // Collect items from the iterator.\n            let mut collected: Vec<i32> = Vec::new();\n            while let Some(item) = into_iter.next() {\n                collected.push(item);\n            }\n            // Check if the collected items match the original items.\n            assert_eq!(collected, items);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582625, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=268, prompt_tokens=16361, total_tokens=16629, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVfAKPTpRMRSlk6WCwJl4Y4DZWZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_is_bucket_full() {\n        // Create a new RawTable with a known number of buckets\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(8);\n        \n        // Fill the table with the maximum number of elements\n        for i in 0..8 {\n            unsafe {\n                table.insert(0, i, |x| x.hash()); // Insert elements to fill the table\n            }\n        }\n\n        // Check if the buckets are full\n        for i in 0..8 {\n            let is_full = unsafe { table.is_bucket_full(i) };\n            assert!(is_full, "Bucket {} should be full", i);\n        }\n        \n        // Insert an additional element to trigger the growth of the table\n        unsafe {\n            table.insert(0, 8, |x| x.hash());\n        }\n\n        // Check if the original buckets remain full\n        for i in 0..8 {\n            let is_full = unsafe { table.is_bucket_full(i) };\n            assert!(is_full, "Bucket {} should still be full", i);\n        }\n        \n        // Check if a new bucket is empty\n        let is_full_index = 8;\n        let is_full = unsafe { table.is_bucket_full(is_full_index) };\n        assert!(!is_full, "Bucket {} should be empty", is_full_index);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582635, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=313, prompt_tokens=16361, total_tokens=16674, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVoizf0pzaWOlCo7fhA469QBUbj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::alloc::Global;\n\n    #[test]\n    fn test_raw_table_is_empty() {\n        // Create a new empty RawTable\n        let table: RawTable<i32, Global> = RawTable::new();\n\n        // Assert that the table is empty\n        assert!(table.is_empty());\n\n        // Create a new RawTable with capacity\n        let table_with_capacity = RawTable::with_capacity(10);\n\n        // Assert that the new table with capacity is empty\n        assert!(table_with_capacity.is_empty());\n    }\n    \n    #[test]\n    fn test_raw_table_is_not_empty() {\n        let mut table = RawTable::new();\n\n        // Insert an element\n        unsafe {\n            table.insert(0, 42, |x| x.hash());\n        }\n\n        // Assert that the table is not empty\n        assert!(!table.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582644, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=197, prompt_tokens=16361, total_tokens=16558, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmVvWWqlY40DOYPGViGUrVXlsgjz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_iter() {\n        // Create a new raw table\n        let mut table: RawTable<i32, Global> = RawTable::new_in(Global);\n        \n        // Insert elements into the table\n        table.insert(1, 10, |x| *x);\n        table.insert(2, 20, |x| *x);\n        table.insert(3, 30, |x| *x);\n        \n        // Ensure the table has 3 items\n        assert_eq!(table.len(), 3);\n        \n        // Create an unsafe block to call the unsafe iter method\n        unsafe {\n            let iter = table.iter();\n            let mut count = 0;\n\n            // Iterate through items\n            for bucket in iter {\n                assert!(count < table.len());\n                count += 1;\n\n                // Ensure we can read the bucket value\n                let value = bucket.as_ref();\n                assert!(value == &10 || value == &20 || value == &30);\n            }\n            // Ensure we have iterated through all items\n            assert_eq!(count, table.len());\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582651, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=257, prompt_tokens=16361, total_tokens=16618, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmW3ukUeCMZ1Nn4xcxAmixe6M3Kx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_iter_hash() {\n        unsafe {\n            let mut table: RawTable<i32, Global> = RawTable::new();\n            table.insert(1, 42, |v| *v);\n            table.insert(2, 43, |v| *v);\n            table.insert(3, 44, |v| *v);\n\n            let mut iter = table.iter_hash(3);\n            let mut found = false;\n\n            while let Some(bucket) = iter.next() {\n                let value = bucket.as_ref();\n                if *value == 44 {\n                    found = true;\n                    break;\n                }\n            }\n\n            assert!(found, "Expected to find value 44 in the iter_hash iterator");\n        }\n    }\n\n    #[test]\n    fn test_iter_hash_empty() {\n        unsafe {\n            let table: RawTable<i32, Global> = RawTable::new();\n            let iter = table.iter_hash(0);\n            assert!(iter.next().is_none(), "Expected iter_hash to return None on empty table");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582659, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=246, prompt_tokens=16361, total_tokens=16607, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmWCm6p3FKuf3Jj5qwEgBIIahoqJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_raw_table_len() {\n        let table: RawTable<u32, Global> = RawTable::new(); // Create a new RawTable\n        assert_eq!(table.len(), 0); // Check initial length\n\n        unsafe {\n            // Insert an item\n            table.insert(0, 1, |&val| val); // Assuming the hasher is the identity function\n        }\n        assert_eq!(table.len(), 1); // Check length after inserting one item\n\n        unsafe {\n            // Insert another item\n            table.insert(1, 2, |&val| val);\n        }\n        assert_eq!(table.len(), 2); // Check length after inserting two items\n\n        // Clear the table\n        table.clear();\n        assert_eq!(table.len(), 0); // Check length after clearing\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582668, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=201, prompt_tokens=16361, total_tokens=16562, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmWNpJkWyImg8yMMu8iYhFYwrQqA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::marker::PhantomData;\n    \n    #[test]\n    fn test_new_in() {\n        // Create a new RawTable with a default allocator\n        let table: RawTable<u32, Global> = RawTable::new_in(Global);\n        \n        // Check that it is initialized correctly\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.buckets(), 1);\n        assert!(table.is_empty());\n        assert_eq!(table.allocation_size(), 0);\n    }\n\n    #[test]\n    fn test_new_in_with_custom_allocator() {\n        // Custom allocator can be replaced with a simple allocator if available\n        struct CustomAllocator;\n        unsafe impl Allocator for CustomAllocator {\n            // Implementation of the allocator methods\n        }\n\n        // Create a new RawTable with a custom allocator\n        let custom: RawTable<u32, CustomAllocator> = RawTable::new_in(CustomAllocator);\n        \n        // Check that it is initialized correctly\n        assert_eq!(custom.len(), 0);\n        assert_eq!(custom.buckets(), 1);\n        assert!(custom.is_empty());\n        assert_eq!(custom.allocation_size(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582679, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=266, prompt_tokens=16361, total_tokens=16627, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmWVQXcvHN1NfmGChZMsHDUpsuwp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{Fallibility, RawTable};\n    use std::alloc::Global;\n\n    #[test]\n    fn test_new_uninitialized_fallible() {\n        let fallibility = Fallibility::Fallible;\n        let buckets = 16; // Must be a power of two\n        let alloc = Global;\n\n        let result = unsafe { RawTable::<i32, _>::new_uninitialized(alloc, buckets, fallibility) };\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_new_uninitialized_infallible() {\n        let fallibility = Fallibility::Infallible;\n        let buckets = 16; // Must be a power of two\n        let alloc = Global;\n\n        let result = unsafe { RawTable::<i32, _>::new_uninitialized(alloc, buckets, fallibility) };\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_new_uninitialized_infallible_panic_on_overflow() {\n        let fallibility = Fallibility::Infallible;\n        let buckets = 1 << 30; // Large bucket count to cause panic\n        let alloc = Global;\n\n        unsafe { RawTable::<i32, _>::new_uninitialized(alloc, buckets, fallibility) };\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582687, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=288, prompt_tokens=472, total_tokens=760, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmWbsDPQbcpPD7TtU7VPBeLE9n5H', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_remove() {\n        // Set up the RawTable\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Insert an item\n        let hash: u64 = 1; // example hash\n        let bucket = table.insert(hash, 42, |x| *x as u64); // insert an item to the table\n\n        unsafe {\n            // Remove the item\n            let (item, insert_slot) = table.remove(bucket);\n            \n            // Verify the removed item\n            assert_eq!(item, 42);\n            \n            // Verify the insert slot index\n            assert_eq!(insert_slot.index, table.bucket_index(&bucket)); // Check the index\n        }\n    }\n\n    #[test]\n    fn test_remove_non_existing() {\n        // Set up the RawTable\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Insert an item\n        let hash: u64 = 1; // example hash\n        let bucket = table.insert(hash, 42, |x| *x as u64); // insert an item to the table\n\n        unsafe {\n            // Remove the item\n            let (item, insert_slot) = table.remove(bucket);\n            assert_eq!(item, 42);\n\n            // Attempt to remove the same item again\n            // The behavior here depends on the state of the table after the first remove\n            // This should ideally return an error or panic, ensure that's properly handled\n        }\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582693, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=345, prompt_tokens=16361, total_tokens=16706, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmWmzquSi9XR1TivjAGSh3yTJ3Lm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_remove_entry() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash = 42;\n\n        // Try to remove from an empty table\n        let result = table.remove_entry(hash, |&x| x == 5);\n        assert!(result.is_none());\n\n        // Insert an element\n        let _bucket = table.insert(hash, 5, |x| *x as u64);\n        // Remove the element\n        let result = table.remove_entry(hash, |&x| x == 5);\n        assert_eq!(result, Some(5));\n\n        // Check that the table is empty now\n        assert!(table.is_empty());\n    }\n\n    #[test]\n    fn test_remove_non_existing_entry() {\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        let hash1 = 42;\n        let hash2 = 43;\n\n        // Insert an element\n        let _bucket1 = table.insert(hash1, 5, |x| *x as u64);\n        // Try to remove a non-existing element\n        let result = table.remove_entry(hash2, |&x| x == 10);\n        assert!(result.is_none()); // Should return None\n    }\n\n    #[test]\n    fn test_remove_entry_with_custom_eq() {\n        let mut table: RawTable<&str, Global> = RawTable::new();\n        let hash1 = 42;\n\n        // Insert a string\n        let _bucket = table.insert(hash1, "hello", |x| hash(x));\n\n        // Remove the string using a custom equality function\n        let result = table.remove_entry(hash1, |&x| x == "hello");\n        assert_eq!(result, Some("hello"));\n\n        // Check that the table is empty now\n        assert!(table.is_empty());\n    }\n\n    fn hash<T: std::hash::Hash>(item: &T) -> u64 {\n        use std::hash::{Hasher, BuildHasherDefault};\n        let mut hasher = BuildHasherDefault::<std::collections::hash_map::DefaultHasher>::default();\n        item.hash(&mut hasher);\n        hasher.finish()\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582704, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=487, prompt_tokens=16361, total_tokens=16848, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmWyEi50v8QUtovM1ktfskA84nFL', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_replace_bucket_with_function() {\n        // Setup a new raw table\n        let mut table: RawTable<i32, Global> = RawTable::new();\n        \n        // Insert an element\n        let hash = 42;\n        let bucket = table.insert(hash, 10, |x| x);\n        \n        // Replace the bucket content\n        let result = unsafe {\n            table.replace_bucket_with(bucket.clone(), |value| {\n                Some(value + 1)  // Replace with the incremented value\n            })\n        };\n\n        // Verify the result\n        assert!(result, "Expected bucket to still contain an element");\n        assert_eq!(unsafe { *bucket.as_ref() }, 11, "Expected bucket value to be updated to 11");\n\n        // Attempt to replace and remove the element\n        let removed = unsafe {\n            table.replace_bucket_with(bucket.clone(), |value| {\n                None  // Replace with None, effectively removing the value\n            })\n        };\n\n        // Verify the result\n        assert!(!removed, "Expected bucket to be empty after removal");\n        \n        // Check if the bucket is empty\n        let is_empty = unsafe {\n            !table.is_bucket_full(table.bucket_index(&bucket))\n        };\n        assert!(is_empty, "Expected bucket to be empty");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582716, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=297, prompt_tokens=16361, total_tokens=16658, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmX6rGFrCfyUa2Pcue6rvzXgPjN9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_reserve() {\n        let mut table = RawTable::<usize, Global>::new();\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.capacity(), 0);\n\n        // Reserve space for 5 elements\n        table.reserve(5, |&x| x as u64);\n        assert!(table.capacity() >= 5);\n    }\n\n    #[test]\n    fn test_reserve_exceeds_growth() {\n        let mut table = RawTable::<usize, Global>::new();\n        table.reserve(1, |&x| x as u64);\n\n        // Initially, capacity should be 1 after the reserve call\n        assert!(table.capacity() >= 1);\n        \n        // Reserve space for more elements than the current growth left\n        let initial_capacity = table.capacity();\n        table.reserve(initial_capacity + 1, |&x| x as u64);\n        \n        // Capacity should have increased\n        assert!(table.capacity() > initial_capacity);\n    }\n\n    #[test]\n    fn test_reserve_no_capacity_growth() {\n        let mut table = RawTable::<usize, Global>::new();\n        table.reserve(0, |&x| x as u64);\n        \n        // Reserve 0 should not change the capacity\n        assert_eq!(table.capacity(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582724, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=299, prompt_tokens=16361, total_tokens=16660, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmXEEnhLga26bDPYWA0gf85KrWaS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_reserve_rehash_increase_capacity() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(2);\n        let initial_capacity = table.capacity();\n        let additional = 2;\n\n        unsafe {\n            let result = table.reserve_rehash(additional, |&x| x as u64, Fallibility::Infallible);\n            assert!(result.is_ok());\n            assert!(table.capacity() > initial_capacity);\n        }\n    }\n\n    #[test]\n    fn test_reserve_rehash_capacity_overflow() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(1);\n        let additional = usize::MAX; // This will cause a capacity overflow\n\n        unsafe {\n            let result = table.reserve_rehash(additional, |&x| x as u64, Fallibility::Fallible);\n            assert!(result.is_err());\n            if let Err(TryReserveError::CapacityOverflow) = result {\n                // Expected\n            } else {\n                panic!("Expected CapacityOverflow error");\n            }\n        }\n    }\n\n    #[test]\n    fn test_reserve_rehash_alloc_error() {\n        use std::alloc::Layout;\n\n        struct TestAllocator;\n        unsafe impl Allocator for TestAllocator {\n            unsafe fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, AllocError> {\n                Err(AllocError) // Simulating an allocation error\n            }\n\n            unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {\n                // No-op for deallocation\n            }\n        }\n\n        let mut table: RawTable<i32, TestAllocator> = RawTable::with_capacity(1);\n        let additional = 1;\n\n        unsafe {\n            let result = table.reserve_rehash(additional, |&x| x as u64, Fallibility::Fallible);\n            assert!(result.is_err());\n            if let Err(TryReserveError::AllocError { layout }) = result {\n                // Expected: here you could check the layout if needed\n            } else {\n                panic!("Expected AllocError");\n            }\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582732, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=474, prompt_tokens=16361, total_tokens=16835, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmXUK77ZsZshYEjfeJXXl7R8x2qD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_resize() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        // Inserting data to the table\n        let values = [1, 2, 3, 4];\n        for val in &values {\n            unsafe {\n                let _ = table.insert(0, *val, |&v| v as u64);\n            }\n        }\n\n        // Current size and items in the table\n        let current_capacity = table.capacity();\n        let current_items = table.len();\n\n        // Resizing to a larger capacity\n        unsafe {\n            let result = table.resize(8, |&v| v as u64, Fallibility::Fallible);\n            assert!(result.is_ok());\n        }\n\n        // Check if the items have been preserved and the capacity has changed\n        assert_eq!(table.len(), current_items);\n        assert!(table.capacity() > current_capacity);\n\n        // Resizing to a smaller capacity\n        unsafe {\n            let result = table.resize(2, |&v| v as u64, Fallibility::Fallible);\n            assert!(result.is_ok());\n        }\n\n        // Check if the items have been preserved and the capacity has changed\n        assert_eq!(table.len(), current_items);\n        assert_eq!(table.capacity(), 2);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_resize_to_zero_capacity() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        // Inserting data to the table\n        unsafe {\n            let _ = table.insert(0, 1, |&v| v as u64);\n        }\n\n        // Attempt to resize to zero capacity\n        unsafe {\n            let _ = table.resize(0, |&v| v as u64, Fallibility::Fallible);\n        }\n    }\n\n    #[test]\n    fn test_resize_without_alloc() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(2);\n\n        // Inserting data to the table\n        unsafe {\n            let _ = table.insert(0, 1, |&v| v as u64);\n        }\n\n        // Resize to a larger capacity without allocating\n        unsafe {\n            let result = table.resize(4, |&v| v as u64, Fallibility::Infallible);\n            assert!(result.is_ok());\n            assert_eq!(table.capacity(), 4);\n        }\n    }\n\n    #[test]\n    fn test_resize_with_failures() {\n        let mut table: RawTable<i32, Global> = RawTable::with_capacity(4);\n\n        // Check for capacity overflow\n        unsafe {\n            let result = table.resize(usize::MAX, |&v| v as u64, Fallibility::Fallible);\n            assert!(result.is_err());\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582748, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=626, prompt_tokens=16361, total_tokens=16987, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmXl5l9ElFaGmS0cr8DXnN8IOqOg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_shrink_to_empty() {\n        let mut table: RawTable<u64, Global> = RawTable::new();\n        table.shrink_to(0, |x| *x); // should not panic or change state\n        assert_eq!(table.len(), 0);\n        assert!(table.is_empty());\n    }\n\n    #[test]\n    fn test_shrink_to_non_empty() {\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(10);\n        table.insert(1, 10, |x| *x);\n        table.insert(2, 20, |x| *x);\n        table.shrink_to(1, |x| *x); // should shrink and maintain at least one element\n        assert_eq!(table.len(), 2);\n        assert!(table.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_shrink_to_remove_all() {\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(5);\n        table.insert(1, 10, |x| *x);\n        table.insert(2, 20, |x| *x);\n        table.shrink_to(0, |x| *x); // should remove all elements\n        assert_eq!(table.len(), 0);\n        assert!(table.is_empty());\n    }\n\n    #[test]\n    fn test_shrink_to_min_size() {\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(5);\n        table.insert(1, 10, |x| *x);\n        table.insert(2, 20, |x| *x);\n        table.shrink_to(1, |x| *x); // should maintain at least 1 element\n        assert_eq!(table.len(), 2);\n    }\n\n    #[test]\n    fn test_shrink_to_inplace() {\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(10);\n        for i in 0..5 {\n            table.insert(1 + i, i, |x| *x);\n        }\n        table.shrink_to(3, |x| *x); // should not shrink below current size\n        assert_eq!(table.len(), 5);\n    }\n\n    #[test]\n    fn test_shrink_to_below_capacity() {\n        let mut table: RawTable<u64, Global> = RawTable::with_capacity(20);\n        for i in 0..10 {\n            table.insert(1 + i, i, |x| *x);\n        }\n        table.shrink_to(5, |x| *x); // should not shrink below current size\n        assert_eq!(table.len(), 10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582765, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=610, prompt_tokens=16361, total_tokens=16971, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmY1ktKA56uUAiy0jtjSfRh869uB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_try_reserve() {\n        let mut table: RawTable<u64, Global> = RawTable::default();\n\n        // Initially, the table can hold 0 elements, we expect an Ok(()) for 0 reserves\n        let result = table.try_reserve(0, |&x| x);\n        assert!(result.is_ok());\n\n        // Reserve space for 1 item, which should succeed since growth_left is initially >= 1\n        let result = table.try_reserve(1, |&x| x);\n        assert!(result.is_ok());\n\n        // This assumes that the initial growth_left is 0 so we expect an error\n        // Trying to reserve 10 will fail initially if the table does not support it\n        let result = table.try_reserve(10, |&x| x);\n        assert!(result.is_err());\n\n        // After inserting 1 item, growth_left should allow for further inserts\n        table.insert(0, 42, |&x| x);\n        let result = table.try_reserve(5, |&x| x);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_reserve_with_multiple_reserves() {\n        let mut table: RawTable<u64, Global> = RawTable::default();\n\n        // Reserve space for 2 items, which should initially succeed\n        let result = table.try_reserve(2, |&x| x);\n        assert!(result.is_ok());\n\n        // Reserve space for 5 items, which should also succeed\n        let result = table.try_reserve(5, |&x| x);\n        assert!(result.is_ok());\n\n        // Reserve with amount larger than currently available\n        let result = table.try_reserve(10, |&x| x);\n        assert!(result.is_err());\n\n        // Insert elements to ensure growth_left is updated\n        table.insert(0, 42, |&x| x);\n        table.insert(0, 43, |&x| x);\n\n        // After inserting items, we should be able to reserve more space\n        let result = table.try_reserve(3, |&x| x);\n        assert!(result.is_ok());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582781, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=489, prompt_tokens=16361, total_tokens=16850, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYF7PlsC0gmli837SQJGutlNdi6', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_with_capacity_in() {\n        let capacity = 10;\n        let allocator = Global;\n\n        // Create a RawTable with specified capacity\n        let table: RawTable<i32, Global> = RawTable::with_capacity_in(capacity, allocator);\n\n        // Assert that the table has the expected properties\n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= capacity);\n        assert!(table.buckets() >= 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582795, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=125, prompt_tokens=16361, total_tokens=16486, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYKWBEVhs5dyDAJrUxZOV8kNqPT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_raw_table_new() {\n        // Create a new RawTable\n        let table: RawTable<i32> = RawTable::new();\n\n        // Check if the table is empty\n        assert!(table.is_empty());\n        \n        // Check the number of buckets\n        assert_eq!(table.buckets(), 1);\n        \n        // Check the capacity\n        assert_eq!(table.capacity(), 1);\n        \n        // Check the length\n        assert_eq!(table.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582800, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=123, prompt_tokens=16361, total_tokens=16484, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYQJGVVq32rNI2CXKcNbZddagiQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_with_capacity() {\n        let capacity = 10;\n        let table: RawTable<u32> = RawTable::with_capacity(capacity);\n\n        // Ensure that the table is initialized with the correct capacity\n        assert_eq!(table.capacity(), 10);\n        assert!(table.len() == 0);\n        assert!(table.buckets() > 0);\n    }\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let capacity = 0;\n        let table: RawTable<u32> = RawTable::with_capacity(capacity);\n\n        // Ensure that the table capacity is 0 and it is empty\n        assert_eq!(table.capacity(), 0);\n        assert!(table.len() == 0);\n    }\n\n    #[test]\n    fn test_with_capacity_non_zero() {\n        let capacity = 15;\n        let table: RawTable<u32> = RawTable::with_capacity(capacity);\n\n        // Ensure that the table is initialized with the correct capacity\n        assert_eq!(table.capacity(), 15);\n        assert!(table.len() == 0);\n        assert!(table.buckets() > 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582806, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=264, prompt_tokens=16361, total_tokens=16625, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYYnyWIzI7QORz3akCP5nwX0btU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_allocation_info() {\n        let layout = TableLayout::default(); // Assume a valid default layout\n        let allocator = System; // Using the global allocator\n        let capacity = 8; // Assume a capacity of 8\n        let mut table = unsafe { RawTableInner::fallible_with_capacity(&allocator, layout, capacity, Fallibility::Infallible).unwrap() };\n        \n        // Access the allocation info\n        let (ptr, alloc_layout) = unsafe { table.allocation_info(layout) };\n\n        // Verify the validity of the pointer\n        assert!(!ptr.as_ptr().is_null());\n\n        // Verify the layout (may need specific assertions depending on TableLayout)\n        assert_eq!(alloc_layout.size(), layout.size());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582814, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=185, prompt_tokens=16361, total_tokens=16546, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYfUmHaXUdh3MAGGGmwdK1UFudz', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_allocation_size_or_zero_with_empty_singleton() {\n        let table_layout = TableLayout::default(); // Adjust with real default or use appropriate layout\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, table_layout, 2, Fallibility::Infallible)\n                .expect("Failed to create RawTableInner")\n        };\n        \n        // Assuming that newly created tables with 0 elements are empty singletons\n        assert_eq!(unsafe { raw_table.allocation_size_or_zero(table_layout) }, 0);\n    }\n\n    #[test]\n    fn test_allocation_size_or_zero_with_non_empty() {\n        let table_layout = TableLayout::default(); // Adjust with real default or use appropriate layout\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, table_layout, 2, Fallibility::Infallible)\n                .expect("Failed to create RawTableInner")\n        };\n\n        // Manually simulate insertion and state\n        let index = 0; // Use a valid index\n        unsafe {\n            raw_table.set_ctrl(index, Tag::full(0)); // Simulate a full bucket\n            raw_table.items = 1; // Simulate that there\'s 1 item\n        }\n\n        // Assuming allocation_info method returns a valid size for the non-empty case\n        let allocation_size = unsafe { raw_table.allocation_size_or_zero(table_layout) };\n        assert!(allocation_size > 0, "Expected non-zero allocation size for non-empty table.");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582821, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=357, prompt_tokens=16361, total_tokens=16718, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmYpGzxbBpIvLzQI20wHHgzRbE9H', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_bucket_valid_index() {\n        let mut table_inner = RawTableInner {\n            bucket_mask: 3, // four buckets (0-3)\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n\n        // Ensure we can safely call bucket on a valid index\n        let index = 2;\n        let bucket = unsafe { table_inner.bucket::<u32>(index) };\n        assert!(!bucket.as_ptr().is_null());\n    }\n\n    #[test]\n    #[should_panic(expected = "assertion failed: index < self.buckets()")]\n    fn test_bucket_index_out_of_bounds() {\n        let table_inner = RawTableInner {\n            bucket_mask: 3, // four buckets (0-3)\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n\n        // This should panic\n        let _ = unsafe { table_inner.bucket::<u32>(4) };\n    }\n\n    #[test]\n    fn test_bucket_zero_index_on_unallocated() {\n        let table_inner = RawTableInner {\n            bucket_mask: 0, // simulating not allocated\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n\n        let index = 0;\n        let bucket = unsafe { table_inner.bucket::<u32>(index) };\n        assert!(!bucket.as_ptr().is_null());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582831, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=337, prompt_tokens=16361, total_tokens=16698, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZ1C28uHsYIj1IYhY9cT2s8iWAS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_bucket_ptr_valid() {\n        unsafe {\n            let alloc = &Global;\n            let layout = /* Appropriate layout based on your implementation */;\n            let mut table = RawTableInner::with_capacity(alloc, layout, 4);\n\n            let size_of: usize = std::mem::size_of::<u64>(); // Example type\n            let index = 0;\n            let ptr = table.bucket_ptr(index, size_of);\n            assert!(!ptr.is_null());\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_bucket_ptr_invalid_index() {\n        unsafe {\n            let alloc = &Global;\n            let layout = /* Appropriate layout based on your implementation */;\n            let mut table = RawTableInner::with_capacity(alloc, layout, 4);\n\n            let size_of: usize = std::mem::size_of::<u64>(); // Example type\n            let index = 5; // Invalid index\n            let _ptr = table.bucket_ptr(index, size_of);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_bucket_ptr_unallocated_table() {\n        unsafe {\n            let table = RawTableInner {\n                bucket_mask: 0,\n                // Add other fields with appropriate initial values\n                ctrl: NonNull::dangling(),\n                growth_left: 0,\n                items: 0,\n            };\n\n            let size_of: usize = std::mem::size_of::<u64>(); // Example type\n            let _ptr = table.bucket_ptr(0, size_of);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582843, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=349, prompt_tokens=16361, total_tokens=16710, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZE8TeR4xZi0dwuElb5PdaCwXBS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_buckets() {\n        let raw_table_inner = RawTableInner {\n            bucket_mask: 7, // Example bucket_mask, corresponds to 8 buckets\n            ctrl: NonNull::dangling(), // Dummy non-null pointer for testing\n            growth_left: 0,\n            items: 0,\n        };\n\n        let bucket_count = raw_table_inner.buckets();\n        assert_eq!(bucket_count, 8, "Expected 8 buckets for bucket_mask 7");\n        \n        let raw_table_inner_empty = RawTableInner {\n            bucket_mask: 0, // Should correspond to 1 bucket\n            ctrl: NonNull::dangling(), // Dummy non-null pointer for testing\n            growth_left: 0,\n            items: 0,\n        };\n\n        let bucket_count_empty = raw_table_inner_empty.buckets();\n        assert_eq!(bucket_count_empty, 1, "Expected 1 bucket for bucket_mask 0");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582856, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=216, prompt_tokens=16361, total_tokens=16577, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZKV4ztWvumIhJwm2h9LN1PnmE9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_clear_no_drop() {\n        // Create an instance of RawTableInner\n        let mut raw_table: RawTableInner = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible).unwrap()\n        };\n\n        // Prepopulate the table with 2 items\n        raw_table.items = 2;\n\n        // Confirm initial state\n        assert_eq!(raw_table.items, 2);\n        \n        // Call the function to clear the table\n        raw_table.clear_no_drop();\n\n        // Confirm the state after clearing\n        assert_eq!(raw_table.items, 0);\n        assert_eq!(raw_table.growth_left, bucket_mask_to_capacity(raw_table.bucket_mask));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582862, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=182, prompt_tokens=16361, total_tokens=16543, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZQXdHw4YmC51e8acLLJ1dVMsRc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_ctrl() {\n        // Setup a RawTableInner with known parameters\n        let bucket_mask = 3; // 4 buckets\n        let buckets = bucket_mask + 1; // 4\n        let ctrl_array: Vec<Tag> = vec![Tag::EMPTY; bucket_mask + 1 + Group::WIDTH];\n        let ctrl_ptr = NonNull::new(ctrl_array.as_ptr() as *mut u8).unwrap();\n\n        let raw_table = RawTableInner {\n            bucket_mask,\n            ctrl: ctrl_ptr,\n            growth_left: 10,\n            items: 0,\n        };\n\n        // Test ctrl with a valid index\n        let index = 0; // valid index\n        unsafe {\n            let ctrl_ptr = raw_table.ctrl(index);\n            assert_eq!(*ctrl_ptr, Tag::EMPTY);\n        }\n\n        // Test ctrl with an index greater than bucket_mask + 1 + Group::WIDTH\n        let invalid_index = bucket_mask + 1 + Group::WIDTH;\n        unsafe {\n            std::panic::catch_unwind(|| {\n                let _ = raw_table.ctrl(invalid_index);\n            })\n            .unwrap_err(); // This should panic\n        }\n\n        // Test with an index equal to bucket_mask + 1 + Group::WIDTH\n        let just_valid_index = bucket_mask + 1 + Group::WIDTH;\n        unsafe {\n            let ctrl_ptr = raw_table.ctrl(just_valid_index);\n            assert_eq!(ctrl_ptr, ctrl_array.as_ptr().add(just_valid_index).cast());\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582868, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=347, prompt_tokens=16361, total_tokens=16708, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZbbz8IFR2dwRg6o0ACnQjM6oSH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_ctrl_slice() {\n        let buckets = 8; // Example number of buckets (must be a power of two).\n        \n        // Create a dummy allocator and layout (assuming appropriate types).\n        let allocator = /* Your allocator here */;\n        let layout = /* Your layout here */;\n        \n        // Create a new RawTableInner with specified buckets\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&allocator, layout, buckets, Fallibility::Infallible)\n                .expect("Failed to create RawTableInner")\n        };\n\n        // Fill the control bytes with EMPTY tags\n        unsafe {\n            raw_table.ctrl_slice().fill(Tag::EMPTY);\n        }\n\n        // Get the control slice and verify the contents\n        let ctrl_slice = unsafe { raw_table.ctrl_slice() };\n\n        // Check if the control slice is initialized correctly\n        assert_eq!(ctrl_slice.len(), raw_table.num_ctrl_bytes());\n        assert!(ctrl_slice.iter().all(|&tag| tag == Tag::EMPTY));\n        \n        // Set a control tag to see if it reflects correctly\n        unsafe {\n            raw_table.ctrl(0).write(Tag::full(42)); // Set a control tag\n        }\n\n        assert_eq!(unsafe { *raw_table.ctrl(0) }, Tag::full(42));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582879, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=298, prompt_tokens=16361, total_tokens=16659, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZkPRLGd5qIyUJpBsMePyHa7Brt', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use std::ptr::NonNull;\n    use super::*;\n\n    #[test]\n    fn test_data_end() {\n        // Setup\n        let buckets = 8; // Example bucket size\n        let alloc = std::alloc::System; // Example allocator (change if necessary)\n        let table_layout = TableLayout::new(); // Set up the table layout based on requirements\n        let mut raw_table_inner = RawTableInner::with_capacity(&alloc, table_layout, buckets);\n\n        // The control pointer must not be null\n        let data_end_ptr: NonNull<u8> = raw_table_inner.data_end::<u8>();\n        assert!(!data_end_ptr.as_ptr().is_null());\n\n        // We can check if the pointer is properly aligned, but there is no guarantee we can access this memory safely\n        // (the internal data structure is not initialized, but we can assume control is set)\n        let control_ptr: *mut u8 = raw_table_inner.ctrl.as_ptr();\n\n        // Validate the pointer arithmetic\n        assert_eq!(data_end_ptr.as_ptr() as usize, control_ptr as usize);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582888, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=242, prompt_tokens=16361, total_tokens=16603, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmZr9k7qPaQMV3yt46gWqWlp8enc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use crate::layout::TableLayout;\n\n    #[test]\n    fn test_drop_elements_empty() {\n        unsafe {\n            let mut raw_table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible).unwrap();\n            raw_table.items = 0;\n            raw_table.drop_elements::<u32>();\n            // Should not panic, as items is 0\n        }\n    }\n\n    #[test]\n    fn test_drop_elements_non_empty() {\n        unsafe {\n            let mut raw_table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible).unwrap();\n            raw_table.items = 1;\n            // Mock an inserted item\n            raw_table.ctrl = NonNull::new_unchecked(std::ptr::null_mut()); // this would ideally be the memory where your items would be\n            raw_table.drop_elements::<u32>();\n            // Should call the drop for each item, so the test doesn\'t panic\n        }\n    }\n\n    #[test]\n    fn test_drop_elements_needs_drop() {\n        struct DropMe;\n        impl Drop for DropMe {\n            fn drop(&mut self) {\n                // drop panics\n                panic!("Dropped");\n            }\n        }\n\n        unsafe {\n            let mut raw_table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible).unwrap();\n            raw_table.items = 1;\n            // We need a memory block where the DropMe type is stored\n            // Let\'s assume we correctly allocated memory for the items\n            raw_table.ctrl = NonNull::new_unchecked(std::ptr::null_mut()); // Mock the control structure\n            // raw_table.items would be 1, we will drop and expect a panic\n            std::panic::set_hook(Box::new(|_| {\n                // We expect a panic here\n            }));\n            raw_table.drop_elements::<DropMe>();\n        }\n    }\n\n    #[test]\n    fn test_drop_elements_no_needs_drop() {\n        unsafe {\n            let mut raw_table = RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible).unwrap();\n            raw_table.items = 1;\n            raw_table.drop_elements::<u32>(); // Should not panic, as u32 does not need drop\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582895, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=521, prompt_tokens=16361, total_tokens=16882, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcma58T81Wv0CpysciDE2wlXtAY9E', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_drop_inner_table_empty() {\n        let mut raw_table_inner = RawTableInner {\n            bucket_mask: 0,\n            ctrl: NonNull::new(std::ptr::null_mut()).unwrap(),\n            growth_left: 0,\n            items: 0,\n        };\n        let layout = TableLayout::default(); // Replace with actual default layout\n        unsafe {\n            raw_table_inner.drop_inner_table::<u8, Global>(&Global, layout);\n        }\n    }\n\n    #[test]\n    fn test_drop_inner_table_with_elements() {\n        let mut raw_table_inner = RawTableInner {\n            bucket_mask: 3,\n            ctrl: NonNull::new(Box::into_raw(Box::new([0u8; 4]))).unwrap(),\n            growth_left: 1,\n            items: 2,\n        };\n        let layout = TableLayout::default(); // Replace with actual default layout\n        unsafe {\n            raw_table_inner.drop_inner_table::<u8, Global>(&Global, layout);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_drop_inner_table_panic_on_double_drop() {\n        let mut raw_table_inner = RawTableInner {\n            bucket_mask: 3,\n            ctrl: NonNull::new(Box::into_raw(Box::new([0u8; 4]))).unwrap(),\n            growth_left: 1,\n            items: 2,\n        };\n        let layout = TableLayout::default(); // Replace with actual default layout\n        unsafe {\n            raw_table_inner.drop_inner_table::<u8, Global>(&Global, layout);\n            raw_table_inner.drop_inner_table::<u8, Global>(&Global, layout);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582909, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=376, prompt_tokens=16361, total_tokens=16737, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmaHAPeTzp9F4DxcFqZmKfMxvQ0l', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_erase_bucket() {\n        unsafe {\n            // Create a new RawTableInner with at least one bucket\n            let mut table = RawTableInner::with_capacity(&Global, TableLayout::default(), 4);\n            let index = 0; // Assuming we want to erase the first index\n\n            // Initialize control bytes to FULL\n            table.set_ctrl(index, Tag::FULL);\n            table.items = 1;\n\n            // Ensure the bucket is full before erasing\n            assert!(table.is_bucket_full(index));\n\n            // Perform the erase operation\n            table.erase(index);\n\n            // Assert the control byte at the index is now EMPTY or DELETED\n            assert!(!table.is_bucket_full(index));\n            assert_eq!(table.items, 0);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_erase_invalid_index() {\n        unsafe {\n            let mut table = RawTableInner::with_capacity(&Global, TableLayout::default(), 4);\n            let index = 10; // Invalid index\n\n            // Attempt to erase at an invalid index, should panic\n            table.erase(index);\n        }\n    }\n\n    #[test]\n    fn test_erase_non_full_bucket() {\n        unsafe {\n            let mut table = RawTableInner::with_capacity(&Global, TableLayout::default(), 4);\n            let index = 0;\n\n            // Initialize control byte to EMPTY\n            table.set_ctrl(index, Tag::EMPTY);\n            table.items = 1;\n\n            // Perform erase operation on a non-full bucket\n            table.erase(index);\n\n            // Assert that items is decremented\n            assert_eq!(table.items, 0);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582921, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=376, prompt_tokens=16361, total_tokens=16737, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmaQxNCVVR2o8PQy6QUV8oCiwQD5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::alloc::Layout;\n    use hashbrown::raw::{Fallibility, TableLayout, RawTableInner};\n    use std::alloc::AllocErr;\n    \n    #[test]\n    fn test_fallible_with_capacity_zero_capacity() {\n        let alloc = &Global;\n        let layout = TableLayout::new::<u8>();\n        let result = RawTableInner::fallible_with_capacity(alloc, layout, 0, Fallibility::Fallible);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_fallible_with_capacity_non_zero_capacity() {\n        let alloc = &Global;\n        let layout = TableLayout::new::<u8>();\n        let capacity = 4; // change this as needed\n        let result = RawTableInner::fallible_with_capacity(alloc, layout, capacity, Fallibility::Fallible);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_fallible_with_capacity_capacity_overflow() {\n        let alloc = &Global;\n        let layout = TableLayout::new::<u8>();\n        let capacity = usize::MAX; // This should trigger a capacity overflow error\n        let result = RawTableInner::fallible_with_capacity(alloc, layout, capacity, Fallibility::Fallible);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_fallible_with_capacity_infallible_capacity_overflow() {\n        let alloc = &Global;\n        let layout = TableLayout::new::<u8>();\n        let capacity = usize::MAX; // This should panic on overflow\n        let _ = RawTableInner::fallible_with_capacity(alloc, layout, capacity, Fallibility::Infallible);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582930, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=402, prompt_tokens=1010, total_tokens=1412, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmafLDug9hHZlqtyeg6Xq8C12nAp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_find_inner() {\n        // Create an allocator and raw table inner instance\n        let allocator = System;\n        let table_layout = TableLayout::default();\n        let mut raw_table = unsafe {\n            RawTableInner::with_capacity(&allocator, table_layout, 4)\n        };\n\n        // Simulate adding items to the raw table\n        let hash = 42; // Arbitrary hash value\n        unsafe {\n            raw_table.set_ctrl_hash(0, Tag::full(hash));\n            raw_table.set_ctrl_hash(1, Tag::full(hash));\n        }\n\n        // Define an equality function\n        let mut eq = |index| {\n            // Match against index for the test\n            index == 0 || index == 1\n        };\n\n        // Test find function\n        unsafe {\n            let found_0 = raw_table.find_inner(hash, &mut eq);\n            assert_eq!(found_0, Some(0));\n            let found_1 = raw_table.find_inner(hash, &mut eq);\n            assert_eq!(found_1, Some(1));\n            let found_none = raw_table.find_inner(99, &mut eq); // Try a hash that isn't present\n            assert_eq!(found_none, None);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_find_inner_panic_on_empty_table() {\n        let allocator = System;\n        let table_layout = TableLayout::default();\n        let raw_table = unsafe {\n            RawTableInner::with_capacity(&allocator, table_layout, 0)\n        };\n\n        // Defining an equality function\n        let mut eq = |_| false;\n\n        // This should panic since there are no empty buckets\n        unsafe {\n            let _ = raw_table.find_inner(0, &mut eq);\n        }\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582945, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=398, prompt_tokens=16361, total_tokens=16759, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmapaRuHiSaPQTQO7goYbn51WXvr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_find_insert_slot() {\n        unsafe {\n            let capacity = 8; // Must be power of two\n            let mut raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), capacity);\n            raw_table.ctrl_slice().fill_empty(); // Initialize with empty control bytes\n\n            // Simulate inserting elements to create an empty slot\n            let hash1 = 1u64; // Any arbitrary hash for testing\n            let hash2 = 2u64;\n\n            let slot1 = raw_table.prepare_insert_slot(hash1);\n            raw_table.ctrl(slot1.0).write(Tag::full(hash1));\n\n            let slot2 = raw_table.prepare_insert_slot(hash2);\n            raw_table.ctrl(slot2.0).write(Tag::full(hash2));\n\n            // Make one slot empty again (simulated deletion)\n            raw_table.ctrl(slot1.0).write(Tag::empty());\n\n            // Now call `find_insert_slot` and expect to find an empty slot where we deleted previously\n            let insert_slot = raw_table.find_insert_slot(0);\n            assert!(insert_slot.index == slot1.index); // Should find the previously empty slot\n        }\n    }\n\n    #[test]\n    fn test_find_insert_slot_empty_table() {\n        unsafe {\n            let capacity = 8; // Must be power of two\n            let mut raw_table = RawTableInner::with_capacity(&Global, TableLayout::default(), capacity);\n            raw_table.ctrl_slice().fill_empty(); // Initialize with empty control bytes\n\n            // The table is empty, so we should find an empty slot\n            let insert_slot = raw_table.find_insert_slot(0);\n            assert!(insert_slot.index < raw_table.buckets());\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582955, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=384, prompt_tokens=16361, total_tokens=16745, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmazgvLeLonyeHsvfVFN16zKNS1v', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_find_insert_slot_in_group() {\n        // Set up a mock `RawTableInner` with a known bucket mask and a group\n        let bucket_mask = 7; // example mask\n        let group = Group::static_empty(); // mock empty group\n        let probe_seq = ProbeSeq { pos: 0, stride: 0 };\n\n        let raw_table_inner = RawTableInner {\n            bucket_mask,\n            ctrl: NonNull::new(std::ptr::null_mut()).unwrap(), // mock ctrl\n            growth_left: 0,\n            items: 0,\n        };\n\n        // Mock the group to return a specific BitMask\n        let bitmask = group.match_empty_or_deleted().lowest_set_bit();\n        let expected_index = (probe_seq.pos + bitmask.unwrap_or(0)) & bucket_mask;\n\n        // Call the target function\n        let result = raw_table_inner.find_insert_slot_in_group(&group, &probe_seq);\n\n        // Check the result\n        assert_eq!(result, Some(expected_index), "Expected index: {:?}", expected_index);\n    }\n\n    #[test]\n    fn test_find_insert_slot_in_group_none() {\n        // Set up a mock `RawTableInner` and group with no empty slots\n        let bucket_mask = 7; // example mask with no empty slots\n        let group = Group::static_empty(); // For a full group, no empty sections\n        let probe_seq = ProbeSeq { pos: 0, stride: 0 };\n\n        let raw_table_inner = RawTableInner {\n            bucket_mask,\n            ctrl: NonNull::new(std::ptr::null_mut()).unwrap(), // mock ctrl\n            growth_left: 0,\n            items: 0,\n        };\n\n        // Call the target function\n        let result = raw_table_inner.find_insert_slot_in_group(&group, &probe_seq);\n\n        // Check the result\n        assert_eq!(result, None, "Expected None when no slots available");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582965, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=436, prompt_tokens=16361, total_tokens=16797, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmbEolQISejTz3wgPXuoKsjbSgKu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_find_or_find_insert_slot_inner() {\n        // Assuming you have a valid instance of RawTableInner\n        // For testing purposes, we will need to create a mock structure\n        // since RawTableInner is not trivially constructible.\n\n        let alloc = &Global; // Using the global allocator\n        let table_layout = TableLayout::default(); // Assuming a default layout\n        let capacity = 8; // A sample capacity\n        let mut table = unsafe {\n            RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Mocking the control bytes and adding elements to simulate the table\n        // (Control bytes should be initialized to a valid state)\n        unsafe {\n            table.ctrl_slice().fill(Tag::EMPTY);\n        }\n\n        let hash = 42; // Some hash value\n        let mut eq = |index: usize| -> bool {\n            index == 0 // Assuming the item we expect is at index 0\n        };\n\n        // Performing the operation\n        let result = unsafe {\n            table.find_or_find_insert_slot_inner(hash, &mut eq)\n        };\n\n        // Check the result\n        match result {\n            Ok(index) => {\n                assert_eq!(index, 0, "Expected to find element at index 0");\n            }\n            Err(insert_slot) => {\n                assert!(false, "Expected to find element, but got insert slot: {:?}", insert_slot);\n            }\n        }\n    }\n\n    #[test]\n    fn test_find_or_find_insert_slot_inner_with_no_empty_slot() {\n        // Assuming a scenario where there are no empty slots\n        let alloc = &Global;\n        let table_layout = TableLayout::default();\n        let capacity = 8;\n        let mut table = unsafe {\n            RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Fill the table to simulate a full state\n        unsafe {\n            table.ctrl_slice().fill(Tag::FULL);\n        }\n\n        let hash = 42;\n        let mut eq = |index: usize| -> bool {\n            index == 8 // Simulating a case where hash leads to a non-existing index\n        };\n\n        // Performing the operation\n        let result = unsafe {\n            table.find_or_find_insert_slot_inner(hash, &mut eq)\n        };\n\n        // Check the result\n        match result {\n            Ok(_) => {\n                assert!(false, "Expected no index found, but got a valid index");\n            }\n            Err(insert_slot) => {\n                assert!(insert_slot.index <= table.buckets(), "Expected insert slot index to be valid");\n            }\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582980, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=593, prompt_tokens=16361, total_tokens=16954, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmbPSpRwXOErG2vD9PwPk0zXXVpV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_fix_insert_slot() {\n        unsafe {\n            let table_layout = TableLayout::calculate_layout_for(8).unwrap(); // Example for 8 buckets\n            let mut raw_table = RawTableInner::fallible_with_capacity(&Global, table_layout, 8, Fallibility::Infallible).unwrap();\n\n            // Initializing control bytes\n            raw_table.ctrl_slice().fill_empty();\n\n            // Simulate a situation where the table has some full buckets\n            raw_table.set_ctrl(0, Tag::full(0)); // Mark bucket 0 as full\n            raw_table.set_ctrl(1, Tag::full(1)); // Mark bucket 1 as full\n            raw_table.set_ctrl(2, Tag::full(2)); // Mark bucket 2 as full\n            raw_table.set_ctrl(3, Tag::full(3)); // Mark bucket 3 as full\n\n            // Now let's find an insert slot\n            let probe_seq = raw_table.probe_seq(0); // Simulate a hash\n            let insert_slot = raw_table.find_insert_slot_in_group(&Group::load(raw_table.ctrl(0)), &probe_seq).unwrap();\n\n            // Now call fix_insert_slot on the insert_slot\n            let fixed_slot = raw_table.fix_insert_slot(insert_slot);\n\n            // Check that the fixed slot is valid\n            assert!(fixed_slot.index < raw_table.buckets());\n        }\n    }\n\n    #[test]\n    fn test_fix_insert_slot_with_full_buckets() {\n        unsafe {\n            let table_layout = TableLayout::calculate_layout_for(4).unwrap(); // Example for 4 buckets\n            let mut raw_table = RawTableInner::fallible_with_capacity(&Global, table_layout, 4, Fallibility::Infallible).unwrap();\n\n            // Initializing control bytes for a smaller table\n            raw_table.ctrl_slice().fill_empty();\n\n            // Mark all buckets as full\n            raw_table.set_ctrl(0, Tag::full(0));\n            raw_table.set_ctrl(1, Tag::full(1));\n            raw_table.set_ctrl(2, Tag::full(2));\n            raw_table.set_ctrl(3, Tag::full(3));\n\n            // Find insert slot\n            let probe_seq = raw_table.probe_seq(0);  // Simulate a hash\n            let insert_slot = raw_table.find_insert_slot_in_group(&Group::load(raw_table.ctrl(0)), &probe_seq).unwrap();\n\n            // Call fix_insert_slot\n            let fixed_slot = raw_table.fix_insert_slot(insert_slot);\n\n            // Here fixed_slot.index should return a valid slot, which is 0, 1, 2 or 3 for a case with full buckets\n            assert!(fixed_slot.index < raw_table.buckets());\n        }\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748582991, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=599, prompt_tokens=16361, total_tokens=16960, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmbbhHIRfFIA31btJgQxBCWN3C71', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::{GlobalAlloc, Layout, System};\n    use std::ptr::null_mut;\n\n    struct MockAllocator;\n\n    unsafe impl Allocator for MockAllocator {\n        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, std::alloc::AllocErr> {\n            unsafe { NonNull::new(std::alloc::alloc(layout)).ok_or(std::alloc::AllocErr) }\n        }\n\n        unsafe fn deallocate(&self, ptr: *mut u8, layout: Layout) {\n            std::alloc::dealloc(ptr, layout);\n        }\n    }\n\n    #[test]\n    fn test_free_buckets() {\n        unsafe {\n            let alloc = MockAllocator;\n            let table_layout = TableLayout::new(/* parameters */); // Add appropriate parameters\n            let mut inner = RawTableInner::new_uninitialized(&alloc, table_layout, /* buckets */ 8, /* fallibility */ Fallibility::Infallible).unwrap();\n\n            // Ensure the inner is properly allocated\n            assert!(!inner.ctrl.as_ptr().is_null());\n\n            // Perform the free_buckets operation\n            inner.free_buckets(&alloc, table_layout);\n            \n            // Verify that memory is deallocated properly\n            // This part is tricky, it's often hard to verify in tests directly\n            // We would check that the `inner` is in a state that suggests\n            // the memory has been freed, for example by checking that\n            // the control pointer is now invalid or similar rules.\n\n            // Ensure control pointer is now pointing to a deallocated memory\n            assert!(inner.ctrl.as_ptr().is_null()); // Mock behavior, adjust condition\n        }\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583003, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=363, prompt_tokens=16361, total_tokens=16724, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmboj6iS0hDVqWLvY72pHlyLVTH3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_full_buckets_indices() {\n        // Setup phase\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 16, Fallibility::Infallible)\n                .unwrap()\n        };\n\n        // Simulate inserting items\n        unsafe {\n            // Manually set control bytes to simulate full buckets\n            for i in 0..16 {\n                let tag = Tag::full(0);\n                raw_table.set_ctrl(i, tag);\n            }\n            raw_table.items = 16;\n        }\n\n        // Iteration test\n        let mut full_buckets_indices = unsafe { raw_table.full_buckets_indices() };\n\n        // Collect the result for assertion\n        let indices: Vec<usize> = full_buckets_indices.by_ref().collect();\n        \n        // Check the correctness: We expect indices to be 0..15\n        assert_eq!(indices, (0..16).collect::<Vec<_>>());\n        \n        // Check the size hint\n        assert_eq!(full_buckets_indices.size_hint(), (0, Some(0)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583016, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=265, prompt_tokens=16361, total_tokens=16626, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmc0605vM89Ams7oCbtq64hRwPbJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System;\n\n    #[test]\n    fn test_is_bucket_full() {\n        let alloc = System;\n        let table_layout = TableLayout::default(); // Assume you have this setup\n        let capacity = 4; // A small capacity for testing\n        let mut table = unsafe {\n            RawTableInner::with_capacity(&alloc, table_layout, capacity)\n        };\n\n        // Assume that we fill the table to test is_bucket_full\n        let index_to_test = 0; // Test the first bucket\n        unsafe {\n            table.set_ctrl(index_to_test, Tag::full(0)); // Manually set full\n            assert!(table.is_bucket_full(index_to_test)); // Check that the bucket is full\n        }\n\n        unsafe {\n            table.set_ctrl(index_to_test, Tag::empty()); // Manually set empty\n            assert!(!table.is_bucket_full(index_to_test)); // Check that the bucket is not full\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_is_bucket_full_out_of_bounds() {\n        let alloc = System;\n        let table_layout = TableLayout::default(); // Assume you have this setup\n        let capacity = 4; // A small capacity for testing\n        let table = unsafe {\n            RawTableInner::with_capacity(&alloc, table_layout, capacity)\n        };\n\n        // Test out of bounds index, should panic\n        unsafe {\n            table.is_bucket_full(capacity); // This should panic\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583028, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=328, prompt_tokens=16361, total_tokens=16689, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcBPftv4TjF5kOTTcxKx8kP5wLI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_is_empty_singleton() {\n        let raw_table = RawTableInner {\n            bucket_mask: 0,\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n        assert!(raw_table.is_empty_singleton());\n\n        let raw_table_non_empty = RawTableInner {\n            bucket_mask: 1,\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n        assert!(!raw_table_non_empty.is_empty_singleton());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583039, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=145, prompt_tokens=16361, total_tokens=16506, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcHmW8QJoMDIW2WHZMQeMDPKHDm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_is_in_same_group() {\n        let mut table = RawTableInner {\n            bucket_mask: 15,  // Example: 16 buckets\n            ctrl: NonNull::dangling(),\n            growth_left: 0,\n            items: 0,\n        };\n        \n        let hash: u64 = 123456;\n\n        // Mock: Assume `probe_seq()` returns 0 for hash 123456\n        let probe_seq_pos = table.probe_seq(hash).pos;\n\n        // These would be in the same group if their indices were the same modulo `Group::WIDTH`\n        let same_group_i = 0;\n        let same_group_new_i = 4; // Assume `Group::WIDTH` is 4\n        let not_same_group_new_i = 5; // Different group\n\n        // Test for indices in the same group\n        assert!(table.is_in_same_group(same_group_i, same_group_new_i, hash));\n\n        // Test for indices not in the same group\n        assert!(!table.is_in_same_group(same_group_i, not_same_group_new_i, hash));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583045, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=261, prompt_tokens=16361, total_tokens=16622, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcTKd1NOIPzN5RbNWSRJXbHJLn4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_table_iter_empty() {\n        let mut table: RawTableInner = RawTableInner::new_uninitialized(/* allocations and parameters need to be adjusted appropriately */);\n        let iter: RawIter<i32> = unsafe { table.iter() };\n        assert_eq!(iter.count(), 0);\n    }\n\n    #[test]\n    fn test_raw_table_iter_single_element() {\n        let mut table: RawTableInner = RawTableInner::new_uninitialized(/* allocations and parameters need to be adjusted appropriately */);\n        // Insert an element into the table's raw structure appropriately\n        let value = 42; // example value\n        unsafe { table.insert(/* params to insert the value */) };\n\n        let iter: RawIter<i32> = unsafe { table.iter() };\n        let count: usize = iter.count();\n        assert_eq!(count, 1);\n    }\n\n    #[test]\n    fn test_raw_table_iter_multiple_elements() {\n        let mut table: RawTableInner = RawTableInner::new_uninitialized(/* allocations and parameters need to be adjusted appropriately */);\n        let values = vec![1, 2, 3, 4, 5];\n        \n        for &value in &values {\n            unsafe { table.insert(/* params to insert the value */) };\n        }\n\n        let iter: RawIter<i32> = unsafe { table.iter() };\n        let yielded_values: Vec<i32> = iter.map(|bucket| unsafe { bucket.as_ref() }).collect();\n        assert_eq!(yielded_values, values);\n    }\n\n    #[test]\n    fn test_raw_table_iter_with_deletions() {\n        let mut table: RawTableInner = RawTableInner::new_uninitialized(/* allocations and parameters need to be adjusted appropriately */);\n        let values = vec![1, 2, 3];\n        \n        for &value in &values {\n            unsafe { table.insert(/* params to insert the value */) };\n        }\n        \n        unsafe { table.erase(/* params to erase the second element */) };\n\n        let iter: RawIter<i32> = unsafe { table.iter() };\n        let yielded_values: Vec<i32> = iter.map(|bucket| unsafe { bucket.as_ref() }).collect();\n        assert_eq!(yielded_values, vec![/* first value, third value */]);\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583057, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=504, prompt_tokens=16361, total_tokens=16865, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmchfeoTqqm8QBXNHrt0Od7CRTW9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_raw_table_inner_new() {\n        let table = RawTableInner::new();\n\n        assert_eq!(table.bucket_mask, 0);\n        assert_eq!(table.items, 0);\n        assert_eq!(table.growth_left, 0);\n        assert!(!table.ctrl.as_ptr().is_null());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583071, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=95, prompt_tokens=16361, total_tokens=16456, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmclmHeC8EU2HN2tD88SyTzzUBEl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_new_uninitialized_valid() {\n        let fallibility = Fallibility::Fallible;\n        let layout = TableLayout::new::<u32>();\n        let buckets = 8; // Must be a power of two\n\n        let result = unsafe {\n            raw::RawTableInner::new_uninitialized(&Global, layout, buckets, fallibility)\n        };\n\n        assert!(result.is_ok());\n        let table = result.unwrap();\n        assert_eq!(table.bucket_mask, buckets - 1);\n        assert_eq!(table.items, 0);\n        // Additional tests can be added to validate table properties\n    }\n\n    #[test]\n    fn test_new_uninitialized_invalid_buckets() {\n        let fallibility = Fallibility::Fallible;\n        let layout = TableLayout::new::<u32>();\n        let buckets = 7; // Not a power of two\n\n        let result = unsafe {\n            raw::RawTableInner::new_uninitialized(&Global, layout, buckets, fallibility)\n        };\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_new_uninitialized_capacity_overflow() {\n        let fallibility = Fallibility::Fallible;\n        let layout = TableLayout::new::<u32>();\n        let buckets = usize::MAX; // Attempting to allocate maximum buckets\n\n        let result = unsafe {\n            raw::RawTableInner::new_uninitialized(&Global, layout, buckets, fallibility)\n        };\n\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583075, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=349, prompt_tokens=1067, total_tokens=1416, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmcvCjtuMqHAjNWSh3w9jX43lEZl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr::NonNull;\n\n    #[test]\n    fn test_num_ctrl_bytes() {\n        let bucket_mask = 3; // Example mask, so buckets = 4 (3 + 1)\n        let group_width = 4;  // Example group width\n        let instance = RawTableInner {\n            bucket_mask,\n            ctrl: NonNull::new(std::ptr::null_mut()).unwrap(),\n            growth_left: 0,\n            items: 0,\n        };\n\n        // Assuming Group::WIDTH = group_width\n        let expected_ctrl_bytes = bucket_mask + 1 + group_width;\n        let actual_ctrl_bytes = instance.num_ctrl_bytes();\n\n        assert_eq!(actual_ctrl_bytes, expected_ctrl_bytes);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583085, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=167, prompt_tokens=16361, total_tokens=16528, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmd2uPEoQJvR1O3bYvrM2ugciHwJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::ptr::NonNull;\n\n    #[test]\n    fn test_prepare_insert_slot() {\n        // Create a mock allocator\n        struct MockAllocator;\n\n        // Define a dummy allocator for testing\n        impl Allocator for MockAllocator {\n            fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n                // Allocate enough space for control bytes\n                let size = layout.size();\n                let ptr = unsafe { core::alloc::alloc(layout) };\n                if ptr.is_null() {\n                    return Err(AllocErr::unable_to_allocate(layout));\n                }\n                Ok(unsafe { NonNull::new_unchecked(ptr) })\n            }\n\n            fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n                unsafe { core::alloc::dealloc(ptr.as_ptr(), layout) }\n            }\n        }\n\n        let allocator = MockAllocator;\n        let layout = TableLayout::default();\n        let capacity = 8; // for testing, 8 buckets\n        let mut raw_table = unsafe {\n            RawTableInner::fallible_with_capacity(&allocator, layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Initialize control bytes with EMPTY\n        unsafe {\n            raw_table.ctrl_slice().fill(Tag::EMPTY);\n        }\n\n        // Test inserting a value\n        for hash in 0..10 {\n            let (index, old_ctrl) = unsafe { raw_table.prepare_insert_slot(hash) };\n\n            // Check that the index returned is within the bounds of the raw_table\n            assert!(index <= raw_table.bucket_mask);\n            assert!(index < raw_table.buckets());\n\n            // Check if the control byte is changed properly\n            if old_ctrl == Tag::EMPTY {\n                assert_eq!(raw_table.ctrl(index), Tag::full(hash));\n            }\n        }\n    }\n\n    #[test]\n    fn test_prepare_insert_slot_with_deleted() {\n        // Same setup as the previous test\n        struct MockAllocator;\n\n        impl Allocator for MockAllocator {\n            fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n                let ptr = unsafe { core::alloc::alloc(layout) };\n                if ptr.is_null() {\n                    return Err(AllocErr::unable_to_allocate(layout));\n                }\n                Ok(unsafe { NonNull::new_unchecked(ptr) })\n            }\n\n            fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n                unsafe { core::alloc::dealloc(ptr.as_ptr(), layout) }\n            }\n        }\n\n        let allocator = MockAllocator;\n        let layout = TableLayout::default();\n        let capacity = 8; // for testing, 8 buckets\n        let mut raw_table = unsafe {\n            RawTableInner::fallible_with_capacity(&allocator, layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Initialize control bytes with EMPTY\n        unsafe {\n            raw_table.ctrl_slice().fill(Tag::EMPTY);\n        }\n\n        // Set a slot to DELETED\n        unsafe {\n            raw_table.set_ctrl(0, Tag::DELETED);\n        }\n        \n        // Test inserting a value after a DELETED slot\n        let (index, old_ctrl) = unsafe { raw_table.prepare_insert_slot(1234) };\n        assert!(index <= raw_table.bucket_mask);\n        assert!(index < raw_table.buckets());\n        assert_eq!(old_ctrl, Tag::DELETED);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583092, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=728, prompt_tokens=16361, total_tokens=17089, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmdKY2eLoFs8lokBc7JO7NIpe2m8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Allocator;\n\n    struct TestAllocator;\n\n    unsafe impl Allocator for TestAllocator {\n        // Implement required methods for the Allocator trait...\n    }\n\n    #[test]\n    fn test_prepare_rehash_in_place() {\n        unsafe {\n            // Arrange\n            let alloc = TestAllocator;\n            let table_layout = /* Initialize your TableLayout here */;\n            let mut raw_table: RawTableInner = RawTableInner::fallible_with_capacity(&alloc, table_layout, 16, Fallibility::Infallible)\n                .expect("Failed to create RawTableInner");\n            \n            // Initialize control bytes to simulate a state with FULL and DELETED entries.\n            for index in 0..16 {\n                // Assume Tag is an enum and FULL and DELETED variants are defined\n                let tag = if index % 2 == 0 { Tag::FULL } else { Tag::DELETED };\n                raw_table.set_ctrl(index, tag);\n            }\n\n            // Act\n            raw_table.prepare_rehash_in_place();\n\n            // Assert\n            for index in 0..16 {\n                let tag = *raw_table.ctrl(index);\n                // Check if FULL was converted to DELETED and DELETED to EMPTY\n                if index % 2 == 0 {\n                    assert_eq!(tag, Tag::DELETED);\n                } else {\n                    assert_eq!(tag, Tag::EMPTY);\n                }\n            }\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583110, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=308, prompt_tokens=16361, total_tokens=16669, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmeRmrQ565fQbX9XlOR81Um5D48i', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::mem::ManuallyDrop;\n\n    #[test]\n    fn test_prepare_resize_success() {\n        // Create a raw table inner with some initial capacity\n        let table_layout = TableLayout::default(); // Assuming a default layout\n        let initial_capacity = 4;\n        let alloc = &Global;\n        let mut raw_table = RawTableInner::with_capacity(alloc, table_layout, initial_capacity);\n\n        // Fill with some items\n        raw_table.items = 2; // Assume some items already present\n        \n        // Prepare for resizing\n        let new_capacity = 8;\n        let fallibility = Fallibility::Fallible;\n\n        // Run prepare_resize\n        let result = raw_table.prepare_resize(alloc, table_layout, new_capacity, fallibility);\n\n        // Check that result is Ok\n        assert!(result.is_ok());\n\n        // Check that we have the expected new table\n        let scope_guard = result.unwrap();\n        assert_eq!(scope_guard.new_table.items, 0); // New table should be empty\n    }\n\n    #[test]\n    fn test_prepare_resize_capacity_overflow() {\n        // Create a raw table inner with capacity\n        let table_layout = TableLayout::default();\n        let initial_capacity = 4;\n        let alloc = &Global;\n        let mut raw_table = RawTableInner::with_capacity(alloc, table_layout, initial_capacity);\n\n        // Fill with items\n        raw_table.items = 2; // Assume some items present\n        \n        // Prepare for resizing with a capacity that would cause overflow\n        let new_capacity = usize::MAX; // This is deliberately large\n        let fallibility = Fallibility::Fallible;\n\n        // Run prepare_resize\n        let result = raw_table.prepare_resize(alloc, table_layout, new_capacity, fallibility);\n\n        // Check that result is Err\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_prepare_resize_requirements() {\n        let table_layout = TableLayout::default();\n        let initial_capacity = 4;\n        let alloc = &Global;\n        let raw_table = RawTableInner::with_capacity(alloc, table_layout, initial_capacity);\n\n        // Create a new table layout that is incompatible\n        let incompatible_layout = TableLayout::default(); // Assuming a different layout for test\n\n        let new_capacity = 8;\n        let fallibility = Fallibility::Fallible;\n\n        // Check that prepare_resize is invoked with incompatible layout\n        let result = raw_table.prepare_resize(alloc, incompatible_layout, new_capacity, fallibility);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_prepare_resize_fallible() {\n        let table_layout = TableLayout::default();\n        let initial_capacity = 4;\n        let alloc = &Global;\n        let mut raw_table = RawTableInner::with_capacity(alloc, table_layout, initial_capacity);\n\n        // Fill with some items\n        raw_table.items = 2;\n\n        // Prepare for resizing with a fallible allocation\n        let new_capacity = 8;\n        let fallibility = Fallibility::Fallible;\n\n        // Simulate allocation failure\n        let result = raw_table.prepare_resize(alloc, table_layout, new_capacity, fallibility);\n        \n        // Check that it is an Err\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583179, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=709, prompt_tokens=16361, total_tokens=17070, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmefY9DCuDiR3zrfXkv7rBHW1UCr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_probe_seq() {\n        // Arrange\n        let alloc = &Global;\n        let table_layout = TableLayout::default(); // Use a default layout or appropriate setup\n        let capacity = 4; // Ensure a small initial capacity\n        let mut raw_table = unsafe {\n            RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Assume we have filled the table with data before testing probe_seq\n        // For the purposes of this test, we will use dummy data or just\n        // test the iterator functionality of probe_seq directly.\n\n        let hash = 42; // Arbitrary hash\n        let probe_seq = raw_table.probe_seq(hash);\n\n        // Act\n        let initial_pos = probe_seq.pos;\n\n        // We will call `move_next` a few times based on the width of the group\n        let mut mutable_probe_seq = probe_seq;\n        let bucket_mask = raw_table.bucket_mask;\n\n        for _ in 0..=bucket_mask {\n            mutable_probe_seq.move_next(bucket_mask);\n            // Check the behavior of the position\n            // Expect it to not exceed the bounds\n            assert!(mutable_probe_seq.pos <= bucket_mask);\n        }\n    }\n    \n    #[test]\n    fn test_probe_seq_no_empty_buckets() {\n        // Arrange\n        let alloc = &Global;\n        let table_layout = TableLayout::default(); // Use a default layout or appropriate setup\n        let capacity = 4; // Ensure a small initial capacity\n        let mut raw_table = unsafe {\n            RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible).unwrap()\n        };\n\n        // Fill the table to have no empty buckets\n        for i in 0..capacity {\n            let hash = i as u64; // Simulating the hash values as the index\n            let index = raw_table.find_insert_slot(hash).index;\n            unsafe {\n                raw_table.set_ctrl_hash(index, hash);\n            }\n        }\n\n        let hash = 42; // Arbitrary hash\n        let mut probe_seq = raw_table.probe_seq(hash);\n\n        // Act: Should continue to move, but we should not expect it to\n        // enter a group with empty buckets.\n        let mut found_empty = false;\n\n        for _ in 0..=raw_table.bucket_mask {\n            unsafe {\n                let group = Group::load(raw_table.ctrl(probe_seq.pos));\n                if group.match_empty().any_bit_set() { \n                    found_empty = true; // We should find empty bucket\n                    break;\n                }\n            }\n            probe_seq.move_next(raw_table.bucket_mask);\n        }\n\n        // Assert\n        assert!(found_empty, "No empty buckets found in probe sequence.");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583193, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=609, prompt_tokens=16361, total_tokens=16970, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmer5aZugyaCbHowuxi9rziBUwhN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    unsafe fn test_record_item_insert_at() {\n        let mut table = RawTableInner::with_capacity(&Global, TableLayout::default(), 8);\n        let index = 0;\n        let old_ctrl = Tag::EMPTY;\n        let hash = 12345;\n\n        // Pre-condition: table should have 0 items\n        assert_eq!(table.items, 0);\n        assert_eq!(table.growth_left, table.bucket_mask + 1);\n\n        // Call the function under test\n        table.record_item_insert_at(index, old_ctrl, hash);\n\n        // Post-condition: table should have 1 item\n        assert_eq!(table.items, 1);\n        assert_eq!(table.growth_left, table.bucket_mask);\n        assert!(table.ctrl(index).is_full());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583205, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=190, prompt_tokens=16361, total_tokens=16551, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmexZljYjMvDHcCOTBPFosM1u1me', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Allocator;\n    use std::ptr::NonNull;\n\n    struct MockAllocator;\n\n    impl Allocator for MockAllocator {\n        fn allocate(&self, layout: std::alloc::Layout) -> std::alloc::AllocResult<NonNull<u8>> {\n            // mock allocation logic\n        }\n        // Implement other allocator methods as needed...\n    }\n  \n    #[test]\n    fn test_rehash_in_place() {\n        let alloc = MockAllocator;\n        let layout = TableLayout::default(); // Assuming a default constructor\n\n        // Initialize RawTableInner\n        let mut table = unsafe {\n            RawTableInner::new_uninitialized(&alloc, layout, 16, Fallibility::Infallible).unwrap()\n        };\n\n        // Insert mock data into table and simulate a filled state\n        // ...\n\n        // Define a mock hasher\n        let hasher: Box<dyn Fn(&mut RawTableInner, usize) -> u64> = Box::new(|table, index| {\n            // mock hashing logic\n            index as u64 // Replace with appropriate hashing\n        });\n\n        unsafe {\n            // Call the rehash_in_place function\n            table.rehash_in_place(&*hasher, std::mem::size_of::<YourDataType>(), None);\n        }\n\n        // Assert the state of the table after rehashing\n        // ...\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583211, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=301, prompt_tokens=16361, total_tokens=16662, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmf6J3OzQloLXw8MilUO05oHgoi7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Layout;\n\n    #[test]\n    fn test_replace_ctrl_hash() {\n        // Define a suitable allocator\n        struct TestAllocator;\n\n        // Define a simple utility function to create a new RawTableInner\n        unsafe fn create_raw_table() -> RawTableInner {\n            let layout = Layout::new::<Tag>();\n            // Assume a safe allocator where allocation is successful\n            let alloc = TestAllocator;\n            let capacity = 8;\n            RawTableInner::with_capacity(&alloc, layout, capacity)\n        }\n\n        unsafe {\n            let mut table = create_raw_table();\n\n            // Set initial control hash for testing\n            let initial_hash = 42;\n            let index = 0;\n            let old_tag = table.replace_ctrl_hash(index, initial_hash);\n\n            // Check that the old control hash is the expected value (should be EMPTY)\n            assert_eq!(old_tag, Tag::EMPTY);\n\n            // Check that the new control hash has been set\n            assert!(table.is_bucket_full(index));\n\n            // Set another hash and check the old value returned\n            let new_hash = 84;\n            let old_tag = table.replace_ctrl_hash(index, new_hash);\n\n            // The old control hash should be the previous hash set (42)\n            assert_eq!(old_tag, Tag::full(initial_hash));\n\n            // Ensure the control hash is now the new hash\n            assert!(table.is_bucket_full(index));\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583220, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=312, prompt_tokens=16361, total_tokens=16673, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmfG2KfAyUHmbd4wooUSnBKhBxHn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::System; // Assuming System is used as Allocator\n    use std::ptr::null_mut;\n\n    #[test]\n    fn test_reserve_rehash_inner() {\n        let layout = TableLayout::default(); // Assuming a default layout is valid\n        let fallibility = Fallibility::Fallible; // Using fallible allocation\n        let alloc = System; // Using the default system allocator\n        \n        // Create a new RawTableInner with a small capacity to test rehashing\n        let mut table = unsafe {\n            RawTableInner::new_uninitialized(&alloc, layout, 4, fallibility).unwrap()\n        };\n\n        // Populate table (Assuming a method to insert items, omitted here)\n        // table.insert(1);\n        // table.insert(2);\n        \n        // Store the original items count\n        let original_items = table.items;\n\n        // Define a dummy hasher function\n        let hasher: &dyn Fn(&mut RawTableInner, usize) -> u64 = &|_, idx| idx as u64;\n\n        // Reserve with an additional count\n        let result = unsafe {\n            table.reserve_rehash_inner(&alloc, 2, hasher, fallibility, layout, None)\n        };\n\n        // Check if the result was OK\n        assert!(result.is_ok());\n\n        // Verify the items count is correctly updated\n        assert!(table.items > original_items);\n        \n        // Verify the table correctly resized if necessary (Assuming a method to check capacity)\n        // assert!(table.capacity() > 4);\n        \n        // Clean up the table (Assuming a drop method)\n        // unsafe { table.drop_inner_table::<i32>(&alloc, layout) };\n    }\n\n    #[test]\n    fn test_reserve_rehash_inner_overflow() {\n        let layout = TableLayout::default(); // Assuming a default layout is valid\n        let fallibility = Fallibility::Fallible; // Using fallible allocation\n        let alloc = System;\n\n        let mut table = unsafe {\n            RawTableInner::new_uninitialized(&alloc, layout, 4, fallibility).unwrap()\n        };\n\n        // Populate table (Assuming a method to insert items, omitted here)\n        // table.insert(1);\n        // table.insert(2);\n        \n        // Define a dummy hasher function\n        let hasher: &dyn Fn(&mut RawTableInner, usize) -> u64 = &|_, idx| idx as u64;\n\n        // Attempt to reserve an excessive amount\n        let result = unsafe {\n            table.reserve_rehash_inner(&alloc, usize::MAX, hasher, fallibility, layout, None)\n        };\n\n        // Since we're testing overflow, the result should be an Err\n        assert!(result.is_err());\n    }\n\n    // Additional tests can be added to test different edge cases as necessary.\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583230, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=607, prompt_tokens=16361, total_tokens=16968, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmfVJQg5VuVzehMXfD0H8Zb05IlQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::mem;\n\n    fn dummy_hasher(_: &mut RawTableInner, _: usize) -> u64 {\n        // A simple dummy hasher that always returns a fixed hash value.\n        0\n    }\n\n    #[test]\n    fn test_resize_inner() {\n        // Set up a RawTableInner with dummy data\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible)\n                .expect("Failed to create RawTableInner")\n        };\n\n        raw_table.items = 2; // Simulate 2 items currently in the table\n        raw_table.growth_left = 2; // Set growth_left to allow for growth\n        raw_table.bucket_mask = 3; // 4 buckets (2^2)\n        \n        // Resize the raw table\n        let result = unsafe {\n            raw_table.resize_inner(\n                &Global,\n                8, // Resize to 8 (double the size)\n                &dummy_hasher,\n                Fallibility::Infallible,\n                TableLayout::default(),\n            )\n        };\n\n        // Check result\n        assert!(result.is_ok());\n\n        // Ensure that the items count is correctly transferred\n        assert_eq!(raw_table.items, 2); // Still 2 items after resize\n        assert_eq!(raw_table.growth_left, 2); // Ensure growth_left remains unchanged\n    }\n\n    #[test]\n    fn test_resize_inner_invalid() {\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 4, Fallibility::Infallible)\n                .expect("Failed to create RawTableInner")\n        };\n\n        raw_table.items = 0; // No items currently in the table\n        raw_table.growth_left = 0; // No growth left\n        \n        // Attempt to resize to 0 capacity, should fail\n        let result = unsafe {\n            raw_table.resize_inner(\n                &Global,\n                0,\n                &dummy_hasher,\n                Fallibility::Infallible,\n                TableLayout::default(),\n            )\n        };\n\n        // Check result\n        assert!(result.is_err());\n\n        // Ensure the items count is still 0\n        assert_eq!(raw_table.items, 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583245, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=505, prompt_tokens=16361, total_tokens=16866, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmfgIKChGzN7JguoVEmY0Ih4Tm9F', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_set_ctrl() {\n        let buckets = 8; // Must be a power of two\n        let mut raw_table = unsafe {\n            RawTableInner::new_uninitialized(&Global, buckets, Fallibility::Infallible).unwrap()\n        };\n\n        // Safety: raw_table has been allocated and we are within valid index bounds\n        unsafe {\n            // Setting control bytes to EMPTY initially\n            for i in 0..raw_table.num_ctrl_bytes() {\n                raw_table.set_ctrl(i, Tag::EMPTY);\n            }\n        }\n\n        // Sanity check: confirm initial values are EMPTY\n        for i in 0..buckets {\n            unsafe {\n                assert_eq!(*raw_table.ctrl(i), Tag::EMPTY);\n            }\n        }\n\n        let index = 3; // Test index within bounds\n        let control = Tag::full(0x55); // Example control tag\n        \n        unsafe {\n            raw_table.set_ctrl(index, control);\n        }\n\n        // Verify the control has been set correctly\n        unsafe {\n            assert_eq!(*raw_table.ctrl(index), control);\n            assert_eq!(*raw_table.ctrl(((index.wrapping_sub(Group::WIDTH)) & raw_table.bucket_mask) + Group::WIDTH), control);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583256, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=287, prompt_tokens=16361, total_tokens=16648, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmfpbOfqmJiZC1rRGScN7X5FZuX9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_set_ctrl_hash() {\n        // Create a new `RawTableInner` instance with a specific capacity\n        let mut table_inner = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 8, Fallibility::Infallible).unwrap()\n        };\n\n        let index = 0;\n        let hash: u64 = 12345;\n\n        unsafe {\n            // Ensure `set_ctrl_hash` does not panic and sets control hash correctly\n            table_inner.set_ctrl_hash(index, hash);\n\n            // Verify that the control hash was set correctly\n            let control_value = *table_inner.ctrl(index);\n            assert_eq!(control_value, Tag::full(hash));\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_ctrl_hash_out_of_bounds() {\n        // Create a new `RawTableInner` instance with a small capacity\n        let mut table_inner = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 1, Fallibility::Infallible).unwrap()\n        };\n\n        let index = 2;  // Index out of bounds\n        let hash: u64 = 12345;\n\n        unsafe {\n            // This should panic as the index is out of bounds\n            table_inner.set_ctrl_hash(index, hash);\n        }\n    }\n\n    #[test]\n    fn test_set_ctrl_hash_empty_table() {\n        // Create a new `RawTableInner` that is empty\n        let mut table_inner = unsafe {\n            RawTableInner::new_uninitialized(&Global, TableLayout::default(), 0, Fallibility::Infallible).unwrap()\n        };\n\n        let index = 0;\n        let hash: u64 = 12345;\n\n        unsafe {\n            // Should not panic, as we are still within bounds (table is empty)\n            table_inner.set_ctrl_hash(index, hash);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583265, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=424, prompt_tokens=16361, total_tokens=16785, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmfyQNOX1GAN73Hiiq1M9mVStyXY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n    use std::alloc::Layout;\n    \n    #[test]\n    fn test_with_capacity_zero_elements() {\n        let layout = TableLayout::new(Layout::from_size_align(0, 1).unwrap());\n        let table = RawTableInner::with_capacity(&Global, layout, 0);\n        assert_eq!(table.items, 0);\n        assert!(table.bucket_mask == 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_with_capacity_exceeds_max() {\n        let layout = TableLayout::new(Layout::from_size_align(1, 1).unwrap());\n        RawTableInner::with_capacity(&Global, layout, usize::MAX);\n    }\n\n    #[test]\n    fn test_with_capacity_non_zero() {\n        let layout = TableLayout::new(Layout::from_size_align(1, 1).unwrap());\n        let capacity = 10;\n        let table = RawTableInner::with_capacity(&Global, layout, capacity);\n        assert!(table.items == 0);\n        assert!(table.bucket_mask >= capacity);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583274, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=244, prompt_tokens=16361, total_tokens=16605, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmg6BT7uPqEtRp0gDSEEAeNsh3SK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::alloc::Layout;\n\n    #[test]\n    fn test_calculate_layout_for_valid_power_of_two() {\n        let layout = TableLayout::new::<u8>();\n        let buckets = 8; // Power of two\n        let result = layout.calculate_layout_for(buckets);\n        assert!(result.is_some());\n        let (layout_result, offset) = result.unwrap();\n        assert_eq!(layout_result.size(), (layout.size * buckets) + offset);\n        assert!(layout_result.align() >= layout.ctrl_align);\n    }\n    \n    #[test]\n    fn test_calculate_layout_for_invalid_power_of_two() {\n        let layout = TableLayout::new::<u8>();\n        let buckets = 5; // Not a power of two\n        let result = layout.calculate_layout_for(buckets);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_calculate_layout_for_too_large_buckets() {\n        let layout = TableLayout::new::<u8>();\n        let buckets = (isize::MAX as usize / layout.size) + 1; // Intentional overflow\n        let result = layout.calculate_layout_for(buckets);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_calculate_layout_for_zero_buckets() {\n        let layout = TableLayout::new::<u8>();\n        let buckets = 0; // Zero buckets\n        let result = layout.calculate_layout_for(buckets);\n        assert!(result.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583282, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=323, prompt_tokens=689, total_tokens=1012, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgGUFw5yoTFCfb49jDi418vlFWy', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Layout;\n\n    #[test]\n    fn test_table_layout_new() {\n        // Test for a type with a specific size and alignment\n        let int_layout = TableLayout::new::<i32>();\n        assert_eq!(int_layout.size, Layout::new::<i32>().size());\n        assert_eq!(int_layout.ctrl_align, if Layout::new::<i32>().align() > Group::WIDTH {\n            Layout::new::<i32>().align()\n        } else {\n            Group::WIDTH\n        });\n\n        // Test for a type with a larger size and alignment\n        let double_layout = TableLayout::new::<f64>();\n        assert_eq!(double_layout.size, Layout::new::<f64>().size());\n        assert_eq!(double_layout.ctrl_align, if Layout::new::<f64>().align() > Group::WIDTH {\n            Layout::new::<f64>().align()\n        } else {\n            Group::WIDTH\n        });\n\n        // Test for a type with a different alignment\n        let char_layout = TableLayout::new::<char>();\n        assert_eq!(char_layout.size, Layout::new::<char>().size());\n        assert_eq!(char_layout.ctrl_align, if Layout::new::<char>().align() > Group::WIDTH {\n            Layout::new::<char>().align()\n        } else {\n            Group::WIDTH\n        });\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583292, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=296, prompt_tokens=554, total_tokens=850, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgPRo0ZKlhNB2HegNCKaZkJaqdZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::{GlobalAlloc, Layout};\n    use std::ptr::NonNull;\n\n    struct MockAllocator;\n\n    impl Allocator for MockAllocator {\n        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, AllocError> {\n            // Simulate successful allocation\n            let ptr = std::alloc::alloc(layout);\n            if ptr.is_null() {\n                Err(AllocError)\n            } else {\n                Ok(NonNull::new(ptr).unwrap())\n            }\n        }\n    }\n    \n    #[test]\n    fn test_do_alloc_success() {\n        let alloc = MockAllocator;\n        let layout = Layout::from_size_align(8, 1).unwrap();\n        let result = do_alloc(&alloc, layout);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_do_alloc_failure() {\n        struct FailingAllocator;\n\n        impl Allocator for FailingAllocator {\n            fn allocate(&self, _: Layout) -> Result<NonNull<u8>, AllocError> {\n                // Simulate allocation failure\n                Err(AllocError)\n            }\n        }\n\n        let alloc = FailingAllocator;\n        let layout = Layout::from_size_align(8, 1).unwrap();\n        let result = do_alloc(&alloc, layout);\n        assert!(result.is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583301, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=290, prompt_tokens=198, total_tokens=488, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgWCvN5JKGcO6XX5buT2pEbDw68', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::raw::bucket_mask_to_capacity;\n\n    #[test]\n    fn test_bucket_mask_to_capacity() {\n        assert_eq!(bucket_mask_to_capacity(0), 0);\n        assert_eq!(bucket_mask_to_capacity(1), 1);\n        assert_eq!(bucket_mask_to_capacity(3), 3);\n        assert_eq!(bucket_mask_to_capacity(7), 7);\n        assert_eq!(bucket_mask_to_capacity(8), 7);\n        assert_eq!(bucket_mask_to_capacity(15), 13);\n        assert_eq!(bucket_mask_to_capacity(16), 14);\n        assert_eq!(bucket_mask_to_capacity(31), 27);\n        assert_eq!(bucket_mask_to_capacity(32), 28);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583308, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=164, prompt_tokens=261, total_tokens=425, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgcMSRAB6TqCN99IhcKcZ4U1TQu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::raw::{capacity_to_buckets, TableLayout};\n\n    #[test]\n    fn test_capacity_to_buckets_small_capacity() {\n        let layout = TableLayout::new::<u8>();\n        assert_eq!(capacity_to_buckets(3, layout), Some(4));\n        assert_eq!(capacity_to_buckets(7, layout), Some(8));\n        assert_eq!(capacity_to_buckets(14, layout), Some(16));\n    }\n\n    #[test]\n    fn test_capacity_to_buckets_large_capacity() {\n        let layout = TableLayout::new::<u8>();\n        assert_eq!(capacity_to_buckets(15, layout), Some(16));\n        assert_eq!(capacity_to_buckets(16, layout), Some(16));\n        assert_eq!(capacity_to_buckets(32, layout), Some(64));\n        assert_eq!(capacity_to_buckets(64, layout), Some(128));\n    }\n\n    #[test]\n    fn test_capacity_to_buckets_overflow() {\n        let layout = TableLayout::new::<u8>();\n        assert_eq!(capacity_to_buckets(usize::MAX, layout), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583314, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=253, prompt_tokens=1200, total_tokens=1453, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgiQgf8hvcb6NCqMDmWTXuiouRT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::raw::h1;\n\n    #[test]\n    fn test_h1_on_32_bit() {\n        let hash: u64 = 0x123456789ABCDEF0;\n        let expected: usize = 0x789ABCDEF0 as usize;\n        let result = h1(hash);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_h1_on_64_bit() {\n        let hash: u64 = 0xFFFFFFFFFFFFFFFF;\n        let expected: usize = 0xFFFFFFFFFFFFFFFF as usize;\n        let result = h1(hash);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_h1_zero() {\n        let hash: u64 = 0;\n        let expected: usize = 0;\n        let result = h1(hash);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_h1_boundary() {\n        let hash: u64 = u64::MAX;\n        let expected: usize = u64::MAX as usize;\n        let result = h1(hash);\n        assert_eq!(result, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583320, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=251, prompt_tokens=188, total_tokens=439, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgoiyLLBQb3lFODynOCrvCuD1KB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_offset_from() {\n        let array = [1, 2, 3, 4];\n        let ptr_from = &array[0] as *const i32;\n        let ptr_to = &array[2] as *const i32;\n\n        // Calculate offset between ptr_to and ptr_from\n        let offset = unsafe { offset_from(ptr_to, ptr_from) };\n        \n        // Check that the offset is correct\n        assert_eq!(offset, 2 * std::mem::size_of::<i32>());\n    }\n\n    #[test]\n    fn test_offset_from_same_pointer() {\n        let array = [1, 2, 3, 4];\n        let ptr = &array[1] as *const i32;\n\n        // Calculate offset between the same pointer\n        let offset = unsafe { offset_from(ptr, ptr) };\n        \n        // Check that the offset is 0\n        assert_eq!(offset, 0);\n    }\n\n    #[test]\n    fn test_offset_from_negative_offset() {\n        let array = [1, 2, 3, 4];\n        let ptr_from = &array[2] as *const i32;\n        let ptr_to = &array[1] as *const i32;\n\n        // Calculate offset between ptr_to and ptr_from\n        let offset = unsafe { offset_from(ptr_to, ptr_from) };\n        \n        // Check that the offset is correct\n        assert_eq!(offset, -1 * std::mem::size_of::<i32>());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583326, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=344, prompt_tokens=161, total_tokens=505, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmgzJD5EOVtSG4HtsdvJ55Tzvyyx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use core::hash::{BuildHasher, Hash};\n\n    #[test]\n    fn test_raw_entry() {\n        let mut map = HashMap::new();\n        map.insert("a", 100);\n        map.insert("b", 200);\n        map.insert("c", 300);\n\n        fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n            use core::hash::Hasher;\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n\n        for k in ["a", "b", "c", "d", "e", "f"] {\n            let hash = compute_hash(map.hasher(), &k);\n            let v = map.get(&k).cloned();\n            let kv = v.as_ref().map(|v| (&k, v));\n\n            assert_eq!(map.raw_entry().from_key(&k), kv);\n            assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n            assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583337, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=274, prompt_tokens=16361, total_tokens=16635, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmh8Sbm1B5tFMpFI6mZd90Vgeu3O', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_map::HashMap;\n    use hashbrown::hash_map::RawEntryMut;\n    use core::hash::{BuildHasher, Hash};\n\n    #[test]\n    fn test_raw_entry_mut() {\n        let mut map = HashMap::new();\n        map.extend([("a", 100), ("b", 200), ("c", 300)]);\n\n        fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n            use core::hash::Hasher;\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n\n        // Existing key (insert and update)\n        match map.raw_entry_mut().from_key(&"a") {\n            RawEntryMut::Vacant(_) => unreachable!(),\n            RawEntryMut::Occupied(mut view) => {\n                assert_eq!(view.get(), &100);\n                let v = view.get_mut();\n                let new_v = (*v) * 10;\n                *v = new_v;\n                assert_eq!(view.insert(1111), 100);\n            }\n        }\n\n        assert_eq!(map[&"a"], 1110);\n        assert_eq!(map.len(), 3);\n\n        // Existing key (take)\n        let hash = compute_hash(map.hasher(), &"c");\n        match map.raw_entry_mut().from_key_hashed_nocheck(hash, &"c") {\n            RawEntryMut::Vacant(_) => unreachable!(),\n            RawEntryMut::Occupied(view) => {\n                assert_eq!(view.remove_entry(), ("c", 300));\n            }\n        }\n        assert_eq!(map.raw_entry().from_key(&"c"), None);\n        assert_eq!(map.len(), 2);\n\n        // Nonexistent key (insert and update)\n        let key = "d";\n        let hash = compute_hash(map.hasher(), &key);\n        match map.raw_entry_mut().from_hash(hash, |q| *q == key) {\n            RawEntryMut::Occupied(_) => unreachable!(),\n            RawEntryMut::Vacant(view) => {\n                let (k, value) = view.insert("d", 4000);\n                assert_eq!((*k, *value), ("d", 4000));\n                *value = 40000;\n            }\n        }\n        assert_eq!(map[&"d"], 40000);\n        assert_eq!(map.len(), 3);\n\n        match map.raw_entry_mut().from_hash(hash, |q| *q == key) {\n            RawEntryMut::Vacant(_) => unreachable!(),\n            RawEntryMut::Occupied(view) => {\n                assert_eq!(view.remove_entry(), ("d", 40000));\n            }\n        }\n        assert_eq!(map.get(&"d"), None);\n        assert_eq!(map.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583346, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=613, prompt_tokens=16361, total_tokens=16974, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmhKuENpGUWi8CIk8CUPJi3jSJOG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use core::hash::{BuildHasher, Hash};\n\n    fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n        use core::hash::Hasher;\n        let mut state = hash_builder.build_hasher();\n        key.hash(&mut state);\n        state.finish()\n    }\n\n    #[test]\n    fn test_from_hash_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n        map.insert("b", 200);\n        \n        let key = "a";\n        let hash = compute_hash(map.hasher(), &key);\n        let result = map.raw_entry().from_hash(hash, |k| k == &key);\n        assert_eq!(result, Some((&"a", &100)));\n    }\n\n    #[test]\n    fn test_from_hash_non_existing_entry() {\n        let map: HashMap<&str, u32> = HashMap::new();\n        let key = "x";\n        let hash = compute_hash(map.hasher(), &key);\n        let result = map.raw_entry().from_hash(hash, |k| k == &key);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_from_hash_with_custom_matcher() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("foo", 42);\n        \n        let hash = compute_hash(map.hasher(), &"foo");\n        let result = map.raw_entry().from_hash(hash, |k| k.starts_with("f"));\n        assert_eq!(result, Some((&"foo", &42)));\n    }\n\n    #[test]\n    fn test_from_hash_with_different_hash() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("test", 1);\n        \n        let hash = compute_hash(map.hasher(), &"different_key");\n        let result = map.raw_entry().from_hash(hash, |k| k == &"test");\n        assert_eq!(result, None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583358, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=472, prompt_tokens=16361, total_tokens=16833, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmhVDmYlU0KSY6TQQjfG1D9BBE5i', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_from_key_existing() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n        map.insert("b", 200);\n        \n        let key = "a";\n        assert_eq!(map.raw_entry().from_key(&key), Some((&"a", &100)));\n    }\n\n    #[test]\n    fn test_from_key_non_existing() {\n        let map: HashMap<&str, u32> = HashMap::new();\n        \n        let key = "c";\n        assert_eq!(map.raw_entry().from_key(&key), None);\n    }\n\n    #[test]\n    fn test_from_key_empty() {\n        let map: HashMap<&str, u32> = HashMap::new();\n        \n        let key = "a";\n        assert_eq!(map.raw_entry().from_key(&key), None);\n    }\n\n    #[test]\n    fn test_from_key_with_different_reference() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("test".to_string(), 150);\n        \n        let key = String::from("test");\n        assert_eq!(map.raw_entry().from_key(&key), Some((&"test".to_string(), &150)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583369, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=297, prompt_tokens=16361, total_tokens=16658, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmhj06bGgyJBChhmgKgKxEFVszP5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use core::hash::{BuildHasher, Hash};\n\n    fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n        let mut state = hash_builder.build_hasher();\n        key.hash(&mut state);\n        state.finish()\n    }\n\n    #[test]\n    fn test_from_key_hashed_nocheck() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n        map.insert("b", 200);\n        \n        let key = "a";\n        let hash = compute_hash(map.hasher(), &key);\n        \n        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &key), Some((&"a", &100)));\n    }\n\n    #[test]\n    fn test_from_key_hashed_nocheck_nonexistent() {\n        let map: HashMap<&str, u32> = HashMap::new();\n        let key = "nonexistent";\n        let hash = compute_hash(map.hasher(), &key);\n        \n        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &key), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583383, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=277, prompt_tokens=16361, total_tokens=16638, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmhsq71lTwzyjwFMGWUrbEi8VHEk', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_search_found() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n        let hash = hashbrown::HashMap::default().hasher().build_hasher().finish();\n        \n        let result = map.raw_entry().from_hash(hash, |k| *k == "key1");\n        assert!(result.is_some());\n        let (key, value) = result.unwrap();\n        assert_eq!(key, &"key1");\n        assert_eq!(value, &1);\n    }\n\n    #[test]\n    fn test_search_not_found() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n        let hash = hashbrown::HashMap::default().hasher().build_hasher().finish();\n        \n        let result = map.raw_entry().from_hash(hash, |k| *k == "key3");\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_search_with_custom_function() {\n        let mut map: HashMap<&str, i32> = HashMap::new();\n        map.insert("key1", 1);\n        map.insert("key2", 2);\n        \n        let result = map.raw_entry().from_key("key2");\n        assert!(result.is_some());\n        let (key, value) = result.unwrap();\n        assert_eq!(key, &"key2");\n        assert_eq!(value, &2);\n    }\n\n    #[test]\n    fn test_search_empty_map() {\n        let map: HashMap<&str, i32> = HashMap::new();\n        \n        let result = map.raw_entry().from_key("key1");\n        assert!(result.is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583392, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=419, prompt_tokens=16361, total_tokens=16780, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmi4xjsMcG4XWL3kk06Wf2MRaKYp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n    use core::hash::{BuildHasher, Hash};\n\n    #[test]\n    fn test_from_hash_insert_and_get() {\n        fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key = "test_key";\n        let hash = compute_hash(map.hasher(), &key);\n        \n        let entry = map.raw_entry_mut().from_hash(hash, |k| k == &key);\n        assert!(matches!(entry, RawEntryMut::Vacant(_)));\n        \n        let (k, v) = entry.insert(key, 42);\n        assert_eq!((*k, *v), (key, 42));\n        assert_eq!(map[key], 42);\n    }\n\n    #[test]\n    fn test_from_hash_existing_key() {\n        fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("key1", 1);\n        let hash = compute_hash(map.hasher(), &"key1");\n        \n        let entry = map.raw_entry_mut().from_hash(hash, |k| k == &"key1");\n        assert!(matches!(entry, RawEntryMut::Occupied(_)));\n        \n        if let RawEntryMut::Occupied(mut view) = entry {\n            assert_eq!(view.get(), &1);\n            let v = view.get_mut();\n            *v *= 2;\n            assert_eq!(map["key1"], 2);\n        }\n    }\n\n    #[test]\n    fn test_from_hash_non_existing_key() {\n        fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key = "new_key";\n        let hash = compute_hash(map.hasher(), &key);\n        \n        let entry = map.raw_entry_mut().from_hash(hash, |k| k == &key);\n        assert!(matches!(entry, RawEntryMut::Vacant(_)));\n\n        let (k, v) = entry.insert(key, 100);\n        assert_eq!((*k, *v), (key, 100));\n        assert_eq!(map[key], 100);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583404, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=623, prompt_tokens=16361, total_tokens=16984, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmiHXFTlha5rwtMhINSd4m6mceAu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n    use hashbrown::hash_map::RawEntryMut;\n\n    #[test]\n    fn test_from_key_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n\n        let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_key(&"a");\n        assert!(matches!(entry, RawEntryMut::Occupied(_)));\n\n        // Update the value\n        let mut view = entry.occupied();\n        let value = view.get_mut();\n        *value += 50;\n\n        assert_eq!(map.get(&"a"), Some(&150));\n    }\n\n    #[test]\n    fn test_from_key_non_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_key(&"b");\n        assert!(matches!(entry, RawEntryMut::Vacant(_)));\n\n        // Insert new key-value\n        let (key, value) = entry.insert("b", 200);\n        assert_eq!((*key, *value), ("b", 200));\n        assert_eq!(map.get(&"b"), Some(&200));\n    }\n\n    #[test]\n    fn test_from_key_with_different_key() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        map.insert("hello".to_string(), 1);\n\n        let entry: RawEntryMut<String, u32, _> = map.raw_entry_mut().from_key(&String::from("hello"));\n        assert!(matches!(entry, RawEntryMut::Occupied(_)));\n    }\n\n    #[test]\n    fn test_from_key_with_reference() {\n        let mut map: HashMap<String, u32> = HashMap::new();\n        let key = "world".to_string();\n        map.insert(key.clone(), 3);\n\n        let entry: RawEntryMut<String, u32, _> = map.raw_entry_mut().from_key(&key);\n        assert!(matches!(entry, RawEntryMut::Occupied(_)));\n        assert_eq!(entry.get(), &3);\n    }\n\n    #[test]\n    fn test_from_key_empty_map() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_key(&"new_key");\n        assert!(matches!(entry, RawEntryMut::Vacant(_)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583417, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=565, prompt_tokens=16361, total_tokens=16926, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmiS9uvblJgwy6E8QHhUlEZVpzVS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n\n    #[test]\n    fn test_from_key_hashed_nocheck() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 1);\n        map.insert("b", 2);\n        map.insert("c", 3);\n\n        let key = "a";\n        let hash = {\n            let mut hasher = map.hasher().build_hasher();\n            key.hash(&mut hasher);\n            hasher.finish()\n        };\n        \n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n        match entry {\n            RawEntryMut::Occupied(mut occupied_entry) => {\n                assert_eq!(occupied_entry.get(), &1);\n                occupied_entry.insert("a", 100);\n                assert_eq!(map[key], 100);\n            }\n            RawEntryMut::Vacant(_) => panic!("Expected occupied entry, found vacant"),\n        }\n\n        let hash_non_existent = {\n            let mut hasher = map.hasher().build_hasher();\n            "d".hash(&mut hasher);\n            hasher.finish()\n        };\n\n        let entry_non_existent = map.raw_entry_mut().from_key_hashed_nocheck(hash_non_existent, &"d");\n        match entry_non_existent {\n            RawEntryMut::Occupied(_) => panic!("Expected vacant entry, found occupied"),\n            RawEntryMut::Vacant(vacant_entry) => {\n                let (key_insert, value_insert) = vacant_entry.insert("d", 4);\n                assert_eq!(*key_insert, "d");\n                assert_eq!(*value_insert, 4);\n                assert_eq!(map["d"], 4);\n            }\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583428, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=384, prompt_tokens=16361, total_tokens=16745, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmieMqJBZ8YLkPDH3VyRVNNZC4GS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_search_occupied() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        map.insert(2, 20);\n        \n        let hash = 1; // hash of key 1\n        let mut builder = map.raw_entry_mut();\n        let entry = builder.search(hash, |&k| k == 1);\n        \n        match entry {\n            RawEntryMut::Occupied(view) => {\n                assert_eq!(view.get(), &10);\n            }\n            _ => panic!("Expected an occupied entry"),\n        }\n    }\n\n    #[test]\n    fn test_search_vacant() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        map.insert(1, 10);\n        \n        let hash = 2; // hash of key 2\n        let mut builder = map.raw_entry_mut();\n        let entry = builder.search(hash, |&k| k == 2);\n        \n        match entry {\n            RawEntryMut::Vacant(view) => {\n                let (key, value) = view.insert(2, 20);\n                assert_eq!(*key, 2);\n                assert_eq!(*value, 20);\n            }\n            _ => panic!("Expected a vacant entry"),\n        }\n    }\n\n    #[test]\n    fn test_search_empty() {\n        let mut map: HashMap<i32, i32> = HashMap::new();\n        \n        let hash = 1; // hash of key 1\n        let mut builder = map.raw_entry_mut();\n        let entry = builder.search(hash, |&k| k == 1);\n        \n        match entry {\n            RawEntryMut::Vacant(_) => assert!(true),\n            _ => panic!("Expected a vacant entry"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583440, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=411, prompt_tokens=16361, total_tokens=16772, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmipZJkT8Tjm7jRKX1yPmU8Pjgoc', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_and_modify_modify_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut()\n            .from_key("test_key")\n            .and_modify(|_k, v| *v += 2)\n            .or_insert("test_key", 10);\n        assert_eq!(map["test_key"], 10);\n\n        map.raw_entry_mut()\n            .from_key("test_key")\n            .and_modify(|_k, v| *v += 2)\n            .or_insert("test_key", 0);\n        assert_eq!(map["test_key"], 12);\n    }\n\n    #[test]\n    fn test_and_modify_insert_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut()\n            .from_key("new_key")\n            .and_modify(|_k, v| *v += 1)\n            .or_insert("new_key", 42);\n        assert_eq!(map["new_key"], 42);\n    }\n\n    #[test]\n    fn test_and_modify_empty_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut()\n            .from_key("empty_key")\n            .and_modify(|_k, v| *v += 1)\n            .or_insert("empty_key", 0);\n        assert_eq!(map["empty_key"], 0);\n    }\n\n    #[test]\n    fn test_and_modify_multiple_keys() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut()\n            .from_key("key_a")\n            .and_modify(|_k, v| *v += 1)\n            .or_insert("key_a", 5);\n        map.raw_entry_mut()\n            .from_key("key_b")\n            .and_modify(|_k, v| *v += 1)\n            .or_insert("key_b", 10);\n        \n        assert_eq!(map["key_a"], 5);\n        assert_eq!(map["key_b"], 10);\n\n        map.raw_entry_mut()\n            .from_key("key_a")\n            .and_modify(|_k, v| *v += 2)\n            .or_insert("key_a", 0);\n        map.raw_entry_mut()\n            .from_key("key_b")\n            .and_modify(|_k, v| *v += 3)\n            .or_insert("key_b", 0);\n        \n        assert_eq!(map["key_a"], 7);\n        assert_eq!(map["key_b"], 13);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583451, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=587, prompt_tokens=16361, total_tokens=16948, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmj1TYvlbyj7p8zkeRphVEH4wSFR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use hashbrown::hash_map::RawEntryMut;\n\n    #[test]\n    fn test_and_replace_entry_with_replaces_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 42);\n\n        let entry = map\n            .raw_entry_mut()\n            .from_key("poneyland")\n            .and_replace_entry_with(|k, v| {\n                assert_eq!(k, &"poneyland");\n                assert_eq!(v, 42);\n                Some(v + 1)\n            });\n\n        match entry {\n            RawEntryMut::Occupied(e) => {\n                assert_eq!(e.key(), &"poneyland");\n                assert_eq!(e.get(), &43);\n            },\n            RawEntryMut::Vacant(_) => panic!(),\n        }\n\n        assert_eq!(map["poneyland"], 43);\n    }\n\n    #[test]\n    fn test_and_replace_entry_with_removes_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("poneyland", 42);\n\n        let entry = map\n            .raw_entry_mut()\n            .from_key("poneyland")\n            .and_replace_entry_with(|_k, _v| None);\n\n        match entry {\n            RawEntryMut::Vacant(_) => {},\n            RawEntryMut::Occupied(_) => panic!(),\n        }\n\n        assert!(!map.contains_key("poneyland"));\n    }\n\n    #[test]\n    fn test_and_replace_entry_with_no_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        let entry = map\n            .raw_entry_mut()\n            .from_key("poneyland")\n            .and_replace_entry_with(|_k, _v| panic!());\n\n        match entry {\n            RawEntryMut::Vacant(_) => {},\n            RawEntryMut::Occupied(_) => panic!(),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583463, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=436, prompt_tokens=16361, total_tokens=16797, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjCZCwCVnAjCyMOsxHvFcHxc73B', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n    use std::hash::BuildHasherDefault;\n    use std::collections::hash_map::DefaultHasher;\n\n    #[test]\n    fn test_insert_occupied_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("key1", 1);\n        let entry = map.raw_entry_mut().from_key("key1").insert("key1", 2);\n        assert_eq!(unsafe { entry.as_mut() }, &mut 2);\n    }\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry = map.raw_entry_mut().from_key("key2").insert("key2", 3);\n        assert_eq!(unsafe { entry.as_ref() }, &3);\n    }\n\n    #[test]\n    fn test_insert_replacing_existing_value() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("key3", 5);\n        let entry = map.raw_entry_mut().from_key("key3").insert("key3", 10);\n        assert_eq!(entry.remove_entry(), ("key3", 10));\n    }\n\n    #[test]\n    fn test_insert_empty_map() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entry = map.raw_entry_mut().from_key("key4").insert("key4", 15);\n        assert_eq!(unsafe { entry.as_ref() }, &15);\n    }\n\n    #[test]\n    fn test_insert_and_fetch() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut().from_key("key5").insert("key5", 20);\n        assert_eq!(map.get("key5"), Some(&20));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583474, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=421, prompt_tokens=16361, total_tokens=16782, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjNG0knw69SdwiUKTm9kuJrSBei', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_insert_key_value() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let (key, value) = map.raw_entry_mut().from_key("test_key").or_insert("test_key", 42);\n        assert_eq!(*key, "test_key");\n        assert_eq!(*value, 42);\n        assert_eq!(map.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_update_value() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.raw_entry_mut().from_key("test_key").or_insert("test_key", 42);\n        let (_, value) = map.raw_entry_mut().from_key("test_key").or_insert("test_key", 100);\n        *value *= 2;\n        assert_eq!(map["test_key"], 84);\n    }\n\n    #[test]\n    fn test_or_insert_with_occupied_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let (key, value) = map.raw_entry_mut().from_key("key1").or_insert("key1", 10);\n        assert_eq!(*key, "key1");\n        assert_eq!(*value, 10);\n        \n        let (key, value) = map.raw_entry_mut().from_key("key1").or_insert("key1", 20);\n        assert_eq!(*key, "key1");\n        assert_eq!(*value, 10); // Value should not change, as entry already occupied\n    }\n\n    #[test]\n    fn test_or_insert_non_existing_entry() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let (key, value) = map.raw_entry_mut().from_key("non_existing").or_insert("non_existing", 100);\n        assert_eq!(*key, "non_existing");\n        assert_eq!(*value, 100);\n    }\n\n    #[test]\n    fn test_or_insert_different_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let (key, value) = map.raw_entry_mut().from_key("key1").or_insert("key1", 10);\n        assert_eq!(*key, "key1");\n        assert_eq!(*value, 10);\n        \n        let (key2, value2) = map.raw_entry_mut().from_key("key2").or_insert("key2", 20);\n        assert_eq!(*key2, "key2");\n        assert_eq!(*value2, 20);\n        assert_eq!(map.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583485, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=596, prompt_tokens=16361, total_tokens=16957, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjcRlSUr1xNj1namgfjezP8XSki', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_or_insert_with() {\n        let mut map: HashMap<&str, String> = HashMap::new();\n\n        let (key, value) = map.raw_entry_mut().from_key("poneyland").or_insert_with(|| {\n            ("poneyland", "hoho".to_string())\n        });\n\n        assert_eq!(key, &"poneyland");\n        assert_eq!(value, &mut "hoho".to_string());\n\n        // Check if the entry is correctly inserted\n        assert_eq!(map["poneyland"], "hoho".to_string());\n\n        // Test inserting with an existing key\n        let (key, value) = map.raw_entry_mut().from_key("poneyland").or_insert_with(|| {\n            ("poneyland", "new_value".to_string())\n        });\n\n        assert_eq!(key, &"poneyland");\n        assert_eq!(value, &mut "hoho".to_string());\n\n        // Check the value has not changed\n        assert_eq!(map["poneyland"], "hoho".to_string());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583500, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=248, prompt_tokens=16361, total_tokens=16609, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjlYf6uQBDucKzXzf2XBy5mYyAK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_get() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n        map.insert("b", 200);\n        \n        // Create a raw entry mutable from key\n        match map.raw_entry_mut().from_key(&"a") {\n            RawEntryMut::Vacant(_) => panic!("Expected entry to be occupied"),\n            RawEntryMut::Occupied(o) => {\n                let value = o.get();\n                assert_eq!(value, &100);\n            },\n        }\n\n        match map.raw_entry_mut().from_key(&"b") {\n            RawEntryMut::Vacant(_) => panic!("Expected entry to be occupied"),\n            RawEntryMut::Occupied(o) => {\n                let value = o.get();\n                assert_eq!(value, &200);\n            },\n        }\n\n        match map.raw_entry_mut().from_key(&"c") {\n            RawEntryMut::Occupied(_) => panic!("Expected entry to be vacant"),\n            RawEntryMut::Vacant(_) => (),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583509, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=255, prompt_tokens=16361, total_tokens=16616, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjuJu782mKNNYwEYyaPhuXhMNMn', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use std::alloc::Global;\n\n    #[test]\n    fn test_get_key_value() {\n        // Create a HashMap instance\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        // Insert elements into the map\n        map.insert("a", 100);\n        map.insert("b", 200);\n\n        // Use raw_entry_mut() to access the map entry\n        match map.raw_entry_mut().from_key(&"a") {\n            RawEntryMut::Vacant(_) => panic!("Expected entry to be occupied."),\n            RawEntryMut::Occupied(o) => {\n                // Assert the key-value pair is correct\n                assert_eq!(o.get_key_value(), (&"a", &100));\n            }\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583518, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=190, prompt_tokens=16361, total_tokens=16551, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmjyiWybIfeYyYhtgsfKzHEkZGNE', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use std::rc::Rc;\n\n    #[test]\n    fn test_get_key_value_mut() {\n        let key_one = Rc::new("a");\n        let key_two = Rc::new("b");\n        \n        let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n        map.insert(key_one.clone(), 10);\n        \n        assert_eq!(map[&key_one], 10);\n\n        match map.raw_entry_mut().from_key(&key_one) {\n            RawEntryMut::Vacant(_) => panic!("Entry should be occupied"),\n            RawEntryMut::Occupied(mut occupied) => {\n                let (inside_key, inside_value) = occupied.get_key_value_mut();\n                *inside_key = key_two.clone();\n                *inside_value = 100;\n            }\n        }\n\n        assert_eq!(map[&key_two], 100);\n        assert!(Rc::strong_count(&key_one) == 1);\n        assert!(Rc::strong_count(&key_two) == 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583522, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=243, prompt_tokens=16361, total_tokens=16604, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmk7lJ9dj51t1BMZdktkhIWwDA6f', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // This assumes that the module where RawOccupiedEntryMut and its methods are defined is in the same scope\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_get_mut() {\n        // Create a new HashMap and insert some values\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n        map.insert("b", 200);\n\n        // Access the entry for the key "a"\n        match map.raw_entry_mut().from_key(&"a") {\n            RawEntryMut::Occupied(mut occupied) => {\n                // Get a mutable reference to the value and modify it\n                let value_mut = occupied.get_mut();\n                *value_mut += 900;\n                \n                // Assert that the value in the map is updated\n                assert_eq!(map[&"a"], 1000);\n            },\n            RawEntryMut::Vacant(_) => panic!("Entry should be occupied"),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583531, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=229, prompt_tokens=16361, total_tokens=16590, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkEmcxtWK0zaFUWdmXBudsrTU5L', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_insert() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n        map.insert("b", 200);\n\n        let mut entry = match map.raw_entry_mut().from_key("a") {\n            RawEntryMut::Vacant(_) => panic!("Expected occupied entry"),\n            RawEntryMut::Occupied(o) => o,\n        };\n\n        assert_eq!(entry.insert(1000), 100);\n        assert_eq!(map["a"], 1000);\n    }\n\n    #[test]\n    fn test_insert_empty() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        assert!(map.raw_entry_mut().from_key("a").is_vacant());\n\n        let mut entry = map.raw_entry_mut().from_key("a").insert(100);\n        assert_eq!(map["a"], 100);\n        assert!(entry.is_occupied());\n    }\n\n    #[test]\n    fn test_insert_multiple() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n        map.insert("b", 200);\n\n        let mut entry = match map.raw_entry_mut().from_key("b") {\n            RawEntryMut::Vacant(_) => panic!("Expected occupied entry"),\n            RawEntryMut::Occupied(o) => o,\n        };\n\n        assert_eq!(entry.insert(300), 200);\n        assert_eq!(map["b"], 300);\n    }\n\n    #[test]\n    fn test_insert_overwrite() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("x", 50);\n\n        let mut entry = match map.raw_entry_mut().from_key("x") {\n            RawEntryMut::Vacant(_) => panic!("Expected occupied entry"),\n            RawEntryMut::Occupied(o) => o,\n        };\n\n        assert_eq!(entry.insert(200), 50);\n        assert_eq!(map["x"], 200);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583538, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=466, prompt_tokens=16361, total_tokens=16827, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkLG9jQzcSpsbVfLnojw0MLI7b0', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::HashMap;\n    use std::rc::Rc;\n\n    #[test]\n    fn test_insert_key() {\n        let key_one = Rc::new("key_one");\n        let key_two = Rc::new("key_two");\n\n        let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n        map.insert(key_one.clone(), 42);\n\n        assert_eq!(map[&key_one], 42);\n        assert_eq!(Rc::strong_count(&key_one), 2);\n        assert_eq!(Rc::strong_count(&key_two), 1);\n\n        match map.raw_entry_mut().from_key(&key_one) {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(mut occupied) => {\n                let old_key = occupied.insert_key(key_two.clone());\n                assert!(Rc::ptr_eq(&old_key, &key_one));\n            }\n        }\n\n        assert_eq!(map[&key_two], 42);\n        assert_eq!(Rc::strong_count(&key_one), 1);\n        assert_eq!(Rc::strong_count(&key_two), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583545, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=257, prompt_tokens=16361, total_tokens=16618, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkQQZxkMjmFV7uk34yL5V0AMNpP', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use std::rc::Rc;\n\n    #[test]\n    fn test_into_key() {\n        let key_one = Rc::new("key_one");\n        let key_two = Rc::new("key_two");\n\n        let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n        map.insert(key_one.clone(), 10);\n\n        assert_eq!(map[&key_one], 10);\n\n        let inside_key: &mut Rc<&str>;\n        match map.raw_entry_mut().from_key(&key_one) {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(o) => inside_key = o.into_key(),\n        }\n        *inside_key = key_two.clone();\n\n        assert_eq!(map[&key_two], 10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583550, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=197, prompt_tokens=16361, total_tokens=16558, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkY6EnfLp7gq2HkLDDdH1qVmUHT', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use std::rc::Rc;\n\n    #[test]\n    fn test_into_key_value() {\n        let key_one = Rc::new("a");\n        let key_two = Rc::new("a");\n        let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n        map.insert(key_one.clone(), 10);\n\n        let inside_key: &mut Rc<&str>;\n        let inside_value: &mut u32;\n\n        match map.raw_entry_mut().from_key(&key_one) {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(o) => {\n                let tuple = o.into_key_value();\n                inside_key = tuple.0;\n                inside_value = tuple.1;\n            }\n        }\n\n        *inside_key = key_two.clone();\n        *inside_value = 100;\n        \n        assert_eq!(map[&key_two], 100);\n        assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583558, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=250, prompt_tokens=16361, total_tokens=16611, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkgGqvwMsiAYKq7HHCZtRMdROPJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_into_mut() {\n        let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n\n        let value: &mut u32;\n\n        match map.raw_entry_mut().from_key(&"a") {\n            RawEntryMut::Vacant(_) => panic!("Expected occupied entry"),\n            RawEntryMut::Occupied(o) => {\n                value = o.into_mut();\n            }\n        }\n        *value += 900;\n\n        assert_eq!(map[&"a"], 1000);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583566, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=153, prompt_tokens=16361, total_tokens=16514, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmkmd028YANeAUZWfyh8OoPGYang', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_key_method() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n        map.insert("b", 200);\n        \n        match map.raw_entry_mut().from_key(&"a") {\n            RawEntryMut::Vacant(_) => panic!("Expected entry to be occupied"),\n            RawEntryMut::Occupied(o) => {\n                assert_eq!(o.key(), &"a");\n            },\n        }\n    }\n\n    #[test]\n    fn test_key_method_non_existent() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n        map.insert("b", 200);\n        \n        match map.raw_entry_mut().from_key(&"c") {\n            RawEntryMut::Occupied(_) => panic!("Expected entry to be vacant"),\n            RawEntryMut::Vacant(_) => {\n                // Check that looking up a non-existent key does not panic\n            },\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583572, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=250, prompt_tokens=16361, total_tokens=16611, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkrZuWeCsrVdHDDnZDbQFvh75Ii', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use std::rc::Rc;\n\n    #[test]\n    fn test_key_mut() {\n        let key_one = Rc::new("a");\n        let key_two = Rc::new("b");\n        \n        let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n        map.insert(key_one.clone(), 10);\n\n        assert_eq!(map[&key_one], 10);\n        \n        match map.raw_entry_mut().from_key(&key_one) {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(mut occupied) => {\n                assert_eq!(occupied.key(), &key_one);\n                *occupied.key_mut() = key_two.clone();\n            }\n        }\n        assert!(map.get(&key_one).is_none());\n        assert_eq!(map[&key_two], 10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583577, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=208, prompt_tokens=16361, total_tokens=16569, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmkyKLzQFFiO0oMp93Xwx74xsxrj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_remove() {\n        let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n        \n        match map.raw_entry_mut().from_key(&"a") {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(o) => {\n                let value = o.remove();\n                assert_eq!(value, 100);\n                assert_eq!(map.get(&"a"), None);\n            },\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583584, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=141, prompt_tokens=16361, total_tokens=16502, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcml3v0Qm1vlywOVIysMNEhGM8t4l', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_remove_entry() {\n        let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n\n        match map.raw_entry_mut().from_key(&"a") {\n            RawEntryMut::Vacant(_) => panic!("Expected occupied entry"),\n            RawEntryMut::Occupied(o) => {\n                let (key, value) = o.remove_entry();\n                assert_eq!(key, "a");\n                assert_eq!(value, 100);\n            }\n        }\n        assert_eq!(map.get(&"a"), None);\n        assert_eq!(map.get(&"b"), Some(&200));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583589, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=172, prompt_tokens=16361, total_tokens=16533, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmlA1ROgFr2jAfeg1HMQptY9taxa', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_replace_entry_with() {\n        let mut map: HashMap<&str, u32> = HashMap::from([("a", 100), ("b", 200)]);\n\n        let raw_entry = match map.raw_entry_mut().from_key(&"a") {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(o) => o.replace_entry_with(|k, v| {\n                assert_eq!(k, &"a");\n                assert_eq!(v, 100);\n                Some(v + 900)\n            }),\n        };\n        let raw_entry = match raw_entry {\n            RawEntryMut::Vacant(_) => panic!(),\n            RawEntryMut::Occupied(o) => o.replace_entry_with(|k, v| {\n                assert_eq!(k, &"a");\n                assert_eq!(v, 1000);\n                None\n            }),\n        };\n        match raw_entry {\n            RawEntryMut::Vacant(_) => {},\n            RawEntryMut::Occupied(_) => panic!(),\n        };\n        assert_eq!(map.get(&"a"), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583596, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=263, prompt_tokens=16361, total_tokens=16624, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmlOOnHphAgUBnez4eJNfZNPJuXB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    #[test]\n    fn test_insert() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n\n        // Insert a new key-value pair\n        let key = "c";\n        let value = 300;\n        let entry = map.raw_entry_mut().from_key(key);\n        match entry {\n            RawEntryMut::Occupied(_) => panic!("Entry should be vacant"),\n            RawEntryMut::Vacant(v) => {\n                let (k, v) = v.insert(key, value);\n                assert_eq!(*k, key);\n                assert_eq!(*v, value);\n            }\n        }\n        assert_eq!(map[&key], value);\n    }\n\n    #[test]\n    fn test_insert_existing_key() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        map.insert("a", 100);\n        \n        // Attempting to insert an existing key\n        let entry = map.raw_entry_mut().from_key("a");\n        match entry {\n            RawEntryMut::Occupied(_) => {\n                // Existing entry should be found\n                assert_eq!(map.get_mut("a"), Some(&mut 100));\n            },\n            RawEntryMut::Vacant(_) => panic!("Entry should be occupied"),\n        }\n    }\n\n    #[test]\n    fn test_insert_multiple() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let entries = vec![("a", 100), ("b", 200), ("c", 300)];\n        \n        for (key, value) in entries {\n            let entry = map.raw_entry_mut().from_key(key);\n            match entry {\n                RawEntryMut::Occupied(_) => panic!("Entry should be vacant"),\n                RawEntryMut::Vacant(v) => {\n                    let (k, v) = v.insert(key, value);\n                    assert_eq!(*k, key);\n                    assert_eq!(*v, value);\n                }\n            }\n        }\n        \n        assert_eq!(map["a"], 100);\n        assert_eq!(map["b"], 200);\n        assert_eq!(map["c"], 300);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583610, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=481, prompt_tokens=16361, total_tokens=16842, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmlbrMLHoRcGpSfhSvIUoRLHBCnr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    #[test]\n    fn test_insert_entry() {\n        let mut table: RawTable<(u32, String)> = RawTable::new();\n        let key = 42;\n        let value = "Hello".to_string();\n        let hash = {\n            let mut hasher = DefaultHasher::new();\n            key.hash(&mut hasher);\n            hasher.finish()\n        };\n\n        // Insert an entry\n        let bucket = unsafe {\n            table.insert_entry(hash, (key, value), |x: &(u32, String)| {\n                let mut hasher = DefaultHasher::new();\n                x.0.hash(&mut hasher);\n                hasher.finish()\n            })\n        };\n\n        // Verify that the value was inserted\n        unsafe {\n            assert_eq!(bucket.as_ref(), &(key, "Hello".to_string()));\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583623, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=213, prompt_tokens=16361, total_tokens=16574, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmlhSPAIjDmDID1G1MiF5qgxMVmW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::hash::{BuildHasher, Hash};\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n\n    fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n        use core::hash::Hasher;\n        let mut state = hash_builder.build_hasher();\n        key.hash(&mut state);\n        state.finish()\n    }\n\n    #[test]\n    fn test_insert_hashed_nocheck() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key = "test_key";\n        let value = 50;\n        let hash = compute_hash(map.hasher(), &key);\n        \n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n        if let RawEntryMut::Vacant(v) = entry {\n            let (k, v) = v.insert_hashed_nocheck(hash, key, value);\n            assert_eq!(*k, key);\n            assert_eq!(*v, value);\n        } else {\n            panic!("Expected a vacant entry, but found occupied.");\n        }\n\n        assert_eq!(map[&"test_key"], 50);\n    }\n\n    #[test]\n    fn test_insert_hashed_nocheck_overwrite() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key = "test_key";\n        let initial_value = 50;\n        let new_value = 100;\n        let hash = compute_hash(map.hasher(), &key);\n        \n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n        if let RawEntryMut::Vacant(v) = entry {\n            v.insert_hashed_nocheck(hash, key, initial_value);\n        }\n\n        let entry = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n        if let RawEntryMut::Occupied(mut v) = entry {\n            let (k, v) = v.insert_hashed_nocheck(hash, key, new_value);\n            assert_eq!(*k, key);\n            assert_eq!(*v, new_value);\n        } else {\n            panic!("Expected an occupied entry, but found vacant.");\n        }\n\n        assert_eq!(map[&"test_key"], 100);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583629, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=512, prompt_tokens=16361, total_tokens=16873, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmlyHigLVZ8MKgQNKcVNe7vdOfKI', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_map::{HashMap, RawEntryMut};\n    use core::hash::{BuildHasher, Hash};\n    \n    #[test]\n    fn test_insert_with_hasher() {\n        let mut map: HashMap<&str, u32> = HashMap::new();\n        let key = "test_key";\n        let hash_builder = map.hasher().clone();\n        let hash = make_hasher(&hash_builder)(&key);\n\n        match map.raw_entry_mut().from_hash(hash, |q| q == &key) {\n            RawEntryMut::Occupied(_) => panic!("Entry already exists."),\n            RawEntryMut::Vacant(v) => {\n                let (k, v) = v.insert_with_hasher(hash, key, 50, make_hasher(&hash_builder));\n                assert_eq!(k, &mut "test_key");\n                assert_eq!(v, &mut 50);\n            },\n        }\n\n        assert_eq!(map[&key], 50);\n    }\n\n    fn make_hasher<K, S>(hash_builder: &S) -> impl Fn(&K) -> u64 + \'_\n    where\n        K: Hash + ?Sized,\n        S: BuildHasher,\n    {\n        move |key: &K| {\n            use core::hash::Hasher;\n            let mut state = hash_builder.build_hasher();\n            key.hash(&mut state);\n            state.finish()\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583646, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=310, prompt_tokens=16361, total_tokens=16671, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmm5VeakR0rpcZYDxhgZhB01GIlg', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::mem::ManuallyDrop;\n\n    #[test]\n    fn test_into_inner() {\n        let mut value = 42;\n        let drop_fn_called = std::sync::Arc::new(std::sync::Mutex::new(false));\n        let drop_fn = {\n            let drop_fn_called = drop_fn_called.clone();\n            move |val: &mut i32| {\n                *val += 1;\n                let mut called = drop_fn_called.lock().unwrap();\n                *called = true;\n            }\n        };\n\n        let guard = ScopeGuard { dropfn, value };\n\n        let inner_value = ScopeGuard::into_inner(guard);\n\n        assert_eq!(inner_value, 42);\n        assert!(*drop_fn_called.lock().unwrap());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583653, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=172, prompt_tokens=637, total_tokens=809, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmm91vBQHCh04Mw9WLz0KYGIifMB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use scopeguard::guard;\n\n    #[test]\n    fn test_guard() {\n        let mut dropped_value = 0;\n        {\n            let _guard = guard(5, |value| {\n                dropped_value = *value;\n                *value = 0;\n            });\n            assert_eq!(*_guard, 5);\n            *_guard += 1; // Mutate the value through the guard\n        }\n        assert_eq!(dropped_value, 5); // Check if dropfn was called\n    }\n\n    #[test]\n    fn test_guard_into_inner() {\n        let mut drop_value = 0;\n        let guard = guard(10, |value| {\n            drop_value = *value;\n            *value = 0;\n        });\n        let inner_value = ScopeGuard::into_inner(guard);\n        assert_eq!(inner_value, 10);\n        assert_eq!(drop_value, 10); // Check if dropfn was called\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583657, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=215, prompt_tokens=563, total_tokens=778, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmmG8xJSMPGPPjzoDD9I5uHvZGyK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_get_occupied_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.insert("poneyland");\n\n        assert_eq!(set.entry("poneyland").get(), &"poneyland");\n    }\n\n    #[test]\n    fn test_get_vacant_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        \n        // Should insert and then get\n        assert_eq!(set.entry("horseland").get(), &"horseland");\n    }\n\n    #[test]\n    fn test_get_nonexistent_entry_after_insert() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.insert("poneyland");\n        \n        assert_eq!(set.entry("horseland").get(), &"horseland");\n        set.insert("horseland");\n        assert_eq!(set.entry("horseland").get(), &"horseland");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583664, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=219, prompt_tokens=16361, total_tokens=16580, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmmNqtWNzZhb3YXcKnTM04hekWiK', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_insert_occupied_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry("horseyland").insert();\n\n        assert_eq!(entry.get(), &"horseyland");\n        assert!(set.contains("horseyland"));\n    }\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry("poneyland").insert();\n\n        assert_eq!(entry.get(), &"poneyland");\n        assert!(set.contains("poneyland"));\n    }\n\n    #[test]\n    fn test_insert_overwrite() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry("land").insert();\n        assert_eq!(entry.get(), &"land");\n\n        let entry = set.entry("land").insert();\n        assert_eq!(entry.get(), &"land");\n        assert!(set.contains("land"));\n    }\n\n    #[test]\n    fn test_insert_multiple_entries() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry1 = set.entry("one").insert();\n        let entry2 = set.entry("two").insert();\n\n        assert_eq!(entry1.get(), &"one");\n        assert_eq!(entry2.get(), &"two");\n        assert!(set.contains("one"));\n        assert!(set.contains("two"));\n    }\n\n    #[test]\n    fn test_insert_multiple_entries_with_existence_check() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.insert("existing");\n\n        let entry = set.entry("existing").insert();\n\n        assert_eq!(entry.get(), &"existing");\n        assert_eq!(set.len(), 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583671, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=407, prompt_tokens=16361, total_tokens=16768, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmmWXElBya5JY3MOmD87N39LQCeM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_or_insert_nonexistent_key() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.entry("poneyland").or_insert();\n        assert!(set.contains("poneyland"));\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_existing_key() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.entry("poneyland").or_insert();\n        set.entry("poneyland").or_insert();\n        assert!(set.contains("poneyland"));\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_or_insert_multiple_keys() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.entry("poneyland").or_insert();\n        set.entry("unicornland").or_insert();\n        assert!(set.contains("poneyland"));\n        assert!(set.contains("unicornland"));\n        assert_eq!(set.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583680, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=243, prompt_tokens=16361, total_tokens=16604, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmmfNtxwv24QvfBHIpVNGK1iAtzF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_allocation_size_empty() {\n        let set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.allocation_size(), 0);\n    }\n\n    #[test]\n    fn test_allocation_size_non_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert!(set.allocation_size() > 0);\n    }\n\n    #[test]\n    fn test_allocation_size_after_clear() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let size_before_clear = set.allocation_size();\n        set.clear();\n        assert_eq!(set.allocation_size(), size_before_clear);\n    }\n\n    #[test]\n    fn test_allocation_size_after_reinsert() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let size_before_clear = set.allocation_size();\n        set.clear();\n        set.insert(4);\n        set.insert(5);\n        assert!(set.allocation_size() > 0);\n        assert!(set.allocation_size() < size_before_clear);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583689, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=309, prompt_tokens=16361, total_tokens=16670, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmmpyg7nICObQERP0XZSfq9dPyrX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_allocator() {\n        // Create a new HashSet with a specific allocator\n        let allocator = bumpalo::Bump::new(); // Example allocator\n        let set: HashSet<i32, hashbrown::DefaultHashBuilder, _> = HashSet::new_in(&allocator);\n\n        // Assert that the allocator is the one we provided\n        assert_eq!(set.allocator() as *const _, &allocator as *const _);\n    }\n\n    #[test]\n    fn test_allocator_after_insertion() {\n        // Create a new HashSet with a specific allocator\n        let allocator = bumpalo::Bump::new(); // Example allocator\n        let mut set: HashSet<i32, hashbrown::DefaultHashBuilder, _> = HashSet::new_in(&allocator);\n\n        // Insert an element into the set\n        set.insert(10);\n\n        // Assert that the allocator is still the one we provided\n        assert_eq!(set.allocator() as *const _, &allocator as *const _);\n    }\n\n    #[test]\n    fn test_allocator_with_different_allocators() {\n        let allocator1 = bumpalo::Bump::new(); // First allocator\n        let allocator2 = bumpalo::Bump::new(); // Second allocator\n\n        let mut set1: HashSet<i32, hashbrown::DefaultHashBuilder, _> = HashSet::new_in(&allocator1);\n        let mut set2: HashSet<i32, hashbrown::DefaultHashBuilder, _> = HashSet::new_in(&allocator2);\n\n        // Insert elements into both sets\n        set1.insert(1);\n        set2.insert(2);\n\n        // Assert that the allocators are different\n        assert_ne!(set1.allocator() as *const _, set2.allocator() as *const _);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583699, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=406, prompt_tokens=16361, total_tokens=16767, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmn9bWJbRtjdMTIOCgh7oSarM6Lu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_capacity() {\n        // Test with initial capacity\n        let set: HashSet<i32> = HashSet::with_capacity(100);\n        assert!(set.capacity() >= 100);\n\n        // Test with zero initial capacity\n        let empty_set: HashSet<i32> = HashSet::with_capacity(0);\n        assert_eq!(empty_set.capacity(), 0);\n        \n        // Test with elements added\n        let mut set_with_elements = HashSet::with_capacity(5);\n        set_with_elements.insert(1);\n        set_with_elements.insert(2);\n        set_with_elements.insert(3);\n        assert!(set_with_elements.capacity() >= 5);\n        \n        // Test capacity after reaching initial capacity\n        set_with_elements.insert(4);\n        set_with_elements.insert(5);\n        assert!(set_with_elements.capacity() >= 5);\n        \n        // Test adding more elements\n        set_with_elements.insert(6);\n        assert!(set_with_elements.capacity() >= 6);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583719, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=230, prompt_tokens=16361, total_tokens=16591, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmnG1lX2it7HBQLQskAOtTXBONkh', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_clear() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.len(), 3);\n        set.clear();\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_clear_on_empty_set() {\n        let mut set = HashSet::new();\n        assert!(set.is_empty());\n        set.clear();\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_clear_after_insert() {\n        let mut set = HashSet::new();\n        set.insert(10);\n        set.insert(20);\n        assert_eq!(set.len(), 2);\n        set.clear();\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_clear_does_not_panic() {\n        let mut set = HashSet::<i32>::new();\n        set.clear(); // Calling clear on an empty set\n        assert!(set.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583726, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=230, prompt_tokens=16361, total_tokens=16591, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmnPJoXyhnL6oUX8kX605LBxZuQr', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_contains() {\n        let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n        assert!(!set.contains(&4));\n    }\n\n    #[test]\n    fn test_contains_with_nonexistent_element() {\n        let set: HashSet<_> = [5, 6, 7].into_iter().collect();\n        assert!(!set.contains(&8));\n    }\n\n    #[test]\n    fn test_contains_empty_set() {\n        let set: HashSet<i32> = HashSet::new();\n        assert!(!set.contains(&1));\n    }\n\n    #[test]\n    fn test_contains_with_different_types() {\n        let set: HashSet<&str> = ["a", "b", "c"].iter().cloned().collect();\n        assert!(set.contains(&"a"));\n        assert!(!set.contains(&"d"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583735, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=235, prompt_tokens=16361, total_tokens=16596, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmnbP3a6VpVBAbvZKJV9XTgJ5u2C', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn difference_test() {\n        let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        let b: HashSet<_> = [2, 3, 4].iter().cloned().collect();\n\n        let diff_a_b: HashSet<_> = a.difference(&b).cloned().collect();\n        let diff_b_a: HashSet<_> = b.difference(&a).cloned().collect();\n\n        assert_eq!(diff_a_b, [1].iter().cloned().collect::<HashSet<_>>());\n        assert_eq!(diff_b_a, [4].iter().cloned().collect::<HashSet<_>>());\n    }\n\n    #[test]\n    fn difference_empty_test() {\n        let a: HashSet<_> = HashSet::new();\n        let b: HashSet<_> = HashSet::new();\n\n        let diff_a_b: HashSet<_> = a.difference(&b).cloned().collect();\n        let diff_b_a: HashSet<_> = b.difference(&a).cloned().collect();\n\n        assert!(diff_a_b.is_empty());\n        assert!(diff_b_a.is_empty());\n    }\n\n    #[test]\n    fn difference_no_common_elements_test() {\n        let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        let b: HashSet<_> = [4, 5, 6].iter().cloned().collect();\n\n        let diff_a_b: HashSet<_> = a.difference(&b).cloned().collect();\n        let diff_b_a: HashSet<_> = b.difference(&a).cloned().collect();\n\n        assert_eq!(diff_a_b, a);\n        assert_eq!(diff_b_a, b);\n    }\n\n    #[test]\n    fn difference_same_elements_test() {\n        let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        let b: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n\n        let diff_a_b: HashSet<_> = a.difference(&b).cloned().collect();\n\n        assert!(diff_a_b.is_empty());\n    }\n\n    #[test]\n    fn difference_with_empty_set_test() {\n        let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        let b: HashSet<_> = HashSet::new();\n\n        let diff_a_b: HashSet<_> = a.difference(&b).cloned().collect();\n\n        assert_eq!(diff_a_b, a);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583747, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=589, prompt_tokens=16361, total_tokens=16950, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmnmuAM60TS690pEYB9pZiNn6L78', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_drain_empty_set() {\n        let mut set: HashSet<i32> = HashSet::new();\n        let drained: Vec<i32> = set.drain().collect();\n        assert!(drained.is_empty());\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_drain_non_empty_set() {\n        let mut set: HashSet<i32> = [1, 2, 3].iter().copied().collect();\n        let drained: Vec<i32> = set.drain().collect();\n\n        assert_eq!(drained.len(), 3);\n        assert!(set.is_empty());\n        for i in drained {\n            assert!(i == 1 || i == 2 || i == 3);\n        }\n    }\n\n    #[test]\n    fn test_drain_partial_iteration() {\n        let mut set: HashSet<i32> = [1, 2, 3, 4].iter().copied().collect();\n        let mut drained_iter = set.drain();\n        \n        assert_eq!(drained_iter.next(), Some(1));\n        assert_eq!(drained_iter.next(), Some(2));\n\n        // Dropping the iterator should still clear the set\n        drop(drained_iter);\n        assert!(set.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583758, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=290, prompt_tokens=16361, total_tokens=16651, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmo7XSypwb7OEZnMeGohoKn8e6fu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use hashbrown::hash_set::Entry::*;\n\n    #[test]\n    fn test_entry_vacant_insert() {\n        let mut set = HashSet::new();\n        let entry = set.entry('a');\n        if let Vacant(vacant_entry) = entry {\n            vacant_entry.insert();\n        }\n        assert!(set.contains(&'a'));\n    }\n\n    #[test]\n    fn test_entry_occupied_replace() {\n        let mut set = HashSet::new();\n        set.insert('b');\n        let entry = set.entry('b');\n        if let Occupied(occupied_entry) = entry {\n            occupied_entry.remove();\n        }\n        assert!(!set.contains(&'b'));\n    }\n\n    #[test]\n    fn test_entry_occupied_insert() {\n        let mut set = HashSet::new();\n        set.insert('c');\n        let entry = set.entry('c');\n        if let Occupied(occupied_entry) = entry {\n            occupied_entry.remove();\n        }\n        assert!(!set.contains(&'c'));\n        let entry = set.entry('c');\n        if let Vacant(vacant_entry) = entry {\n            vacant_entry.insert();\n        }\n        assert!(set.contains(&'c'));\n    }\n\n    #[test]\n    fn test_entry_vacant_insert_existing() {\n        let mut set = HashSet::new();\n        set.insert('d');\n        let entry = set.entry('d');\n        if let Occupied(occupied_entry) = entry {\n            assert!(set.contains(&'d'));\n            occupied_entry.remove();\n        }\n        assert!(!set.contains(&'d'));\n    }\n\n    #[test]\n    fn test_entry_insert_multiple() {\n        let mut set = HashSet::new();\n        let mut seen = HashSet::new();\n        let chars = vec!['e', 'f', 'g', 'e'];\n\n        for ch in chars {\n            match seen.entry(ch) {\n                Vacant(vacant_entry) => {\n                    vacant_entry.insert();\n                }\n                Occupied(_) => {\n                    set.entry(ch).or_insert_with(|| {\n                        set.insert(ch);\n                        set.get(&ch).unwrap()  // To simulate some in-place manipulation\n                    });\n                }\n            }\n        }\n\n        assert!(set.contains(&'e'));\n        assert!(!set.contains(&'f'));\n        assert!(!set.contains(&'g'));\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583779, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=511, prompt_tokens=16361, total_tokens=16872, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmoItKWjQUBGZevCtANL3hmlShSR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_extract_if() {\n        let mut set: HashSet<i32> = HashSet::from_iter(0..8);\n        let drained: HashSet<i32> = set.extract_if(|&v| v % 2 == 0).collect();\n\n        let mut evens = drained.into_iter().collect::<Vec<_>>();\n        let mut odds = set.into_iter().collect::<Vec<_>>();\n        evens.sort();\n        odds.sort();\n\n        assert_eq!(evens, vec![0, 2, 4, 6]);\n        assert_eq!(odds, vec![1, 3, 5, 7]);\n    }\n\n    #[test]\n    fn test_extract_if_not_exhausted() {\n        let mut set: HashSet<i32> = HashSet::from_iter(0..8);\n        {\n            let _drained = set.extract_if(|&v| v % 2 != 0);\n        }\n        assert_eq!(set.len(), 8);\n    }\n\n    #[test]\n    fn test_extract_if_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        let drained: HashSet<i32> = set.extract_if(|&v| v % 2 == 0).collect();\n\n        assert!(drained.is_empty());\n        assert!(set.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583790, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=304, prompt_tokens=16361, total_tokens=16665, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmoRrfpN3ebvKwn7S4mADAukpBTp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_get_existing_value() {\n        let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        assert_eq!(set.get(&2), Some(&2));\n    }\n\n    #[test]\n    fn test_get_non_existing_value() {\n        let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        assert_eq!(set.get(&4), None);\n    }\n\n    #[test]\n    fn test_get_with_different_reference_type() {\n        let set: HashSet<_> = [String::from("hello"), String::from("world")].iter().cloned().collect();\n        assert_eq!(set.get(&String::from("hello")), Some(&String::from("hello")));\n        assert_eq!(set.get(&String::from("notfound")), None);\n    }\n\n    #[test]\n    fn test_get_with_non_hashable_type() {\n        let set: HashSet<_> = [1.0, 2.0, 3.0].iter().cloned().collect();\n        assert_eq!(set.get(&2.0), Some(&2.0));\n        assert_eq!(set.get(&4.0), None);\n    }\n\n    #[test]\n    fn test_get_on_empty_set() {\n        let set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.get(&1), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583799, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=326, prompt_tokens=16361, total_tokens=16687, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmoXyYeNmbppofP7H0d8avpJ3aJA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_get_or_insert() {\n        let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n        assert_eq!(set.len(), 3);\n        assert_eq!(set.get_or_insert(2), &2);\n        assert_eq!(set.get_or_insert(100), &100);\n        assert_eq!(set.len(), 4); // 100 was inserted\n    }\n\n    #[test]\n    fn test_get_or_insert_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.len(), 0);\n        assert_eq!(set.get_or_insert(42), &42);\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_get_or_insert_multiple() {\n        let mut set: HashSet<_> = HashSet::new();\n        assert_eq!(set.get_or_insert(1), &1);\n        assert_eq!(set.get_or_insert(2), &2);\n        assert_eq!(set.len(), 2);\n        assert_eq!(set.get_or_insert(1), &1);  // 1 should not be inserted again\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_get_or_insert_different_types() {\n        let mut set: HashSet<String> = HashSet::new();\n        assert_eq!(set.get_or_insert("hello".to_string()), &"hello".to_string());\n        assert_eq!(set.len(), 1);\n        assert_eq!(set.get_or_insert("world".to_string()), &"world".to_string());\n        assert_eq!(set.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583805, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=379, prompt_tokens=16361, total_tokens=16740, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmoj9fzhiyJiOhfaun95L6zwXF2K', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_get_or_insert_with_insert_new() {\n        let mut set: HashSet<String> = HashSet::new();\n        let value = set.get_or_insert_with("fish", str::to_owned);\n        assert_eq!(value, "fish");\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_get_or_insert_with_existing_value() {\n        let mut set: HashSet<String> = ["cat", "dog"].iter().map(|&pet| pet.to_owned()).collect();\n        let value = set.get_or_insert_with("cat", str::to_owned);\n        assert_eq!(value, "cat");\n        assert_eq!(set.len(), 2);\n    }\n\n    #[test]\n    fn test_get_or_insert_with_insert_existing() {\n        let mut set: HashSet<String> = HashSet::new();\n        set.insert("dog".to_owned());\n        let value = set.get_or_insert_with("dog", str::to_owned);\n        assert_eq!(value, "dog");\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_get_or_insert_with_panic_on_non_equivalent() {\n        let mut set: HashSet<String> = HashSet::new();\n        set.get_or_insert_with("rust", |_| String::from("not rust"));\n    }\n\n    #[test]\n    fn test_get_or_insert_with_multiple() {\n        let mut set: HashSet<String> = HashSet::new();\n        let value1 = set.get_or_insert_with("pet", str::to_owned);\n        let value2 = set.get_or_insert_with("pet", str::to_owned);\n        assert_eq!(value1, value2);\n        assert_eq!(set.len(), 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583817, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=397, prompt_tokens=16361, total_tokens=16758, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmotUyrBwRkqDY4dCj83qlSqnGtM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashSet, DefaultHashBuilder};\n\n    #[test]\n    fn test_hasher() {\n        // Create a HashSet with a specified hasher\n        let hasher = DefaultHashBuilder::default();\n        let set: HashSet<i32> = HashSet::with_hasher(hasher);\n        \n        // Retrieve a reference to the hasher\n        let retrieved_hasher: &DefaultHashBuilder = set.hasher();\n        \n        // Ensure the retrieved hasher is the same as the original\n        assert_eq!(retrieved_hasher, &DefaultHashBuilder::default());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583827, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=140, prompt_tokens=16361, total_tokens=16501, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmozItvQ84h0oxwhrYA4gV5blo6G', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_insert() {\n        let mut set = HashSet::new();\n\n        // Inserting a new element\n        assert_eq!(set.insert(1), true);\n        assert_eq!(set.len(), 1);\n\n        // Inserting the same element again\n        assert_eq!(set.insert(1), false);\n        assert_eq!(set.len(), 1);\n\n        // Inserting a different element\n        assert_eq!(set.insert(2), true);\n        assert_eq!(set.len(), 2);\n\n        // Inserting another new element\n        assert_eq!(set.insert(3), true);\n        assert_eq!(set.len(), 3);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583833, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=159, prompt_tokens=16361, total_tokens=16520, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmp4f5v0u5GFhPy6kv9ny5x12OCj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_insert_unique_unchecked() {\n        let mut set: HashSet<i32> = HashSet::new();\n        unsafe {\n            let value = 42;\n            set.insert_unique_unchecked(value);\n            assert!(set.contains(&value));\n\n            let another_value = 100;\n            set.insert_unique_unchecked(another_value);\n            assert!(set.contains(&another_value));\n\n            assert_eq!(set.len(), 2);\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_insert_unique_unchecked_unsoundness() {\n        let mut set: HashSet<i32> = HashSet::new();\n        unsafe {\n            set.insert_unique_unchecked(42);\n            set.insert_unique_unchecked(42); // This should cause panic or undefined behavior\n        }\n    }\n\n    #[test]\n    fn test_insert_multiple_unique() {\n        let mut set: HashSet<String> = HashSet::new();\n        unsafe {\n            let value1 = String::from("hello");\n            let value2 = String::from("world");\n            set.insert_unique_unchecked(value1);\n            set.insert_unique_unchecked(value2);\n            assert!(set.contains(&"hello".to_string()));\n            assert!(set.contains(&"world".to_string()));\n            assert_eq!(set.len(), 2);\n        }\n    }\n\n    #[test]\n    fn test_no_duplicates() {\n        let mut set: HashSet<i32> = HashSet::new();\n        unsafe {\n            set.insert_unique_unchecked(1);\n            set.insert_unique_unchecked(2);\n            assert!(set.contains(&1));\n            assert!(set.contains(&2));\n            assert_eq!(set.len(), 2);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583838, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=378, prompt_tokens=16361, total_tokens=16739, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmpF6tAraedoy5sjiwEAuhRc2VxZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_intersection_with_different_elements() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n        let intersection: HashSet<_> = a.intersection(&b).collect();\n        assert_eq!(intersection, [2, 3].iter().collect::<HashSet<_>>());\n    }\n\n    #[test]\n    fn test_intersection_with_no_common_elements() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = [4, 5, 6].into_iter().collect();\n        let intersection: HashSet<_> = a.intersection(&b).collect();\n        assert_eq!(intersection.len(), 0);\n    }\n\n    #[test]\n    fn test_intersection_with_identical_sets() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let intersection: HashSet<_> = a.intersection(&a).collect();\n        assert_eq!(intersection, a);\n    }\n\n    #[test]\n    fn test_intersection_with_empty_set() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = HashSet::new();\n        let intersection: HashSet<_> = a.intersection(&b).collect();\n        assert!(intersection.is_empty());\n    }\n\n    #[test]\n    fn test_intersection_empty_with_empty_set() {\n        let a: HashSet<_> = HashSet::new();\n        let b: HashSet<_> = HashSet::new();\n        let intersection: HashSet<_> = a.intersection(&b).collect();\n        assert!(intersection.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583849, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=429, prompt_tokens=16361, total_tokens=16790, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmpQ2ysyco5L7sB2LbhA47ycCDGV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_is_disjoint() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let mut b = HashSet::new();\n        \n        assert_eq!(a.is_disjoint(&b), true);\n        \n        b.insert(4);\n        assert_eq!(a.is_disjoint(&b), true);\n        \n        b.insert(1);\n        assert_eq!(a.is_disjoint(&b), false);\n       \n        let c: HashSet<_> = [4, 5, 6].into_iter().collect();\n        assert_eq!(a.is_disjoint(&c), true);\n        \n        b.insert(5);\n        assert_eq!(a.is_disjoint(&b), false);\n        \n        b.clear();\n        b.insert(2);\n        assert_eq!(a.is_disjoint(&b), false);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583860, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=202, prompt_tokens=16361, total_tokens=16563, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmpX2bG2H6752aVBVKfg2BRPQLbX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_is_empty() {\n        let mut set = HashSet::new();\n        assert!(set.is_empty());\n        set.insert(1);\n        assert!(!set.is_empty());\n        set.remove(&1);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_is_empty_after_insertions() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert!(set.is_empty());\n        set.insert(1);\n        set.insert(2);\n        assert!(!set.is_empty());\n    }\n    \n    #[test]\n    fn test_is_empty_after_clear() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.clear();\n        assert!(set.is_empty());\n    }\n    \n    #[test]\n    fn test_is_empty_with_multiple_insertions() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        assert!(!set.is_empty());\n        set.insert(3);\n        assert!(!set.is_empty());\n    }\n\n    #[test]\n    fn test_is_empty_with_different_data_types() {\n        let mut set: HashSet<String> = HashSet::new();\n        assert!(set.is_empty());\n        set.insert("Hello".to_string());\n        assert!(!set.is_empty());\n        set.remove("Hello");\n        assert!(set.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583867, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=317, prompt_tokens=16361, total_tokens=16678, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmpddsx8WfWQt8pBwXfmTVsElxyC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_is_subset() {\n        let sup: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let mut set = HashSet::new();\n\n        assert_eq!(set.is_subset(&sup), true);\n        set.insert(2);\n        assert_eq!(set.is_subset(&sup), true);\n        set.insert(4);\n        assert_eq!(set.is_subset(&sup), false);\n    }\n\n    #[test]\n    fn test_is_subset_empty() {\n        let empty: HashSet<_> = HashSet::new();\n        let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n\n        assert!(empty.is_subset(&set));\n        assert!(set.is_subset(&empty) == false);\n    }\n\n    #[test]\n    fn test_is_subset_equal() {\n        let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let sup = set.clone();\n\n        assert!(set.is_subset(&sup));\n        assert!(sup.is_subset(&set));\n    }\n\n    #[test]\n    fn test_is_subset_with_disjoint_sets() {\n        let set_a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let set_b: HashSet<_> = [4, 5, 6].into_iter().collect();\n\n        assert_eq!(set_a.is_subset(&set_b), false);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583873, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=327, prompt_tokens=16361, total_tokens=16688, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmpnetI8Sz5pASJx4EXw9w2FqJ1Q', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_is_superset() {\n        let sub: HashSet<_> = [1, 2].into_iter().collect();\n        let mut set = HashSet::new();\n\n        assert_eq!(set.is_superset(&sub), false);\n\n        set.insert(0);\n        set.insert(1);\n        assert_eq!(set.is_superset(&sub), false);\n\n        set.insert(2);\n        assert_eq!(set.is_superset(&sub), true);\n    }\n\n    #[test]\n    fn test_is_superset_empty() {\n        let mut set: HashSet<_> = HashSet::new();\n        let sub: HashSet<_> = HashSet::new();\n\n        assert_eq!(set.is_superset(&sub), true);\n    }\n\n    #[test]\n    fn test_is_superset_not_superset() {\n        let mut set: HashSet<_> = [1, 2].iter().cloned().collect();\n        let sub: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n\n        assert_eq!(set.is_superset(&sub), false);\n    }\n\n    #[test]\n    fn test_is_superset_with_different_elements() {\n        let set: HashSet<_> = [1, 2, 3, 4].iter().cloned().collect();\n        let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n\n        assert_eq!(set.is_superset(&sub), true);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583883, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=337, prompt_tokens=16361, total_tokens=16698, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmpwYS6ruR7683nP2ZiKG4XZ8LuY', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Adjust this import as necessary to reference HashSet\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_iter_empty_set() {\n        let set: HashSet<i32> = HashSet::new();\n        let iter: Vec<_> = set.iter().collect();\n        assert!(iter.is_empty());\n    }\n\n    #[test]\n    fn test_iter_single_element() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        let iter: Vec<_> = set.iter().collect();\n        assert_eq!(iter.len(), 1);\n        assert!(iter.contains(&&1));\n    }\n\n    #[test]\n    fn test_iter_multiple_elements() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let iter: Vec<_> = set.iter().collect();\n        assert_eq!(iter.len(), 3);\n        assert!(iter.contains(&&1) || iter.contains(&&2) || iter.contains(&&3));\n    }\n\n    #[test]\n    fn test_iter_no_duplicates() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(1); // Inserting duplicates\n        set.insert(2);\n        let iter: Vec<_> = set.iter().collect();\n        assert_eq!(iter.len(), 2);\n        assert!(iter.contains(&&1));\n        assert!(iter.contains(&&2));\n    }\n\n    #[test]\n    fn test_iter_order() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        let iter: Vec<_> = set.iter().collect();\n        assert!(iter.len() == 3);\n        // The order is arbitrary, test contains instead.\n        assert!(iter.contains(&&1) || iter.contains(&&2) || iter.contains(&&3));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583892, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=421, prompt_tokens=16361, total_tokens=16782, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmq8z8fCMpvNo3zPbSR09khQYplf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_len() {\n        let mut set = HashSet::new();\n        assert_eq!(set.len(), 0);\n\n        set.insert(1);\n        assert_eq!(set.len(), 1);\n\n        set.insert(2);\n        assert_eq!(set.len(), 2);\n\n        set.remove(&1);\n        assert_eq!(set.len(), 1);\n        \n        set.clear();\n        assert_eq!(set.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583904, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=115, prompt_tokens=16361, total_tokens=16476, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmqLF8lmKibND5wS9d5rAAkaP4d9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn remove_existing_value() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        assert_eq!(set.remove(&1), true);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn remove_non_existing_value() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        assert_eq!(set.remove(&2), false);\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn remove_multiple_values() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        \n        assert_eq!(set.remove(&2), true);\n        assert_eq!(set.len(), 2);\n        assert_eq!(set.remove(&2), false);\n    }\n\n    #[test]\n    fn remove_with_same_reference() {\n        let mut set = HashSet::new();\n        let value = 3;\n        set.insert(value);\n        \n        assert_eq!(set.remove(&value), true);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn remove_non_hashable() {\n        #[derive(Debug, Hash, Eq, PartialEq)]\n        struct NonHashableStruct;\n        \n        let mut set = HashSet::new();\n        set.insert(NonHashableStruct);\n        assert_eq!(set.remove(&NonHashableStruct), true);\n        assert_eq!(set.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583917, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=330, prompt_tokens=16361, total_tokens=16691, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmqa0Dp1lofDznQgt73I2WkkQEsv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_replace_existing_value() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        let replaced = set.replace(1);\n        assert_eq!(replaced, Some(1));\n        assert!(set.contains(&1)); // The value should still exist in the set\n    }\n\n    #[test]\n    fn test_replace_replacing_value() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.replace(1);\n        let replaced = set.replace(2);\n        assert_eq!(replaced, None); // No value was replaced\n        assert!(set.contains(&2)); // The new value should now exist in the set\n        assert!(!set.contains(&1)); // The old value should not exist in the set\n    }\n\n    #[test]\n    fn test_replace_without_existing_value() {\n        let mut set = HashSet::new();\n        let replaced = set.replace(1);\n        assert_eq!(replaced, None); // No value was replaced\n        assert!(set.contains(&1)); // The new value should exist in the set\n    }\n\n    #[test]\n    fn test_replace_multiple_replacements() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.replace(2);\n        let replaced = set.replace(1);\n        assert_eq!(replaced, Some(1)); // The old value 1 is replaced\n        assert!(!set.contains(&1)); // The old value should not exist\n        assert!(set.contains(&2)); // The value 2 should still exist\n    }\n\n    #[test]\n    fn test_replace_vector() {\n        let mut set = HashSet::new();\n        let v1 = vec![1, 2, 3];\n        set.replace(v1.clone());\n        let v2 = vec![4, 5, 6];\n        let replaced = set.replace(v2.clone());\n        assert_eq!(replaced, None); // No value was replaced\n        assert!(set.contains(&v1)); // The original value should exist\n        assert!(set.contains(&v2)); // The new value should exist\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583932, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=482, prompt_tokens=16361, total_tokens=16843, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmqmok6COYljJXi6MzzEauyHRjDR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_reserve_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.reserve(10);\n        assert!(set.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_reserve_non_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        let current_capacity = set.capacity();\n        set.reserve(5);\n        assert!(set.capacity() >= current_capacity);\n        assert!(set.capacity() >= 5);\n    }\n\n    #[test]\n    fn test_reserve_large_number() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.reserve(usize::MAX);\n        assert!(set.capacity() >= usize::MAX);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_reserve_panic() {\n        let mut set: HashSet<i32> = HashSet::new();\n        // This should panic as it exceeds isize::MAX\n        set.reserve(usize::MAX);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583944, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=245, prompt_tokens=16361, total_tokens=16606, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmquK7Mkql7MhtPOT3j2CIxM6XmJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_retain_even_numbers() {\n        let xs = [1, 2, 3, 4, 5, 6];\n        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n        set.retain(|&k| k % 2 == 0);\n        assert_eq!(set.len(), 3);\n        let retained: Vec<i32> = set.iter().cloned().collect();\n        assert_eq!(retained, vec![2, 4, 6]);\n    }\n\n    #[test]\n    fn test_retain_empty_set() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.retain(|&k| k % 2 == 0);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_retain_none() {\n        let xs = [1, 3, 5, 7];\n        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n        set.retain(|&k| k % 2 == 0);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_retain_all() {\n        let xs = [1, 2, 3, 4, 5];\n        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n        set.retain(|&k| true);\n        assert_eq!(set.len(), 5);\n    }\n\n    #[test]\n    fn test_retain_none_condition() {\n        let xs = [1, 2, 3, 4];\n        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n        set.retain(|&k| k == 0);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_retain_conditionally() {\n        let xs = [1, 2, 3, 4, 5];\n        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n        set.retain(|&k| k > 3);\n        assert_eq!(set.len(), 2);\n        let retained: Vec<i32> = set.iter().cloned().collect();\n        assert_eq!(retained, vec![4, 5]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583952, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=524, prompt_tokens=16361, total_tokens=16885, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmr6Yis3pW0yg4KfSn4ptO4Dz03z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_shrink_to() {\n        let mut set = HashSet::with_capacity(100);\n        set.insert(1);\n        set.insert(2);\n        assert!(set.capacity() >= 100);\n        \n        set.shrink_to(10);\n        assert!(set.capacity() >= 10);\n        \n        set.shrink_to(0);\n        assert!(set.capacity() >= 2);\n        \n        set.shrink_to(10);\n        assert!(set.capacity() >= 2);\n        \n        let mut empty_set: HashSet<i32> = HashSet::new();\n        assert!(empty_set.capacity() == 0);\n        empty_set.shrink_to(5); // should not panic, and capacity remains 0\n        assert!(empty_set.capacity() == 0);\n    }\n\n    #[test]\n    #[should_panic(expected = "minimum capacity exceeded")]\n    fn test_shrink_to_panics() {\n        let mut set = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.shrink_to(3); // should panic since current capacity is 2\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583964, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=259, prompt_tokens=16361, total_tokens=16620, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmrGC01VyOlo6ecAAZjbs2UqdTNW', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut set = HashSet::with_capacity(100);\n        set.insert(1);\n        set.insert(2);\n        assert!(set.capacity() >= 100);\n        set.shrink_to_fit();\n        assert!(set.capacity() >= 2);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_empty() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.shrink_to_fit();\n        assert!(set.capacity() == 0);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_with_multiple_elements() {\n        let mut set = HashSet::with_capacity(50);\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.insert(4);\n        assert!(set.capacity() >= 50);\n        set.shrink_to_fit();\n        assert!(set.capacity() >= 4);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_after_removal() {\n        let mut set = HashSet::with_capacity(50);\n        set.insert(1);\n        set.insert(2);\n        set.remove(&1);\n        set.shrink_to_fit();\n        assert!(set.capacity() >= 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583974, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=288, prompt_tokens=16361, total_tokens=16649, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmrQJKahRxscw7y6aAQ4fuoVay6C', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_symmetric_difference() {\n        let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n        let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n        \n        let diff: HashSet<_> = a.symmetric_difference(&b).collect();\n        assert_eq!(diff, [1, 4].iter().collect::<HashSet<_>>());\n        \n        let diff2: HashSet<_> = b.symmetric_difference(&a).collect();\n        assert_eq!(diff2, diff);\n        assert_eq!(diff2, [4, 1].iter().collect::<HashSet<_>>());\n        \n        let c: HashSet<_> = [].into_iter().collect();\n        let diff_empty: HashSet<_> = a.symmetric_difference(&c).collect();\n        assert_eq!(diff_empty, a);\n        \n        let diff_empty2: HashSet<_> = c.symmetric_difference(&a).collect();\n        assert_eq!(diff_empty2, a);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583984, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=249, prompt_tokens=16361, total_tokens=16610, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmrbTSmoASMo4OahGEjmJ0a3FvAB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Use the parent module where `HashSet` is defined\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_take_existing_value() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n\n        assert_eq!(set.take(&2), Some(2));\n        assert_eq!(set.contains(&2), false); // Ensure the value is removed\n    }\n\n    #[test]\n    fn test_take_non_existing_value() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.insert(1);\n        set.insert(2);\n\n        assert_eq!(set.take(&3), None); // Trying to take a value not present\n        assert_eq!(set.len(), 2); // Set length should not change\n    }\n\n    #[test]\n    fn test_take_borrowed_value() {\n        let mut set: HashSet<String> = HashSet::new();\n        set.insert("hello".to_string());\n        set.insert("world".to_string());\n\n        let borrowed_key = "hello";\n        assert_eq!(set.take(&borrowed_key), Some("hello".to_string()));\n        assert_eq!(set.contains(&borrowed_key), false); // Ensure the borrowed value is removed\n    }\n\n    #[test]\n    fn test_take_from_empty_set() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.take(&1), None); // Taking from an empty set should return None\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748583995, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=345, prompt_tokens=16361, total_tokens=16706, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmrnXmiota3iJUvVVWlMEpTLasMf', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_try_reserve() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.try_reserve(10).is_ok(), true);\n        assert!(set.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_try_reserve_overflow() {\n        let mut set: HashSet<i32> = HashSet::new();\n        set.try_reserve(usize::MAX).unwrap_err();\n    }\n\n    #[test]\n    fn test_try_reserve_zero() {\n        let mut set: HashSet<i32> = HashSet::new();\n        assert_eq!(set.try_reserve(0).is_ok(), true);\n        assert!(set.capacity() >= 0); // Capacity should not change\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584007, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=188, prompt_tokens=16361, total_tokens=16549, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmrvXTcMFShv0MwlyiXcNGmUIc4x', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_union_with_no_common_elements() {\n        let a: HashSet<_> = [1, 2, 3].iter().copied().collect();\n        let b: HashSet<_> = [4, 5, 6].iter().copied().collect();\n        let union: HashSet<_> = a.union(&b).collect();\n        assert_eq!(union, [1, 2, 3, 4, 5, 6].iter().copied().collect::<HashSet<_>>());\n    }\n    \n    #[test]\n    fn test_union_with_some_common_elements() {\n        let a: HashSet<_> = [1, 2, 3].iter().copied().collect();\n        let b: HashSet<_> = [3, 4, 5].iter().copied().collect();\n        let union: HashSet<_> = a.union(&b).collect();\n        assert_eq!(union, [1, 2, 3, 4, 5].iter().copied().collect::<HashSet<_>>());\n    }\n\n    #[test]\n    fn test_union_with_identical_sets() {\n        let a: HashSet<_> = [1, 2, 3].iter().copied().collect();\n        let b: HashSet<_> = [1, 2, 3].iter().copied().collect();\n        let union: HashSet<_> = a.union(&b).collect();\n        assert_eq!(union, [1, 2, 3].iter().copied().collect::<HashSet<_>>());\n    }\n\n    #[test]\n    fn test_union_with_empty_set() {\n        let a: HashSet<_> = [1, 2, 3].iter().copied().collect();\n        let b: HashSet<_> = HashSet::new();\n        let union: HashSet<_> = a.union(&b).collect();\n        assert_eq!(union, [1, 2, 3].iter().copied().collect::<HashSet<_>>());\n    }\n\n    #[test]\n    fn test_union_with_two_empty_sets() {\n        let a: HashSet<_> = HashSet::new();\n        let b: HashSet<_> = HashSet::new();\n        let union: HashSet<_> = a.union(&b).collect();\n        assert_eq!(union, HashSet::new());\n    }\n\n    #[test]\n    fn test_union_with_large_sets() {\n        let a: HashSet<_> = (1..=1000).collect();\n        let b: HashSet<_> = (500..=1500).collect();\n        let union: HashSet<_> = a.union(&b).collect();\n        let expected: HashSet<_> = (1..=1500).collect();\n        assert_eq!(union, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584015, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=624, prompt_tokens=16361, total_tokens=16985, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmsD8UqZZ7bZVa3dPhujP8SBf2jV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::DefaultHashBuilder;\n\n    #[test]\n    fn test_with_capacity_and_hasher_in() {\n        let capacity = 10;\n        let hasher = DefaultHashBuilder::default();\n        let allocator = bumpalo::Bump::new();\n\n        let set: HashSet<i32, DefaultHashBuilder, bumpalo::Bump> = HashSet::with_capacity_and_hasher_in(capacity, hasher, allocator);\n\n        assert!(set.is_empty());\n        assert!(set.capacity() >= capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_in_non_zero_capacity() {\n        let capacity = 5;\n        let hasher = DefaultHashBuilder::default();\n        let allocator = bumpalo::Bump::new();\n\n        let mut set: HashSet<i32, DefaultHashBuilder, bumpalo::Bump> = HashSet::with_capacity_and_hasher_in(capacity, hasher, allocator);\n        set.insert(1);\n        set.insert(2);\n\n        assert_eq!(set.len(), 2);\n        assert!(set.capacity() >= capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_in_zero_capacity() {\n        let capacity = 0;\n        let hasher = DefaultHashBuilder::default();\n        let allocator = bumpalo::Bump::new();\n\n        let set: HashSet<i32, DefaultHashBuilder, bumpalo::Bump> = HashSet::with_capacity_and_hasher_in(capacity, hasher, allocator);\n\n        assert!(set.is_empty());\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_in_different_allocators() {\n        let capacity = 10;\n        let hasher = DefaultHashBuilder::default();\n        let allocator = bumpalo::Bump::new();\n\n        let set: HashSet<i32, DefaultHashBuilder, bumpalo::Bump> = HashSet::with_capacity_and_hasher_in(capacity, hasher, allocator);\n        set.insert(1);\n        set.insert(2);\n\n        assert!(set.len() > 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584033, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=457, prompt_tokens=16361, total_tokens=16818, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmsPBSp3LNtoVZyLK90f53LVEL99', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use hashbrown::DefaultHashBuilder;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_with_hasher_in_empty() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let set: HashSet<i32, DefaultHashBuilder, _> = HashSet::with_hasher_in(hasher, bump);\n\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_with_hasher_in_capacity() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let mut set: HashSet<i32, DefaultHashBuilder, _> = HashSet::with_hasher_in(hasher, bump);\n\n        set.insert(1);\n        set.insert(2);\n\n        assert_eq!(set.len(), 2);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n    }\n\n    #[test]\n    fn test_with_hasher_in_no_allocation() {\n        let bump = Bump::new();\n        let hasher = DefaultHashBuilder::default();\n        let set: HashSet<i32, DefaultHashBuilder, _> = HashSet::with_hasher_in(hasher, bump);\n\n        assert_eq!(set.capacity(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584045, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_54eb4bd693', usage=CompletionUsage(completion_tokens=301, prompt_tokens=16361, total_tokens=16662, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmsY3Xjt34H08kQ4xn3EbGwViHK3', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use hashbrown::DefaultHashBuilder;\n\n    #[test]\n    fn test_with_capacity_and_hasher() {\n        let hasher = DefaultHashBuilder::default();\n        let mut set = HashSet::with_capacity_and_hasher(10, hasher);\n\n        // Check that the set is initially empty.\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n\n        // Insert an element and check the set's state.\n        set.insert(1);\n        assert!(!set.is_empty());\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n\n        // Check the capacity is at least 10\n        assert!(set.raw_capacity() >= 10);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_empty() {\n        let hasher = DefaultHashBuilder::default();\n        let set = HashSet::<i32, DefaultHashBuilder>::with_capacity_and_hasher(0, hasher);\n\n        // Check that the set is initially empty and does not allocate.\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n        assert_eq!(set.raw_capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_multiple_inserts() {\n        let hasher = DefaultHashBuilder::default();\n        let mut set = HashSet::with_capacity_and_hasher(5, hasher);\n\n        // Insert multiple elements\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n    }\n\n    #[test]\n    fn test_with_capacity_and_hasher_no_realloc() {\n        let hasher = DefaultHashBuilder::default();\n        let mut set = HashSet::with_capacity_and_hasher(1, hasher);\n        \n        // Insert an element\n        set.insert(1);\n        assert_eq!(set.len(), 1);\n\n        // Insert without needing to reallocate\n        set.insert(2);\n        assert_eq!(set.len(), 2);\n        assert!(set.contains(&2));\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584054, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=479, prompt_tokens=16361, total_tokens=16840, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmskRVEPZQotTCN0zBBCJWcv9HIV', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashSet, DefaultHashBuilder};\n    \n    #[test]\n    fn test_with_hasher() {\n        let hasher = DefaultHashBuilder::default();\n        let set: HashSet<i32, DefaultHashBuilder> = HashSet::with_hasher(hasher);\n        \n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_with_hasher_inserts() {\n        let hasher = DefaultHashBuilder::default();\n        let mut set: HashSet<i32, DefaultHashBuilder> = HashSet::with_hasher(hasher);\n        \n        set.insert(1);\n        set.insert(2);\n        \n        assert_eq!(set.len(), 2);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n    }\n\n    #[test]\n    fn test_with_hasher_unique() {\n        let hasher = DefaultHashBuilder::default();\n        let mut set: HashSet<i32, DefaultHashBuilder> = HashSet::with_hasher(hasher);\n        \n        set.insert(1);\n        set.insert(1); // Inserting duplicate\n        \n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n    }\n\n    #[test]\n    fn test_with_hasher_capacity() {\n        let hasher = DefaultHashBuilder::default();\n        let set: HashSet<i32, DefaultHashBuilder> = HashSet::with_hasher(hasher);\n        \n        // Should have a capacity of 0 at initialization\n        assert_eq!(set.len(), 0);\n        // Inserting elements should change capacity\n        let mut set_with_inserts = set;\n        set_with_inserts.insert(3);\n        assert!(set_with_inserts.len() > 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584066, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=385, prompt_tokens=16361, total_tokens=16746, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmsvNTIPM1JO0vD4BFaYNhwF2eKm', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_hashset_new_in_empty() {\n        let bump = Bump::new();\n        let set: HashSet<i32> = HashSet::new_in(&bump);\n        assert_eq!(set.len(), 0);\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_hashset_new_in_capacity() {\n        let bump = Bump::new();\n        let set: HashSet<i32> = HashSet::new_in(&bump);\n        assert_eq!(set.len(), 0);\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_hashset_new_in_insert() {\n        let bump = Bump::new();\n        let mut set: HashSet<i32> = HashSet::new_in(&bump);\n        set.insert(1);\n        assert_eq!(set.len(), 1);\n        assert!(set.contains(&1));\n    }\n\n    #[test]\n    fn test_hashset_new_in_multiple_inserts() {\n        let bump = Bump::new();\n        let mut set: HashSet<i32> = HashSet::new_in(&bump);\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.len(), 3);\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(set.contains(&3));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584077, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=325, prompt_tokens=16361, total_tokens=16686, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmt4IqAZUKw1mlIyZmlksAImXCoU', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use bumpalo::Bump;\n\n    #[test]\n    fn test_with_capacity_in_zero_capacity() {\n        let bump = Bump::new();\n        let set: HashSet<i32> = HashSet::with_capacity_in(0, &bump);\n        assert!(set.is_empty());\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_in_non_zero_capacity() {\n        let bump = Bump::new();\n        let capacity = 10;\n        let set: HashSet<i32> = HashSet::with_capacity_in(capacity, &bump);\n        assert!(set.capacity() >= capacity);\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_in_insert_elements() {\n        let bump = Bump::new();\n        let capacity = 5;\n        let mut set: HashSet<i32> = HashSet::with_capacity_in(capacity, &bump);\n        \n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        set.insert(4);\n        set.insert(5);\n\n        assert_eq!(set.len(), 5);\n        assert!(set.capacity() >= capacity);\n    }\n\n    #[test]\n    fn test_with_capacity_in_preserve_capacity() {\n        let bump = Bump::new();\n        let capacity = 5;\n        let mut set: HashSet<i32> = HashSet::with_capacity_in(capacity, &bump);\n        \n        let initial_capacity = set.capacity();\n        set.insert(1);\n\n        assert_eq!(set.len(), 1);\n        assert_eq!(set.capacity(), initial_capacity);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584086, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=370, prompt_tokens=16361, total_tokens=16731, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmtDHqb8U5j5Xr27c0hNcJwJxuwN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_hash_set_new() {\n        // Create a new empty HashSet\n        let set: HashSet<i32> = HashSet::new();\n\n        // Verify that the set is empty\n        assert!(set.is_empty());\n\n        // Verify the length of the set is zero\n        assert_eq!(set.len(), 0);\n\n        // Verify the capacity is zero\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_hash_set_with_capacity() {\n        let mut set: HashSet<i32> = HashSet::new();\n\n        // Insert elements into the set\n        set.insert(1);\n        set.insert(2);\n\n        // Verify that the set contains the elements\n        assert!(set.contains(&1));\n        assert!(set.contains(&2));\n        assert!(!set.contains(&3));\n\n        // Verify the length of the set\n        assert_eq!(set.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584095, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=222, prompt_tokens=16361, total_tokens=16583, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmtN4CDtZIffXGXKEir4E3kj1jJ8', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_with_capacity() {\n        let set: HashSet<i32> = HashSet::with_capacity(10);\n        assert!(set.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let set: HashSet<i32> = HashSet::with_capacity(0);\n        assert_eq!(set.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_greater_than_zero() {\n        let set: HashSet<i32> = HashSet::with_capacity(5);\n        assert!(set.capacity() >= 5);\n    }\n\n    #[test]\n    fn test_with_capacity_non_empty_set() {\n        let mut set: HashSet<i32> = HashSet::with_capacity(10);\n        set.insert(1);\n        set.insert(2);\n        set.insert(3);\n        assert_eq!(set.len(), 3);\n        assert!(set.capacity() >= 10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584105, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=221, prompt_tokens=16361, total_tokens=16582, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmtVaKmsiLa0oxTjK42IpKGqN19t', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_set::{Entry, HashSet};\n\n    #[test]\n    fn test_get_occupied_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.entry("poneyland").or_insert();\n        \n        match set.entry("poneyland") {\n            Entry::Vacant(_) => panic!(),\n            Entry::Occupied(entry) => {\n                assert_eq!(entry.get(), &"poneyland");\n            },\n        }\n    }\n\n    #[test]\n    fn test_get_non_existent_entry() {\n        let set: HashSet<&str> = HashSet::new();\n        let entry = set.entry("nonexistent");\n        match entry {\n            Entry::Vacant(_) => assert!(true),\n            Entry::Occupied(_) => panic!(),\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584113, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=180, prompt_tokens=16361, total_tokens=16541, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmtdF3U5coC7lWLulu1lUW6dNYow', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n    use hashbrown::hash_set::Entry;\n\n    #[test]\n    fn test_remove() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.entry("poneyland").or_insert();\n        let capacity_before_remove = set.capacity();\n\n        if let Entry::Occupied(o) = set.entry("poneyland") {\n            assert_eq!(o.remove(), "poneyland");\n        }\n\n        assert_eq!(set.contains("poneyland"), false);\n        assert!(set.len() == 0 && set.capacity() == capacity_before_remove);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584121, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=140, prompt_tokens=16361, total_tokens=16501, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmtjYHP3yz9PSjBRPTrAMLDY0bMD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_vacant_entry_get() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry("poneyland");\n        assert_eq!(entry.get(), &"poneyland");\n    }\n\n    #[test]\n    fn test_vacant_entry_get_empty() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry("new_entry");\n        assert_eq!(entry.get(), &"new_entry");\n    }\n\n    #[test]\n    fn test_vacant_entry_get_after_insert() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry = set.entry("test_entry");\n        let _ = entry.insert();\n        assert_eq!(entry.get(), &"test_entry");\n    }\n\n    #[test]\n    fn test_vacant_entry_get_multiple_entries() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry1 = set.entry("first_entry");\n        let entry2 = set.entry("second_entry");\n        assert_eq!(entry1.get(), &"first_entry");\n        assert_eq!(entry2.get(), &"second_entry");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584127, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=276, prompt_tokens=16361, total_tokens=16637, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmtr3LXborB2MDLYmUNOFXqS6VgQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::HashSet;\n    use hashbrown::hash_set::Entry;\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut set: HashSet<&str> = HashSet::new();\n        \n        // Check initial state\n        assert!(set.is_empty());\n\n        // Insert a value using VacantEntry\n        if let Entry::Vacant(o) = set.entry("poneyland") {\n            o.insert();\n        }\n\n        // Check if the value was inserted\n        assert!(set.contains("poneyland"));\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_insert_existing_value() {\n        let mut set: HashSet<&str> = HashSet::new();\n        set.insert("poneyland");\n\n        // Attempt to insert an existing value\n        if let Entry::Vacant(o) = set.entry("poneyland") {\n            o.insert();\n        }\n\n        // Check the set remains unchanged\n        assert_eq!(set.len(), 1);\n        assert!(set.contains("poneyland"));\n    }\n\n    #[test]\n    fn test_insert_multiple_values() {\n        let mut set: HashSet<&str> = HashSet::new();\n        \n        // Insert multiple values\n        if let Entry::Vacant(o) = set.entry("poneyland") {\n            o.insert();\n        }\n        if let Entry::Vacant(o) = set.entry("horse land") {\n            o.insert();\n        }\n\n        // Check if all values were inserted\n        assert!(set.contains("poneyland"));\n        assert!(set.contains("horse land"));\n        assert_eq!(set.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584135, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=360, prompt_tokens=16361, total_tokens=16721, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmtySwnOUQiUt5HaMzmSvlB7LSOD', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::hash_set::{Entry, HashSet};\n\n    #[test]\n    fn test_into_value_vacant() {\n        let mut set: HashSet<&str> = HashSet::new();\n        match set.entry("poneyland") {\n            Entry::Occupied(_) => panic!(),\n            Entry::Vacant(v) => {\n                let result = v.into_value();\n                assert_eq!(result, "poneyland");\n            }\n        }\n    }\n    \n    #[test]\n    fn test_into_value_multiple_entries() {\n        let mut set: HashSet<&str> = HashSet::new();\n        let entry1 = set.entry("poneyland");\n        assert!(matches!(entry1, Entry::Vacant(_)));\n\n        let entry2 = set.entry("poneyland");\n        match entry2 {\n            Entry::Occupied(_) => panic!(),\n            Entry::Vacant(v) => {\n                let result = v.into_value();\n                assert_eq!(result, "poneyland");\n            }\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584142, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=224, prompt_tokens=16361, total_tokens=16585, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmu6HIYTrSAvxx5nKhWQli6iFyQp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use hashbrown::set::{Iter, IntoIter, Difference, SymmetricDifference, Intersection, Union, Drain};\n    use std::alloc::Allocator;\n    use std::collections::hash_map::DefaultHashBuilder;\n\n    #[test]\n    fn test_assert_covariance() {\n        let static_set: HashSet<&'static str> = HashSet::new();\n        let static_iter: Iter<&'static str> = static_set.iter();\n        let static_into_iter: IntoIter<&'static str, DefaultHashBuilder> = static_set.clone().into_iter();\n        let static_difference: Difference<&'static str, DefaultHashBuilder, _> = static_set.difference(&static_set);\n        let static_symmetric_difference: SymmetricDifference<&'static str, DefaultHashBuilder, _> = static_set.symmetric_difference(&static_set);\n        let static_intersection: Intersection<&'static str, DefaultHashBuilder, _> = static_set.intersection(&static_set);\n        let static_union: Union<&'static str, DefaultHashBuilder, _> = static_set.union(&static_set);\n        let static_drain: Drain<'static, &'static str, DefaultHashBuilder> = static_set.drain();\n\n        let _new_set: HashSet<&'new str> = set(static_set);\n        let _new_iter: Iter<'static, &'new str> = iter(static_iter);\n        let _new_into_iter: IntoIter<&'new str, DefaultHashBuilder> = into_iter(static_into_iter);\n        let _new_difference: Difference<'static, &'new str, DefaultHashBuilder, _> = difference(static_difference);\n        let _new_symmetric_difference: SymmetricDifference<'static, &'new str, DefaultHashBuilder, _> = symmetric_difference(static_symmetric_difference);\n        let _new_intersection: Intersection<'static, &'new str, DefaultHashBuilder, _> = intersection(static_intersection);\n        let _new_union: Union<'static, &'new str, DefaultHashBuilder, _> = union(static_union);\n        let _new_drain: Drain<'new, &'new str, DefaultHashBuilder> = drain(static_drain);\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584150, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=470, prompt_tokens=502, total_tokens=972, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmuKsUV2fzEdMwrqAs2ihH0Lrlne', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_difference() {\n        let bitmask = control::bitmask::BitMask(0b1100); // Example bitmask\n        let difference_result = set::assert_covariance::difference(bitmask.clone());\n\n        // Ensure the output is the same as the input type\n        assert_eq!(difference_result.0, bitmask.0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584164, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=102, prompt_tokens=16361, total_tokens=16463, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmuUPAusXx8sjEaN5L4ZM6QQ09jF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::Global;\n\n    #[test]\n    fn test_drain_covariance() {\n        let allocator = Global;\n\n        // Create a Drain with static lifetimes\n        let static_key: &\'static str = "static_key";\n        let static_value: &\'static str = "static_value";\n        let drain: Drain<\'static, &\'static str, &\'static str, Global> = Drain {\n            inner: RawDrain {\n                // Mock RawDrain initialization as per your use case\n                iter: RawIter::default(),\n                table: RawTableInner::new_uninitialized(&allocator, TableLayout::default(), 1, Fallibility::Infallible).unwrap(),\n                orig_table: NonNull::new_unchecked(ptr::null_mut()),\n                marker: PhantomData,\n            },\n        };\n\n        // Call the drain function\n        let result = drain::drain(drain);\n\n        // Verify the result is a Drain with new lifetimes\n        assert!(result.inner.items == drain.inner.items);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584174, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=224, prompt_tokens=16361, total_tokens=16585, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmub8jp2nE9IKLIufeJ64MjJpv8C', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashMap;\n\n    #[test]\n    fn test_intersection() {\n        let first_set: HashMap<&str, &str> = HashMap::from([("a", "1"), ("b", "2"), ("c", "3")]);\n        let second_set: HashMap<&str, &str> = HashMap::from([("b", "2"), ("c", "3"), ("d", "4")]);\n        \n        let first_keys: Vec<&str> = first_set.keys().cloned().collect();\n        let second_keys: Vec<&str> = second_set.keys().cloned().collect();\n\n        let intersection_result = intersection(Intersection::new(first_keys, second_keys));\n        \n        let expected_keys: Vec<&str> = vec!["b", "c"];\n        assert_eq!(intersection_result.collect::<Vec<&str>>(), expected_keys);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584181, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=203, prompt_tokens=16361, total_tokens=16564, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmuidWdvlMFur0Ps6QGty98PHEon', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::set::IntoIter;\n    use hashbrown::map::IntoIter as MapIntoIter;\n    use hashbrown::Alloc;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_into_iter() {\n        let input = MapIntoIter::default();\n        let result: IntoIter<&str, Global> = super::set::assert_covariance::into_iter(input);\n        \n        assert_eq!(result.len(), input.len());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584188, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=109, prompt_tokens=10807, total_tokens=10916, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmunKWRO1KL0EFmd0AVdSki4rUxH', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_iter() {\n        let set: HashSet<&\'static str> = HashSet::from_iter(vec!["a", "b", "c"]);\n        let iter = set.iter();\n\n        let collected: Vec<_> = iter.collect();\n\n        assert_eq!(collected.len(), 3);\n        assert!(collected.contains(&&"a"));\n        assert!(collected.contains(&&"b"));\n        assert!(collected.contains(&&"c"));\n    }\n\n    #[test]\n    fn test_iter_empty() {\n        let set: HashSet<&\'static str> = HashSet::new();\n        let iter = set.iter();\n\n        let collected: Vec<_> = iter.collect();\n\n        assert!(collected.is_empty());\n    }\n\n    #[test]\n    fn test_iter_covariance() {\n        let set: HashSet<&\'static str> = HashSet::from_iter(vec!["x", "y"]);\n        let iter = set.iter();\n\n        let mut new_iter = iter.map(|&s| s.to_string());\n        let collected: Vec<_> = new_iter.collect();\n\n        assert_eq!(collected.len(), 2);\n        assert_eq!(&collected[0], "x");\n        assert_eq!(&collected[1], "y");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584193, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=293, prompt_tokens=10991, total_tokens=11284, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmuvGhBo2GuCjLjf7zzQdDO0KpvA', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n\n    #[test]\n    fn test_set_with_static_strs() {\n        let mut input_set: HashSet<&\'static str> = HashSet::new();\n        input_set.insert("Hello");\n        input_set.insert("World");\n\n        let result: HashSet<&\'static str> = set(input_set);\n        let expected: HashSet<&\'static str> = ["Hello", "World"].iter().cloned().collect();\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_set_with_empty_set() {\n        let input_set: HashSet<&\'static str> = HashSet::new();\n        let result: HashSet<&\'static str> = set(input_set);\n        \n        let expected: HashSet<&\'static str> = HashSet::new();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_set_with_repeated_elements() {\n        let mut input_set: HashSet<&\'static str> = HashSet::new();\n        input_set.insert("Hello");\n        input_set.insert("Hello"); // Repeated entry\n\n        let result: HashSet<&\'static str> = set(input_set);\n        let expected: HashSet<&\'static str> = ["Hello"].iter().cloned().collect();\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_set_with_different_elements() {\n        let mut input_set: HashSet<&\'static str> = HashSet::new();\n        input_set.insert("Rust");\n        input_set.insert("is");\n        input_set.insert("awesome");\n\n        let result: HashSet<&\'static str> = set(input_set);\n        let expected: HashSet<&\'static str> = ["Rust", "is", "awesome"].iter().cloned().collect();\n\n        assert_eq!(result, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584201, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=405, prompt_tokens=16361, total_tokens=16766, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmv5jmHiwmmrlqx7EvtkWRN9YxwC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use std::alloc::Global;\n    use std::hash::BuildHasherDefault;\n\n    #[test]\n    fn test_symmetric_difference() {\n        let set_a: HashSet<&\'static str, BuildHasherDefault<DefaultHasher>> = \n            [(\'a\', ()), (\'b\', ())].iter().cloned().collect();\n        let set_b: HashSet<&\'static str, BuildHasherDefault<DefaultHasher>> = \n            [(\'b\', ()), (\'c\', ())].iter().cloned().collect();\n\n        let sym_diff: SymmetricDifference<_, _, Global> = set_a.symmetric_difference(&set_b);\n\n        let result: Vec<&str> = sym_diff.collect();\n        let expected: Vec<&str> = vec!["a", "c"];\n        \n        assert_eq!(result, expected);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584211, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=195, prompt_tokens=748, total_tokens=943, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmvEcEOKAvQk1roPvU00MBB12Bjd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashSet;\n    use std::alloc::Global;\n    use std::collections::hash_map::RandomState;\n\n    #[test]\n    fn test_union() {\n        let set_a: HashSet<&\'static str, RandomState> = HashSet::from_iter(vec!["a", "b", "c"]);\n        let set_b: HashSet<&\'static str, RandomState> = HashSet::from_iter(vec!["b", "c", "d"]);\n\n        let union_iter = union(Union::new(set_a.iter(), set_b.difference(set_a.iter())));\n        let union_elements: Vec<&\'static str> = union_iter.collect();\n\n        assert_eq!(union_elements, vec!["a", "b", "c", "d"]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584220, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=179, prompt_tokens=712, total_tokens=891, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmvJRlisQsic17ueaWJEBlQtEiYs', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::raw::{RawTable, RawTableInner, Global};\n    use std::alloc::Allocator;\n    use std::mem;\n\n    #[test]\n    fn test_into_table() {\n        // Create a new RawTable\n        let mut raw_table: RawTable<i32, Global> = RawTable::new();\n        let raw_table_inner = raw_table.table;\n\n        // Create an AbsentEntry\n        let absent_entry = AbsentEntry {\n            table: &mut raw_table_inner,\n            // Assuming that appropriate fields for AbsentEntry are set\n        };\n\n        // Convert AbsentEntry into table\n        let table_ref = absent_entry.into_table();\n\n        // Validate that the reference points to the correct table\n        assert_eq!(table_ref, &mut raw_table_inner);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584225, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=181, prompt_tokens=16361, total_tokens=16542, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmvQ3W4Aill8byv73u0zfNApW70x', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_and_modify_existing_entry() {\n        let mut table: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table\n            .entry(\n                hasher(&"poneyland"),\n                |&(x, _)| x == "poneyland",\n                |(k, _)| hasher(&k),\n            )\n            .or_insert(("poneyland", 42));\n\n        table\n            .entry(\n                hasher(&"poneyland"),\n                |&(x, _)| x == "poneyland",\n                |(k, _)| hasher(&k),\n            )\n            .and_modify(|(_, v)| *v += 1);\n\n        assert_eq!(\n            table.find(hasher(&"poneyland"), |&(k, _)| k == "poneyland"),\n            Some(&("poneyland", 43))\n        );\n    }\n\n    #[test]\n    fn test_and_modify_new_entry() {\n        let mut table: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        let result = table\n            .entry(\n                hasher(&"poneyland"),\n                |&(x, _)| x == "poneyland",\n                |(k, _)| hasher(&k),\n            )\n            .and_modify(|(_, v)| *v += 1)\n            .or_insert(("poneyland", 42));\n\n        assert_eq!(result, &("poneyland", 42));\n        assert_eq!(\n            table.find(hasher(&"poneyland"), |&(k, _)| k == "poneyland"),\n            Some(&("poneyland", 42))\n        );\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584232, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=436, prompt_tokens=16361, total_tokens=16797, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmva1KfebkGxkL8G1uL4eethPzBF', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_insert_occupied_entry() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&"test_key");\n\n        let _entry = table\n            .entry(hash, |&x| x == "test_key", hasher)\n            .insert("initial_value");\n\n        let occupied_entry = table\n            .entry(hash, |&x| x == "test_key", hasher)\n            .insert("updated_value");\n\n        assert_eq!(occupied_entry.get(), &"updated_value");\n    }\n\n    #[test]\n    fn test_insert_vacant_entry() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&"new_key");\n\n        let occupied_entry = table\n            .entry(hash, |&x| x == "new_key", hasher)\n            .insert("new_value");\n\n        assert_eq!(occupied_entry.get(), &"new_value");\n    }\n\n    #[test]\n    fn test_insert_replace_existing_value() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&"replace_key");\n\n        table\n            .entry(hash, |&x| x == "replace_key", hasher)\n            .insert("old_value");\n\n        let occupied_entry = table\n            .entry(hash, |&x| x == "replace_key", hasher)\n            .insert("new_value");\n\n        assert_eq!(occupied_entry.get(), &"new_value");\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584242, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=385, prompt_tokens=16361, total_tokens=16746, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmviqUx9o96qSHI0DbEAHDGcXFjx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    \n    #[test]\n    fn test_or_insert() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        // Test insertion when key is not present\n        let entry1 = table.entry(hasher(&"test_key"), |&x| x == "test_key", hasher);\n        let occupied1 = entry1.or_insert("default_value");\n        assert_eq!(unsafe { occupied1.as_ref() }, &"default_value");\n        assert!(table.find(hasher(&"test_key"), |&x| x == "test_key").is_some());\n\n        // Test insertion when the key is already present\n        let entry2 = table.entry(hasher(&"test_key"), |&x| x == "test_key", hasher);\n        let occupied2 = entry2.or_insert("new_value");\n        assert_eq!(unsafe { occupied2.as_ref() }, &"default_value");\n        assert_eq!(table.len(), 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584250, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=255, prompt_tokens=16361, total_tokens=16616, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmvpbOnPKQFSoPsbZ2Y6xtv6PtGR', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_or_insert_with() {\n        let mut table: HashTable<String> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &_| hasher.hash_one(val);\n\n        let entry = table.entry(hasher_fn("test_key"), |x| x == "test_key", |val| hasher_fn(val));\n        let occupied_entry = entry.or_insert_with(|| "default_value".to_string());\n\n        assert_eq!(occupied_entry.as_ref(), &"default_value".to_string());\n        \n        // Test inserting again to ensure it does not overwrite\n        let entry2 = table.entry(hasher_fn("test_key"), |x| x == "test_key", |val| hasher_fn(val));\n        let occupied_entry2 = entry2.or_insert_with(|| "another_value".to_string());\n\n        assert_eq!(occupied_entry2.as_ref(), &"default_value".to_string());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584257, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=235, prompt_tokens=16361, total_tokens=16596, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmvxVQExtLbmJklgUnEAOBWHYd9X', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_allocation_size() {\n        let table: HashTable<i32, Global> = HashTable::new();\n        assert_eq!(table.allocation_size(), 0); // No memory should be allocated for an empty table.\n\n        let mut table_with_capacity = HashTable::with_capacity_in(1024, Global);\n        assert!(table_with_capacity.allocation_size() > 0); // Should return a non-zero allocation size for a table with capacity.\n\n        // Insert an element and check the allocation size again\n        unsafe {\n            table_with_capacity.insert(0, 42, |_x| 0);\n        }\n        assert!(table_with_capacity.allocation_size() > 0); // Memory should be allocated after inserting an element.\n\n        // Clear the table and check the allocation size\n        table_with_capacity.clear();\n        assert!(table_with_capacity.allocation_size() > 0); // Memory should remain allocated after clearing.\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584265, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=222, prompt_tokens=16361, total_tokens=16583, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmwAm7HgHmzPoWj91eKLv5GqYjhO', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use crate::table::HashTable;\n    use std::alloc::Global;\n\n    #[test]\n    fn test_allocator() {\n        // Create an empty HashTable with the global allocator\n        let table: HashTable<i32, Global> = HashTable::new();\n\n        // Retrieve the allocator\n        let allocator = table.allocator();\n\n        // Verify that the allocator is the global allocator\n        assert_eq!(allocator.name(), Global.name());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584278, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=105, prompt_tokens=16361, total_tokens=16466, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmwGRZ3MKjS3n4NkzE7fbhNVS3gN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_capacity_with_initial_capacity() {\n        let table: HashTable<i32> = HashTable::with_capacity(100);\n        assert_eq!(table.capacity(), 100);\n    }\n\n    #[test]\n    fn test_capacity_with_increased_capacity() {\n        let mut table: HashTable<i32> = HashTable::with_capacity(100);\n        table.insert(1, 10, |&v| v);\n        table.insert(2, 20, |&v| v);\n        assert!(table.capacity() >= 100);\n    }\n\n    #[test]\n    fn test_capacity_with_default_capacity() {\n        let table: HashTable<i32> = HashTable::default();\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_capacity_after_insertion() {\n        let mut table: HashTable<i32> = HashTable::with_capacity(10);\n        for i in 0..10 {\n            table.insert(i, i * 10, |&v| v);\n        }\n        assert!(table.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_capacity_after_growing() {\n        let mut table: HashTable<i32> = HashTable::with_capacity(1);\n        for i in 0..100 {\n            table.insert(i, i, |&v| v);\n            assert!(table.capacity() >= 100);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584284, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=321, prompt_tokens=16361, total_tokens=16682, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmwQvKPYQDPgKlnEe6acYr004jMv', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import the HashTable\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_hash_table_clear() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_func = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher_func(&1), 1, hasher_func);\n        table.insert_unique(hasher_func(&2), 2, hasher_func);\n        table.insert_unique(hasher_func(&3), 3, hasher_func);\n        \n        assert!(!table.is_empty());\n        assert_eq!(table.len(), 3);\n\n        table.clear();\n        \n        assert!(table.is_empty());\n        assert_eq!(table.len(), 0);\n    }\n\n    #[test]\n    fn test_clear_on_empty_table() {\n        let mut table = HashTable::new();\n        \n        assert!(table.is_empty());\n        \n        table.clear();\n        \n        assert!(table.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584294, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=234, prompt_tokens=16361, total_tokens=16595, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmwXAkvxK0kBcQF5DbA6T9JPe9NN', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n    use std::hash::BuildHasherDefault;\n    use std::hash::Hasher;\n\n    #[test]\n    fn test_drain() {\n        let mut table = HashTable::new();\n        let hasher = BuildHasherDefault::<std::collections::hash_map::RandomState>::default();\n        let hasher_fn = |val: &| hasher.hash_one(val);\n\n        for x in 1..=3 {\n            table.insert_unique(hasher_fn(&x), x, hasher_fn);\n        }\n\n        assert!(!table.is_empty());\n\n        let drained: Vec<_> = table.drain().collect();\n        assert_eq!(drained.len(), 3);\n        assert!(table.is_empty());\n    }\n\n    #[test]\n    fn test_drain_empty_table() {\n        let mut table: HashTable<u32, BuildHasherDefault<std::collections::hash_map::RandomState>> = HashTable::new();\n        let drained: Vec<_> = table.drain().collect();\n        assert!(drained.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584301, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=237, prompt_tokens=16361, total_tokens=16598, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmwe4nhIRSB0kjoXsGFhiG6VlM5E', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use hashbrown::hash_table::Entry;\n    \n    #[test]\n    fn test_entry_insert() {\n        let mut table: HashTable<u64, _> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &u64| hasher.hash_one(val);\n\n        // Test inserting a new entry\n        let entry_result = table.entry(hasher_fn(&1), |val| *val == 1, |val| hasher_fn(val));\n        assert!(matches!(entry_result, Entry::Vacant(_)));\n        \n        // Now insert the entry\n        if let Entry::Vacant(entry) = entry_result {\n            entry.insert(1);\n        }\n\n        // Verify the entry has been inserted\n        assert_eq!(table.find(hasher_fn(&1), |val| *val == 1), Some(&1));\n    }\n\n    #[test]\n    fn test_entry_remove() {\n        let mut table: HashTable<u64, _> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &u64| hasher.hash_one(val);\n        \n        // Insert an entry\n        table.insert_unique(hasher_fn(&1), 1, |val| hasher.hash_one(val));\n        \n        // Now test the entry remove\n        let entry_result = table.entry(hasher_fn(&1), |val| *val == 1, |val| hasher_fn(val));\n        if let Entry::Occupied(entry) = entry_result {\n            entry.remove();\n        }\n\n        // Verify the entry has been removed\n        assert_eq!(table.find(hasher_fn(&1), |val| *val == 1), None);\n    }\n\n    #[test]\n    fn test_entry_vacant() {\n        let mut table: HashTable<u64, _> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &u64| hasher.hash_one(val);\n        \n        // Attempt to get a vacant entry\n        let entry_result = table.entry(hasher_fn(&2), |val| *val == 2, |val| hasher_fn(val));\n        assert!(matches!(entry_result, Entry::Vacant(_)));\n\n        // Now insert the entry\n        if let Entry::Vacant(entry) = entry_result {\n            entry.insert(2);\n        }\n\n        // Verify the entry has been inserted\n        assert_eq!(table.find(hasher_fn(&2), |val| *val == 2), Some(&2));\n    }\n\n    #[test]\n    fn test_entry_occupied() {\n        let mut table: HashTable<u64, _> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &u64| hasher.hash_one(val);\n        \n        // Insert an entry\n        table.insert_unique(hasher_fn(&3), 3, |val| hasher.hash_one(val));\n        \n        // Now test the entry\n        let entry_result = table.entry(hasher_fn(&3), |val| *val == 3, |val| hasher_fn(val));\n        assert!(matches!(entry_result, Entry::Occupied(_)));\n\n        // Verify the entry has been found\n        if let Entry::Occupied(entry) = entry_result {\n            assert_eq!(entry.get(), &3);\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584308, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=748, prompt_tokens=16361, total_tokens=17109, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmwxNqPHY6T5ZVEyunHdwQkKyIHh', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_extract_if() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        \n        for x in 0..10 {\n            table.insert_unique(hasher(&x), x, hasher);\n        }\n        \n        let drained: Vec<i32> = table.extract_if(|v| v % 2 == 0).collect();\n        \n        let evens: Vec<_> = drained.into_iter().collect();\n        let odds: Vec<_> = table.into_iter().collect();\n        \n        let expected_evens = vec![0, 2, 4, 6, 8];\n        let expected_odds = vec![1, 3, 5, 7, 9];\n        \n        assert_eq!(evens, expected_evens);\n        assert_eq!(odds, expected_odds);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584327, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=233, prompt_tokens=16361, total_tokens=16594, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmx5nbPP8rMBlceEvcxJh7IVR4PJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_find_existing_element() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher(&1), 1, hasher);\n        table.insert_unique(hasher(&2), 2, hasher);\n        table.insert_unique(hasher(&3), 3, hasher);\n\n        assert_eq!(table.find(hasher(&2), |&val| val == 2), Some(&2));\n    }\n\n    #[test]\n    fn test_find_non_existing_element() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher(&1), 1, hasher);\n        table.insert_unique(hasher(&2), 2, hasher);\n        table.insert_unique(hasher(&3), 3, hasher);\n\n        assert_eq!(table.find(hasher(&4), |&val| val == 4), None);\n    }\n\n    #[test]\n    fn test_find_with_different_hash() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher(&1), 1, hasher);\n        table.insert_unique(hasher(&2), 2, hasher);\n        table.insert_unique(hasher(&3), 3, hasher);\n\n        assert_eq!(table.find(hasher(&1), |&val| val == 1), Some(&1));\n        assert_eq!(table.find(hasher(&2), |&val| val == 2), Some(&2));\n        assert_eq!(table.find(hasher(&3), |&val| val == 3), Some(&3));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584335, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=437, prompt_tokens=16361, total_tokens=16798, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmxH5vwqeKANavK2vC4NcMMt6a8J', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n    use std::hash::BuildHasherDefault;\n    use std::hash::Hasher;\n\n    #[test]\n    fn test_find_entry_existing() {\n        let mut table = HashTable::new();\n        let mut hasher = BuildHasherDefault::default();\n\n        table.insert_unique(hasher.hash_one(&1), (1, "value1"), |val| hasher.hash_one(&val.0));\n\n        let entry = table.find_entry(hasher.hash_one(&1), |val| val.0 == 1);\n        assert!(entry.is_ok(), "Entry should exist");\n        let occupied_entry = entry.unwrap();\n        assert_eq!(occupied_entry.bucket.as_ref(), &(1, "value1"));\n    }\n\n    #[test]\n    fn test_find_entry_non_existing() {\n        let mut table = HashTable::new();\n        let mut hasher = BuildHasherDefault::default();\n\n        let entry = table.find_entry(hasher.hash_one(&2), |val| val.0 == 2);\n        assert!(entry.is_err(), "Entry should not exist");\n    }\n\n    #[test]\n    fn test_find_entry_with_different_hash() {\n        let mut table = HashTable::new();\n        let mut hasher = BuildHasherDefault::default();\n\n        table.insert_unique(hasher.hash_one(&1), (1, "value1"), |val| hasher.hash_one(&val.0));\n\n        let entry = table.find_entry(hasher.hash_one(&2), |val| val.0 == 1);\n        assert!(entry.is_ok(), "Entry should exist (hash collision)");\n        let occupied_entry = entry.unwrap();\n        assert_eq!(occupied_entry.bucket.as_ref(), &(1, "value1"));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584347, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=376, prompt_tokens=16361, total_tokens=16737, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmxWqUlaxpEzvTW4prpTIQTNIDFG', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_find_mut_existing_entry() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&1);\n        table.insert_unique(hash, (1, "a"), |val| hasher.hash_one(&val.0));\n        \n        if let Some(val) = table.find_mut(hash, |val| val.0 == 1) {\n            val.1 = "b";\n        }\n        \n        assert_eq!(table.find(hash, |val| val.0 == 1), Some(&(1, "b")));\n    }\n\n    #[test]\n    fn test_find_mut_non_existing_entry() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&2);\n        table.insert_unique(hasher.hash_one(&1), (1, "a"), |val| hasher.hash_one(&val.0));\n        \n        let result = table.find_mut(hash, |val| val.0 == 2);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_find_mut_multiple_entries() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash1 = hasher.hash_one(&1);\n        let hash2 = hasher.hash_one(&2);\n        table.insert_unique(hash1, (1, "a"), |val| hasher.hash_one(&val.0));\n        table.insert_unique(hash2, (2, "b"), |val| hasher.hash_one(&val.0));\n        \n        if let Some(val) = table.find_mut(hash1, |val| val.0 == 1) {\n            val.1 = "changed";\n        }\n        \n        assert_eq!(table.find(hash1, |val| val.0 == 1), Some(&(1, "changed")));\n        assert_eq!(table.find(hash2, |val| val.0 == 2), Some(&(2, "b")));\n    }\n\n    #[test]\n    fn test_find_mut_no_hash() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher.hash_one(&1), (1, "a"), |val| hasher.hash_one(&val.0));\n        \n        if let Some(val) = table.find_mut(hasher.hash_one(&1), |val| val.0 == 1) {\n            val.1 = "b";\n        }\n\n        assert_eq!(table.find(hasher.hash_one(&1), |val| val.0 == 1), Some(&(1, "b")));\n        assert_eq!(table.find(hasher.hash_one(&2), |val| val.0 == 2), None);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584362, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=621, prompt_tokens=16361, total_tokens=16982, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmxjdqc4K0rl1p26utDgc4WEUg27', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_get_many_mut() {\n        let mut libraries: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        for (k, v) in [\n            ("Bodleian Library", 1602),\n            ("Athenum", 1807),\n            ("Herzogin-Anna-Amalia-Bibliothek", 1691),\n            ("Library of Congress", 1800),\n        ] {\n            libraries.insert_unique(hasher(&k), (k, v), |(k, _)| hasher(&k));\n        }\n\n        let keys = ["Athenum", "Library of Congress"];\n        let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n        assert_eq!(\n            got,\n            [\n                Some(&mut ("Athenum", 1807)),\n                Some(&mut ("Library of Congress", 1800)),\n            ],\n        );\n\n        let keys = ["Athenum", "New York Public Library"];\n        let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n        assert_eq!(got, [Some(&mut ("Athenum", 1807)), None]);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_get_many_mut_panics_on_duplicate_keys() {\n        let mut libraries: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        for (k, v) in [\n            ("Athenum", 1807),\n            ("Library of Congress", 1800),\n        ] {\n            libraries.insert_unique(hasher(&k), (k, v), |(k, _)| hasher(&k));\n        }\n\n        let keys = ["Athenum", "Athenum"];\n        let _got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584375, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=518, prompt_tokens=16361, total_tokens=16879, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmxwMv82Do512eMH6UWNqnVtVzC1', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_get_many_unchecked_mut() {\n        let mut table: HashTable<(&str, u32)> = HashTable::with_capacity(4);\n        \n        // Hash function simulation for this test\n        let hasher = |val: &str| {\n            let mut hash = 0;\n            for byte in val.as_bytes() {\n                hash = hash.wrapping_add(*byte as u64);\n            }\n            hash\n        };\n\n        // Insert items into the table\n        table.insert(hasher("A"), ("A", 1), hasher);\n        table.insert(hasher("B"), ("B", 2), hasher);\n        table.insert(hasher("C"), ("C", 3), hasher);\n        \n        let hashes: [u64; 3] = [hasher("A"), hasher("B"), hasher("C")];\n        \n        // Using a closure for the `eq` argument\n        let eq = |i: usize, val: &(&str, u32)| {\n            let keys = ["A", "B", "C"];\n            keys[i] == val.0\n        };\n\n        // Safe: Retrieve mutable references\n        let results: [Option<&mut (&str, u32)>; 3] = unsafe {\n            table.get_many_unchecked_mut(hashes, eq)\n        };\n\n        // Check the results\n        assert_eq!(results[0], Some(&mut ("A", 1)));\n        assert_eq!(results[1], Some(&mut ("B", 2)));\n        assert_eq!(results[2], Some(&mut ("C", 3)));\n\n        // Test overlapping keys: this should cause undefined behavior\n        let hashes_overlap: [u64; 2] = [hasher("A"), hasher("A")];\n        let results_overlap: [Option<&mut (&str, u32)>; 2] = unsafe {\n            table.get_many_unchecked_mut(hashes_overlap, eq)\n        };\n\n        assert_eq!(results_overlap[0], Some(&mut ("A", 1)));\n        assert_eq!(results_overlap[1], Some(&mut ("A", 1)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584388, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=478, prompt_tokens=16361, total_tokens=16839, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmy5hDUAREyA5OaQifPwGcSlLmNC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Import the parent module\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_insert_unique() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash = hasher.hash_one(&1);\n\n        // Insert an element\n        let entry = table.insert_unique(hash, 1, |x| hasher.hash_one(x));\n        assert_eq!(unsafe { *entry.as_ref() }, 1);\n\n        // Insert another element\n        let entry2 = table.insert_unique(hasher.hash_one(&2), 2, |x| hasher.hash_one(x));\n        assert_eq!(unsafe { *entry2.as_ref() }, 2);\n        \n        // Assert the hash table has two entries\n        assert_eq!(table.len(), 2);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584397, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=201, prompt_tokens=16361, total_tokens=16562, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmyCZf0CJEDQ9YnLpM2TVYTyGWZe', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_is_empty() {\n        let hasher = DefaultHashBuilder::default();\n        let mut table: HashTable<i32, DefaultHashBuilder> = HashTable::new();\n        \n        // Initially, the table should be empty\n        assert!(table.is_empty());\n\n        // Insert an element\n        let hash = hasher.hash_one(&1);\n        table.insert_unique(hash, 1, |val: &_| hasher.hash_one(val));\n\n        // Table should not be empty after insertion\n        assert!(!table.is_empty());\n\n        // Clear the table\n        table.clear();\n\n        // Table should be empty again\n        assert!(table.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584404, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=166, prompt_tokens=16361, total_tokens=16527, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmyKuGZ9sV4mhjSZt5PS9BLhSO3l', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    \n    #[test]\n    fn test_iter_empty() {\n        let table: HashTable<i32, DefaultHashBuilder> = HashTable::new();\n        let mut iter = table.iter();\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_single_element() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher.hash_one(&1), 1, hasher);\n        \n        let mut iter = table.iter();\n        assert_eq!(iter.next(), Some(&1));\n        assert_eq!(iter.next(), None);\n    }\n\n    #[test]\n    fn test_iter_multiple_elements() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher.hash_one(&1), 1, hasher);\n        table.insert_unique(hasher.hash_one(&2), 2, hasher);\n        table.insert_unique(hasher.hash_one(&3), 3, hasher);\n        \n        let mut iter = table.iter();\n        let mut elements: Vec<_> = iter.collect();\n        elements.sort(); // Sort elements to ensure order-independent test\n        assert_eq!(elements, vec![&1, &2, &3]);\n    }\n\n    #[test]\n    fn test_iter_after_insertion() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher.hash_one(&1), 1, hasher);\n        table.insert_unique(hasher.hash_one(&2), 2, hasher);\n        \n        let mut iter = table.iter();\n        assert_eq!(iter.next(), Some(&1));\n        table.insert_unique(hasher.hash_one(&3), 3, hasher);\n        assert_eq!(iter.next(), Some(&2));\n        assert_eq!(iter.next(), None);\n        \n        // Collecting after insertion\n        let mut extra_iter = table.iter();\n        assert_eq!(extra_iter.next(), Some(&3));\n    }\n\n    #[test]\n    fn test_iter_unknown_order() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher.hash_one(&1), 1, hasher);\n        table.insert_unique(hasher.hash_one(&3), 3, hasher);\n        table.insert_unique(hasher.hash_one(&2), 2, hasher);\n        \n        let mut iter = table.iter();\n        let mut elements: Vec<_> = iter.collect();\n        elements.sort(); // Sort to ensure order-independent test\n        assert_eq!(elements, vec![&1, &2, &3]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584412, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=588, prompt_tokens=16361, total_tokens=16949, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmyfTQO9qyB9FhxDdnsIwEBp6L1Z', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_iter_hash() {\n        let mut table = HashTable::new();\n        let hasher = |val: &_| val.hash();\n\n        table.insert_unique(hasher(&"a"), "a", hasher);\n        table.insert_unique(hasher(&"a"), "b", hasher);\n        table.insert_unique(hasher(&"b"), "c", hasher);\n\n        let hash = hasher(&"a");\n        let mut results = Vec::new();\n\n        // Collect elements yielded by iter_hash\n        for x in unsafe { table.iter_hash(hash) } {\n            results.push(x);\n        }\n\n        // Check that "a" and "b" are in the results (and that at least one of them is present)\n        assert!(results.contains(&"a"));\n        assert!(results.contains(&"b"));\n        assert!(results.len() <= 3); // Ensure we do not have more than possible elements\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584433, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=230, prompt_tokens=16361, total_tokens=16591, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmykEa9poCufbYTrJKAXSr6vKnM4', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_iter_hash_mut() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hash_fn(&1), 2, hash_fn);\n        table.insert_unique(hash_fn(&1), 3, hash_fn);\n        table.insert_unique(hash_fn(&2), 5, hash_fn);\n\n        // Update matching values using iter_hash_mut\n        for val in table.iter_hash_mut(hash_fn(&1)) {\n            *val *= 2;\n        }\n\n        assert_eq!(table.len(), 3);\n        let mut vec: Vec<i32> = Vec::new();\n\n        for val in &table {\n            vec.push(*val);\n        }\n\n        assert!(vec.contains(&4));\n        assert!(vec.contains(&6));\n    }\n\n    #[test]\n    fn test_iter_hash_mut_no_match() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hash_fn(&3), 4, hash_fn);\n        table.insert_unique(hash_fn(&5), 6, hash_fn);\n\n        // Update using a hash that has no matching entry\n        for val in table.iter_hash_mut(hash_fn(&1)) {\n            *val *= 2; // Should not alter anything\n        }\n\n        assert_eq!(table.len(), 2);\n        let mut vec: Vec<i32> = Vec::new();\n\n        for val in &table {\n            vec.push(*val);\n        }\n\n        assert!(vec.contains(&4));\n        assert!(vec.contains(&6));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584438, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=391, prompt_tokens=16361, total_tokens=16752, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmyuY8FRQIvWa4Jfne5wAgTQVSkd', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_iter_mut() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        table.insert_unique(hasher(&1), 1, hasher);\n        table.insert_unique(hasher(&2), 2, hasher);\n        table.insert_unique(hasher(&3), 3, hasher);\n\n        for val in table.iter_mut() {\n            *val *= 2; // Modify values\n        }\n\n        assert_eq!(table.len(), 3);\n        let mut vec: Vec<i32> = Vec::new();\n\n        for val in &table {\n            vec.push(*val); // Collect values\n        }\n\n        vec.sort_unstable();\n        assert_eq!(vec, [2, 4, 6]);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584448, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=209, prompt_tokens=16361, total_tokens=16570, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmz0GR0Jj96HKAoFFpJqJPU4LpYu', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_hash_table_len() {\n        let hasher = DefaultHashBuilder::default();\n        let hasher_fn = |val: &_| hasher.hash_one(val);\n        \n        let mut table = HashTable::new();\n        \n        // Test initial length\n        assert_eq!(table.len(), 0);\n\n        // Insert an element\n        table.insert_unique(hasher_fn(&1), 1, hasher);\n        assert_eq!(table.len(), 1);\n\n        // Insert another element\n        table.insert_unique(hasher_fn(&2), 2, hasher);\n        assert_eq!(table.len(), 2);\n\n        // Remove an element\n        unsafe {\n            let bucket = table.find_or_find_insert_slot(hasher_fn(&1), |_| true, hasher).unwrap();\n            table.remove(bucket);\n        }\n        assert_eq!(table.len(), 1);\n        \n        // Clear the table\n        table.clear();\n        assert_eq!(table.len(), 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584454, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=234, prompt_tokens=16361, total_tokens=16595, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmz6kHMr20JRhi2tA8oUOsWAnUKp', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use bumpalo::Bump;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_new_in() {\n        let bump = Bump::new();\n        let table: HashTable<_, _> = HashTable::new_in(&bump);\n\n        // The created HashTable holds no elements\n        assert_eq!(table.len(), 0);\n\n        // The created HashTable also doesn\'t allocate memory\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_insert_into_new_in() {\n        let bump = Bump::new();\n        let mut table: HashTable<_, _> = HashTable::new_in(&bump);\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        // Insert element into created HashTable\n        table.insert_unique(hasher(&"One"), "One", hasher);\n\n        // Check that the HashTable now holds 1 element\n        assert_eq!(table.len(), 1);\n        // Check that it has allocated some capacity\n        assert!(table.capacity() > 0);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584460, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=264, prompt_tokens=16361, total_tokens=16625, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmzE3Ek1KGkg99sAW2cNBjuelwEx', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    \n    #[test]\n    fn test_reserve() {\n        let mut table: HashTable<i32> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &i32| hasher.hash_one(val);\n        \n        // Initial capacity check\n        assert_eq!(table.capacity(), 0);\n        \n        // Reserve space for 10 elements\n        table.reserve(10, hash_fn);\n        assert!(table.capacity() >= 10);\n        \n        // Reserve space for more elements\n        table.reserve(20, hash_fn);\n        assert!(table.capacity() >= 30);\n        \n        // Reserve space for 0 elements (should not panic)\n        table.reserve(0, hash_fn);\n        assert!(table.capacity() >= 30);\n\n        // Check the length of the table\n        assert_eq!(table.len(), 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_reserve_panic_on_exceeding_max_capacity() {\n        let mut table: HashTable<i32> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &i32| hasher.hash_one(val);\n\n        // Reserve capacity that exceeds the maximum size\n        let _ = table.reserve(usize::MAX, hash_fn);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584468, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=309, prompt_tokens=16361, total_tokens=16670, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmzLLVgqaWnPi2eKOf8QY9FSfqb7', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_retain() {\n        let mut table = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        for x in 1..=6 {\n            table.insert_unique(hasher(&x), x, hasher);\n        }\n        table.retain(|&mut x| x % 2 == 0);\n        assert_eq!(table.len(), 3);\n        assert!(table.get(hasher(&2), |&x| x == 2).is_some());\n        assert!(table.get(hasher(&4), |&x| x == 4).is_some());\n        assert!(table.get(hasher(&6), |&x| x == 6).is_some());\n        assert!(table.get(hasher(&1), |&x| x == 1).is_none());\n        assert!(table.get(hasher(&3), |&x| x == 3).is_none());\n        assert!(table.get(hasher(&5), |&x| x == 5).is_none());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584475, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=272, prompt_tokens=16361, total_tokens=16633, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmzTyeWnsaovG8tXNFY1VyTOoAAh', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_shrink_to() {\n        let mut table = HashTable::with_capacity(100);\n        let hasher = DefaultHashBuilder::default();\n        let hash_hasher = |val: &_| hasher.hash_one(val);\n        \n        table.insert_unique(hash_hasher(&1), 1, hash_hasher);\n        table.insert_unique(hash_hasher(&2), 2, hash_hasher);\n        assert!(table.capacity() >= 100);\n        \n        table.shrink_to(10, hash_hasher);\n        assert!(table.capacity() >= 10);\n        \n        table.shrink_to(0, hash_hasher);\n        assert!(table.capacity() >= 2);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_shrink_to_panic_due_to_small_capacity() {\n        let mut table = HashTable::with_capacity(5);\n        let hasher = DefaultHashBuilder::default();\n        let hash_hasher = |val: &_| hasher.hash_one(val);\n        \n        table.insert_unique(hash_hasher(&1), 1, hash_hasher);\n        table.shrink_to(10, hash_hasher);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584483, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=274, prompt_tokens=16361, total_tokens=16635, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcmzb9gaZ0uJRoDGX9Y2XBsu3qItM', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_shrink_to_fit() {\n        let mut table = HashTable::with_capacity(100);\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &_| hasher.hash_one(val);\n        \n        table.insert_unique(hash_fn(&1), 1, hash_fn);\n        table.insert_unique(hash_fn(&2), 2, hash_fn);\n        \n        assert!(table.capacity() >= 100);\n        table.shrink_to_fit(hash_fn);\n        assert!(table.capacity() >= 2);\n        assert_eq!(table.len(), 2);\n    }\n\n    #[test]\n    fn test_shrink_to_fit_empty_table() {\n        let mut table: HashTable<i32, Global> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hash_fn = |val: &_| hasher.hash_one(val);\n\n        table.shrink_to_fit(hash_fn);\n        assert!(table.capacity() >= 0);\n        assert!(table.is_empty());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584491, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=253, prompt_tokens=16361, total_tokens=16614, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmzjR2n18S2CDp3BEtM0iSI6VtbQ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_try_reserve_with_enough_capacity() {\n        let mut table: HashTable<i32> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        assert!(table.try_reserve(10, hasher).is_ok());\n        assert_eq!(table.capacity(), 10);\n    }\n\n    #[test]\n    fn test_try_reserve_with_zero_capacity() {\n        let mut table: HashTable<i32> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        assert!(table.try_reserve(0, hasher).is_ok());\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_try_reserve_with_exceeding_capacity() {\n        let mut table: HashTable<i32> = HashTable::with_capacity(1);\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        // Fill the table to the brim\n        table.try_reserve(1, hasher).expect("Should succeed");\n        assert!(table.try_reserve(2, hasher).is_err());\n    }\n\n    #[test]\n    fn test_try_reserve_with_large_capacity() {\n        let mut table: HashTable<i32> = HashTable::with_capacity(1);\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        // Attempt to reserve a large number\n        assert!(table.try_reserve(usize::MAX, hasher).is_err());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584499, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=406, prompt_tokens=16361, total_tokens=16767, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmzrJj8Kf7RLnPUIIIOavJThyKMS', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use bumpalo::Bump;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_with_capacity_in() {\n        let bump = Bump::new();\n        let mut table = HashTable::with_capacity_in(5, &bump);\n        \n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= 5);\n\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher(&"One"), "One", hasher);\n        table.insert_unique(hasher(&"Two"), "Two", hasher);\n        table.insert_unique(hasher(&"Three"), "Three", hasher);\n        table.insert_unique(hasher(&"Four"), "Four", hasher);\n        table.insert_unique(hasher(&"Five"), "Five", hasher);\n\n        assert_eq!(table.len(), 5);\n        assert_eq!(table.capacity(), table.capacity());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584507, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=221, prompt_tokens=16361, total_tokens=16582, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-BcmzzTA47mBm4jLpZpN6gTP9rXLSC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_hash_table_new() {\n        let table: HashTable<&str> = HashTable::new();\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_hash_table_new_with_capacity() {\n        let table: HashTable<i32> = HashTable::with_capacity(10);\n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= 10);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584515, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=127, prompt_tokens=16361, total_tokens=16488, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcn06jL7hDXGA1Jr7GZE2jw0MrwA9', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable; // Ensure the HashTable is properly imported\n\n    #[test]\n    fn test_with_capacity_non_zero() {\n        let table: HashTable<&str> = HashTable::with_capacity(10);\n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= 10);\n    }\n\n    #[test]\n    fn test_with_capacity_zero() {\n        let table: HashTable<&str> = HashTable::with_capacity(0);\n        assert_eq!(table.len(), 0);\n        assert_eq!(table.capacity(), 0);\n    }\n\n    #[test]\n    fn test_with_capacity_large_number() {\n        let table: HashTable<i32> = HashTable::with_capacity(1_000_000);\n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= 1_000_000);\n    }\n\n    #[test]\n    fn test_with_capacity_edge_case() {\n        let table: HashTable<u32> = HashTable::with_capacity(1);\n        assert_eq!(table.len(), 0);\n        assert!(table.capacity() >= 1);\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584522, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=252, prompt_tokens=16361, total_tokens=16613, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcn0DzDankpJT4f5LCFmqsLYH0Ik5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_occupied_entry_get() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        table.insert_unique(hasher(&"test"), "test", hasher);\n\n        match table.entry(hasher(&"test"), |&x| x == "test", hasher) {\n            Entry::Vacant(_) => panic!("Expected entry to be occupied"),\n            Entry::Occupied(entry) => {\n                assert_eq!(entry.get(), &"test");\n            },\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584529, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=172, prompt_tokens=16361, total_tokens=16533, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcn0LwYvjPNqKP7ly2IL7wPE9OdwX', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_get_mut() {\n        let mut table: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n        \n        table.insert_unique(hasher(&"poneyland"), ("poneyland", 12), |(k, _)| hasher(&k));\n        \n        // Modify the entry and check the result\n        if let Entry::Occupied(mut o) = table.entry(hasher(&"poneyland"), |&(x, _)| x == "poneyland", |(k, _)| hasher(&k)) {\n            let value = o.get_mut();\n            value.1 += 10;\n            assert_eq!(o.get().1, 22);\n            \n            // Modify it again\n            o.get_mut().1 += 2;\n        }\n\n        assert_eq!(table.find(hasher(&"poneyland"), |&(x, _)| x == "poneyland",), Some(&("poneyland", 24)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584537, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=261, prompt_tokens=16361, total_tokens=16622, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcn0TOurZb5IQIWJYnFgaLRMimIcB', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::{HashTable, DefaultHashBuilder};\n\n    #[test]\n    fn test_into_mut() {\n        let mut table: HashTable<(&str, u32)> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        table.insert_unique(hasher(&"test_key"), ("test_key", 42), |(k, _)| hasher(&k));\n\n        match table.entry(hasher(&"test_key"), |&(x, _)| x == "test_key", |(k, _)| hasher(&k)) {\n            Entry::Occupied(entry) => {\n                let value: &mut (&str, u32) = entry.into_mut();\n                value.1 += 1;\n                assert_eq!(value.1, 43);\n            },\n            Entry::Vacant(_) => panic!("Entry should be occupied."),\n        }\n\n        assert_eq!(table.find(hasher(&"test_key"), |&(x, _)| x == "test_key"), Some(&("test_key", 43)));\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584545, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=232, prompt_tokens=16361, total_tokens=16593, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcn0cseJV9VOnm3gmi3kovmQb6YyC', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{table::{OccupiedEntry, HashTable}}; // Adjust path according to your project structure\n\n    #[test]\n    fn test_into_table() {\n        let mut table: HashTable<i32, Global> = HashTable::with_capacity(10);\n        let entry = table.insert(42);\n        let occupied_entry = entry.entry();\n        \n        let table_ref = occupied_entry.into_table();\n        \n        // Validate that the table reference returned is correct\n        assert_eq!(table_ref.len(), 1);\n        assert_eq!(table_ref.get(42), Some(&42));\n    }\n\n    #[test]\n    fn test_into_table_empty() {\n        let table: HashTable<i32, Global> = HashTable::with_capacity(10);\n        let result = table.get(42); // Entry for non-existent key\n\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_into_table_multiple_entries() {\n        let mut table: HashTable<i32, Global> = HashTable::with_capacity(10);\n        table.insert(10);\n        table.insert(20);\n        \n        let entry = table.get(10).unwrap();\n        let occupied_entry = entry.entry();\n        \n        let table_ref = occupied_entry.into_table();\n        \n        assert_eq!(table_ref.len(), 2); // Two entries in the table\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584554, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=292, prompt_tokens=16361, total_tokens=16653, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcn0kjjtF9JOjOhFkMrdha5T2L8wl', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::hash_table::Entry;\n    use hashbrown::HashTable;\n    use hashbrown::DefaultHashBuilder;\n    use std::hash::BuildHasher;\n\n    #[test]\n    fn test_remove() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hasher = DefaultHashBuilder::default();\n        let hasher = |val: &_| hasher.hash_one(val);\n\n        table.insert_unique(hasher(&"test"), "test", hasher);\n        let capacity_before_remove = table.capacity();\n\n        if let Entry::Occupied(o) = table.entry(hasher(&"test"), |&x| x == "test", hasher) {\n            let (removed_value, vacant_entry) = o.remove();\n            assert_eq!(removed_value, "test");\n            assert!(table.find(hasher(&"test"), |&x| x == "test").is_none());\n            assert!(table.len() == 0 && table.capacity() == capacity_before_remove);\n        } else {\n            panic!("Entry not found");\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584562, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_62a23a81ef', usage=CompletionUsage(completion_tokens=239, prompt_tokens=16361, total_tokens=16600, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcn108VqmpCth0sQdbMpOIl9K3Au5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use hashbrown::HashTable;\n\n    #[test]\n    fn test_insert_new_entry() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hash = DefaultHashBuilder::default().hash_one(&"test_key");\n        let entry = table.entry(hash, |&x| x == "test_key", |val| val);\n\n        if let Entry::Vacant(o) = entry {\n            let occupied_entry = o.insert("test_value");\n            assert_eq!(occupied_entry.as_ref(), &"test_value");\n            assert_eq!(table.find(hash, |&x| x == "test_value"), Some(occupied_entry.as_ref()));\n        } else {\n            panic!("Entry should be vacant");\n        }\n    }\n    \n    #[test]\n    fn test_insert_replace_existing_entry() {\n        let mut table: HashTable<&str> = HashTable::new();\n        let hash = DefaultHashBuilder::default().hash_one(&"test_key");\n        \n        // Insert first value\n        {\n            let entry = table.entry(hash, |&x| x == "test_key", |val| val);\n            if let Entry::Vacant(o) = entry {\n                let occupied_entry = o.insert("value_one");\n                assert_eq!(occupied_entry.as_ref(), &"value_one");\n            } else {\n                panic!("Entry should be vacant");\n            }\n        }\n\n        // Insert second value, replacing the first\n        {\n            let entry = table.entry(hash, |&x| x == "test_key", |val| val);\n            if let Entry::Occupied(o) = entry {\n                let occupied_entry = o.insert("value_two");\n                assert_eq!(occupied_entry.as_ref(), &"value_two");\n                assert_eq!(table.find(hash, |&x| x == "value_two"), Some(occupied_entry.as_ref()));\n                assert_eq!(table.find(hash, |&x| x == "value_one"), None);\n            } else {\n                panic!("Entry should be occupied");\n            }\n        }\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584578, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=436, prompt_tokens=16361, total_tokens=16797, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcn180HBCWYPJjiwTqPcEl2iLcOOJ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content="```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::table::{HashTable, VacantEntry};\n\n    #[test]\n    fn test_into_table() {\n        let mut table: HashTable<u32, _> = HashTable::with_capacity(10);\n        let vacant_entry: VacantEntry<u32, _> = table.vacant_entry(42);\n        \n        // Convert VacantEntry into a mutable reference to the underlying HashTable\n        let table_ref: &mut HashTable<u32, _> = vacant_entry.into_table();\n        \n        // Ensure the table reference is still valid\n        assert_eq!(table_ref.len(), 0);\n        \n        // Try inserting a value to the table to ensure it's working\n        table_ref.insert(42, 100);\n        assert_eq!(table_ref.len(), 1);\n        assert_eq!(table_ref.get(&42).unwrap(), &100);\n    }\n}\n```", refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584586, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=195, prompt_tokens=16361, total_tokens=16556, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
ChatCompletion(id='chatcmpl-Bcn1DB45mG3wcTLLaZmGeRlUqTYn5', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::ptr;\n\n    #[test]\n    fn test_invalid_mut() {\n        let addr: usize = 0x1 as usize; // Sample invalid address\n        let ptr: *mut i32 = invalid_mut(addr);\n        \n        // Ensure that the pointer is the same as the address we passed\n        assert_eq!(ptr as usize, addr);\n        \n        // Check that the pointer is non-null\n        assert!(!ptr.is_null());\n    }\n\n    #[test]\n    fn test_invalid_mut_different_types() {\n        let addr: usize = 0x2 as usize; // Sample invalid address\n        let ptr: *mut f64 = invalid_mut(addr);\n        \n        // Ensure that the pointer is the same as the address we passed\n        assert_eq!(ptr as usize, addr);\n        \n        // Check that the pointer is non-null\n        assert!(!ptr.is_null());\n    }\n}\n```', refusal=None, role='assistant', annotations=[], audio=None, function_call=None, tool_calls=None))], created=1748584591, model='gpt-4o-mini-2024-07-18', object='chat.completion', service_tier='default', system_fingerprint='fp_34a54ae93c', usage=CompletionUsage(completion_tokens=203, prompt_tokens=170, total_tokens=373, completion_tokens_details=CompletionTokensDetails(accepted_prediction_tokens=0, audio_tokens=0, reasoning_tokens=0, rejected_prediction_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=0, cached_tokens=0)))
71
({'dependencies': {"<&'a map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], "<&'a mut map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::IterMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], "<&'a mut table::HashTable<T, A> as core::iter::IntoIterator>::into_iter": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::IterMut'], "<&'a set::HashSet<T, S, A> as core::iter::IntoIterator>::into_iter": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Iter'], "<&'a table::HashTable<T, A> as core::iter::IntoIterator>::into_iter": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::Iter'], '<&set::HashSet<T, S, A> as core::ops::BitAnd<&set::HashSet<T, S, A>>>::bitand': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<&set::HashSet<T, S, A> as core::ops::BitOr<&set::HashSet<T, S, A>>>::bitor': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<&set::HashSet<T, S, A> as core::ops::BitXor<&set::HashSet<T, S, A>>>::bitxor': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<&set::HashSet<T, S, A> as core::ops::Sub<&set::HashSet<T, S, A>>>::sub': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<TryReserveError as core::clone::Clone>::clone': ['TryReserveError', 'core::alloc::Layout'], '<TryReserveError as core::cmp::Eq>::assert_receiver_is_total_eq': ['TryReserveError', 'core::alloc::Layout'], '<TryReserveError as core::cmp::PartialEq>::eq': ['TryReserveError', 'core::alloc::Layout'], '<TryReserveError as core::fmt::Debug>::fmt': ['TryReserveError', 'core::alloc::Layout', 'core::fmt::Formatter', 'core::marker::Sized', 'core::result::Result'], '<[control::tag::Tag] as control::tag::TagSliceExt>::fill_tag': ['control::tag::Tag'], '<control::bitmask::BitMask as core::clone::Clone>::clone': ['control::bitmask::BitMask'], '<control::bitmask::BitMask as core::iter::IntoIterator>::into_iter': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter'], '<control::bitmask::BitMaskIter as core::clone::Clone>::clone': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter'], '<control::bitmask::BitMaskIter as core::iter::Iterator>::next': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::option::Option'], '<control::group::sse2::Group as core::clone::Clone>::clone': ['control::group::sse2::Group', 'core::arch::x86_64::__m128i'], '<control::tag::Tag as core::clone::Clone>::clone': ['control::tag::Tag'], '<control::tag::Tag as core::cmp::Eq>::assert_receiver_is_total_eq': ['control::tag::Tag'], '<control::tag::Tag as core::cmp::PartialEq>::eq': ['control::tag::Tag'], '<control::tag::Tag as core::fmt::Debug>::fmt': ['control::tag::Tag', 'core::fmt::Formatter', 'core::marker::Sized', 'core::result::Result'], "<map::Drain<'_, K, V, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], "<map::Drain<'_, K, V, A> as core::iter::ExactSizeIterator>::len": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], "<map::Drain<'_, K, V, A> as core::iter::Iterator>::fold": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], "<map::Drain<'_, K, V, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], "<map::Drain<'_, K, V, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], "<map::Entry<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "<map::EntryRef<'_, '_, K, Q, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::EntryRef', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "<map::ExtractIf<'_, K, V, F, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::ExtractIf', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], "<map::ExtractIf<'_, K, V, F, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::ExtractIf', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], '<map::HashMap<K, V, S, A> as core::clone::Clone>::clone': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], '<map::HashMap<K, V, S, A> as core::clone::Clone>::clone_from': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], '<map::HashMap<K, V, S, A> as core::cmp::PartialEq>::eq': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], '<map::HashMap<K, V, S, A> as core::default::Default>::default': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], '<map::HashMap<K, V, S, A> as core::fmt::Debug>::fmt': ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], "<map::HashMap<K, V, S, A> as core::iter::Extend<&'a (K, V)>>::extend": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'core::iter::IntoIterator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], "<map::HashMap<K, V, S, A> as core::iter::Extend<(&'a K, &'a V)>>::extend": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'core::iter::IntoIterator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], '<map::HashMap<K, V, S, A> as core::iter::Extend<(K, V)>>::extend': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'core::iter::IntoIterator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], '<map::HashMap<K, V, S, A> as core::iter::FromIterator<(K, V)>>::from_iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'core::iter::IntoIterator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], '<map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], '<map::HashMap<K, V, S, A> as core::ops::Index<&Q>>::index': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], '<map::HashMap<K, V, foldhash::fast::RandomState, A> as core::convert::From<[(K, V); N]>>::from': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], '<map::IntoIter<K, V, A> as core::default::Default>::default': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoIter<K, V, A> as core::fmt::Debug>::fmt': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'core::result::Result', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoIter<K, V, A> as core::iter::ExactSizeIterator>::len': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoIter<K, V, A> as core::iter::Iterator>::fold': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoIter<K, V, A> as core::iter::Iterator>::next': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoIter<K, V, A> as core::iter::Iterator>::size_hint': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoKeys<K, V, A> as core::default::Default>::default': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoKeys', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoKeys<K, V, A> as core::fmt::Debug>::fmt': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'core::result::Result', 'map::IntoIter', 'map::IntoKeys', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoKeys<K, V, A> as core::iter::ExactSizeIterator>::len': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoKeys', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoKeys<K, V, A> as core::iter::Iterator>::fold': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoKeys', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoKeys<K, V, A> as core::iter::Iterator>::next': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoKeys', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoKeys<K, V, A> as core::iter::Iterator>::size_hint': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoKeys', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoValues<K, V, A> as core::default::Default>::default': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoValues', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoValues<K, V, A> as core::fmt::Debug>::fmt': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'core::result::Result', 'map::IntoIter', 'map::IntoValues', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoValues<K, V, A> as core::iter::ExactSizeIterator>::len': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoValues', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoValues<K, V, A> as core::iter::Iterator>::fold': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoValues', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoValues<K, V, A> as core::iter::Iterator>::next': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoValues', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<map::IntoValues<K, V, A> as core::iter::Iterator>::size_hint': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoValues', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], "<map::Iter<'_, K, V> as core::clone::Clone>::clone": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Iter<'_, K, V> as core::default::Default>::default": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Iter<'_, K, V> as core::fmt::Debug>::fmt": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Iter<'_, K, V> as core::iter::ExactSizeIterator>::len": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Iter<'a, K, V> as core::iter::Iterator>::fold": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Iter<'a, K, V> as core::iter::Iterator>::next": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Iter<'a, K, V> as core::iter::Iterator>::size_hint": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::IterMut<'_, K, V> as core::default::Default>::default": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::IterMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::IterMut<'_, K, V> as core::fmt::Debug>::fmt": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::IterMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::IterMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::IterMut<'a, K, V> as core::iter::Iterator>::fold": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::IterMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::IterMut<'a, K, V> as core::iter::Iterator>::next": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IterMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::IterMut<'a, K, V> as core::iter::Iterator>::size_hint": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IterMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Keys<'_, K, V> as core::clone::Clone>::clone": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Keys<'_, K, V> as core::default::Default>::default": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Keys<'_, K, V> as core::fmt::Debug>::fmt": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Keys<'_, K, V> as core::iter::ExactSizeIterator>::len": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Keys<'a, K, V> as core::iter::Iterator>::fold": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Keys<'a, K, V> as core::iter::Iterator>::next": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Keys<'a, K, V> as core::iter::Iterator>::size_hint": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::OccupiedEntry<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "<map::OccupiedError<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'map::OccupiedEntry', 'map::OccupiedError', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "<map::OccupiedError<'_, K, V, S, A> as core::fmt::Display>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'map::OccupiedEntry', 'map::OccupiedError', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "<map::VacantEntry<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'map::VacantEntry', 'raw::RawTable', 'raw::RawTableInner'], "<map::VacantEntryRef<'_, '_, K, Q, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'map::VacantEntryRef', 'raw::RawTable', 'raw::RawTableInner'], "<map::Values<'_, K, V> as core::clone::Clone>::clone": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Values<'_, K, V> as core::default::Default>::default": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Values<'_, K, V> as core::fmt::Debug>::fmt": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Values<'_, K, V> as core::iter::ExactSizeIterator>::len": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Values<'a, K, V> as core::iter::Iterator>::fold": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Values<'a, K, V> as core::iter::Iterator>::next": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::Values<'a, K, V> as core::iter::Iterator>::size_hint": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::ValuesMut<'_, K, V> as core::default::Default>::default": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::IterMut', 'map::ValuesMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::ValuesMut<'_, K, V> as core::fmt::Debug>::fmt": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::IterMut', 'map::ValuesMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::ValuesMut<'_, K, V> as core::iter::ExactSizeIterator>::len": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::IterMut', 'map::ValuesMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::fold": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::IterMut', 'map::ValuesMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::next": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IterMut', 'map::ValuesMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::size_hint": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IterMut', 'map::ValuesMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], '<raw::Bucket<T> as core::clone::Clone>::clone': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], '<raw::Fallibility as core::clone::Clone>::clone': ['raw::Fallibility'], '<raw::FullBucketsIndices as core::iter::Iterator>::next': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::FullBucketsIndices'], '<raw::FullBucketsIndices as core::iter::Iterator>::size_hint': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::FullBucketsIndices'], '<raw::ProbeSeq as core::clone::Clone>::clone': ['raw::ProbeSeq'], "<raw::RawDrain<'_, T, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], "<raw::RawDrain<'_, T, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], "<raw::RawDrain<'_, T, A> as core::ops::Drop>::drop": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], '<raw::RawIntoIter<T, A> as core::default::Default>::default': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<raw::RawIntoIter<T, A> as core::iter::Iterator>::next': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<raw::RawIntoIter<T, A> as core::iter::Iterator>::size_hint': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<raw::RawIntoIter<T, A> as core::ops::Drop>::drop': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], '<raw::RawIter<T> as core::clone::Clone>::clone': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], '<raw::RawIter<T> as core::default::Default>::default': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], '<raw::RawIter<T> as core::iter::Iterator>::fold': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], '<raw::RawIter<T> as core::iter::Iterator>::next': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], '<raw::RawIter<T> as core::iter::Iterator>::size_hint': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], '<raw::RawIterHash<T> as core::clone::Clone>::clone': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner'], '<raw::RawIterHash<T> as core::default::Default>::default': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner'], '<raw::RawIterHash<T> as core::iter::Iterator>::next': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner'], '<raw::RawIterHashInner as core::clone::Clone>::clone': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHashInner'], '<raw::RawIterHashInner as core::iter::Iterator>::next': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHashInner'], '<raw::RawIterRange<T> as core::clone::Clone>::clone': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIterRange'], '<raw::RawIterRange<T> as core::iter::Iterator>::next': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIterRange'], '<raw::RawIterRange<T> as core::iter::Iterator>::size_hint': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIterRange'], '<raw::RawTable<T, A> as core::clone::Clone>::clone': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], '<raw::RawTable<T, A> as core::clone::Clone>::clone_from': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], '<raw::RawTable<T, A> as core::default::Default>::default': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], '<raw::RawTable<T, A> as core::iter::IntoIterator>::into_iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], '<raw::RawTable<T, A> as core::ops::Drop>::drop': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], '<raw::RawTable<T, A> as raw::RawTableClone>::clone_from_spec': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], '<raw::TableLayout as core::clone::Clone>::clone': ['raw::TableLayout'], "<raw_entry::RawEntryBuilder<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilder'], "<raw_entry::RawEntryBuilderMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilderMut'], "<raw_entry::RawEntryMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], "<raw_entry::RawOccupiedEntryMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "<raw_entry::RawVacantEntryMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawVacantEntryMut'], '<scopeguard::ScopeGuard<T, F> as core::ops::Deref>::deref': ['core::marker::Sized', 'core::ops::FnMut', 'scopeguard::ScopeGuard'], '<scopeguard::ScopeGuard<T, F> as core::ops::DerefMut>::deref_mut': ['core::marker::Sized', 'core::ops::FnMut', 'scopeguard::ScopeGuard'], '<scopeguard::ScopeGuard<T, F> as core::ops::Drop>::drop': ['core::marker::Sized', 'core::ops::FnMut', 'scopeguard::ScopeGuard'], "<set::Difference<'_, T, S, A> as core::clone::Clone>::clone": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::Difference', 'set::HashSet', 'set::Iter'], "<set::Difference<'_, T, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::Difference', 'set::HashSet', 'set::Iter'], "<set::Difference<'a, T, S, A> as core::iter::Iterator>::fold": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::Difference', 'set::HashSet', 'set::Iter'], "<set::Difference<'a, T, S, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::Difference', 'set::HashSet', 'set::Iter'], "<set::Difference<'a, T, S, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::Difference', 'set::HashSet', 'set::Iter'], "<set::Drain<'_, K, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'set::Drain'], "<set::Drain<'_, K, A> as core::iter::ExactSizeIterator>::len": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'set::Drain'], "<set::Drain<'_, K, A> as core::iter::Iterator>::fold": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'set::Drain'], "<set::Drain<'_, K, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'set::Drain'], "<set::Drain<'_, K, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'set::Drain'], "<set::Entry<'_, T, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::Entry', 'set::OccupiedEntry', 'set::VacantEntry'], "<set::ExtractIf<'_, K, F, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::ExtractIf'], "<set::ExtractIf<'_, K, F, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::ExtractIf'], '<set::HashSet<T, S, A> as core::clone::Clone>::clone': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::clone::Clone>::clone_from': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::cmp::PartialEq>::eq': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::convert::From<map::HashMap<T, (), S, A>>>::from': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::default::Default>::default': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::fmt::Debug>::fmt': ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], "<set::HashSet<T, S, A> as core::iter::Extend<&'a T>>::extend": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'core::iter::IntoIterator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::iter::Extend<T>>::extend': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'core::iter::IntoIterator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::iter::FromIterator<T>>::from_iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'core::iter::IntoIterator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::iter::IntoIterator>::into_iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::IntoIter'], '<set::HashSet<T, S, A> as core::ops::BitAndAssign<&set::HashSet<T, S, A>>>::bitand_assign': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::ops::BitOrAssign<&set::HashSet<T, S, A>>>::bitor_assign': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::ops::BitXorAssign<&set::HashSet<T, S, A>>>::bitxor_assign': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, S, A> as core::ops::SubAssign<&set::HashSet<T, S, A>>>::sub_assign': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], '<set::HashSet<T, foldhash::fast::RandomState, A> as core::convert::From<[T; N]>>::from': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], "<set::Intersection<'_, T, S, A> as core::clone::Clone>::clone": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Intersection', 'set::Iter'], "<set::Intersection<'_, T, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Intersection', 'set::Iter'], "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::fold": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Intersection', 'set::Iter'], "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Intersection', 'set::Iter'], "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Intersection', 'set::Iter'], '<set::IntoIter<K, A> as core::default::Default>::default': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'set::IntoIter'], '<set::IntoIter<K, A> as core::fmt::Debug>::fmt': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'core::result::Result', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'set::IntoIter'], '<set::IntoIter<K, A> as core::iter::ExactSizeIterator>::len': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'set::IntoIter'], '<set::IntoIter<K, A> as core::iter::Iterator>::fold': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'set::IntoIter'], '<set::IntoIter<K, A> as core::iter::Iterator>::next': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'set::IntoIter'], '<set::IntoIter<K, A> as core::iter::Iterator>::size_hint': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'set::IntoIter'], "<set::Iter<'_, K> as core::clone::Clone>::clone": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'set::Iter'], "<set::Iter<'_, K> as core::default::Default>::default": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'set::Iter'], "<set::Iter<'_, K> as core::fmt::Debug>::fmt": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'set::Iter'], "<set::Iter<'_, K> as core::iter::ExactSizeIterator>::len": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'set::Iter'], "<set::Iter<'a, K> as core::iter::Iterator>::fold": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'set::Iter'], "<set::Iter<'a, K> as core::iter::Iterator>::next": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'set::Iter'], "<set::Iter<'a, K> as core::iter::Iterator>::size_hint": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'set::Iter'], "<set::OccupiedEntry<'_, T, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::OccupiedEntry'], "<set::SymmetricDifference<'_, T, S, A> as core::clone::Clone>::clone": ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'set::SymmetricDifference'], "<set::SymmetricDifference<'_, T, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::iter::Chain', 'core::marker::Sized', 'core::result::Result', 'set::SymmetricDifference'], "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::fold": ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'core::ops::FnMut', 'set::SymmetricDifference'], "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'core::option::Option', 'set::SymmetricDifference'], "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'core::option::Option', 'set::SymmetricDifference'], "<set::Union<'_, T, S, A> as core::clone::Clone>::clone": ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'set::Union'], "<set::Union<'_, T, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::iter::Chain', 'core::marker::Sized', 'core::result::Result', 'set::Union'], "<set::Union<'a, T, S, A> as core::iter::Iterator>::fold": ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'core::ops::FnMut', 'set::Union'], "<set::Union<'a, T, S, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'core::option::Option', 'set::Union'], "<set::Union<'a, T, S, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'core::option::Option', 'set::Union'], "<set::VacantEntry<'_, T, S, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'map::VacantEntry', 'raw::RawTable', 'raw::RawTableInner', 'set::VacantEntry'], "<table::AbsentEntry<'_, T, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::RawTable', 'raw::RawTableInner', 'table::AbsentEntry', 'table::HashTable'], "<table::Drain<'_, T, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'table::Drain'], "<table::Drain<'_, T, A> as core::iter::ExactSizeIterator>::len": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'table::Drain'], "<table::Drain<'_, T, A> as core::iter::Iterator>::fold": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'table::Drain'], "<table::Drain<'_, T, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'table::Drain'], "<table::Drain<'_, T, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'table::Drain'], "<table::Entry<'_, T, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::Entry', 'table::HashTable', 'table::OccupiedEntry', 'table::VacantEntry'], "<table::ExtractIf<'_, T, F, A> as core::iter::Iterator>::next": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'table::ExtractIf'], "<table::ExtractIf<'_, T, F, A> as core::iter::Iterator>::size_hint": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'table::ExtractIf'], '<table::HashTable<T, A> as core::clone::Clone>::clone': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], '<table::HashTable<T, A> as core::default::Default>::default': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], '<table::HashTable<T, A> as core::fmt::Debug>::fmt': ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], '<table::HashTable<T, A> as core::iter::IntoIterator>::into_iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::IntoIter'], '<table::IntoIter<T, A> as core::default::Default>::default': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'table::IntoIter'], '<table::IntoIter<T, A> as core::fmt::Debug>::fmt': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'core::result::Result', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'table::IntoIter'], '<table::IntoIter<T, A> as core::iter::ExactSizeIterator>::len': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'table::IntoIter'], '<table::IntoIter<T, A> as core::iter::Iterator>::fold': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'table::IntoIter'], '<table::IntoIter<T, A> as core::iter::Iterator>::next': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'table::IntoIter'], '<table::IntoIter<T, A> as core::iter::Iterator>::size_hint': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'table::IntoIter'], "<table::Iter<'_, T> as core::default::Default>::default": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::Iter'], "<table::Iter<'_, T> as core::fmt::Debug>::fmt": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::Iter'], "<table::Iter<'_, T> as core::iter::ExactSizeIterator>::len": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::Iter'], "<table::Iter<'a, T> as core::clone::Clone>::clone": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::Iter'], "<table::Iter<'a, T> as core::iter::Iterator>::fold": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::Iter'], "<table::Iter<'a, T> as core::iter::Iterator>::next": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::Iter'], "<table::Iter<'a, T> as core::iter::Iterator>::size_hint": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::Iter'], "<table::IterHash<'_, T> as core::default::Default>::default": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHash'], "<table::IterHash<'_, T> as core::fmt::Debug>::fmt": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHash'], "<table::IterHash<'a, T> as core::clone::Clone>::clone": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHash'], "<table::IterHash<'a, T> as core::iter::Iterator>::fold": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHash'], "<table::IterHash<'a, T> as core::iter::Iterator>::next": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHash'], "<table::IterHashMut<'_, T> as core::default::Default>::default": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHashMut'], "<table::IterHashMut<'_, T> as core::fmt::Debug>::fmt": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHashMut'], "<table::IterHashMut<'a, T> as core::iter::Iterator>::fold": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHashMut'], "<table::IterHashMut<'a, T> as core::iter::Iterator>::next": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHashMut'], "<table::IterMut<'_, T> as core::default::Default>::default": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::IterMut'], "<table::IterMut<'_, T> as core::fmt::Debug>::fmt": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::IterMut'], "<table::IterMut<'_, T> as core::iter::ExactSizeIterator>::len": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::IterMut'], "<table::IterMut<'a, T> as core::iter::Iterator>::fold": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::IterMut'], "<table::IterMut<'a, T> as core::iter::Iterator>::next": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::IterMut'], "<table::IterMut<'a, T> as core::iter::Iterator>::size_hint": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::IterMut'], "<table::OccupiedEntry<'_, T, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::OccupiedEntry'], "<table::VacantEntry<'_, T, A> as core::fmt::Debug>::fmt": ['allocator_api2::alloc::Allocator', 'core::fmt::Formatter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::VacantEntry'], 'TryReserveError': ['TryReserveError', 'core::alloc::Layout'], 'control::bitmask::BitMask': ['control::bitmask::BitMask'], 'control::bitmask::BitMask::any_bit_set': ['control::bitmask::BitMask'], 'control::bitmask::BitMask::invert': ['control::bitmask::BitMask'], 'control::bitmask::BitMask::leading_zeros': ['control::bitmask::BitMask'], 'control::bitmask::BitMask::lowest_set_bit': ['control::bitmask::BitMask', 'core::marker::Sized', 'core::option::Option'], 'control::bitmask::BitMask::nonzero_trailing_zeros': ['core::marker::Sized', 'core::num::NonZero', 'core::num::ZeroablePrimitive'], 'control::bitmask::BitMask::remove_lowest_bit': ['control::bitmask::BitMask'], 'control::bitmask::BitMask::trailing_zeros': ['control::bitmask::BitMask'], 'control::bitmask::BitMaskIter': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter'], 'control::group::sse2::Group': ['control::group::sse2::Group', 'core::arch::x86_64::__m128i'], 'control::group::sse2::Group::convert_special_to_empty_and_full_to_deleted': ['control::group::sse2::Group', 'core::arch::x86_64::__m128i'], 'control::group::sse2::Group::load': ['control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i'], 'control::group::sse2::Group::load_aligned': ['control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i'], 'control::group::sse2::Group::match_empty': ['control::bitmask::BitMask', 'control::group::sse2::Group', 'core::arch::x86_64::__m128i'], 'control::group::sse2::Group::match_empty_or_deleted': ['control::bitmask::BitMask', 'control::group::sse2::Group', 'core::arch::x86_64::__m128i'], 'control::group::sse2::Group::match_full': ['control::bitmask::BitMask', 'control::group::sse2::Group', 'core::arch::x86_64::__m128i'], 'control::group::sse2::Group::match_tag': ['control::bitmask::BitMask', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i'], 'control::group::sse2::Group::static_empty': ['control::tag::Tag'], 'control::group::sse2::Group::static_empty::AlignedTags': ['control::group::sse2::Group', 'control::group::sse2::Group::static_empty::AlignedTags', 'control::tag::Tag', 'core::arch::x86_64::__m128i'], 'control::group::sse2::Group::store_aligned': ['control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i'], 'control::tag::Tag': ['control::tag::Tag'], 'control::tag::Tag::full': ['control::tag::Tag'], 'control::tag::Tag::is_full': ['control::tag::Tag'], 'control::tag::Tag::is_special': ['control::tag::Tag'], 'control::tag::Tag::special_is_empty': ['control::tag::Tag'], 'control::tag::TagSliceExt::fill_empty': [], 'control::tag::TagSliceExt::fill_tag': ['control::tag::Tag'], 'map::Drain': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], "map::Drain::<'_, K, V, A>::iter": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Drain', 'map::Iter', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], 'map::Entry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::Entry::<'a, K, V, S, A>::and_modify": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::Entry::<'a, K, V, S, A>::and_replace_entry_with": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::Entry::<'a, K, V, S, A>::insert": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::Entry::<'a, K, V, S, A>::key": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::Entry::<'a, K, V, S, A>::or_default": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::Entry::<'a, K, V, S, A>::or_insert": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::Entry::<'a, K, V, S, A>::or_insert_with": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::Entry::<'a, K, V, S, A>::or_insert_with_key": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'map::EntryRef': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::EntryRef', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::and_modify": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'map::EntryRef', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::insert": ['allocator_api2::alloc::Allocator', 'core::convert::Into', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::EntryRef', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::key": ['allocator_api2::alloc::Allocator', 'core::borrow::Borrow', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::EntryRef', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_default": ['allocator_api2::alloc::Allocator', 'core::convert::Into', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::EntryRef', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert": ['allocator_api2::alloc::Allocator', 'core::convert::Into', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::EntryRef', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert_with": ['allocator_api2::alloc::Allocator', 'core::convert::Into', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'map::EntryRef', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert_with_key": ['allocator_api2::alloc::Allocator', 'core::borrow::Borrow', 'core::convert::Into', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'map::EntryRef', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'map::ExtractIf': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::ExtractIf', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::allocation_size': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::allocator': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::build_hashes_inner': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::capacity': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::clear': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::contains_key': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::drain': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Drain', 'map::HashMap', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::entry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::entry_ref': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::EntryRef', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::extract_if': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::ExtractIf', 'map::HashMap', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::find_or_find_insert_slot': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_inner': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_inner_mut': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_key_value': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_key_value_mut': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_many_key_value_mut': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_many_key_value_unchecked_mut': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_many_mut': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_many_mut_inner': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_many_unchecked_mut': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_many_unchecked_mut_inner': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::get_mut': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::hasher': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::insert': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::insert_unique_unchecked': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::into_keys': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'map::IntoIter', 'map::IntoKeys', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::into_values': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'map::IntoIter', 'map::IntoValues', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::is_empty': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::iter_mut': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::IterMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::keys': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::len': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::remove': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::remove_entry': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::reserve': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::retain': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::shrink_to': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::shrink_to_fit': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::try_insert': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::try_reserve': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::values': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::values_mut': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::IterMut', 'map::ValuesMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::with_capacity_and_hasher_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S, A>::with_hasher_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S>::with_capacity_and_hasher': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, S>::with_hasher': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, foldhash::fast::RandomState, A>::new_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V, foldhash::fast::RandomState, A>::with_capacity_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V>::new': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::HashMap::<K, V>::with_capacity': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::IntoIter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], 'map::IntoIter::<K, V, A>::iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::Iter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], 'map::IntoKeys': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoKeys', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], 'map::IntoValues': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'map::IntoValues', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], 'map::Iter': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::IterMut': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::IterMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], "map::IterMut::<'_, K, V>::iter": ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::IterMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::Keys': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::OccupiedEntry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::OccupiedEntry::<'a, K, V, S, A>::get": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::OccupiedEntry::<'a, K, V, S, A>::get_mut": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::OccupiedEntry::<'a, K, V, S, A>::insert": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::OccupiedEntry::<'a, K, V, S, A>::into_mut": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::OccupiedEntry::<'a, K, V, S, A>::key": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::OccupiedEntry::<'a, K, V, S, A>::remove": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::OccupiedEntry::<'a, K, V, S, A>::remove_entry": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::OccupiedEntry::<'a, K, V, S, A>::replace_entry_with": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'map::Entry', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'map::OccupiedError': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'map::OccupiedError', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'map::VacantEntry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::VacantEntry', 'raw::RawTable', 'raw::RawTableInner'], "map::VacantEntry::<'a, K, V, S, A>::insert": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::VacantEntry', 'raw::RawTable', 'raw::RawTableInner'], "map::VacantEntry::<'a, K, V, S, A>::insert_entry": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::VacantEntry::<'a, K, V, S, A>::into_key": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::VacantEntry', 'raw::RawTable', 'raw::RawTableInner'], "map::VacantEntry::<'a, K, V, S, A>::key": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::VacantEntry', 'raw::RawTable', 'raw::RawTableInner'], 'map::VacantEntryRef': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::VacantEntryRef', 'raw::RawTable', 'raw::RawTableInner'], "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::insert": ['allocator_api2::alloc::Allocator', 'core::convert::Into', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::VacantEntryRef', 'raw::RawTable', 'raw::RawTableInner'], "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::insert_entry": ['allocator_api2::alloc::Allocator', 'core::convert::Into', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntryRef', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::key": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::VacantEntryRef', 'raw::RawTable', 'raw::RawTableInner'], 'map::Values': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::ValuesMut': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::IterMut', 'map::ValuesMut', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::assert_covariance': [], 'map::assert_covariance::drain': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], 'map::assert_covariance::into_iter_key': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], 'map::assert_covariance::into_iter_val': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], 'map::assert_covariance::iter_key': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::assert_covariance::iter_val': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::assert_covariance::keys_key': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::assert_covariance::keys_val': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::assert_covariance::map_key': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::assert_covariance::map_val': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner'], 'map::assert_covariance::values_key': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::assert_covariance::values_val': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Values', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'map::equivalent': ['core::marker::Sized', 'equivalent::Equivalent'], 'map::equivalent_key': ['core::marker::Sized', 'equivalent::Equivalent'], 'map::make_hash': ['core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::Sized'], 'map::make_hasher': ['core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::Sized'], 'raw::Bucket': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Bucket::<T>::as_mut': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Bucket::<T>::as_non_null': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Bucket::<T>::as_ptr': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Bucket::<T>::as_ref': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Bucket::<T>::drop': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Bucket::<T>::from_base_index': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Bucket::<T>::next_n': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Bucket::<T>::read': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Bucket::<T>::to_base_index': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Bucket::<T>::write': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket'], 'raw::Fallibility': ['raw::Fallibility'], 'raw::Fallibility::alloc_err': ['TryReserveError', 'core::alloc::Layout', 'raw::Fallibility'], 'raw::Fallibility::capacity_overflow': ['TryReserveError', 'core::alloc::Layout', 'raw::Fallibility'], 'raw::FullBucketsIndices': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::ptr::NonNull', 'raw::FullBucketsIndices'], 'raw::FullBucketsIndices::next_impl': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::FullBucketsIndices'], 'raw::InsertSlot': ['raw::InsertSlot'], 'raw::ProbeSeq': ['raw::ProbeSeq'], 'raw::ProbeSeq::move_next': ['raw::ProbeSeq'], 'raw::RawDrain': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], "raw::RawDrain::<'_, T, A>::iter": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], 'raw::RawExtractIf': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], "raw::RawExtractIf::<'_, T, A>::next": ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawIntoIter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], 'raw::RawIntoIter::<T, A>::iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange'], 'raw::RawIter': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'raw::RawIter::<T>::drop_elements': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange'], 'raw::RawIterHash': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner'], 'raw::RawIterHash::<T>::new': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawIterHashInner': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHashInner'], 'raw::RawIterHashInner::new': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHashInner', 'raw::RawTableInner'], 'raw::RawIterRange': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIterRange'], 'raw::RawIterRange::<T>::fold_impl': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIterRange'], 'raw::RawIterRange::<T>::new': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIterRange'], 'raw::RawIterRange::<T>::next_impl': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIterRange'], 'raw::RawTable': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::allocation_size': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::allocator': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::bucket': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::bucket_index': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::buckets': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::capacity': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::clear': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::clear_no_drop': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::clone_from_impl': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::data_end': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::drain': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::drain_iter_from': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::erase': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::erase_no_drop': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::find': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::find_or_find_insert_slot': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ops::FnMut', 'core::ptr::NonNull', 'core::result::Result', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::get': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::get_many_mut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::get_many_mut_pointers': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::get_many_unchecked_mut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::get_mut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::insert': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::insert_entry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::insert_in_slot': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::into_allocation': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::into_iter_from': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::is_bucket_full': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::is_empty': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::iter_hash': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::len': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::new_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::new_uninitialized': ['core::marker::Sized', 'core::result::Result', 'raw::Fallibility'], 'raw::RawTable::<T, A>::remove': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::remove_entry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::replace_bucket_with': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::reserve': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::reserve_rehash': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'core::result::Result', 'raw::Fallibility', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::resize': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'core::result::Result', 'raw::Fallibility', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::shrink_to': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::try_reserve': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'core::result::Result', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T, A>::with_capacity_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T>::new': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTable::<T>::with_capacity': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner'], 'raw::RawTableClone::clone_from_spec': [], 'raw::RawTableInner': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::allocation_info': ['core::alloc::Layout', 'core::ptr::NonNull', 'raw::RawTableInner', 'raw::TableLayout'], 'raw::RawTableInner::allocation_size_or_zero': ['core::ptr::NonNull', 'raw::RawTableInner', 'raw::TableLayout'], 'raw::RawTableInner::bucket': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTableInner'], 'raw::RawTableInner::bucket_ptr': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::buckets': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::clear_no_drop': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::ctrl': ['control::tag::Tag', 'core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::ctrl_slice': ['control::tag::Tag', 'core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::data_end': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::drop_elements': ['core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::drop_inner_table': ['allocator_api2::alloc::Allocator', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTableInner', 'raw::TableLayout'], 'raw::RawTableInner::erase': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::fallible_with_capacity': ['allocator_api2::alloc::Allocator', 'core::marker::Sized', 'core::result::Result', 'raw::Fallibility', 'raw::TableLayout'], 'raw::RawTableInner::find_inner': ['core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::find_insert_slot': ['core::ptr::NonNull', 'raw::InsertSlot', 'raw::RawTableInner'], 'raw::RawTableInner::find_insert_slot_in_group': ['control::group::sse2::Group', 'core::arch::x86_64::__m128i', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawTableInner'], 'raw::RawTableInner::find_or_find_insert_slot_inner': ['core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::RawTableInner'], 'raw::RawTableInner::fix_insert_slot': ['core::ptr::NonNull', 'raw::InsertSlot', 'raw::RawTableInner'], 'raw::RawTableInner::free_buckets': ['allocator_api2::alloc::Allocator', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTableInner', 'raw::TableLayout'], 'raw::RawTableInner::full_buckets_indices': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::ptr::NonNull', 'raw::FullBucketsIndices', 'raw::RawTableInner'], 'raw::RawTableInner::is_bucket_full': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::is_empty_singleton': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::is_in_same_group': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::iter': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner'], 'raw::RawTableInner::new': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::new_uninitialized': ['allocator_api2::alloc::Allocator', 'core::marker::Sized', 'core::result::Result', 'raw::Fallibility', 'raw::TableLayout'], 'raw::RawTableInner::num_ctrl_bytes': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::prepare_insert_slot': ['control::tag::Tag', 'core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::prepare_rehash_in_place': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::prepare_resize': ['allocator_api2::alloc::Allocator', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::Fallibility', 'raw::RawTableInner', 'raw::TableLayout'], 'raw::RawTableInner::probe_seq': ['core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawTableInner'], 'raw::RawTableInner::record_item_insert_at': ['control::tag::Tag', 'core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::rehash_in_place': ['core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::replace_ctrl_hash': ['control::tag::Tag', 'core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::reserve_rehash_inner': ['allocator_api2::alloc::Allocator', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'core::result::Result', 'raw::Fallibility', 'raw::RawTableInner', 'raw::TableLayout'], 'raw::RawTableInner::resize_inner': ['allocator_api2::alloc::Allocator', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'raw::Fallibility', 'raw::RawTableInner', 'raw::TableLayout'], 'raw::RawTableInner::set_ctrl': ['control::tag::Tag', 'core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::set_ctrl_hash': ['core::ptr::NonNull', 'raw::RawTableInner'], 'raw::RawTableInner::with_capacity': ['allocator_api2::alloc::Allocator', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTableInner', 'raw::TableLayout'], 'raw::TableLayout': ['raw::TableLayout'], 'raw::TableLayout::calculate_layout_for': ['core::marker::Sized', 'core::option::Option', 'raw::TableLayout'], 'raw::TableLayout::new': ['core::marker::Sized', 'raw::TableLayout'], 'raw::alloc::inner::do_alloc': ['allocator_api2::alloc::Allocator', 'core::alloc::Layout', 'core::marker::Sized', 'core::result::Result'], 'raw::bucket_mask_to_capacity': [], 'raw::capacity_to_buckets': ['core::marker::Sized', 'core::option::Option', 'raw::TableLayout'], 'raw::h1': [], 'raw::offset_from': ['core::marker::Sized'], 'raw_entry::<impl map::HashMap<K, V, S, A>>::raw_entry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilder'], 'raw_entry::<impl map::HashMap<K, V, S, A>>::raw_entry_mut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilderMut'], 'raw_entry::RawEntryBuilder': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilder'], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_hash": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilder'], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_key": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilder'], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_key_hashed_nocheck": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilder'], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::search": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilder'], 'raw_entry::RawEntryBuilderMut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilderMut'], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_hash": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::HashMap', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilderMut', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_key": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilderMut', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_key_hashed_nocheck": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilderMut', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::search": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::HashMap', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryBuilderMut', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], 'raw_entry::RawEntryMut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawEntryMut::<'a, K, V, S, A>::and_modify": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawEntryMut::<'a, K, V, S, A>::and_replace_entry_with": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawEntryMut::<'a, K, V, S, A>::insert": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawEntryMut::<'a, K, V, S, A>::or_insert": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawEntryMut::<'a, K, V, S, A>::or_insert_with": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], 'raw_entry::RawOccupiedEntryMut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_key_value": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_key_value_mut": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_mut": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::insert": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::insert_key": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_key": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_key_value": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_mut": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::key": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::key_mut": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::remove": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::remove_entry": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::replace_entry_with": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], 'raw_entry::RawVacantEntryMut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_entry": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_hashed_nocheck": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawVacantEntryMut'], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_with_hasher": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'raw_entry::RawVacantEntryMut'], 'scopeguard::ScopeGuard': ['core::marker::Sized', 'core::ops::FnMut', 'scopeguard::ScopeGuard'], 'scopeguard::ScopeGuard::<T, F>::into_inner': ['core::marker::Sized', 'core::ops::FnMut', 'scopeguard::ScopeGuard'], 'scopeguard::guard': ['core::marker::Sized', 'core::ops::FnMut', 'scopeguard::ScopeGuard'], 'set::Difference': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::Difference', 'set::HashSet', 'set::Iter'], 'set::Drain': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'set::Drain'], 'set::Entry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::Entry', 'set::OccupiedEntry', 'set::VacantEntry'], "set::Entry::<'a, T, S, A>::get": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::Entry', 'set::OccupiedEntry', 'set::VacantEntry'], "set::Entry::<'a, T, S, A>::insert": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::Entry', 'set::OccupiedEntry', 'set::VacantEntry'], "set::Entry::<'a, T, S, A>::or_insert": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::Entry', 'set::OccupiedEntry', 'set::VacantEntry'], 'set::ExtractIf': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::ExtractIf'], 'set::HashSet': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::allocation_size': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::allocator': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::capacity': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::clear': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::contains': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::difference': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::Difference', 'set::HashSet', 'set::Iter'], 'set::HashSet::<T, S, A>::drain': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Drain', 'map::HashMap', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::Drain', 'set::HashSet'], 'set::HashSet::<T, S, A>::entry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::Entry', 'set::HashSet', 'set::OccupiedEntry', 'set::VacantEntry'], 'set::HashSet::<T, S, A>::extract_if': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::HashMap', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::ExtractIf', 'set::HashSet'], 'set::HashSet::<T, S, A>::get': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::get_or_insert': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::get_or_insert_with': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::hasher': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::insert': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::insert_unique_unchecked': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::intersection': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Intersection', 'set::Iter'], 'set::HashSet::<T, S, A>::is_disjoint': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::is_empty': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::is_subset': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::is_superset': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Iter'], 'set::HashSet::<T, S, A>::len': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::remove': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::replace': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::reserve': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::retain': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::shrink_to': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::shrink_to_fit': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::symmetric_difference': ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::SymmetricDifference'], 'set::HashSet::<T, S, A>::take': ['allocator_api2::alloc::Allocator', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'equivalent::Equivalent', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::try_reserve': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'core::result::Result', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::union': ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Union'], 'set::HashSet::<T, S, A>::with_capacity_and_hasher_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S, A>::with_hasher_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S>::with_capacity_and_hasher': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, S>::with_hasher': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, foldhash::fast::RandomState, A>::new_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T, foldhash::fast::RandomState, A>::with_capacity_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T>::new': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::HashSet::<T>::with_capacity': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::Intersection': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Intersection', 'set::Iter'], 'set::IntoIter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'set::IntoIter'], 'set::Iter': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'set::Iter'], 'set::OccupiedEntry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::OccupiedEntry'], "set::OccupiedEntry::<'_, T, S, A>::get": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::OccupiedEntry'], "set::OccupiedEntry::<'_, T, S, A>::remove": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::OccupiedEntry'], 'set::SymmetricDifference': ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'set::SymmetricDifference'], 'set::Union': ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'set::Union'], 'set::VacantEntry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::VacantEntry', 'raw::RawTable', 'raw::RawTableInner', 'set::VacantEntry'], "set::VacantEntry::<'a, T, S, A>::get": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::VacantEntry', 'raw::RawTable', 'raw::RawTableInner', 'set::VacantEntry'], "set::VacantEntry::<'a, T, S, A>::insert": ['allocator_api2::alloc::Allocator', 'core::hash::BuildHasher', 'core::hash::Hash', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::OccupiedEntry', 'map::VacantEntry', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'set::OccupiedEntry', 'set::VacantEntry'], "set::VacantEntry::<'a, T, S, A>::into_value": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::VacantEntry', 'raw::RawTable', 'raw::RawTableInner', 'set::VacantEntry'], 'set::assert_covariance': [], 'set::assert_covariance::difference': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::Difference', 'set::HashSet', 'set::Iter'], 'set::assert_covariance::drain': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Drain', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'set::Drain'], 'set::assert_covariance::intersection': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet', 'set::Intersection', 'set::Iter'], 'set::assert_covariance::into_iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'map::IntoIter', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'set::IntoIter'], 'set::assert_covariance::iter': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::Iter', 'map::Keys', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'set::Iter'], 'set::assert_covariance::set': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'map::HashMap', 'raw::RawTable', 'raw::RawTableInner', 'set::HashSet'], 'set::assert_covariance::symmetric_difference': ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'set::SymmetricDifference'], 'set::assert_covariance::union': ['allocator_api2::alloc::Allocator', 'core::iter::Chain', 'core::marker::Sized', 'set::Union'], 'table::AbsentEntry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::AbsentEntry', 'table::HashTable'], "table::AbsentEntry::<'a, T, A>::into_table": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::AbsentEntry', 'table::HashTable'], 'table::Drain': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTableInner', 'table::Drain'], 'table::Entry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::Entry', 'table::HashTable', 'table::OccupiedEntry', 'table::VacantEntry'], "table::Entry::<'a, T, A>::and_modify": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::Entry', 'table::HashTable', 'table::OccupiedEntry', 'table::VacantEntry'], "table::Entry::<'a, T, A>::insert": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::Entry', 'table::HashTable', 'table::OccupiedEntry', 'table::VacantEntry'], "table::Entry::<'a, T, A>::or_insert": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::Entry', 'table::HashTable', 'table::OccupiedEntry', 'table::VacantEntry'], "table::Entry::<'a, T, A>::or_insert_with": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnOnce', 'core::ptr::NonNull', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::Entry', 'table::HashTable', 'table::OccupiedEntry', 'table::VacantEntry'], 'table::ExtractIf': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'table::ExtractIf'], 'table::HashTable': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::allocation_size': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::allocator': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::capacity': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::clear': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::drain': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'table::Drain', 'table::HashTable'], 'table::HashTable::<T, A>::entry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ops::FnMut', 'core::ptr::NonNull', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::Entry', 'table::HashTable', 'table::OccupiedEntry', 'table::VacantEntry'], 'table::HashTable::<T, A>::extract_if': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawExtractIf', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'table::ExtractIf', 'table::HashTable'], 'table::HashTable::<T, A>::find': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::find_entry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'core::result::Result', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::find_mut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::get_many_mut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::get_many_unchecked_mut': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::option::Option', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::insert_unique': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::OccupiedEntry'], 'table::HashTable::<T, A>::is_empty': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::iter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::Iter'], 'table::HashTable::<T, A>::iter_hash': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::IterHash'], 'table::HashTable::<T, A>::iter_hash_mut': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::IterHashMut'], 'table::HashTable::<T, A>::iter_mut': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::IterMut'], 'table::HashTable::<T, A>::len': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::new_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::reserve': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::retain': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::FnMut', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::shrink_to': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::shrink_to_fit': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::try_reserve': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ops::Fn', 'core::ptr::NonNull', 'core::result::Result', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T, A>::with_capacity_in': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T>::new': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::HashTable::<T>::with_capacity': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable'], 'table::IntoIter': ['allocator_api2::alloc::Allocator', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::option::Option', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'table::IntoIter'], 'table::Iter': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::Iter'], 'table::IterHash': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHash'], 'table::IterHashMut': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'core::arch::x86_64::__m128i', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::ProbeSeq', 'raw::RawIterHash', 'raw::RawIterHashInner', 'table::IterHashMut'], 'table::IterMut': ['control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawIter', 'raw::RawIterRange', 'table::IterMut'], 'table::OccupiedEntry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::OccupiedEntry'], "table::OccupiedEntry::<'a, T, A>::get": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::OccupiedEntry'], "table::OccupiedEntry::<'a, T, A>::get_mut": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::OccupiedEntry'], "table::OccupiedEntry::<'a, T, A>::into_mut": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::OccupiedEntry'], "table::OccupiedEntry::<'a, T, A>::into_table": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::OccupiedEntry'], "table::OccupiedEntry::<'a, T, A>::remove": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::OccupiedEntry', 'table::VacantEntry'], 'table::VacantEntry': ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::VacantEntry'], "table::VacantEntry::<'a, T, A>::insert": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::Bucket', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::OccupiedEntry', 'table::VacantEntry'], "table::VacantEntry::<'a, T, A>::into_table": ['allocator_api2::alloc::Allocator', 'core::marker::PhantomData', 'core::marker::Sized', 'core::ptr::NonNull', 'raw::InsertSlot', 'raw::RawTable', 'raw::RawTableInner', 'table::HashTable', 'table::VacantEntry'], 'util::invalid_mut': ['core::marker::Sized']}, 'glob_path_import': {'map': 'hash_map::', 'raw_entry': 'map::', 'set': 'hash_set::', 'table': 'hash_table::'}, 'self_to_fn': {'<T as raw::SizedTypeProperties>::T': ['impl<T> SizedTypeProperties for T {}'], 'TryReserveError': ['Clone', 'Debug', 'Eq', 'PartialEq'], 'control::bitmask::BitMask': ['Clone', 'Copy', 'impl BitMask {\n    /// Returns a new `BitMask` with all bits inverted.\n    #[inline]\n    #[must_use]\n    #[allow(dead_code)]\n    pub(crate) fn invert(self) -> Self {\n        BitMask(self.0 ^ BITMASK_MASK)\n    }\n\n    /// Returns a new `BitMask` with the lowest bit removed.\n    #[inline]\n    #[must_use]\n    fn remove_lowest_bit(self) -> Self {\n        BitMask(self.0 & (self.0 - 1))\n    }\n\n    /// Returns whether the `BitMask` has at least one set bit.\n    #[inline]\n    pub(crate) fn any_bit_set(self) -> bool {\n        self.0 != 0\n    }\n\n    /// Returns the first set bit in the `BitMask`, if there is one.\n    #[inline]\n    pub(crate) fn lowest_set_bit(self) -> Option<usize> {\n        if let Some(nonzero) = NonZeroBitMaskWord::new(self.0) {\n            Some(Self::nonzero_trailing_zeros(nonzero))\n        } else {\n            None\n        }\n    }\n\n    /// Returns the number of trailing zeroes in the `BitMask`.\n    #[inline]\n    pub(crate) fn trailing_zeros(self) -> usize {\n        // ARM doesn\'t have a trailing_zeroes instruction, and instead uses\n        // reverse_bits (RBIT) + leading_zeroes (CLZ). However older ARM\n        // versions (pre-ARMv7) don\'t have RBIT and need to emulate it\n        // instead. Since we only have 1 bit set in each byte on ARM, we can\n        // use swap_bytes (REV) + leading_zeroes instead.\n        if cfg!(target_arch = "arm") && BITMASK_STRIDE % 8 == 0 {\n            self.0.swap_bytes().leading_zeros() as usize / BITMASK_STRIDE\n        } else {\n            self.0.trailing_zeros() as usize / BITMASK_STRIDE\n        }\n    }\n\n    /// Same as above but takes a `NonZeroBitMaskWord`.\n    #[inline]\n    fn nonzero_trailing_zeros(nonzero: NonZeroBitMaskWord) -> usize {\n        if cfg!(target_arch = "arm") && BITMASK_STRIDE % 8 == 0 {\n            // SAFETY: A byte-swapped non-zero value is still non-zero.\n            let swapped = unsafe { NonZeroBitMaskWord::new_unchecked(nonzero.get().swap_bytes()) };\n            swapped.leading_zeros() as usize / BITMASK_STRIDE\n        } else {\n            nonzero.trailing_zeros() as usize / BITMASK_STRIDE\n        }\n    }\n\n    /// Returns the number of leading zeroes in the `BitMask`.\n    #[inline]\n    pub(crate) fn leading_zeros(self) -> usize {\n        self.0.leading_zeros() as usize / BITMASK_STRIDE\n    }\n}', 'impl IntoIterator for BitMask {\n    type Item = usize;\n    type IntoIter = BitMaskIter;\n\n    #[inline]\n    fn into_iter(self) -> BitMaskIter {\n        // A BitMask only requires each element (group of bits) to be non-zero.\n        // However for iteration we need each element to only contain 1 bit.\n        BitMaskIter(BitMask(self.0 & BITMASK_ITER_MASK))\n    }\n}'], 'control::bitmask::BitMaskIter': ['Clone', 'impl Iterator for BitMaskIter {\n    type Item = usize;\n\n    #[inline]\n    fn next(&mut self) -> Option<usize> {\n        let bit = self.0.lowest_set_bit()?;\n        self.0 = self.0.remove_lowest_bit();\n        Some(bit)\n    }\n}'], 'control::group::sse2::Group': ['Clone', 'Copy', "impl Group {\n    /// Number of bytes in the group.\n    pub(crate) const WIDTH: usize = mem::size_of::<Self>();\n\n    /// Returns a full group of empty tags, suitable for use as the initial\n    /// value for an empty hash table.\n    ///\n    /// This is guaranteed to be aligned to the group size.\n    #[inline]\n    #[allow(clippy::items_after_statements)]\n    pub(crate) const fn static_empty() -> &'static [Tag; Group::WIDTH] {\n        #[repr(C)]\n        struct AlignedTags {\n            _align: [Group; 0],\n            tags: [Tag; Group::WIDTH],\n        }\n        const ALIGNED_TAGS: AlignedTags = AlignedTags {\n            _align: [],\n            tags: [Tag::EMPTY; Group::WIDTH],\n        };\n        &ALIGNED_TAGS.tags\n    }\n\n    /// Loads a group of tags starting at the given address.\n    #[inline]\n    #[allow(clippy::cast_ptr_alignment)] // unaligned load\n    pub(crate) unsafe fn load(ptr: *const Tag) -> Self {\n        Group(x86::_mm_loadu_si128(ptr.cast()))\n    }\n\n    /// Loads a group of tags starting at the given address, which must be\n    /// aligned to `mem::align_of::<Group>()`.\n    #[inline]\n    #[allow(clippy::cast_ptr_alignment)]\n    pub(crate) unsafe fn load_aligned(ptr: *const Tag) -> Self {\n        debug_assert_eq!(ptr.align_offset(mem::align_of::<Self>()), 0);\n        Group(x86::_mm_load_si128(ptr.cast()))\n    }\n\n    /// Stores the group of tags to the given address, which must be\n    /// aligned to `mem::align_of::<Group>()`.\n    #[inline]\n    #[allow(clippy::cast_ptr_alignment)]\n    pub(crate) unsafe fn store_aligned(self, ptr: *mut Tag) {\n        debug_assert_eq!(ptr.align_offset(mem::align_of::<Self>()), 0);\n        x86::_mm_store_si128(ptr.cast(), self.0);\n    }\n\n    /// Returns a `BitMask` indicating all tags in the group which have\n    /// the given value.\n    #[inline]\n    pub(crate) fn match_tag(self, tag: Tag) -> BitMask {\n        #[allow(\n            clippy::cast_possible_wrap, // tag.0: Tag as i8\n            // tag: i32 as u16\n            //   note: _mm_movemask_epi8 returns a 16-bit mask in a i32, the\n            //   upper 16-bits of the i32 are zeroed:\n            clippy::cast_sign_loss,\n            clippy::cast_possible_truncation\n        )]\n        unsafe {\n            let cmp = x86::_mm_cmpeq_epi8(self.0, x86::_mm_set1_epi8(tag.0 as i8));\n            BitMask(x86::_mm_movemask_epi8(cmp) as u16)\n        }\n    }\n\n    /// Returns a `BitMask` indicating all tags in the group which are\n    /// `EMPTY`.\n    #[inline]\n    pub(crate) fn match_empty(self) -> BitMask {\n        self.match_tag(Tag::EMPTY)\n    }\n\n    /// Returns a `BitMask` indicating all tags in the group which are\n    /// `EMPTY` or `DELETED`.\n    #[inline]\n    pub(crate) fn match_empty_or_deleted(self) -> BitMask {\n        #[allow(\n            // tag: i32 as u16\n            //   note: _mm_movemask_epi8 returns a 16-bit mask in a i32, the\n            //   upper 16-bits of the i32 are zeroed:\n            clippy::cast_sign_loss,\n            clippy::cast_possible_truncation\n        )]\n        unsafe {\n            // A tag is EMPTY or DELETED iff the high bit is set\n            BitMask(x86::_mm_movemask_epi8(self.0) as u16)\n        }\n    }\n\n    /// Returns a `BitMask` indicating all tags in the group which are full.\n    #[inline]\n    pub(crate) fn match_full(&self) -> BitMask {\n        self.match_empty_or_deleted().invert()\n    }\n\n    /// Performs the following transformation on all tags in the group:\n    /// - `EMPTY => EMPTY`\n    /// - `DELETED => EMPTY`\n    /// - `FULL => DELETED`\n    #[inline]\n    pub(crate) fn convert_special_to_empty_and_full_to_deleted(self) -> Self {\n        // Map high_bit = 1 (EMPTY or DELETED) to 1111_1111\n        // and high_bit = 0 (FULL) to 1000_0000\n        //\n        // Here's this logic expanded to concrete values:\n        //   let special = 0 > tag = 1111_1111 (true) or 0000_0000 (false)\n        //   1111_1111 | 1000_0000 = 1111_1111\n        //   0000_0000 | 1000_0000 = 1000_0000\n        #[allow(\n            clippy::cast_possible_wrap, // tag: Tag::DELETED.0 as i8\n        )]\n        unsafe {\n            let zero = x86::_mm_setzero_si128();\n            let special = x86::_mm_cmpgt_epi8(zero, self.0);\n            Group(x86::_mm_or_si128(\n                special,\n                x86::_mm_set1_epi8(Tag::DELETED.0 as i8),\n            ))\n        }\n    }\n}"], 'control::tag::Tag': ['Clone', 'Copy', 'Eq', 'PartialEq', 'impl Tag {\n    /// Control tag value for an empty bucket.\n    pub(crate) const EMPTY: Tag = Tag(0b1111_1111);\n\n    /// Control tag value for a deleted bucket.\n    pub(crate) const DELETED: Tag = Tag(0b1000_0000);\n\n    /// Checks whether a control tag represents a full bucket (top bit is clear).\n    #[inline]\n    pub(crate) const fn is_full(self) -> bool {\n        self.0 & 0x80 == 0\n    }\n\n    /// Checks whether a control tag represents a special value (top bit is set).\n    #[inline]\n    pub(crate) const fn is_special(self) -> bool {\n        self.0 & 0x80 != 0\n    }\n\n    /// Checks whether a special control value is EMPTY (just check 1 bit).\n    #[inline]\n    pub(crate) const fn special_is_empty(self) -> bool {\n        debug_assert!(self.is_special());\n        self.0 & 0x01 != 0\n    }\n\n    /// Creates a control tag representing a full bucket with the given hash.\n    #[inline]\n    #[allow(clippy::cast_possible_truncation)]\n    pub(crate) const fn full(hash: u64) -> Tag {\n        // Constant for function that grabs the top 7 bits of the hash.\n        const MIN_HASH_LEN: usize = if mem::size_of::<usize>() < mem::size_of::<u64>() {\n            mem::size_of::<usize>()\n        } else {\n            mem::size_of::<u64>()\n        };\n\n        // Grab the top 7 bits of the hash. While the hash is normally a full 64-bit\n        // value, some hash functions (such as FxHash) produce a usize result\n        // instead, which means that the top 32 bits are 0 on 32-bit platforms.\n        // So we use MIN_HASH_LEN constant to handle this.\n        let top7 = hash >> (MIN_HASH_LEN * 8 - 7);\n        Tag((top7 & 0x7f) as u8) // truncation\n    }\n}', 'impl fmt::Debug for Tag {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        if self.is_special() {\n            if self.special_is_empty() {\n                f.pad("EMPTY")\n            } else {\n                f.pad("DELETED")\n            }\n        } else {\n            f.debug_tuple("full").field(&(self.0 & 0x7F)).finish()\n        }\n    }\n}'], 'map::Drain': ['impl<K, V, A: Allocator> Drain<\'_, K, V, A> {\n    /// Returns a iterator of references over the remaining items.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub(super) fn iter(&self) -> Iter<\'_, K, V> {\n        Iter {\n            inner: self.inner.iter(),\n            marker: PhantomData,\n        }\n    }\n}', 'impl<K, V, A: Allocator> ExactSizeIterator for Drain<\'_, K, V, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}', "impl<K, V, A: Allocator> FusedIterator for Drain<'_, K, V, A> {}", 'impl<K, V, A: Allocator> Iterator for Drain<\'_, K, V, A> {\n    type Item = (K, V);\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<(K, V)> {\n        self.inner.next()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, f)\n    }\n}', "impl<K, V, A> fmt::Debug for Drain<'_, K, V, A>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}"], 'map::Entry': ['impl<\'a, K, V, S, A: Allocator> Entry<\'a, K, V, S, A> {\n    /// Sets the value of the entry, and returns an `OccupiedEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// let entry = map.entry("horseyland").insert(37);\n    ///\n    /// assert_eq!(entry.key(), &"horseyland");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(self, value: V) -> OccupiedEntry<\'a, K, V, S, A>\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            Entry::Occupied(mut entry) => {\n                entry.insert(value);\n                entry\n            }\n            Entry::Vacant(entry) => entry.insert_entry(value),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// // nonexistent key\n    /// map.entry("poneyland").or_insert(3);\n    /// assert_eq!(map["poneyland"], 3);\n    ///\n    /// // existing key\n    /// *map.entry("poneyland").or_insert(10) *= 2;\n    /// assert_eq!(map["poneyland"], 6);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_insert(self, default: V) -> &\'a mut V\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// // nonexistent key\n    /// map.entry("poneyland").or_insert_with(|| 3);\n    /// assert_eq!(map["poneyland"], 3);\n    ///\n    /// // existing key\n    /// *map.entry("poneyland").or_insert_with(|| 10) *= 2;\n    /// assert_eq!(map["poneyland"], 6);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &\'a mut V\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting, if empty, the result of the default function.\n    /// This method allows for generating key-derived values for insertion by providing the default\n    /// function a reference to the key that was moved during the `.entry(key)` method call.\n    ///\n    /// The reference to the moved key is provided so that cloning or copying the key is\n    /// unnecessary, unlike with `.or_insert_with(|| ... )`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, usize> = HashMap::new();\n    ///\n    /// // nonexistent key\n    /// map.entry("poneyland").or_insert_with_key(|key| key.chars().count());\n    /// assert_eq!(map["poneyland"], 9);\n    ///\n    /// // existing key\n    /// *map.entry("poneyland").or_insert_with_key(|key| key.chars().count() * 10) *= 2;\n    /// assert_eq!(map["poneyland"], 18);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &\'a mut V\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => {\n                let value = default(entry.key());\n                entry.insert(value)\n            }\n        }\n    }\n\n    /// Returns a reference to this entry\'s key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry("poneyland").or_insert(3);\n    /// // existing key\n    /// assert_eq!(map.entry("poneyland").key(), &"poneyland");\n    /// // nonexistent key\n    /// assert_eq!(map.entry("horseland").key(), &"horseland");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn key(&self) -> &K {\n        match *self {\n            Entry::Occupied(ref entry) => entry.key(),\n            Entry::Vacant(ref entry) => entry.key(),\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.entry("poneyland")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map["poneyland"], 42);\n    ///\n    /// map.entry("poneyland")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map["poneyland"], 43);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n        match self {\n            Entry::Occupied(mut entry) => {\n                f(entry.get_mut());\n                Entry::Occupied(entry)\n            }\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }\n\n    /// Provides shared access to the key and owned access to the value of\n    /// an occupied entry and allows to replace or remove it based on the\n    /// value of the returned option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// let entry = map\n    ///     .entry("poneyland")\n    ///     .and_replace_entry_with(|_k, _v| panic!());\n    ///\n    /// match entry {\n    ///     Entry::Vacant(e) => {\n    ///         assert_eq!(e.key(), &"poneyland");\n    ///     }\n    ///     Entry::Occupied(_) => panic!(),\n    /// }\n    ///\n    /// map.insert("poneyland", 42);\n    ///\n    /// let entry = map\n    ///     .entry("poneyland")\n    ///     .and_replace_entry_with(|k, v| {\n    ///         assert_eq!(k, &"poneyland");\n    ///         assert_eq!(v, 42);\n    ///         Some(v + 1)\n    ///     });\n    ///\n    /// match entry {\n    ///     Entry::Occupied(e) => {\n    ///         assert_eq!(e.key(), &"poneyland");\n    ///         assert_eq!(e.get(), &43);\n    ///     }\n    ///     Entry::Vacant(_) => panic!(),\n    /// }\n    ///\n    /// assert_eq!(map["poneyland"], 43);\n    ///\n    /// let entry = map\n    ///     .entry("poneyland")\n    ///     .and_replace_entry_with(|_k, _v| None);\n    ///\n    /// match entry {\n    ///     Entry::Vacant(e) => assert_eq!(e.key(), &"poneyland"),\n    ///     Entry::Occupied(_) => panic!(),\n    /// }\n    ///\n    /// assert!(!map.contains_key("poneyland"));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn and_replace_entry_with<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&K, V) -> Option<V>,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.replace_entry_with(f),\n            Entry::Vacant(_) => self,\n        }\n    }\n}', 'impl<\'a, K, V: Default, S, A: Allocator> Entry<\'a, K, V, S, A> {\n    /// Ensures a value is in the entry by inserting the default value if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, Option<u32>> = HashMap::new();\n    ///\n    /// // nonexistent key\n    /// map.entry("poneyland").or_default();\n    /// assert_eq!(map["poneyland"], None);\n    ///\n    /// map.insert("horseland", Some(3));\n    ///\n    /// // existing key\n    /// assert_eq!(map.entry("horseland").or_default(), &mut Some(3));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_default(self) -> &\'a mut V\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(Default::default()),\n        }\n    }\n}', 'impl<K: Debug, V: Debug, S, A: Allocator> Debug for Entry<\'_, K, V, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match *self {\n            Entry::Vacant(ref v) => f.debug_tuple("Entry").field(v).finish(),\n            Entry::Occupied(ref o) => f.debug_tuple("Entry").field(o).finish(),\n        }\n    }\n}'], 'map::EntryRef': ['impl<\'a, \'b, K, Q: ?Sized, V, S, A: Allocator> EntryRef<\'a, \'b, K, Q, V, S, A> {\n    /// Sets the value of the entry, and returns an `OccupiedEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<String, u32> = HashMap::new();\n    /// let entry = map.entry_ref("horseyland").insert(37);\n    ///\n    /// assert_eq!(entry.key(), "horseyland");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(self, value: V) -> OccupiedEntry<\'a, K, V, S, A>\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,\n    {\n        match self {\n            EntryRef::Occupied(mut entry) => {\n                entry.insert(value);\n                entry\n            }\n            EntryRef::Vacant(entry) => entry.insert_entry(value),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<String, u32> = HashMap::new();\n    ///\n    /// // nonexistent key\n    /// map.entry_ref("poneyland").or_insert(3);\n    /// assert_eq!(map["poneyland"], 3);\n    ///\n    /// // existing key\n    /// *map.entry_ref("poneyland").or_insert(10) *= 2;\n    /// assert_eq!(map["poneyland"], 6);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_insert(self, default: V) -> &\'a mut V\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,\n    {\n        match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => entry.insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<String, u32> = HashMap::new();\n    ///\n    /// // nonexistent key\n    /// map.entry_ref("poneyland").or_insert_with(|| 3);\n    /// assert_eq!(map["poneyland"], 3);\n    ///\n    /// // existing key\n    /// *map.entry_ref("poneyland").or_insert_with(|| 10) *= 2;\n    /// assert_eq!(map["poneyland"], 6);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &\'a mut V\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,\n    {\n        match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => entry.insert(default()),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting, if empty, the result of the default function.\n    /// This method allows for generating key-derived values for insertion by providing the default\n    /// function an access to the borrower form of the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<String, usize> = HashMap::new();\n    ///\n    /// // nonexistent key\n    /// map.entry_ref("poneyland").or_insert_with_key(|key| key.chars().count());\n    /// assert_eq!(map["poneyland"], 9);\n    ///\n    /// // existing key\n    /// *map.entry_ref("poneyland").or_insert_with_key(|key| key.chars().count() * 10) *= 2;\n    /// assert_eq!(map["poneyland"], 18);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_insert_with_key<F: FnOnce(&Q) -> V>(self, default: F) -> &\'a mut V\n    where\n        K: Hash + Borrow<Q>,\n        &\'b Q: Into<K>,\n        S: BuildHasher,\n    {\n        match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => {\n                let value = default(entry.key);\n                entry.insert(value)\n            }\n        }\n    }\n\n    /// Returns a reference to this entry\'s key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<String, u32> = HashMap::new();\n    /// map.entry_ref("poneyland").or_insert(3);\n    /// // existing key\n    /// assert_eq!(map.entry_ref("poneyland").key(), "poneyland");\n    /// // nonexistent key\n    /// assert_eq!(map.entry_ref("horseland").key(), "horseland");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn key(&self) -> &Q\n    where\n        K: Borrow<Q>,\n    {\n        match *self {\n            EntryRef::Occupied(ref entry) => entry.key().borrow(),\n            EntryRef::Vacant(ref entry) => entry.key(),\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<String, u32> = HashMap::new();\n    ///\n    /// map.entry_ref("poneyland")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map["poneyland"], 42);\n    ///\n    /// map.entry_ref("poneyland")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map["poneyland"], 43);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n        match self {\n            EntryRef::Occupied(mut entry) => {\n                f(entry.get_mut());\n                EntryRef::Occupied(entry)\n            }\n            EntryRef::Vacant(entry) => EntryRef::Vacant(entry),\n        }\n    }\n}', 'impl<\'a, \'b, K, Q: ?Sized, V: Default, S, A: Allocator> EntryRef<\'a, \'b, K, Q, V, S, A> {\n    /// Ensures a value is in the entry by inserting the default value if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<String, Option<u32>> = HashMap::new();\n    ///\n    /// // nonexistent key\n    /// map.entry_ref("poneyland").or_default();\n    /// assert_eq!(map["poneyland"], None);\n    ///\n    /// map.insert("horseland".to_string(), Some(3));\n    ///\n    /// // existing key\n    /// assert_eq!(map.entry_ref("horseland").or_default(), &mut Some(3));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_default(self) -> &\'a mut V\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,\n    {\n        match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => entry.insert(Default::default()),\n        }\n    }\n}', 'impl<K, Q, V, S, A> Debug for EntryRef<\'_, \'_, K, Q, V, S, A>\nwhere\n    K: Debug + Borrow<Q>,\n    Q: Debug + ?Sized,\n    V: Debug,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match *self {\n            EntryRef::Vacant(ref v) => f.debug_tuple("EntryRef").field(v).finish(),\n            EntryRef::Occupied(ref o) => f.debug_tuple("EntryRef").field(o).finish(),\n        }\n    }\n}'], 'map::ExtractIf': ['impl<K, V, F, A> Iterator for ExtractIf<\'_, K, V, F, A>\nwhere\n    F: FnMut(&K, &mut V) -> bool,\n    A: Allocator,\n{\n    type Item = (K, V);\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next(|&mut (ref k, ref mut v)| (self.f)(k, v))\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.inner.iter.size_hint().1)\n    }\n}', "impl<K, V, F> FusedIterator for ExtractIf<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}"], 'map::HashMap': ['impl<\'a, K, V, S, A> Extend<&\'a (K, V)> for HashMap<K, V, S, A>\nwhere\n    K: Eq + Hash + Copy,\n    V: Copy,\n    S: BuildHasher,\n    A: Allocator,\n{\n    /// Inserts all new key-values from the iterator to existing `HashMap<K, V, S, A>`.\n    /// Replace values with existing keys with new values returned from the iterator.\n    /// The keys and values must implement [`Copy`] trait.\n    ///\n    /// [`Copy`]: https://doc.rust-lang.org/core/marker/trait.Copy.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, 100);\n    ///\n    /// let arr = [(1, 1), (2, 2)];\n    /// let some_iter = arr.iter();\n    /// map.extend(some_iter);\n    /// // Replace values with existing keys with new values returned from the iterator.\n    /// // So that the map.get(&1) doesn\'t return Some(&100).\n    /// assert_eq!(map.get(&1), Some(&1));\n    ///\n    /// let some_vec: Vec<_> = vec![(3, 3), (4, 4)];\n    /// map.extend(&some_vec);\n    ///\n    /// let some_arr = [(5, 5), (6, 6)];\n    /// map.extend(&some_arr);\n    ///\n    /// let mut vec: Vec<_> = map.into_iter().collect();\n    /// // The `IntoIter` iterator produces items in arbitrary order, so the\n    /// // items must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn extend<T: IntoIterator<Item = &\'a (K, V)>>(&mut self, iter: T) {\n        self.extend(iter.into_iter().map(|&(key, value)| (key, value)));\n    }\n\n    #[inline]\n    #[cfg(feature = "nightly")]\n    fn extend_one(&mut self, &(k, v): &\'a (K, V)) {\n        self.insert(k, v);\n    }\n\n    #[inline]\n    #[cfg(feature = "nightly")]\n    fn extend_reserve(&mut self, additional: usize) {\n        Extend::<(K, V)>::extend_reserve(self, additional);\n    }\n}', 'impl<\'a, K, V, S, A> Extend<(&\'a K, &\'a V)> for HashMap<K, V, S, A>\nwhere\n    K: Eq + Hash + Copy,\n    V: Copy,\n    S: BuildHasher,\n    A: Allocator,\n{\n    /// Inserts all new key-values from the iterator to existing `HashMap<K, V, S, A>`.\n    /// Replace values with existing keys with new values returned from the iterator.\n    /// The keys and values must implement [`Copy`] trait.\n    ///\n    /// [`Copy`]: https://doc.rust-lang.org/core/marker/trait.Copy.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, 100);\n    ///\n    /// let arr = [(1, 1), (2, 2)];\n    /// let some_iter = arr.iter().map(|(k, v)| (k, v));\n    /// map.extend(some_iter);\n    /// // Replace values with existing keys with new values returned from the iterator.\n    /// // So that the map.get(&1) doesn\'t return Some(&100).\n    /// assert_eq!(map.get(&1), Some(&1));\n    ///\n    /// let some_vec: Vec<_> = vec![(3, 3), (4, 4)];\n    /// map.extend(some_vec.iter().map(|(k, v)| (k, v)));\n    ///\n    /// let some_arr = [(5, 5), (6, 6)];\n    /// map.extend(some_arr.iter().map(|(k, v)| (k, v)));\n    ///\n    /// // You can also extend from another HashMap\n    /// let mut new_map = HashMap::new();\n    /// new_map.extend(&map);\n    /// assert_eq!(new_map, map);\n    ///\n    /// let mut vec: Vec<_> = new_map.into_iter().collect();\n    /// // The `IntoIter` iterator produces items in arbitrary order, so the\n    /// // items must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn extend<T: IntoIterator<Item = (&\'a K, &\'a V)>>(&mut self, iter: T) {\n        self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n    }\n\n    #[inline]\n    #[cfg(feature = "nightly")]\n    fn extend_one(&mut self, (k, v): (&\'a K, &\'a V)) {\n        self.insert(*k, *v);\n    }\n\n    #[inline]\n    #[cfg(feature = "nightly")]\n    fn extend_reserve(&mut self, additional: usize) {\n        Extend::<(K, V)>::extend_reserve(self, additional);\n    }\n}', 'impl<K, Q, V, S, A> Index<&Q> for HashMap<K, V, S, A>\nwhere\n    K: Eq + Hash,\n    Q: Hash + Equivalent<K> + ?Sized,\n    S: BuildHasher,\n    A: Allocator,\n{\n    type Output = V;\n\n    /// Returns a reference to the value corresponding to the supplied key.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the key is not present in the `HashMap`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let map: HashMap<_, _> = [("a", "One"), ("b", "Two")].into();\n    ///\n    /// assert_eq!(map[&"a"], "One");\n    /// assert_eq!(map[&"b"], "Two");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn index(&self, key: &Q) -> &V {\n        self.get(key).expect("no entry found for key")\n    }\n}', 'impl<K, V, A, const N: usize> From<[(K, V); N]> for HashMap<K, V, DefaultHashBuilder, A>\nwhere\n    K: Eq + Hash,\n    A: Default + Allocator,\n{\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let map1 = HashMap::from([(1, 2), (3, 4)]);\n    /// let map2: HashMap<_, _> = [(1, 2), (3, 4)].into();\n    /// assert_eq!(map1, map2);\n    /// ```\n    fn from(arr: [(K, V); N]) -> Self {\n        arr.into_iter().collect()\n    }\n}', 'impl<K, V, A: Allocator> HashMap<K, V, DefaultHashBuilder, A> {\n    /// Creates an empty `HashMap` using the given allocator.\n    ///\n    /// The hash map is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashMap`], for example with\n    /// [`with_hasher_in`](HashMap::with_hasher_in) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use bumpalo::Bump;\n    ///\n    /// let bump = Bump::new();\n    /// let mut map = HashMap::new_in(&bump);\n    ///\n    /// // The created HashMap holds none elements\n    /// assert_eq!(map.len(), 0);\n    ///\n    /// // The created HashMap also doesn\'t allocate memory\n    /// assert_eq!(map.capacity(), 0);\n    ///\n    /// // Now we insert element inside created HashMap\n    /// map.insert("One", 1);\n    /// // We can see that the HashMap holds 1 element\n    /// assert_eq!(map.len(), 1);\n    /// // And it also allocates some capacity\n    /// assert!(map.capacity() > 1);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn new_in(alloc: A) -> Self {\n        Self::with_hasher_in(DefaultHashBuilder::default(), alloc)\n    }\n\n    /// Creates an empty `HashMap` with the specified capacity using the given allocator.\n    ///\n    /// The hash map will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashMap`], for example with\n    /// [`with_capacity_and_hasher_in`](HashMap::with_capacity_and_hasher_in) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use bumpalo::Bump;\n    ///\n    /// let bump = Bump::new();\n    /// let mut map = HashMap::with_capacity_in(5, &bump);\n    ///\n    /// // The created HashMap holds none elements\n    /// assert_eq!(map.len(), 0);\n    /// // But it can hold at least 5 elements without reallocating\n    /// let empty_map_capacity = map.capacity();\n    /// assert!(empty_map_capacity >= 5);\n    ///\n    /// // Now we insert some 5 elements inside created HashMap\n    /// map.insert("One",   1);\n    /// map.insert("Two",   2);\n    /// map.insert("Three", 3);\n    /// map.insert("Four",  4);\n    /// map.insert("Five",  5);\n    ///\n    /// // We can see that the HashMap holds 5 elements\n    /// assert_eq!(map.len(), 5);\n    /// // But its capacity isn\'t changed\n    /// assert_eq!(map.capacity(), empty_map_capacity)\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n        Self::with_capacity_and_hasher_in(capacity, DefaultHashBuilder::default(), alloc)\n    }\n}', 'impl<K, V, S, A: Allocator> HashMap<K, V, S, A> {\n    /// Creates a raw entry builder for the `HashMap`.\n    ///\n    /// Raw entries provide the lowest level of control for searching and\n    /// manipulating a map. They must be manually initialized with a hash and\n    /// then manually searched. After this, insertions into a vacant entry\n    /// still require an owned key to be provided.\n    ///\n    /// Raw entries are useful for such exotic situations as:\n    ///\n    /// * Hash memoization\n    /// * Deferring the creation of an owned key until it is known to be required\n    /// * Using a search key that doesn\'t work with the Borrow trait\n    /// * Using custom comparison logic without newtype wrappers\n    ///\n    /// Because raw entries provide much more low-level control, it\'s much easier\n    /// to put the `HashMap` into an inconsistent state which, while memory-safe,\n    /// will cause the map to produce seemingly random results. Higher-level and\n    /// more foolproof APIs like `entry` should be preferred when possible.\n    ///\n    /// In particular, the hash used to initialized the raw entry must still be\n    /// consistent with the hash of the key that is ultimately stored in the entry.\n    /// This is because implementations of `HashMap` may need to recompute hashes\n    /// when resizing, at which point only the keys are available.\n    ///\n    /// Raw entries give mutable access to the keys. This must not be used\n    /// to modify how the key would compare or hash, as the map will not re-evaluate\n    /// where the key should go, meaning the keys may become "lost" if their\n    /// location does not reflect their state. For instance, if you change a key\n    /// so that the map now contains keys which compare equal, search may start\n    /// acting erratically, with two keys randomly masking each other. Implementations\n    /// are free to assume this doesn\'t happen (within the limits of memory-safety).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use core::hash::{BuildHasher, Hash};\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map = HashMap::new();\n    /// map.extend([("a", 100), ("b", 200), ("c", 300)]);\n    ///\n    /// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n    ///     use core::hash::Hasher;\n    ///     let mut state = hash_builder.build_hasher();\n    ///     key.hash(&mut state);\n    ///     state.finish()\n    /// }\n    ///\n    /// // Existing key (insert and update)\n    /// match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => unreachable!(),\n    ///     RawEntryMut::Occupied(mut view) => {\n    ///         assert_eq!(view.get(), &100);\n    ///         let v = view.get_mut();\n    ///         let new_v = (*v) * 10;\n    ///         *v = new_v;\n    ///         assert_eq!(view.insert(1111), 1000);\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(map[&"a"], 1111);\n    /// assert_eq!(map.len(), 3);\n    ///\n    /// // Existing key (take)\n    /// let hash = compute_hash(map.hasher(), &"c");\n    /// match map.raw_entry_mut().from_key_hashed_nocheck(hash, &"c") {\n    ///     RawEntryMut::Vacant(_) => unreachable!(),\n    ///     RawEntryMut::Occupied(view) => {\n    ///         assert_eq!(view.remove_entry(), ("c", 300));\n    ///     }\n    /// }\n    /// assert_eq!(map.raw_entry().from_key(&"c"), None);\n    /// assert_eq!(map.len(), 2);\n    ///\n    /// // Nonexistent key (insert and update)\n    /// let key = "d";\n    /// let hash = compute_hash(map.hasher(), &key);\n    /// match map.raw_entry_mut().from_hash(hash, |q| *q == key) {\n    ///     RawEntryMut::Occupied(_) => unreachable!(),\n    ///     RawEntryMut::Vacant(view) => {\n    ///         let (k, value) = view.insert("d", 4000);\n    ///         assert_eq!((*k, *value), ("d", 4000));\n    ///         *value = 40000;\n    ///     }\n    /// }\n    /// assert_eq!(map[&"d"], 40000);\n    /// assert_eq!(map.len(), 3);\n    ///\n    /// match map.raw_entry_mut().from_hash(hash, |q| *q == key) {\n    ///     RawEntryMut::Vacant(_) => unreachable!(),\n    ///     RawEntryMut::Occupied(view) => {\n    ///         assert_eq!(view.remove_entry(), ("d", 40000));\n    ///     }\n    /// }\n    /// assert_eq!(map.get(&"d"), None);\n    /// assert_eq!(map.len(), 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<\'_, K, V, S, A> {\n        RawEntryBuilderMut { map: self }\n    }\n\n    /// Creates a raw immutable entry builder for the `HashMap`.\n    ///\n    /// Raw entries provide the lowest level of control for searching and\n    /// manipulating a map. They must be manually initialized with a hash and\n    /// then manually searched.\n    ///\n    /// This is useful for\n    /// * Hash memoization\n    /// * Using a search key that doesn\'t work with the Borrow trait\n    /// * Using custom comparison logic without newtype wrappers\n    ///\n    /// Unless you are in such a situation, higher-level and more foolproof APIs like\n    /// `get` should be preferred.\n    ///\n    /// Immutable raw entries have very limited use; you might instead want `raw_entry_mut`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use core::hash::{BuildHasher, Hash};\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.extend([("a", 100), ("b", 200), ("c", 300)]);\n    ///\n    /// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n    ///     use core::hash::Hasher;\n    ///     let mut state = hash_builder.build_hasher();\n    ///     key.hash(&mut state);\n    ///     state.finish()\n    /// }\n    ///\n    /// for k in ["a", "b", "c", "d", "e", "f"] {\n    ///     let hash = compute_hash(map.hasher(), k);\n    ///     let v = map.get(&k).cloned();\n    ///     let kv = v.as_ref().map(|v| (&k, v));\n    ///\n    ///     println!("Key: {} and value: {:?}", k, v);\n    ///\n    ///     assert_eq!(map.raw_entry().from_key(&k), kv);\n    ///     assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n    ///     assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn raw_entry(&self) -> RawEntryBuilder<\'_, K, V, S, A> {\n        RawEntryBuilder { map: self }\n    }\n}', 'impl<K, V, S, A: Allocator> HashMap<K, V, S, A> {\n    /// Returns a reference to the underlying allocator.\n    #[inline]\n    pub fn allocator(&self) -> &A {\n        self.table.allocator()\n    }\n\n    /// Creates an empty `HashMap` which will use the given hash builder to hash\n    /// keys. It will be allocated with the given allocator.\n    ///\n    /// The hash map is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashMap`].\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n    /// let mut map = HashMap::with_hasher(s);\n    /// map.insert(1, 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[cfg_attr(feature = "rustc-dep-of-std", rustc_const_stable_indirect)]\n    pub const fn with_hasher_in(hash_builder: S, alloc: A) -> Self {\n        Self {\n            hash_builder,\n            table: RawTable::new_in(alloc),\n        }\n    }\n\n    /// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n    /// to hash the keys. It will be allocated with the given allocator.\n    ///\n    /// The hash map will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashMap`].\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n    /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n    /// map.insert(1, 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn with_capacity_and_hasher_in(capacity: usize, hash_builder: S, alloc: A) -> Self {\n        Self {\n            hash_builder,\n            table: RawTable::with_capacity_in(capacity, alloc),\n        }\n    }\n\n    /// Returns a reference to the map\'s [`BuildHasher`].\n    ///\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::DefaultHashBuilder;\n    ///\n    /// let hasher = DefaultHashBuilder::default();\n    /// let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n    /// let hasher: &DefaultHashBuilder = map.hasher();\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn hasher(&self) -> &S {\n        &self.hash_builder\n    }\n\n    /// Returns the number of elements the map can hold without reallocating.\n    ///\n    /// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n    /// more, but is guaranteed to be able to hold at least this many.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// assert_eq!(map.len(), 0);\n    /// assert!(map.capacity() >= 100);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn capacity(&self) -> usize {\n        self.table.capacity()\n    }\n\n    /// An iterator visiting all keys in arbitrary order.\n    /// The iterator element type is `&\'a K`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert("a", 1);\n    /// map.insert("b", 2);\n    /// map.insert("c", 3);\n    /// assert_eq!(map.len(), 3);\n    /// let mut vec: Vec<&str> = Vec::new();\n    ///\n    /// for key in map.keys() {\n    ///     println!("{}", key);\n    ///     vec.push(*key);\n    /// }\n    ///\n    /// // The `Keys` iterator produces keys in arbitrary order, so the\n    /// // keys must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, ["a", "b", "c"]);\n    ///\n    /// assert_eq!(map.len(), 3);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn keys(&self) -> Keys<\'_, K, V> {\n        Keys { inner: self.iter() }\n    }\n\n    /// An iterator visiting all values in arbitrary order.\n    /// The iterator element type is `&\'a V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert("a", 1);\n    /// map.insert("b", 2);\n    /// map.insert("c", 3);\n    /// assert_eq!(map.len(), 3);\n    /// let mut vec: Vec<i32> = Vec::new();\n    ///\n    /// for val in map.values() {\n    ///     println!("{}", val);\n    ///     vec.push(*val);\n    /// }\n    ///\n    /// // The `Values` iterator produces values in arbitrary order, so the\n    /// // values must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [1, 2, 3]);\n    ///\n    /// assert_eq!(map.len(), 3);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn values(&self) -> Values<\'_, K, V> {\n        Values { inner: self.iter() }\n    }\n\n    /// An iterator visiting all values mutably in arbitrary order.\n    /// The iterator element type is `&\'a mut V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    ///\n    /// map.insert("a", 1);\n    /// map.insert("b", 2);\n    /// map.insert("c", 3);\n    ///\n    /// for val in map.values_mut() {\n    ///     *val = *val + 10;\n    /// }\n    ///\n    /// assert_eq!(map.len(), 3);\n    /// let mut vec: Vec<i32> = Vec::new();\n    ///\n    /// for val in map.values() {\n    ///     println!("{}", val);\n    ///     vec.push(*val);\n    /// }\n    ///\n    /// // The `Values` iterator produces values in arbitrary order, so the\n    /// // values must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [11, 12, 13]);\n    ///\n    /// assert_eq!(map.len(), 3);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn values_mut(&mut self) -> ValuesMut<\'_, K, V> {\n        ValuesMut {\n            inner: self.iter_mut(),\n        }\n    }\n\n    /// An iterator visiting all key-value pairs in arbitrary order.\n    /// The iterator element type is `(&\'a K, &\'a V)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert("a", 1);\n    /// map.insert("b", 2);\n    /// map.insert("c", 3);\n    /// assert_eq!(map.len(), 3);\n    /// let mut vec: Vec<(&str, i32)> = Vec::new();\n    ///\n    /// for (key, val) in map.iter() {\n    ///     println!("key: {} val: {}", key, val);\n    ///     vec.push((*key, *val));\n    /// }\n    ///\n    /// // The `Iter` iterator produces items in arbitrary order, so the\n    /// // items must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [("a", 1), ("b", 2), ("c", 3)]);\n    ///\n    /// assert_eq!(map.len(), 3);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn iter(&self) -> Iter<\'_, K, V> {\n        // Here we tie the lifetime of self to the iter.\n        unsafe {\n            Iter {\n                inner: self.table.iter(),\n                marker: PhantomData,\n            }\n        }\n    }\n\n    /// An iterator visiting all key-value pairs in arbitrary order,\n    /// with mutable references to the values.\n    /// The iterator element type is `(&\'a K, &\'a mut V)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert("a", 1);\n    /// map.insert("b", 2);\n    /// map.insert("c", 3);\n    ///\n    /// // Update all values\n    /// for (_, val) in map.iter_mut() {\n    ///     *val *= 2;\n    /// }\n    ///\n    /// assert_eq!(map.len(), 3);\n    /// let mut vec: Vec<(&str, i32)> = Vec::new();\n    ///\n    /// for (key, val) in &map {\n    ///     println!("key: {} val: {}", key, val);\n    ///     vec.push((*key, *val));\n    /// }\n    ///\n    /// // The `Iter` iterator produces items in arbitrary order, so the\n    /// // items must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [("a", 2), ("b", 4), ("c", 6)]);\n    ///\n    /// assert_eq!(map.len(), 3);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn iter_mut(&mut self) -> IterMut<\'_, K, V> {\n        // Here we tie the lifetime of self to the iter.\n        unsafe {\n            IterMut {\n                inner: self.table.iter(),\n                marker: PhantomData,\n            }\n        }\n    }\n\n    #[cfg(test)]\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn raw_capacity(&self) -> usize {\n        self.table.buckets()\n    }\n\n    /// Returns the number of elements in the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// assert_eq!(a.len(), 0);\n    /// a.insert(1, "a");\n    /// assert_eq!(a.len(), 1);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn len(&self) -> usize {\n        self.table.len()\n    }\n\n    /// Returns `true` if the map contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// assert!(a.is_empty());\n    /// a.insert(1, "a");\n    /// assert!(!a.is_empty());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n    /// allocated memory for reuse.\n    ///\n    /// If the returned iterator is dropped before being fully consumed, it\n    /// drops the remaining key-value pairs. The returned iterator keeps a\n    /// mutable borrow on the vector to optimize its implementation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// a.insert(1, "a");\n    /// a.insert(2, "b");\n    /// let capacity_before_drain = a.capacity();\n    ///\n    /// for (k, v) in a.drain().take(1) {\n    ///     assert!(k == 1 || k == 2);\n    ///     assert!(v == "a" || v == "b");\n    /// }\n    ///\n    /// // As we can see, the map is empty and contains no element.\n    /// assert!(a.is_empty() && a.len() == 0);\n    /// // But map capacity is equal to old one.\n    /// assert_eq!(a.capacity(), capacity_before_drain);\n    ///\n    /// let mut a = HashMap::new();\n    /// a.insert(1, "a");\n    /// a.insert(2, "b");\n    ///\n    /// {   // Iterator is dropped without being consumed.\n    ///     let d = a.drain();\n    /// }\n    ///\n    /// // But the map is empty even if we do not use Drain iterator.\n    /// assert!(a.is_empty());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn drain(&mut self) -> Drain<\'_, K, V, A> {\n        Drain {\n            inner: self.table.drain(),\n        }\n    }\n\n    /// Retains only the elements specified by the predicate. Keeps the\n    /// allocated memory for reuse.\n    ///\n    /// In other words, remove all pairs `(k, v)` such that `f(&k, &mut v)` returns `false`.\n    /// The elements are visited in unsorted (and unspecified) order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = (0..8).map(|x|(x, x*10)).collect();\n    /// assert_eq!(map.len(), 8);\n    ///\n    /// map.retain(|&k, _| k % 2 == 0);\n    ///\n    /// // We can see, that the number of elements inside map is changed.\n    /// assert_eq!(map.len(), 4);\n    ///\n    /// let mut vec: Vec<(i32, i32)> = map.iter().map(|(&k, &v)| (k, v)).collect();\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [(0, 0), (2, 20), (4, 40), (6, 60)]);\n    /// ```\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        // Here we only use `iter` as a temporary, preventing use-after-free\n        unsafe {\n            for item in self.table.iter() {\n                let &mut (ref key, ref mut value) = item.as_mut();\n                if !f(key, value) {\n                    self.table.erase(item);\n                }\n            }\n        }\n    }\n\n    /// Drains elements which are true under the given predicate,\n    /// and returns an iterator over the removed items.\n    ///\n    /// In other words, move all pairs `(k, v)` such that `f(&k, &mut v)` returns `true` out\n    /// into another iterator.\n    ///\n    /// Note that `extract_if` lets you mutate every value in the filter closure, regardless of\n    /// whether you choose to keep or remove it.\n    ///\n    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n    /// or the iteration short-circuits, then the remaining elements will be retained.\n    /// Use [`retain()`] with a negated predicate if you do not need the returned iterator.\n    ///\n    /// Keeps the allocated memory for reuse.\n    ///\n    /// [`retain()`]: HashMap::retain\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n    ///\n    /// let drained: HashMap<i32, i32> = map.extract_if(|k, _v| k % 2 == 0).collect();\n    ///\n    /// let mut evens = drained.keys().cloned().collect::<Vec<_>>();\n    /// let mut odds = map.keys().cloned().collect::<Vec<_>>();\n    /// evens.sort();\n    /// odds.sort();\n    ///\n    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n    ///\n    /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n    ///\n    /// {   // Iterator is dropped without being consumed.\n    ///     let d = map.extract_if(|k, _v| k % 2 != 0);\n    /// }\n    ///\n    /// // ExtractIf was not exhausted, therefore no elements were drained.\n    /// assert_eq!(map.len(), 8);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn extract_if<F>(&mut self, f: F) -> ExtractIf<\'_, K, V, F, A>\n    where\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        ExtractIf {\n            f,\n            inner: RawExtractIf {\n                iter: unsafe { self.table.iter() },\n                table: &mut self.table,\n            },\n        }\n    }\n\n    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n    /// for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// a.insert(1, "a");\n    /// let capacity_before_clear = a.capacity();\n    ///\n    /// a.clear();\n    ///\n    /// // Map is empty.\n    /// assert!(a.is_empty());\n    /// // But map capacity is equal to old one.\n    /// assert_eq!(a.capacity(), capacity_before_clear);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn clear(&mut self) {\n        self.table.clear();\n    }\n\n    /// Creates a consuming iterator visiting all the keys in arbitrary order.\n    /// The map cannot be used after calling this.\n    /// The iterator element type is `K`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert("a", 1);\n    /// map.insert("b", 2);\n    /// map.insert("c", 3);\n    ///\n    /// let mut vec: Vec<&str> = map.into_keys().collect();\n    ///\n    /// // The `IntoKeys` iterator produces keys in arbitrary order, so the\n    /// // keys must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, ["a", "b", "c"]);\n    /// ```\n    #[inline]\n    pub fn into_keys(self) -> IntoKeys<K, V, A> {\n        IntoKeys {\n            inner: self.into_iter(),\n        }\n    }\n\n    /// Creates a consuming iterator visiting all the values in arbitrary order.\n    /// The map cannot be used after calling this.\n    /// The iterator element type is `V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert("a", 1);\n    /// map.insert("b", 2);\n    /// map.insert("c", 3);\n    ///\n    /// let mut vec: Vec<i32> = map.into_values().collect();\n    ///\n    /// // The `IntoValues` iterator produces values in arbitrary order, so\n    /// // the values must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// ```\n    #[inline]\n    pub fn into_values(self) -> IntoValues<K, V, A> {\n        IntoValues {\n            inner: self.into_iter(),\n        }\n    }\n}', 'impl<K, V, S, A: Allocator> IntoIterator for HashMap<K, V, S, A> {\n    type Item = (K, V);\n    type IntoIter = IntoIter<K, V, A>;\n\n    /// Creates a consuming iterator, that is, one that moves each key-value\n    /// pair out of the map in arbitrary order. The map cannot be used after\n    /// calling this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let map: HashMap<_, _> = [("a", 1), ("b", 2), ("c", 3)].into();\n    ///\n    /// // Not possible with .iter()\n    /// let mut vec: Vec<(&str, i32)> = map.into_iter().collect();\n    /// // The `IntoIter` iterator produces items in arbitrary order, so\n    /// // the items must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [("a", 1), ("b", 2), ("c", 3)]);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn into_iter(self) -> IntoIter<K, V, A> {\n        IntoIter {\n            inner: self.table.into_iter(),\n        }\n    }\n}', "impl<K, V, S, A> Debug for HashMap<K, V, S, A>\nwhere\n    K: Debug,\n    V: Debug,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_map().entries(self.iter()).finish()\n    }\n}", 'impl<K, V, S, A> Default for HashMap<K, V, S, A>\nwhere\n    S: Default,\n    A: Default + Allocator,\n{\n    /// Creates an empty `HashMap<K, V, S, A>`, with the `Default` value for the hasher and allocator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// // You can specify all types of HashMap, including hasher and allocator.\n    /// // Created map is empty and don\'t allocate memory\n    /// let map: HashMap<u32, String> = Default::default();\n    /// assert_eq!(map.capacity(), 0);\n    /// let map: HashMap<u32, String, RandomState> = HashMap::default();\n    /// assert_eq!(map.capacity(), 0);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self::with_hasher_in(Default::default(), Default::default())\n    }\n}', 'impl<K, V, S, A> Eq for HashMap<K, V, S, A>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    S: BuildHasher,\n    A: Allocator,\n{\n}', 'impl<K, V, S, A> Extend<(K, V)> for HashMap<K, V, S, A>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    /// Inserts all new key-values from the iterator to existing `HashMap<K, V, S, A>`.\n    /// Replace values with existing keys with new values returned from the iterator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, 100);\n    ///\n    /// let some_iter = [(1, 1), (2, 2)].into_iter();\n    /// map.extend(some_iter);\n    /// // Replace values with existing keys with new values returned from the iterator.\n    /// // So that the map.get(&1) doesn\'t return Some(&100).\n    /// assert_eq!(map.get(&1), Some(&1));\n    ///\n    /// let some_vec: Vec<_> = vec![(3, 3), (4, 4)];\n    /// map.extend(some_vec);\n    ///\n    /// let some_arr = [(5, 5), (6, 6)];\n    /// map.extend(some_arr);\n    /// let old_map_len = map.len();\n    ///\n    /// // You can also extend from another HashMap\n    /// let mut new_map = HashMap::new();\n    /// new_map.extend(map);\n    /// assert_eq!(new_map.len(), old_map_len);\n    ///\n    /// let mut vec: Vec<_> = new_map.into_iter().collect();\n    /// // The `IntoIter` iterator produces items in arbitrary order, so the\n    /// // items must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let iter = iter.into_iter();\n        let reserve = if self.is_empty() {\n            iter.size_hint().0\n        } else {\n            (iter.size_hint().0 + 1) / 2\n        };\n        self.reserve(reserve);\n        iter.for_each(move |(k, v)| {\n            self.insert(k, v);\n        });\n    }\n\n    #[inline]\n    #[cfg(feature = "nightly")]\n    fn extend_one(&mut self, (k, v): (K, V)) {\n        self.insert(k, v);\n    }\n\n    #[inline]\n    #[cfg(feature = "nightly")]\n    fn extend_reserve(&mut self, additional: usize) {\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let reserve = if self.is_empty() {\n            additional\n        } else {\n            (additional + 1) / 2\n        };\n        self.reserve(reserve);\n    }\n}', 'impl<K, V, S, A> FromIterator<(K, V)> for HashMap<K, V, S, A>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher + Default,\n    A: Default + Allocator,\n{\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> Self {\n        let iter = iter.into_iter();\n        let mut map =\n            Self::with_capacity_and_hasher_in(iter.size_hint().0, S::default(), A::default());\n        iter.for_each(|(k, v)| {\n            map.insert(k, v);\n        });\n        map\n    }\n}', 'impl<K, V, S, A> HashMap<K, V, S, A>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the `HashMap`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds [`isize::MAX`] bytes and [`abort`] the program\n    /// in case of allocation error. Use [`try_reserve`](HashMap::try_reserve) instead\n    /// if you want to handle memory allocation failure.\n    ///\n    /// [`isize::MAX`]: https://doc.rust-lang.org/std/primitive.isize.html\n    /// [`abort`]: https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::new();\n    /// // Map is empty and doesn\'t allocate memory\n    /// assert_eq!(map.capacity(), 0);\n    ///\n    /// map.reserve(10);\n    ///\n    /// // And now map can hold at least 10 elements\n    /// assert!(map.capacity() >= 10);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn reserve(&mut self, additional: usize) {\n        self.table\n            .reserve(additional, make_hasher::<_, V, S>(&self.hash_builder));\n    }\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `HashMap<K,V>`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, isize> = HashMap::new();\n    /// // Map is empty and doesn\'t allocate memory\n    /// assert_eq!(map.capacity(), 0);\n    ///\n    /// map.try_reserve(10).expect("why is the test harness OOMing on 10 bytes?");\n    ///\n    /// // And now map can hold at least 10 elements\n    /// assert!(map.capacity() >= 10);\n    /// ```\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned:\n    /// ```\n    /// # fn test() {\n    /// use hashbrown::HashMap;\n    /// use hashbrown::TryReserveError;\n    /// let mut map: HashMap<i32, i32> = HashMap::new();\n    ///\n    /// match map.try_reserve(usize::MAX) {\n    ///     Err(error) => match error {\n    ///         TryReserveError::CapacityOverflow => {}\n    ///         _ => panic!("TryReserveError::AllocError ?"),\n    ///     },\n    ///     _ => panic!(),\n    /// }\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(not(miri))]\n    /// #     test()\n    /// # }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.table\n            .try_reserve(additional, make_hasher::<_, V, S>(&self.hash_builder))\n    }\n\n    /// Shrinks the capacity of the map as much as possible. It will drop\n    /// down as much as possible while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// assert!(map.capacity() >= 100);\n    /// map.shrink_to_fit();\n    /// assert!(map.capacity() >= 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn shrink_to_fit(&mut self) {\n        self.table\n            .shrink_to(0, make_hasher::<_, V, S>(&self.hash_builder));\n    }\n\n    /// Shrinks the capacity of the map with a lower limit. It will drop\n    /// down no lower than the supplied limit while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// This function does nothing if the current capacity is smaller than the\n    /// supplied minimum capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// assert!(map.capacity() >= 100);\n    /// map.shrink_to(10);\n    /// assert!(map.capacity() >= 10);\n    /// map.shrink_to(0);\n    /// assert!(map.capacity() >= 2);\n    /// map.shrink_to(10);\n    /// assert!(map.capacity() >= 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.table\n            .shrink_to(min_capacity, make_hasher::<_, V, S>(&self.hash_builder));\n    }\n\n    /// Gets the given key\'s corresponding entry in the map for in-place manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut letters = HashMap::new();\n    ///\n    /// for ch in "a short treatise on fungi".chars() {\n    ///     let counter = letters.entry(ch).or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(letters[&\'s\'], 2);\n    /// assert_eq!(letters[&\'t\'], 3);\n    /// assert_eq!(letters[&\'u\'], 1);\n    /// assert_eq!(letters.get(&\'y\'), None);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn entry(&mut self, key: K) -> Entry<\'_, K, V, S, A> {\n        let hash = make_hash::<K, S>(&self.hash_builder, &key);\n        if let Some(elem) = self.table.find(hash, equivalent_key(&key)) {\n            Entry::Occupied(OccupiedEntry {\n                hash,\n                elem,\n                table: self,\n            })\n        } else {\n            Entry::Vacant(VacantEntry {\n                hash,\n                key,\n                table: self,\n            })\n        }\n    }\n\n    /// Gets the given key\'s corresponding entry by reference in the map for in-place manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut words: HashMap<String, usize> = HashMap::new();\n    /// let source = ["poneyland", "horseyland", "poneyland", "poneyland"];\n    /// for (i, &s) in source.iter().enumerate() {\n    ///     let counter = words.entry_ref(s).or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(words["poneyland"], 3);\n    /// assert_eq!(words["horseyland"], 1);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn entry_ref<\'a, \'b, Q>(&\'a mut self, key: &\'b Q) -> EntryRef<\'a, \'b, K, Q, V, S, A>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        let hash = make_hash::<Q, S>(&self.hash_builder, key);\n        if let Some(elem) = self.table.find(hash, equivalent_key(key)) {\n            EntryRef::Occupied(OccupiedEntry {\n                hash,\n                elem,\n                table: self,\n            })\n        } else {\n            EntryRef::Vacant(VacantEntryRef {\n                hash,\n                key,\n                table: self,\n            })\n        }\n    }\n\n    /// Returns a reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map\'s key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, "a");\n    /// assert_eq!(map.get(&1), Some(&"a"));\n    /// assert_eq!(map.get(&2), None);\n    /// ```\n    #[inline]\n    pub fn get<Q>(&self, k: &Q) -> Option<&V>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.get_inner(k) {\n            Some((_, v)) => Some(v),\n            None => None,\n        }\n    }\n\n    /// Returns the key-value pair corresponding to the supplied key.\n    ///\n    /// The supplied key may be any borrowed form of the map\'s key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, "a");\n    /// assert_eq!(map.get_key_value(&1), Some((&1, &"a")));\n    /// assert_eq!(map.get_key_value(&2), None);\n    /// ```\n    #[inline]\n    pub fn get_key_value<Q>(&self, k: &Q) -> Option<(&K, &V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.get_inner(k) {\n            Some((key, value)) => Some((key, value)),\n            None => None,\n        }\n    }\n\n    #[inline]\n    fn get_inner<Q>(&self, k: &Q) -> Option<&(K, V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        if self.table.is_empty() {\n            None\n        } else {\n            let hash = make_hash::<Q, S>(&self.hash_builder, k);\n            self.table.get(hash, equivalent_key(k))\n        }\n    }\n\n    /// Returns the key-value pair corresponding to the supplied key, with a mutable reference to value.\n    ///\n    /// The supplied key may be any borrowed form of the map\'s key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, "a");\n    /// let (k, v) = map.get_key_value_mut(&1).unwrap();\n    /// assert_eq!(k, &1);\n    /// assert_eq!(v, &mut "a");\n    /// *v = "b";\n    /// assert_eq!(map.get_key_value_mut(&1), Some((&1, &mut "b")));\n    /// assert_eq!(map.get_key_value_mut(&2), None);\n    /// ```\n    #[inline]\n    pub fn get_key_value_mut<Q>(&mut self, k: &Q) -> Option<(&K, &mut V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.get_inner_mut(k) {\n            Some(&mut (ref key, ref mut value)) => Some((key, value)),\n            None => None,\n        }\n    }\n\n    /// Returns `true` if the map contains a value for the specified key.\n    ///\n    /// The key may be any borrowed form of the map\'s key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, "a");\n    /// assert_eq!(map.contains_key(&1), true);\n    /// assert_eq!(map.contains_key(&2), false);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn contains_key<Q>(&self, k: &Q) -> bool\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        self.get_inner(k).is_some()\n    }\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map\'s key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, "a");\n    /// if let Some(x) = map.get_mut(&1) {\n    ///     *x = "b";\n    /// }\n    /// assert_eq!(map[&1], "b");\n    ///\n    /// assert_eq!(map.get_mut(&2), None);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get_mut<Q>(&mut self, k: &Q) -> Option<&mut V>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.get_inner_mut(k) {\n            Some(&mut (_, ref mut v)) => Some(v),\n            None => None,\n        }\n    }\n\n    #[inline]\n    fn get_inner_mut<Q>(&mut self, k: &Q) -> Option<&mut (K, V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        if self.table.is_empty() {\n            None\n        } else {\n            let hash = make_hash::<Q, S>(&self.hash_builder, k);\n            self.table.get_mut(hash, equivalent_key(k))\n        }\n    }\n\n    /// Attempts to get mutable references to `N` values in the map at once.\n    ///\n    /// Returns an array of length `N` with the results of each query. For soundness, at most one\n    /// mutable reference will be returned to any value. `None` will be used if the key is missing.\n    ///\n    /// # Panics\n    ///\n    /// Panics if any keys are overlapping.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut libraries = HashMap::new();\n    /// libraries.insert("Bodleian Library".to_string(), 1602);\n    /// libraries.insert("Athenum".to_string(), 1807);\n    /// libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n    /// libraries.insert("Library of Congress".to_string(), 1800);\n    ///\n    /// // Get Athenum and Bodleian Library\n    /// let [Some(a), Some(b)] = libraries.get_many_mut([\n    ///     "Athenum",\n    ///     "Bodleian Library",\n    /// ]) else { panic!() };\n    ///\n    /// // Assert values of Athenum and Library of Congress\n    /// let got = libraries.get_many_mut([\n    ///     "Athenum",\n    ///     "Library of Congress",\n    /// ]);\n    /// assert_eq!(\n    ///     got,\n    ///     [\n    ///         Some(&mut 1807),\n    ///         Some(&mut 1800),\n    ///     ],\n    /// );\n    ///\n    /// // Missing keys result in None\n    /// let got = libraries.get_many_mut([\n    ///     "Athenum",\n    ///     "New York Public Library",\n    /// ]);\n    /// assert_eq!(\n    ///     got,\n    ///     [\n    ///         Some(&mut 1807),\n    ///         None\n    ///     ]\n    /// );\n    /// ```\n    ///\n    /// ```should_panic\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut libraries = HashMap::new();\n    /// libraries.insert("Athenum".to_string(), 1807);\n    ///\n    /// // Duplicate keys panic!\n    /// let got = libraries.get_many_mut([\n    ///     "Athenum",\n    ///     "Athenum",\n    /// ]);\n    /// ```\n    pub fn get_many_mut<Q, const N: usize>(&mut self, ks: [&Q; N]) -> [Option<&\'_ mut V>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        self.get_many_mut_inner(ks).map(|res| res.map(|(_, v)| v))\n    }\n\n    /// Attempts to get mutable references to `N` values in the map at once, without validating that\n    /// the values are unique.\n    ///\n    /// Returns an array of length `N` with the results of each query. `None` will be used if\n    /// the key is missing.\n    ///\n    /// For a safe alternative see [`get_many_mut`](`HashMap::get_many_mut`).\n    ///\n    /// # Safety\n    ///\n    /// Calling this method with overlapping keys is *[undefined behavior]* even if the resulting\n    /// references are not used.\n    ///\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut libraries = HashMap::new();\n    /// libraries.insert("Bodleian Library".to_string(), 1602);\n    /// libraries.insert("Athenum".to_string(), 1807);\n    /// libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n    /// libraries.insert("Library of Congress".to_string(), 1800);\n    ///\n    /// // SAFETY: The keys do not overlap.\n    /// let [Some(a), Some(b)] = (unsafe { libraries.get_many_unchecked_mut([\n    ///     "Athenum",\n    ///     "Bodleian Library",\n    /// ]) }) else { panic!() };\n    ///\n    /// // SAFETY: The keys do not overlap.\n    /// let got = unsafe { libraries.get_many_unchecked_mut([\n    ///     "Athenum",\n    ///     "Library of Congress",\n    /// ]) };\n    /// assert_eq!(\n    ///     got,\n    ///     [\n    ///         Some(&mut 1807),\n    ///         Some(&mut 1800),\n    ///     ],\n    /// );\n    ///\n    /// // SAFETY: The keys do not overlap.\n    /// let got = unsafe { libraries.get_many_unchecked_mut([\n    ///     "Athenum",\n    ///     "New York Public Library",\n    /// ]) };\n    /// // Missing keys result in None\n    /// assert_eq!(got, [Some(&mut 1807), None]);\n    /// ```\n    pub unsafe fn get_many_unchecked_mut<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<&\'_ mut V>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        self.get_many_unchecked_mut_inner(ks)\n            .map(|res| res.map(|(_, v)| v))\n    }\n\n    /// Attempts to get mutable references to `N` values in the map at once, with immutable\n    /// references to the corresponding keys.\n    ///\n    /// Returns an array of length `N` with the results of each query. For soundness, at most one\n    /// mutable reference will be returned to any value. `None` will be used if the key is missing.\n    ///\n    /// # Panics\n    ///\n    /// Panics if any keys are overlapping.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut libraries = HashMap::new();\n    /// libraries.insert("Bodleian Library".to_string(), 1602);\n    /// libraries.insert("Athenum".to_string(), 1807);\n    /// libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n    /// libraries.insert("Library of Congress".to_string(), 1800);\n    ///\n    /// let got = libraries.get_many_key_value_mut([\n    ///     "Bodleian Library",\n    ///     "Herzogin-Anna-Amalia-Bibliothek",\n    /// ]);\n    /// assert_eq!(\n    ///     got,\n    ///     [\n    ///         Some((&"Bodleian Library".to_string(), &mut 1602)),\n    ///         Some((&"Herzogin-Anna-Amalia-Bibliothek".to_string(), &mut 1691)),\n    ///     ],\n    /// );\n    /// // Missing keys result in None\n    /// let got = libraries.get_many_key_value_mut([\n    ///     "Bodleian Library",\n    ///     "Gewandhaus",\n    /// ]);\n    /// assert_eq!(got, [Some((&"Bodleian Library".to_string(), &mut 1602)), None]);\n    /// ```\n    ///\n    /// ```should_panic\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut libraries = HashMap::new();\n    /// libraries.insert("Bodleian Library".to_string(), 1602);\n    /// libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n    ///\n    /// // Duplicate keys result in panic!\n    /// let got = libraries.get_many_key_value_mut([\n    ///     "Bodleian Library",\n    ///     "Herzogin-Anna-Amalia-Bibliothek",\n    ///     "Herzogin-Anna-Amalia-Bibliothek",\n    /// ]);\n    /// ```\n    pub fn get_many_key_value_mut<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<(&\'_ K, &\'_ mut V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        self.get_many_mut_inner(ks)\n            .map(|res| res.map(|(k, v)| (&*k, v)))\n    }\n\n    /// Attempts to get mutable references to `N` values in the map at once, with immutable\n    /// references to the corresponding keys, without validating that the values are unique.\n    ///\n    /// Returns an array of length `N` with the results of each query. `None` will be returned if\n    /// any of the keys are missing.\n    ///\n    /// For a safe alternative see [`get_many_key_value_mut`](`HashMap::get_many_key_value_mut`).\n    ///\n    /// # Safety\n    ///\n    /// Calling this method with overlapping keys is *[undefined behavior]* even if the resulting\n    /// references are not used.\n    ///\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut libraries = HashMap::new();\n    /// libraries.insert("Bodleian Library".to_string(), 1602);\n    /// libraries.insert("Athenum".to_string(), 1807);\n    /// libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n    /// libraries.insert("Library of Congress".to_string(), 1800);\n    ///\n    /// let got = libraries.get_many_key_value_mut([\n    ///     "Bodleian Library",\n    ///     "Herzogin-Anna-Amalia-Bibliothek",\n    /// ]);\n    /// assert_eq!(\n    ///     got,\n    ///     [\n    ///         Some((&"Bodleian Library".to_string(), &mut 1602)),\n    ///         Some((&"Herzogin-Anna-Amalia-Bibliothek".to_string(), &mut 1691)),\n    ///     ],\n    /// );\n    /// // Missing keys result in None\n    /// let got = libraries.get_many_key_value_mut([\n    ///     "Bodleian Library",\n    ///     "Gewandhaus",\n    /// ]);\n    /// assert_eq!(\n    ///     got,\n    ///     [\n    ///         Some((&"Bodleian Library".to_string(), &mut 1602)),\n    ///         None,\n    ///     ],\n    /// );\n    /// ```\n    pub unsafe fn get_many_key_value_unchecked_mut<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<(&\'_ K, &\'_ mut V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        self.get_many_unchecked_mut_inner(ks)\n            .map(|res| res.map(|(k, v)| (&*k, v)))\n    }\n\n    fn get_many_mut_inner<Q, const N: usize>(&mut self, ks: [&Q; N]) -> [Option<&\'_ mut (K, V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        let hashes = self.build_hashes_inner(ks);\n        self.table\n            .get_many_mut(hashes, |i, (k, _)| ks[i].equivalent(k))\n    }\n\n    unsafe fn get_many_unchecked_mut_inner<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<&\'_ mut (K, V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        let hashes = self.build_hashes_inner(ks);\n        self.table\n            .get_many_unchecked_mut(hashes, |i, (k, _)| ks[i].equivalent(k))\n    }\n\n    fn build_hashes_inner<Q, const N: usize>(&self, ks: [&Q; N]) -> [u64; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        let mut hashes = [0_u64; N];\n        for i in 0..N {\n            hashes[i] = make_hash::<Q, S>(&self.hash_builder, ks[i]);\n        }\n        hashes\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not have this key present, [`None`] is returned.\n    ///\n    /// If the map did have this key present, the value is updated, and the old\n    /// value is returned. The key is not updated, though; this matters for\n    /// types that can be `==` without being identical. See the [`std::collections`]\n    /// [module-level documentation] for more.\n    ///\n    /// [`None`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n    /// [`std::collections`]: https://doc.rust-lang.org/std/collections/index.html\n    /// [module-level documentation]: https://doc.rust-lang.org/std/collections/index.html#insert-and-complex-keys\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// assert_eq!(map.insert(37, "a"), None);\n    /// assert_eq!(map.is_empty(), false);\n    ///\n    /// map.insert(37, "b");\n    /// assert_eq!(map.insert(37, "c"), Some("b"));\n    /// assert_eq!(map[&37], "c");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n        let hash = make_hash::<K, S>(&self.hash_builder, &k);\n        match self.find_or_find_insert_slot(hash, &k) {\n            Ok(bucket) => Some(mem::replace(unsafe { &mut bucket.as_mut().1 }, v)),\n            Err(slot) => {\n                unsafe {\n                    self.table.insert_in_slot(hash, slot, (k, v));\n                }\n                None\n            }\n        }\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub(crate) fn find_or_find_insert_slot<Q>(\n        &mut self,\n        hash: u64,\n        key: &Q,\n    ) -> Result<Bucket<(K, V)>, crate::raw::InsertSlot>\n    where\n        Q: Equivalent<K> + ?Sized,\n    {\n        self.table.find_or_find_insert_slot(\n            hash,\n            equivalent_key(key),\n            make_hasher(&self.hash_builder),\n        )\n    }\n\n    /// Insert a key-value pair into the map without checking\n    /// if the key already exists in the map.\n    ///\n    /// This operation is faster than regular insert, because it does not perform\n    /// lookup before insertion.\n    ///\n    /// This operation is useful during initial population of the map.\n    /// For example, when constructing a map from another map, we know\n    /// that keys are unique.\n    ///\n    /// Returns a reference to the key and value just inserted.\n    ///\n    /// # Safety\n    ///\n    /// This operation is safe if a key does not exist in the map.\n    ///\n    /// However, if a key exists in the map already, the behavior is unspecified:\n    /// this operation may panic, loop forever, or any following operation with the map\n    /// may panic, loop forever or return arbitrary result.\n    ///\n    /// That said, this operation (and following operations) are guaranteed to\n    /// not violate memory safety.\n    ///\n    /// However this operation is still unsafe because the resulting `HashMap`\n    /// may be passed to unsafe code which does expect the map to behave\n    /// correctly, and would cause unsoundness as a result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map1 = HashMap::new();\n    /// assert_eq!(map1.insert(1, "a"), None);\n    /// assert_eq!(map1.insert(2, "b"), None);\n    /// assert_eq!(map1.insert(3, "c"), None);\n    /// assert_eq!(map1.len(), 3);\n    ///\n    /// let mut map2 = HashMap::new();\n    ///\n    /// for (key, value) in map1.into_iter() {\n    ///     unsafe {\n    ///         map2.insert_unique_unchecked(key, value);\n    ///     }\n    /// }\n    ///\n    /// let (key, value) = unsafe { map2.insert_unique_unchecked(4, "d") };\n    /// assert_eq!(key, &4);\n    /// assert_eq!(value, &mut "d");\n    /// *value = "e";\n    ///\n    /// assert_eq!(map2[&1], "a");\n    /// assert_eq!(map2[&2], "b");\n    /// assert_eq!(map2[&3], "c");\n    /// assert_eq!(map2[&4], "e");\n    /// assert_eq!(map2.len(), 4);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub unsafe fn insert_unique_unchecked(&mut self, k: K, v: V) -> (&K, &mut V) {\n        let hash = make_hash::<K, S>(&self.hash_builder, &k);\n        let bucket = self\n            .table\n            .insert(hash, (k, v), make_hasher::<_, V, S>(&self.hash_builder));\n        let (k_ref, v_ref) = unsafe { bucket.as_mut() };\n        (k_ref, v_ref)\n    }\n\n    /// Tries to insert a key-value pair into the map, and returns\n    /// a mutable reference to the value in the entry.\n    ///\n    /// # Errors\n    ///\n    /// If the map already had this key present, nothing is updated, and\n    /// an error containing the occupied entry and the value is returned.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::OccupiedError;\n    ///\n    /// let mut map = HashMap::new();\n    /// assert_eq!(map.try_insert(37, "a").unwrap(), &"a");\n    ///\n    /// match map.try_insert(37, "b") {\n    ///     Err(OccupiedError { entry, value }) => {\n    ///         assert_eq!(entry.key(), &37);\n    ///         assert_eq!(entry.get(), &"a");\n    ///         assert_eq!(value, "b");\n    ///     }\n    ///     _ => panic!()\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn try_insert(\n        &mut self,\n        key: K,\n        value: V,\n    ) -> Result<&mut V, OccupiedError<\'_, K, V, S, A>> {\n        match self.entry(key) {\n            Entry::Occupied(entry) => Err(OccupiedError { entry, value }),\n            Entry::Vacant(entry) => Ok(entry.insert(value)),\n        }\n    }\n\n    /// Removes a key from the map, returning the value at the key if the key\n    /// was previously in the map. Keeps the allocated memory for reuse.\n    ///\n    /// The key may be any borrowed form of the map\'s key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// // The map is empty\n    /// assert!(map.is_empty() && map.capacity() == 0);\n    ///\n    /// map.insert(1, "a");\n    ///\n    /// assert_eq!(map.remove(&1), Some("a"));\n    /// assert_eq!(map.remove(&1), None);\n    ///\n    /// // Now map holds none elements\n    /// assert!(map.is_empty());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn remove<Q>(&mut self, k: &Q) -> Option<V>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.remove_entry(k) {\n            Some((_, v)) => Some(v),\n            None => None,\n        }\n    }\n\n    /// Removes a key from the map, returning the stored key and value if the\n    /// key was previously in the map. Keeps the allocated memory for reuse.\n    ///\n    /// The key may be any borrowed form of the map\'s key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// // The map is empty\n    /// assert!(map.is_empty() && map.capacity() == 0);\n    ///\n    /// map.insert(1, "a");\n    ///\n    /// assert_eq!(map.remove_entry(&1), Some((1, "a")));\n    /// assert_eq!(map.remove(&1), None);\n    ///\n    /// // Now map hold none elements\n    /// assert!(map.is_empty());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn remove_entry<Q>(&mut self, k: &Q) -> Option<(K, V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        let hash = make_hash::<Q, S>(&self.hash_builder, k);\n        self.table.remove_entry(hash, equivalent_key(k))\n    }\n\n    /// Returns the total amount of memory allocated internally by the hash\n    /// set, in bytes.\n    ///\n    /// The returned number is informational only. It is intended to be\n    /// primarily used for memory profiling.\n    #[inline]\n    pub fn allocation_size(&self) -> usize {\n        self.table.allocation_size()\n    }\n}', 'impl<K, V, S, A> PartialEq for HashMap<K, V, S, A>\nwhere\n    K: Eq + Hash,\n    V: PartialEq,\n    S: BuildHasher,\n    A: Allocator,\n{\n    fn eq(&self, other: &Self) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter()\n            .all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\n    }\n}', 'impl<K, V, S> HashMap<K, V, S> {\n    /// Creates an empty `HashMap` which will use the given hash builder to hash\n    /// keys.\n    ///\n    /// The hash map is initially created with a capacity of 0, so it will not\n    /// allocate until it is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashMap`].\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the `HashMap` to be useful, see its documentation for details.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n    /// let mut map = HashMap::with_hasher(s);\n    /// assert_eq!(map.len(), 0);\n    /// assert_eq!(map.capacity(), 0);\n    ///\n    /// map.insert(1, 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[cfg_attr(feature = "rustc-dep-of-std", rustc_const_stable_indirect)]\n    pub const fn with_hasher(hash_builder: S) -> Self {\n        Self {\n            hash_builder,\n            table: RawTable::new(),\n        }\n    }\n\n    /// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n    /// to hash the keys.\n    ///\n    /// The hash map will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashMap`].\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the `HashMap` to be useful, see its documentation for details.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n    /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n    /// assert_eq!(map.len(), 0);\n    /// assert!(map.capacity() >= 10);\n    ///\n    /// map.insert(1, 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> Self {\n        Self {\n            hash_builder,\n            table: RawTable::with_capacity(capacity),\n        }\n    }\n}', 'impl<K, V> HashMap<K, V, DefaultHashBuilder> {\n    /// Creates an empty `HashMap`.\n    ///\n    /// The hash map is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashMap`], for example with\n    /// [`with_hasher`](HashMap::with_hasher) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::new();\n    /// assert_eq!(map.len(), 0);\n    /// assert_eq!(map.capacity(), 0);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Creates an empty `HashMap` with the specified capacity.\n    ///\n    /// The hash map will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashMap`], for example with\n    /// [`with_capacity_and_hasher`](HashMap::with_capacity_and_hasher) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::with_capacity(10);\n    /// assert_eq!(map.len(), 0);\n    /// assert!(map.capacity() >= 10);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn with_capacity(capacity: usize) -> Self {\n        Self::with_capacity_and_hasher(capacity, DefaultHashBuilder::default())\n    }\n}', 'impl<K: Clone, V: Clone, S: Clone, A: Allocator + Clone> Clone for HashMap<K, V, S, A> {\n    fn clone(&self) -> Self {\n        HashMap {\n            hash_builder: self.hash_builder.clone(),\n            table: self.table.clone(),\n        }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.table.clone_from(&source.table);\n\n        // Update hash_builder only if we successfully cloned all elements.\n        self.hash_builder.clone_from(&source.hash_builder);\n    }\n}'], 'map::IntoIter': ['impl<K, V, A: Allocator> Default for IntoIter<K, V, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self {\n            inner: Default::default(),\n        }\n    }\n}', 'impl<K, V, A: Allocator> ExactSizeIterator for IntoIter<K, V, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}', 'impl<K, V, A: Allocator> FusedIterator for IntoIter<K, V, A> {}', 'impl<K, V, A: Allocator> IntoIter<K, V, A> {\n    /// Returns a iterator of references over the remaining items.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub(super) fn iter(&self) -> Iter<\'_, K, V> {\n        Iter {\n            inner: self.inner.iter(),\n            marker: PhantomData,\n        }\n    }\n}', 'impl<K, V, A: Allocator> Iterator for IntoIter<K, V, A> {\n    type Item = (K, V);\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<(K, V)> {\n        self.inner.next()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, f)\n    }\n}', "impl<K: Debug, V: Debug, A: Allocator> fmt::Debug for IntoIter<K, V, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}"], 'map::IntoKeys': ['impl<K, V, A: Allocator> Default for IntoKeys<K, V, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self {\n            inner: Default::default(),\n        }\n    }\n}', 'impl<K, V, A: Allocator> ExactSizeIterator for IntoKeys<K, V, A> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}', 'impl<K, V, A: Allocator> FusedIterator for IntoKeys<K, V, A> {}', 'impl<K, V, A: Allocator> Iterator for IntoKeys<K, V, A> {\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n        self.inner.next().map(|(k, _)| k)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n    #[inline]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, |acc, (k, _)| f(acc, k))\n    }\n}', "impl<K: Debug, V: Debug, A: Allocator> fmt::Debug for IntoKeys<K, V, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list()\n            .entries(self.inner.iter().map(|(k, _)| k))\n            .finish()\n    }\n}"], 'map::IntoValues': ['impl<K, V, A: Allocator> Default for IntoValues<K, V, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self {\n            inner: Default::default(),\n        }\n    }\n}', 'impl<K, V, A: Allocator> ExactSizeIterator for IntoValues<K, V, A> {\n    #[inline]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}', 'impl<K, V, A: Allocator> FusedIterator for IntoValues<K, V, A> {}', 'impl<K, V, A: Allocator> Iterator for IntoValues<K, V, A> {\n    type Item = V;\n\n    #[inline]\n    fn next(&mut self) -> Option<V> {\n        self.inner.next().map(|(_, v)| v)\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n    #[inline]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, |acc, (_, v)| f(acc, v))\n    }\n}', "impl<K, V: Debug, A: Allocator> fmt::Debug for IntoValues<K, V, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list()\n            .entries(self.inner.iter().map(|(_, v)| v))\n            .finish()\n    }\n}"], 'map::Iter': ['impl<\'a, K, V> Iterator for Iter<\'a, K, V> {\n    type Item = (&\'a K, &\'a V);\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<(&\'a K, &\'a V)> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(x) => unsafe {\n                let r = x.as_ref();\n                Some((&r.0, &r.1))\n            },\n            None => None,\n        }\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, |acc, x| unsafe {\n            let (k, v) = x.as_ref();\n            f(acc, (k, v))\n        })\n    }\n}', 'impl<K, V> Clone for Iter<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        Iter {\n            inner: self.inner.clone(),\n            marker: PhantomData,\n        }\n    }\n}', 'impl<K, V> Default for Iter<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }\n}', 'impl<K, V> ExactSizeIterator for Iter<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}', "impl<K, V> FusedIterator for Iter<'_, K, V> {}", "impl<K: Debug, V: Debug> fmt::Debug for Iter<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"], 'map::IterMut': ['impl<\'a, K, V> Iterator for IterMut<\'a, K, V> {\n    type Item = (&\'a K, &\'a mut V);\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<(&\'a K, &\'a mut V)> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(x) => unsafe {\n                let r = x.as_mut();\n                Some((&r.0, &mut r.1))\n            },\n            None => None,\n        }\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, |acc, x| unsafe {\n            let (k, v) = x.as_mut();\n            f(acc, (k, v))\n        })\n    }\n}', 'impl<K, V> Default for IterMut<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }\n}', 'impl<K, V> ExactSizeIterator for IterMut<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}', "impl<K, V> FusedIterator for IterMut<'_, K, V> {}", 'impl<K, V> IterMut<\'_, K, V> {\n    /// Returns a iterator of references over the remaining items.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub(super) fn iter(&self) -> Iter<\'_, K, V> {\n        Iter {\n            inner: self.inner.clone(),\n            marker: PhantomData,\n        }\n    }\n}', "impl<K, V> fmt::Debug for IterMut<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}", "unsafe impl<K: Send, V: Send> Send for IterMut<'_, K, V> {}"], 'map::Keys': ['impl<\'a, K, V> Iterator for Keys<\'a, K, V> {\n    type Item = &\'a K;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<&\'a K> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, |acc, (k, _)| f(acc, k))\n    }\n}', 'impl<K, V> Clone for Keys<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        Keys {\n            inner: self.inner.clone(),\n        }\n    }\n}', 'impl<K, V> Default for Keys<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self {\n            inner: Default::default(),\n        }\n    }\n}', 'impl<K, V> ExactSizeIterator for Keys<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}', "impl<K, V> FusedIterator for Keys<'_, K, V> {}", "impl<K: Debug, V> fmt::Debug for Keys<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"], 'map::OccupiedEntry': ['impl<\'a, K, V, S, A: Allocator> OccupiedEntry<\'a, K, V, S, A> {\n    /// Gets a reference to the key in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{Entry, HashMap};\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry("poneyland").or_insert(12);\n    ///\n    /// match map.entry("poneyland") {\n    ///     Entry::Vacant(_) => panic!(),\n    ///     Entry::Occupied(entry) => assert_eq!(entry.key(), &"poneyland"),\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn key(&self) -> &K {\n        unsafe { &self.elem.as_ref().0 }\n    }\n\n    /// Take the ownership of the key and value from the map.\n    /// Keeps the allocated memory for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// // The map is empty\n    /// assert!(map.is_empty() && map.capacity() == 0);\n    ///\n    /// map.entry("poneyland").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry("poneyland") {\n    ///     // We delete the entry from the map.\n    ///     assert_eq!(o.remove_entry(), ("poneyland", 12));\n    /// }\n    ///\n    /// assert_eq!(map.contains_key("poneyland"), false);\n    /// // Now map hold none elements\n    /// assert!(map.is_empty());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn remove_entry(self) -> (K, V) {\n        unsafe { self.table.table.remove(self.elem).0 }\n    }\n\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry("poneyland").or_insert(12);\n    ///\n    /// match map.entry("poneyland") {\n    ///     Entry::Vacant(_) => panic!(),\n    ///     Entry::Occupied(entry) => assert_eq!(entry.get(), &12),\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get(&self) -> &V {\n        unsafe { &self.elem.as_ref().1 }\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// If you need a reference to the `OccupiedEntry` which may outlive the\n    /// destruction of the `Entry` value, see [`into_mut`].\n    ///\n    /// [`into_mut`]: #method.into_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry("poneyland").or_insert(12);\n    ///\n    /// assert_eq!(map["poneyland"], 12);\n    /// if let Entry::Occupied(mut o) = map.entry("poneyland") {\n    ///     *o.get_mut() += 10;\n    ///     assert_eq!(*o.get(), 22);\n    ///\n    ///     // We can use the same Entry multiple times.\n    ///     *o.get_mut() += 2;\n    /// }\n    ///\n    /// assert_eq!(map["poneyland"], 24);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get_mut(&mut self) -> &mut V {\n        unsafe { &mut self.elem.as_mut().1 }\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself.\n    ///\n    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n    ///\n    /// [`get_mut`]: #method.get_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{Entry, HashMap};\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry("poneyland").or_insert(12);\n    ///\n    /// assert_eq!(map["poneyland"], 12);\n    ///\n    /// let value: &mut u32;\n    /// match map.entry("poneyland") {\n    ///     Entry::Occupied(entry) => value = entry.into_mut(),\n    ///     Entry::Vacant(_) => panic!(),\n    /// }\n    /// *value += 10;\n    ///\n    /// assert_eq!(map["poneyland"], 22);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn into_mut(self) -> &\'a mut V {\n        unsafe { &mut self.elem.as_mut().1 }\n    }\n\n    /// Sets the value of the entry, and returns the entry\'s old value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry("poneyland").or_insert(12);\n    ///\n    /// if let Entry::Occupied(mut o) = map.entry("poneyland") {\n    ///     assert_eq!(o.insert(15), 12);\n    /// }\n    ///\n    /// assert_eq!(map["poneyland"], 15);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(&mut self, value: V) -> V {\n        mem::replace(self.get_mut(), value)\n    }\n\n    /// Takes the value out of the entry, and returns it.\n    /// Keeps the allocated memory for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// // The map is empty\n    /// assert!(map.is_empty() && map.capacity() == 0);\n    ///\n    /// map.entry("poneyland").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry("poneyland") {\n    ///     assert_eq!(o.remove(), 12);\n    /// }\n    ///\n    /// assert_eq!(map.contains_key("poneyland"), false);\n    /// // Now map hold none elements\n    /// assert!(map.is_empty());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn remove(self) -> V {\n        self.remove_entry().1\n    }\n\n    /// Provides shared access to the key and owned access to the value of\n    /// the entry and allows to replace or remove it based on the\n    /// value of the returned option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.insert("poneyland", 42);\n    ///\n    /// let entry = match map.entry("poneyland") {\n    ///     Entry::Occupied(e) => {\n    ///         e.replace_entry_with(|k, v| {\n    ///             assert_eq!(k, &"poneyland");\n    ///             assert_eq!(v, 42);\n    ///             Some(v + 1)\n    ///         })\n    ///     }\n    ///     Entry::Vacant(_) => panic!(),\n    /// };\n    ///\n    /// match entry {\n    ///     Entry::Occupied(e) => {\n    ///         assert_eq!(e.key(), &"poneyland");\n    ///         assert_eq!(e.get(), &43);\n    ///     }\n    ///     Entry::Vacant(_) => panic!(),\n    /// }\n    ///\n    /// assert_eq!(map["poneyland"], 43);\n    ///\n    /// let entry = match map.entry("poneyland") {\n    ///     Entry::Occupied(e) => e.replace_entry_with(|_k, _v| None),\n    ///     Entry::Vacant(_) => panic!(),\n    /// };\n    ///\n    /// match entry {\n    ///     Entry::Vacant(e) => {\n    ///         assert_eq!(e.key(), &"poneyland");\n    ///     }\n    ///     Entry::Occupied(_) => panic!(),\n    /// }\n    ///\n    /// assert!(!map.contains_key("poneyland"));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn replace_entry_with<F>(self, f: F) -> Entry<\'a, K, V, S, A>\n    where\n        F: FnOnce(&K, V) -> Option<V>,\n    {\n        unsafe {\n            let mut spare_key = None;\n\n            self.table\n                .table\n                .replace_bucket_with(self.elem.clone(), |(key, value)| {\n                    if let Some(new_value) = f(&key, value) {\n                        Some((key, new_value))\n                    } else {\n                        spare_key = Some(key);\n                        None\n                    }\n                });\n\n            if let Some(key) = spare_key {\n                Entry::Vacant(VacantEntry {\n                    hash: self.hash,\n                    key,\n                    table: self.table,\n                })\n            } else {\n                Entry::Occupied(self)\n            }\n        }\n    }\n}', 'impl<K: Debug, V: Debug, S, A: Allocator> Debug for OccupiedEntry<\'_, K, V, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("OccupiedEntry")\n            .field("key", self.key())\n            .field("value", self.get())\n            .finish()\n    }\n}', "unsafe impl<K, V, S, A> Send for OccupiedEntry<'_, K, V, S, A>\nwhere\n    K: Send,\n    V: Send,\n    S: Send,\n    A: Send + Allocator,\n{\n}", "unsafe impl<K, V, S, A> Sync for OccupiedEntry<'_, K, V, S, A>\nwhere\n    K: Sync,\n    V: Sync,\n    S: Sync,\n    A: Sync + Allocator,\n{\n}"], 'map::OccupiedError': ['impl<K: Debug, V: Debug, S, A: Allocator> Debug for OccupiedError<\'_, K, V, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("OccupiedError")\n            .field("key", self.entry.key())\n            .field("old_value", self.entry.get())\n            .field("new_value", &self.value)\n            .finish()\n    }\n}', 'impl<K: Debug, V: Debug, S, A: Allocator> fmt::Display for OccupiedError<\'_, K, V, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        write!(\n            f,\n            "failed to insert {:?}, key {:?} already exists with value {:?}",\n            self.value,\n            self.entry.key(),\n            self.entry.get(),\n        )\n    }\n}'], 'map::VacantEntry': ['impl<\'a, K, V, S, A: Allocator> VacantEntry<\'a, K, V, S, A> {\n    /// Gets a reference to the key that would be used when inserting a value\n    /// through the `VacantEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// assert_eq!(map.entry("poneyland").key(), &"poneyland");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn key(&self) -> &K {\n        &self.key\n    }\n\n    /// Take ownership of the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{Entry, HashMap};\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// match map.entry("poneyland") {\n    ///     Entry::Occupied(_) => panic!(),\n    ///     Entry::Vacant(v) => assert_eq!(v.into_key(), "poneyland"),\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn into_key(self) -> K {\n        self.key\n    }\n\n    /// Sets the value of the entry with the [`VacantEntry`]\'s key,\n    /// and returns a mutable reference to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(o) = map.entry("poneyland") {\n    ///     o.insert(37);\n    /// }\n    /// assert_eq!(map["poneyland"], 37);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(self, value: V) -> &\'a mut V\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        let table = &mut self.table.table;\n        let entry = table.insert_entry(\n            self.hash,\n            (self.key, value),\n            make_hasher::<_, V, S>(&self.table.hash_builder),\n        );\n        &mut entry.1\n    }\n\n    /// Sets the value of the entry with the [`VacantEntry`]\'s key,\n    /// and returns an [`OccupiedEntry`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry("poneyland") {\n    ///     let o = v.insert_entry(37);\n    ///     assert_eq!(o.get(), &37);\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert_entry(self, value: V) -> OccupiedEntry<\'a, K, V, S, A>\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        let elem = self.table.table.insert(\n            self.hash,\n            (self.key, value),\n            make_hasher::<_, V, S>(&self.table.hash_builder),\n        );\n        OccupiedEntry {\n            hash: self.hash,\n            elem,\n            table: self.table,\n        }\n    }\n}', 'impl<K: Debug, V, S, A: Allocator> Debug for VacantEntry<\'_, K, V, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_tuple("VacantEntry").field(self.key()).finish()\n    }\n}'], 'map::VacantEntryRef': ['impl<\'a, \'b, K, Q: ?Sized, V, S, A: Allocator> VacantEntryRef<\'a, \'b, K, Q, V, S, A> {\n    /// Gets a reference to the key that would be used when inserting a value\n    /// through the `VacantEntryRef`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<String, u32> = HashMap::new();\n    /// let key: &str = "poneyland";\n    /// assert_eq!(map.entry_ref(key).key(), "poneyland");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn key(&self) -> &\'b Q {\n        self.key\n    }\n\n    /// Sets the value of the entry with the `VacantEntryRef`\'s key,\n    /// and returns a mutable reference to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::EntryRef;\n    ///\n    /// let mut map: HashMap<String, u32> = HashMap::new();\n    /// let key: &str = "poneyland";\n    ///\n    /// if let EntryRef::Vacant(o) = map.entry_ref(key) {\n    ///     o.insert(37);\n    /// }\n    /// assert_eq!(map["poneyland"], 37);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(self, value: V) -> &\'a mut V\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,\n    {\n        let table = &mut self.table.table;\n        let entry = table.insert_entry(\n            self.hash,\n            (self.key.into(), value),\n            make_hasher::<_, V, S>(&self.table.hash_builder),\n        );\n        &mut entry.1\n    }\n\n    /// Sets the value of the entry with the [`VacantEntryRef`]\'s key,\n    /// and returns an [`OccupiedEntry`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::EntryRef;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let EntryRef::Vacant(v) = map.entry_ref("poneyland") {\n    ///     let o = v.insert_entry(37);\n    ///     assert_eq!(o.get(), &37);\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert_entry(self, value: V) -> OccupiedEntry<\'a, K, V, S, A>\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,\n    {\n        let elem = self.table.table.insert(\n            self.hash,\n            (self.key.into(), value),\n            make_hasher::<_, V, S>(&self.table.hash_builder),\n        );\n        OccupiedEntry {\n            hash: self.hash,\n            elem,\n            table: self.table,\n        }\n    }\n}', 'impl<K, Q, V, S, A> Debug for VacantEntryRef<\'_, \'_, K, Q, V, S, A>\nwhere\n    K: Borrow<Q>,\n    Q: Debug + ?Sized,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_tuple("VacantEntryRef").field(&self.key()).finish()\n    }\n}'], 'map::Values': ['impl<\'a, K, V> Iterator for Values<\'a, K, V> {\n    type Item = &\'a V;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<&\'a V> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some((_, v)) => Some(v),\n            None => None,\n        }\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, |acc, (_, v)| f(acc, v))\n    }\n}', "impl<K, V: Debug> fmt::Debug for Values<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}", 'impl<K, V> Clone for Values<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        Values {\n            inner: self.inner.clone(),\n        }\n    }\n}', 'impl<K, V> Default for Values<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self {\n            inner: Default::default(),\n        }\n    }\n}', 'impl<K, V> ExactSizeIterator for Values<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}', "impl<K, V> FusedIterator for Values<'_, K, V> {}"], 'map::ValuesMut': ['impl<\'a, K, V> Iterator for ValuesMut<\'a, K, V> {\n    type Item = &\'a mut V;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<&\'a mut V> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some((_, v)) => Some(v),\n            None => None,\n        }\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, |acc, (_, v)| f(acc, v))\n    }\n}', "impl<K, V: Debug> fmt::Debug for ValuesMut<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list()\n            .entries(self.inner.iter().map(|(_, val)| val))\n            .finish()\n    }\n}", 'impl<K, V> Default for ValuesMut<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self {\n            inner: Default::default(),\n        }\n    }\n}', 'impl<K, V> ExactSizeIterator for ValuesMut<\'_, K, V> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}', "impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}"], 'raw::Bucket': ['impl<T> Bucket<T> {\n    /// Creates a [`Bucket`] that contain pointer to the data.\n    /// The pointer calculation is performed by calculating the\n    /// offset from given `base` pointer (convenience for\n    /// `base.as_ptr().sub(index)`).\n    ///\n    /// `index` is in units of `T`; e.g., an `index` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// If the `T` is a ZST, then we instead track the index of the element\n    /// in the table so that `erase` works properly (return\n    /// `NonNull::new_unchecked((index + 1) as *mut T)`)\n    ///\n    /// # Safety\n    ///\n    /// If `mem::size_of::<T>() != 0`, then the safety rules are directly derived\n    /// from the safety rules for [`<*mut T>::sub`] method of `*mut T` and the safety\n    /// rules of [`NonNull::new_unchecked`] function.\n    ///\n    /// Thus, in order to uphold the safety contracts for the [`<*mut T>::sub`] method\n    /// and [`NonNull::new_unchecked`] function, as well as for the correct\n    /// logic of the work of this crate, the following rules are necessary and\n    /// sufficient:\n    ///\n    /// * the `base` pointer must not be `dangling` and must points to the\n    ///   end of the first `value element` from the `data part` of the table, i.e.\n    ///   must be the pointer that returned by [`RawTable::data_end`] or by\n    ///   [`RawTableInner::data_end<T>`];\n    ///\n    /// * `index` must not be greater than `RawTableInner.bucket_mask`, i.e.\n    ///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)`\n    ///   must be no greater than the number returned by the function\n    ///   [`RawTable::buckets`] or [`RawTableInner::buckets`].\n    ///\n    /// If `mem::size_of::<T>() == 0`, then the only requirement is that the\n    /// `index` must not be greater than `RawTableInner.bucket_mask`, i.e.\n    /// `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)`\n    /// must be no greater than the number returned by the function\n    /// [`RawTable::buckets`] or [`RawTableInner::buckets`].\n    ///\n    /// [`Bucket`]: crate::raw::Bucket\n    /// [`<*mut T>::sub`]: https://doc.rust-lang.org/core/primitive.pointer.html#method.sub-1\n    /// [`NonNull::new_unchecked`]: https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.new_unchecked\n    /// [`RawTable::data_end`]: crate::raw::RawTable::data_end\n    /// [`RawTableInner::data_end<T>`]: RawTableInner::data_end<T>\n    /// [`RawTable::buckets`]: crate::raw::RawTable::buckets\n    /// [`RawTableInner::buckets`]: RawTableInner::buckets\n    #[inline]\n    unsafe fn from_base_index(base: NonNull<T>, index: usize) -> Self {\n        // If mem::size_of::<T>() != 0 then return a pointer to an `element` in\n        // the data part of the table (we start counting from "0", so that\n        // in the expression T[last], the "last" index actually one less than the\n        // "buckets" number in the table, i.e. "last = RawTableInner.bucket_mask"):\n        //\n        //                   `from_base_index(base, 1).as_ptr()` returns a pointer that\n        //                   points here in the data part of the table\n        //                   (to the start of T1)\n        //                        |\n        //                        |        `base: NonNull<T>` must point here\n        //                        |         (to the end of T0 or to the start of C0)\n        //                        v         v\n        // [Padding], Tlast, ..., |T1|, T0, |C0, C1, ..., Clast\n        //                           ^\n        //                           `from_base_index(base, 1)` returns a pointer\n        //                           that points here in the data part of the table\n        //                           (to the end of T1)\n        //\n        // where: T0...Tlast - our stored data; C0...Clast - control bytes\n        // or metadata for data.\n        let ptr = if T::IS_ZERO_SIZED {\n            // won\'t overflow because index must be less than length (bucket_mask)\n            // and bucket_mask is guaranteed to be less than `isize::MAX`\n            // (see TableLayout::calculate_layout_for method)\n            invalid_mut(index + 1)\n        } else {\n            base.as_ptr().sub(index)\n        };\n        Self {\n            ptr: NonNull::new_unchecked(ptr),\n        }\n    }\n\n    /// Calculates the index of a [`Bucket`] as distance between two pointers\n    /// (convenience for `base.as_ptr().offset_from(self.ptr.as_ptr()) as usize`).\n    /// The returned value is in units of T: the distance in bytes divided by\n    /// [`core::mem::size_of::<T>()`].\n    ///\n    /// If the `T` is a ZST, then we return the index of the element in\n    /// the table so that `erase` works properly (return `self.ptr.as_ptr() as usize - 1`).\n    ///\n    /// This function is the inverse of [`from_base_index`].\n    ///\n    /// # Safety\n    ///\n    /// If `mem::size_of::<T>() != 0`, then the safety rules are directly derived\n    /// from the safety rules for [`<*const T>::offset_from`] method of `*const T`.\n    ///\n    /// Thus, in order to uphold the safety contracts for [`<*const T>::offset_from`]\n    /// method, as well as for the correct logic of the work of this crate, the\n    /// following rules are necessary and sufficient:\n    ///\n    /// * `base` contained pointer must not be `dangling` and must point to the\n    ///   end of the first `element` from the `data part` of the table, i.e.\n    ///   must be a pointer that returns by [`RawTable::data_end`] or by\n    ///   [`RawTableInner::data_end<T>`];\n    ///\n    /// * `self` also must not contain dangling pointer;\n    ///\n    /// * both `self` and `base` must be created from the same [`RawTable`]\n    ///   (or [`RawTableInner`]).\n    ///\n    /// If `mem::size_of::<T>() == 0`, this function is always safe.\n    ///\n    /// [`Bucket`]: crate::raw::Bucket\n    /// [`from_base_index`]: crate::raw::Bucket::from_base_index\n    /// [`RawTable::data_end`]: crate::raw::RawTable::data_end\n    /// [`RawTableInner::data_end<T>`]: RawTableInner::data_end<T>\n    /// [`RawTable`]: crate::raw::RawTable\n    /// [`RawTableInner`]: RawTableInner\n    /// [`<*const T>::offset_from`]: https://doc.rust-lang.org/nightly/core/primitive.pointer.html#method.offset_from\n    #[inline]\n    unsafe fn to_base_index(&self, base: NonNull<T>) -> usize {\n        // If mem::size_of::<T>() != 0 then return an index under which we used to store the\n        // `element` in the data part of the table (we start counting from "0", so\n        // that in the expression T[last], the "last" index actually is one less than the\n        // "buckets" number in the table, i.e. "last = RawTableInner.bucket_mask").\n        // For example for 5th element in table calculation is performed like this:\n        //\n        //                        mem::size_of::<T>()\n        //                          |\n        //                          |         `self = from_base_index(base, 5)` that returns pointer\n        //                          |         that points here in the data part of the table\n        //                          |         (to the end of T5)\n        //                          |           |                    `base: NonNull<T>` must point here\n        //                          v           |                    (to the end of T0 or to the start of C0)\n        //                        /???\\         v                      v\n        // [Padding], Tlast, ..., |T10|, ..., T5|, T4, T3, T2, T1, T0, |C0, C1, C2, C3, C4, C5, ..., C10, ..., Clast\n        //                                      \\__________  __________/\n        //                                                 \\/\n        //                                     `bucket.to_base_index(base)` = 5\n        //                                     (base.as_ptr() as usize - self.ptr.as_ptr() as usize) / mem::size_of::<T>()\n        //\n        // where: T0...Tlast - our stored data; C0...Clast - control bytes or metadata for data.\n        if T::IS_ZERO_SIZED {\n            // this can not be UB\n            self.ptr.as_ptr() as usize - 1\n        } else {\n            offset_from(base.as_ptr(), self.ptr.as_ptr())\n        }\n    }\n\n    /// Acquires the underlying raw pointer `*mut T` to `data`.\n    ///\n    /// # Note\n    ///\n    /// If `T` is not [`Copy`], do not use `*mut T` methods that can cause calling the\n    /// destructor of `T` (for example the [`<*mut T>::drop_in_place`] method), because\n    /// for properly dropping the data we also need to clear `data` control bytes. If we\n    /// drop data, but do not clear `data control byte` it leads to double drop when\n    /// [`RawTable`] goes out of scope.\n    ///\n    /// If you modify an already initialized `value`, so [`Hash`] and [`Eq`] on the new\n    /// `T` value and its borrowed form *must* match those for the old `T` value, as the map\n    /// will not re-evaluate where the new value should go, meaning the value may become\n    /// "lost" if their location does not reflect their state.\n    ///\n    /// [`RawTable`]: crate::raw::RawTable\n    /// [`<*mut T>::drop_in_place`]: https://doc.rust-lang.org/core/primitive.pointer.html#method.drop_in_place\n    /// [`Hash`]: https://doc.rust-lang.org/core/hash/trait.Hash.html\n    /// [`Eq`]: https://doc.rust-lang.org/core/cmp/trait.Eq.html\n    #[inline]\n    pub fn as_ptr(&self) -> *mut T {\n        if T::IS_ZERO_SIZED {\n            // Just return an arbitrary ZST pointer which is properly aligned\n            // invalid pointer is good enough for ZST\n            invalid_mut(mem::align_of::<T>())\n        } else {\n            unsafe { self.ptr.as_ptr().sub(1) }\n        }\n    }\n\n    /// Acquires the underlying non-null pointer `*mut T` to `data`.\n    #[inline]\n    fn as_non_null(&self) -> NonNull<T> {\n        // SAFETY: `self.ptr` is already a `NonNull`\n        unsafe { NonNull::new_unchecked(self.as_ptr()) }\n    }\n\n    /// Create a new [`Bucket`] that is offset from the `self` by the given\n    /// `offset`. The pointer calculation is performed by calculating the\n    /// offset from `self` pointer (convenience for `self.ptr.as_ptr().sub(offset)`).\n    /// This function is used for iterators.\n    ///\n    /// `offset` is in units of `T`; e.g., a `offset` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If `mem::size_of::<T>() != 0`, then the safety rules are directly derived\n    /// from the safety rules for [`<*mut T>::sub`] method of `*mut T` and safety\n    /// rules of [`NonNull::new_unchecked`] function.\n    ///\n    /// Thus, in order to uphold the safety contracts for [`<*mut T>::sub`] method\n    /// and [`NonNull::new_unchecked`] function, as well as for the correct\n    /// logic of the work of this crate, the following rules are necessary and\n    /// sufficient:\n    ///\n    /// * `self` contained pointer must not be `dangling`;\n    ///\n    /// * `self.to_base_index() + offset` must not be greater than `RawTableInner.bucket_mask`,\n    ///   i.e. `(self.to_base_index() + offset) <= RawTableInner.bucket_mask` or, in other\n    ///   words, `self.to_base_index() + offset + 1` must be no greater than the number returned\n    ///   by the function [`RawTable::buckets`] or [`RawTableInner::buckets`].\n    ///\n    /// If `mem::size_of::<T>() == 0`, then the only requirement is that the\n    /// `self.to_base_index() + offset` must not be greater than `RawTableInner.bucket_mask`,\n    /// i.e. `(self.to_base_index() + offset) <= RawTableInner.bucket_mask` or, in other words,\n    /// `self.to_base_index() + offset + 1` must be no greater than the number returned by the\n    /// function [`RawTable::buckets`] or [`RawTableInner::buckets`].\n    ///\n    /// [`Bucket`]: crate::raw::Bucket\n    /// [`<*mut T>::sub`]: https://doc.rust-lang.org/core/primitive.pointer.html#method.sub-1\n    /// [`NonNull::new_unchecked`]: https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.new_unchecked\n    /// [`RawTable::buckets`]: crate::raw::RawTable::buckets\n    /// [`RawTableInner::buckets`]: RawTableInner::buckets\n    #[inline]\n    unsafe fn next_n(&self, offset: usize) -> Self {\n        let ptr = if T::IS_ZERO_SIZED {\n            // invalid pointer is good enough for ZST\n            invalid_mut(self.ptr.as_ptr() as usize + offset)\n        } else {\n            self.ptr.as_ptr().sub(offset)\n        };\n        Self {\n            ptr: NonNull::new_unchecked(ptr),\n        }\n    }\n\n    /// Executes the destructor (if any) of the pointed-to `data`.\n    ///\n    /// # Safety\n    ///\n    /// See [`ptr::drop_in_place`] for safety concerns.\n    ///\n    /// You should use [`RawTable::erase`] instead of this function,\n    /// or be careful with calling this function directly, because for\n    /// properly dropping the data we need also clear `data` control bytes.\n    /// If we drop data, but do not erase `data control byte` it leads to\n    /// double drop when [`RawTable`] goes out of scope.\n    ///\n    /// [`ptr::drop_in_place`]: https://doc.rust-lang.org/core/ptr/fn.drop_in_place.html\n    /// [`RawTable`]: crate::raw::RawTable\n    /// [`RawTable::erase`]: crate::raw::RawTable::erase\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub(crate) unsafe fn drop(&self) {\n        self.as_ptr().drop_in_place();\n    }\n\n    /// Reads the `value` from `self` without moving it. This leaves the\n    /// memory in `self` unchanged.\n    ///\n    /// # Safety\n    ///\n    /// See [`ptr::read`] for safety concerns.\n    ///\n    /// You should use [`RawTable::remove`] instead of this function,\n    /// or be careful with calling this function directly, because compiler\n    /// calls its destructor when the read `value` goes out of scope. It\n    /// can cause double dropping when [`RawTable`] goes out of scope,\n    /// because of not erased `data control byte`.\n    ///\n    /// [`ptr::read`]: https://doc.rust-lang.org/core/ptr/fn.read.html\n    /// [`RawTable`]: crate::raw::RawTable\n    /// [`RawTable::remove`]: crate::raw::RawTable::remove\n    #[inline]\n    pub(crate) unsafe fn read(&self) -> T {\n        self.as_ptr().read()\n    }\n\n    /// Overwrites a memory location with the given `value` without reading\n    /// or dropping the old value (like [`ptr::write`] function).\n    ///\n    /// # Safety\n    ///\n    /// See [`ptr::write`] for safety concerns.\n    ///\n    /// # Note\n    ///\n    /// [`Hash`] and [`Eq`] on the new `T` value and its borrowed form *must* match\n    /// those for the old `T` value, as the map will not re-evaluate where the new\n    /// value should go, meaning the value may become "lost" if their location\n    /// does not reflect their state.\n    ///\n    /// [`ptr::write`]: https://doc.rust-lang.org/core/ptr/fn.write.html\n    /// [`Hash`]: https://doc.rust-lang.org/core/hash/trait.Hash.html\n    /// [`Eq`]: https://doc.rust-lang.org/core/cmp/trait.Eq.html\n    #[inline]\n    pub(crate) unsafe fn write(&self, val: T) {\n        self.as_ptr().write(val);\n    }\n\n    /// Returns a shared immutable reference to the `value`.\n    ///\n    /// # Safety\n    ///\n    /// See [`NonNull::as_ref`] for safety concerns.\n    ///\n    /// [`NonNull::as_ref`]: https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.as_ref\n    #[inline]\n    pub unsafe fn as_ref<\'a>(&self) -> &\'a T {\n        &*self.as_ptr()\n    }\n\n    /// Returns a unique mutable reference to the `value`.\n    ///\n    /// # Safety\n    ///\n    /// See [`NonNull::as_mut`] for safety concerns.\n    ///\n    /// # Note\n    ///\n    /// [`Hash`] and [`Eq`] on the new `T` value and its borrowed form *must* match\n    /// those for the old `T` value, as the map will not re-evaluate where the new\n    /// value should go, meaning the value may become "lost" if their location\n    /// does not reflect their state.\n    ///\n    /// [`NonNull::as_mut`]: https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.as_mut\n    /// [`Hash`]: https://doc.rust-lang.org/core/hash/trait.Hash.html\n    /// [`Eq`]: https://doc.rust-lang.org/core/cmp/trait.Eq.html\n    #[inline]\n    pub unsafe fn as_mut<\'a>(&self) -> &\'a mut T {\n        &mut *self.as_ptr()\n    }\n}', 'impl<T> Clone for Bucket<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Self { ptr: self.ptr }\n    }\n}', 'unsafe impl<T> Send for Bucket<T> {}'], 'raw::Fallibility': ['Clone', 'Copy', 'impl Fallibility {\n    /// Error to return on capacity overflow.\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn capacity_overflow(self) -> TryReserveError {\n        match self {\n            Fallibility::Fallible => TryReserveError::CapacityOverflow,\n            Fallibility::Infallible => panic!("Hash table capacity overflow"),\n        }\n    }\n\n    /// Error to return on allocation error.\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn alloc_err(self, layout: Layout) -> TryReserveError {\n        match self {\n            Fallibility::Fallible => TryReserveError::AllocError { layout },\n            Fallibility::Infallible => handle_alloc_error(layout),\n        }\n    }\n}'], 'raw::FullBucketsIndices': ['impl ExactSizeIterator for FullBucketsIndices {}', 'impl FullBucketsIndices {\n    /// Advances the iterator and returns the next value.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is\n    /// [`Undefined Behavior`]:\n    ///\n    /// * The [`RawTableInner`] / [`RawTable`] must be alive and not moved,\n    ///   i.e. table outlives the `FullBucketsIndices`;\n    ///\n    /// * It never tries to iterate after getting all elements.\n    ///\n    /// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline(always)]\n    unsafe fn next_impl(&mut self) -> Option<usize> {\n        loop {\n            if let Some(index) = self.current_group.next() {\n                // The returned `self.group_first_index + index` will always\n                // be in the range `0..self.buckets()`. See explanation below.\n                return Some(self.group_first_index + index);\n            }\n\n            // SAFETY: The caller of this function ensures that:\n            //\n            // 1. It never tries to iterate after getting all the elements;\n            // 2. The table is alive and did not moved;\n            // 3. The first `self.ctrl` pointed to the start of the array of control bytes.\n            //\n            // Taking the above into account, we always stay within the bounds, because:\n            //\n            // 1. For tables smaller than the group width (self.buckets() <= Group::WIDTH),\n            //    we will never end up in the given branch, since we should have already\n            //    yielded all the elements of the table.\n            //\n            // 2. For tables larger than the group width. The number of buckets is a\n            //    power of two (2 ^ n), Group::WIDTH is also power of two (2 ^ k). Since\n            //    `(2 ^ n) > (2 ^ k)`, than `(2 ^ n) % (2 ^ k) = 0`. As we start from the\n            //    the start of the array of control bytes, and never try to iterate after\n            //    getting all the elements, the last `self.ctrl` will be equal to\n            //    the `self.buckets() - Group::WIDTH`, so `self.current_group.next()`\n            //    will always contains indices within the range `0..Group::WIDTH`,\n            //    and subsequent `self.group_first_index + index` will always return a\n            //    number less than `self.buckets()`.\n            self.ctrl = NonNull::new_unchecked(self.ctrl.as_ptr().add(Group::WIDTH));\n\n            // SAFETY: See explanation above.\n            self.current_group = Group::load_aligned(self.ctrl.as_ptr().cast())\n                .match_full()\n                .into_iter();\n            self.group_first_index += Group::WIDTH;\n        }\n    }\n}', 'impl FusedIterator for FullBucketsIndices {}', 'impl Iterator for FullBucketsIndices {\n    type Item = usize;\n\n    /// Advances the iterator and returns the next value. It is up to\n    /// the caller to ensure that the `RawTable` outlives the `FullBucketsIndices`,\n    /// because we cannot make the `next` method unsafe.\n    #[inline(always)]\n    fn next(&mut self) -> Option<usize> {\n        // Return if we already yielded all items.\n        if self.items == 0 {\n            return None;\n        }\n\n        let nxt = unsafe {\n            // SAFETY:\n            // 1. We check number of items to yield using `items` field.\n            // 2. The caller ensures that the table is alive and has not moved.\n            self.next_impl()\n        };\n\n        debug_assert!(nxt.is_some());\n        self.items -= 1;\n\n        nxt\n    }\n\n    #[inline(always)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.items, Some(self.items))\n    }\n}'], 'raw::ProbeSeq': ['Clone', 'impl ProbeSeq {\n    #[inline]\n    fn move_next(&mut self, bucket_mask: usize) {\n        // We should have found an empty bucket by now and ended the probe.\n        debug_assert!(\n            self.stride <= bucket_mask,\n            "Went past end of probe sequence"\n        );\n\n        self.stride += Group::WIDTH;\n        self.pos += self.stride;\n        self.pos &= bucket_mask;\n    }\n}'], 'raw::RawDrain': ['impl<T, A: Allocator> Drop for RawDrain<\'_, T, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn drop(&mut self) {\n        unsafe {\n            // Drop all remaining elements. Note that this may panic.\n            self.iter.drop_elements();\n\n            // Reset the contents of the table now that all elements have been\n            // dropped.\n            self.table.clear_no_drop();\n\n            // Move the now empty table back to its original location.\n            self.orig_table\n                .as_ptr()\n                .copy_from_nonoverlapping(&self.table, 1);\n        }\n    }\n}', "impl<T, A: Allocator> ExactSizeIterator for RawDrain<'_, T, A> {}", "impl<T, A: Allocator> FusedIterator for RawDrain<'_, T, A> {}", 'impl<T, A: Allocator> Iterator for RawDrain<\'_, T, A> {\n    type Item = T;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<T> {\n        unsafe {\n            let item = self.iter.next()?;\n            Some(item.read())\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}', 'impl<T, A: Allocator> RawDrain<\'_, T, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn iter(&self) -> RawIter<T> {\n        self.iter.clone()\n    }\n}', "unsafe impl<T, A: Allocator> Send for RawDrain<'_, T, A>\nwhere\n    T: Send,\n    A: Send,\n{\n}", "unsafe impl<T, A: Allocator> Sync for RawDrain<'_, T, A>\nwhere\n    T: Sync,\n    A: Sync,\n{\n}"], 'raw::RawExtractIf': ['impl<T, A: Allocator> RawExtractIf<\'_, T, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub(crate) fn next<F>(&mut self, mut f: F) -> Option<T>\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n        unsafe {\n            for item in &mut self.iter {\n                if f(item.as_mut()) {\n                    return Some(self.table.remove(item).0);\n                }\n            }\n        }\n        None\n    }\n}'], 'raw::RawIntoIter': ['impl<T, A: Allocator> Default for RawIntoIter<T, A> {\n    fn default() -> Self {\n        Self {\n            iter: Default::default(),\n            allocation: None,\n            marker: PhantomData,\n        }\n    }\n}', 'impl<T, A: Allocator> Drop for RawIntoIter<T, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn drop(&mut self) {\n        unsafe {\n            // Drop all remaining elements\n            self.iter.drop_elements();\n\n            // Free the table\n            if let Some((ptr, layout, ref alloc)) = self.allocation {\n                alloc.deallocate(ptr, layout);\n            }\n        }\n    }\n}', 'impl<T, A: Allocator> ExactSizeIterator for RawIntoIter<T, A> {}', 'impl<T, A: Allocator> FusedIterator for RawIntoIter<T, A> {}', 'impl<T, A: Allocator> Iterator for RawIntoIter<T, A> {\n    type Item = T;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<T> {\n        unsafe { Some(self.iter.next()?.read()) }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}', 'impl<T, A: Allocator> RawIntoIter<T, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn iter(&self) -> RawIter<T> {\n        self.iter.clone()\n    }\n}', 'unsafe impl<T, A: Allocator> Send for RawIntoIter<T, A>\nwhere\n    T: Send,\n    A: Send,\n{\n}', 'unsafe impl<T, A: Allocator> Sync for RawIntoIter<T, A>\nwhere\n    T: Sync,\n    A: Sync,\n{\n}'], 'raw::RawIter': ['impl<T> Clone for RawIter<T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        Self {\n            iter: self.iter.clone(),\n            items: self.items,\n        }\n    }\n}', 'impl<T> Default for RawIter<T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        // SAFETY: Because the table is static, it always outlives the iter.\n        unsafe { RawTableInner::NEW.iter() }\n    }\n}', 'impl<T> ExactSizeIterator for RawIter<T> {}', 'impl<T> FusedIterator for RawIter<T> {}', 'impl<T> Iterator for RawIter<T> {\n    type Item = Bucket<T>;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<Bucket<T>> {\n        // Inner iterator iterates over buckets\n        // so it can do unnecessary work if we already yielded all items.\n        if self.items == 0 {\n            return None;\n        }\n\n        let nxt = unsafe {\n            // SAFETY: We check number of items to yield using `items` field.\n            self.iter.next_impl::<false>()\n        };\n\n        debug_assert!(nxt.is_some());\n        self.items -= 1;\n\n        nxt\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.items, Some(self.items))\n    }\n\n    #[inline]\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        unsafe { self.iter.fold_impl(self.items, init, f) }\n    }\n}', 'impl<T> RawIter<T> {\n    unsafe fn drop_elements(&mut self) {\n        if T::NEEDS_DROP && self.items != 0 {\n            for item in self {\n                item.drop();\n            }\n        }\n    }\n}'], 'raw::RawIterHash': ['impl<T> Clone for RawIterHash<T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        Self {\n            inner: self.inner.clone(),\n            _marker: PhantomData,\n        }\n    }\n}', 'impl<T> Default for RawIterHash<T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self {\n            // SAFETY: Because the table is static, it always outlives the iter.\n            inner: unsafe { RawIterHashInner::new(&RawTableInner::NEW, 0) },\n            _marker: PhantomData,\n        }\n    }\n}', "impl<T> Iterator for RawIterHash<T> {\n    type Item = Bucket<T>;\n\n    fn next(&mut self) -> Option<Bucket<T>> {\n        unsafe {\n            match self.inner.next() {\n                Some(index) => {\n                    // Can't use `RawTable::bucket` here as we don't have\n                    // an actual `RawTable` reference to use.\n                    debug_assert!(index <= self.inner.bucket_mask);\n                    let bucket = Bucket::from_base_index(self.inner.ctrl.cast(), index);\n                    Some(bucket)\n                }\n                None => None,\n            }\n        }\n    }\n}", 'impl<T> RawIterHash<T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    unsafe fn new<A: Allocator>(table: &RawTable<T, A>, hash: u64) -> Self {\n        RawIterHash {\n            inner: RawIterHashInner::new(&table.table, hash),\n            _marker: PhantomData,\n        }\n    }\n}'], 'raw::RawIterHashInner': ['Clone', "impl Iterator for RawIterHashInner {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        unsafe {\n            loop {\n                if let Some(bit) = self.bitmask.next() {\n                    let index = (self.probe_seq.pos + bit) & self.bucket_mask;\n                    return Some(index);\n                }\n                if likely(self.group.match_empty().any_bit_set()) {\n                    return None;\n                }\n                self.probe_seq.move_next(self.bucket_mask);\n\n                // Can't use `RawTableInner::ctrl` here as we don't have\n                // an actual `RawTableInner` reference to use.\n                let index = self.probe_seq.pos;\n                debug_assert!(index < self.bucket_mask + 1 + Group::WIDTH);\n                let group_ctrl = self.ctrl.as_ptr().add(index).cast();\n\n                self.group = Group::load(group_ctrl);\n                self.bitmask = self.group.match_tag(self.tag_hash).into_iter();\n            }\n        }\n    }\n}", 'impl RawIterHashInner {\n    #[cfg_attr(feature = "inline-more", inline)]\n    unsafe fn new(table: &RawTableInner, hash: u64) -> Self {\n        let tag_hash = Tag::full(hash);\n        let probe_seq = table.probe_seq(hash);\n        let group = Group::load(table.ctrl(probe_seq.pos));\n        let bitmask = group.match_tag(tag_hash).into_iter();\n\n        RawIterHashInner {\n            bucket_mask: table.bucket_mask,\n            ctrl: table.ctrl,\n            tag_hash,\n            probe_seq,\n            group,\n            bitmask,\n        }\n    }\n}'], 'raw::RawIterRange': ['impl<T> Clone for RawIterRange<T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        Self {\n            data: self.data.clone(),\n            next_ctrl: self.next_ctrl,\n            current_group: self.current_group.clone(),\n            end: self.end,\n        }\n    }\n}', 'impl<T> FusedIterator for RawIterRange<T> {}', 'impl<T> Iterator for RawIterRange<T> {\n    type Item = Bucket<T>;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<Bucket<T>> {\n        unsafe {\n            // SAFETY: We set checker flag to true.\n            self.next_impl::<true>()\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // We don\'t have an item count, so just guess based on the range size.\n        let remaining_buckets = if self.end > self.next_ctrl {\n            unsafe { offset_from(self.end, self.next_ctrl) }\n        } else {\n            0\n        };\n\n        // Add a group width to include the group we are currently processing.\n        (0, Some(Group::WIDTH + remaining_buckets))\n    }\n}', 'impl<T> RawIterRange<T> {\n    /// Returns a `RawIterRange` covering a subset of a table.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is\n    /// [`undefined behavior`]:\n    ///\n    /// * `ctrl` must be [valid] for reads, i.e. table outlives the `RawIterRange`;\n    ///\n    /// * `ctrl` must be properly aligned to the group size (`Group::WIDTH`);\n    ///\n    /// * `ctrl` must point to the array of properly initialized control bytes;\n    ///\n    /// * `data` must be the [`Bucket`] at the `ctrl` index in the table;\n    ///\n    /// * the value of `len` must be less than or equal to the number of table buckets,\n    ///   and the returned value of `ctrl.as_ptr().add(len).offset_from(ctrl.as_ptr())`\n    ///   must be positive.\n    ///\n    /// * The `ctrl.add(len)` pointer must be either in bounds or one\n    ///   byte past the end of the same [allocated table].\n    ///\n    /// * The `len` must be a power of two.\n    ///\n    /// [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[cfg_attr(feature = "inline-more", inline)]\n    unsafe fn new(ctrl: *const u8, data: Bucket<T>, len: usize) -> Self {\n        debug_assert_ne!(len, 0);\n        debug_assert_eq!(ctrl as usize % Group::WIDTH, 0);\n        // SAFETY: The caller must uphold the safety rules for the [`RawIterRange::new`]\n        let end = ctrl.add(len);\n\n        // Load the first group and advance ctrl to point to the next group\n        // SAFETY: The caller must uphold the safety rules for the [`RawIterRange::new`]\n        let current_group = Group::load_aligned(ctrl.cast()).match_full();\n        let next_ctrl = ctrl.add(Group::WIDTH);\n\n        Self {\n            current_group: current_group.into_iter(),\n            data,\n            next_ctrl,\n            end,\n        }\n    }\n\n    /// Splits a `RawIterRange` into two halves.\n    ///\n    /// Returns `None` if the remaining range is smaller than or equal to the\n    /// group width.\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[cfg(feature = "rayon")]\n    pub(crate) fn split(mut self) -> (Self, Option<RawIterRange<T>>) {\n        unsafe {\n            if self.end <= self.next_ctrl {\n                // Nothing to split if the group that we are current processing\n                // is the last one.\n                (self, None)\n            } else {\n                // len is the remaining number of elements after the group that\n                // we are currently processing. It must be a multiple of the\n                // group size (small tables are caught by the check above).\n                let len = offset_from(self.end, self.next_ctrl);\n                debug_assert_eq!(len % Group::WIDTH, 0);\n\n                // Split the remaining elements into two halves, but round the\n                // midpoint down in case there is an odd number of groups\n                // remaining. This ensures that:\n                // - The tail is at least 1 group long.\n                // - The split is roughly even considering we still have the\n                //   current group to process.\n                let mid = (len / 2) & !(Group::WIDTH - 1);\n\n                let tail = Self::new(\n                    self.next_ctrl.add(mid),\n                    self.data.next_n(Group::WIDTH).next_n(mid),\n                    len - mid,\n                );\n                debug_assert_eq!(\n                    self.data.next_n(Group::WIDTH).next_n(mid).ptr,\n                    tail.data.ptr\n                );\n                debug_assert_eq!(self.end, tail.end);\n                self.end = self.next_ctrl.add(mid);\n                debug_assert_eq!(self.end.add(Group::WIDTH), tail.next_ctrl);\n                (self, Some(tail))\n            }\n        }\n    }\n\n    /// # Safety\n    /// If `DO_CHECK_PTR_RANGE` is false, caller must ensure that we never try to iterate\n    /// after yielding all elements.\n    #[cfg_attr(feature = "inline-more", inline)]\n    unsafe fn next_impl<const DO_CHECK_PTR_RANGE: bool>(&mut self) -> Option<Bucket<T>> {\n        loop {\n            if let Some(index) = self.current_group.next() {\n                return Some(self.data.next_n(index));\n            }\n\n            if DO_CHECK_PTR_RANGE && self.next_ctrl >= self.end {\n                return None;\n            }\n\n            // We might read past self.end up to the next group boundary,\n            // but this is fine because it only occurs on tables smaller\n            // than the group size where the trailing control bytes are all\n            // EMPTY. On larger tables self.end is guaranteed to be aligned\n            // to the group size (since tables are power-of-two sized).\n            self.current_group = Group::load_aligned(self.next_ctrl.cast())\n                .match_full()\n                .into_iter();\n            self.data = self.data.next_n(Group::WIDTH);\n            self.next_ctrl = self.next_ctrl.add(Group::WIDTH);\n        }\n    }\n\n    /// Folds every element into an accumulator by applying an operation,\n    /// returning the final result.\n    ///\n    /// `fold_impl()` takes three arguments: the number of items remaining in\n    /// the iterator, an initial value, and a closure with two arguments: an\n    /// \'accumulator\', and an element. The closure returns the value that the\n    /// accumulator should have for the next iteration.\n    ///\n    /// The initial value is the value the accumulator will have on the first call.\n    ///\n    /// After applying this closure to every element of the iterator, `fold_impl()`\n    /// returns the accumulator.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is\n    /// [`Undefined Behavior`]:\n    ///\n    /// * The [`RawTableInner`] / [`RawTable`] must be alive and not moved,\n    ///   i.e. table outlives the `RawIterRange`;\n    ///\n    /// * The provided `n` value must match the actual number of items\n    ///   in the table.\n    ///\n    /// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[allow(clippy::while_let_on_iterator)]\n    #[cfg_attr(feature = "inline-more", inline)]\n    unsafe fn fold_impl<F, B>(mut self, mut n: usize, mut acc: B, mut f: F) -> B\n    where\n        F: FnMut(B, Bucket<T>) -> B,\n    {\n        loop {\n            while let Some(index) = self.current_group.next() {\n                // The returned `index` will always be in the range `0..Group::WIDTH`,\n                // so that calling `self.data.next_n(index)` is safe (see detailed explanation below).\n                debug_assert!(n != 0);\n                let bucket = self.data.next_n(index);\n                acc = f(acc, bucket);\n                n -= 1;\n            }\n\n            if n == 0 {\n                return acc;\n            }\n\n            // SAFETY: The caller of this function ensures that:\n            //\n            // 1. The provided `n` value matches the actual number of items in the table;\n            // 2. The table is alive and did not moved.\n            //\n            // Taking the above into account, we always stay within the bounds, because:\n            //\n            // 1. For tables smaller than the group width (self.buckets() <= Group::WIDTH),\n            //    we will never end up in the given branch, since we should have already\n            //    yielded all the elements of the table.\n            //\n            // 2. For tables larger than the group width. The number of buckets is a\n            //    power of two (2 ^ n), Group::WIDTH is also power of two (2 ^ k). Since\n            //    `(2 ^ n) > (2 ^ k)`, than `(2 ^ n) % (2 ^ k) = 0`. As we start from the\n            //    start of the array of control bytes, and never try to iterate after\n            //    getting all the elements, the last `self.current_group` will read bytes\n            //    from the `self.buckets() - Group::WIDTH` index.  We know also that\n            //    `self.current_group.next()` will always return indices within the range\n            //    `0..Group::WIDTH`.\n            //\n            //    Knowing all of the above and taking into account that we are synchronizing\n            //    the `self.data` index with the index we used to read the `self.current_group`,\n            //    the subsequent `self.data.next_n(index)` will always return a bucket with\n            //    an index number less than `self.buckets()`.\n            //\n            //    The last `self.next_ctrl`, whose index would be `self.buckets()`, will never\n            //    actually be read, since we should have already yielded all the elements of\n            //    the table.\n            self.current_group = Group::load_aligned(self.next_ctrl.cast())\n                .match_full()\n                .into_iter();\n            self.data = self.data.next_n(Group::WIDTH);\n            self.next_ctrl = self.next_ctrl.add(Group::WIDTH);\n        }\n    }\n}', 'unsafe impl<T> Send for RawIterRange<T> {}', 'unsafe impl<T> Sync for RawIterRange<T> {}'], 'raw::RawTable': ['impl<T, A: Allocator + Default> Default for RawTable<T, A> {\n    #[inline]\n    fn default() -> Self {\n        Self::new_in(Default::default())\n    }\n}', 'impl<T, A: Allocator> Drop for RawTable<T, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn drop(&mut self) {\n        unsafe {\n            // SAFETY:\n            // 1. We call the function only once;\n            // 2. We know for sure that `alloc` and `table_layout` matches the [`Allocator`]\n            //    and [`TableLayout`] that were used to allocate this table.\n            // 3. If the drop function of any elements fails, then only a memory leak will occur,\n            //    and we don\'t care because we are inside the `Drop` function of the `RawTable`,\n            //    so there won\'t be any table left in an inconsistent state.\n            self.table\n                .drop_inner_table::<T, _>(&self.alloc, Self::TABLE_LAYOUT);\n        }\n    }\n}', 'impl<T, A: Allocator> IntoIterator for RawTable<T, A> {\n    type Item = T;\n    type IntoIter = RawIntoIter<T, A>;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn into_iter(self) -> RawIntoIter<T, A> {\n        unsafe {\n            let iter = self.iter();\n            self.into_iter_from(iter)\n        }\n    }\n}', 'impl<T, A: Allocator> RawTable<T, A> {\n    const TABLE_LAYOUT: TableLayout = TableLayout::new::<T>();\n\n    /// Creates a new empty hash table without allocating any memory, using the\n    /// given allocator.\n    ///\n    /// In effect this returns a table with exactly 1 bucket. However we can\n    /// leave the data pointer dangling since that bucket is never written to\n    /// due to our load factor forcing us to always have at least 1 free bucket.\n    #[inline]\n    #[cfg_attr(feature = "rustc-dep-of-std", rustc_const_stable_indirect)]\n    pub const fn new_in(alloc: A) -> Self {\n        Self {\n            table: RawTableInner::NEW,\n            alloc,\n            marker: PhantomData,\n        }\n    }\n\n    /// Allocates a new hash table with the given number of buckets.\n    ///\n    /// The control bytes are left uninitialized.\n    #[cfg_attr(feature = "inline-more", inline)]\n    unsafe fn new_uninitialized(\n        alloc: A,\n        buckets: usize,\n        fallibility: Fallibility,\n    ) -> Result<Self, TryReserveError> {\n        debug_assert!(buckets.is_power_of_two());\n\n        Ok(Self {\n            table: RawTableInner::new_uninitialized(\n                &alloc,\n                Self::TABLE_LAYOUT,\n                buckets,\n                fallibility,\n            )?,\n            alloc,\n            marker: PhantomData,\n        })\n    }\n\n    /// Allocates a new hash table using the given allocator, with at least enough capacity for\n    /// inserting the given number of elements without reallocating.\n    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n        Self {\n            table: RawTableInner::with_capacity(&alloc, Self::TABLE_LAYOUT, capacity),\n            alloc,\n            marker: PhantomData,\n        }\n    }\n\n    /// Returns a reference to the underlying allocator.\n    #[inline]\n    pub fn allocator(&self) -> &A {\n        &self.alloc\n    }\n\n    /// Returns pointer to one past last `data` element in the table as viewed from\n    /// the start point of the allocation.\n    ///\n    /// The caller must ensure that the `RawTable` outlives the returned [`NonNull<T>`],\n    /// otherwise using it may result in [`undefined behavior`].\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    pub fn data_end(&self) -> NonNull<T> {\n        //                        `self.table.ctrl.cast()` returns pointer that\n        //                        points here (to the end of `T0`)\n        //                          \n        // [Pad], T_n, ..., T1, T0, |CT0, CT1, ..., CT_n|, CTa_0, CTa_1, ..., CTa_m\n        //                           \\________  ________/\n        //                                    \\/\n        //       `n = buckets - 1`, i.e. `RawTable::buckets() - 1`\n        //\n        // where: T0...T_n  - our stored data;\n        //        CT0...CT_n - control bytes or metadata for `data`.\n        //        CTa_0...CTa_m - additional control bytes, where `m = Group::WIDTH - 1` (so that the search\n        //                        with loading `Group` bytes from the heap works properly, even if the result\n        //                        of `h1(hash) & self.bucket_mask` is equal to `self.bucket_mask`). See also\n        //                        `RawTableInner::set_ctrl` function.\n        //\n        // P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n        // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n        self.table.ctrl.cast()\n    }\n\n    /// Returns pointer to start of data table.\n    #[inline]\n    #[cfg(feature = "nightly")]\n    pub unsafe fn data_start(&self) -> NonNull<T> {\n        NonNull::new_unchecked(self.data_end().as_ptr().wrapping_sub(self.buckets()))\n    }\n\n    /// Returns the total amount of memory allocated internally by the hash\n    /// table, in bytes.\n    ///\n    /// The returned number is informational only. It is intended to be\n    /// primarily used for memory profiling.\n    #[inline]\n    pub fn allocation_size(&self) -> usize {\n        // SAFETY: We use the same `table_layout` that was used to allocate\n        // this table.\n        unsafe { self.table.allocation_size_or_zero(Self::TABLE_LAYOUT) }\n    }\n\n    /// Returns the index of a bucket from a `Bucket`.\n    #[inline]\n    pub unsafe fn bucket_index(&self, bucket: &Bucket<T>) -> usize {\n        bucket.to_base_index(self.data_end())\n    }\n\n    /// Returns a pointer to an element in the table.\n    ///\n    /// The caller must ensure that the `RawTable` outlives the returned [`Bucket<T>`],\n    /// otherwise using it may result in [`undefined behavior`].\n    ///\n    /// # Safety\n    ///\n    /// If `mem::size_of::<T>() != 0`, then the caller of this function must observe the\n    /// following safety rules:\n    ///\n    /// * The table must already be allocated;\n    ///\n    /// * The `index` must not be greater than the number returned by the [`RawTable::buckets`]\n    ///   function, i.e. `(index + 1) <= self.buckets()`.\n    ///\n    /// It is safe to call this function with index of zero (`index == 0`) on a table that has\n    /// not been allocated, but using the returned [`Bucket`] results in [`undefined behavior`].\n    ///\n    /// If `mem::size_of::<T>() == 0`, then the only requirement is that the `index` must\n    /// not be greater than the number returned by the [`RawTable::buckets`] function, i.e.\n    /// `(index + 1) <= self.buckets()`.\n    ///\n    /// [`RawTable::buckets`]: RawTable::buckets\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    pub unsafe fn bucket(&self, index: usize) -> Bucket<T> {\n        // If mem::size_of::<T>() != 0 then return a pointer to the `element` in the `data part` of the table\n        // (we start counting from "0", so that in the expression T[n], the "n" index actually one less than\n        // the "buckets" number of our `RawTable`, i.e. "n = RawTable::buckets() - 1"):\n        //\n        //           `table.bucket(3).as_ptr()` returns a pointer that points here in the `data`\n        //           part of the `RawTable`, i.e. to the start of T3 (see `Bucket::as_ptr`)\n        //                  |\n        //                  |               `base = self.data_end()` points here\n        //                  |               (to the start of CT0 or to the end of T0)\n        //                  v                 v\n        // [Pad], T_n, ..., |T3|, T2, T1, T0, |CT0, CT1, CT2, CT3, ..., CT_n, CTa_0, CTa_1, ..., CTa_m\n        //                     ^                                              \\__________  __________/\n        //        `table.bucket(3)` returns a pointer that points                        \\/\n        //         here in the `data` part of the `RawTable` (to              additional control bytes\n        //         the end of T3)                                              `m = Group::WIDTH - 1`\n        //\n        // where: T0...T_n  - our stored data;\n        //        CT0...CT_n - control bytes or metadata for `data`;\n        //        CTa_0...CTa_m - additional control bytes (so that the search with loading `Group` bytes from\n        //                        the heap works properly, even if the result of `h1(hash) & self.table.bucket_mask`\n        //                        is equal to `self.table.bucket_mask`). See also `RawTableInner::set_ctrl` function.\n        //\n        // P.S. `h1(hash) & self.table.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n        // of buckets is a power of two, and `self.table.bucket_mask = self.buckets() - 1`.\n        debug_assert_ne!(self.table.bucket_mask, 0);\n        debug_assert!(index < self.buckets());\n        Bucket::from_base_index(self.data_end(), index)\n    }\n\n    /// Erases an element from the table without dropping it.\n    #[cfg_attr(feature = "inline-more", inline)]\n    unsafe fn erase_no_drop(&mut self, item: &Bucket<T>) {\n        let index = self.bucket_index(item);\n        self.table.erase(index);\n    }\n\n    /// Erases an element from the table, dropping it in place.\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[allow(clippy::needless_pass_by_value)]\n    pub unsafe fn erase(&mut self, item: Bucket<T>) {\n        // Erase the element from the table first since drop might panic.\n        self.erase_no_drop(&item);\n        item.drop();\n    }\n\n    /// Removes an element from the table, returning it.\n    ///\n    /// This also returns an `InsertSlot` pointing to the newly free bucket.\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[allow(clippy::needless_pass_by_value)]\n    pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n        self.erase_no_drop(&item);\n        (\n            item.read(),\n            InsertSlot {\n                index: self.bucket_index(&item),\n            },\n        )\n    }\n\n    /// Finds and removes an element from the table, returning it.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<T> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.find(hash, eq) {\n            Some(bucket) => Some(unsafe { self.remove(bucket).0 }),\n            None => None,\n        }\n    }\n\n    /// Marks all table buckets as empty without dropping their contents.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn clear_no_drop(&mut self) {\n        self.table.clear_no_drop();\n    }\n\n    /// Removes all elements from the table without freeing the backing memory.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn clear(&mut self) {\n        if self.is_empty() {\n            // Special case empty table to avoid surprising O(capacity) time.\n            return;\n        }\n        // Ensure that the table is reset even if one of the drops panic\n        let mut self_ = guard(self, |self_| self_.clear_no_drop());\n        unsafe {\n            // SAFETY: ScopeGuard sets to zero the `items` field of the table\n            // even in case of panic during the dropping of the elements so\n            // that there will be no double drop of the elements.\n            self_.table.drop_elements::<T>();\n        }\n    }\n\n    /// Shrinks the table to fit `max(self.len(), min_size)` elements.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn shrink_to(&mut self, min_size: usize, hasher: impl Fn(&T) -> u64) {\n        // Calculate the minimal number of elements that we need to reserve\n        // space for.\n        let min_size = usize::max(self.table.items, min_size);\n        if min_size == 0 {\n            let mut old_inner = mem::replace(&mut self.table, RawTableInner::NEW);\n            unsafe {\n                // SAFETY:\n                // 1. We call the function only once;\n                // 2. We know for sure that `alloc` and `table_layout` matches the [`Allocator`]\n                //    and [`TableLayout`] that were used to allocate this table.\n                // 3. If any elements\' drop function panics, then there will only be a memory leak,\n                //    because we have replaced the inner table with a new one.\n                old_inner.drop_inner_table::<T, _>(&self.alloc, Self::TABLE_LAYOUT);\n            }\n            return;\n        }\n\n        // Calculate the number of buckets that we need for this number of\n        // elements. If the calculation overflows then the requested bucket\n        // count must be larger than what we have right and nothing needs to be\n        // done.\n        let min_buckets = match capacity_to_buckets(min_size, Self::TABLE_LAYOUT) {\n            Some(buckets) => buckets,\n            None => return,\n        };\n\n        // If we have more buckets than we need, shrink the table.\n        if min_buckets < self.buckets() {\n            // Fast path if the table is empty\n            if self.table.items == 0 {\n                let new_inner =\n                    RawTableInner::with_capacity(&self.alloc, Self::TABLE_LAYOUT, min_size);\n                let mut old_inner = mem::replace(&mut self.table, new_inner);\n                unsafe {\n                    // SAFETY:\n                    // 1. We call the function only once;\n                    // 2. We know for sure that `alloc` and `table_layout` matches the [`Allocator`]\n                    //    and [`TableLayout`] that were used to allocate this table.\n                    // 3. If any elements\' drop function panics, then there will only be a memory leak,\n                    //    because we have replaced the inner table with a new one.\n                    old_inner.drop_inner_table::<T, _>(&self.alloc, Self::TABLE_LAYOUT);\n                }\n            } else {\n                // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.\n                unsafe {\n                    // SAFETY:\n                    // 1. We know for sure that `min_size >= self.table.items`.\n                    // 2. The [`RawTableInner`] must already have properly initialized control bytes since\n                    //    we will never expose RawTable::new_uninitialized in a public API.\n                    if self\n                        .resize(min_size, hasher, Fallibility::Infallible)\n                        .is_err()\n                    {\n                        // SAFETY: The result of calling the `resize` function cannot be an error\n                        // because `fallibility == Fallibility::Infallible.\n                        hint::unreachable_unchecked()\n                    }\n                }\n            }\n        }\n    }\n\n    /// Ensures that at least `additional` items can be inserted into the table\n    /// without reallocation.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64) {\n        if unlikely(additional > self.table.growth_left) {\n            // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.\n            unsafe {\n                // SAFETY: The [`RawTableInner`] must already have properly initialized control\n                // bytes since we will never expose RawTable::new_uninitialized in a public API.\n                if self\n                    .reserve_rehash(additional, hasher, Fallibility::Infallible)\n                    .is_err()\n                {\n                    // SAFETY: All allocation errors will be caught inside `RawTableInner::reserve_rehash`.\n                    hint::unreachable_unchecked()\n                }\n            }\n        }\n    }\n\n    /// Tries to ensure that at least `additional` items can be inserted into\n    /// the table without reallocation.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn try_reserve(\n        &mut self,\n        additional: usize,\n        hasher: impl Fn(&T) -> u64,\n    ) -> Result<(), TryReserveError> {\n        if additional > self.table.growth_left {\n            // SAFETY: The [`RawTableInner`] must already have properly initialized control\n            // bytes since we will never expose RawTable::new_uninitialized in a public API.\n            unsafe { self.reserve_rehash(additional, hasher, Fallibility::Fallible) }\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Out-of-line slow path for `reserve` and `try_reserve`.\n    ///\n    /// # Safety\n    ///\n    /// The [`RawTableInner`] must have properly initialized control bytes,\n    /// otherwise calling this function results in [`undefined behavior`]\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[cold]\n    #[inline(never)]\n    unsafe fn reserve_rehash(\n        &mut self,\n        additional: usize,\n        hasher: impl Fn(&T) -> u64,\n        fallibility: Fallibility,\n    ) -> Result<(), TryReserveError> {\n        unsafe {\n            // SAFETY:\n            // 1. We know for sure that `alloc` and `layout` matches the [`Allocator`] and\n            //    [`TableLayout`] that were used to allocate this table.\n            // 2. The `drop` function is the actual drop function of the elements stored in\n            //    the table.\n            // 3. The caller ensures that the control bytes of the `RawTableInner`\n            //    are already initialized.\n            self.table.reserve_rehash_inner(\n                &self.alloc,\n                additional,\n                &|table, index| hasher(table.bucket::<T>(index).as_ref()),\n                fallibility,\n                Self::TABLE_LAYOUT,\n                if T::NEEDS_DROP {\n                    Some(|ptr| ptr::drop_in_place(ptr as *mut T))\n                } else {\n                    None\n                },\n            )\n        }\n    }\n\n    /// Allocates a new table of a different size and moves the contents of the\n    /// current table into it.\n    ///\n    /// # Safety\n    ///\n    /// The [`RawTableInner`] must have properly initialized control bytes,\n    /// otherwise calling this function results in [`undefined behavior`]\n    ///\n    /// The caller of this function must ensure that `capacity >= self.table.items`\n    /// otherwise:\n    ///\n    /// * If `self.table.items != 0`, calling of this function with `capacity`\n    ///   equal to 0 (`capacity == 0`) results in [`undefined behavior`].\n    ///\n    /// * If `self.table.items > capacity_to_buckets(capacity, Self::TABLE_LAYOUT)`\n    ///   calling this function are never return (will loop infinitely).\n    ///\n    /// See [`RawTableInner::find_insert_slot`] for more information.\n    ///\n    /// [`RawTableInner::find_insert_slot`]: RawTableInner::find_insert_slot\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    unsafe fn resize(\n        &mut self,\n        capacity: usize,\n        hasher: impl Fn(&T) -> u64,\n        fallibility: Fallibility,\n    ) -> Result<(), TryReserveError> {\n        // SAFETY:\n        // 1. The caller of this function guarantees that `capacity >= self.table.items`.\n        // 2. We know for sure that `alloc` and `layout` matches the [`Allocator`] and\n        //    [`TableLayout`] that were used to allocate this table.\n        // 3. The caller ensures that the control bytes of the `RawTableInner`\n        //    are already initialized.\n        self.table.resize_inner(\n            &self.alloc,\n            capacity,\n            &|table, index| hasher(table.bucket::<T>(index).as_ref()),\n            fallibility,\n            Self::TABLE_LAYOUT,\n        )\n    }\n\n    /// Inserts a new element into the table, and returns its raw bucket.\n    ///\n    /// This does not check if the given element already exists in the table.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> Bucket<T> {\n        unsafe {\n            // SAFETY:\n            // 1. The [`RawTableInner`] must already have properly initialized control bytes since\n            //    we will never expose `RawTable::new_uninitialized` in a public API.\n            //\n            // 2. We reserve additional space (if necessary) right after calling this function.\n            let mut slot = self.table.find_insert_slot(hash);\n\n            // We can avoid growing the table once we have reached our load factor if we are replacing\n            // a tombstone. This works since the number of EMPTY slots does not change in this case.\n            //\n            // SAFETY: The function is guaranteed to return [`InsertSlot`] that contains an index\n            // in the range `0..=self.buckets()`.\n            let old_ctrl = *self.table.ctrl(slot.index);\n            if unlikely(self.table.growth_left == 0 && old_ctrl.special_is_empty()) {\n                self.reserve(1, hasher);\n                // SAFETY: We know for sure that `RawTableInner` has control bytes\n                // initialized and that there is extra space in the table.\n                slot = self.table.find_insert_slot(hash);\n            }\n\n            self.insert_in_slot(hash, slot, value)\n        }\n    }\n\n    /// Inserts a new element into the table, and returns a mutable reference to it.\n    ///\n    /// This does not check if the given element already exists in the table.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert_entry(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> &mut T {\n        unsafe { self.insert(hash, value, hasher).as_mut() }\n    }\n\n    /// Inserts a new element into the table, without growing the table.\n    ///\n    /// There must be enough space in the table to insert the new element.\n    ///\n    /// This does not check if the given element already exists in the table.\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[cfg(feature = "rustc-internal-api")]\n    pub unsafe fn insert_no_grow(&mut self, hash: u64, value: T) -> Bucket<T> {\n        let (index, old_ctrl) = self.table.prepare_insert_slot(hash);\n        let bucket = self.table.bucket(index);\n\n        // If we are replacing a DELETED entry then we don\'t need to update\n        // the load counter.\n        self.table.growth_left -= old_ctrl.special_is_empty() as usize;\n\n        bucket.write(value);\n        self.table.items += 1;\n        bucket\n    }\n\n    /// Temporary removes a bucket, applying the given function to the removed\n    /// element and optionally put back the returned value in the same bucket.\n    ///\n    /// Returns `true` if the bucket still contains an element\n    ///\n    /// This does not check if the given bucket is actually occupied.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub unsafe fn replace_bucket_with<F>(&mut self, bucket: Bucket<T>, f: F) -> bool\n    where\n        F: FnOnce(T) -> Option<T>,\n    {\n        let index = self.bucket_index(&bucket);\n        let old_ctrl = *self.table.ctrl(index);\n        debug_assert!(self.is_bucket_full(index));\n        let old_growth_left = self.table.growth_left;\n        let item = self.remove(bucket).0;\n        if let Some(new_item) = f(item) {\n            self.table.growth_left = old_growth_left;\n            self.table.set_ctrl(index, old_ctrl);\n            self.table.items += 1;\n            self.bucket(index).write(new_item);\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Searches for an element in the table. If the element is not found,\n    /// returns `Err` with the position of a slot where an element with the\n    /// same hash could be inserted.\n    ///\n    /// This function may resize the table if additional space is required for\n    /// inserting an element.\n    #[inline]\n    pub fn find_or_find_insert_slot(\n        &mut self,\n        hash: u64,\n        mut eq: impl FnMut(&T) -> bool,\n        hasher: impl Fn(&T) -> u64,\n    ) -> Result<Bucket<T>, InsertSlot> {\n        self.reserve(1, hasher);\n\n        unsafe {\n            // SAFETY:\n            // 1. We know for sure that there is at least one empty `bucket` in the table.\n            // 2. The [`RawTableInner`] must already have properly initialized control bytes since we will\n            //    never expose `RawTable::new_uninitialized` in a public API.\n            // 3. The `find_or_find_insert_slot_inner` function returns the `index` of only the full bucket,\n            //    which is in the range `0..self.buckets()` (since there is at least one empty `bucket` in\n            //    the table), so calling `self.bucket(index)` and `Bucket::as_ref` is safe.\n            match self\n                .table\n                .find_or_find_insert_slot_inner(hash, &mut |index| eq(self.bucket(index).as_ref()))\n            {\n                // SAFETY: See explanation above.\n                Ok(index) => Ok(self.bucket(index)),\n                Err(slot) => Err(slot),\n            }\n        }\n    }\n\n    /// Inserts a new element into the table in the given slot, and returns its\n    /// raw bucket.\n    ///\n    /// # Safety\n    ///\n    /// `slot` must point to a slot previously returned by\n    /// `find_or_find_insert_slot`, and no mutation of the table must have\n    /// occurred since that call.\n    #[inline]\n    pub unsafe fn insert_in_slot(&mut self, hash: u64, slot: InsertSlot, value: T) -> Bucket<T> {\n        let old_ctrl = *self.table.ctrl(slot.index);\n        self.table.record_item_insert_at(slot.index, old_ctrl, hash);\n\n        let bucket = self.bucket(slot.index);\n        bucket.write(value);\n        bucket\n    }\n\n    /// Searches for an element in the table.\n    #[inline]\n    pub fn find(&self, hash: u64, mut eq: impl FnMut(&T) -> bool) -> Option<Bucket<T>> {\n        unsafe {\n            // SAFETY:\n            // 1. The [`RawTableInner`] must already have properly initialized control bytes since we\n            //    will never expose `RawTable::new_uninitialized` in a public API.\n            // 1. The `find_inner` function returns the `index` of only the full bucket, which is in\n            //    the range `0..self.buckets()`, so calling `self.bucket(index)` and `Bucket::as_ref`\n            //    is safe.\n            let result = self\n                .table\n                .find_inner(hash, &mut |index| eq(self.bucket(index).as_ref()));\n\n            // Avoid `Option::map` because it bloats LLVM IR.\n            match result {\n                // SAFETY: See explanation above.\n                Some(index) => Some(self.bucket(index)),\n                None => None,\n            }\n        }\n    }\n\n    /// Gets a reference to an element in the table.\n    #[inline]\n    pub fn get(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.find(hash, eq) {\n            Some(bucket) => Some(unsafe { bucket.as_ref() }),\n            None => None,\n        }\n    }\n\n    /// Gets a mutable reference to an element in the table.\n    #[inline]\n    pub fn get_mut(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&mut T> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.find(hash, eq) {\n            Some(bucket) => Some(unsafe { bucket.as_mut() }),\n            None => None,\n        }\n    }\n\n    /// Attempts to get mutable references to `N` entries in the table at once.\n    ///\n    /// Returns an array of length `N` with the results of each query.\n    ///\n    /// At most one mutable reference will be returned to any entry. `None` will be returned if any\n    /// of the hashes are duplicates. `None` will be returned if the hash is not found.\n    ///\n    /// The `eq` argument should be a closure such that `eq(i, k)` returns true if `k` is equal to\n    /// the `i`th key to be looked up.\n    pub fn get_many_mut<const N: usize>(\n        &mut self,\n        hashes: [u64; N],\n        eq: impl FnMut(usize, &T) -> bool,\n    ) -> [Option<&\'_ mut T>; N] {\n        unsafe {\n            let ptrs = self.get_many_mut_pointers(hashes, eq);\n\n            for (i, cur) in ptrs.iter().enumerate() {\n                if cur.is_some() && ptrs[..i].contains(cur) {\n                    panic!("duplicate keys found");\n                }\n            }\n            // All bucket are distinct from all previous buckets so we\'re clear to return the result\n            // of the lookup.\n\n            ptrs.map(|ptr| ptr.map(|mut ptr| ptr.as_mut()))\n        }\n    }\n\n    pub unsafe fn get_many_unchecked_mut<const N: usize>(\n        &mut self,\n        hashes: [u64; N],\n        eq: impl FnMut(usize, &T) -> bool,\n    ) -> [Option<&\'_ mut T>; N] {\n        let ptrs = self.get_many_mut_pointers(hashes, eq);\n        ptrs.map(|ptr| ptr.map(|mut ptr| ptr.as_mut()))\n    }\n\n    unsafe fn get_many_mut_pointers<const N: usize>(\n        &mut self,\n        hashes: [u64; N],\n        mut eq: impl FnMut(usize, &T) -> bool,\n    ) -> [Option<NonNull<T>>; N] {\n        array::from_fn(|i| {\n            self.find(hashes[i], |k| eq(i, k))\n                .map(|cur| cur.as_non_null())\n        })\n    }\n\n    /// Returns the number of elements the map can hold without reallocating.\n    ///\n    /// This number is a lower bound; the table might be able to hold\n    /// more, but is guaranteed to be able to hold at least this many.\n    #[inline]\n    pub fn capacity(&self) -> usize {\n        self.table.items + self.table.growth_left\n    }\n\n    /// Returns the number of elements in the table.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.table.items\n    }\n\n    /// Returns `true` if the table contains no elements.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns the number of buckets in the table.\n    #[inline]\n    pub fn buckets(&self) -> usize {\n        self.table.bucket_mask + 1\n    }\n\n    /// Checks whether the bucket at `index` is full.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure `index` is less than the number of buckets.\n    #[inline]\n    pub unsafe fn is_bucket_full(&self, index: usize) -> bool {\n        self.table.is_bucket_full(index)\n    }\n\n    /// Returns an iterator over every element in the table. It is up to\n    /// the caller to ensure that the `RawTable` outlives the `RawIter`.\n    /// Because we cannot make the `next` method unsafe on the `RawIter`\n    /// struct, we have to make the `iter` method unsafe.\n    #[inline]\n    pub unsafe fn iter(&self) -> RawIter<T> {\n        // SAFETY:\n        // 1. The caller must uphold the safety contract for `iter` method.\n        // 2. The [`RawTableInner`] must already have properly initialized control bytes since\n        //    we will never expose RawTable::new_uninitialized in a public API.\n        self.table.iter()\n    }\n\n    /// Returns an iterator over occupied buckets that could match a given hash.\n    ///\n    /// `RawTable` only stores 7 bits of the hash value, so this iterator may\n    /// return items that have a hash value different than the one provided. You\n    /// should always validate the returned values before using them.\n    ///\n    /// It is up to the caller to ensure that the `RawTable` outlives the\n    /// `RawIterHash`. Because we cannot make the `next` method unsafe on the\n    /// `RawIterHash` struct, we have to make the `iter_hash` method unsafe.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub unsafe fn iter_hash(&self, hash: u64) -> RawIterHash<T> {\n        RawIterHash::new(self, hash)\n    }\n\n    /// Returns an iterator which removes all elements from the table without\n    /// freeing the memory.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn drain(&mut self) -> RawDrain<\'_, T, A> {\n        unsafe {\n            let iter = self.iter();\n            self.drain_iter_from(iter)\n        }\n    }\n\n    /// Returns an iterator which removes all elements from the table without\n    /// freeing the memory.\n    ///\n    /// Iteration starts at the provided iterator\'s current location.\n    ///\n    /// It is up to the caller to ensure that the iterator is valid for this\n    /// `RawTable` and covers all items that remain in the table.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub unsafe fn drain_iter_from(&mut self, iter: RawIter<T>) -> RawDrain<\'_, T, A> {\n        debug_assert_eq!(iter.len(), self.len());\n        RawDrain {\n            iter,\n            table: mem::replace(&mut self.table, RawTableInner::NEW),\n            orig_table: NonNull::from(&mut self.table),\n            marker: PhantomData,\n        }\n    }\n\n    /// Returns an iterator which consumes all elements from the table.\n    ///\n    /// Iteration starts at the provided iterator\'s current location.\n    ///\n    /// It is up to the caller to ensure that the iterator is valid for this\n    /// `RawTable` and covers all items that remain in the table.\n    pub unsafe fn into_iter_from(self, iter: RawIter<T>) -> RawIntoIter<T, A> {\n        debug_assert_eq!(iter.len(), self.len());\n\n        let allocation = self.into_allocation();\n        RawIntoIter {\n            iter,\n            allocation,\n            marker: PhantomData,\n        }\n    }\n\n    /// Converts the table into a raw allocation. The contents of the table\n    /// should be dropped using a `RawIter` before freeing the allocation.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub(crate) fn into_allocation(self) -> Option<(NonNull<u8>, Layout, A)> {\n        let alloc = if self.table.is_empty_singleton() {\n            None\n        } else {\n            // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.\n            let (layout, ctrl_offset) =\n                match Self::TABLE_LAYOUT.calculate_layout_for(self.table.buckets()) {\n                    Some(lco) => lco,\n                    None => unsafe { hint::unreachable_unchecked() },\n                };\n            Some((\n                unsafe { NonNull::new_unchecked(self.table.ctrl.as_ptr().sub(ctrl_offset).cast()) },\n                layout,\n                unsafe { ptr::read(&self.alloc) },\n            ))\n        };\n        mem::forget(self);\n        alloc\n    }\n}', "impl<T: Clone, A: Allocator + Clone> Clone for RawTable<T, A> {\n    fn clone(&self) -> Self {\n        if self.table.is_empty_singleton() {\n            Self::new_in(self.alloc.clone())\n        } else {\n            unsafe {\n                // Avoid `Result::ok_or_else` because it bloats LLVM IR.\n                //\n                // SAFETY: This is safe as we are taking the size of an already allocated table\n                // and therefore capacity overflow cannot occur, `self.table.buckets()` is power\n                // of two and all allocator errors will be caught inside `RawTableInner::new_uninitialized`.\n                let mut new_table = match Self::new_uninitialized(\n                    self.alloc.clone(),\n                    self.table.buckets(),\n                    Fallibility::Infallible,\n                ) {\n                    Ok(table) => table,\n                    Err(_) => hint::unreachable_unchecked(),\n                };\n\n                // Cloning elements may fail (the clone function may panic). But we don't\n                // need to worry about uninitialized control bits, since:\n                // 1. The number of items (elements) in the table is zero, which means that\n                //    the control bits will not be read by Drop function.\n                // 2. The `clone_from_spec` method will first copy all control bits from\n                //    `self` (thus initializing them). But this will not affect the `Drop`\n                //    function, since the `clone_from_spec` function sets `items` only after\n                //    successfully cloning all elements.\n                new_table.clone_from_spec(self);\n                new_table\n            }\n        }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        if source.table.is_empty_singleton() {\n            let mut old_inner = mem::replace(&mut self.table, RawTableInner::NEW);\n            unsafe {\n                // SAFETY:\n                // 1. We call the function only once;\n                // 2. We know for sure that `alloc` and `table_layout` matches the [`Allocator`]\n                //    and [`TableLayout`] that were used to allocate this table.\n                // 3. If any elements' drop function panics, then there will only be a memory leak,\n                //    because we have replaced the inner table with a new one.\n                old_inner.drop_inner_table::<T, _>(&self.alloc, Self::TABLE_LAYOUT);\n            }\n        } else {\n            unsafe {\n                // Make sure that if any panics occurs, we clear the table and\n                // leave it in an empty state.\n                let mut self_ = guard(self, |self_| {\n                    self_.clear_no_drop();\n                });\n\n                // First, drop all our elements without clearing the control\n                // bytes. If this panics then the scope guard will clear the\n                // table, leaking any elements that were not dropped yet.\n                //\n                // This leak is unavoidable: we can't try dropping more elements\n                // since this could lead to another panic and abort the process.\n                //\n                // SAFETY: If something gets wrong we clear our table right after\n                // dropping the elements, so there is no double drop, since `items`\n                // will be equal to zero.\n                self_.table.drop_elements::<T>();\n\n                // If necessary, resize our table to match the source.\n                if self_.buckets() != source.buckets() {\n                    let new_inner = match RawTableInner::new_uninitialized(\n                        &self_.alloc,\n                        Self::TABLE_LAYOUT,\n                        source.buckets(),\n                        Fallibility::Infallible,\n                    ) {\n                        Ok(table) => table,\n                        Err(_) => hint::unreachable_unchecked(),\n                    };\n                    // Replace the old inner with new uninitialized one. It's ok, since if something gets\n                    // wrong `ScopeGuard` will initialize all control bytes and leave empty table.\n                    let mut old_inner = mem::replace(&mut self_.table, new_inner);\n                    if !old_inner.is_empty_singleton() {\n                        // SAFETY:\n                        // 1. We have checked that our table is allocated.\n                        // 2. We know for sure that `alloc` and `table_layout` matches\n                        // the [`Allocator`] and [`TableLayout`] that were used to allocate this table.\n                        old_inner.free_buckets(&self_.alloc, Self::TABLE_LAYOUT);\n                    }\n                }\n\n                // Cloning elements may fail (the clone function may panic), but the `ScopeGuard`\n                // inside the `clone_from_impl` function will take care of that, dropping all\n                // cloned elements if necessary. Our `ScopeGuard` will clear the table.\n                self_.clone_from_spec(source);\n\n                // Disarm the scope guard if cloning was successful.\n                ScopeGuard::into_inner(self_);\n            }\n        }\n    }\n}", 'impl<T: Clone, A: Allocator + Clone> RawTable<T, A> {\n    /// Common code for `clone` and `clone_from`. Assumes:\n    /// - `self.buckets() == source.buckets()`.\n    /// - Any existing elements have been dropped.\n    /// - The control bytes are not initialized yet.\n    #[cfg_attr(feature = "inline-more", inline)]\n    unsafe fn clone_from_impl(&mut self, source: &Self) {\n        // Copy the control bytes unchanged. We do this in a single pass\n        source\n            .table\n            .ctrl(0)\n            .copy_to_nonoverlapping(self.table.ctrl(0), self.table.num_ctrl_bytes());\n\n        // The cloning of elements may panic, in which case we need\n        // to make sure we drop only the elements that have been\n        // cloned so far.\n        let mut guard = guard((0, &mut *self), |(index, self_)| {\n            if T::NEEDS_DROP {\n                for i in 0..*index {\n                    if self_.is_bucket_full(i) {\n                        self_.bucket(i).drop();\n                    }\n                }\n            }\n        });\n\n        for from in source.iter() {\n            let index = source.bucket_index(&from);\n            let to = guard.1.bucket(index);\n            to.write(from.as_ref().clone());\n\n            // Update the index in case we need to unwind.\n            guard.0 = index + 1;\n        }\n\n        // Successfully cloned all items, no need to clean up.\n        mem::forget(guard);\n\n        self.table.items = source.table.items;\n        self.table.growth_left = source.table.growth_left;\n    }\n}', 'impl<T: Clone, A: Allocator + Clone> RawTableClone for RawTable<T, A> {\n    default_fn! {\n        #[cfg_attr(feature = "inline-more", inline)]\n        unsafe fn clone_from_spec(&mut self, source: &Self) {\n            self.clone_from_impl(source);\n        }\n    }\n}', 'impl<T> RawTable<T, Global> {\n    /// Creates a new empty hash table without allocating any memory.\n    ///\n    /// In effect this returns a table with exactly 1 bucket. However we can\n    /// leave the data pointer dangling since that bucket is never written to\n    /// due to our load factor forcing us to always have at least 1 free bucket.\n    #[inline]\n    #[cfg_attr(feature = "rustc-dep-of-std", rustc_const_stable_indirect)]\n    pub const fn new() -> Self {\n        Self {\n            table: RawTableInner::NEW,\n            alloc: Global,\n            marker: PhantomData,\n        }\n    }\n\n    /// Allocates a new hash table with at least enough capacity for inserting\n    /// the given number of elements without reallocating.\n    pub fn with_capacity(capacity: usize) -> Self {\n        Self::with_capacity_in(capacity, Global)\n    }\n}', 'unsafe impl<T, A: Allocator> Send for RawTable<T, A>\nwhere\n    T: Send,\n    A: Send,\n{\n}', 'unsafe impl<T, A: Allocator> Sync for RawTable<T, A>\nwhere\n    T: Sync,\n    A: Sync,\n{\n}'], 'raw::RawTableInner': ['impl RawTableInner {\n    /// Allocates a new [`RawTableInner`] with the given number of buckets.\n    /// The control bytes and buckets are left uninitialized.\n    ///\n    /// # Safety\n    ///\n    /// The caller of this function must ensure that the `buckets` is power of two\n    /// and also initialize all control bytes of the length `self.bucket_mask + 1 +\n    /// Group::WIDTH` with the [`Tag::EMPTY`] bytes.\n    ///\n    /// See also [`Allocator`] API for other safety concerns.\n    ///\n    /// [`Allocator`]: https://doc.rust-lang.org/alloc/alloc/trait.Allocator.html\n    #[cfg_attr(feature = "inline-more", inline)]\n    unsafe fn new_uninitialized<A>(\n        alloc: &A,\n        table_layout: TableLayout,\n        buckets: usize,\n        fallibility: Fallibility,\n    ) -> Result<Self, TryReserveError>\n    where\n        A: Allocator,\n    {\n        debug_assert!(buckets.is_power_of_two());\n\n        // Avoid `Option::ok_or_else` because it bloats LLVM IR.\n        let (layout, ctrl_offset) = match table_layout.calculate_layout_for(buckets) {\n            Some(lco) => lco,\n            None => return Err(fallibility.capacity_overflow()),\n        };\n\n        let ptr: NonNull<u8> = match do_alloc(alloc, layout) {\n            Ok(block) => block.cast(),\n            Err(_) => return Err(fallibility.alloc_err(layout)),\n        };\n\n        // SAFETY: null pointer will be caught in above check\n        let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));\n        Ok(Self {\n            ctrl,\n            bucket_mask: buckets - 1,\n            items: 0,\n            growth_left: bucket_mask_to_capacity(buckets - 1),\n        })\n    }\n\n    /// Attempts to allocate a new [`RawTableInner`] with at least enough\n    /// capacity for inserting the given number of elements without reallocating.\n    ///\n    /// All the control bytes are initialized with the [`Tag::EMPTY`] bytes.\n    #[inline]\n    fn fallible_with_capacity<A>(\n        alloc: &A,\n        table_layout: TableLayout,\n        capacity: usize,\n        fallibility: Fallibility,\n    ) -> Result<Self, TryReserveError>\n    where\n        A: Allocator,\n    {\n        if capacity == 0 {\n            Ok(Self::NEW)\n        } else {\n            // SAFETY: We checked that we could successfully allocate the new table, and then\n            // initialized all control bytes with the constant `Tag::EMPTY` byte.\n            unsafe {\n                let buckets = capacity_to_buckets(capacity, table_layout)\n                    .ok_or_else(|| fallibility.capacity_overflow())?;\n\n                let mut result =\n                    Self::new_uninitialized(alloc, table_layout, buckets, fallibility)?;\n                // SAFETY: We checked that the table is allocated and therefore the table already has\n                // `self.bucket_mask + 1 + Group::WIDTH` number of control bytes (see TableLayout::calculate_layout_for)\n                // so writing `self.num_ctrl_bytes() == bucket_mask + 1 + Group::WIDTH` bytes is safe.\n                result.ctrl_slice().fill_empty();\n\n                Ok(result)\n            }\n        }\n    }\n\n    /// Allocates a new [`RawTableInner`] with at least enough capacity for inserting\n    /// the given number of elements without reallocating.\n    ///\n    /// Panics if the new capacity exceeds [`isize::MAX`] bytes and [`abort`] the program\n    /// in case of allocation error. Use [`fallible_with_capacity`] instead if you want to\n    /// handle memory allocation failure.\n    ///\n    /// All the control bytes are initialized with the [`Tag::EMPTY`] bytes.\n    ///\n    /// [`fallible_with_capacity`]: RawTableInner::fallible_with_capacity\n    /// [`abort`]: https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html\n    fn with_capacity<A>(alloc: &A, table_layout: TableLayout, capacity: usize) -> Self\n    where\n        A: Allocator,\n    {\n        // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.\n        match Self::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible) {\n            Ok(table_inner) => table_inner,\n            // SAFETY: All allocation errors will be caught inside `RawTableInner::new_uninitialized`.\n            Err(_) => unsafe { hint::unreachable_unchecked() },\n        }\n    }\n\n    /// Fixes up an insertion slot returned by the [`RawTableInner::find_insert_slot_in_group`] method.\n    ///\n    /// In tables smaller than the group width (`self.buckets() < Group::WIDTH`), trailing control\n    /// bytes outside the range of the table are filled with [`Tag::EMPTY`] entries. These will unfortunately\n    /// trigger a match of [`RawTableInner::find_insert_slot_in_group`] function. This is because\n    /// the `Some(bit)` returned by `group.match_empty_or_deleted().lowest_set_bit()` after masking\n    /// (`(probe_seq.pos + bit) & self.bucket_mask`) may point to a full bucket that is already occupied.\n    /// We detect this situation here and perform a second scan starting at the beginning of the table.\n    /// This second scan is guaranteed to find an empty slot (due to the load factor) before hitting the\n    /// trailing control bytes (containing [`Tag::EMPTY`] bytes).\n    ///\n    /// If this function is called correctly, it is guaranteed to return [`InsertSlot`] with an\n    /// index of an empty or deleted bucket in the range `0..self.buckets()` (see `Warning` and\n    /// `Safety`).\n    ///\n    /// # Warning\n    ///\n    /// The table must have at least 1 empty or deleted `bucket`, otherwise if the table is less than\n    /// the group width (`self.buckets() < Group::WIDTH`) this function returns an index outside of the\n    /// table indices range `0..self.buckets()` (`0..=self.bucket_mask`). Attempt to write data at that\n    /// index will cause immediate [`undefined behavior`].\n    ///\n    /// # Safety\n    ///\n    /// The safety rules are directly derived from the safety rules for [`RawTableInner::ctrl`] method.\n    /// Thus, in order to uphold those safety contracts, as well as for the correct logic of the work\n    /// of this crate, the following rules are necessary and sufficient:\n    ///\n    /// * The [`RawTableInner`] must have properly initialized control bytes otherwise calling this\n    ///   function results in [`undefined behavior`].\n    ///\n    /// * This function must only be used on insertion slots found by [`RawTableInner::find_insert_slot_in_group`]\n    ///   (after the `find_insert_slot_in_group` function, but before insertion into the table).\n    ///\n    /// * The `index` must not be greater than the `self.bucket_mask`, i.e. `(index + 1) <= self.buckets()`\n    ///   (this one is provided by the [`RawTableInner::find_insert_slot_in_group`] function).\n    ///\n    /// Calling this function with an index not provided by [`RawTableInner::find_insert_slot_in_group`]\n    /// may result in [`undefined behavior`] even if the index satisfies the safety rules of the\n    /// [`RawTableInner::ctrl`] function (`index < self.bucket_mask + 1 + Group::WIDTH`).\n    ///\n    /// [`RawTableInner::ctrl`]: RawTableInner::ctrl\n    /// [`RawTableInner::find_insert_slot_in_group`]: RawTableInner::find_insert_slot_in_group\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn fix_insert_slot(&self, mut index: usize) -> InsertSlot {\n        // SAFETY: The caller of this function ensures that `index` is in the range `0..=self.bucket_mask`.\n        if unlikely(self.is_bucket_full(index)) {\n            debug_assert!(self.bucket_mask < Group::WIDTH);\n            // SAFETY:\n            //\n            // * Since the caller of this function ensures that the control bytes are properly\n            //   initialized and `ptr = self.ctrl(0)` points to the start of the array of control\n            //   bytes, therefore: `ctrl` is valid for reads, properly aligned to `Group::WIDTH`\n            //   and points to the properly initialized control bytes (see also\n            //   `TableLayout::calculate_layout_for` and `ptr::read`);\n            //\n            // * Because the caller of this function ensures that the index was provided by the\n            //   `self.find_insert_slot_in_group()` function, so for for tables larger than the\n            //   group width (self.buckets() >= Group::WIDTH), we will never end up in the given\n            //   branch, since `(probe_seq.pos + bit) & self.bucket_mask` in `find_insert_slot_in_group`\n            //   cannot return a full bucket index. For tables smaller than the group width, calling\n            //   the `unwrap_unchecked` function is also safe, as the trailing control bytes outside\n            //   the range of the table are filled with EMPTY bytes (and we know for sure that there\n            //   is at least one FULL bucket), so this second scan either finds an empty slot (due to\n            //   the load factor) or hits the trailing control bytes (containing EMPTY).\n            index = Group::load_aligned(self.ctrl(0))\n                .match_empty_or_deleted()\n                .lowest_set_bit()\n                .unwrap_unchecked();\n        }\n        InsertSlot { index }\n    }\n\n    /// Finds the position to insert something in a group.\n    ///\n    /// **This may have false positives and must be fixed up with `fix_insert_slot`\n    /// before it\'s used.**\n    ///\n    /// The function is guaranteed to return the index of an empty or deleted [`Bucket`]\n    /// in the range `0..self.buckets()` (`0..=self.bucket_mask`).\n    #[inline]\n    fn find_insert_slot_in_group(&self, group: &Group, probe_seq: &ProbeSeq) -> Option<usize> {\n        let bit = group.match_empty_or_deleted().lowest_set_bit();\n\n        if likely(bit.is_some()) {\n            // This is the same as `(probe_seq.pos + bit) % self.buckets()` because the number\n            // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n            Some((probe_seq.pos + bit.unwrap()) & self.bucket_mask)\n        } else {\n            None\n        }\n    }\n\n    /// Searches for an element in the table, or a potential slot where that element could\n    /// be inserted (an empty or deleted [`Bucket`] index).\n    ///\n    /// This uses dynamic dispatch to reduce the amount of code generated, but that is\n    /// eliminated by LLVM optimizations.\n    ///\n    /// This function does not make any changes to the `data` part of the table, or any\n    /// changes to the `items` or `growth_left` field of the table.\n    ///\n    /// The table must have at least 1 empty or deleted `bucket`, otherwise, if the\n    /// `eq: &mut dyn FnMut(usize) -> bool` function does not return `true`, this function\n    /// will never return (will go into an infinite loop) for tables larger than the group\n    /// width, or return an index outside of the table indices range if the table is less\n    /// than the group width.\n    ///\n    /// This function is guaranteed to provide the `eq: &mut dyn FnMut(usize) -> bool`\n    /// function with only `FULL` buckets\' indices and return the `index` of the found\n    /// element (as `Ok(index)`). If the element is not found and there is at least 1\n    /// empty or deleted [`Bucket`] in the table, the function is guaranteed to return\n    /// [`InsertSlot`] with an index in the range `0..self.buckets()`, but in any case,\n    /// if this function returns [`InsertSlot`], it will contain an index in the range\n    /// `0..=self.buckets()`.\n    ///\n    /// # Safety\n    ///\n    /// The [`RawTableInner`] must have properly initialized control bytes otherwise calling\n    /// this function results in [`undefined behavior`].\n    ///\n    /// Attempt to write data at the [`InsertSlot`] returned by this function when the table is\n    /// less than the group width and if there was not at least one empty or deleted bucket in\n    /// the table will cause immediate [`undefined behavior`]. This is because in this case the\n    /// function will return `self.bucket_mask + 1` as an index due to the trailing [`Tag::EMPTY`]\n    /// control bytes outside the table range.\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn find_or_find_insert_slot_inner(\n        &self,\n        hash: u64,\n        eq: &mut dyn FnMut(usize) -> bool,\n    ) -> Result<usize, InsertSlot> {\n        let mut insert_slot = None;\n\n        let tag_hash = Tag::full(hash);\n        let mut probe_seq = self.probe_seq(hash);\n\n        loop {\n            // SAFETY:\n            // * Caller of this function ensures that the control bytes are properly initialized.\n            //\n            // * `ProbeSeq.pos` cannot be greater than `self.bucket_mask = self.buckets() - 1`\n            //   of the table due to masking with `self.bucket_mask` and also because the number\n            //   of buckets is a power of two (see `self.probe_seq` function).\n            //\n            // * Even if `ProbeSeq.pos` returns `position == self.bucket_mask`, it is safe to\n            //   call `Group::load` due to the extended control bytes range, which is\n            //  `self.bucket_mask + 1 + Group::WIDTH` (in fact, this means that the last control\n            //   byte will never be read for the allocated table);\n            //\n            // * Also, even if `RawTableInner` is not already allocated, `ProbeSeq.pos` will\n            //   always return "0" (zero), so Group::load will read unaligned `Group::static_empty()`\n            //   bytes, which is safe (see RawTableInner::new).\n            let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };\n\n            for bit in group.match_tag(tag_hash) {\n                let index = (probe_seq.pos + bit) & self.bucket_mask;\n\n                if likely(eq(index)) {\n                    return Ok(index);\n                }\n            }\n\n            // We didn\'t find the element we were looking for in the group, try to get an\n            // insertion slot from the group if we don\'t have one yet.\n            if likely(insert_slot.is_none()) {\n                insert_slot = self.find_insert_slot_in_group(&group, &probe_seq);\n            }\n\n            if let Some(insert_slot) = insert_slot {\n                // Only stop the search if the group contains at least one empty element.\n                // Otherwise, the element that we are looking for might be in a following group.\n                if likely(group.match_empty().any_bit_set()) {\n                    // We must have found a insert slot by now, since the current group contains at\n                    // least one. For tables smaller than the group width, there will still be an\n                    // empty element in the current (and only) group due to the load factor.\n                    unsafe {\n                        // SAFETY:\n                        // * Caller of this function ensures that the control bytes are properly initialized.\n                        //\n                        // * We use this function with the slot / index found by `self.find_insert_slot_in_group`\n                        return Err(self.fix_insert_slot(insert_slot));\n                    }\n                }\n            }\n\n            probe_seq.move_next(self.bucket_mask);\n        }\n    }\n\n    /// Searches for an empty or deleted bucket which is suitable for inserting a new\n    /// element and sets the hash for that slot. Returns an index of that slot and the\n    /// old control byte stored in the found index.\n    ///\n    /// This function does not check if the given element exists in the table. Also,\n    /// this function does not check if there is enough space in the table to insert\n    /// a new element. The caller of the function must make sure that the table has at\n    /// least 1 empty or deleted `bucket`, otherwise this function will never return\n    /// (will go into an infinite loop) for tables larger than the group width, or\n    /// return an index outside of the table indices range if the table is less than\n    /// the group width.\n    ///\n    /// If there is at least 1 empty or deleted `bucket` in the table, the function is\n    /// guaranteed to return an `index` in the range `0..self.buckets()`, but in any case,\n    /// if this function returns an `index` it will be in the range `0..=self.buckets()`.\n    ///\n    /// This function does not make any changes to the `data` parts of the table,\n    /// or any changes to the `items` or `growth_left` field of the table.\n    ///\n    /// # Safety\n    ///\n    /// The safety rules are directly derived from the safety rules for the\n    /// [`RawTableInner::set_ctrl_hash`] and [`RawTableInner::find_insert_slot`] methods.\n    /// Thus, in order to uphold the safety contracts for that methods, as well as for\n    /// the correct logic of the work of this crate, you must observe the following rules\n    /// when calling this function:\n    ///\n    /// * The [`RawTableInner`] has already been allocated and has properly initialized\n    ///   control bytes otherwise calling this function results in [`undefined behavior`].\n    ///\n    /// * The caller of this function must ensure that the "data" parts of the table\n    ///   will have an entry in the returned index (matching the given hash) right\n    ///   after calling this function.\n    ///\n    /// Attempt to write data at the `index` returned by this function when the table is\n    /// less than the group width and if there was not at least one empty or deleted bucket in\n    /// the table will cause immediate [`undefined behavior`]. This is because in this case the\n    /// function will return `self.bucket_mask + 1` as an index due to the trailing [`Tag::EMPTY`]\n    /// control bytes outside the table range.\n    ///\n    /// The caller must independently increase the `items` field of the table, and also,\n    /// if the old control byte was [`Tag::EMPTY`], then decrease the table\'s `growth_left`\n    /// field, and do not change it if the old control byte was [`Tag::DELETED`].\n    ///\n    /// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n    /// or saving `element` from / into the [`RawTable`] / [`RawTableInner`].\n    ///\n    /// [`Bucket::as_ptr`]: Bucket::as_ptr\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    /// [`RawTableInner::ctrl`]: RawTableInner::ctrl\n    /// [`RawTableInner::set_ctrl_hash`]: RawTableInner::set_ctrl_hash\n    /// [`RawTableInner::find_insert_slot`]: RawTableInner::find_insert_slot\n    #[inline]\n    unsafe fn prepare_insert_slot(&mut self, hash: u64) -> (usize, Tag) {\n        // SAFETY: Caller of this function ensures that the control bytes are properly initialized.\n        let index: usize = self.find_insert_slot(hash).index;\n        // SAFETY:\n        // 1. The `find_insert_slot` function either returns an `index` less than or\n        //    equal to `self.buckets() = self.bucket_mask + 1` of the table, or never\n        //    returns if it cannot find an empty or deleted slot.\n        // 2. The caller of this function guarantees that the table has already been\n        //    allocated\n        let old_ctrl = *self.ctrl(index);\n        self.set_ctrl_hash(index, hash);\n        (index, old_ctrl)\n    }\n\n    /// Searches for an empty or deleted bucket which is suitable for inserting\n    /// a new element, returning the `index` for the new [`Bucket`].\n    ///\n    /// This function does not make any changes to the `data` part of the table, or any\n    /// changes to the `items` or `growth_left` field of the table.\n    ///\n    /// The table must have at least 1 empty or deleted `bucket`, otherwise this function\n    /// will never return (will go into an infinite loop) for tables larger than the group\n    /// width, or return an index outside of the table indices range if the table is less\n    /// than the group width.\n    ///\n    /// If there is at least 1 empty or deleted `bucket` in the table, the function is\n    /// guaranteed to return [`InsertSlot`] with an index in the range `0..self.buckets()`,\n    /// but in any case, if this function returns [`InsertSlot`], it will contain an index\n    /// in the range `0..=self.buckets()`.\n    ///\n    /// # Safety\n    ///\n    /// The [`RawTableInner`] must have properly initialized control bytes otherwise calling\n    /// this function results in [`undefined behavior`].\n    ///\n    /// Attempt to write data at the [`InsertSlot`] returned by this function when the table is\n    /// less than the group width and if there was not at least one empty or deleted bucket in\n    /// the table will cause immediate [`undefined behavior`]. This is because in this case the\n    /// function will return `self.bucket_mask + 1` as an index due to the trailing [`Tag::EMPTY`]\n    /// control bytes outside the table range.\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn find_insert_slot(&self, hash: u64) -> InsertSlot {\n        let mut probe_seq = self.probe_seq(hash);\n        loop {\n            // SAFETY:\n            // * Caller of this function ensures that the control bytes are properly initialized.\n            //\n            // * `ProbeSeq.pos` cannot be greater than `self.bucket_mask = self.buckets() - 1`\n            //   of the table due to masking with `self.bucket_mask` and also because the number\n            //   of buckets is a power of two (see `self.probe_seq` function).\n            //\n            // * Even if `ProbeSeq.pos` returns `position == self.bucket_mask`, it is safe to\n            //   call `Group::load` due to the extended control bytes range, which is\n            //  `self.bucket_mask + 1 + Group::WIDTH` (in fact, this means that the last control\n            //   byte will never be read for the allocated table);\n            //\n            // * Also, even if `RawTableInner` is not already allocated, `ProbeSeq.pos` will\n            //   always return "0" (zero), so Group::load will read unaligned `Group::static_empty()`\n            //   bytes, which is safe (see RawTableInner::new).\n            let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };\n\n            let index = self.find_insert_slot_in_group(&group, &probe_seq);\n            if likely(index.is_some()) {\n                // SAFETY:\n                // * Caller of this function ensures that the control bytes are properly initialized.\n                //\n                // * We use this function with the slot / index found by `self.find_insert_slot_in_group`\n                unsafe {\n                    return self.fix_insert_slot(index.unwrap_unchecked());\n                }\n            }\n            probe_seq.move_next(self.bucket_mask);\n        }\n    }\n\n    /// Searches for an element in a table, returning the `index` of the found element.\n    /// This uses dynamic dispatch to reduce the amount of code generated, but it is\n    /// eliminated by LLVM optimizations.\n    ///\n    /// This function does not make any changes to the `data` part of the table, or any\n    /// changes to the `items` or `growth_left` field of the table.\n    ///\n    /// The table must have at least 1 empty `bucket`, otherwise, if the\n    /// `eq: &mut dyn FnMut(usize) -> bool` function does not return `true`,\n    /// this function will also never return (will go into an infinite loop).\n    ///\n    /// This function is guaranteed to provide the `eq: &mut dyn FnMut(usize) -> bool`\n    /// function with only `FULL` buckets\' indices and return the `index` of the found\n    /// element as `Some(index)`, so the index will always be in the range\n    /// `0..self.buckets()`.\n    ///\n    /// # Safety\n    ///\n    /// The [`RawTableInner`] must have properly initialized control bytes otherwise calling\n    /// this function results in [`undefined behavior`].\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline(always)]\n    unsafe fn find_inner(&self, hash: u64, eq: &mut dyn FnMut(usize) -> bool) -> Option<usize> {\n        let tag_hash = Tag::full(hash);\n        let mut probe_seq = self.probe_seq(hash);\n\n        loop {\n            // SAFETY:\n            // * Caller of this function ensures that the control bytes are properly initialized.\n            //\n            // * `ProbeSeq.pos` cannot be greater than `self.bucket_mask = self.buckets() - 1`\n            //   of the table due to masking with `self.bucket_mask`.\n            //\n            // * Even if `ProbeSeq.pos` returns `position == self.bucket_mask`, it is safe to\n            //   call `Group::load` due to the extended control bytes range, which is\n            //  `self.bucket_mask + 1 + Group::WIDTH` (in fact, this means that the last control\n            //   byte will never be read for the allocated table);\n            //\n            // * Also, even if `RawTableInner` is not already allocated, `ProbeSeq.pos` will\n            //   always return "0" (zero), so Group::load will read unaligned `Group::static_empty()`\n            //   bytes, which is safe (see RawTableInner::new_in).\n            let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };\n\n            for bit in group.match_tag(tag_hash) {\n                // This is the same as `(probe_seq.pos + bit) % self.buckets()` because the number\n                // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n                let index = (probe_seq.pos + bit) & self.bucket_mask;\n\n                if likely(eq(index)) {\n                    return Some(index);\n                }\n            }\n\n            if likely(group.match_empty().any_bit_set()) {\n                return None;\n            }\n\n            probe_seq.move_next(self.bucket_mask);\n        }\n    }\n\n    /// Prepares for rehashing data in place (that is, without allocating new memory).\n    /// Converts all full index `control bytes` to `Tag::DELETED` and all `Tag::DELETED` control\n    /// bytes to `Tag::EMPTY`, i.e. performs the following conversion:\n    ///\n    /// - `Tag::EMPTY` control bytes   -> `Tag::EMPTY`;\n    /// - `Tag::DELETED` control bytes -> `Tag::EMPTY`;\n    /// - `FULL` control bytes    -> `Tag::DELETED`.\n    ///\n    /// This function does not make any changes to the `data` parts of the table,\n    /// or any changes to the `items` or `growth_left` field of the table.\n    ///\n    /// # Safety\n    ///\n    /// You must observe the following safety rules when calling this function:\n    ///\n    /// * The [`RawTableInner`] has already been allocated;\n    ///\n    /// * The caller of this function must convert the `Tag::DELETED` bytes back to `FULL`\n    ///   bytes when re-inserting them into their ideal position (which was impossible\n    ///   to do during the first insert due to tombstones). If the caller does not do\n    ///   this, then calling this function may result in a memory leak.\n    ///\n    /// * The [`RawTableInner`] must have properly initialized control bytes otherwise\n    ///   calling this function results in [`undefined behavior`].\n    ///\n    /// Calling this function on a table that has not been allocated results in\n    /// [`undefined behavior`].\n    ///\n    /// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n    /// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n    ///\n    /// [`Bucket::as_ptr`]: Bucket::as_ptr\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[allow(clippy::mut_mut)]\n    #[inline]\n    unsafe fn prepare_rehash_in_place(&mut self) {\n        // Bulk convert all full control bytes to DELETED, and all DELETED control bytes to EMPTY.\n        // This effectively frees up all buckets containing a DELETED entry.\n        //\n        // SAFETY:\n        // 1. `i` is guaranteed to be within bounds since we are iterating from zero to `buckets - 1`;\n        // 2. Even if `i` will be `i == self.bucket_mask`, it is safe to call `Group::load_aligned`\n        //    due to the extended control bytes range, which is `self.bucket_mask + 1 + Group::WIDTH`;\n        // 3. The caller of this function guarantees that [`RawTableInner`] has already been allocated;\n        // 4. We can use `Group::load_aligned` and `Group::store_aligned` here since we start from 0\n        //    and go to the end with a step equal to `Group::WIDTH` (see TableLayout::calculate_layout_for).\n        for i in (0..self.buckets()).step_by(Group::WIDTH) {\n            let group = Group::load_aligned(self.ctrl(i));\n            let group = group.convert_special_to_empty_and_full_to_deleted();\n            group.store_aligned(self.ctrl(i));\n        }\n\n        // Fix up the trailing control bytes. See the comments in set_ctrl\n        // for the handling of tables smaller than the group width.\n        //\n        // SAFETY: The caller of this function guarantees that [`RawTableInner`]\n        // has already been allocated\n        if unlikely(self.buckets() < Group::WIDTH) {\n            // SAFETY: We have `self.bucket_mask + 1 + Group::WIDTH` number of control bytes,\n            // so copying `self.buckets() == self.bucket_mask + 1` bytes with offset equal to\n            // `Group::WIDTH` is safe\n            self.ctrl(0)\n                .copy_to(self.ctrl(Group::WIDTH), self.buckets());\n        } else {\n            // SAFETY: We have `self.bucket_mask + 1 + Group::WIDTH` number of\n            // control bytes,so copying `Group::WIDTH` bytes with offset equal\n            // to `self.buckets() == self.bucket_mask + 1` is safe\n            self.ctrl(0)\n                .copy_to(self.ctrl(self.buckets()), Group::WIDTH);\n        }\n    }\n\n    /// Returns an iterator over every element in the table.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result\n    /// is [`undefined behavior`]:\n    ///\n    /// * The caller has to ensure that the `RawTableInner` outlives the\n    ///   `RawIter`. Because we cannot make the `next` method unsafe on\n    ///   the `RawIter` struct, we have to make the `iter` method unsafe.\n    ///\n    /// * The [`RawTableInner`] must have properly initialized control bytes.\n    ///\n    /// The type `T` must be the actual type of the elements stored in the table,\n    /// otherwise using the returned [`RawIter`] results in [`undefined behavior`].\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn iter<T>(&self) -> RawIter<T> {\n        // SAFETY:\n        // 1. Since the caller of this function ensures that the control bytes\n        //    are properly initialized and `self.data_end()` points to the start\n        //    of the array of control bytes, therefore: `ctrl` is valid for reads,\n        //    properly aligned to `Group::WIDTH` and points to the properly initialized\n        //    control bytes.\n        // 2. `data` bucket index in the table is equal to the `ctrl` index (i.e.\n        //    equal to zero).\n        // 3. We pass the exact value of buckets of the table to the function.\n        //\n        //                         `ctrl` points here (to the start\n        //                         of the first control byte `CT0`)\n        //                          \n        // [Pad], T_n, ..., T1, T0, |CT0, CT1, ..., CT_n|, CTa_0, CTa_1, ..., CTa_m\n        //                           \\________  ________/\n        //                                    \\/\n        //       `n = buckets - 1`, i.e. `RawTableInner::buckets() - 1`\n        //\n        // where: T0...T_n  - our stored data;\n        //        CT0...CT_n - control bytes or metadata for `data`.\n        //        CTa_0...CTa_m - additional control bytes, where `m = Group::WIDTH - 1` (so that the search\n        //                        with loading `Group` bytes from the heap works properly, even if the result\n        //                        of `h1(hash) & self.bucket_mask` is equal to `self.bucket_mask`). See also\n        //                        `RawTableInner::set_ctrl` function.\n        //\n        // P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n        // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n        let data = Bucket::from_base_index(self.data_end(), 0);\n        RawIter {\n            // SAFETY: See explanation above\n            iter: RawIterRange::new(self.ctrl.as_ptr(), data, self.buckets()),\n            items: self.items,\n        }\n    }\n\n    /// Executes the destructors (if any) of the values stored in the table.\n    ///\n    /// # Note\n    ///\n    /// This function does not erase the control bytes of the table and does\n    /// not make any changes to the `items` or `growth_left` fields of the\n    /// table. If necessary, the caller of this function must manually set\n    /// up these table fields, for example using the [`clear_no_drop`] function.\n    ///\n    /// Be careful during calling this function, because drop function of\n    /// the elements can panic, and this can leave table in an inconsistent\n    /// state.\n    ///\n    /// # Safety\n    ///\n    /// The type `T` must be the actual type of the elements stored in the table,\n    /// otherwise calling this function may result in [`undefined behavior`].\n    ///\n    /// If `T` is a type that should be dropped and **the table is not empty**,\n    /// calling this function more than once results in [`undefined behavior`].\n    ///\n    /// If `T` is not [`Copy`], attempting to use values stored in the table after\n    /// calling this function may result in [`undefined behavior`].\n    ///\n    /// It is safe to call this function on a table that has not been allocated,\n    /// on a table with uninitialized control bytes, and on a table with no actual\n    /// data but with `Full` control bytes if `self.items == 0`.\n    ///\n    /// See also [`Bucket::drop`] / [`Bucket::as_ptr`] methods, for more information\n    /// about of properly removing or saving `element` from / into the [`RawTable`] /\n    /// [`RawTableInner`].\n    ///\n    /// [`Bucket::drop`]: Bucket::drop\n    /// [`Bucket::as_ptr`]: Bucket::as_ptr\n    /// [`clear_no_drop`]: RawTableInner::clear_no_drop\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    unsafe fn drop_elements<T>(&mut self) {\n        // Check that `self.items != 0`. Protects against the possibility\n        // of creating an iterator on an table with uninitialized control bytes.\n        if T::NEEDS_DROP && self.items != 0 {\n            // SAFETY: We know for sure that RawTableInner will outlive the\n            // returned `RawIter` iterator, and the caller of this function\n            // must uphold the safety contract for `drop_elements` method.\n            for item in self.iter::<T>() {\n                // SAFETY: The caller must uphold the safety contract for\n                // `drop_elements` method.\n                item.drop();\n            }\n        }\n    }\n\n    /// Executes the destructors (if any) of the values stored in the table and than\n    /// deallocates the table.\n    ///\n    /// # Note\n    ///\n    /// Calling this function automatically makes invalid (dangling) all instances of\n    /// buckets ([`Bucket`]) and makes invalid (dangling) the `ctrl` field of the table.\n    ///\n    /// This function does not make any changes to the `bucket_mask`, `items` or `growth_left`\n    /// fields of the table. If necessary, the caller of this function must manually set\n    /// up these table fields.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is [`undefined behavior`]:\n    ///\n    /// * Calling this function more than once;\n    ///\n    /// * The type `T` must be the actual type of the elements stored in the table.\n    ///\n    /// * The `alloc` must be the same [`Allocator`] as the `Allocator` that was used\n    ///   to allocate this table.\n    ///\n    /// * The `table_layout` must be the same [`TableLayout`] as the `TableLayout` that\n    ///   was used to allocate this table.\n    ///\n    /// The caller of this function should pay attention to the possibility of the\n    /// elements\' drop function panicking, because this:\n    ///\n    ///    * May leave the table in an inconsistent state;\n    ///\n    ///    * Memory is never deallocated, so a memory leak may occur.\n    ///\n    /// Attempt to use the `ctrl` field of the table (dereference) after calling this\n    /// function results in [`undefined behavior`].\n    ///\n    /// It is safe to call this function on a table that has not been allocated,\n    /// on a table with uninitialized control bytes, and on a table with no actual\n    /// data but with `Full` control bytes if `self.items == 0`.\n    ///\n    /// See also [`RawTableInner::drop_elements`] or [`RawTableInner::free_buckets`]\n    /// for more  information.\n    ///\n    /// [`RawTableInner::drop_elements`]: RawTableInner::drop_elements\n    /// [`RawTableInner::free_buckets`]: RawTableInner::free_buckets\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    unsafe fn drop_inner_table<T, A: Allocator>(&mut self, alloc: &A, table_layout: TableLayout) {\n        if !self.is_empty_singleton() {\n            unsafe {\n                // SAFETY: The caller must uphold the safety contract for `drop_inner_table` method.\n                self.drop_elements::<T>();\n                // SAFETY:\n                // 1. We have checked that our table is allocated.\n                // 2. The caller must uphold the safety contract for `drop_inner_table` method.\n                self.free_buckets(alloc, table_layout);\n            }\n        }\n    }\n\n    /// Returns a pointer to an element in the table (convenience for\n    /// `Bucket::from_base_index(self.data_end::<T>(), index)`).\n    ///\n    /// The caller must ensure that the `RawTableInner` outlives the returned [`Bucket<T>`],\n    /// otherwise using it may result in [`undefined behavior`].\n    ///\n    /// # Safety\n    ///\n    /// If `mem::size_of::<T>() != 0`, then the safety rules are directly derived from the\n    /// safety rules of the [`Bucket::from_base_index`] function. Therefore, when calling\n    /// this function, the following safety rules must be observed:\n    ///\n    /// * The table must already be allocated;\n    ///\n    /// * The `index` must not be greater than the number returned by the [`RawTableInner::buckets`]\n    ///   function, i.e. `(index + 1) <= self.buckets()`.\n    ///\n    /// * The type `T` must be the actual type of the elements stored in the table, otherwise\n    ///   using the returned [`Bucket`] may result in [`undefined behavior`].\n    ///\n    /// It is safe to call this function with index of zero (`index == 0`) on a table that has\n    /// not been allocated, but using the returned [`Bucket`] results in [`undefined behavior`].\n    ///\n    /// If `mem::size_of::<T>() == 0`, then the only requirement is that the `index` must\n    /// not be greater than the number returned by the [`RawTable::buckets`] function, i.e.\n    /// `(index + 1) <= self.buckets()`.\n    ///\n    /// ```none\n    /// If mem::size_of::<T>() != 0 then return a pointer to the `element` in the `data part` of the table\n    /// (we start counting from "0", so that in the expression T[n], the "n" index actually one less than\n    /// the "buckets" number of our `RawTableInner`, i.e. "n = RawTableInner::buckets() - 1"):\n    ///\n    ///           `table.bucket(3).as_ptr()` returns a pointer that points here in the `data`\n    ///           part of the `RawTableInner`, i.e. to the start of T3 (see [`Bucket::as_ptr`])\n    ///                  |\n    ///                  |               `base = table.data_end::<T>()` points here\n    ///                  |               (to the start of CT0 or to the end of T0)\n    ///                  v                 v\n    /// [Pad], T_n, ..., |T3|, T2, T1, T0, |CT0, CT1, CT2, CT3, ..., CT_n, CTa_0, CTa_1, ..., CTa_m\n    ///                     ^                                              \\__________  __________/\n    ///        `table.bucket(3)` returns a pointer that points                        \\/\n    ///         here in the `data` part of the `RawTableInner`             additional control bytes\n    ///         (to the end of T3)                                          `m = Group::WIDTH - 1`\n    ///\n    /// where: T0...T_n  - our stored data;\n    ///        CT0...CT_n - control bytes or metadata for `data`;\n    ///        CTa_0...CTa_m - additional control bytes (so that the search with loading `Group` bytes from\n    ///                        the heap works properly, even if the result of `h1(hash) & self.bucket_mask`\n    ///                        is equal to `self.bucket_mask`). See also `RawTableInner::set_ctrl` function.\n    ///\n    /// P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n    /// of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n    /// ```\n    ///\n    /// [`Bucket::from_base_index`]: Bucket::from_base_index\n    /// [`RawTableInner::buckets`]: RawTableInner::buckets\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn bucket<T>(&self, index: usize) -> Bucket<T> {\n        debug_assert_ne!(self.bucket_mask, 0);\n        debug_assert!(index < self.buckets());\n        Bucket::from_base_index(self.data_end(), index)\n    }\n\n    /// Returns a raw `*mut u8` pointer to the start of the `data` element in the table\n    /// (convenience for `self.data_end::<u8>().as_ptr().sub((index + 1) * size_of)`).\n    ///\n    /// The caller must ensure that the `RawTableInner` outlives the returned `*mut u8`,\n    /// otherwise using it may result in [`undefined behavior`].\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is [`undefined behavior`]:\n    ///\n    /// * The table must already be allocated;\n    ///\n    /// * The `index` must not be greater than the number returned by the [`RawTableInner::buckets`]\n    ///   function, i.e. `(index + 1) <= self.buckets()`;\n    ///\n    /// * The `size_of` must be equal to the size of the elements stored in the table;\n    ///\n    /// ```none\n    /// If mem::size_of::<T>() != 0 then return a pointer to the `element` in the `data part` of the table\n    /// (we start counting from "0", so that in the expression T[n], the "n" index actually one less than\n    /// the "buckets" number of our `RawTableInner`, i.e. "n = RawTableInner::buckets() - 1"):\n    ///\n    ///           `table.bucket_ptr(3, mem::size_of::<T>())` returns a pointer that points here in the\n    ///           `data` part of the `RawTableInner`, i.e. to the start of T3\n    ///                  |\n    ///                  |               `base = table.data_end::<u8>()` points here\n    ///                  |               (to the start of CT0 or to the end of T0)\n    ///                  v                 v\n    /// [Pad], T_n, ..., |T3|, T2, T1, T0, |CT0, CT1, CT2, CT3, ..., CT_n, CTa_0, CTa_1, ..., CTa_m\n    ///                                                                    \\__________  __________/\n    ///                                                                               \\/\n    ///                                                                    additional control bytes\n    ///                                                                     `m = Group::WIDTH - 1`\n    ///\n    /// where: T0...T_n  - our stored data;\n    ///        CT0...CT_n - control bytes or metadata for `data`;\n    ///        CTa_0...CTa_m - additional control bytes (so that the search with loading `Group` bytes from\n    ///                        the heap works properly, even if the result of `h1(hash) & self.bucket_mask`\n    ///                        is equal to `self.bucket_mask`). See also `RawTableInner::set_ctrl` function.\n    ///\n    /// P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n    /// of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n    /// ```\n    ///\n    /// [`RawTableInner::buckets`]: RawTableInner::buckets\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn bucket_ptr(&self, index: usize, size_of: usize) -> *mut u8 {\n        debug_assert_ne!(self.bucket_mask, 0);\n        debug_assert!(index < self.buckets());\n        let base: *mut u8 = self.data_end().as_ptr();\n        base.sub((index + 1) * size_of)\n    }\n\n    /// Returns pointer to one past last `data` element in the table as viewed from\n    /// the start point of the allocation (convenience for `self.ctrl.cast()`).\n    ///\n    /// This function actually returns a pointer to the end of the `data element` at\n    /// index "0" (zero).\n    ///\n    /// The caller must ensure that the `RawTableInner` outlives the returned [`NonNull<T>`],\n    /// otherwise using it may result in [`undefined behavior`].\n    ///\n    /// # Note\n    ///\n    /// The type `T` must be the actual type of the elements stored in the table, otherwise\n    /// using the returned [`NonNull<T>`] may result in [`undefined behavior`].\n    ///\n    /// ```none\n    ///                        `table.data_end::<T>()` returns pointer that points here\n    ///                        (to the end of `T0`)\n    ///                          \n    /// [Pad], T_n, ..., T1, T0, |CT0, CT1, ..., CT_n|, CTa_0, CTa_1, ..., CTa_m\n    ///                           \\________  ________/\n    ///                                    \\/\n    ///       `n = buckets - 1`, i.e. `RawTableInner::buckets() - 1`\n    ///\n    /// where: T0...T_n  - our stored data;\n    ///        CT0...CT_n - control bytes or metadata for `data`.\n    ///        CTa_0...CTa_m - additional control bytes, where `m = Group::WIDTH - 1` (so that the search\n    ///                        with loading `Group` bytes from the heap works properly, even if the result\n    ///                        of `h1(hash) & self.bucket_mask` is equal to `self.bucket_mask`). See also\n    ///                        `RawTableInner::set_ctrl` function.\n    ///\n    /// P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n    /// of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n    /// ```\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    fn data_end<T>(&self) -> NonNull<T> {\n        self.ctrl.cast()\n    }\n\n    /// Returns an iterator-like object for a probe sequence on the table.\n    ///\n    /// This iterator never terminates, but is guaranteed to visit each bucket\n    /// group exactly once. The loop using `probe_seq` must terminate upon\n    /// reaching a group containing an empty bucket.\n    #[inline]\n    fn probe_seq(&self, hash: u64) -> ProbeSeq {\n        ProbeSeq {\n            // This is the same as `hash as usize % self.buckets()` because the number\n            // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n            pos: h1(hash) & self.bucket_mask,\n            stride: 0,\n        }\n    }\n\n    #[inline]\n    unsafe fn record_item_insert_at(&mut self, index: usize, old_ctrl: Tag, hash: u64) {\n        self.growth_left -= usize::from(old_ctrl.special_is_empty());\n        self.set_ctrl_hash(index, hash);\n        self.items += 1;\n    }\n\n    #[inline]\n    fn is_in_same_group(&self, i: usize, new_i: usize, hash: u64) -> bool {\n        let probe_seq_pos = self.probe_seq(hash).pos;\n        let probe_index =\n            |pos: usize| (pos.wrapping_sub(probe_seq_pos) & self.bucket_mask) / Group::WIDTH;\n        probe_index(i) == probe_index(new_i)\n    }\n\n    /// Sets a control byte to the hash, and possibly also the replicated control byte at\n    /// the end of the array.\n    ///\n    /// This function does not make any changes to the `data` parts of the table,\n    /// or any changes to the `items` or `growth_left` field of the table.\n    ///\n    /// # Safety\n    ///\n    /// The safety rules are directly derived from the safety rules for [`RawTableInner::set_ctrl`]\n    /// method. Thus, in order to uphold the safety contracts for the method, you must observe the\n    /// following rules when calling this function:\n    ///\n    /// * The [`RawTableInner`] has already been allocated;\n    ///\n    /// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n    ///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n    ///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n    ///\n    /// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n    ///\n    /// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n    /// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n    ///\n    /// [`RawTableInner::set_ctrl`]: RawTableInner::set_ctrl\n    /// [`RawTableInner::buckets`]: RawTableInner::buckets\n    /// [`Bucket::as_ptr`]: Bucket::as_ptr\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn set_ctrl_hash(&mut self, index: usize, hash: u64) {\n        // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::set_ctrl_hash`]\n        self.set_ctrl(index, Tag::full(hash));\n    }\n\n    /// Replaces the hash in the control byte at the given index with the provided one,\n    /// and possibly also replicates the new control byte at the end of the array of control\n    /// bytes, returning the old control byte.\n    ///\n    /// This function does not make any changes to the `data` parts of the table,\n    /// or any changes to the `items` or `growth_left` field of the table.\n    ///\n    /// # Safety\n    ///\n    /// The safety rules are directly derived from the safety rules for [`RawTableInner::set_ctrl_hash`]\n    /// and [`RawTableInner::ctrl`] methods. Thus, in order to uphold the safety contracts for both\n    /// methods, you must observe the following rules when calling this function:\n    ///\n    /// * The [`RawTableInner`] has already been allocated;\n    ///\n    /// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n    ///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n    ///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n    ///\n    /// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n    ///\n    /// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n    /// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n    ///\n    /// [`RawTableInner::set_ctrl_hash`]: RawTableInner::set_ctrl_hash\n    /// [`RawTableInner::buckets`]: RawTableInner::buckets\n    /// [`Bucket::as_ptr`]: Bucket::as_ptr\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn replace_ctrl_hash(&mut self, index: usize, hash: u64) -> Tag {\n        // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::replace_ctrl_hash`]\n        let prev_ctrl = *self.ctrl(index);\n        self.set_ctrl_hash(index, hash);\n        prev_ctrl\n    }\n\n    /// Sets a control byte, and possibly also the replicated control byte at\n    /// the end of the array.\n    ///\n    /// This function does not make any changes to the `data` parts of the table,\n    /// or any changes to the `items` or `growth_left` field of the table.\n    ///\n    /// # Safety\n    ///\n    /// You must observe the following safety rules when calling this function:\n    ///\n    /// * The [`RawTableInner`] has already been allocated;\n    ///\n    /// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n    ///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n    ///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n    ///\n    /// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n    ///\n    /// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n    /// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n    ///\n    /// [`RawTableInner::buckets`]: RawTableInner::buckets\n    /// [`Bucket::as_ptr`]: Bucket::as_ptr\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn set_ctrl(&mut self, index: usize, ctrl: Tag) {\n        // Replicate the first Group::WIDTH control bytes at the end of\n        // the array without using a branch. If the tables smaller than\n        // the group width (self.buckets() < Group::WIDTH),\n        // `index2 = Group::WIDTH + index`, otherwise `index2` is:\n        //\n        // - If index >= Group::WIDTH then index == index2.\n        // - Otherwise index2 == self.bucket_mask + 1 + index.\n        //\n        // The very last replicated control byte is never actually read because\n        // we mask the initial index for unaligned loads, but we write it\n        // anyways because it makes the set_ctrl implementation simpler.\n        //\n        // If there are fewer buckets than Group::WIDTH then this code will\n        // replicate the buckets at the end of the trailing group. For example\n        // with 2 buckets and a group size of 4, the control bytes will look\n        // like this:\n        //\n        //     Real    |             Replicated\n        // ---------------------------------------------\n        // | [A] | [B] | [Tag::EMPTY] | [EMPTY] | [A] | [B] |\n        // ---------------------------------------------\n\n        // This is the same as `(index.wrapping_sub(Group::WIDTH)) % self.buckets() + Group::WIDTH`\n        // because the number of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n        let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;\n\n        // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::set_ctrl`]\n        *self.ctrl(index) = ctrl;\n        *self.ctrl(index2) = ctrl;\n    }\n\n    /// Returns a pointer to a control byte.\n    ///\n    /// # Safety\n    ///\n    /// For the allocated [`RawTableInner`], the result is [`Undefined Behavior`],\n    /// if the `index` is greater than the `self.bucket_mask + 1 + Group::WIDTH`.\n    /// In that case, calling this function with `index == self.bucket_mask + 1 + Group::WIDTH`\n    /// will return a pointer to the end of the allocated table and it is useless on its own.\n    ///\n    /// Calling this function with `index >= self.bucket_mask + 1 + Group::WIDTH` on a\n    /// table that has not been allocated results in [`Undefined Behavior`].\n    ///\n    /// So to satisfy both requirements you should always follow the rule that\n    /// `index < self.bucket_mask + 1 + Group::WIDTH`\n    ///\n    /// Calling this function on [`RawTableInner`] that are not already allocated is safe\n    /// for read-only purpose.\n    ///\n    /// See also [`Bucket::as_ptr()`] method, for more information about of properly removing\n    /// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n    ///\n    /// [`Bucket::as_ptr()`]: Bucket::as_ptr()\n    /// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn ctrl(&self, index: usize) -> *mut Tag {\n        debug_assert!(index < self.num_ctrl_bytes());\n        // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::ctrl`]\n        self.ctrl.as_ptr().add(index).cast()\n    }\n\n    /// Gets the slice of all control bytes.\n    fn ctrl_slice(&mut self) -> &mut [Tag] {\n        // SAFETY: We\'ve intiailized all control bytes, and have the correct number.\n        unsafe { slice::from_raw_parts_mut(self.ctrl.as_ptr().cast(), self.num_ctrl_bytes()) }\n    }\n\n    #[inline]\n    fn buckets(&self) -> usize {\n        self.bucket_mask + 1\n    }\n\n    /// Checks whether the bucket at `index` is full.\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure `index` is less than the number of buckets.\n    #[inline]\n    unsafe fn is_bucket_full(&self, index: usize) -> bool {\n        debug_assert!(index < self.buckets());\n        (*self.ctrl(index)).is_full()\n    }\n\n    #[inline]\n    fn num_ctrl_bytes(&self) -> usize {\n        self.bucket_mask + 1 + Group::WIDTH\n    }\n\n    #[inline]\n    fn is_empty_singleton(&self) -> bool {\n        self.bucket_mask == 0\n    }\n\n    /// Attempts to allocate a new hash table with at least enough capacity\n    /// for inserting the given number of elements without reallocating,\n    /// and return it inside `ScopeGuard` to protect against panic in the hash\n    /// function.\n    ///\n    /// # Note\n    ///\n    /// It is recommended (but not required):\n    ///\n    /// * That the new table\'s `capacity` be greater than or equal to `self.items`.\n    ///\n    /// * The `alloc` is the same [`Allocator`] as the `Allocator` used\n    ///   to allocate this table.\n    ///\n    /// * The `table_layout` is the same [`TableLayout`] as the `TableLayout` used\n    ///   to allocate this table.\n    ///\n    /// If `table_layout` does not match the `TableLayout` that was used to allocate\n    /// this table, then using `mem::swap` with the `self` and the new table returned\n    /// by this function results in [`undefined behavior`].\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[allow(clippy::mut_mut)]\n    #[inline]\n    fn prepare_resize<\'a, A>(\n        &self,\n        alloc: &\'a A,\n        table_layout: TableLayout,\n        capacity: usize,\n        fallibility: Fallibility,\n    ) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self) + \'a>, TryReserveError>\n    where\n        A: Allocator,\n    {\n        debug_assert!(self.items <= capacity);\n\n        // Allocate and initialize the new table.\n        let new_table =\n            RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, fallibility)?;\n\n        // The hash function may panic, in which case we simply free the new\n        // table without dropping any elements that may have been copied into\n        // it.\n        //\n        // This guard is also used to free the old table on success, see\n        // the comment at the bottom of this function.\n        Ok(guard(new_table, move |self_| {\n            if !self_.is_empty_singleton() {\n                // SAFETY:\n                // 1. We have checked that our table is allocated.\n                // 2. We know for sure that the `alloc` and `table_layout` matches the\n                //    [`Allocator`] and [`TableLayout`] used to allocate this table.\n                unsafe { self_.free_buckets(alloc, table_layout) };\n            }\n        }))\n    }\n\n    /// Reserves or rehashes to make room for `additional` more elements.\n    ///\n    /// This uses dynamic dispatch to reduce the amount of\n    /// code generated, but it is eliminated by LLVM optimizations when inlined.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is\n    /// [`undefined behavior`]:\n    ///\n    /// * The `alloc` must be the same [`Allocator`] as the `Allocator` used\n    ///   to allocate this table.\n    ///\n    /// * The `layout` must be the same [`TableLayout`] as the `TableLayout`\n    ///   used to allocate this table.\n    ///\n    /// * The `drop` function (`fn(*mut u8)`) must be the actual drop function of\n    ///   the elements stored in the table.\n    ///\n    /// * The [`RawTableInner`] must have properly initialized control bytes.\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[allow(clippy::inline_always)]\n    #[inline(always)]\n    unsafe fn reserve_rehash_inner<A>(\n        &mut self,\n        alloc: &A,\n        additional: usize,\n        hasher: &dyn Fn(&mut Self, usize) -> u64,\n        fallibility: Fallibility,\n        layout: TableLayout,\n        drop: Option<unsafe fn(*mut u8)>,\n    ) -> Result<(), TryReserveError>\n    where\n        A: Allocator,\n    {\n        // Avoid `Option::ok_or_else` because it bloats LLVM IR.\n        let new_items = match self.items.checked_add(additional) {\n            Some(new_items) => new_items,\n            None => return Err(fallibility.capacity_overflow()),\n        };\n        let full_capacity = bucket_mask_to_capacity(self.bucket_mask);\n        if new_items <= full_capacity / 2 {\n            // Rehash in-place without re-allocating if we have plenty of spare\n            // capacity that is locked up due to DELETED entries.\n\n            // SAFETY:\n            // 1. We know for sure that `[`RawTableInner`]` has already been allocated\n            //    (since new_items <= full_capacity / 2);\n            // 2. The caller ensures that `drop` function is the actual drop function of\n            //    the elements stored in the table.\n            // 3. The caller ensures that `layout` matches the [`TableLayout`] that was\n            //    used to allocate this table.\n            // 4. The caller ensures that the control bytes of the `RawTableInner`\n            //    are already initialized.\n            self.rehash_in_place(hasher, layout.size, drop);\n            Ok(())\n        } else {\n            // Otherwise, conservatively resize to at least the next size up\n            // to avoid churning deletes into frequent rehashes.\n            //\n            // SAFETY:\n            // 1. We know for sure that `capacity >= self.items`.\n            // 2. The caller ensures that `alloc` and `layout` matches the [`Allocator`] and\n            //    [`TableLayout`] that were used to allocate this table.\n            // 3. The caller ensures that the control bytes of the `RawTableInner`\n            //    are already initialized.\n            self.resize_inner(\n                alloc,\n                usize::max(new_items, full_capacity + 1),\n                hasher,\n                fallibility,\n                layout,\n            )\n        }\n    }\n\n    /// Returns an iterator over full buckets indices in the table.\n    ///\n    /// # Safety\n    ///\n    /// Behavior is undefined if any of the following conditions are violated:\n    ///\n    /// * The caller has to ensure that the `RawTableInner` outlives the\n    ///   `FullBucketsIndices`. Because we cannot make the `next` method\n    ///   unsafe on the `FullBucketsIndices` struct, we have to make the\n    ///   `full_buckets_indices` method unsafe.\n    ///\n    /// * The [`RawTableInner`] must have properly initialized control bytes.\n    #[inline(always)]\n    unsafe fn full_buckets_indices(&self) -> FullBucketsIndices {\n        // SAFETY:\n        // 1. Since the caller of this function ensures that the control bytes\n        //    are properly initialized and `self.ctrl(0)` points to the start\n        //    of the array of control bytes, therefore: `ctrl` is valid for reads,\n        //    properly aligned to `Group::WIDTH` and points to the properly initialized\n        //    control bytes.\n        // 2. The value of `items` is equal to the amount of data (values) added\n        //    to the table.\n        //\n        //                         `ctrl` points here (to the start\n        //                         of the first control byte `CT0`)\n        //                          \n        // [Pad], T_n, ..., T1, T0, |CT0, CT1, ..., CT_n|, Group::WIDTH\n        //                           \\________  ________/\n        //                                    \\/\n        //       `n = buckets - 1`, i.e. `RawTableInner::buckets() - 1`\n        //\n        // where: T0...T_n  - our stored data;\n        //        CT0...CT_n - control bytes or metadata for `data`.\n        let ctrl = NonNull::new_unchecked(self.ctrl(0).cast::<u8>());\n\n        FullBucketsIndices {\n            // Load the first group\n            // SAFETY: See explanation above.\n            current_group: Group::load_aligned(ctrl.as_ptr().cast())\n                .match_full()\n                .into_iter(),\n            group_first_index: 0,\n            ctrl,\n            items: self.items,\n        }\n    }\n\n    /// Allocates a new table of a different size and moves the contents of the\n    /// current table into it.\n    ///\n    /// This uses dynamic dispatch to reduce the amount of\n    /// code generated, but it is eliminated by LLVM optimizations when inlined.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is\n    /// [`undefined behavior`]:\n    ///\n    /// * The `alloc` must be the same [`Allocator`] as the `Allocator` used\n    ///   to allocate this table;\n    ///\n    /// * The `layout` must be the same [`TableLayout`] as the `TableLayout`\n    ///   used to allocate this table;\n    ///\n    /// * The [`RawTableInner`] must have properly initialized control bytes.\n    ///\n    /// The caller of this function must ensure that `capacity >= self.items`\n    /// otherwise:\n    ///\n    /// * If `self.items != 0`, calling of this function with `capacity == 0`\n    ///   results in [`undefined behavior`].\n    ///\n    /// * If `capacity_to_buckets(capacity) < Group::WIDTH` and\n    ///   `self.items > capacity_to_buckets(capacity)` calling this function\n    ///   results in [`undefined behavior`].\n    ///\n    /// * If `capacity_to_buckets(capacity) >= Group::WIDTH` and\n    ///   `self.items > capacity_to_buckets(capacity)` calling this function\n    ///   are never return (will go into an infinite loop).\n    ///\n    /// Note: It is recommended (but not required) that the new table\'s `capacity`\n    /// be greater than or equal to `self.items`. In case if `capacity <= self.items`\n    /// this function can never return. See [`RawTableInner::find_insert_slot`] for\n    /// more information.\n    ///\n    /// [`RawTableInner::find_insert_slot`]: RawTableInner::find_insert_slot\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[allow(clippy::inline_always)]\n    #[inline(always)]\n    unsafe fn resize_inner<A>(\n        &mut self,\n        alloc: &A,\n        capacity: usize,\n        hasher: &dyn Fn(&mut Self, usize) -> u64,\n        fallibility: Fallibility,\n        layout: TableLayout,\n    ) -> Result<(), TryReserveError>\n    where\n        A: Allocator,\n    {\n        // SAFETY: We know for sure that `alloc` and `layout` matches the [`Allocator`] and [`TableLayout`]\n        // that were used to allocate this table.\n        let mut new_table = self.prepare_resize(alloc, layout, capacity, fallibility)?;\n\n        // SAFETY: We know for sure that RawTableInner will outlive the\n        // returned `FullBucketsIndices` iterator, and the caller of this\n        // function ensures that the control bytes are properly initialized.\n        for full_byte_index in self.full_buckets_indices() {\n            // This may panic.\n            let hash = hasher(self, full_byte_index);\n\n            // SAFETY:\n            // We can use a simpler version of insert() here since:\n            // 1. There are no DELETED entries.\n            // 2. We know there is enough space in the table.\n            // 3. All elements are unique.\n            // 4. The caller of this function guarantees that `capacity > 0`\n            //    so `new_table` must already have some allocated memory.\n            // 5. We set `growth_left` and `items` fields of the new table\n            //    after the loop.\n            // 6. We insert into the table, at the returned index, the data\n            //    matching the given hash immediately after calling this function.\n            let (new_index, _) = new_table.prepare_insert_slot(hash);\n\n            // SAFETY:\n            //\n            // * `src` is valid for reads of `layout.size` bytes, since the\n            //   table is alive and the `full_byte_index` is guaranteed to be\n            //   within bounds (see `FullBucketsIndices::next_impl`);\n            //\n            // * `dst` is valid for writes of `layout.size` bytes, since the\n            //   caller ensures that `table_layout` matches the [`TableLayout`]\n            //   that was used to allocate old table and we have the `new_index`\n            //   returned by `prepare_insert_slot`.\n            //\n            // * Both `src` and `dst` are properly aligned.\n            //\n            // * Both `src` and `dst` point to different region of memory.\n            ptr::copy_nonoverlapping(\n                self.bucket_ptr(full_byte_index, layout.size),\n                new_table.bucket_ptr(new_index, layout.size),\n                layout.size,\n            );\n        }\n\n        // The hash function didn\'t panic, so we can safely set the\n        // `growth_left` and `items` fields of the new table.\n        new_table.growth_left -= self.items;\n        new_table.items = self.items;\n\n        // We successfully copied all elements without panicking. Now replace\n        // self with the new table. The old table will have its memory freed but\n        // the items will not be dropped (since they have been moved into the\n        // new table).\n        // SAFETY: The caller ensures that `table_layout` matches the [`TableLayout`]\n        // that was used to allocate this table.\n        mem::swap(self, &mut new_table);\n\n        Ok(())\n    }\n\n    /// Rehashes the contents of the table in place (i.e. without changing the\n    /// allocation).\n    ///\n    /// If `hasher` panics then some the table\'s contents may be lost.\n    ///\n    /// This uses dynamic dispatch to reduce the amount of\n    /// code generated, but it is eliminated by LLVM optimizations when inlined.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is [`undefined behavior`]:\n    ///\n    /// * The `size_of` must be equal to the size of the elements stored in the table;\n    ///\n    /// * The `drop` function (`fn(*mut u8)`) must be the actual drop function of\n    ///   the elements stored in the table.\n    ///\n    /// * The [`RawTableInner`] has already been allocated;\n    ///\n    /// * The [`RawTableInner`] must have properly initialized control bytes.\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[allow(clippy::inline_always)]\n    #[cfg_attr(feature = "inline-more", inline(always))]\n    #[cfg_attr(not(feature = "inline-more"), inline)]\n    unsafe fn rehash_in_place(\n        &mut self,\n        hasher: &dyn Fn(&mut Self, usize) -> u64,\n        size_of: usize,\n        drop: Option<unsafe fn(*mut u8)>,\n    ) {\n        // If the hash function panics then properly clean up any elements\n        // that we haven\'t rehashed yet. We unfortunately can\'t preserve the\n        // element since we lost their hash and have no way of recovering it\n        // without risking another panic.\n        self.prepare_rehash_in_place();\n\n        let mut guard = guard(self, move |self_| {\n            if let Some(drop) = drop {\n                for i in 0..self_.buckets() {\n                    if *self_.ctrl(i) == Tag::DELETED {\n                        self_.set_ctrl(i, Tag::EMPTY);\n                        drop(self_.bucket_ptr(i, size_of));\n                        self_.items -= 1;\n                    }\n                }\n            }\n            self_.growth_left = bucket_mask_to_capacity(self_.bucket_mask) - self_.items;\n        });\n\n        // At this point, DELETED elements are elements that we haven\'t\n        // rehashed yet. Find them and re-insert them at their ideal\n        // position.\n        \'outer: for i in 0..guard.buckets() {\n            if *guard.ctrl(i) != Tag::DELETED {\n                continue;\n            }\n\n            let i_p = guard.bucket_ptr(i, size_of);\n\n            \'inner: loop {\n                // Hash the current item\n                let hash = hasher(*guard, i);\n\n                // Search for a suitable place to put it\n                //\n                // SAFETY: Caller of this function ensures that the control bytes\n                // are properly initialized.\n                let new_i = guard.find_insert_slot(hash).index;\n\n                // Probing works by scanning through all of the control\n                // bytes in groups, which may not be aligned to the group\n                // size. If both the new and old position fall within the\n                // same unaligned group, then there is no benefit in moving\n                // it and we can just continue to the next item.\n                if likely(guard.is_in_same_group(i, new_i, hash)) {\n                    guard.set_ctrl_hash(i, hash);\n                    continue \'outer;\n                }\n\n                let new_i_p = guard.bucket_ptr(new_i, size_of);\n\n                // We are moving the current item to a new position. Write\n                // our H2 to the control byte of the new position.\n                let prev_ctrl = guard.replace_ctrl_hash(new_i, hash);\n                if prev_ctrl == Tag::EMPTY {\n                    guard.set_ctrl(i, Tag::EMPTY);\n                    // If the target slot is empty, simply move the current\n                    // element into the new slot and clear the old control\n                    // byte.\n                    ptr::copy_nonoverlapping(i_p, new_i_p, size_of);\n                    continue \'outer;\n                } else {\n                    // If the target slot is occupied, swap the two elements\n                    // and then continue processing the element that we just\n                    // swapped into the old slot.\n                    debug_assert_eq!(prev_ctrl, Tag::DELETED);\n                    ptr::swap_nonoverlapping(i_p, new_i_p, size_of);\n                    continue \'inner;\n                }\n            }\n        }\n\n        guard.growth_left = bucket_mask_to_capacity(guard.bucket_mask) - guard.items;\n\n        mem::forget(guard);\n    }\n\n    /// Deallocates the table without dropping any entries.\n    ///\n    /// # Note\n    ///\n    /// This function must be called only after [`drop_elements`](RawTableInner::drop_elements),\n    /// else it can lead to leaking of memory. Also calling this function automatically\n    /// makes invalid (dangling) all instances of buckets ([`Bucket`]) and makes invalid\n    /// (dangling) the `ctrl` field of the table.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is [`Undefined Behavior`]:\n    ///\n    /// * The [`RawTableInner`] has already been allocated;\n    ///\n    /// * The `alloc` must be the same [`Allocator`] as the `Allocator` that was used\n    ///   to allocate this table.\n    ///\n    /// * The `table_layout` must be the same [`TableLayout`] as the `TableLayout` that was used\n    ///   to allocate this table.\n    ///\n    /// See also [`GlobalAlloc::dealloc`] or [`Allocator::deallocate`] for more  information.\n    ///\n    /// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    /// [`GlobalAlloc::dealloc`]: https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.dealloc\n    /// [`Allocator::deallocate`]: https://doc.rust-lang.org/alloc/alloc/trait.Allocator.html#tymethod.deallocate\n    #[inline]\n    unsafe fn free_buckets<A>(&mut self, alloc: &A, table_layout: TableLayout)\n    where\n        A: Allocator,\n    {\n        // SAFETY: The caller must uphold the safety contract for `free_buckets`\n        // method.\n        let (ptr, layout) = self.allocation_info(table_layout);\n        alloc.deallocate(ptr, layout);\n    }\n\n    /// Returns a pointer to the allocated memory and the layout that was used to\n    /// allocate the table.\n    ///\n    /// # Safety\n    ///\n    /// Caller of this function must observe the following safety rules:\n    ///\n    /// * The [`RawTableInner`] has already been allocated, otherwise\n    ///   calling this function results in [`undefined behavior`]\n    ///\n    /// * The `table_layout` must be the same [`TableLayout`] as the `TableLayout`\n    ///   that was used to allocate this table. Failure to comply with this condition\n    ///   may result in [`undefined behavior`].\n    ///\n    /// See also [`GlobalAlloc::dealloc`] or [`Allocator::deallocate`] for more  information.\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    /// [`GlobalAlloc::dealloc`]: https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.dealloc\n    /// [`Allocator::deallocate`]: https://doc.rust-lang.org/alloc/alloc/trait.Allocator.html#tymethod.deallocate\n    #[inline]\n    unsafe fn allocation_info(&self, table_layout: TableLayout) -> (NonNull<u8>, Layout) {\n        debug_assert!(\n            !self.is_empty_singleton(),\n            "this function can only be called on non-empty tables"\n        );\n\n        // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.\n        let (layout, ctrl_offset) = match table_layout.calculate_layout_for(self.buckets()) {\n            Some(lco) => lco,\n            None => unsafe { hint::unreachable_unchecked() },\n        };\n        (\n            // SAFETY: The caller must uphold the safety contract for `allocation_info` method.\n            unsafe { NonNull::new_unchecked(self.ctrl.as_ptr().sub(ctrl_offset)) },\n            layout,\n        )\n    }\n\n    /// Returns the total amount of memory allocated internally by the hash\n    /// table, in bytes.\n    ///\n    /// The returned number is informational only. It is intended to be\n    /// primarily used for memory profiling.\n    ///\n    /// # Safety\n    ///\n    /// The `table_layout` must be the same [`TableLayout`] as the `TableLayout`\n    /// that was used to allocate this table. Failure to comply with this condition\n    /// may result in [`undefined behavior`].\n    ///\n    ///\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn allocation_size_or_zero(&self, table_layout: TableLayout) -> usize {\n        if self.is_empty_singleton() {\n            0\n        } else {\n            // SAFETY:\n            // 1. We have checked that our table is allocated.\n            // 2. The caller ensures that `table_layout` matches the [`TableLayout`]\n            // that was used to allocate this table.\n            unsafe { self.allocation_info(table_layout).1.size() }\n        }\n    }\n\n    /// Marks all table buckets as empty without dropping their contents.\n    #[inline]\n    fn clear_no_drop(&mut self) {\n        if !self.is_empty_singleton() {\n            self.ctrl_slice().fill_empty();\n        }\n        self.items = 0;\n        self.growth_left = bucket_mask_to_capacity(self.bucket_mask);\n    }\n\n    /// Erases the [`Bucket`]\'s control byte at the given index so that it does not\n    /// triggered as full, decreases the `items` of the table and, if it can be done,\n    /// increases `self.growth_left`.\n    ///\n    /// This function does not actually erase / drop the [`Bucket`] itself, i.e. it\n    /// does not make any changes to the `data` parts of the table. The caller of this\n    /// function must take care to properly drop the `data`, otherwise calling this\n    /// function may result in a memory leak.\n    ///\n    /// # Safety\n    ///\n    /// You must observe the following safety rules when calling this function:\n    ///\n    /// * The [`RawTableInner`] has already been allocated;\n    ///\n    /// * It must be the full control byte at the given position;\n    ///\n    /// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n    ///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n    ///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n    ///\n    /// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n    ///\n    /// Calling this function on a table with no elements is unspecified, but calling subsequent\n    /// functions is likely to result in [`undefined behavior`] due to overflow subtraction\n    /// (`self.items -= 1 cause overflow when self.items == 0`).\n    ///\n    /// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n    /// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n    ///\n    /// [`RawTableInner::buckets`]: RawTableInner::buckets\n    /// [`Bucket::as_ptr`]: Bucket::as_ptr\n    /// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    #[inline]\n    unsafe fn erase(&mut self, index: usize) {\n        debug_assert!(self.is_bucket_full(index));\n\n        // This is the same as `index.wrapping_sub(Group::WIDTH) % self.buckets()` because\n        // the number of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n        let index_before = index.wrapping_sub(Group::WIDTH) & self.bucket_mask;\n        // SAFETY:\n        // - The caller must uphold the safety contract for `erase` method;\n        // - `index_before` is guaranteed to be in range due to masking with `self.bucket_mask`\n        let empty_before = Group::load(self.ctrl(index_before)).match_empty();\n        let empty_after = Group::load(self.ctrl(index)).match_empty();\n\n        // Inserting and searching in the map is performed by two key functions:\n        //\n        // - The `find_insert_slot` function that looks up the index of any `Tag::EMPTY` or `Tag::DELETED`\n        //   slot in a group to be able to insert. If it doesn\'t find an `Tag::EMPTY` or `Tag::DELETED`\n        //   slot immediately in the first group, it jumps to the next `Group` looking for it,\n        //   and so on until it has gone through all the groups in the control bytes.\n        //\n        // - The `find_inner` function that looks for the index of the desired element by looking\n        //   at all the `FULL` bytes in the group. If it did not find the element right away, and\n        //   there is no `Tag::EMPTY` byte in the group, then this means that the `find_insert_slot`\n        //   function may have found a suitable slot in the next group. Therefore, `find_inner`\n        //   jumps further, and if it does not find the desired element and again there is no `Tag::EMPTY`\n        //   byte, then it jumps further, and so on. The search stops only if `find_inner` function\n        //   finds the desired element or hits an `Tag::EMPTY` slot/byte.\n        //\n        // Accordingly, this leads to two consequences:\n        //\n        // - The map must have `Tag::EMPTY` slots (bytes);\n        //\n        // - You can\'t just mark the byte to be erased as `Tag::EMPTY`, because otherwise the `find_inner`\n        //   function may stumble upon an `Tag::EMPTY` byte before finding the desired element and stop\n        //   searching.\n        //\n        // Thus it is necessary to check all bytes after and before the erased element. If we are in\n        // a contiguous `Group` of `FULL` or `Tag::DELETED` bytes (the number of `FULL` or `Tag::DELETED` bytes\n        // before and after is greater than or equal to `Group::WIDTH`), then we must mark our byte as\n        // `Tag::DELETED` in order for the `find_inner` function to go further. On the other hand, if there\n        // is at least one `Tag::EMPTY` slot in the `Group`, then the `find_inner` function will still stumble\n        // upon an `Tag::EMPTY` byte, so we can safely mark our erased byte as `Tag::EMPTY` as well.\n        //\n        // Finally, since `index_before == (index.wrapping_sub(Group::WIDTH) & self.bucket_mask) == index`\n        // and given all of the above, tables smaller than the group width (self.buckets() < Group::WIDTH)\n        // cannot have `Tag::DELETED` bytes.\n        //\n        // Note that in this context `leading_zeros` refers to the bytes at the end of a group, while\n        // `trailing_zeros` refers to the bytes at the beginning of a group.\n        let ctrl = if empty_before.leading_zeros() + empty_after.trailing_zeros() >= Group::WIDTH {\n            Tag::DELETED\n        } else {\n            self.growth_left += 1;\n            Tag::EMPTY\n        };\n        // SAFETY: the caller must uphold the safety contract for `erase` method.\n        self.set_ctrl(index, ctrl);\n        self.items -= 1;\n    }\n}', 'impl RawTableInner {\n    const NEW: Self = RawTableInner::new();\n\n    /// Creates a new empty hash table without allocating any memory.\n    ///\n    /// In effect this returns a table with exactly 1 bucket. However we can\n    /// leave the data pointer dangling since that bucket is never accessed\n    /// due to our load factor forcing us to always have at least 1 free bucket.\n    #[inline]\n    const fn new() -> Self {\n        Self {\n            // Be careful to cast the entire slice to a raw pointer.\n            ctrl: unsafe {\n                NonNull::new_unchecked(Group::static_empty().as_ptr().cast_mut().cast())\n            },\n            bucket_mask: 0,\n            items: 0,\n            growth_left: 0,\n        }\n    }\n}'], 'raw::TableLayout': ['Clone', 'Copy', "impl TableLayout {\n    #[inline]\n    const fn new<T>() -> Self {\n        let layout = Layout::new::<T>();\n        Self {\n            size: layout.size(),\n            ctrl_align: if layout.align() > Group::WIDTH {\n                layout.align()\n            } else {\n                Group::WIDTH\n            },\n        }\n    }\n\n    #[inline]\n    fn calculate_layout_for(self, buckets: usize) -> Option<(Layout, usize)> {\n        debug_assert!(buckets.is_power_of_two());\n\n        let TableLayout { size, ctrl_align } = self;\n        // Manual layout calculation since Layout methods are not yet stable.\n        let ctrl_offset =\n            size.checked_mul(buckets)?.checked_add(ctrl_align - 1)? & !(ctrl_align - 1);\n        let len = ctrl_offset.checked_add(buckets + Group::WIDTH)?;\n\n        // We need an additional check to ensure that the allocation doesn't\n        // exceed `isize::MAX` (https://github.com/rust-lang/rust/pull/95295).\n        if len > isize::MAX as usize - (ctrl_align - 1) {\n            return None;\n        }\n\n        Some((\n            unsafe { Layout::from_size_align_unchecked(len, ctrl_align) },\n            ctrl_offset,\n        ))\n    }\n}"], 'raw_entry::RawEntryBuilder': ['impl<\'a, K, V, S, A: Allocator> RawEntryBuilder<\'a, K, V, S, A> {\n    /// Access an immutable entry by key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    /// let key = "a";\n    /// assert_eq!(map.raw_entry().from_key(&key), Some((&"a", &100)));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[allow(clippy::wrong_self_convention)]\n    pub fn from_key<Q>(self, k: &Q) -> Option<(&\'a K, &\'a V)>\n    where\n        S: BuildHasher,\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        let hash = make_hash::<Q, S>(&self.map.hash_builder, k);\n        self.from_key_hashed_nocheck(hash, k)\n    }\n\n    /// Access an immutable entry by a key and its hash.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use core::hash::{BuildHasher, Hash};\n    /// use hashbrown::HashMap;\n    ///\n    /// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n    ///     use core::hash::Hasher;\n    ///     let mut state = hash_builder.build_hasher();\n    ///     key.hash(&mut state);\n    ///     state.finish()\n    /// }\n    ///\n    /// let map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    /// let key = "a";\n    /// let hash = compute_hash(map.hasher(), &key);\n    /// assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &key), Some((&"a", &100)));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[allow(clippy::wrong_self_convention)]\n    pub fn from_key_hashed_nocheck<Q>(self, hash: u64, k: &Q) -> Option<(&\'a K, &\'a V)>\n    where\n        Q: Equivalent<K> + ?Sized,\n    {\n        self.from_hash(hash, equivalent(k))\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn search<F>(self, hash: u64, mut is_match: F) -> Option<(&\'a K, &\'a V)>\n    where\n        F: FnMut(&K) -> bool,\n    {\n        match self.map.table.get(hash, |(k, _)| is_match(k)) {\n            Some((key, value)) => Some((key, value)),\n            None => None,\n        }\n    }\n\n    /// Access an immutable entry by hash and matching function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use core::hash::{BuildHasher, Hash};\n    /// use hashbrown::HashMap;\n    ///\n    /// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n    ///     use core::hash::Hasher;\n    ///     let mut state = hash_builder.build_hasher();\n    ///     key.hash(&mut state);\n    ///     state.finish()\n    /// }\n    ///\n    /// let map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    /// let key = "a";\n    /// let hash = compute_hash(map.hasher(), &key);\n    /// assert_eq!(map.raw_entry().from_hash(hash, |k| k == &key), Some((&"a", &100)));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[allow(clippy::wrong_self_convention)]\n    pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&\'a K, &\'a V)>\n    where\n        F: FnMut(&K) -> bool,\n    {\n        self.search(hash, is_match)\n    }\n}', 'impl<K, V, S, A: Allocator> Debug for RawEntryBuilder<\'_, K, V, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("RawEntryBuilder").finish()\n    }\n}'], 'raw_entry::RawEntryBuilderMut': ['impl<\'a, K, V, S, A: Allocator> RawEntryBuilderMut<\'a, K, V, S, A> {\n    /// Creates a `RawEntryMut` from the given hash and matching function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use core::hash::{BuildHasher, Hash};\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n    ///     use core::hash::Hasher;\n    ///     let mut state = hash_builder.build_hasher();\n    ///     key.hash(&mut state);\n    ///     state.finish()\n    /// }\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// let key = "a";\n    /// let hash = compute_hash(map.hasher(), &key);\n    /// let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_hash(hash, |k| k == &key);\n    /// entry.insert(key, 100);\n    /// assert_eq!(map[&"a"], 100);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[allow(clippy::wrong_self_convention)]\n    pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<\'a, K, V, S, A>\n    where\n        for<\'b> F: FnMut(&\'b K) -> bool,\n    {\n        self.search(hash, is_match)\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn search<F>(self, hash: u64, mut is_match: F) -> RawEntryMut<\'a, K, V, S, A>\n    where\n        for<\'b> F: FnMut(&\'b K) -> bool,\n    {\n        match self.map.table.find(hash, |(k, _)| is_match(k)) {\n            Some(elem) => RawEntryMut::Occupied(RawOccupiedEntryMut {\n                elem,\n                table: &mut self.map.table,\n                hash_builder: &self.map.hash_builder,\n            }),\n            None => RawEntryMut::Vacant(RawVacantEntryMut {\n                table: &mut self.map.table,\n                hash_builder: &self.map.hash_builder,\n            }),\n        }\n    }\n}', 'impl<\'a, K, V, S, A: Allocator> RawEntryBuilderMut<\'a, K, V, S, A> {\n    /// Creates a `RawEntryMut` from the given key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// let key = "a";\n    /// let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_key(&key);\n    /// entry.insert(key, 100);\n    /// assert_eq!(map[&"a"], 100);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[allow(clippy::wrong_self_convention)]\n    pub fn from_key<Q>(self, k: &Q) -> RawEntryMut<\'a, K, V, S, A>\n    where\n        S: BuildHasher,\n        Q: Hash + Equivalent<K> + ?Sized,\n    {\n        let hash = make_hash::<Q, S>(&self.map.hash_builder, k);\n        self.from_key_hashed_nocheck(hash, k)\n    }\n\n    /// Creates a `RawEntryMut` from the given key and its hash.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use core::hash::{BuildHasher, Hash};\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n    ///     use core::hash::Hasher;\n    ///     let mut state = hash_builder.build_hasher();\n    ///     key.hash(&mut state);\n    ///     state.finish()\n    /// }\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// let key = "a";\n    /// let hash = compute_hash(map.hasher(), &key);\n    /// let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n    /// entry.insert(key, 100);\n    /// assert_eq!(map[&"a"], 100);\n    /// ```\n    #[inline]\n    #[allow(clippy::wrong_self_convention)]\n    pub fn from_key_hashed_nocheck<Q>(self, hash: u64, k: &Q) -> RawEntryMut<\'a, K, V, S, A>\n    where\n        Q: Equivalent<K> + ?Sized,\n    {\n        self.from_hash(hash, equivalent(k))\n    }\n}', 'impl<K, V, S, A: Allocator> Debug for RawEntryBuilderMut<\'_, K, V, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("RawEntryBuilder").finish()\n    }\n}'], 'raw_entry::RawEntryMut': ['impl<\'a, K, V, S, A: Allocator> RawEntryMut<\'a, K, V, S, A> {\n    /// Sets the value of the entry, and returns a `RawOccupiedEntryMut`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// let entry = map.raw_entry_mut().from_key("horseyland").insert("horseyland", 37);\n    ///\n    /// assert_eq!(entry.remove_entry(), ("horseyland", 37));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(self, key: K, value: V) -> RawOccupiedEntryMut<\'a, K, V, S, A>\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            RawEntryMut::Occupied(mut entry) => {\n                entry.insert(value);\n                entry\n            }\n            RawEntryMut::Vacant(entry) => entry.insert_entry(key, value),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// mutable references to the key and value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.raw_entry_mut().from_key("poneyland").or_insert("poneyland", 3);\n    /// assert_eq!(map["poneyland"], 3);\n    ///\n    /// *map.raw_entry_mut().from_key("poneyland").or_insert("poneyland", 10).1 *= 2;\n    /// assert_eq!(map["poneyland"], 6);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_insert(self, default_key: K, default_val: V) -> (&\'a mut K, &\'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n            RawEntryMut::Vacant(entry) => entry.insert(default_key, default_val),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns mutable references to the key and value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, String> = HashMap::new();\n    ///\n    /// map.raw_entry_mut().from_key("poneyland").or_insert_with(|| {\n    ///     ("poneyland", "hoho".to_string())\n    /// });\n    ///\n    /// assert_eq!(map["poneyland"], "hoho".to_string());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_insert_with<F>(self, default: F) -> (&\'a mut K, &\'a mut V)\n    where\n        F: FnOnce() -> (K, V),\n        K: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n            RawEntryMut::Vacant(entry) => {\n                let (k, v) = default();\n                entry.insert(k, v)\n            }\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.raw_entry_mut()\n    ///    .from_key("poneyland")\n    ///    .and_modify(|_k, v| { *v += 1 })\n    ///    .or_insert("poneyland", 42);\n    /// assert_eq!(map["poneyland"], 42);\n    ///\n    /// map.raw_entry_mut()\n    ///    .from_key("poneyland")\n    ///    .and_modify(|_k, v| { *v += 1 })\n    ///    .or_insert("poneyland", 0);\n    /// assert_eq!(map["poneyland"], 43);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut K, &mut V),\n    {\n        match self {\n            RawEntryMut::Occupied(mut entry) => {\n                {\n                    let (k, v) = entry.get_key_value_mut();\n                    f(k, v);\n                }\n                RawEntryMut::Occupied(entry)\n            }\n            RawEntryMut::Vacant(entry) => RawEntryMut::Vacant(entry),\n        }\n    }\n\n    /// Provides shared access to the key and owned access to the value of\n    /// an occupied entry and allows to replace or remove it based on the\n    /// value of the returned option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashMap;\n    /// use hashbrown::hash_map::RawEntryMut;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// let entry = map\n    ///     .raw_entry_mut()\n    ///     .from_key("poneyland")\n    ///     .and_replace_entry_with(|_k, _v| panic!());\n    ///\n    /// match entry {\n    ///     RawEntryMut::Vacant(_) => {},\n    ///     RawEntryMut::Occupied(_) => panic!(),\n    /// }\n    ///\n    /// map.insert("poneyland", 42);\n    ///\n    /// let entry = map\n    ///     .raw_entry_mut()\n    ///     .from_key("poneyland")\n    ///     .and_replace_entry_with(|k, v| {\n    ///         assert_eq!(k, &"poneyland");\n    ///         assert_eq!(v, 42);\n    ///         Some(v + 1)\n    ///     });\n    ///\n    /// match entry {\n    ///     RawEntryMut::Occupied(e) => {\n    ///         assert_eq!(e.key(), &"poneyland");\n    ///         assert_eq!(e.get(), &43);\n    ///     },\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    /// }\n    ///\n    /// assert_eq!(map["poneyland"], 43);\n    ///\n    /// let entry = map\n    ///     .raw_entry_mut()\n    ///     .from_key("poneyland")\n    ///     .and_replace_entry_with(|_k, _v| None);\n    ///\n    /// match entry {\n    ///     RawEntryMut::Vacant(_) => {},\n    ///     RawEntryMut::Occupied(_) => panic!(),\n    /// }\n    ///\n    /// assert!(!map.contains_key("poneyland"));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn and_replace_entry_with<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&K, V) -> Option<V>,\n    {\n        match self {\n            RawEntryMut::Occupied(entry) => entry.replace_entry_with(f),\n            RawEntryMut::Vacant(_) => self,\n        }\n    }\n}', 'impl<K: Debug, V: Debug, S, A: Allocator> Debug for RawEntryMut<\'_, K, V, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match *self {\n            RawEntryMut::Vacant(ref v) => f.debug_tuple("RawEntry").field(v).finish(),\n            RawEntryMut::Occupied(ref o) => f.debug_tuple("RawEntry").field(o).finish(),\n        }\n    }\n}'], 'raw_entry::RawOccupiedEntryMut': ['impl<\'a, K, V, S, A: Allocator> RawOccupiedEntryMut<\'a, K, V, S, A> {\n    /// Gets a reference to the key in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    ///\n    /// match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(o) => assert_eq!(o.key(), &"a")\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn key(&self) -> &K {\n        unsafe { &self.elem.as_ref().0 }\n    }\n\n    /// Gets a mutable reference to the key in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    /// use std::rc::Rc;\n    ///\n    /// let key_one = Rc::new("a");\n    /// let key_two = Rc::new("a");\n    ///\n    /// let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n    /// map.insert(key_one.clone(), 10);\n    ///\n    /// assert_eq!(map[&key_one], 10);\n    /// assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n    ///\n    /// match map.raw_entry_mut().from_key(&key_one) {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(mut o) => {\n    ///         *o.key_mut() = key_two.clone();\n    ///     }\n    /// }\n    /// assert_eq!(map[&key_two], 10);\n    /// assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn key_mut(&mut self) -> &mut K {\n        unsafe { &mut self.elem.as_mut().0 }\n    }\n\n    /// Converts the entry into a mutable reference to the key in the entry\n    /// with a lifetime bound to the map itself.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    /// use std::rc::Rc;\n    ///\n    /// let key_one = Rc::new("a");\n    /// let key_two = Rc::new("a");\n    ///\n    /// let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n    /// map.insert(key_one.clone(), 10);\n    ///\n    /// assert_eq!(map[&key_one], 10);\n    /// assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n    ///\n    /// let inside_key: &mut Rc<&str>;\n    ///\n    /// match map.raw_entry_mut().from_key(&key_one) {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(o) => inside_key = o.into_key(),\n    /// }\n    /// *inside_key = key_two.clone();\n    ///\n    /// assert_eq!(map[&key_two], 10);\n    /// assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn into_key(self) -> &\'a mut K {\n        unsafe { &mut self.elem.as_mut().0 }\n    }\n\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    ///\n    /// match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(o) => assert_eq!(o.get(), &100),\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get(&self) -> &V {\n        unsafe { &self.elem.as_ref().1 }\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    ///\n    /// let value: &mut u32;\n    ///\n    /// match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(o) => value = o.into_mut(),\n    /// }\n    /// *value += 900;\n    ///\n    /// assert_eq!(map[&"a"], 1000);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn into_mut(self) -> &\'a mut V {\n        unsafe { &mut self.elem.as_mut().1 }\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    ///\n    /// match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(mut o) => *o.get_mut() += 900,\n    /// }\n    ///\n    /// assert_eq!(map[&"a"], 1000);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get_mut(&mut self) -> &mut V {\n        unsafe { &mut self.elem.as_mut().1 }\n    }\n\n    /// Gets a reference to the key and value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    ///\n    /// match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(o) => assert_eq!(o.get_key_value(), (&"a", &100)),\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get_key_value(&self) -> (&K, &V) {\n        unsafe {\n            let (key, value) = self.elem.as_ref();\n            (key, value)\n        }\n    }\n\n    /// Gets a mutable reference to the key and value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    /// use std::rc::Rc;\n    ///\n    /// let key_one = Rc::new("a");\n    /// let key_two = Rc::new("a");\n    ///\n    /// let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n    /// map.insert(key_one.clone(), 10);\n    ///\n    /// assert_eq!(map[&key_one], 10);\n    /// assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n    ///\n    /// match map.raw_entry_mut().from_key(&key_one) {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(mut o) => {\n    ///         let (inside_key, inside_value) = o.get_key_value_mut();\n    ///         *inside_key = key_two.clone();\n    ///         *inside_value = 100;\n    ///     }\n    /// }\n    /// assert_eq!(map[&key_two], 100);\n    /// assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {\n        unsafe {\n            let &mut (ref mut key, ref mut value) = self.elem.as_mut();\n            (key, value)\n        }\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the key and value in the entry\n    /// with a lifetime bound to the map itself.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    /// use std::rc::Rc;\n    ///\n    /// let key_one = Rc::new("a");\n    /// let key_two = Rc::new("a");\n    ///\n    /// let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n    /// map.insert(key_one.clone(), 10);\n    ///\n    /// assert_eq!(map[&key_one], 10);\n    /// assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n    ///\n    /// let inside_key: &mut Rc<&str>;\n    /// let inside_value: &mut u32;\n    /// match map.raw_entry_mut().from_key(&key_one) {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(o) => {\n    ///         let tuple = o.into_key_value();\n    ///         inside_key = tuple.0;\n    ///         inside_value = tuple.1;\n    ///     }\n    /// }\n    /// *inside_key = key_two.clone();\n    /// *inside_value = 100;\n    /// assert_eq!(map[&key_two], 100);\n    /// assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn into_key_value(self) -> (&\'a mut K, &\'a mut V) {\n        unsafe {\n            let &mut (ref mut key, ref mut value) = self.elem.as_mut();\n            (key, value)\n        }\n    }\n\n    /// Sets the value of the entry, and returns the entry\'s old value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    ///\n    /// match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(mut o) => assert_eq!(o.insert(1000), 100),\n    /// }\n    ///\n    /// assert_eq!(map[&"a"], 1000);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(&mut self, value: V) -> V {\n        mem::replace(self.get_mut(), value)\n    }\n\n    /// Sets the value of the entry, and returns the entry\'s old value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    /// use std::rc::Rc;\n    ///\n    /// let key_one = Rc::new("a");\n    /// let key_two = Rc::new("a");\n    ///\n    /// let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n    /// map.insert(key_one.clone(), 10);\n    ///\n    /// assert_eq!(map[&key_one], 10);\n    /// assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n    ///\n    /// match map.raw_entry_mut().from_key(&key_one) {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(mut o) => {\n    ///         let old_key = o.insert_key(key_two.clone());\n    ///         assert!(Rc::ptr_eq(&old_key, &key_one));\n    ///     }\n    /// }\n    /// assert_eq!(map[&key_two], 10);\n    /// assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert_key(&mut self, key: K) -> K {\n        mem::replace(self.key_mut(), key)\n    }\n\n    /// Takes the value out of the entry, and returns it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    ///\n    /// match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(o) => assert_eq!(o.remove(), 100),\n    /// }\n    /// assert_eq!(map.get(&"a"), None);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn remove(self) -> V {\n        self.remove_entry().1\n    }\n\n    /// Take the ownership of the key and value from the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    ///\n    /// match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(o) => assert_eq!(o.remove_entry(), ("a", 100)),\n    /// }\n    /// assert_eq!(map.get(&"a"), None);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn remove_entry(self) -> (K, V) {\n        unsafe { self.table.remove(self.elem).0 }\n    }\n\n    /// Provides shared access to the key and owned access to the value of\n    /// the entry and allows to replace or remove it based on the\n    /// value of the returned option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    ///\n    /// let raw_entry = match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(o) => o.replace_entry_with(|k, v| {\n    ///         assert_eq!(k, &"a");\n    ///         assert_eq!(v, 100);\n    ///         Some(v + 900)\n    ///     }),\n    /// };\n    /// let raw_entry = match raw_entry {\n    ///     RawEntryMut::Vacant(_) => panic!(),\n    ///     RawEntryMut::Occupied(o) => o.replace_entry_with(|k, v| {\n    ///         assert_eq!(k, &"a");\n    ///         assert_eq!(v, 1000);\n    ///         None\n    ///     }),\n    /// };\n    /// match raw_entry {\n    ///     RawEntryMut::Vacant(_) => { },\n    ///     RawEntryMut::Occupied(_) => panic!(),\n    /// };\n    /// assert_eq!(map.get(&"a"), None);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn replace_entry_with<F>(self, f: F) -> RawEntryMut<\'a, K, V, S, A>\n    where\n        F: FnOnce(&K, V) -> Option<V>,\n    {\n        unsafe {\n            let still_occupied = self\n                .table\n                .replace_bucket_with(self.elem.clone(), |(key, value)| {\n                    f(&key, value).map(|new_value| (key, new_value))\n                });\n\n            if still_occupied {\n                RawEntryMut::Occupied(self)\n            } else {\n                RawEntryMut::Vacant(RawVacantEntryMut {\n                    table: self.table,\n                    hash_builder: self.hash_builder,\n                })\n            }\n        }\n    }\n}', 'impl<K: Debug, V: Debug, S, A: Allocator> Debug for RawOccupiedEntryMut<\'_, K, V, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("RawOccupiedEntryMut")\n            .field("key", self.key())\n            .field("value", self.get())\n            .finish()\n    }\n}', "unsafe impl<K, V, S, A> Send for RawOccupiedEntryMut<'_, K, V, S, A>\nwhere\n    K: Send,\n    V: Send,\n    S: Send,\n    A: Send + Allocator,\n{\n}", "unsafe impl<K, V, S, A> Sync for RawOccupiedEntryMut<'_, K, V, S, A>\nwhere\n    K: Sync,\n    V: Sync,\n    S: Sync,\n    A: Sync + Allocator,\n{\n}"], 'raw_entry::RawVacantEntryMut': ['impl<\'a, K, V, S, A: Allocator> RawVacantEntryMut<\'a, K, V, S, A> {\n    /// Sets the value of the entry with the `VacantEntry`\'s key,\n    /// and returns a mutable reference to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    ///\n    /// match map.raw_entry_mut().from_key(&"c") {\n    ///     RawEntryMut::Occupied(_) => panic!(),\n    ///     RawEntryMut::Vacant(v) => assert_eq!(v.insert("c", 300), (&mut "c", &mut 300)),\n    /// }\n    ///\n    /// assert_eq!(map[&"c"], 300);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(self, key: K, value: V) -> (&\'a mut K, &\'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        let hash = make_hash::<K, S>(self.hash_builder, &key);\n        self.insert_hashed_nocheck(hash, key, value)\n    }\n\n    /// Sets the value of the entry with the `VacantEntry`\'s key,\n    /// and returns a mutable reference to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use core::hash::{BuildHasher, Hash};\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n    ///     use core::hash::Hasher;\n    ///     let mut state = hash_builder.build_hasher();\n    ///     key.hash(&mut state);\n    ///     state.finish()\n    /// }\n    ///\n    /// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n    /// let key = "c";\n    /// let hash = compute_hash(map.hasher(), &key);\n    ///\n    /// match map.raw_entry_mut().from_key_hashed_nocheck(hash, &key) {\n    ///     RawEntryMut::Occupied(_) => panic!(),\n    ///     RawEntryMut::Vacant(v) => assert_eq!(\n    ///         v.insert_hashed_nocheck(hash, key, 300),\n    ///         (&mut "c", &mut 300)\n    ///     ),\n    /// }\n    ///\n    /// assert_eq!(map[&"c"], 300);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[allow(clippy::shadow_unrelated)]\n    pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&\'a mut K, &\'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        let &mut (ref mut k, ref mut v) = self.table.insert_entry(\n            hash,\n            (key, value),\n            make_hasher::<_, V, S>(self.hash_builder),\n        );\n        (k, v)\n    }\n\n    /// Set the value of an entry with a custom hasher function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use core::hash::{BuildHasher, Hash};\n    /// use hashbrown::hash_map::{HashMap, RawEntryMut};\n    ///\n    /// fn make_hasher<K, S>(hash_builder: &S) -> impl Fn(&K) -> u64 + \'_\n    /// where\n    ///     K: Hash + ?Sized,\n    ///     S: BuildHasher,\n    /// {\n    ///     move |key: &K| {\n    ///         use core::hash::Hasher;\n    ///         let mut state = hash_builder.build_hasher();\n    ///         key.hash(&mut state);\n    ///         state.finish()\n    ///     }\n    /// }\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// let key = "a";\n    /// let hash_builder = map.hasher().clone();\n    /// let hash = make_hasher(&hash_builder)(&key);\n    ///\n    /// match map.raw_entry_mut().from_hash(hash, |q| q == &key) {\n    ///     RawEntryMut::Occupied(_) => panic!(),\n    ///     RawEntryMut::Vacant(v) => assert_eq!(\n    ///         v.insert_with_hasher(hash, key, 100, make_hasher(&hash_builder)),\n    ///         (&mut "a", &mut 100)\n    ///     ),\n    /// }\n    /// map.extend([("b", 200), ("c", 300), ("d", 400), ("e", 500), ("f", 600)]);\n    /// assert_eq!(map[&"a"], 100);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert_with_hasher<H>(\n        self,\n        hash: u64,\n        key: K,\n        value: V,\n        hasher: H,\n    ) -> (&\'a mut K, &\'a mut V)\n    where\n        H: Fn(&K) -> u64,\n    {\n        let &mut (ref mut k, ref mut v) = self\n            .table\n            .insert_entry(hash, (key, value), |x| hasher(&x.0));\n        (k, v)\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn insert_entry(self, key: K, value: V) -> RawOccupiedEntryMut<\'a, K, V, S, A>\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n        let hash = make_hash::<K, S>(self.hash_builder, &key);\n        let elem = self.table.insert(\n            hash,\n            (key, value),\n            make_hasher::<_, V, S>(self.hash_builder),\n        );\n        RawOccupiedEntryMut {\n            elem,\n            table: self.table,\n            hash_builder: self.hash_builder,\n        }\n    }\n}', 'impl<K, V, S, A: Allocator> Debug for RawVacantEntryMut<\'_, K, V, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("RawVacantEntryMut").finish()\n    }\n}'], 'scopeguard::ScopeGuard': ['impl<T, F> Deref for ScopeGuard<T, F>\nwhere\n    F: FnMut(&mut T),\n{\n    type Target = T;\n    #[inline]\n    fn deref(&self) -> &T {\n        &self.value\n    }\n}', 'impl<T, F> DerefMut for ScopeGuard<T, F>\nwhere\n    F: FnMut(&mut T),\n{\n    #[inline]\n    fn deref_mut(&mut self) -> &mut T {\n        &mut self.value\n    }\n}', 'impl<T, F> Drop for ScopeGuard<T, F>\nwhere\n    F: FnMut(&mut T),\n{\n    #[inline]\n    fn drop(&mut self) {\n        (self.dropfn)(&mut self.value);\n    }\n}', "impl<T, F> ScopeGuard<T, F>\nwhere\n    F: FnMut(&mut T),\n{\n    #[inline]\n    pub fn into_inner(guard: Self) -> T {\n        // Cannot move out of Drop-implementing types, so\n        // ptr::read the value out of a ManuallyDrop<Self>\n        // Don't use mem::forget as that might invalidate value\n        let guard = ManuallyDrop::new(guard);\n        unsafe {\n            let value = ptr::read(&guard.value);\n            // read the closure so that it is dropped\n            let _ = ptr::read(&guard.dropfn);\n            value\n        }\n    }\n}"], 'set::Difference': ['impl<\'a, T, S, A> Iterator for Difference<\'a, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    type Item = &\'a T;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<&\'a T> {\n        loop {\n            let elt = self.iter.next()?;\n            if !self.other.contains(elt) {\n                return Some(elt);\n            }\n        }\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, upper) = self.iter.size_hint();\n        (lower.saturating_sub(self.other.len()), upper)\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, |acc, elt| {\n            if self.other.contains(elt) {\n                acc\n            } else {\n                f(acc, elt)\n            }\n        })\n    }\n}', 'impl<T, S, A: Allocator> Clone for Difference<\'_, T, S, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        Difference {\n            iter: self.iter.clone(),\n            ..*self\n        }\n    }\n}', "impl<T, S, A> FusedIterator for Difference<'_, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n}", "impl<T, S, A> fmt::Debug for Difference<'_, T, S, A>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"], 'set::Drain': ['impl<K, A: Allocator> ExactSizeIterator for Drain<\'_, K, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}', "impl<K, A: Allocator> FusedIterator for Drain<'_, K, A> {}", 'impl<K, A: Allocator> Iterator for Drain<\'_, K, A> {\n    type Item = K;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<K> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.iter.next() {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, |acc, (k, ())| f(acc, k))\n    }\n}', "impl<K: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, K, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let entries_iter = self.iter.iter().map(|(k, _)| k);\n        f.debug_list().entries(entries_iter).finish()\n    }\n}"], 'set::Entry': ['impl<\'a, T, S, A: Allocator> Entry<\'a, T, S, A> {\n    /// Sets the value of the entry, and returns an `OccupiedEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    /// let entry = set.entry("horseyland").insert();\n    ///\n    /// assert_eq!(entry.get(), &"horseyland");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(self) -> OccupiedEntry<\'a, T, S, A>\n    where\n        T: Hash,\n        S: BuildHasher,\n    {\n        match self {\n            Entry::Occupied(entry) => entry,\n            Entry::Vacant(entry) => entry.insert(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting if it was vacant.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    ///\n    /// // nonexistent key\n    /// set.entry("poneyland").or_insert();\n    /// assert!(set.contains("poneyland"));\n    ///\n    /// // existing key\n    /// set.entry("poneyland").or_insert();\n    /// assert!(set.contains("poneyland"));\n    /// assert_eq!(set.len(), 1);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn or_insert(self)\n    where\n        T: Hash,\n        S: BuildHasher,\n    {\n        if let Entry::Vacant(entry) = self {\n            entry.insert();\n        }\n    }\n\n    /// Returns a reference to this entry\'s value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    /// set.entry("poneyland").or_insert();\n    /// // existing key\n    /// assert_eq!(set.entry("poneyland").get(), &"poneyland");\n    /// // nonexistent key\n    /// assert_eq!(set.entry("horseland").get(), &"horseland");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get(&self) -> &T {\n        match *self {\n            Entry::Occupied(ref entry) => entry.get(),\n            Entry::Vacant(ref entry) => entry.get(),\n        }\n    }\n}', 'impl<T: fmt::Debug, S, A: Allocator> fmt::Debug for Entry<\'_, T, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match *self {\n            Entry::Vacant(ref v) => f.debug_tuple("Entry").field(v).finish(),\n            Entry::Occupied(ref o) => f.debug_tuple("Entry").field(o).finish(),\n        }\n    }\n}'], 'set::ExtractIf': ["impl<K, F, A: Allocator> FusedIterator for ExtractIf<'_, K, F, A> where F: FnMut(&K) -> bool {}", 'impl<K, F, A: Allocator> Iterator for ExtractIf<\'_, K, F, A>\nwhere\n    F: FnMut(&K) -> bool,\n{\n    type Item = K;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner\n            .next(|&mut (ref k, ())| (self.f)(k))\n            .map(|(k, ())| k)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.inner.iter.size_hint().1)\n    }\n}'], 'set::HashSet': ['impl<\'a, T, S, A> Extend<&\'a T> for HashSet<T, S, A>\nwhere\n    T: \'a + Eq + Hash + Copy,\n    S: BuildHasher,\n    A: Allocator,\n{\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn extend<I: IntoIterator<Item = &\'a T>>(&mut self, iter: I) {\n        self.extend(iter.into_iter().copied());\n    }\n\n    #[inline]\n    #[cfg(feature = "nightly")]\n    fn extend_one(&mut self, k: &\'a T) {\n        self.map.insert(*k, ());\n    }\n\n    #[inline]\n    #[cfg(feature = "nightly")]\n    fn extend_reserve(&mut self, additional: usize) {\n        Extend::<(T, ())>::extend_reserve(&mut self.map, additional);\n    }\n}', 'impl<T, A, const N: usize> From<[T; N]> for HashSet<T, DefaultHashBuilder, A>\nwhere\n    T: Eq + Hash,\n    A: Default + Allocator,\n{\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let set1 = HashSet::from([1, 2, 3, 4]);\n    /// let set2: HashSet<_> = [1, 2, 3, 4].into();\n    /// assert_eq!(set1, set2);\n    /// ```\n    fn from(arr: [T; N]) -> Self {\n        arr.into_iter().collect()\n    }\n}', 'impl<T, S, A: Allocator> HashSet<T, S, A> {\n    /// Returns the number of elements the set can hold without reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(100);\n    /// assert!(set.capacity() >= 100);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn capacity(&self) -> usize {\n        self.map.capacity()\n    }\n\n    /// An iterator visiting all elements in arbitrary order.\n    /// The iterator element type is `&\'a T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let mut set = HashSet::new();\n    /// set.insert("a");\n    /// set.insert("b");\n    ///\n    /// // Will print in an arbitrary order.\n    /// for x in set.iter() {\n    ///     println!("{}", x);\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn iter(&self) -> Iter<\'_, T> {\n        Iter {\n            iter: self.map.keys(),\n        }\n    }\n\n    /// Returns the number of elements in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// assert_eq!(v.len(), 0);\n    /// v.insert(1);\n    /// assert_eq!(v.len(), 1);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn len(&self) -> usize {\n        self.map.len()\n    }\n\n    /// Returns `true` if the set contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// assert!(v.is_empty());\n    /// v.insert(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn is_empty(&self) -> bool {\n        self.map.is_empty()\n    }\n\n    /// Clears the set, returning all elements in an iterator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// assert!(!set.is_empty());\n    ///\n    /// // print 1, 2, 3 in an arbitrary order\n    /// for i in set.drain() {\n    ///     println!("{}", i);\n    /// }\n    ///\n    /// assert!(set.is_empty());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn drain(&mut self) -> Drain<\'_, T, A> {\n        Drain {\n            iter: self.map.drain(),\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let xs = [1,2,3,4,5,6];\n    /// let mut set: HashSet<i32> = xs.into_iter().collect();\n    /// set.retain(|&k| k % 2 == 0);\n    /// assert_eq!(set.len(), 3);\n    /// ```\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n        self.map.retain(|k, _| f(k));\n    }\n\n    /// Drains elements which are true under the given predicate,\n    /// and returns an iterator over the removed items.\n    ///\n    /// In other words, move all elements `e` such that `f(&e)` returns `true` out\n    /// into another iterator.\n    ///\n    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n    /// or the iteration short-circuits, then the remaining elements will be retained.\n    /// Use [`retain()`] with a negated predicate if you do not need the returned iterator.\n    ///\n    /// [`retain()`]: HashSet::retain\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<i32> = (0..8).collect();\n    /// let drained: HashSet<i32> = set.extract_if(|v| v % 2 == 0).collect();\n    ///\n    /// let mut evens = drained.into_iter().collect::<Vec<_>>();\n    /// let mut odds = set.into_iter().collect::<Vec<_>>();\n    /// evens.sort();\n    /// odds.sort();\n    ///\n    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn extract_if<F>(&mut self, f: F) -> ExtractIf<\'_, T, F, A>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        ExtractIf {\n            f,\n            inner: RawExtractIf {\n                iter: unsafe { self.map.table.iter() },\n                table: &mut self.map.table,\n            },\n        }\n    }\n\n    /// Clears the set, removing all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// v.insert(1);\n    /// v.clear();\n    /// assert!(v.is_empty());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn clear(&mut self) {\n        self.map.clear();\n    }\n}', 'impl<T, S, A: Allocator> IntoIterator for HashSet<T, S, A> {\n    type Item = T;\n    type IntoIter = IntoIter<T, A>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out\n    /// of the set in arbitrary order. The set cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let mut set = HashSet::new();\n    /// set.insert("a".to_string());\n    /// set.insert("b".to_string());\n    ///\n    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n    /// let v: Vec<String> = set.into_iter().collect();\n    ///\n    /// // Will print in an arbitrary order.\n    /// for x in &v {\n    ///     println!("{}", x);\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn into_iter(self) -> IntoIter<T, A> {\n        IntoIter {\n            iter: self.map.into_iter(),\n        }\n    }\n}', 'impl<T, S, A> BitAndAssign<&HashSet<T, S, A>> for HashSet<T, S, A>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher,\n    A: Allocator,\n{\n    /// Modifies this set to contain the intersection of `self` and `rhs`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n    ///\n    /// a &= &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [2, 3];\n    /// for x in &a {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitand_assign(&mut self, rhs: &HashSet<T, S, A>) {\n        self.retain(|item| rhs.contains(item));\n    }\n}', 'impl<T, S, A> BitOrAssign<&HashSet<T, S, A>> for HashSet<T, S, A>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher,\n    A: Allocator,\n{\n    /// Modifies this set to contain the union of `self` and `rhs`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// a |= &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2, 3, 4, 5];\n    /// for x in &a {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitor_assign(&mut self, rhs: &HashSet<T, S, A>) {\n        for item in rhs {\n            if !self.contains(item) {\n                self.insert(item.clone());\n            }\n        }\n    }\n}', 'impl<T, S, A> BitXorAssign<&HashSet<T, S, A>> for HashSet<T, S, A>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher,\n    A: Allocator,\n{\n    /// Modifies this set to contain the symmetric difference of `self` and `rhs`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// a ^= &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2, 4, 5];\n    /// for x in &a {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitxor_assign(&mut self, rhs: &HashSet<T, S, A>) {\n        for item in rhs {\n            let hash = make_hash(&self.map.hash_builder, item);\n            match self.map.find_or_find_insert_slot(hash, item) {\n                Ok(bucket) => unsafe {\n                    self.map.table.remove(bucket);\n                },\n                Err(slot) => unsafe {\n                    self.map\n                        .table\n                        .insert_in_slot(hash, slot, (item.clone(), ()));\n                },\n            }\n        }\n    }\n}', 'impl<T, S, A> Default for HashSet<T, S, A>\nwhere\n    S: Default,\n    A: Default + Allocator,\n{\n    /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Self {\n            map: HashMap::default(),\n        }\n    }\n}', 'impl<T, S, A> Eq for HashSet<T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n}', 'impl<T, S, A> Extend<T> for HashSet<T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        self.map.extend(iter.into_iter().map(|k| (k, ())));\n    }\n\n    #[inline]\n    #[cfg(feature = "nightly")]\n    fn extend_one(&mut self, k: T) {\n        self.map.insert(k, ());\n    }\n\n    #[inline]\n    #[cfg(feature = "nightly")]\n    fn extend_reserve(&mut self, additional: usize) {\n        Extend::<(T, ())>::extend_reserve(&mut self.map, additional);\n    }\n}', 'impl<T, S, A> From<HashMap<T, (), S, A>> for HashSet<T, S, A>\nwhere\n    A: Allocator,\n{\n    fn from(map: HashMap<T, (), S, A>) -> Self {\n        Self { map }\n    }\n}', 'impl<T, S, A> FromIterator<T> for HashSet<T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher + Default,\n    A: Default + Allocator,\n{\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n        let mut set = Self::with_hasher_in(Default::default(), Default::default());\n        set.extend(iter);\n        set\n    }\n}', 'impl<T, S, A> HashSet<T, S, A>\nwhere\n    A: Allocator,\n{\n    /// Returns a reference to the underlying allocator.\n    #[inline]\n    pub fn allocator(&self) -> &A {\n        self.map.allocator()\n    }\n\n    /// Creates a new empty hash set which will use the given hasher to hash\n    /// keys.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not\n    /// allocate until it is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`].\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the `HashSet` to be useful, see its documentation for details.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n    /// let mut set = HashSet::with_hasher(s);\n    /// set.insert(2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[cfg_attr(feature = "rustc-dep-of-std", rustc_const_stable_indirect)]\n    pub const fn with_hasher_in(hasher: S, alloc: A) -> Self {\n        Self {\n            map: HashMap::with_hasher_in(hasher, alloc),\n        }\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity, using\n    /// `hasher` to hash the keys.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`].\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the `HashSet` to be useful, see its documentation for details.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n    /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n    /// set.insert(1);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn with_capacity_and_hasher_in(capacity: usize, hasher: S, alloc: A) -> Self {\n        Self {\n            map: HashMap::with_capacity_and_hasher_in(capacity, hasher, alloc),\n        }\n    }\n\n    /// Returns a reference to the set\'s [`BuildHasher`].\n    ///\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::DefaultHashBuilder;\n    ///\n    /// let hasher = DefaultHashBuilder::default();\n    /// let set: HashSet<i32> = HashSet::with_hasher(hasher);\n    /// let hasher: &DefaultHashBuilder = set.hasher();\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn hasher(&self) -> &S {\n        self.map.hasher()\n    }\n}', 'impl<T, S, A> HashSet<T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the `HashSet`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds [`isize::MAX`] bytes and [`abort`] the program\n    /// in case of allocation error. Use [`try_reserve`](HashSet::try_reserve) instead\n    /// if you want to handle memory allocation failure.\n    ///\n    /// [`isize::MAX`]: https://doc.rust-lang.org/std/primitive.isize.html\n    /// [`abort`]: https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let mut set: HashSet<i32> = HashSet::new();\n    /// set.reserve(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn reserve(&mut self, additional: usize) {\n        self.map.reserve(additional);\n    }\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `HashSet<K,V>`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let mut set: HashSet<i32> = HashSet::new();\n    /// set.try_reserve(10).expect("why is the test harness OOMing on 10 bytes?");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.map.try_reserve(additional)\n    }\n\n    /// Shrinks the capacity of the set as much as possible. It will drop\n    /// down as much as possible while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set = HashSet::with_capacity(100);\n    /// set.insert(1);\n    /// set.insert(2);\n    /// assert!(set.capacity() >= 100);\n    /// set.shrink_to_fit();\n    /// assert!(set.capacity() >= 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn shrink_to_fit(&mut self) {\n        self.map.shrink_to_fit();\n    }\n\n    /// Shrinks the capacity of the set with a lower limit. It will drop\n    /// down no lower than the supplied limit while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// Panics if the current capacity is smaller than the supplied\n    /// minimum capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set = HashSet::with_capacity(100);\n    /// set.insert(1);\n    /// set.insert(2);\n    /// assert!(set.capacity() >= 100);\n    /// set.shrink_to(10);\n    /// assert!(set.capacity() >= 10);\n    /// set.shrink_to(0);\n    /// assert!(set.capacity() >= 2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        self.map.shrink_to(min_capacity);\n    }\n\n    /// Visits the values representing the difference,\n    /// i.e., the values that are in `self` but not in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n    ///\n    /// // Can be seen as `a - b`.\n    /// for x in a.difference(&b) {\n    ///     println!("{}", x); // Print 1\n    /// }\n    ///\n    /// let diff: HashSet<_> = a.difference(&b).collect();\n    /// assert_eq!(diff, [1].iter().collect());\n    ///\n    /// // Note that difference is not symmetric,\n    /// // and `b - a` means something else:\n    /// let diff: HashSet<_> = b.difference(&a).collect();\n    /// assert_eq!(diff, [4].iter().collect());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn difference<\'a>(&\'a self, other: &\'a Self) -> Difference<\'a, T, S, A> {\n        Difference {\n            iter: self.iter(),\n            other,\n        }\n    }\n\n    /// Visits the values representing the symmetric difference,\n    /// i.e., the values that are in `self` or in `other` but not in both.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n    ///\n    /// // Print 1, 4 in arbitrary order.\n    /// for x in a.symmetric_difference(&b) {\n    ///     println!("{}", x);\n    /// }\n    ///\n    /// let diff1: HashSet<_> = a.symmetric_difference(&b).collect();\n    /// let diff2: HashSet<_> = b.symmetric_difference(&a).collect();\n    ///\n    /// assert_eq!(diff1, diff2);\n    /// assert_eq!(diff1, [1, 4].iter().collect());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn symmetric_difference<\'a>(&\'a self, other: &\'a Self) -> SymmetricDifference<\'a, T, S, A> {\n        SymmetricDifference {\n            iter: self.difference(other).chain(other.difference(self)),\n        }\n    }\n\n    /// Visits the values representing the intersection,\n    /// i.e., the values that are both in `self` and `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n    ///\n    /// // Print 2, 3 in arbitrary order.\n    /// for x in a.intersection(&b) {\n    ///     println!("{}", x);\n    /// }\n    ///\n    /// let intersection: HashSet<_> = a.intersection(&b).collect();\n    /// assert_eq!(intersection, [2, 3].iter().collect());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn intersection<\'a>(&\'a self, other: &\'a Self) -> Intersection<\'a, T, S, A> {\n        let (smaller, larger) = if self.len() <= other.len() {\n            (self, other)\n        } else {\n            (other, self)\n        };\n        Intersection {\n            iter: smaller.iter(),\n            other: larger,\n        }\n    }\n\n    /// Visits the values representing the union,\n    /// i.e., all the values in `self` or `other`, without duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n    ///\n    /// // Print 1, 2, 3, 4 in arbitrary order.\n    /// for x in a.union(&b) {\n    ///     println!("{}", x);\n    /// }\n    ///\n    /// let union: HashSet<_> = a.union(&b).collect();\n    /// assert_eq!(union, [1, 2, 3, 4].iter().collect());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn union<\'a>(&\'a self, other: &\'a Self) -> Union<\'a, T, S, A> {\n        // We\'ll iterate one set in full, and only the remaining difference from the other.\n        // Use the smaller set for the difference in order to reduce hash lookups.\n        let (smaller, larger) = if self.len() <= other.len() {\n            (self, other)\n        } else {\n            (other, self)\n        };\n        Union {\n            iter: larger.iter().chain(smaller.difference(larger)),\n        }\n    }\n\n    /// Returns `true` if the set contains a value.\n    ///\n    /// The value may be any borrowed form of the set\'s value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// assert_eq!(set.contains(&1), true);\n    /// assert_eq!(set.contains(&4), false);\n    /// ```\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn contains<Q>(&self, value: &Q) -> bool\n    where\n        Q: Hash + Equivalent<T> + ?Sized,\n    {\n        self.map.contains_key(value)\n    }\n\n    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n    ///\n    /// The value may be any borrowed form of the set\'s value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// assert_eq!(set.get(&2), Some(&2));\n    /// assert_eq!(set.get(&4), None);\n    /// ```\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get<Q>(&self, value: &Q) -> Option<&T>\n    where\n        Q: Hash + Equivalent<T> + ?Sized,\n    {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.map.get_key_value(value) {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }\n\n    /// Inserts the given `value` into the set if it is not present, then\n    /// returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// assert_eq!(set.len(), 3);\n    /// assert_eq!(set.get_or_insert(2), &2);\n    /// assert_eq!(set.get_or_insert(100), &100);\n    /// assert_eq!(set.len(), 4); // 100 was inserted\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get_or_insert(&mut self, value: T) -> &T {\n        let hash = make_hash(&self.map.hash_builder, &value);\n        let bucket = match self.map.find_or_find_insert_slot(hash, &value) {\n            Ok(bucket) => bucket,\n            Err(slot) => unsafe { self.map.table.insert_in_slot(hash, slot, (value, ())) },\n        };\n        unsafe { &bucket.as_ref().0 }\n    }\n\n    /// Inserts a value computed from `f` into the set if the given `value` is\n    /// not present, then returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<String> = ["cat", "dog", "horse"]\n    ///     .iter().map(|&pet| pet.to_owned()).collect();\n    ///\n    /// assert_eq!(set.len(), 3);\n    /// for &pet in &["cat", "dog", "fish"] {\n    ///     let value = set.get_or_insert_with(pet, str::to_owned);\n    ///     assert_eq!(value, pet);\n    /// }\n    /// assert_eq!(set.len(), 4); // a new "fish" was inserted\n    /// ```\n    ///\n    /// The following example will panic because the new value doesn\'t match.\n    ///\n    /// ```should_panic\n    /// let mut set = hashbrown::HashSet::new();\n    /// set.get_or_insert_with("rust", |_| String::new());\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get_or_insert_with<Q, F>(&mut self, value: &Q, f: F) -> &T\n    where\n        Q: Hash + Equivalent<T> + ?Sized,\n        F: FnOnce(&Q) -> T,\n    {\n        let hash = make_hash(&self.map.hash_builder, value);\n        let bucket = match self.map.find_or_find_insert_slot(hash, value) {\n            Ok(bucket) => bucket,\n            Err(slot) => {\n                let new = f(value);\n                assert!(value.equivalent(&new), "new value is not equivalent");\n                unsafe { self.map.table.insert_in_slot(hash, slot, (new, ())) }\n            }\n        };\n        unsafe { &bucket.as_ref().0 }\n    }\n\n    /// Gets the given value\'s corresponding entry in the set for in-place manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::hash_set::Entry::*;\n    ///\n    /// let mut singles = HashSet::new();\n    /// let mut dupes = HashSet::new();\n    ///\n    /// for ch in "a short treatise on fungi".chars() {\n    ///     if let Vacant(dupe_entry) = dupes.entry(ch) {\n    ///         // We haven\'t already seen a duplicate, so\n    ///         // check if we\'ve at least seen it once.\n    ///         match singles.entry(ch) {\n    ///             Vacant(single_entry) => {\n    ///                 // We found a new character for the first time.\n    ///                 single_entry.insert();\n    ///             }\n    ///             Occupied(single_entry) => {\n    ///                 // We\'ve already seen this once, "move" it to dupes.\n    ///                 single_entry.remove();\n    ///                 dupe_entry.insert();\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert!(!singles.contains(&\'t\') && dupes.contains(&\'t\'));\n    /// assert!(singles.contains(&\'u\') && !dupes.contains(&\'u\'));\n    /// assert!(!singles.contains(&\'v\') && !dupes.contains(&\'v\'));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn entry(&mut self, value: T) -> Entry<\'_, T, S, A> {\n        match self.map.entry(value) {\n            map::Entry::Occupied(entry) => Entry::Occupied(OccupiedEntry { inner: entry }),\n            map::Entry::Vacant(entry) => Entry::Vacant(VacantEntry { inner: entry }),\n        }\n    }\n\n    /// Returns `true` if `self` has no elements in common with `other`.\n    /// This is equivalent to checking for an empty intersection.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let mut b = HashSet::new();\n    ///\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(4);\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(1);\n    /// assert_eq!(a.is_disjoint(&b), false);\n    /// ```\n    pub fn is_disjoint(&self, other: &Self) -> bool {\n        self.intersection(other).next().is_none()\n    }\n\n    /// Returns `true` if the set is a subset of another,\n    /// i.e., `other` contains at least all the values in `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let sup: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(2);\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(4);\n    /// assert_eq!(set.is_subset(&sup), false);\n    /// ```\n    pub fn is_subset(&self, other: &Self) -> bool {\n        self.len() <= other.len() && self.iter().all(|v| other.contains(v))\n    }\n\n    /// Returns `true` if the set is a superset of another,\n    /// i.e., `self` contains at least all the values in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let sub: HashSet<_> = [1, 2].into_iter().collect();\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(0);\n    /// set.insert(1);\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.is_superset(&sub), true);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn is_superset(&self, other: &Self) -> bool {\n        other.is_subset(self)\n    }\n\n    /// Adds a value to the set.\n    ///\n    /// If the set did not have this value present, `true` is returned.\n    ///\n    /// If the set did have this value present, `false` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.insert(2), true);\n    /// assert_eq!(set.insert(2), false);\n    /// assert_eq!(set.len(), 1);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(&mut self, value: T) -> bool {\n        self.map.insert(value, ()).is_none()\n    }\n\n    /// Insert a value the set without checking if the value already exists in the set.\n    ///\n    /// This operation is faster than regular insert, because it does not perform\n    /// lookup before insertion.\n    ///\n    /// This operation is useful during initial population of the set.\n    /// For example, when constructing a set from another set, we know\n    /// that values are unique.\n    ///\n    /// # Safety\n    ///\n    /// This operation is safe if a value does not exist in the set.\n    ///\n    /// However, if a value exists in the set already, the behavior is unspecified:\n    /// this operation may panic, loop forever, or any following operation with the set\n    /// may panic, loop forever or return arbitrary result.\n    ///\n    /// That said, this operation (and following operations) are guaranteed to\n    /// not violate memory safety.\n    ///\n    /// However this operation is still unsafe because the resulting `HashSet`\n    /// may be passed to unsafe code which does expect the set to behave\n    /// correctly, and would cause unsoundness as a result.\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub unsafe fn insert_unique_unchecked(&mut self, value: T) -> &T {\n        self.map.insert_unique_unchecked(value, ()).0\n    }\n\n    /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n    /// one. Returns the replaced value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    /// set.insert(Vec::<i32>::new());\n    ///\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 0);\n    /// set.replace(Vec::with_capacity(10));\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 10);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn replace(&mut self, value: T) -> Option<T> {\n        let hash = make_hash(&self.map.hash_builder, &value);\n        match self.map.find_or_find_insert_slot(hash, &value) {\n            Ok(bucket) => Some(mem::replace(unsafe { &mut bucket.as_mut().0 }, value)),\n            Err(slot) => {\n                unsafe {\n                    self.map.table.insert_in_slot(hash, slot, (value, ()));\n                }\n                None\n            }\n        }\n    }\n\n    /// Removes a value from the set. Returns whether the value was\n    /// present in the set.\n    ///\n    /// The value may be any borrowed form of the set\'s value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.remove(&2), true);\n    /// assert_eq!(set.remove(&2), false);\n    /// ```\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn remove<Q>(&mut self, value: &Q) -> bool\n    where\n        Q: Hash + Equivalent<T> + ?Sized,\n    {\n        self.map.remove(value).is_some()\n    }\n\n    /// Removes and returns the value in the set, if any, that is equal to the given one.\n    ///\n    /// The value may be any borrowed form of the set\'s value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].into_iter().collect();\n    /// assert_eq!(set.take(&2), Some(2));\n    /// assert_eq!(set.take(&2), None);\n    /// ```\n    ///\n    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n    /// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn take<Q>(&mut self, value: &Q) -> Option<T>\n    where\n        Q: Hash + Equivalent<T> + ?Sized,\n    {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.map.remove_entry(value) {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }\n\n    /// Returns the total amount of memory allocated internally by the hash\n    /// set, in bytes.\n    ///\n    /// The returned number is informational only. It is intended to be\n    /// primarily used for memory profiling.\n    #[inline]\n    pub fn allocation_size(&self) -> usize {\n        self.map.allocation_size()\n    }\n}', 'impl<T, S, A> PartialEq for HashSet<T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    fn eq(&self, other: &Self) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter().all(|key| other.contains(key))\n    }\n}', 'impl<T, S, A> SubAssign<&HashSet<T, S, A>> for HashSet<T, S, A>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher,\n    A: Allocator,\n{\n    /// Modifies this set to contain the difference of `self` and `rhs`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// a -= &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2];\n    /// for x in &a {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn sub_assign(&mut self, rhs: &HashSet<T, S, A>) {\n        if rhs.len() < self.len() {\n            for item in rhs {\n                self.remove(item);\n            }\n        } else {\n            self.retain(|item| !rhs.contains(item));\n        }\n    }\n}', "impl<T, S, A> fmt::Debug for HashSet<T, S, A>\nwhere\n    T: fmt::Debug,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_set().entries(self.iter()).finish()\n    }\n}", 'impl<T, S> HashSet<T, S, Global> {\n    /// Creates a new empty hash set which will use the given hasher to hash\n    /// keys.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not\n    /// allocate until it is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`].\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the `HashSet` to be useful, see its documentation for details.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n    /// let mut set = HashSet::with_hasher(s);\n    /// set.insert(2);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    #[cfg_attr(feature = "rustc-dep-of-std", rustc_const_stable_indirect)]\n    pub const fn with_hasher(hasher: S) -> Self {\n        Self {\n            map: HashMap::with_hasher(hasher),\n        }\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity, using\n    /// `hasher` to hash the keys.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`].\n    ///\n    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n    /// the `HashSet` to be useful, see its documentation for details.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    /// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::DefaultHashBuilder;\n    ///\n    /// let s = DefaultHashBuilder::default();\n    /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n    /// set.insert(1);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> Self {\n        Self {\n            map: HashMap::with_capacity_and_hasher(capacity, hasher),\n        }\n    }\n}', 'impl<T: Clone, S: Clone, A: Allocator + Clone> Clone for HashSet<T, S, A> {\n    fn clone(&self) -> Self {\n        HashSet {\n            map: self.map.clone(),\n        }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.map.clone_from(&source.map);\n    }\n}', 'impl<T: Hash + Eq, A: Allocator> HashSet<T, DefaultHashBuilder, A> {\n    /// Creates an empty `HashSet`.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`], for example with\n    /// [`with_hasher_in`](HashSet::with_hasher_in) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let set: HashSet<i32> = HashSet::new();\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn new_in(alloc: A) -> Self {\n        Self {\n            map: HashMap::new_in(alloc),\n        }\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`], for example with\n    /// [`with_capacity_and_hasher_in`](HashSet::with_capacity_and_hasher_in) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n        Self {\n            map: HashMap::with_capacity_in(capacity, alloc),\n        }\n    }\n}', 'impl<T> HashSet<T, DefaultHashBuilder> {\n    /// Creates an empty `HashSet`.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`], for example with\n    /// [`with_hasher`](HashSet::with_hasher) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let set: HashSet<i32> = HashSet::new();\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn new() -> Self {\n        Self {\n            map: HashMap::new(),\n        }\n    }\n\n    /// Creates an empty `HashSet` with the specified capacity.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # HashDoS resistance\n    ///\n    /// The `hash_builder` normally use a fixed key by default and that does\n    /// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n    /// Users who require HashDoS resistance should explicitly use\n    /// [`std::collections::hash_map::RandomState`]\n    /// as the hasher when creating a [`HashSet`], for example with\n    /// [`with_capacity_and_hasher`](HashSet::with_capacity_and_hasher) method.\n    ///\n    /// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n    /// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn with_capacity(capacity: usize) -> Self {\n        Self {\n            map: HashMap::with_capacity(capacity),\n        }\n    }\n}'], 'set::Intersection': ['impl<\'a, T, S, A> Iterator for Intersection<\'a, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    type Item = &\'a T;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<&\'a T> {\n        loop {\n            let elt = self.iter.next()?;\n            if self.other.contains(elt) {\n                return Some(elt);\n            }\n        }\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper)\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, |acc, elt| {\n            if self.other.contains(elt) {\n                f(acc, elt)\n            } else {\n                acc\n            }\n        })\n    }\n}', 'impl<T, S, A: Allocator> Clone for Intersection<\'_, T, S, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        Intersection {\n            iter: self.iter.clone(),\n            ..*self\n        }\n    }\n}', "impl<T, S, A> FusedIterator for Intersection<'_, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n}", "impl<T, S, A> fmt::Debug for Intersection<'_, T, S, A>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"], 'set::IntoIter': ['impl<K, A: Allocator> Default for IntoIter<K, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        IntoIter {\n            iter: Default::default(),\n        }\n    }\n}', 'impl<K, A: Allocator> ExactSizeIterator for IntoIter<K, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}', 'impl<K, A: Allocator> FusedIterator for IntoIter<K, A> {}', 'impl<K, A: Allocator> Iterator for IntoIter<K, A> {\n    type Item = K;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<K> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.iter.next() {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, |acc, (k, ())| f(acc, k))\n    }\n}', "impl<K: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<K, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let entries_iter = self.iter.iter().map(|(k, _)| k);\n        f.debug_list().entries(entries_iter).finish()\n    }\n}"], 'set::Iter': ['impl<\'a, K> Iterator for Iter<\'a, K> {\n    type Item = &\'a K;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<&\'a K> {\n        self.iter.next()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, f)\n    }\n}', "impl<K: fmt::Debug> fmt::Debug for Iter<'_, K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}", 'impl<K> Clone for Iter<\'_, K> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        Iter {\n            iter: self.iter.clone(),\n        }\n    }\n}', 'impl<K> Default for Iter<\'_, K> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Iter {\n            iter: Default::default(),\n        }\n    }\n}', 'impl<K> ExactSizeIterator for Iter<\'_, K> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn len(&self) -> usize {\n        self.iter.len()\n    }\n}', "impl<K> FusedIterator for Iter<'_, K> {}"], 'set::OccupiedEntry': ['impl<T, S, A: Allocator> OccupiedEntry<\'_, T, S, A> {\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_set::{Entry, HashSet};\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    /// set.entry("poneyland").or_insert();\n    ///\n    /// match set.entry("poneyland") {\n    ///     Entry::Vacant(_) => panic!(),\n    ///     Entry::Occupied(entry) => assert_eq!(entry.get(), &"poneyland"),\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get(&self) -> &T {\n        self.inner.key()\n    }\n\n    /// Takes the value out of the entry, and returns it.\n    /// Keeps the allocated memory for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::hash_set::Entry;\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    /// // The set is empty\n    /// assert!(set.is_empty() && set.capacity() == 0);\n    ///\n    /// set.entry("poneyland").or_insert();\n    /// let capacity_before_remove = set.capacity();\n    ///\n    /// if let Entry::Occupied(o) = set.entry("poneyland") {\n    ///     assert_eq!(o.remove(), "poneyland");\n    /// }\n    ///\n    /// assert_eq!(set.contains("poneyland"), false);\n    /// // Now set hold none elements but capacity is equal to the old one\n    /// assert!(set.len() == 0 && set.capacity() == capacity_before_remove);\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn remove(self) -> T {\n        self.inner.remove_entry().0\n    }\n}', 'impl<T: fmt::Debug, S, A: Allocator> fmt::Debug for OccupiedEntry<\'_, T, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("OccupiedEntry")\n            .field("value", self.get())\n            .finish()\n    }\n}'], 'set::SymmetricDifference': ['impl<\'a, T, S, A> Iterator for SymmetricDifference<\'a, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    type Item = &\'a T;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<&\'a T> {\n        self.iter.next()\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, f)\n    }\n}', 'impl<T, S, A: Allocator> Clone for SymmetricDifference<\'_, T, S, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        SymmetricDifference {\n            iter: self.iter.clone(),\n        }\n    }\n}', "impl<T, S, A> FusedIterator for SymmetricDifference<'_, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n}", "impl<T, S, A> fmt::Debug for SymmetricDifference<'_, T, S, A>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"], 'set::Union': ['impl<\'a, T, S, A> Iterator for Union<\'a, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    type Item = &\'a T;\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn next(&mut self) -> Option<&\'a T> {\n        self.iter.next()\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.iter.fold(init, f)\n    }\n}', 'impl<T, S, A: Allocator> Clone for Union<\'_, T, S, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Self {\n        Union {\n            iter: self.iter.clone(),\n        }\n    }\n}', "impl<T, S, A> FusedIterator for Union<'_, T, S, A>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n}", "impl<T, S, A> fmt::Debug for Union<'_, T, S, A>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"], 'set::VacantEntry': ['impl<\'a, T, S, A: Allocator> VacantEntry<\'a, T, S, A> {\n    /// Gets a reference to the value that would be used when inserting\n    /// through the `VacantEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    /// assert_eq!(set.entry("poneyland").get(), &"poneyland");\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn get(&self) -> &T {\n        self.inner.key()\n    }\n\n    /// Take ownership of the value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_set::{Entry, HashSet};\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    ///\n    /// match set.entry("poneyland") {\n    ///     Entry::Occupied(_) => panic!(),\n    ///     Entry::Vacant(v) => assert_eq!(v.into_value(), "poneyland"),\n    /// }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn into_value(self) -> T {\n        self.inner.into_key()\n    }\n\n    /// Sets the value of the entry with the `VacantEntry`\'s value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashSet;\n    /// use hashbrown::hash_set::Entry;\n    ///\n    /// let mut set: HashSet<&str> = HashSet::new();\n    ///\n    /// if let Entry::Vacant(o) = set.entry("poneyland") {\n    ///     o.insert();\n    /// }\n    /// assert!(set.contains("poneyland"));\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn insert(self) -> OccupiedEntry<\'a, T, S, A>\n    where\n        T: Hash,\n        S: BuildHasher,\n    {\n        OccupiedEntry {\n            inner: self.inner.insert_entry(()),\n        }\n    }\n}', 'impl<T: fmt::Debug, S, A: Allocator> fmt::Debug for VacantEntry<\'_, T, S, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_tuple("VacantEntry").field(self.get()).finish()\n    }\n}'], 'table::AbsentEntry': ["impl<'a, T, A> AbsentEntry<'a, T, A>\nwhere\n    A: Allocator,\n{\n    /// Converts the `AbsentEntry` into a mutable reference to the underlying\n    /// table.\n    pub fn into_table(self) -> &'a mut HashTable<T, A> {\n        self.table\n    }\n}", 'impl<T: fmt::Debug, A: Allocator> fmt::Debug for AbsentEntry<\'_, T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.write_str("AbsentEntry")\n    }\n}'], 'table::Drain': ["impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}", "impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}", "impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        self.inner.next()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, f)\n    }\n}", "impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list()\n            .entries(Iter {\n                inner: self.inner.iter(),\n                marker: PhantomData,\n            })\n            .finish()\n    }\n}"], 'table::Entry': ['impl<\'a, T, A> Entry<\'a, T, A>\nwhere\n    A: Allocator,\n{\n    /// Sets the value of the entry, replacing any existing value if there is\n    /// one, and returns an [`OccupiedEntry`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<&str> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    ///\n    /// let entry = table\n    ///     .entry(hasher(&"horseyland"), |&x| x == "horseyland", hasher)\n    ///     .insert("horseyland");\n    ///\n    /// assert_eq!(entry.get(), &"horseyland");\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn insert(self, value: T) -> OccupiedEntry<\'a, T, A> {\n        match self {\n            Entry::Occupied(mut entry) => {\n                *entry.get_mut() = value;\n                entry\n            }\n            Entry::Vacant(entry) => entry.insert(value),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting if it was vacant.\n    ///\n    /// Returns an [`OccupiedEntry`] pointing to the now-occupied entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<&str> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    ///\n    /// // nonexistent key\n    /// table\n    ///     .entry(hasher(&"poneyland"), |&x| x == "poneyland", hasher)\n    ///     .or_insert("poneyland");\n    /// assert!(table\n    ///     .find(hasher(&"poneyland"), |&x| x == "poneyland")\n    ///     .is_some());\n    ///\n    /// // existing key\n    /// table\n    ///     .entry(hasher(&"poneyland"), |&x| x == "poneyland", hasher)\n    ///     .or_insert("poneyland");\n    /// assert!(table\n    ///     .find(hasher(&"poneyland"), |&x| x == "poneyland")\n    ///     .is_some());\n    /// assert_eq!(table.len(), 1);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn or_insert(self, default: T) -> OccupiedEntry<\'a, T, A> {\n        match self {\n            Entry::Occupied(entry) => entry,\n            Entry::Vacant(entry) => entry.insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty..\n    ///\n    /// Returns an [`OccupiedEntry`] pointing to the now-occupied entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<String> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    ///\n    /// table\n    ///     .entry(hasher("poneyland"), |x| x == "poneyland", |val| hasher(val))\n    ///     .or_insert_with(|| "poneyland".to_string());\n    ///\n    /// assert!(table\n    ///     .find(hasher(&"poneyland"), |x| x == "poneyland")\n    ///     .is_some());\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn or_insert_with(self, default: impl FnOnce() -> T) -> OccupiedEntry<\'a, T, A> {\n        match self {\n            Entry::Occupied(entry) => entry,\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the table.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<(&str, u32)> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    ///\n    /// table\n    ///     .entry(\n    ///         hasher(&"poneyland"),\n    ///         |&(x, _)| x == "poneyland",\n    ///         |(k, _)| hasher(&k),\n    ///     )\n    ///     .and_modify(|(_, v)| *v += 1)\n    ///     .or_insert(("poneyland", 42));\n    /// assert_eq!(\n    ///     table.find(hasher(&"poneyland"), |&(k, _)| k == "poneyland"),\n    ///     Some(&("poneyland", 42))\n    /// );\n    ///\n    /// table\n    ///     .entry(\n    ///         hasher(&"poneyland"),\n    ///         |&(x, _)| x == "poneyland",\n    ///         |(k, _)| hasher(&k),\n    ///     )\n    ///     .and_modify(|(_, v)| *v += 1)\n    ///     .or_insert(("poneyland", 42));\n    /// assert_eq!(\n    ///     table.find(hasher(&"poneyland"), |&(k, _)| k == "poneyland"),\n    ///     Some(&("poneyland", 43))\n    /// );\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn and_modify(self, f: impl FnOnce(&mut T)) -> Self {\n        match self {\n            Entry::Occupied(mut entry) => {\n                f(entry.get_mut());\n                Entry::Occupied(entry)\n            }\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }\n}', 'impl<T: fmt::Debug, A: Allocator> fmt::Debug for Entry<\'_, T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match *self {\n            Entry::Vacant(ref v) => f.debug_tuple("Entry").field(v).finish(),\n            Entry::Occupied(ref o) => f.debug_tuple("Entry").field(o).finish(),\n        }\n    }\n}'], 'table::ExtractIf': ["impl<T, F, A: Allocator> FusedIterator for ExtractIf<'_, T, F, A> where F: FnMut(&mut T) -> bool {}", "impl<T, F, A: Allocator> Iterator for ExtractIf<'_, T, F, A>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next(|val| (self.f)(val))\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.inner.iter.size_hint().1)\n    }\n}"], 'table::HashTable': ['impl<T, A> Clone for HashTable<T, A>\nwhere\n    T: Clone,\n    A: Allocator + Clone,\n{\n    fn clone(&self) -> Self {\n        Self {\n            raw: self.raw.clone(),\n        }\n    }\n}', 'impl<T, A> Default for HashTable<T, A>\nwhere\n    A: Allocator + Default,\n{\n    fn default() -> Self {\n        Self {\n            raw: Default::default(),\n        }\n    }\n}', 'impl<T, A> HashTable<T, A>\nwhere\n    A: Allocator,\n{\n    /// Creates an empty `HashTable` using the given allocator.\n    ///\n    /// The hash table is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use bumpalo::Bump;\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let bump = Bump::new();\n    /// let mut table = HashTable::new_in(&bump);\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    ///\n    /// // The created HashTable holds none elements\n    /// assert_eq!(table.len(), 0);\n    ///\n    /// // The created HashTable also doesn\'t allocate memory\n    /// assert_eq!(table.capacity(), 0);\n    ///\n    /// // Now we insert element inside created HashTable\n    /// table.insert_unique(hasher(&"One"), "One", hasher);\n    /// // We can see that the HashTable holds 1 element\n    /// assert_eq!(table.len(), 1);\n    /// // And it also allocates some capacity\n    /// assert!(table.capacity() > 1);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub const fn new_in(alloc: A) -> Self {\n        Self {\n            raw: RawTable::new_in(alloc),\n        }\n    }\n\n    /// Creates an empty `HashTable` with the specified capacity using the given allocator.\n    ///\n    /// The hash table will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash table will not allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use bumpalo::Bump;\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let bump = Bump::new();\n    /// let mut table = HashTable::with_capacity_in(5, &bump);\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    ///\n    /// // The created HashTable holds none elements\n    /// assert_eq!(table.len(), 0);\n    /// // But it can hold at least 5 elements without reallocating\n    /// let empty_map_capacity = table.capacity();\n    /// assert!(empty_map_capacity >= 5);\n    ///\n    /// // Now we insert some 5 elements inside created HashTable\n    /// table.insert_unique(hasher(&"One"), "One", hasher);\n    /// table.insert_unique(hasher(&"Two"), "Two", hasher);\n    /// table.insert_unique(hasher(&"Three"), "Three", hasher);\n    /// table.insert_unique(hasher(&"Four"), "Four", hasher);\n    /// table.insert_unique(hasher(&"Five"), "Five", hasher);\n    ///\n    /// // We can see that the HashTable holds 5 elements\n    /// assert_eq!(table.len(), 5);\n    /// // But its capacity isn\'t changed\n    /// assert_eq!(table.capacity(), empty_map_capacity)\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n        Self {\n            raw: RawTable::with_capacity_in(capacity, alloc),\n        }\n    }\n\n    /// Returns a reference to the underlying allocator.\n    pub fn allocator(&self) -> &A {\n        self.raw.allocator()\n    }\n\n    /// Returns a reference to an entry in the table with the given hash and\n    /// which satisfies the equality function passed.\n    ///\n    /// This method will call `eq` for all entries with the given hash, but may\n    /// also call it for entries with a different hash. `eq` should only return\n    /// true for the desired entry, at which point the search is stopped.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&1), 1, hasher);\n    /// table.insert_unique(hasher(&2), 2, hasher);\n    /// table.insert_unique(hasher(&3), 3, hasher);\n    /// assert_eq!(table.find(hasher(&2), |&val| val == 2), Some(&2));\n    /// assert_eq!(table.find(hasher(&4), |&val| val == 4), None);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn find(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T> {\n        self.raw.get(hash, eq)\n    }\n\n    /// Returns a mutable reference to an entry in the table with the given hash\n    /// and which satisfies the equality function passed.\n    ///\n    /// This method will call `eq` for all entries with the given hash, but may\n    /// also call it for entries with a different hash. `eq` should only return\n    /// true for the desired entry, at which point the search is stopped.\n    ///\n    /// When mutating an entry, you should ensure that it still retains the same\n    /// hash value as when it was inserted, otherwise lookups of that entry may\n    /// fail to find it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&1), (1, "a"), |val| hasher(&val.0));\n    /// if let Some(val) = table.find_mut(hasher(&1), |val| val.0 == 1) {\n    ///     val.1 = "b";\n    /// }\n    /// assert_eq!(table.find(hasher(&1), |val| val.0 == 1), Some(&(1, "b")));\n    /// assert_eq!(table.find(hasher(&2), |val| val.0 == 2), None);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn find_mut(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&mut T> {\n        self.raw.get_mut(hash, eq)\n    }\n\n    /// Returns an `OccupiedEntry` for an entry in the table with the given hash\n    /// and which satisfies the equality function passed.\n    ///\n    /// This can be used to remove the entry from the table. Call\n    /// [`HashTable::entry`] instead if you wish to insert an entry if the\n    /// lookup fails.\n    ///\n    /// This method will call `eq` for all entries with the given hash, but may\n    /// also call it for entries with a different hash. `eq` should only return\n    /// true for the desired entry, at which point the search is stopped.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&1), (1, "a"), |val| hasher(&val.0));\n    /// if let Ok(entry) = table.find_entry(hasher(&1), |val| val.0 == 1) {\n    ///     entry.remove();\n    /// }\n    /// assert_eq!(table.find(hasher(&1), |val| val.0 == 1), None);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn find_entry(\n        &mut self,\n        hash: u64,\n        eq: impl FnMut(&T) -> bool,\n    ) -> Result<OccupiedEntry<\'_, T, A>, AbsentEntry<\'_, T, A>> {\n        match self.raw.find(hash, eq) {\n            Some(bucket) => Ok(OccupiedEntry {\n                hash,\n                bucket,\n                table: self,\n            }),\n            None => Err(AbsentEntry { table: self }),\n        }\n    }\n\n    /// Returns an `Entry` for an entry in the table with the given hash\n    /// and which satisfies the equality function passed.\n    ///\n    /// This can be used to remove the entry from the table, or insert a new\n    /// entry with the given hash if one doesn\'t already exist.\n    ///\n    /// This method will call `eq` for all entries with the given hash, but may\n    /// also call it for entries with a different hash. `eq` should only return\n    /// true for the desired entry, at which point the search is stopped.\n    ///\n    /// This method may grow the table in preparation for an insertion. Call\n    /// [`HashTable::find_entry`] if this is undesirable.\n    ///\n    /// `hasher` is called if entries need to be moved or copied to a new table.\n    /// This must return the same hash value that each entry was inserted with.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::hash_table::Entry;\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&1), (1, "a"), |val| hasher(&val.0));\n    /// if let Entry::Occupied(entry) = table.entry(hasher(&1), |val| val.0 == 1, |val| hasher(&val.0))\n    /// {\n    ///     entry.remove();\n    /// }\n    /// if let Entry::Vacant(entry) = table.entry(hasher(&2), |val| val.0 == 2, |val| hasher(&val.0)) {\n    ///     entry.insert((2, "b"));\n    /// }\n    /// assert_eq!(table.find(hasher(&1), |val| val.0 == 1), None);\n    /// assert_eq!(table.find(hasher(&2), |val| val.0 == 2), Some(&(2, "b")));\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn entry(\n        &mut self,\n        hash: u64,\n        eq: impl FnMut(&T) -> bool,\n        hasher: impl Fn(&T) -> u64,\n    ) -> Entry<\'_, T, A> {\n        match self.raw.find_or_find_insert_slot(hash, eq, hasher) {\n            Ok(bucket) => Entry::Occupied(OccupiedEntry {\n                hash,\n                bucket,\n                table: self,\n            }),\n            Err(insert_slot) => Entry::Vacant(VacantEntry {\n                hash,\n                insert_slot,\n                table: self,\n            }),\n        }\n    }\n\n    /// Inserts an element into the `HashTable` with the given hash value, but\n    /// without checking whether an equivalent element already exists within the\n    /// table.\n    ///\n    /// `hasher` is called if entries need to be moved or copied to a new table.\n    /// This must return the same hash value that each entry was inserted with.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut v = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// v.insert_unique(hasher(&1), 1, hasher);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn insert_unique(\n        &mut self,\n        hash: u64,\n        value: T,\n        hasher: impl Fn(&T) -> u64,\n    ) -> OccupiedEntry<\'_, T, A> {\n        let bucket = self.raw.insert(hash, value, hasher);\n        OccupiedEntry {\n            hash,\n            bucket,\n            table: self,\n        }\n    }\n\n    /// Clears the table, removing all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut v = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// v.insert_unique(hasher(&1), 1, hasher);\n    /// v.clear();\n    /// assert!(v.is_empty());\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn clear(&mut self) {\n        self.raw.clear();\n    }\n\n    /// Shrinks the capacity of the table as much as possible. It will drop\n    /// down as much as possible while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// `hasher` is called if entries need to be moved or copied to a new table.\n    /// This must return the same hash value that each entry was inserted with.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::with_capacity(100);\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&1), 1, hasher);\n    /// table.insert_unique(hasher(&2), 2, hasher);\n    /// assert!(table.capacity() >= 100);\n    /// table.shrink_to_fit(hasher);\n    /// assert!(table.capacity() >= 2);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn shrink_to_fit(&mut self, hasher: impl Fn(&T) -> u64) {\n        self.raw.shrink_to(self.len(), hasher)\n    }\n\n    /// Shrinks the capacity of the table with a lower limit. It will drop\n    /// down no lower than the supplied limit while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// `hasher` is called if entries need to be moved or copied to a new table.\n    /// This must return the same hash value that each entry was inserted with.\n    ///\n    /// Panics if the current capacity is smaller than the supplied\n    /// minimum capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::with_capacity(100);\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&1), 1, hasher);\n    /// table.insert_unique(hasher(&2), 2, hasher);\n    /// assert!(table.capacity() >= 100);\n    /// table.shrink_to(10, hasher);\n    /// assert!(table.capacity() >= 10);\n    /// table.shrink_to(0, hasher);\n    /// assert!(table.capacity() >= 2);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn shrink_to(&mut self, min_capacity: usize, hasher: impl Fn(&T) -> u64) {\n        self.raw.shrink_to(min_capacity, hasher);\n    }\n\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the `HashTable`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// `hasher` is called if entries need to be moved or copied to a new table.\n    /// This must return the same hash value that each entry was inserted with.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds [`isize::MAX`] bytes and [`abort`] the program\n    /// in case of allocation error. Use [`try_reserve`](HashTable::try_reserve) instead\n    /// if you want to handle memory allocation failure.\n    ///\n    /// [`isize::MAX`]: https://doc.rust-lang.org/std/primitive.isize.html\n    /// [`abort`]: https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<i32> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.reserve(10, hasher);\n    /// assert!(table.capacity() >= 10);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64) {\n        self.raw.reserve(additional, hasher)\n    }\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `HashTable`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// `hasher` is called if entries need to be moved or copied to a new table.\n    /// This must return the same hash value that each entry was inserted with.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<i32> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table\n    ///     .try_reserve(10, hasher)\n    ///     .expect("why is the test harness OOMing on 10 bytes?");\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn try_reserve(\n        &mut self,\n        additional: usize,\n        hasher: impl Fn(&T) -> u64,\n    ) -> Result<(), TryReserveError> {\n        self.raw.try_reserve(additional, hasher)\n    }\n\n    /// Returns the number of elements the table can hold without reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashTable;\n    /// let table: HashTable<i32> = HashTable::with_capacity(100);\n    /// assert!(table.capacity() >= 100);\n    /// ```\n    pub fn capacity(&self) -> usize {\n        self.raw.capacity()\n    }\n\n    /// Returns the number of elements in the table.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// let mut v = HashTable::new();\n    /// assert_eq!(v.len(), 0);\n    /// v.insert_unique(hasher(&1), 1, hasher);\n    /// assert_eq!(v.len(), 1);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn len(&self) -> usize {\n        self.raw.len()\n    }\n\n    /// Returns `true` if the set contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// let mut v = HashTable::new();\n    /// assert!(v.is_empty());\n    /// v.insert_unique(hasher(&1), 1, hasher);\n    /// assert!(!v.is_empty());\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn is_empty(&self) -> bool {\n        self.raw.is_empty()\n    }\n\n    /// An iterator visiting all elements in arbitrary order.\n    /// The iterator element type is `&\'a T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&"a"), "b", hasher);\n    /// table.insert_unique(hasher(&"b"), "b", hasher);\n    ///\n    /// // Will print in an arbitrary order.\n    /// for x in table.iter() {\n    ///     println!("{}", x);\n    /// }\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn iter(&self) -> Iter<\'_, T> {\n        Iter {\n            inner: unsafe { self.raw.iter() },\n            marker: PhantomData,\n        }\n    }\n\n    /// An iterator visiting all elements in arbitrary order,\n    /// with mutable references to the elements.\n    /// The iterator element type is `&\'a mut T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&1), 1, hasher);\n    /// table.insert_unique(hasher(&2), 2, hasher);\n    /// table.insert_unique(hasher(&3), 3, hasher);\n    ///\n    /// // Update all values\n    /// for val in table.iter_mut() {\n    ///     *val *= 2;\n    /// }\n    ///\n    /// assert_eq!(table.len(), 3);\n    /// let mut vec: Vec<i32> = Vec::new();\n    ///\n    /// for val in &table {\n    ///     println!("val: {}", val);\n    ///     vec.push(*val);\n    /// }\n    ///\n    /// // The `Iter` iterator produces items in arbitrary order, so the\n    /// // items must be sorted to test them against a sorted array.\n    /// vec.sort_unstable();\n    /// assert_eq!(vec, [2, 4, 6]);\n    ///\n    /// assert_eq!(table.len(), 3);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn iter_mut(&mut self) -> IterMut<\'_, T> {\n        IterMut {\n            inner: unsafe { self.raw.iter() },\n            marker: PhantomData,\n        }\n    }\n\n    /// An iterator visiting all elements which may match a hash.\n    /// The iterator element type is `&\'a T`.\n    ///\n    /// This iterator may return elements from the table that have a hash value\n    /// different than the one provided. You should always validate the returned\n    /// values before using them.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&"a"), "a", hasher);\n    /// table.insert_unique(hasher(&"a"), "b", hasher);\n    /// table.insert_unique(hasher(&"b"), "c", hasher);\n    ///\n    /// // Will print "a" and "b" (and possibly "c") in an arbitrary order.\n    /// for x in table.iter_hash(hasher(&"a")) {\n    ///     println!("{}", x);\n    /// }\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn iter_hash(&self, hash: u64) -> IterHash<\'_, T> {\n        IterHash {\n            inner: unsafe { self.raw.iter_hash(hash) },\n            marker: PhantomData,\n        }\n    }\n\n    /// A mutable iterator visiting all elements which may match a hash.\n    /// The iterator element type is `&\'a mut T`.\n    ///\n    /// This iterator may return elements from the table that have a hash value\n    /// different than the one provided. You should always validate the returned\n    /// values before using them.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&1), 2, hasher);\n    /// table.insert_unique(hasher(&1), 3, hasher);\n    /// table.insert_unique(hasher(&2), 5, hasher);\n    ///\n    /// // Update matching values\n    /// for val in table.iter_hash_mut(hasher(&1)) {\n    ///     *val *= 2;\n    /// }\n    ///\n    /// assert_eq!(table.len(), 3);\n    /// let mut vec: Vec<i32> = Vec::new();\n    ///\n    /// for val in &table {\n    ///     println!("val: {}", val);\n    ///     vec.push(*val);\n    /// }\n    ///\n    /// // The values will contain 4 and 6 and may contain either 5 or 10.\n    /// assert!(vec.contains(&4));\n    /// assert!(vec.contains(&6));\n    ///\n    /// assert_eq!(table.len(), 3);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn iter_hash_mut(&mut self, hash: u64) -> IterHashMut<\'_, T> {\n        IterHashMut {\n            inner: unsafe { self.raw.iter_hash(hash) },\n            marker: PhantomData,\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// for x in 1..=6 {\n    ///     table.insert_unique(hasher(&x), x, hasher);\n    /// }\n    /// table.retain(|&mut x| x % 2 == 0);\n    /// assert_eq!(table.len(), 3);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn retain(&mut self, mut f: impl FnMut(&mut T) -> bool) {\n        // Here we only use `iter` as a temporary, preventing use-after-free\n        unsafe {\n            for item in self.raw.iter() {\n                if !f(item.as_mut()) {\n                    self.raw.erase(item);\n                }\n            }\n        }\n    }\n\n    /// Clears the set, returning all elements in an iterator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// for x in 1..=3 {\n    ///     table.insert_unique(hasher(&x), x, hasher);\n    /// }\n    /// assert!(!table.is_empty());\n    ///\n    /// // print 1, 2, 3 in an arbitrary order\n    /// for i in table.drain() {\n    ///     println!("{}", i);\n    /// }\n    ///\n    /// assert!(table.is_empty());\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn drain(&mut self) -> Drain<\'_, T, A> {\n        Drain {\n            inner: self.raw.drain(),\n        }\n    }\n\n    /// Drains elements which are true under the given predicate,\n    /// and returns an iterator over the removed items.\n    ///\n    /// In other words, move all elements `e` such that `f(&e)` returns `true` out\n    /// into another iterator.\n    ///\n    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n    /// or the iteration short-circuits, then the remaining elements will be retained.\n    /// Use [`retain()`] with a negated predicate if you do not need the returned iterator.\n    ///\n    /// [`retain()`]: HashTable::retain\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// for x in 0..8 {\n    ///     table.insert_unique(hasher(&x), x, hasher);\n    /// }\n    /// let drained: Vec<i32> = table.extract_if(|&mut v| v % 2 == 0).collect();\n    ///\n    /// let mut evens = drained.into_iter().collect::<Vec<_>>();\n    /// let mut odds = table.into_iter().collect::<Vec<_>>();\n    /// evens.sort();\n    /// odds.sort();\n    ///\n    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn extract_if<F>(&mut self, f: F) -> ExtractIf<\'_, T, F, A>\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n        ExtractIf {\n            f,\n            inner: RawExtractIf {\n                iter: unsafe { self.raw.iter() },\n                table: &mut self.raw,\n            },\n        }\n    }\n\n    /// Attempts to get mutable references to `N` values in the map at once.\n    ///\n    /// The `eq` argument should be a closure such that `eq(i, k)` returns true if `k` is equal to\n    /// the `i`th key to be looked up.\n    ///\n    /// Returns an array of length `N` with the results of each query. For soundness, at most one\n    /// mutable reference will be returned to any value. `None` will be used if the key is missing.\n    ///\n    /// # Panics\n    ///\n    /// Panics if any keys are overlapping.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::hash_table::Entry;\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut libraries: HashTable<(&str, u32)> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// for (k, v) in [\n    ///     ("Bodleian Library", 1602),\n    ///     ("Athenum", 1807),\n    ///     ("Herzogin-Anna-Amalia-Bibliothek", 1691),\n    ///     ("Library of Congress", 1800),\n    /// ] {\n    ///     libraries.insert_unique(hasher(&k), (k, v), |(k, _)| hasher(&k));\n    /// }\n    ///\n    /// let keys = ["Athenum", "Library of Congress"];\n    /// let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n    /// assert_eq!(\n    ///     got,\n    ///     [Some(&mut ("Athenum", 1807)), Some(&mut ("Library of Congress", 1800))],\n    /// );\n    ///\n    /// // Missing keys result in None\n    /// let keys = ["Athenum", "New York Public Library"];\n    /// let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n    /// assert_eq!(got, [Some(&mut ("Athenum", 1807)), None]);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    ///\n    /// ```should_panic\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// # use hashbrown::{HashTable, DefaultHashBuilder};\n    /// # use std::hash::BuildHasher;\n    ///\n    /// let mut libraries: HashTable<(&str, u32)> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// for (k, v) in [\n    ///     ("Athenum", 1807),\n    ///     ("Library of Congress", 1800),\n    /// ] {\n    ///     libraries.insert_unique(hasher(&k), (k, v), |(k, _)| hasher(&k));\n    /// }\n    ///\n    /// // Duplicate keys result in a panic!\n    /// let keys = ["Athenum", "Athenum"];\n    /// let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test();\n    /// #     #[cfg(not(feature = "nightly"))]\n    /// #     panic!();\n    /// # }\n    /// ```\n    pub fn get_many_mut<const N: usize>(\n        &mut self,\n        hashes: [u64; N],\n        eq: impl FnMut(usize, &T) -> bool,\n    ) -> [Option<&\'_ mut T>; N] {\n        self.raw.get_many_mut(hashes, eq)\n    }\n\n    /// Attempts to get mutable references to `N` values in the map at once, without validating that\n    /// the values are unique.\n    ///\n    /// The `eq` argument should be a closure such that `eq(i, k)` returns true if `k` is equal to\n    /// the `i`th key to be looked up.\n    ///\n    /// Returns an array of length `N` with the results of each query. `None` will be returned if\n    /// any of the keys are missing.\n    ///\n    /// For a safe alternative see [`get_many_mut`](`HashTable::get_many_mut`).\n    ///\n    /// # Safety\n    ///\n    /// Calling this method with overlapping keys is *[undefined behavior]* even if the resulting\n    /// references are not used.\n    ///\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::hash_table::Entry;\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut libraries: HashTable<(&str, u32)> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// for (k, v) in [\n    ///     ("Bodleian Library", 1602),\n    ///     ("Athenum", 1807),\n    ///     ("Herzogin-Anna-Amalia-Bibliothek", 1691),\n    ///     ("Library of Congress", 1800),\n    /// ] {\n    ///     libraries.insert_unique(hasher(&k), (k, v), |(k, _)| hasher(&k));\n    /// }\n    ///\n    /// let keys = ["Athenum", "Library of Congress"];\n    /// let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n    /// assert_eq!(\n    ///     got,\n    ///     [Some(&mut ("Athenum", 1807)), Some(&mut ("Library of Congress", 1800))],\n    /// );\n    ///\n    /// // Missing keys result in None\n    /// let keys = ["Athenum", "New York Public Library"];\n    /// let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n    /// assert_eq!(got, [Some(&mut ("Athenum", 1807)), None]);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub unsafe fn get_many_unchecked_mut<const N: usize>(\n        &mut self,\n        hashes: [u64; N],\n        eq: impl FnMut(usize, &T) -> bool,\n    ) -> [Option<&\'_ mut T>; N] {\n        self.raw.get_many_unchecked_mut(hashes, eq)\n    }\n\n    /// Returns the total amount of memory allocated internally by the hash\n    /// table, in bytes.\n    ///\n    /// The returned number is informational only. It is intended to be\n    /// primarily used for memory profiling.\n    #[inline]\n    pub fn allocation_size(&self) -> usize {\n        self.raw.allocation_size()\n    }\n}', 'impl<T, A> IntoIterator for HashTable<T, A>\nwhere\n    A: Allocator,\n{\n    type Item = T;\n    type IntoIter = IntoIter<T, A>;\n\n    fn into_iter(self) -> IntoIter<T, A> {\n        IntoIter {\n            inner: self.raw.into_iter(),\n        }\n    }\n}', "impl<T, A> fmt::Debug for HashTable<T, A>\nwhere\n    T: fmt::Debug,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_set().entries(self.iter()).finish()\n    }\n}", 'impl<T> HashTable<T, Global> {\n    /// Creates an empty `HashTable`.\n    ///\n    /// The hash table is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashTable;\n    /// let mut table: HashTable<&str> = HashTable::new();\n    /// assert_eq!(table.len(), 0);\n    /// assert_eq!(table.capacity(), 0);\n    /// ```\n    pub const fn new() -> Self {\n        Self {\n            raw: RawTable::new(),\n        }\n    }\n\n    /// Creates an empty `HashTable` with the specified capacity.\n    ///\n    /// The hash table will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash table will not allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::HashTable;\n    /// let mut table: HashTable<&str> = HashTable::with_capacity(10);\n    /// assert_eq!(table.len(), 0);\n    /// assert!(table.capacity() >= 10);\n    /// ```\n    pub fn with_capacity(capacity: usize) -> Self {\n        Self {\n            raw: RawTable::with_capacity(capacity),\n        }\n    }\n}'], 'table::IntoIter': ['impl<T, A: Allocator> Default for IntoIter<T, A> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        IntoIter {\n            inner: Default::default(),\n        }\n    }\n}', 'impl<T, A> ExactSizeIterator for IntoIter<T, A>\nwhere\n    A: Allocator,\n{\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}', 'impl<T, A> FusedIterator for IntoIter<T, A> where A: Allocator {}', 'impl<T, A> Iterator for IntoIter<T, A>\nwhere\n    A: Allocator,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next()\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner.fold(init, f)\n    }\n}', "impl<T, A> fmt::Debug for IntoIter<T, A>\nwhere\n    T: fmt::Debug,\n    A: Allocator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list()\n            .entries(Iter {\n                inner: self.inner.iter(),\n                marker: PhantomData,\n            })\n            .finish()\n    }\n}"], 'table::Iter': ['impl<\'a, T> Clone for Iter<\'a, T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> Iter<\'a, T> {\n        Iter {\n            inner: self.inner.clone(),\n            marker: PhantomData,\n        }\n    }\n}', "impl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(bucket) => Some(unsafe { bucket.as_ref() }),\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner\n            .fold(init, |acc, bucket| unsafe { f(acc, bucket.as_ref()) })\n    }\n}", "impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}", 'impl<T> Default for Iter<\'_, T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        Iter {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }\n}', "impl<T> ExactSizeIterator for Iter<'_, T> {\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}", "impl<T> FusedIterator for Iter<'_, T> {}"], 'table::IterHash': ['impl<\'a, T> Clone for IterHash<\'a, T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn clone(&self) -> IterHash<\'a, T> {\n        IterHash {\n            inner: self.inner.clone(),\n            marker: PhantomData,\n        }\n    }\n}', "impl<'a, T> Iterator for IterHash<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(bucket) => Some(unsafe { bucket.as_ref() }),\n            None => None,\n        }\n    }\n\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner\n            .fold(init, |acc, bucket| unsafe { f(acc, bucket.as_ref()) })\n    }\n}", 'impl<T> Default for IterHash<\'_, T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        IterHash {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }\n}', "impl<T> FusedIterator for IterHash<'_, T> {}", "impl<T> fmt::Debug for IterHash<'_, T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self.clone()).finish()\n    }\n}"], 'table::IterHashMut': ["impl<'a, T> Iterator for IterHashMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(bucket) => Some(unsafe { bucket.as_mut() }),\n            None => None,\n        }\n    }\n\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner\n            .fold(init, |acc, bucket| unsafe { f(acc, bucket.as_mut()) })\n    }\n}", 'impl<T> Default for IterHashMut<\'_, T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        IterHashMut {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }\n}', "impl<T> FusedIterator for IterHashMut<'_, T> {}", "impl<T> fmt::Debug for IterHashMut<'_, T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list()\n            .entries(IterHash {\n                inner: self.inner.clone(),\n                marker: PhantomData,\n            })\n            .finish()\n    }\n}"], 'table::IterMut': ["impl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(bucket) => Some(unsafe { bucket.as_mut() }),\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n\n    fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.inner\n            .fold(init, |acc, bucket| unsafe { f(acc, bucket.as_mut()) })\n    }\n}", 'impl<T> Default for IterMut<\'_, T> {\n    #[cfg_attr(feature = "inline-more", inline)]\n    fn default() -> Self {\n        IterMut {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }\n}', "impl<T> ExactSizeIterator for IterMut<'_, T> {\n    fn len(&self) -> usize {\n        self.inner.len()\n    }\n}", "impl<T> FusedIterator for IterMut<'_, T> {}", "impl<T> fmt::Debug for IterMut<'_, T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list()\n            .entries(Iter {\n                inner: self.inner.clone(),\n                marker: PhantomData,\n            })\n            .finish()\n    }\n}"], 'table::OccupiedEntry': ['impl<\'a, T, A> OccupiedEntry<\'a, T, A>\nwhere\n    A: Allocator,\n{\n    /// Takes the value out of the entry, and returns it along with a\n    /// `VacantEntry` that can be used to insert another value with the same\n    /// hash as the one that was just removed.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::hash_table::Entry;\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<&str> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// // The table is empty\n    /// assert!(table.is_empty() && table.capacity() == 0);\n    ///\n    /// table.insert_unique(hasher(&"poneyland"), "poneyland", hasher);\n    /// let capacity_before_remove = table.capacity();\n    ///\n    /// if let Entry::Occupied(o) = table.entry(hasher(&"poneyland"), |&x| x == "poneyland", hasher) {\n    ///     assert_eq!(o.remove().0, "poneyland");\n    /// }\n    ///\n    /// assert!(table\n    ///     .find(hasher(&"poneyland"), |&x| x == "poneyland")\n    ///     .is_none());\n    /// // Now table hold none elements but capacity is equal to the old one\n    /// assert!(table.len() == 0 && table.capacity() == capacity_before_remove);\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    #[cfg_attr(feature = "inline-more", inline)]\n    pub fn remove(self) -> (T, VacantEntry<\'a, T, A>) {\n        let (val, slot) = unsafe { self.table.raw.remove(self.bucket) };\n        (\n            val,\n            VacantEntry {\n                hash: self.hash,\n                insert_slot: slot,\n                table: self.table,\n            },\n        )\n    }\n\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::hash_table::Entry;\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<&str> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&"poneyland"), "poneyland", hasher);\n    ///\n    /// match table.entry(hasher(&"poneyland"), |&x| x == "poneyland", hasher) {\n    ///     Entry::Vacant(_) => panic!(),\n    ///     Entry::Occupied(entry) => assert_eq!(entry.get(), &"poneyland"),\n    /// }\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    #[inline]\n    pub fn get(&self) -> &T {\n        unsafe { self.bucket.as_ref() }\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// If you need a reference to the `OccupiedEntry` which may outlive the\n    /// destruction of the `Entry` value, see [`into_mut`].\n    ///\n    /// [`into_mut`]: #method.into_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::hash_table::Entry;\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<(&str, u32)> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&"poneyland"), ("poneyland", 12), |(k, _)| hasher(&k));\n    ///\n    /// assert_eq!(\n    ///     table.find(hasher(&"poneyland"), |&(x, _)| x == "poneyland",),\n    ///     Some(&("poneyland", 12))\n    /// );\n    ///\n    /// if let Entry::Occupied(mut o) = table.entry(\n    ///     hasher(&"poneyland"),\n    ///     |&(x, _)| x == "poneyland",\n    ///     |(k, _)| hasher(&k),\n    /// ) {\n    ///     o.get_mut().1 += 10;\n    ///     assert_eq!(o.get().1, 22);\n    ///\n    ///     // We can use the same Entry multiple times.\n    ///     o.get_mut().1 += 2;\n    /// }\n    ///\n    /// assert_eq!(\n    ///     table.find(hasher(&"poneyland"), |&(x, _)| x == "poneyland",),\n    ///     Some(&("poneyland", 24))\n    /// );\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    #[inline]\n    pub fn get_mut(&mut self) -> &mut T {\n        unsafe { self.bucket.as_mut() }\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n    /// with a lifetime bound to the table itself.\n    ///\n    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n    ///\n    /// [`get_mut`]: #method.get_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::hash_table::Entry;\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<(&str, u32)> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// table.insert_unique(hasher(&"poneyland"), ("poneyland", 12), |(k, _)| hasher(&k));\n    ///\n    /// assert_eq!(\n    ///     table.find(hasher(&"poneyland"), |&(x, _)| x == "poneyland",),\n    ///     Some(&("poneyland", 12))\n    /// );\n    ///\n    /// let value: &mut (&str, u32);\n    /// match table.entry(\n    ///     hasher(&"poneyland"),\n    ///     |&(x, _)| x == "poneyland",\n    ///     |(k, _)| hasher(&k),\n    /// ) {\n    ///     Entry::Occupied(entry) => value = entry.into_mut(),\n    ///     Entry::Vacant(_) => panic!(),\n    /// }\n    /// value.1 += 10;\n    ///\n    /// assert_eq!(\n    ///     table.find(hasher(&"poneyland"), |&(x, _)| x == "poneyland",),\n    ///     Some(&("poneyland", 22))\n    /// );\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    pub fn into_mut(self) -> &\'a mut T {\n        unsafe { self.bucket.as_mut() }\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the underlying\n    /// table.\n    pub fn into_table(self) -> &\'a mut HashTable<T, A> {\n        self.table\n    }\n}', 'impl<T: fmt::Debug, A: Allocator> fmt::Debug for OccupiedEntry<\'_, T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.debug_struct("OccupiedEntry")\n            .field("value", self.get())\n            .finish()\n    }\n}', "unsafe impl<T, A> Send for OccupiedEntry<'_, T, A>\nwhere\n    T: Send,\n    A: Send + Allocator,\n{\n}", "unsafe impl<T, A> Sync for OccupiedEntry<'_, T, A>\nwhere\n    T: Sync,\n    A: Sync + Allocator,\n{\n}"], 'table::VacantEntry': ['impl<\'a, T, A> VacantEntry<\'a, T, A>\nwhere\n    A: Allocator,\n{\n    /// Inserts a new element into the table with the hash that was used to\n    /// obtain the `VacantEntry`.\n    ///\n    /// An `OccupiedEntry` is returned for the newly inserted element.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::hash_table::Entry;\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table: HashTable<&str> = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    ///\n    /// if let Entry::Vacant(o) = table.entry(hasher(&"poneyland"), |&x| x == "poneyland", hasher) {\n    ///     o.insert("poneyland");\n    /// }\n    /// assert_eq!(\n    ///     table.find(hasher(&"poneyland"), |&x| x == "poneyland"),\n    ///     Some(&"poneyland")\n    /// );\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    #[inline]\n    pub fn insert(self, value: T) -> OccupiedEntry<\'a, T, A> {\n        let bucket = unsafe {\n            self.table\n                .raw\n                .insert_in_slot(self.hash, self.insert_slot, value)\n        };\n        OccupiedEntry {\n            hash: self.hash,\n            bucket,\n            table: self.table,\n        }\n    }\n\n    /// Converts the `VacantEntry` into a mutable reference to the underlying\n    /// table.\n    pub fn into_table(self) -> &\'a mut HashTable<T, A> {\n        self.table\n    }\n}', 'impl<T: fmt::Debug, A: Allocator> fmt::Debug for VacantEntry<\'_, T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        f.write_str("VacantEntry")\n    }\n}']}, 'single_path_import': {'allocator_api2::alloc::Allocator': 'raw::alloc::inner::Allocator', 'allocator_api2::alloc::Global': 'raw::alloc::inner::Global', 'equivalent::Equivalent': 'Equivalent', 'map::HashMap': 'HashMap', 'set::HashSet': 'HashSet', 'table::HashTable': 'HashTable'}, 'srcs': {"<&'a map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter": ['/// Creates an iterator over the entries of a `HashMap` in arbitrary order.\n/// The iterator element type is `(&\'a K, &\'a V)`.\n///\n/// Return the same `Iter` struct as by the [`iter`] method on [`HashMap`].\n///\n/// [`iter`]: struct.HashMap.html#method.iter\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// let map_one: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n/// let mut map_two = HashMap::new();\n///\n/// for (key, value) in &map_one {\n///     println!("Key: {}, Value: {}", key, value);\n///     map_two.insert(*key, *value);\n/// }\n///\n/// assert_eq!(map_one, map_two);\n/// ```\ninline\nfn into_iter(self) -> Iter<\'a, K, V>{\n        self.iter()\n    }', 'Real(LocalPath("src/map.rs"))'], "<&'a mut map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter": ['/// Creates an iterator over the entries of a `HashMap` in arbitrary order\n/// with mutable references to the values. The iterator element type is\n/// `(&\'a K, &\'a mut V)`.\n///\n/// Return the same `IterMut` struct as by the [`iter_mut`] method on\n/// [`HashMap`].\n///\n/// [`iter_mut`]: struct.HashMap.html#method.iter_mut\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// let mut map: HashMap<_, _> = [("a", 1), ("b", 2), ("c", 3)].into();\n///\n/// for (key, value) in &mut map {\n///     println!("Key: {}, Value: {}", key, value);\n///     *value *= 2;\n/// }\n///\n/// let mut vec = map.iter().collect::<Vec<_>>();\n/// // The `Iter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [(&"a", &2), (&"b", &4), (&"c", &6)]);\n/// ```\ninline\nfn into_iter(self) -> IterMut<\'a, K, V>{\n        self.iter_mut()\n    }', 'Real(LocalPath("src/map.rs"))'], "<&'a mut table::HashTable<T, A> as core::iter::IntoIterator>::into_iter": ["fn into_iter(self) -> IterMut<'a, T>{\n        self.iter_mut()\n    }", 'Real(LocalPath("src/table.rs"))'], "<&'a set::HashSet<T, S, A> as core::iter::IntoIterator>::into_iter": ["inline\nfn into_iter(self) -> Iter<'a, T>{\n        self.iter()\n    }", 'Real(LocalPath("src/set.rs"))'], "<&'a table::HashTable<T, A> as core::iter::IntoIterator>::into_iter": ["fn into_iter(self) -> Iter<'a, T>{\n        self.iter()\n    }", 'Real(LocalPath("src/table.rs"))'], '<&set::HashSet<T, S, A> as core::ops::BitAnd<&set::HashSet<T, S, A>>>::bitand': ['/// Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n///\n/// let set = &a & &b;\n///\n/// let mut i = 0;\n/// let expected = [2, 3];\n/// for x in &set {\n///     assert!(expected.contains(x));\n///     i += 1;\n/// }\n/// assert_eq!(i, expected.len());\n/// ```\nfn bitand(self, rhs: &HashSet<T, S, A>) -> HashSet<T, S, A>{\n        self.intersection(rhs).cloned().collect()\n    }', 'Real(LocalPath("src/set.rs"))'], '<&set::HashSet<T, S, A> as core::ops::BitOr<&set::HashSet<T, S, A>>>::bitor': ['/// Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n///\n/// let set = &a | &b;\n///\n/// let mut i = 0;\n/// let expected = [1, 2, 3, 4, 5];\n/// for x in &set {\n///     assert!(expected.contains(x));\n///     i += 1;\n/// }\n/// assert_eq!(i, expected.len());\n/// ```\nfn bitor(self, rhs: &HashSet<T, S, A>) -> HashSet<T, S, A>{\n        self.union(rhs).cloned().collect()\n    }', 'Real(LocalPath("src/set.rs"))'], '<&set::HashSet<T, S, A> as core::ops::BitXor<&set::HashSet<T, S, A>>>::bitxor': ['/// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n///\n/// let set = &a ^ &b;\n///\n/// let mut i = 0;\n/// let expected = [1, 2, 4, 5];\n/// for x in &set {\n///     assert!(expected.contains(x));\n///     i += 1;\n/// }\n/// assert_eq!(i, expected.len());\n/// ```\nfn bitxor(self, rhs: &HashSet<T, S, A>) -> HashSet<T, S, A>{\n        self.symmetric_difference(rhs).cloned().collect()\n    }', 'Real(LocalPath("src/set.rs"))'], '<&set::HashSet<T, S, A> as core::ops::Sub<&set::HashSet<T, S, A>>>::sub': ['/// Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n///\n/// let set = &a - &b;\n///\n/// let mut i = 0;\n/// let expected = [1, 2];\n/// for x in &set {\n///     assert!(expected.contains(x));\n///     i += 1;\n/// }\n/// assert_eq!(i, expected.len());\n/// ```\nfn sub(self, rhs: &HashSet<T, S, A>) -> HashSet<T, S, A>{\n        self.difference(rhs).cloned().collect()\n    }', 'Real(LocalPath("src/set.rs"))'], '<[control::tag::Tag] as control::tag::TagSliceExt>::fill_tag': ['#[inline]\nfn fill_tag(&mut self, tag: Tag){\n        // SAFETY: We have access to the entire slice, so, we can write to the entire slice.\n        unsafe { self.as_mut_ptr().write_bytes(tag.0, self.len()) }\n    }', 'Real(LocalPath("src/control/tag.rs"))'], '<control::bitmask::BitMask as core::iter::IntoIterator>::into_iter': ['#[inline]\nfn into_iter(self) -> BitMaskIter{\n        // A BitMask only requires each element (group of bits) to be non-zero.\n        // However for iteration we need each element to only contain 1 bit.\n        BitMaskIter(BitMask(self.0 & BITMASK_ITER_MASK))\n    }', 'Real(LocalPath("src/control/bitmask.rs"))'], '<control::bitmask::BitMaskIter as core::iter::Iterator>::next': ['#[inline]\nfn next(&mut self) -> Option<usize>{\n        let bit = self.0.lowest_set_bit()?;\n        self.0 = self.0.remove_lowest_bit();\n        Some(bit)\n    }', 'Real(LocalPath("src/control/bitmask.rs"))'], '<control::tag::Tag as core::fmt::Debug>::fmt': ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        if self.is_special() {\n            if self.special_is_empty() {\n                f.pad("EMPTY")\n            } else {\n                f.pad("DELETED")\n            }\n        } else {\n            f.debug_tuple("full").field(&(self.0 & 0x7F)).finish()\n        }\n    }', 'Real(LocalPath("src/control/tag.rs"))'], "<map::Drain<'_, K, V, A> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.iter()).finish()\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::Drain<'_, K, V, A> as core::iter::ExactSizeIterator>::len": ['inline\nfn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Drain<'_, K, V, A> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, f)\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Drain<'_, K, V, A> as core::iter::Iterator>::next": ['inline\nfn next(&mut self) -> Option<(K, V)>{\n        self.inner.next()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Drain<'_, K, V, A> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Entry<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        match *self {\n            Entry::Vacant(ref v) => f.debug_tuple("Entry").field(v).finish(),\n            Entry::Occupied(ref o) => f.debug_tuple("Entry").field(o).finish(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::EntryRef<'_, '_, K, Q, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        match *self {\n            EntryRef::Vacant(ref v) => f.debug_tuple("EntryRef").field(v).finish(),\n            EntryRef::Occupied(ref o) => f.debug_tuple("EntryRef").field(o).finish(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::ExtractIf<'_, K, V, F, A> as core::iter::Iterator>::next": ['inline\nfn next(&mut self) -> Option<Self::Item>{\n        self.inner.next(|&mut (ref k, ref mut v)| (self.f)(k, v))\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::ExtractIf<'_, K, V, F, A> as core::iter::Iterator>::size_hint": ['#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        (0, self.inner.iter.size_hint().1)\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::HashMap<K, V, S, A> as core::clone::Clone>::clone': ['fn clone(&self) -> Self{\n        HashMap {\n            hash_builder: self.hash_builder.clone(),\n            table: self.table.clone(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::HashMap<K, V, S, A> as core::clone::Clone>::clone_from': ['fn clone_from(&mut self, source: &Self){\n        self.table.clone_from(&source.table);\n\n        // Update hash_builder only if we successfully cloned all elements.\n        self.hash_builder.clone_from(&source.hash_builder);\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::HashMap<K, V, S, A> as core::cmp::PartialEq>::eq': ['fn eq(&self, other: &Self) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter()\n            .all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::HashMap<K, V, S, A> as core::default::Default>::default': ["/// Creates an empty `HashMap<K, V, S, A>`, with the `Default` value for the hasher and allocator.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use std::collections::hash_map::RandomState;\n///\n/// // You can specify all types of HashMap, including hasher and allocator.\n/// // Created map is empty and don't allocate memory\n/// let map: HashMap<u32, String> = Default::default();\n/// assert_eq!(map.capacity(), 0);\n/// let map: HashMap<u32, String, RandomState> = HashMap::default();\n/// assert_eq!(map.capacity(), 0);\n/// ```\ninline\nfn default() -> Self{\n        Self::with_hasher_in(Default::default(), Default::default())\n    }", 'Real(LocalPath("src/map.rs"))'], '<map::HashMap<K, V, S, A> as core::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_map().entries(self.iter()).finish()\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::HashMap<K, V, S, A> as core::iter::Extend<&'a (K, V)>>::extend": ["/// Inserts all new key-values from the iterator to existing `HashMap<K, V, S, A>`.\n/// Replace values with existing keys with new values returned from the iterator.\n/// The keys and values must implement [`Copy`] trait.\n///\n/// [`Copy`]: https://doc.rust-lang.org/core/marker/trait.Copy.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(1, 100);\n///\n/// let arr = [(1, 1), (2, 2)];\n/// let some_iter = arr.iter();\n/// map.extend(some_iter);\n/// // Replace values with existing keys with new values returned from the iterator.\n/// // So that the map.get(&1) doesn't return Some(&100).\n/// assert_eq!(map.get(&1), Some(&1));\n///\n/// let some_vec: Vec<_> = vec![(3, 3), (4, 4)];\n/// map.extend(&some_vec);\n///\n/// let some_arr = [(5, 5), (6, 6)];\n/// map.extend(&some_arr);\n///\n/// let mut vec: Vec<_> = map.into_iter().collect();\n/// // The `IntoIter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]);\n/// ```\ninline\nfn extend<T: IntoIterator<Item = &'a (K, V)>>(&mut self, iter: T){\n        self.extend(iter.into_iter().map(|&(key, value)| (key, value)));\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::HashMap<K, V, S, A> as core::iter::Extend<(&'a K, &'a V)>>::extend": ["/// Inserts all new key-values from the iterator to existing `HashMap<K, V, S, A>`.\n/// Replace values with existing keys with new values returned from the iterator.\n/// The keys and values must implement [`Copy`] trait.\n///\n/// [`Copy`]: https://doc.rust-lang.org/core/marker/trait.Copy.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(1, 100);\n///\n/// let arr = [(1, 1), (2, 2)];\n/// let some_iter = arr.iter().map(|(k, v)| (k, v));\n/// map.extend(some_iter);\n/// // Replace values with existing keys with new values returned from the iterator.\n/// // So that the map.get(&1) doesn't return Some(&100).\n/// assert_eq!(map.get(&1), Some(&1));\n///\n/// let some_vec: Vec<_> = vec![(3, 3), (4, 4)];\n/// map.extend(some_vec.iter().map(|(k, v)| (k, v)));\n///\n/// let some_arr = [(5, 5), (6, 6)];\n/// map.extend(some_arr.iter().map(|(k, v)| (k, v)));\n///\n/// // You can also extend from another HashMap\n/// let mut new_map = HashMap::new();\n/// new_map.extend(&map);\n/// assert_eq!(new_map, map);\n///\n/// let mut vec: Vec<_> = new_map.into_iter().collect();\n/// // The `IntoIter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]);\n/// ```\ninline\nfn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T){\n        self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n    }", 'Real(LocalPath("src/map.rs"))'], '<map::HashMap<K, V, S, A> as core::iter::Extend<(K, V)>>::extend': ["/// Inserts all new key-values from the iterator to existing `HashMap<K, V, S, A>`.\n/// Replace values with existing keys with new values returned from the iterator.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(1, 100);\n///\n/// let some_iter = [(1, 1), (2, 2)].into_iter();\n/// map.extend(some_iter);\n/// // Replace values with existing keys with new values returned from the iterator.\n/// // So that the map.get(&1) doesn't return Some(&100).\n/// assert_eq!(map.get(&1), Some(&1));\n///\n/// let some_vec: Vec<_> = vec![(3, 3), (4, 4)];\n/// map.extend(some_vec);\n///\n/// let some_arr = [(5, 5), (6, 6)];\n/// map.extend(some_arr);\n/// let old_map_len = map.len();\n///\n/// // You can also extend from another HashMap\n/// let mut new_map = HashMap::new();\n/// new_map.extend(map);\n/// assert_eq!(new_map.len(), old_map_len);\n///\n/// let mut vec: Vec<_> = new_map.into_iter().collect();\n/// // The `IntoIter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]);\n/// ```\ninline\nfn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T){\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let iter = iter.into_iter();\n        let reserve = if self.is_empty() {\n            iter.size_hint().0\n        } else {\n            (iter.size_hint().0 + 1) / 2\n        };\n        self.reserve(reserve);\n        iter.for_each(move |(k, v)| {\n            self.insert(k, v);\n        });\n    }", 'Real(LocalPath("src/map.rs"))'], '<map::HashMap<K, V, S, A> as core::iter::FromIterator<(K, V)>>::from_iter': ['inline\nfn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> Self{\n        let iter = iter.into_iter();\n        let mut map =\n            Self::with_capacity_and_hasher_in(iter.size_hint().0, S::default(), A::default());\n        iter.for_each(|(k, v)| {\n            map.insert(k, v);\n        });\n        map\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter': ['/// Creates a consuming iterator, that is, one that moves each key-value\n/// pair out of the map in arbitrary order. The map cannot be used after\n/// calling this.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let map: HashMap<_, _> = [("a", 1), ("b", 2), ("c", 3)].into();\n///\n/// // Not possible with .iter()\n/// let mut vec: Vec<(&str, i32)> = map.into_iter().collect();\n/// // The `IntoIter` iterator produces items in arbitrary order, so\n/// // the items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [("a", 1), ("b", 2), ("c", 3)]);\n/// ```\ninline\nfn into_iter(self) -> IntoIter<K, V, A>{\n        IntoIter {\n            inner: self.table.into_iter(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::HashMap<K, V, S, A> as core::ops::Index<&Q>>::index': ['/// Returns a reference to the value corresponding to the supplied key.\n///\n/// # Panics\n///\n/// Panics if the key is not present in the `HashMap`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let map: HashMap<_, _> = [("a", "One"), ("b", "Two")].into();\n///\n/// assert_eq!(map[&"a"], "One");\n/// assert_eq!(map[&"b"], "Two");\n/// ```\ninline\nfn index(&self, key: &Q) -> &V{\n        self.get(key).expect("no entry found for key")\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::HashMap<K, V, foldhash::fast::RandomState, A> as core::convert::From<[(K, V); N]>>::from': ['/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let map1 = HashMap::from([(1, 2), (3, 4)]);\n/// let map2: HashMap<_, _> = [(1, 2), (3, 4)].into();\n/// assert_eq!(map1, map2);\n/// ```\nfn from(arr: [(K, V); N]) -> Self{\n        arr.into_iter().collect()\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoIter<K, V, A> as core::default::Default>::default': ['inline\nfn default() -> Self{\n        Self {\n            inner: Default::default(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoIter<K, V, A> as core::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.iter()).finish()\n    }", 'Real(LocalPath("src/map.rs"))'], '<map::IntoIter<K, V, A> as core::iter::ExactSizeIterator>::len': ['inline\nfn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoIter<K, V, A> as core::iter::Iterator>::fold': ['inline\nfn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, f)\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoIter<K, V, A> as core::iter::Iterator>::next': ['inline\nfn next(&mut self) -> Option<(K, V)>{\n        self.inner.next()\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoIter<K, V, A> as core::iter::Iterator>::size_hint': ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoKeys<K, V, A> as core::default::Default>::default': ['inline\nfn default() -> Self{\n        Self {\n            inner: Default::default(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoKeys<K, V, A> as core::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list()\n            .entries(self.inner.iter().map(|(k, _)| k))\n            .finish()\n    }", 'Real(LocalPath("src/map.rs"))'], '<map::IntoKeys<K, V, A> as core::iter::ExactSizeIterator>::len': ['#[inline]\nfn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoKeys<K, V, A> as core::iter::Iterator>::fold': ['#[inline]\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, |acc, (k, _)| f(acc, k))\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoKeys<K, V, A> as core::iter::Iterator>::next': ['#[inline]\nfn next(&mut self) -> Option<K>{\n        self.inner.next().map(|(k, _)| k)\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoKeys<K, V, A> as core::iter::Iterator>::size_hint': ['#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoValues<K, V, A> as core::default::Default>::default': ['inline\nfn default() -> Self{\n        Self {\n            inner: Default::default(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoValues<K, V, A> as core::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list()\n            .entries(self.inner.iter().map(|(_, v)| v))\n            .finish()\n    }", 'Real(LocalPath("src/map.rs"))'], '<map::IntoValues<K, V, A> as core::iter::ExactSizeIterator>::len': ['#[inline]\nfn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoValues<K, V, A> as core::iter::Iterator>::fold': ['#[inline]\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, |acc, (_, v)| f(acc, v))\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoValues<K, V, A> as core::iter::Iterator>::next': ['#[inline]\nfn next(&mut self) -> Option<V>{\n        self.inner.next().map(|(_, v)| v)\n    }', 'Real(LocalPath("src/map.rs"))'], '<map::IntoValues<K, V, A> as core::iter::Iterator>::size_hint': ['#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Iter<'_, K, V> as core::clone::Clone>::clone": ['inline\nfn clone(&self) -> Self{\n        Iter {\n            inner: self.inner.clone(),\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Iter<'_, K, V> as core::default::Default>::default": ['inline\nfn default() -> Self{\n        Self {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Iter<'_, K, V> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::Iter<'_, K, V> as core::iter::ExactSizeIterator>::len": ['inline\nfn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Iter<'a, K, V> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, |acc, x| unsafe {\n            let (k, v) = x.as_ref();\n            f(acc, (k, v))\n        })\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Iter<'a, K, V> as core::iter::Iterator>::next": ["inline\nfn next(&mut self) -> Option<(&'a K, &'a V)>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(x) => unsafe {\n                let r = x.as_ref();\n                Some((&r.0, &r.1))\n            },\n            None => None,\n        }\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::Iter<'a, K, V> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::IterMut<'_, K, V> as core::default::Default>::default": ['inline\nfn default() -> Self{\n        Self {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::IterMut<'_, K, V> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.iter()).finish()\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len": ['inline\nfn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::IterMut<'a, K, V> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, |acc, x| unsafe {\n            let (k, v) = x.as_mut();\n            f(acc, (k, v))\n        })\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::IterMut<'a, K, V> as core::iter::Iterator>::next": ["inline\nfn next(&mut self) -> Option<(&'a K, &'a mut V)>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(x) => unsafe {\n                let r = x.as_mut();\n                Some((&r.0, &mut r.1))\n            },\n            None => None,\n        }\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::IterMut<'a, K, V> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Keys<'_, K, V> as core::clone::Clone>::clone": ['inline\nfn clone(&self) -> Self{\n        Keys {\n            inner: self.inner.clone(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Keys<'_, K, V> as core::default::Default>::default": ['inline\nfn default() -> Self{\n        Self {\n            inner: Default::default(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Keys<'_, K, V> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::Keys<'_, K, V> as core::iter::ExactSizeIterator>::len": ['inline\nfn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Keys<'a, K, V> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, |acc, (k, _)| f(acc, k))\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Keys<'a, K, V> as core::iter::Iterator>::next": ["inline\nfn next(&mut self) -> Option<&'a K>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::Keys<'a, K, V> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::OccupiedEntry<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("OccupiedEntry")\n            .field("key", self.key())\n            .field("value", self.get())\n            .finish()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::OccupiedError<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("OccupiedError")\n            .field("key", self.entry.key())\n            .field("old_value", self.entry.get())\n            .field("new_value", &self.value)\n            .finish()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::OccupiedError<'_, K, V, S, A> as core::fmt::Display>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        write!(\n            f,\n            "failed to insert {:?}, key {:?} already exists with value {:?}",\n            self.value,\n            self.entry.key(),\n            self.entry.get(),\n        )\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::VacantEntry<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_tuple("VacantEntry").field(self.key()).finish()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::VacantEntryRef<'_, '_, K, Q, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_tuple("VacantEntryRef").field(&self.key()).finish()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Values<'_, K, V> as core::clone::Clone>::clone": ['inline\nfn clone(&self) -> Self{\n        Values {\n            inner: self.inner.clone(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Values<'_, K, V> as core::default::Default>::default": ['inline\nfn default() -> Self{\n        Self {\n            inner: Default::default(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Values<'_, K, V> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::Values<'_, K, V> as core::iter::ExactSizeIterator>::len": ['inline\nfn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Values<'a, K, V> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, |acc, (_, v)| f(acc, v))\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::Values<'a, K, V> as core::iter::Iterator>::next": ["inline\nfn next(&mut self) -> Option<&'a V>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some((_, v)) => Some(v),\n            None => None,\n        }\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::Values<'a, K, V> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::ValuesMut<'_, K, V> as core::default::Default>::default": ['inline\nfn default() -> Self{\n        Self {\n            inner: Default::default(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::ValuesMut<'_, K, V> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list()\n            .entries(self.inner.iter().map(|(_, val)| val))\n            .finish()\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::ValuesMut<'_, K, V> as core::iter::ExactSizeIterator>::len": ['inline\nfn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, |acc, (_, v)| f(acc, v))\n    }', 'Real(LocalPath("src/map.rs"))'], "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::next": ["inline\nfn next(&mut self) -> Option<&'a mut V>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some((_, v)) => Some(v),\n            None => None,\n        }\n    }", 'Real(LocalPath("src/map.rs"))'], "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/map.rs"))'], '<raw::Bucket<T> as core::clone::Clone>::clone': ['#[inline]\nfn clone(&self) -> Self{\n        Self { ptr: self.ptr }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::FullBucketsIndices as core::iter::Iterator>::next': ['/// Advances the iterator and returns the next value. It is up to\n/// the caller to ensure that the `RawTable` outlives the `FullBucketsIndices`,\n/// because we cannot make the `next` method unsafe.\n#[inline(always)]\nfn next(&mut self) -> Option<usize>{\n        // Return if we already yielded all items.\n        if self.items == 0 {\n            return None;\n        }\n\n        let nxt = unsafe {\n            // SAFETY:\n            // 1. We check number of items to yield using `items` field.\n            // 2. The caller ensures that the table is alive and has not moved.\n            self.next_impl()\n        };\n\n        debug_assert!(nxt.is_some());\n        self.items -= 1;\n\n        nxt\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::FullBucketsIndices as core::iter::Iterator>::size_hint': ['#[inline(always)]\nfn size_hint(&self) -> (usize, Option<usize>){\n        (self.items, Some(self.items))\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], "<raw::RawDrain<'_, T, A> as core::iter::Iterator>::next": ['inline\nfn next(&mut self) -> Option<T>{\n        unsafe {\n            let item = self.iter.next()?;\n            Some(item.read())\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], "<raw::RawDrain<'_, T, A> as core::iter::Iterator>::size_hint": ['#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], "<raw::RawDrain<'_, T, A> as core::ops::Drop>::drop": ['inline\nfn drop(&mut self){\n        unsafe {\n            // Drop all remaining elements. Note that this may panic.\n            self.iter.drop_elements();\n\n            // Reset the contents of the table now that all elements have been\n            // dropped.\n            self.table.clear_no_drop();\n\n            // Move the now empty table back to its original location.\n            self.orig_table\n                .as_ptr()\n                .copy_from_nonoverlapping(&self.table, 1);\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIntoIter<T, A> as core::default::Default>::default': ['fn default() -> Self{\n        Self {\n            iter: Default::default(),\n            allocation: None,\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIntoIter<T, A> as core::iter::Iterator>::next': ['inline\nfn next(&mut self) -> Option<T>{\n        unsafe { Some(self.iter.next()?.read()) }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIntoIter<T, A> as core::iter::Iterator>::size_hint': ['#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIntoIter<T, A> as core::ops::Drop>::drop': ['inline\nfn drop(&mut self){\n        unsafe {\n            // Drop all remaining elements\n            self.iter.drop_elements();\n\n            // Free the table\n            if let Some((ptr, layout, ref alloc)) = self.allocation {\n                alloc.deallocate(ptr, layout);\n            }\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIter<T> as core::clone::Clone>::clone': ['inline\nfn clone(&self) -> Self{\n        Self {\n            iter: self.iter.clone(),\n            items: self.items,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIter<T> as core::default::Default>::default': ['inline\nfn default() -> Self{\n        // SAFETY: Because the table is static, it always outlives the iter.\n        unsafe { RawTableInner::NEW.iter() }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIter<T> as core::iter::Iterator>::fold': ['#[inline]\nfn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        unsafe { self.iter.fold_impl(self.items, init, f) }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIter<T> as core::iter::Iterator>::next': ['inline\nfn next(&mut self) -> Option<Bucket<T>>{\n        // Inner iterator iterates over buckets\n        // so it can do unnecessary work if we already yielded all items.\n        if self.items == 0 {\n            return None;\n        }\n\n        let nxt = unsafe {\n            // SAFETY: We check number of items to yield using `items` field.\n            self.iter.next_impl::<false>()\n        };\n\n        debug_assert!(nxt.is_some());\n        self.items -= 1;\n\n        nxt\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIter<T> as core::iter::Iterator>::size_hint': ['#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        (self.items, Some(self.items))\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIterHash<T> as core::clone::Clone>::clone': ['inline\nfn clone(&self) -> Self{\n        Self {\n            inner: self.inner.clone(),\n            _marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIterHash<T> as core::default::Default>::default': ['inline\nfn default() -> Self{\n        Self {\n            // SAFETY: Because the table is static, it always outlives the iter.\n            inner: unsafe { RawIterHashInner::new(&RawTableInner::NEW, 0) },\n            _marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIterHash<T> as core::iter::Iterator>::next': ["fn next(&mut self) -> Option<Bucket<T>>{\n        unsafe {\n            match self.inner.next() {\n                Some(index) => {\n                    // Can't use `RawTable::bucket` here as we don't have\n                    // an actual `RawTable` reference to use.\n                    debug_assert!(index <= self.inner.bucket_mask);\n                    let bucket = Bucket::from_base_index(self.inner.ctrl.cast(), index);\n                    Some(bucket)\n                }\n                None => None,\n            }\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIterHashInner as core::iter::Iterator>::next': ["fn next(&mut self) -> Option<Self::Item>{\n        unsafe {\n            loop {\n                if let Some(bit) = self.bitmask.next() {\n                    let index = (self.probe_seq.pos + bit) & self.bucket_mask;\n                    return Some(index);\n                }\n                if likely(self.group.match_empty().any_bit_set()) {\n                    return None;\n                }\n                self.probe_seq.move_next(self.bucket_mask);\n\n                // Can't use `RawTableInner::ctrl` here as we don't have\n                // an actual `RawTableInner` reference to use.\n                let index = self.probe_seq.pos;\n                debug_assert!(index < self.bucket_mask + 1 + Group::WIDTH);\n                let group_ctrl = self.ctrl.as_ptr().add(index).cast();\n\n                self.group = Group::load(group_ctrl);\n                self.bitmask = self.group.match_tag(self.tag_hash).into_iter();\n            }\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIterRange<T> as core::clone::Clone>::clone': ['inline\nfn clone(&self) -> Self{\n        Self {\n            data: self.data.clone(),\n            next_ctrl: self.next_ctrl,\n            current_group: self.current_group.clone(),\n            end: self.end,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIterRange<T> as core::iter::Iterator>::next': ['inline\nfn next(&mut self) -> Option<Bucket<T>>{\n        unsafe {\n            // SAFETY: We set checker flag to true.\n            self.next_impl::<true>()\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawIterRange<T> as core::iter::Iterator>::size_hint': ["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        // We don't have an item count, so just guess based on the range size.\n        let remaining_buckets = if self.end > self.next_ctrl {\n            unsafe { offset_from(self.end, self.next_ctrl) }\n        } else {\n            0\n        };\n\n        // Add a group width to include the group we are currently processing.\n        (0, Some(Group::WIDTH + remaining_buckets))\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawTable<T, A> as core::clone::Clone>::clone': ["fn clone(&self) -> Self{\n        if self.table.is_empty_singleton() {\n            Self::new_in(self.alloc.clone())\n        } else {\n            unsafe {\n                // Avoid `Result::ok_or_else` because it bloats LLVM IR.\n                //\n                // SAFETY: This is safe as we are taking the size of an already allocated table\n                // and therefore capacity overflow cannot occur, `self.table.buckets()` is power\n                // of two and all allocator errors will be caught inside `RawTableInner::new_uninitialized`.\n                let mut new_table = match Self::new_uninitialized(\n                    self.alloc.clone(),\n                    self.table.buckets(),\n                    Fallibility::Infallible,\n                ) {\n                    Ok(table) => table,\n                    Err(_) => hint::unreachable_unchecked(),\n                };\n\n                // Cloning elements may fail (the clone function may panic). But we don't\n                // need to worry about uninitialized control bits, since:\n                // 1. The number of items (elements) in the table is zero, which means that\n                //    the control bits will not be read by Drop function.\n                // 2. The `clone_from_spec` method will first copy all control bits from\n                //    `self` (thus initializing them). But this will not affect the `Drop`\n                //    function, since the `clone_from_spec` function sets `items` only after\n                //    successfully cloning all elements.\n                new_table.clone_from_spec(self);\n                new_table\n            }\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawTable<T, A> as core::clone::Clone>::clone_from': ["fn clone_from(&mut self, source: &Self){\n        if source.table.is_empty_singleton() {\n            let mut old_inner = mem::replace(&mut self.table, RawTableInner::NEW);\n            unsafe {\n                // SAFETY:\n                // 1. We call the function only once;\n                // 2. We know for sure that `alloc` and `table_layout` matches the [`Allocator`]\n                //    and [`TableLayout`] that were used to allocate this table.\n                // 3. If any elements' drop function panics, then there will only be a memory leak,\n                //    because we have replaced the inner table with a new one.\n                old_inner.drop_inner_table::<T, _>(&self.alloc, Self::TABLE_LAYOUT);\n            }\n        } else {\n            unsafe {\n                // Make sure that if any panics occurs, we clear the table and\n                // leave it in an empty state.\n                let mut self_ = guard(self, |self_| {\n                    self_.clear_no_drop();\n                });\n\n                // First, drop all our elements without clearing the control\n                // bytes. If this panics then the scope guard will clear the\n                // table, leaking any elements that were not dropped yet.\n                //\n                // This leak is unavoidable: we can't try dropping more elements\n                // since this could lead to another panic and abort the process.\n                //\n                // SAFETY: If something gets wrong we clear our table right after\n                // dropping the elements, so there is no double drop, since `items`\n                // will be equal to zero.\n                self_.table.drop_elements::<T>();\n\n                // If necessary, resize our table to match the source.\n                if self_.buckets() != source.buckets() {\n                    let new_inner = match RawTableInner::new_uninitialized(\n                        &self_.alloc,\n                        Self::TABLE_LAYOUT,\n                        source.buckets(),\n                        Fallibility::Infallible,\n                    ) {\n                        Ok(table) => table,\n                        Err(_) => hint::unreachable_unchecked(),\n                    };\n                    // Replace the old inner with new uninitialized one. It's ok, since if something gets\n                    // wrong `ScopeGuard` will initialize all control bytes and leave empty table.\n                    let mut old_inner = mem::replace(&mut self_.table, new_inner);\n                    if !old_inner.is_empty_singleton() {\n                        // SAFETY:\n                        // 1. We have checked that our table is allocated.\n                        // 2. We know for sure that `alloc` and `table_layout` matches\n                        // the [`Allocator`] and [`TableLayout`] that were used to allocate this table.\n                        old_inner.free_buckets(&self_.alloc, Self::TABLE_LAYOUT);\n                    }\n                }\n\n                // Cloning elements may fail (the clone function may panic), but the `ScopeGuard`\n                // inside the `clone_from_impl` function will take care of that, dropping all\n                // cloned elements if necessary. Our `ScopeGuard` will clear the table.\n                self_.clone_from_spec(source);\n\n                // Disarm the scope guard if cloning was successful.\n                ScopeGuard::into_inner(self_);\n            }\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawTable<T, A> as core::default::Default>::default': ['#[inline]\nfn default() -> Self{\n        Self::new_in(Default::default())\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawTable<T, A> as core::iter::IntoIterator>::into_iter': ['inline\nfn into_iter(self) -> RawIntoIter<T, A>{\n        unsafe {\n            let iter = self.iter();\n            self.into_iter_from(iter)\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawTable<T, A> as core::ops::Drop>::drop': ["inline\nfn drop(&mut self){\n        unsafe {\n            // SAFETY:\n            // 1. We call the function only once;\n            // 2. We know for sure that `alloc` and `table_layout` matches the [`Allocator`]\n            //    and [`TableLayout`] that were used to allocate this table.\n            // 3. If the drop function of any elements fails, then only a memory leak will occur,\n            //    and we don't care because we are inside the `Drop` function of the `RawTable`,\n            //    so there won't be any table left in an inconsistent state.\n            self.table\n                .drop_inner_table::<T, _>(&self.alloc, Self::TABLE_LAYOUT);\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], '<raw::RawTable<T, A> as raw::RawTableClone>::clone_from_spec': ['inline\nunsafe fn clone_from_spec(&mut self, source: &Self){\n            self.clone_from_impl(source);\n        }', 'Real(LocalPath("src/raw/mod.rs"))'], "<raw_entry::RawEntryBuilder<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("RawEntryBuilder").finish()\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "<raw_entry::RawEntryBuilderMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("RawEntryBuilder").finish()\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "<raw_entry::RawEntryMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        match *self {\n            RawEntryMut::Vacant(ref v) => f.debug_tuple("RawEntry").field(v).finish(),\n            RawEntryMut::Occupied(ref o) => f.debug_tuple("RawEntry").field(o).finish(),\n        }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "<raw_entry::RawOccupiedEntryMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("RawOccupiedEntryMut")\n            .field("key", self.key())\n            .field("value", self.get())\n            .finish()\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "<raw_entry::RawVacantEntryMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("RawVacantEntryMut").finish()\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], '<scopeguard::ScopeGuard<T, F> as core::ops::Deref>::deref': ['#[inline]\nfn deref(&self) -> &T{\n        &self.value\n    }', 'Real(LocalPath("src/scopeguard.rs"))'], '<scopeguard::ScopeGuard<T, F> as core::ops::DerefMut>::deref_mut': ['#[inline]\nfn deref_mut(&mut self) -> &mut T{\n        &mut self.value\n    }', 'Real(LocalPath("src/scopeguard.rs"))'], '<scopeguard::ScopeGuard<T, F> as core::ops::Drop>::drop': ['#[inline]\nfn drop(&mut self){\n        (self.dropfn)(&mut self.value);\n    }', 'Real(LocalPath("src/scopeguard.rs"))'], "<set::Difference<'_, T, S, A> as core::clone::Clone>::clone": ['inline\nfn clone(&self) -> Self{\n        Difference {\n            iter: self.iter.clone(),\n            ..*self\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Difference<'_, T, S, A> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::Difference<'a, T, S, A> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.fold(init, |acc, elt| {\n            if self.other.contains(elt) {\n                acc\n            } else {\n                f(acc, elt)\n            }\n        })\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Difference<'a, T, S, A> as core::iter::Iterator>::next": ["inline\nfn next(&mut self) -> Option<&'a T>{\n        loop {\n            let elt = self.iter.next()?;\n            if !self.other.contains(elt) {\n                return Some(elt);\n            }\n        }\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::Difference<'a, T, S, A> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        let (lower, upper) = self.iter.size_hint();\n        (lower.saturating_sub(self.other.len()), upper)\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Drain<'_, K, A> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let entries_iter = self.iter.iter().map(|(k, _)| k);\n        f.debug_list().entries(entries_iter).finish()\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::Drain<'_, K, A> as core::iter::ExactSizeIterator>::len": ['inline\nfn len(&self) -> usize{\n        self.iter.len()\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Drain<'_, K, A> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.fold(init, |acc, (k, ())| f(acc, k))\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Drain<'_, K, A> as core::iter::Iterator>::next": ['inline\nfn next(&mut self) -> Option<K>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.iter.next() {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Drain<'_, K, A> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Entry<'_, T, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        match *self {\n            Entry::Vacant(ref v) => f.debug_tuple("Entry").field(v).finish(),\n            Entry::Occupied(ref o) => f.debug_tuple("Entry").field(o).finish(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::ExtractIf<'_, K, F, A> as core::iter::Iterator>::next": ['inline\nfn next(&mut self) -> Option<Self::Item>{\n        self.inner\n            .next(|&mut (ref k, ())| (self.f)(k))\n            .map(|(k, ())| k)\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::ExtractIf<'_, K, F, A> as core::iter::Iterator>::size_hint": ['#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        (0, self.inner.iter.size_hint().1)\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::clone::Clone>::clone': ['fn clone(&self) -> Self{\n        HashSet {\n            map: self.map.clone(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::clone::Clone>::clone_from': ['fn clone_from(&mut self, source: &Self){\n        self.map.clone_from(&source.map);\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::cmp::PartialEq>::eq': ['fn eq(&self, other: &Self) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.iter().all(|key| other.contains(key))\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::convert::From<map::HashMap<T, (), S, A>>>::from': ['fn from(map: HashMap<T, (), S, A>) -> Self{\n        Self { map }\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::default::Default>::default': ['/// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\ninline\nfn default() -> Self{\n        Self {\n            map: HashMap::default(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_set().entries(self.iter()).finish()\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::HashSet<T, S, A> as core::iter::Extend<&'a T>>::extend": ["inline\nfn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I){\n        self.extend(iter.into_iter().copied());\n    }", 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::iter::Extend<T>>::extend': ['inline\nfn extend<I: IntoIterator<Item = T>>(&mut self, iter: I){\n        self.map.extend(iter.into_iter().map(|k| (k, ())));\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::iter::FromIterator<T>>::from_iter': ['inline\nfn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self{\n        let mut set = Self::with_hasher_in(Default::default(), Default::default());\n        set.extend(iter);\n        set\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::iter::IntoIterator>::into_iter': ['/// Creates a consuming iterator, that is, one that moves each value out\n/// of the set in arbitrary order. The set cannot be used after calling\n/// this.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let mut set = HashSet::new();\n/// set.insert("a".to_string());\n/// set.insert("b".to_string());\n///\n/// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n/// let v: Vec<String> = set.into_iter().collect();\n///\n/// // Will print in an arbitrary order.\n/// for x in &v {\n///     println!("{}", x);\n/// }\n/// ```\ninline\nfn into_iter(self) -> IntoIter<T, A>{\n        IntoIter {\n            iter: self.map.into_iter(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::ops::BitAndAssign<&set::HashSet<T, S, A>>>::bitand_assign': ['/// Modifies this set to contain the intersection of `self` and `rhs`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n///\n/// a &= &b;\n///\n/// let mut i = 0;\n/// let expected = [2, 3];\n/// for x in &a {\n///     assert!(expected.contains(x));\n///     i += 1;\n/// }\n/// assert_eq!(i, expected.len());\n/// ```\nfn bitand_assign(&mut self, rhs: &HashSet<T, S, A>){\n        self.retain(|item| rhs.contains(item));\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::ops::BitOrAssign<&set::HashSet<T, S, A>>>::bitor_assign': ['/// Modifies this set to contain the union of `self` and `rhs`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n///\n/// a |= &b;\n///\n/// let mut i = 0;\n/// let expected = [1, 2, 3, 4, 5];\n/// for x in &a {\n///     assert!(expected.contains(x));\n///     i += 1;\n/// }\n/// assert_eq!(i, expected.len());\n/// ```\nfn bitor_assign(&mut self, rhs: &HashSet<T, S, A>){\n        for item in rhs {\n            if !self.contains(item) {\n                self.insert(item.clone());\n            }\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::ops::BitXorAssign<&set::HashSet<T, S, A>>>::bitxor_assign': ['/// Modifies this set to contain the symmetric difference of `self` and `rhs`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n///\n/// a ^= &b;\n///\n/// let mut i = 0;\n/// let expected = [1, 2, 4, 5];\n/// for x in &a {\n///     assert!(expected.contains(x));\n///     i += 1;\n/// }\n/// assert_eq!(i, expected.len());\n/// ```\nfn bitxor_assign(&mut self, rhs: &HashSet<T, S, A>){\n        for item in rhs {\n            let hash = make_hash(&self.map.hash_builder, item);\n            match self.map.find_or_find_insert_slot(hash, item) {\n                Ok(bucket) => unsafe {\n                    self.map.table.remove(bucket);\n                },\n                Err(slot) => unsafe {\n                    self.map\n                        .table\n                        .insert_in_slot(hash, slot, (item.clone(), ()));\n                },\n            }\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, S, A> as core::ops::SubAssign<&set::HashSet<T, S, A>>>::sub_assign': ['/// Modifies this set to contain the difference of `self` and `rhs`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n///\n/// a -= &b;\n///\n/// let mut i = 0;\n/// let expected = [1, 2];\n/// for x in &a {\n///     assert!(expected.contains(x));\n///     i += 1;\n/// }\n/// assert_eq!(i, expected.len());\n/// ```\nfn sub_assign(&mut self, rhs: &HashSet<T, S, A>){\n        if rhs.len() < self.len() {\n            for item in rhs {\n                self.remove(item);\n            }\n        } else {\n            self.retain(|item| !rhs.contains(item));\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::HashSet<T, foldhash::fast::RandomState, A> as core::convert::From<[T; N]>>::from': ['/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let set1 = HashSet::from([1, 2, 3, 4]);\n/// let set2: HashSet<_> = [1, 2, 3, 4].into();\n/// assert_eq!(set1, set2);\n/// ```\nfn from(arr: [T; N]) -> Self{\n        arr.into_iter().collect()\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Intersection<'_, T, S, A> as core::clone::Clone>::clone": ['inline\nfn clone(&self) -> Self{\n        Intersection {\n            iter: self.iter.clone(),\n            ..*self\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Intersection<'_, T, S, A> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.fold(init, |acc, elt| {\n            if self.other.contains(elt) {\n                f(acc, elt)\n            } else {\n                acc\n            }\n        })\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::next": ["inline\nfn next(&mut self) -> Option<&'a T>{\n        loop {\n            let elt = self.iter.next()?;\n            if self.other.contains(elt) {\n                return Some(elt);\n            }\n        }\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        let (_, upper) = self.iter.size_hint();\n        (0, upper)\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::IntoIter<K, A> as core::default::Default>::default': ['inline\nfn default() -> Self{\n        IntoIter {\n            iter: Default::default(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::IntoIter<K, A> as core::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let entries_iter = self.iter.iter().map(|(k, _)| k);\n        f.debug_list().entries(entries_iter).finish()\n    }", 'Real(LocalPath("src/set.rs"))'], '<set::IntoIter<K, A> as core::iter::ExactSizeIterator>::len': ['inline\nfn len(&self) -> usize{\n        self.iter.len()\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::IntoIter<K, A> as core::iter::Iterator>::fold': ['inline\nfn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.fold(init, |acc, (k, ())| f(acc, k))\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::IntoIter<K, A> as core::iter::Iterator>::next': ['inline\nfn next(&mut self) -> Option<K>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.iter.next() {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], '<set::IntoIter<K, A> as core::iter::Iterator>::size_hint': ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Iter<'_, K> as core::clone::Clone>::clone": ['inline\nfn clone(&self) -> Self{\n        Iter {\n            iter: self.iter.clone(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Iter<'_, K> as core::default::Default>::default": ['inline\nfn default() -> Self{\n        Iter {\n            iter: Default::default(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Iter<'_, K> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::Iter<'_, K> as core::iter::ExactSizeIterator>::len": ['inline\nfn len(&self) -> usize{\n        self.iter.len()\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Iter<'a, K> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.fold(init, f)\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Iter<'a, K> as core::iter::Iterator>::next": ["inline\nfn next(&mut self) -> Option<&'a K>{\n        self.iter.next()\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::Iter<'a, K> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::OccupiedEntry<'_, T, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("OccupiedEntry")\n            .field("value", self.get())\n            .finish()\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::SymmetricDifference<'_, T, S, A> as core::clone::Clone>::clone": ['inline\nfn clone(&self) -> Self{\n        SymmetricDifference {\n            iter: self.iter.clone(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::SymmetricDifference<'_, T, S, A> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.fold(init, f)\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::next": ["inline\nfn next(&mut self) -> Option<&'a T>{\n        self.iter.next()\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Union<'_, T, S, A> as core::clone::Clone>::clone": ['inline\nfn clone(&self) -> Self{\n        Union {\n            iter: self.iter.clone(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Union<'_, T, S, A> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::Union<'a, T, S, A> as core::iter::Iterator>::fold": ['inline\nfn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.iter.fold(init, f)\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::Union<'a, T, S, A> as core::iter::Iterator>::next": ["inline\nfn next(&mut self) -> Option<&'a T>{\n        self.iter.next()\n    }", 'Real(LocalPath("src/set.rs"))'], "<set::Union<'a, T, S, A> as core::iter::Iterator>::size_hint": ['inline\nfn size_hint(&self) -> (usize, Option<usize>){\n        self.iter.size_hint()\n    }', 'Real(LocalPath("src/set.rs"))'], "<set::VacantEntry<'_, T, S, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_tuple("VacantEntry").field(self.get()).finish()\n    }', 'Real(LocalPath("src/set.rs"))'], "<table::AbsentEntry<'_, T, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.write_str("AbsentEntry")\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::Drain<'_, T, A> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list()\n            .entries(Iter {\n                inner: self.inner.iter(),\n                marker: PhantomData,\n            })\n            .finish()\n    }", 'Real(LocalPath("src/table.rs"))'], "<table::Drain<'_, T, A> as core::iter::ExactSizeIterator>::len": ['fn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::Drain<'_, T, A> as core::iter::Iterator>::fold": ['fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, f)\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::Drain<'_, T, A> as core::iter::Iterator>::next": ['fn next(&mut self) -> Option<T>{\n        self.inner.next()\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::Drain<'_, T, A> as core::iter::Iterator>::size_hint": ['fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::Entry<'_, T, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        match *self {\n            Entry::Vacant(ref v) => f.debug_tuple("Entry").field(v).finish(),\n            Entry::Occupied(ref o) => f.debug_tuple("Entry").field(o).finish(),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::ExtractIf<'_, T, F, A> as core::iter::Iterator>::next": ['#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        self.inner.next(|val| (self.f)(val))\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::ExtractIf<'_, T, F, A> as core::iter::Iterator>::size_hint": ['#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        (0, self.inner.iter.size_hint().1)\n    }', 'Real(LocalPath("src/table.rs"))'], '<table::HashTable<T, A> as core::clone::Clone>::clone': ['fn clone(&self) -> Self{\n        Self {\n            raw: self.raw.clone(),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], '<table::HashTable<T, A> as core::default::Default>::default': ['fn default() -> Self{\n        Self {\n            raw: Default::default(),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], '<table::HashTable<T, A> as core::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_set().entries(self.iter()).finish()\n    }", 'Real(LocalPath("src/table.rs"))'], '<table::HashTable<T, A> as core::iter::IntoIterator>::into_iter': ['fn into_iter(self) -> IntoIter<T, A>{\n        IntoIter {\n            inner: self.raw.into_iter(),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], '<table::IntoIter<T, A> as core::default::Default>::default': ['inline\nfn default() -> Self{\n        IntoIter {\n            inner: Default::default(),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], '<table::IntoIter<T, A> as core::fmt::Debug>::fmt': ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list()\n            .entries(Iter {\n                inner: self.inner.iter(),\n                marker: PhantomData,\n            })\n            .finish()\n    }", 'Real(LocalPath("src/table.rs"))'], '<table::IntoIter<T, A> as core::iter::ExactSizeIterator>::len': ['fn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/table.rs"))'], '<table::IntoIter<T, A> as core::iter::Iterator>::fold': ['fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner.fold(init, f)\n    }', 'Real(LocalPath("src/table.rs"))'], '<table::IntoIter<T, A> as core::iter::Iterator>::next': ['fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next()\n    }', 'Real(LocalPath("src/table.rs"))'], '<table::IntoIter<T, A> as core::iter::Iterator>::size_hint': ['fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::Iter<'_, T> as core::default::Default>::default": ['inline\nfn default() -> Self{\n        Iter {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::Iter<'_, T> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }", 'Real(LocalPath("src/table.rs"))'], "<table::Iter<'_, T> as core::iter::ExactSizeIterator>::len": ['fn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::Iter<'a, T> as core::clone::Clone>::clone": ["inline\nfn clone(&self) -> Iter<'a, T>{\n        Iter {\n            inner: self.inner.clone(),\n            marker: PhantomData,\n        }\n    }", 'Real(LocalPath("src/table.rs"))'], "<table::Iter<'a, T> as core::iter::Iterator>::fold": ['fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner\n            .fold(init, |acc, bucket| unsafe { f(acc, bucket.as_ref()) })\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::Iter<'a, T> as core::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(bucket) => Some(unsafe { bucket.as_ref() }),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::Iter<'a, T> as core::iter::Iterator>::size_hint": ['fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterHash<'_, T> as core::default::Default>::default": ['inline\nfn default() -> Self{\n        IterHash {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterHash<'_, T> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self.clone()).finish()\n    }", 'Real(LocalPath("src/table.rs"))'], "<table::IterHash<'a, T> as core::clone::Clone>::clone": ["inline\nfn clone(&self) -> IterHash<'a, T>{\n        IterHash {\n            inner: self.inner.clone(),\n            marker: PhantomData,\n        }\n    }", 'Real(LocalPath("src/table.rs"))'], "<table::IterHash<'a, T> as core::iter::Iterator>::fold": ['fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner\n            .fold(init, |acc, bucket| unsafe { f(acc, bucket.as_ref()) })\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterHash<'a, T> as core::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(bucket) => Some(unsafe { bucket.as_ref() }),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterHashMut<'_, T> as core::default::Default>::default": ['inline\nfn default() -> Self{\n        IterHashMut {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterHashMut<'_, T> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list()\n            .entries(IterHash {\n                inner: self.inner.clone(),\n                marker: PhantomData,\n            })\n            .finish()\n    }", 'Real(LocalPath("src/table.rs"))'], "<table::IterHashMut<'a, T> as core::iter::Iterator>::fold": ['fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner\n            .fold(init, |acc, bucket| unsafe { f(acc, bucket.as_mut()) })\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterHashMut<'a, T> as core::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(bucket) => Some(unsafe { bucket.as_mut() }),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterMut<'_, T> as core::default::Default>::default": ['inline\nfn default() -> Self{\n        IterMut {\n            inner: Default::default(),\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterMut<'_, T> as core::fmt::Debug>::fmt": ["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list()\n            .entries(Iter {\n                inner: self.inner.clone(),\n                marker: PhantomData,\n            })\n            .finish()\n    }", 'Real(LocalPath("src/table.rs"))'], "<table::IterMut<'_, T> as core::iter::ExactSizeIterator>::len": ['fn len(&self) -> usize{\n        self.inner.len()\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterMut<'a, T> as core::iter::Iterator>::fold": ['fn fold<B, F>(self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,{\n        self.inner\n            .fold(init, |acc, bucket| unsafe { f(acc, bucket.as_mut()) })\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterMut<'a, T> as core::iter::Iterator>::next": ['fn next(&mut self) -> Option<Self::Item>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.inner.next() {\n            Some(bucket) => Some(unsafe { bucket.as_mut() }),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::IterMut<'a, T> as core::iter::Iterator>::size_hint": ['fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::OccupiedEntry<'_, T, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.debug_struct("OccupiedEntry")\n            .field("value", self.get())\n            .finish()\n    }', 'Real(LocalPath("src/table.rs"))'], "<table::VacantEntry<'_, T, A> as core::fmt::Debug>::fmt": ['fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result{\n        f.write_str("VacantEntry")\n    }', 'Real(LocalPath("src/table.rs"))'], 'TryReserveError': ["/// The error type for `try_reserve` methods.\npub enum TryReserveError {\n    /// Error due to the computed capacity exceeding the collection's maximum\n    /// (usually `isize::MAX` bytes).\n    CapacityOverflow,\n\n    /// The memory allocator returned an error\n    AllocError {\n        /// The layout of the allocation request that failed.\n        layout: alloc::alloc::Layout,\n    },\n}", 'Real(LocalPath("src/lib.rs"))'], 'control::bitmask::BitMask': ['/// A bit mask which contains the result of a `Match` operation on a `Group` and\n/// allows iterating through them.\n///\n/// The bit mask is arranged so that low-order bits represent lower memory\n/// addresses for group match results.\n///\n/// For implementation reasons, the bits in the set may be sparsely packed with\n/// groups of 8 bits representing one element. If any of these bits are non-zero\n/// then this element is considered to true in the mask. If this is the\n/// case, `BITMASK_STRIDE` will be 8 to indicate a divide-by-8 should be\n/// performed on counts/indices to normalize this difference. `BITMASK_MASK` is\n/// similarly a mask of all the actually-used bits.\n///\n/// To iterate over a bit mask, it must be converted to a form where only 1 bit\n/// is set per element. This is done by applying `BITMASK_ITER_MASK` on the\n/// mask bits.\npub(crate) struct BitMask(pub(crate) BitMaskWord);', 'Real(LocalPath("src/control/bitmask.rs"))'], 'control::bitmask::BitMask::any_bit_set': ['/// Returns whether the `BitMask` has at least one set bit.\n#[inline]\npub(crate) fn any_bit_set(self) -> bool{\n        self.0 != 0\n    }', 'Real(LocalPath("src/control/bitmask.rs"))'], 'control::bitmask::BitMask::invert': ['/// Returns a new `BitMask` with all bits inverted.\n#[inline]\n#[must_use]\n#[allow(dead_code)]\npub(crate) fn invert(self) -> Self{\n        BitMask(self.0 ^ BITMASK_MASK)\n    }', 'Real(LocalPath("src/control/bitmask.rs"))'], 'control::bitmask::BitMask::leading_zeros': ['/// Returns the number of leading zeroes in the `BitMask`.\n#[inline]\npub(crate) fn leading_zeros(self) -> usize{\n        self.0.leading_zeros() as usize / BITMASK_STRIDE\n    }', 'Real(LocalPath("src/control/bitmask.rs"))'], 'control::bitmask::BitMask::lowest_set_bit': ['/// Returns the first set bit in the `BitMask`, if there is one.\n#[inline]\npub(crate) fn lowest_set_bit(self) -> Option<usize>{\n        if let Some(nonzero) = NonZeroBitMaskWord::new(self.0) {\n            Some(Self::nonzero_trailing_zeros(nonzero))\n        } else {\n            None\n        }\n    }', 'Real(LocalPath("src/control/bitmask.rs"))'], 'control::bitmask::BitMask::nonzero_trailing_zeros': ['/// Same as above but takes a `NonZeroBitMaskWord`.\n#[inline]\nfn nonzero_trailing_zeros(nonzero: NonZeroBitMaskWord) -> usize{\n        if cfg!(target_arch = "arm") && BITMASK_STRIDE % 8 == 0 {\n            // SAFETY: A byte-swapped non-zero value is still non-zero.\n            let swapped = unsafe { NonZeroBitMaskWord::new_unchecked(nonzero.get().swap_bytes()) };\n            swapped.leading_zeros() as usize / BITMASK_STRIDE\n        } else {\n            nonzero.trailing_zeros() as usize / BITMASK_STRIDE\n        }\n    }', 'Real(LocalPath("src/control/bitmask.rs"))'], 'control::bitmask::BitMask::remove_lowest_bit': ['/// Returns a new `BitMask` with the lowest bit removed.\n#[inline]\n#[must_use]\nfn remove_lowest_bit(self) -> Self{\n        BitMask(self.0 & (self.0 - 1))\n    }', 'Real(LocalPath("src/control/bitmask.rs"))'], 'control::bitmask::BitMask::trailing_zeros': ['/// Returns the number of trailing zeroes in the `BitMask`.\n#[inline]\npub(crate) fn trailing_zeros(self) -> usize{\n        // ARM doesn\'t have a trailing_zeroes instruction, and instead uses\n        // reverse_bits (RBIT) + leading_zeroes (CLZ). However older ARM\n        // versions (pre-ARMv7) don\'t have RBIT and need to emulate it\n        // instead. Since we only have 1 bit set in each byte on ARM, we can\n        // use swap_bytes (REV) + leading_zeroes instead.\n        if cfg!(target_arch = "arm") && BITMASK_STRIDE % 8 == 0 {\n            self.0.swap_bytes().leading_zeros() as usize / BITMASK_STRIDE\n        } else {\n            self.0.trailing_zeros() as usize / BITMASK_STRIDE\n        }\n    }', 'Real(LocalPath("src/control/bitmask.rs"))'], 'control::bitmask::BitMaskIter': ['/// Iterator over the contents of a `BitMask`, returning the indices of set\n/// bits.\npub(crate) struct BitMaskIter(pub(crate) BitMask);', 'Real(LocalPath("src/control/bitmask.rs"))'], 'control::group::sse2::Group': ['/// Abstraction over a group of control tags which can be scanned in\n/// parallel.\n///\n/// This implementation uses a 128-bit SSE value.\npub(crate) struct Group(x86::__m128i);', 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::group::sse2::Group::convert_special_to_empty_and_full_to_deleted': ["/// Performs the following transformation on all tags in the group:\n/// - `EMPTY => EMPTY`\n/// - `DELETED => EMPTY`\n/// - `FULL => DELETED`\n#[inline]\npub(crate) fn convert_special_to_empty_and_full_to_deleted(self) -> Self{\n        // Map high_bit = 1 (EMPTY or DELETED) to 1111_1111\n        // and high_bit = 0 (FULL) to 1000_0000\n        //\n        // Here's this logic expanded to concrete values:\n        //   let special = 0 > tag = 1111_1111 (true) or 0000_0000 (false)\n        //   1111_1111 | 1000_0000 = 1111_1111\n        //   0000_0000 | 1000_0000 = 1000_0000\n        #[allow(\n            clippy::cast_possible_wrap, // tag: Tag::DELETED.0 as i8\n        )]\n        unsafe {\n            let zero = x86::_mm_setzero_si128();\n            let special = x86::_mm_cmpgt_epi8(zero, self.0);\n            Group(x86::_mm_or_si128(\n                special,\n                x86::_mm_set1_epi8(Tag::DELETED.0 as i8),\n            ))\n        }\n    }", 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::group::sse2::Group::load': ['/// Loads a group of tags starting at the given address.\n#[inline]\n#[allow(clippy::cast_ptr_alignment)]\npub(crate) unsafe fn load(ptr: *const Tag) -> Self{\n        Group(x86::_mm_loadu_si128(ptr.cast()))\n    }', 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::group::sse2::Group::load_aligned': ['/// Loads a group of tags starting at the given address, which must be\n/// aligned to `mem::align_of::<Group>()`.\n#[inline]\n#[allow(clippy::cast_ptr_alignment)]\npub(crate) unsafe fn load_aligned(ptr: *const Tag) -> Self{\n        debug_assert_eq!(ptr.align_offset(mem::align_of::<Self>()), 0);\n        Group(x86::_mm_load_si128(ptr.cast()))\n    }', 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::group::sse2::Group::match_empty': ['/// Returns a `BitMask` indicating all tags in the group which are\n/// `EMPTY`.\n#[inline]\npub(crate) fn match_empty(self) -> BitMask{\n        self.match_tag(Tag::EMPTY)\n    }', 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::group::sse2::Group::match_empty_or_deleted': ['/// Returns a `BitMask` indicating all tags in the group which are\n/// `EMPTY` or `DELETED`.\n#[inline]\npub(crate) fn match_empty_or_deleted(self) -> BitMask{\n        #[allow(\n            // tag: i32 as u16\n            //   note: _mm_movemask_epi8 returns a 16-bit mask in a i32, the\n            //   upper 16-bits of the i32 are zeroed:\n            clippy::cast_sign_loss,\n            clippy::cast_possible_truncation\n        )]\n        unsafe {\n            // A tag is EMPTY or DELETED iff the high bit is set\n            BitMask(x86::_mm_movemask_epi8(self.0) as u16)\n        }\n    }', 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::group::sse2::Group::match_full': ['/// Returns a `BitMask` indicating all tags in the group which are full.\n#[inline]\npub(crate) fn match_full(&self) -> BitMask{\n        self.match_empty_or_deleted().invert()\n    }', 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::group::sse2::Group::match_tag': ['/// Returns a `BitMask` indicating all tags in the group which have\n/// the given value.\n#[inline]\npub(crate) fn match_tag(self, tag: Tag) -> BitMask{\n        #[allow(\n            clippy::cast_possible_wrap, // tag.0: Tag as i8\n            // tag: i32 as u16\n            //   note: _mm_movemask_epi8 returns a 16-bit mask in a i32, the\n            //   upper 16-bits of the i32 are zeroed:\n            clippy::cast_sign_loss,\n            clippy::cast_possible_truncation\n        )]\n        unsafe {\n            let cmp = x86::_mm_cmpeq_epi8(self.0, x86::_mm_set1_epi8(tag.0 as i8));\n            BitMask(x86::_mm_movemask_epi8(cmp) as u16)\n        }\n    }', 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::group::sse2::Group::static_empty': ["/// Returns a full group of empty tags, suitable for use as the initial\n/// value for an empty hash table.\n///\n/// This is guaranteed to be aligned to the group size.\n#[inline]\n#[allow(clippy::items_after_statements)]\npub(crate) const fn static_empty() -> &'static [Tag; Group::WIDTH]{\n        #[repr(C)]\n        struct AlignedTags {\n            _align: [Group; 0],\n            tags: [Tag; Group::WIDTH],\n        }\n        const ALIGNED_TAGS: AlignedTags = AlignedTags {\n            _align: [],\n            tags: [Tag::EMPTY; Group::WIDTH],\n        };\n        &ALIGNED_TAGS.tags\n    }", 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::group::sse2::Group::static_empty::AlignedTags': ['#[repr(C)]\nstruct AlignedTags {\n            _align: [Group; 0],\n            tags: [Tag; Group::WIDTH],\n        }', 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::group::sse2::Group::store_aligned': ['/// Stores the group of tags to the given address, which must be\n/// aligned to `mem::align_of::<Group>()`.\n#[inline]\n#[allow(clippy::cast_ptr_alignment)]\npub(crate) unsafe fn store_aligned(self, ptr: *mut Tag){\n        debug_assert_eq!(ptr.align_offset(mem::align_of::<Self>()), 0);\n        x86::_mm_store_si128(ptr.cast(), self.0);\n    }', 'Real(LocalPath("src/control/group/sse2.rs"))'], 'control::tag::Tag': ['/// Single tag in a control group.\n#[repr(transparent)]\npub(crate) struct Tag(pub(super) u8);', 'Real(LocalPath("src/control/tag.rs"))'], 'control::tag::Tag::full': ['/// Creates a control tag representing a full bucket with the given hash.\n#[inline]\n#[allow(clippy::cast_possible_truncation)]\npub(crate) const fn full(hash: u64) -> Tag{\n        // Constant for function that grabs the top 7 bits of the hash.\n        const MIN_HASH_LEN: usize = if mem::size_of::<usize>() < mem::size_of::<u64>() {\n            mem::size_of::<usize>()\n        } else {\n            mem::size_of::<u64>()\n        };\n\n        // Grab the top 7 bits of the hash. While the hash is normally a full 64-bit\n        // value, some hash functions (such as FxHash) produce a usize result\n        // instead, which means that the top 32 bits are 0 on 32-bit platforms.\n        // So we use MIN_HASH_LEN constant to handle this.\n        let top7 = hash >> (MIN_HASH_LEN * 8 - 7);\n        Tag((top7 & 0x7f) as u8) // truncation\n    }', 'Real(LocalPath("src/control/tag.rs"))'], 'control::tag::Tag::is_full': ['/// Checks whether a control tag represents a full bucket (top bit is clear).\n#[inline]\npub(crate) const fn is_full(self) -> bool{\n        self.0 & 0x80 == 0\n    }', 'Real(LocalPath("src/control/tag.rs"))'], 'control::tag::Tag::is_special': ['/// Checks whether a control tag represents a special value (top bit is set).\n#[inline]\npub(crate) const fn is_special(self) -> bool{\n        self.0 & 0x80 != 0\n    }', 'Real(LocalPath("src/control/tag.rs"))'], 'control::tag::Tag::special_is_empty': ['/// Checks whether a special control value is EMPTY (just check 1 bit).\n#[inline]\npub(crate) const fn special_is_empty(self) -> bool{\n        debug_assert!(self.is_special());\n        self.0 & 0x01 != 0\n    }', 'Real(LocalPath("src/control/tag.rs"))'], 'control::tag::TagSliceExt': ['/// Extension trait for slices of tags.\npub(crate) trait TagSliceExt {\n    /// Fills the control with the given tag.\n    fn fill_tag(&mut self, tag: Tag);\n\n    /// Clears out the control.\n    #[inline]\n    fn fill_empty(&mut self) {\n        self.fill_tag(Tag::EMPTY)\n    }\n}', 'Real(LocalPath("src/control/tag.rs"))'], 'control::tag::TagSliceExt::fill_empty': ['/// Clears out the control.\n#[inline]\nfn fill_empty(&mut self){\n        self.fill_tag(Tag::EMPTY)\n    }', 'Real(LocalPath("src/control/tag.rs"))'], 'map::Drain': ['/// A draining iterator over the entries of a `HashMap` in arbitrary\n/// order. The iterator element type is `(K, V)`.\n///\n/// This `struct` is created by the [`drain`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`drain`]: struct.HashMap.html#method.drain\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n///\n/// let mut drain_iter = map.drain();\n/// let mut vec = vec![drain_iter.next(), drain_iter.next(), drain_iter.next()];\n///\n/// // The `Drain` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [Some((1, "a")), Some((2, "b")), Some((3, "c"))]);\n///\n/// // It is fused iterator\n/// assert_eq!(drain_iter.next(), None);\n/// assert_eq!(drain_iter.next(), None);\n/// ```\npub struct Drain<\'a, K, V, A: Allocator = Global> {\n    inner: RawDrain<\'a, (K, V), A>,\n}', 'Real(LocalPath("src/map.rs"))'], "map::Drain::<'_, K, V, A>::iter": ["/// Returns a iterator of references over the remaining items.\ninline\npub(super) fn iter(&self) -> Iter<'_, K, V>{\n        Iter {\n            inner: self.inner.iter(),\n            marker: PhantomData,\n        }\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::Entry': ['/// A view into a single entry in a map, which may either be vacant or occupied.\n///\n/// This `enum` is constructed from the [`entry`] method on [`HashMap`].\n///\n/// [`HashMap`]: struct.HashMap.html\n/// [`entry`]: struct.HashMap.html#method.entry\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{Entry, HashMap, OccupiedEntry};\n///\n/// let mut map = HashMap::new();\n/// map.extend([("a", 10), ("b", 20), ("c", 30)]);\n/// assert_eq!(map.len(), 3);\n///\n/// // Existing key (insert)\n/// let entry: Entry<_, _, _> = map.entry("a");\n/// let _raw_o: OccupiedEntry<_, _, _> = entry.insert(1);\n/// assert_eq!(map.len(), 3);\n/// // Nonexistent key (insert)\n/// map.entry("d").insert(4);\n///\n/// // Existing key (or_insert)\n/// let v = map.entry("b").or_insert(2);\n/// assert_eq!(std::mem::replace(v, 2), 20);\n/// // Nonexistent key (or_insert)\n/// map.entry("e").or_insert(5);\n///\n/// // Existing key (or_insert_with)\n/// let v = map.entry("c").or_insert_with(|| 3);\n/// assert_eq!(std::mem::replace(v, 3), 30);\n/// // Nonexistent key (or_insert_with)\n/// map.entry("f").or_insert_with(|| 6);\n///\n/// println!("Our HashMap: {:?}", map);\n///\n/// let mut vec: Vec<_> = map.iter().map(|(&k, &v)| (k, v)).collect();\n/// // The `Iter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [("a", 1), ("b", 2), ("c", 3), ("d", 4), ("e", 5), ("f", 6)]);\n/// ```\npub enum Entry<\'a, K, V, S, A = Global>\nwhere\n    A: Allocator,\n{\n    /// An occupied entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{Entry, HashMap};\n    /// let mut map: HashMap<_, _> = [("a", 100), ("b", 200)].into();\n    ///\n    /// match map.entry("a") {\n    ///     Entry::Vacant(_) => unreachable!(),\n    ///     Entry::Occupied(_) => { }\n    /// }\n    /// ```\n    Occupied(OccupiedEntry<\'a, K, V, S, A>),\n\n    /// A vacant entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{Entry, HashMap};\n    /// let mut map: HashMap<&str, i32> = HashMap::new();\n    ///\n    /// match map.entry("a") {\n    ///     Entry::Occupied(_) => unreachable!(),\n    ///     Entry::Vacant(_) => { }\n    /// }\n    /// ```\n    Vacant(VacantEntry<\'a, K, V, S, A>),\n}', 'Real(LocalPath("src/map.rs"))'], "map::Entry::<'a, K, V, S, A>::and_modify": ['/// Provides in-place mutable access to an occupied entry before any\n/// potential inserts into the map.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// map.entry("poneyland")\n///    .and_modify(|e| { *e += 1 })\n///    .or_insert(42);\n/// assert_eq!(map["poneyland"], 42);\n///\n/// map.entry("poneyland")\n///    .and_modify(|e| { *e += 1 })\n///    .or_insert(42);\n/// assert_eq!(map["poneyland"], 43);\n/// ```\ninline\npub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),{\n        match self {\n            Entry::Occupied(mut entry) => {\n                f(entry.get_mut());\n                Entry::Occupied(entry)\n            }\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::Entry::<'a, K, V, S, A>::and_replace_entry_with": ['/// Provides shared access to the key and owned access to the value of\n/// an occupied entry and allows to replace or remove it based on the\n/// value of the returned option.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::Entry;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// let entry = map\n///     .entry("poneyland")\n///     .and_replace_entry_with(|_k, _v| panic!());\n///\n/// match entry {\n///     Entry::Vacant(e) => {\n///         assert_eq!(e.key(), &"poneyland");\n///     }\n///     Entry::Occupied(_) => panic!(),\n/// }\n///\n/// map.insert("poneyland", 42);\n///\n/// let entry = map\n///     .entry("poneyland")\n///     .and_replace_entry_with(|k, v| {\n///         assert_eq!(k, &"poneyland");\n///         assert_eq!(v, 42);\n///         Some(v + 1)\n///     });\n///\n/// match entry {\n///     Entry::Occupied(e) => {\n///         assert_eq!(e.key(), &"poneyland");\n///         assert_eq!(e.get(), &43);\n///     }\n///     Entry::Vacant(_) => panic!(),\n/// }\n///\n/// assert_eq!(map["poneyland"], 43);\n///\n/// let entry = map\n///     .entry("poneyland")\n///     .and_replace_entry_with(|_k, _v| None);\n///\n/// match entry {\n///     Entry::Vacant(e) => assert_eq!(e.key(), &"poneyland"),\n///     Entry::Occupied(_) => panic!(),\n/// }\n///\n/// assert!(!map.contains_key("poneyland"));\n/// ```\ninline\npub fn and_replace_entry_with<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&K, V) -> Option<V>,{\n        match self {\n            Entry::Occupied(entry) => entry.replace_entry_with(f),\n            Entry::Vacant(_) => self,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::Entry::<'a, K, V, S, A>::insert": ['/// Sets the value of the entry, and returns an `OccupiedEntry`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// let entry = map.entry("horseyland").insert(37);\n///\n/// assert_eq!(entry.key(), &"horseyland");\n/// ```\ninline\npub fn insert(self, value: V) -> OccupiedEntry<\'a, K, V, S, A>\n    where\n        K: Hash,\n        S: BuildHasher,{\n        match self {\n            Entry::Occupied(mut entry) => {\n                entry.insert(value);\n                entry\n            }\n            Entry::Vacant(entry) => entry.insert_entry(value),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::Entry::<'a, K, V, S, A>::key": ['/// Returns a reference to this entry\'s key.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// map.entry("poneyland").or_insert(3);\n/// // existing key\n/// assert_eq!(map.entry("poneyland").key(), &"poneyland");\n/// // nonexistent key\n/// assert_eq!(map.entry("horseland").key(), &"horseland");\n/// ```\ninline\npub fn key(&self) -> &K{\n        match *self {\n            Entry::Occupied(ref entry) => entry.key(),\n            Entry::Vacant(ref entry) => entry.key(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::Entry::<'a, K, V, S, A>::or_default": ['/// Ensures a value is in the entry by inserting the default value if empty,\n/// and returns a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, Option<u32>> = HashMap::new();\n///\n/// // nonexistent key\n/// map.entry("poneyland").or_default();\n/// assert_eq!(map["poneyland"], None);\n///\n/// map.insert("horseland", Some(3));\n///\n/// // existing key\n/// assert_eq!(map.entry("horseland").or_default(), &mut Some(3));\n/// ```\ninline\npub fn or_default(self) -> &\'a mut V\n    where\n        K: Hash,\n        S: BuildHasher,{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(Default::default()),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::Entry::<'a, K, V, S, A>::or_insert": ['/// Ensures a value is in the entry by inserting the default if empty, and returns\n/// a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// // nonexistent key\n/// map.entry("poneyland").or_insert(3);\n/// assert_eq!(map["poneyland"], 3);\n///\n/// // existing key\n/// *map.entry("poneyland").or_insert(10) *= 2;\n/// assert_eq!(map["poneyland"], 6);\n/// ```\ninline\npub fn or_insert(self, default: V) -> &\'a mut V\n    where\n        K: Hash,\n        S: BuildHasher,{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::Entry::<'a, K, V, S, A>::or_insert_with": ['/// Ensures a value is in the entry by inserting the result of the default function if empty,\n/// and returns a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// // nonexistent key\n/// map.entry("poneyland").or_insert_with(|| 3);\n/// assert_eq!(map["poneyland"], 3);\n///\n/// // existing key\n/// *map.entry("poneyland").or_insert_with(|| 10) *= 2;\n/// assert_eq!(map["poneyland"], 6);\n/// ```\ninline\npub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &\'a mut V\n    where\n        K: Hash,\n        S: BuildHasher,{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::Entry::<'a, K, V, S, A>::or_insert_with_key": ['/// Ensures a value is in the entry by inserting, if empty, the result of the default function.\n/// This method allows for generating key-derived values for insertion by providing the default\n/// function a reference to the key that was moved during the `.entry(key)` method call.\n///\n/// The reference to the moved key is provided so that cloning or copying the key is\n/// unnecessary, unlike with `.or_insert_with(|| ... )`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, usize> = HashMap::new();\n///\n/// // nonexistent key\n/// map.entry("poneyland").or_insert_with_key(|key| key.chars().count());\n/// assert_eq!(map["poneyland"], 9);\n///\n/// // existing key\n/// *map.entry("poneyland").or_insert_with_key(|key| key.chars().count() * 10) *= 2;\n/// assert_eq!(map["poneyland"], 18);\n/// ```\ninline\npub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &\'a mut V\n    where\n        K: Hash,\n        S: BuildHasher,{\n        match self {\n            Entry::Occupied(entry) => entry.into_mut(),\n            Entry::Vacant(entry) => {\n                let value = default(entry.key());\n                entry.insert(value)\n            }\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::EntryRef': ['/// A view into a single entry in a map, which may either be vacant or occupied,\n/// with any borrowed form of the map\'s key type.\n///\n///\n/// This `enum` is constructed from the [`entry_ref`] method on [`HashMap`].\n///\n/// [`Hash`] and [`Eq`] on the borrowed form of the map\'s key type *must* match those\n/// for the key type. It also require that key may be constructed from the borrowed\n/// form through the [`From`] trait.\n///\n/// [`HashMap`]: struct.HashMap.html\n/// [`entry_ref`]: struct.HashMap.html#method.entry_ref\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n/// [`From`]: https://doc.rust-lang.org/std/convert/trait.From.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{EntryRef, HashMap, OccupiedEntry};\n///\n/// let mut map = HashMap::new();\n/// map.extend([("a".to_owned(), 10), ("b".into(), 20), ("c".into(), 30)]);\n/// assert_eq!(map.len(), 3);\n///\n/// // Existing key (insert)\n/// let key = String::from("a");\n/// let entry: EntryRef<_, _, _, _> = map.entry_ref(&key);\n/// let _raw_o: OccupiedEntry<_, _, _, _> = entry.insert(1);\n/// assert_eq!(map.len(), 3);\n/// // Nonexistent key (insert)\n/// map.entry_ref("d").insert(4);\n///\n/// // Existing key (or_insert)\n/// let v = map.entry_ref("b").or_insert(2);\n/// assert_eq!(std::mem::replace(v, 2), 20);\n/// // Nonexistent key (or_insert)\n/// map.entry_ref("e").or_insert(5);\n///\n/// // Existing key (or_insert_with)\n/// let v = map.entry_ref("c").or_insert_with(|| 3);\n/// assert_eq!(std::mem::replace(v, 3), 30);\n/// // Nonexistent key (or_insert_with)\n/// map.entry_ref("f").or_insert_with(|| 6);\n///\n/// println!("Our HashMap: {:?}", map);\n///\n/// for (key, value) in ["a", "b", "c", "d", "e", "f"].into_iter().zip(1..=6) {\n///     assert_eq!(map[key], value)\n/// }\n/// assert_eq!(map.len(), 6);\n/// ```\npub enum EntryRef<\'a, \'b, K, Q: ?Sized, V, S, A = Global>\nwhere\n    A: Allocator,\n{\n    /// An occupied entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{EntryRef, HashMap};\n    /// let mut map: HashMap<_, _> = [("a".to_owned(), 100), ("b".into(), 200)].into();\n    ///\n    /// match map.entry_ref("a") {\n    ///     EntryRef::Vacant(_) => unreachable!(),\n    ///     EntryRef::Occupied(_) => { }\n    /// }\n    /// ```\n    Occupied(OccupiedEntry<\'a, K, V, S, A>),\n\n    /// A vacant entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_map::{EntryRef, HashMap};\n    /// let mut map: HashMap<String, i32> = HashMap::new();\n    ///\n    /// match map.entry_ref("a") {\n    ///     EntryRef::Occupied(_) => unreachable!(),\n    ///     EntryRef::Vacant(_) => { }\n    /// }\n    /// ```\n    Vacant(VacantEntryRef<\'a, \'b, K, Q, V, S, A>),\n}', 'Real(LocalPath("src/map.rs"))'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::and_modify": ['/// Provides in-place mutable access to an occupied entry before any\n/// potential inserts into the map.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<String, u32> = HashMap::new();\n///\n/// map.entry_ref("poneyland")\n///    .and_modify(|e| { *e += 1 })\n///    .or_insert(42);\n/// assert_eq!(map["poneyland"], 42);\n///\n/// map.entry_ref("poneyland")\n///    .and_modify(|e| { *e += 1 })\n///    .or_insert(42);\n/// assert_eq!(map["poneyland"], 43);\n/// ```\ninline\npub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),{\n        match self {\n            EntryRef::Occupied(mut entry) => {\n                f(entry.get_mut());\n                EntryRef::Occupied(entry)\n            }\n            EntryRef::Vacant(entry) => EntryRef::Vacant(entry),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::insert": ['/// Sets the value of the entry, and returns an `OccupiedEntry`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<String, u32> = HashMap::new();\n/// let entry = map.entry_ref("horseyland").insert(37);\n///\n/// assert_eq!(entry.key(), "horseyland");\n/// ```\ninline\npub fn insert(self, value: V) -> OccupiedEntry<\'a, K, V, S, A>\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,{\n        match self {\n            EntryRef::Occupied(mut entry) => {\n                entry.insert(value);\n                entry\n            }\n            EntryRef::Vacant(entry) => entry.insert_entry(value),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::key": ['/// Returns a reference to this entry\'s key.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<String, u32> = HashMap::new();\n/// map.entry_ref("poneyland").or_insert(3);\n/// // existing key\n/// assert_eq!(map.entry_ref("poneyland").key(), "poneyland");\n/// // nonexistent key\n/// assert_eq!(map.entry_ref("horseland").key(), "horseland");\n/// ```\ninline\npub fn key(&self) -> &Q\n    where\n        K: Borrow<Q>,{\n        match *self {\n            EntryRef::Occupied(ref entry) => entry.key().borrow(),\n            EntryRef::Vacant(ref entry) => entry.key(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_default": ['/// Ensures a value is in the entry by inserting the default value if empty,\n/// and returns a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<String, Option<u32>> = HashMap::new();\n///\n/// // nonexistent key\n/// map.entry_ref("poneyland").or_default();\n/// assert_eq!(map["poneyland"], None);\n///\n/// map.insert("horseland".to_string(), Some(3));\n///\n/// // existing key\n/// assert_eq!(map.entry_ref("horseland").or_default(), &mut Some(3));\n/// ```\ninline\npub fn or_default(self) -> &\'a mut V\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,{\n        match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => entry.insert(Default::default()),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert": ['/// Ensures a value is in the entry by inserting the default if empty, and returns\n/// a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<String, u32> = HashMap::new();\n///\n/// // nonexistent key\n/// map.entry_ref("poneyland").or_insert(3);\n/// assert_eq!(map["poneyland"], 3);\n///\n/// // existing key\n/// *map.entry_ref("poneyland").or_insert(10) *= 2;\n/// assert_eq!(map["poneyland"], 6);\n/// ```\ninline\npub fn or_insert(self, default: V) -> &\'a mut V\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,{\n        match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => entry.insert(default),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert_with": ['/// Ensures a value is in the entry by inserting the result of the default function if empty,\n/// and returns a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<String, u32> = HashMap::new();\n///\n/// // nonexistent key\n/// map.entry_ref("poneyland").or_insert_with(|| 3);\n/// assert_eq!(map["poneyland"], 3);\n///\n/// // existing key\n/// *map.entry_ref("poneyland").or_insert_with(|| 10) *= 2;\n/// assert_eq!(map["poneyland"], 6);\n/// ```\ninline\npub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &\'a mut V\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,{\n        match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => entry.insert(default()),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert_with_key": ['/// Ensures a value is in the entry by inserting, if empty, the result of the default function.\n/// This method allows for generating key-derived values for insertion by providing the default\n/// function an access to the borrower form of the key.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<String, usize> = HashMap::new();\n///\n/// // nonexistent key\n/// map.entry_ref("poneyland").or_insert_with_key(|key| key.chars().count());\n/// assert_eq!(map["poneyland"], 9);\n///\n/// // existing key\n/// *map.entry_ref("poneyland").or_insert_with_key(|key| key.chars().count() * 10) *= 2;\n/// assert_eq!(map["poneyland"], 18);\n/// ```\ninline\npub fn or_insert_with_key<F: FnOnce(&Q) -> V>(self, default: F) -> &\'a mut V\n    where\n        K: Hash + Borrow<Q>,\n        &\'b Q: Into<K>,\n        S: BuildHasher,{\n        match self {\n            EntryRef::Occupied(entry) => entry.into_mut(),\n            EntryRef::Vacant(entry) => {\n                let value = default(entry.key);\n                entry.insert(value)\n            }\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::ExtractIf': ['/// A draining iterator over entries of a `HashMap` which don\'t satisfy the predicate\n/// `f(&k, &mut v)` in arbitrary order. The iterator element type is `(K, V)`.\n///\n/// This `struct` is created by the [`extract_if`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`extract_if`]: struct.HashMap.html#method.extract_if\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<i32, &str> = [(1, "a"), (2, "b"), (3, "c")].into();\n///\n/// let mut extract_if = map.extract_if(|k, _v| k % 2 != 0);\n/// let mut vec = vec![extract_if.next(), extract_if.next()];\n///\n/// // The `ExtractIf` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [Some((1, "a")),Some((3, "c"))]);\n///\n/// // It is fused iterator\n/// assert_eq!(extract_if.next(), None);\n/// assert_eq!(extract_if.next(), None);\n/// drop(extract_if);\n///\n/// assert_eq!(map.len(), 1);\n/// ```\n#[must_use = "Iterators are lazy unless consumed"]\npub struct ExtractIf<\'a, K, V, F, A: Allocator = Global> {\n    f: F,\n    inner: RawExtractIf<\'a, (K, V), A>,\n}', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap': ['/// A hash map implemented with quadratic probing and SIMD lookup.\n///\n/// The default hashing algorithm is currently [`foldhash`], though this is\n/// subject to change at any point in the future. This hash function is very\n/// fast for all types of keys, but this algorithm will typically *not* protect\n/// against attacks such as HashDoS.\n///\n/// The hashing algorithm can be replaced on a per-`HashMap` basis using the\n/// [`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods. Many\n/// alternative algorithms are available on crates.io, such as the [`fnv`] crate.\n///\n/// It is required that the keys implement the [`Eq`] and [`Hash`] traits, although\n/// this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\n/// If you implement these yourself, it is important that the following\n/// property holds:\n///\n/// ```text\n/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must be equal.\n///\n/// It is a logic error for a key to be modified in such a way that the key\'s\n/// hash, as determined by the [`Hash`] trait, or its equality, as determined by\n/// the [`Eq`] trait, changes while it is in the map. This is normally only\n/// possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n///\n/// It is also a logic error for the [`Hash`] implementation of a key to panic.\n/// This is generally only possible if the trait is implemented manually. If a\n/// panic does occur then the contents of the `HashMap` may become corrupted and\n/// some items may be dropped from the table.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `HashMap<String, String>` in this example).\n/// let mut book_reviews = HashMap::new();\n///\n/// // Review some books.\n/// book_reviews.insert(\n///     "Adventures of Huckleberry Finn".to_string(),\n///     "My favorite book.".to_string(),\n/// );\n/// book_reviews.insert(\n///     "Grimms\' Fairy Tales".to_string(),\n///     "Masterpiece.".to_string(),\n/// );\n/// book_reviews.insert(\n///     "Pride and Prejudice".to_string(),\n///     "Very enjoyable.".to_string(),\n/// );\n/// book_reviews.insert(\n///     "The Adventures of Sherlock Holmes".to_string(),\n///     "Eye lyked it alot.".to_string(),\n/// );\n///\n/// // Check for a specific one.\n/// // When collections store owned values (String), they can still be\n/// // queried using references (&str).\n/// if !book_reviews.contains_key("Les Misrables") {\n///     println!("We\'ve got {} reviews, but Les Misrables ain\'t one.",\n///              book_reviews.len());\n/// }\n///\n/// // oops, this review has a lot of spelling mistakes, let\'s delete it.\n/// book_reviews.remove("The Adventures of Sherlock Holmes");\n///\n/// // Look up the values associated with some keys.\n/// let to_find = ["Pride and Prejudice", "Alice\'s Adventure in Wonderland"];\n/// for &book in &to_find {\n///     match book_reviews.get(book) {\n///         Some(review) => println!("{}: {}", book, review),\n///         None => println!("{} is unreviewed.", book)\n///     }\n/// }\n///\n/// // Look up the value for a key (will panic if the key is not found).\n/// println!("Review for Jane: {}", book_reviews["Pride and Prejudice"]);\n///\n/// // Iterate over everything.\n/// for (book, review) in &book_reviews {\n///     println!("{}: \\"{}\\"", book, review);\n/// }\n/// ```\n///\n/// `HashMap` also implements an [`Entry API`](#method.entry), which allows\n/// for more complex methods of getting, setting, updating and removing keys and\n/// their values:\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// // type inference lets us omit an explicit type signature (which\n/// // would be `HashMap<&str, u8>` in this example).\n/// let mut player_stats = HashMap::new();\n///\n/// fn random_stat_buff() -> u8 {\n///     // could actually return some random value here - let\'s just return\n///     // some fixed value for now\n///     42\n/// }\n///\n/// // insert a key only if it doesn\'t already exist\n/// player_stats.entry("health").or_insert(100);\n///\n/// // insert a key using a function that provides a new value only if it\n/// // doesn\'t already exist\n/// player_stats.entry("defence").or_insert_with(random_stat_buff);\n///\n/// // update a key, guarding against the key possibly not being set\n/// let stat = player_stats.entry("attack").or_insert(100);\n/// *stat += random_stat_buff();\n/// ```\n///\n/// The easiest way to use `HashMap` with a custom key type is to derive [`Eq`] and [`Hash`].\n/// We must also derive [`PartialEq`].\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n/// [`PartialEq`]: https://doc.rust-lang.org/std/cmp/trait.PartialEq.html\n/// [`RefCell`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html\n/// [`Cell`]: https://doc.rust-lang.org/std/cell/struct.Cell.html\n/// [`default`]: #method.default\n/// [`with_hasher`]: #method.with_hasher\n/// [`with_capacity_and_hasher`]: #method.with_capacity_and_hasher\n/// [`fnv`]: https://crates.io/crates/fnv\n/// [`foldhash`]: https://crates.io/crates/foldhash\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// #[derive(Hash, Eq, PartialEq, Debug)]\n/// struct Viking {\n///     name: String,\n///     country: String,\n/// }\n///\n/// impl Viking {\n///     /// Creates a new Viking.\n///     fn new(name: &str, country: &str) -> Viking {\n///         Viking { name: name.to_string(), country: country.to_string() }\n///     }\n/// }\n///\n/// // Use a HashMap to store the vikings\' health points.\n/// let mut vikings = HashMap::new();\n///\n/// vikings.insert(Viking::new("Einar", "Norway"), 25);\n/// vikings.insert(Viking::new("Olaf", "Denmark"), 24);\n/// vikings.insert(Viking::new("Harald", "Iceland"), 12);\n///\n/// // Use derived implementation to print the status of the vikings.\n/// for (viking, health) in &vikings {\n///     println!("{:?} has {} hp", viking, health);\n/// }\n/// ```\n///\n/// A `HashMap` with fixed list of elements can be initialized from an array:\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let timber_resources: HashMap<&str, i32> = [("Norway", 100), ("Denmark", 50), ("Iceland", 10)]\n///     .into_iter().collect();\n/// // use the values stored in map\n/// ```\npub struct HashMap<K, V, S = DefaultHashBuilder, A: Allocator = Global> {\n    pub(crate) hash_builder: S,\n    pub(crate) table: RawTable<(K, V), A>,\n}', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::allocation_size': ['/// Returns the total amount of memory allocated internally by the hash\n/// set, in bytes.\n///\n/// The returned number is informational only. It is intended to be\n/// primarily used for memory profiling.\n#[inline]\npub fn allocation_size(&self) -> usize{\n        self.table.allocation_size()\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::allocator': ['/// Returns a reference to the underlying allocator.\n#[inline]\npub fn allocator(&self) -> &A{\n        self.table.allocator()\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::build_hashes_inner': ['fn build_hashes_inner<Q, const N: usize>(&self, ks: [&Q; N]) -> [u64; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        let mut hashes = [0_u64; N];\n        for i in 0..N {\n            hashes[i] = make_hash::<Q, S>(&self.hash_builder, ks[i]);\n        }\n        hashes\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::capacity': ['/// Returns the number of elements the map can hold without reallocating.\n///\n/// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n/// more, but is guaranteed to be able to hold at least this many.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n/// assert_eq!(map.len(), 0);\n/// assert!(map.capacity() >= 100);\n/// ```\ninline\npub fn capacity(&self) -> usize{\n        self.table.capacity()\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::clear': ['/// Clears the map, removing all key-value pairs. Keeps the allocated memory\n/// for reuse.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut a = HashMap::new();\n/// a.insert(1, "a");\n/// let capacity_before_clear = a.capacity();\n///\n/// a.clear();\n///\n/// // Map is empty.\n/// assert!(a.is_empty());\n/// // But map capacity is equal to old one.\n/// assert_eq!(a.capacity(), capacity_before_clear);\n/// ```\ninline\npub fn clear(&mut self){\n        self.table.clear();\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::contains_key': ['/// Returns `true` if the map contains a value for the specified key.\n///\n/// The key may be any borrowed form of the map\'s key type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the key type.\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(1, "a");\n/// assert_eq!(map.contains_key(&1), true);\n/// assert_eq!(map.contains_key(&2), false);\n/// ```\ninline\npub fn contains_key<Q>(&self, k: &Q) -> bool\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        self.get_inner(k).is_some()\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::drain': ['/// Clears the map, returning all key-value pairs as an iterator. Keeps the\n/// allocated memory for reuse.\n///\n/// If the returned iterator is dropped before being fully consumed, it\n/// drops the remaining key-value pairs. The returned iterator keeps a\n/// mutable borrow on the vector to optimize its implementation.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut a = HashMap::new();\n/// a.insert(1, "a");\n/// a.insert(2, "b");\n/// let capacity_before_drain = a.capacity();\n///\n/// for (k, v) in a.drain().take(1) {\n///     assert!(k == 1 || k == 2);\n///     assert!(v == "a" || v == "b");\n/// }\n///\n/// // As we can see, the map is empty and contains no element.\n/// assert!(a.is_empty() && a.len() == 0);\n/// // But map capacity is equal to old one.\n/// assert_eq!(a.capacity(), capacity_before_drain);\n///\n/// let mut a = HashMap::new();\n/// a.insert(1, "a");\n/// a.insert(2, "b");\n///\n/// {   // Iterator is dropped without being consumed.\n///     let d = a.drain();\n/// }\n///\n/// // But the map is empty even if we do not use Drain iterator.\n/// assert!(a.is_empty());\n/// ```\ninline\npub fn drain(&mut self) -> Drain<\'_, K, V, A>{\n        Drain {\n            inner: self.table.drain(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::entry': ['/// Gets the given key\'s corresponding entry in the map for in-place manipulation.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut letters = HashMap::new();\n///\n/// for ch in "a short treatise on fungi".chars() {\n///     let counter = letters.entry(ch).or_insert(0);\n///     *counter += 1;\n/// }\n///\n/// assert_eq!(letters[&\'s\'], 2);\n/// assert_eq!(letters[&\'t\'], 3);\n/// assert_eq!(letters[&\'u\'], 1);\n/// assert_eq!(letters.get(&\'y\'), None);\n/// ```\ninline\npub fn entry(&mut self, key: K) -> Entry<\'_, K, V, S, A>{\n        let hash = make_hash::<K, S>(&self.hash_builder, &key);\n        if let Some(elem) = self.table.find(hash, equivalent_key(&key)) {\n            Entry::Occupied(OccupiedEntry {\n                hash,\n                elem,\n                table: self,\n            })\n        } else {\n            Entry::Vacant(VacantEntry {\n                hash,\n                key,\n                table: self,\n            })\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::entry_ref': ['/// Gets the given key\'s corresponding entry by reference in the map for in-place manipulation.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut words: HashMap<String, usize> = HashMap::new();\n/// let source = ["poneyland", "horseyland", "poneyland", "poneyland"];\n/// for (i, &s) in source.iter().enumerate() {\n///     let counter = words.entry_ref(s).or_insert(0);\n///     *counter += 1;\n/// }\n///\n/// assert_eq!(words["poneyland"], 3);\n/// assert_eq!(words["horseyland"], 1);\n/// ```\ninline\npub fn entry_ref<\'a, \'b, Q>(&\'a mut self, key: &\'b Q) -> EntryRef<\'a, \'b, K, Q, V, S, A>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        let hash = make_hash::<Q, S>(&self.hash_builder, key);\n        if let Some(elem) = self.table.find(hash, equivalent_key(key)) {\n            EntryRef::Occupied(OccupiedEntry {\n                hash,\n                elem,\n                table: self,\n            })\n        } else {\n            EntryRef::Vacant(VacantEntryRef {\n                hash,\n                key,\n                table: self,\n            })\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::extract_if': ["/// Drains elements which are true under the given predicate,\n/// and returns an iterator over the removed items.\n///\n/// In other words, move all pairs `(k, v)` such that `f(&k, &mut v)` returns `true` out\n/// into another iterator.\n///\n/// Note that `extract_if` lets you mutate every value in the filter closure, regardless of\n/// whether you choose to keep or remove it.\n///\n/// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n/// or the iteration short-circuits, then the remaining elements will be retained.\n/// Use [`retain()`] with a negated predicate if you do not need the returned iterator.\n///\n/// Keeps the allocated memory for reuse.\n///\n/// [`retain()`]: HashMap::retain\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n///\n/// let drained: HashMap<i32, i32> = map.extract_if(|k, _v| k % 2 == 0).collect();\n///\n/// let mut evens = drained.keys().cloned().collect::<Vec<_>>();\n/// let mut odds = map.keys().cloned().collect::<Vec<_>>();\n/// evens.sort();\n/// odds.sort();\n///\n/// assert_eq!(evens, vec![0, 2, 4, 6]);\n/// assert_eq!(odds, vec![1, 3, 5, 7]);\n///\n/// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n///\n/// {   // Iterator is dropped without being consumed.\n///     let d = map.extract_if(|k, _v| k % 2 != 0);\n/// }\n///\n/// // ExtractIf was not exhausted, therefore no elements were drained.\n/// assert_eq!(map.len(), 8);\n/// ```\ninline\npub fn extract_if<F>(&mut self, f: F) -> ExtractIf<'_, K, V, F, A>\n    where\n        F: FnMut(&K, &mut V) -> bool,{\n        ExtractIf {\n            f,\n            inner: RawExtractIf {\n                iter: unsafe { self.table.iter() },\n                table: &mut self.table,\n            },\n        }\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::find_or_find_insert_slot': ['inline\npub(crate) fn find_or_find_insert_slot<Q>(\n        &mut self,\n        hash: u64,\n        key: &Q,\n    ) -> Result<Bucket<(K, V)>, crate::raw::InsertSlot>\n    where\n        Q: Equivalent<K> + ?Sized,{\n        self.table.find_or_find_insert_slot(\n            hash,\n            equivalent_key(key),\n            make_hasher(&self.hash_builder),\n        )\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get': ['/// Returns a reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map\'s key type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the key type.\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(1, "a");\n/// assert_eq!(map.get(&1), Some(&"a"));\n/// assert_eq!(map.get(&2), None);\n/// ```\n#[inline]\npub fn get<Q>(&self, k: &Q) -> Option<&V>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.get_inner(k) {\n            Some((_, v)) => Some(v),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_inner': ['#[inline]\nfn get_inner<Q>(&self, k: &Q) -> Option<&(K, V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        if self.table.is_empty() {\n            None\n        } else {\n            let hash = make_hash::<Q, S>(&self.hash_builder, k);\n            self.table.get(hash, equivalent_key(k))\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_inner_mut': ['#[inline]\nfn get_inner_mut<Q>(&mut self, k: &Q) -> Option<&mut (K, V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        if self.table.is_empty() {\n            None\n        } else {\n            let hash = make_hash::<Q, S>(&self.hash_builder, k);\n            self.table.get_mut(hash, equivalent_key(k))\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_key_value': ['/// Returns the key-value pair corresponding to the supplied key.\n///\n/// The supplied key may be any borrowed form of the map\'s key type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the key type.\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(1, "a");\n/// assert_eq!(map.get_key_value(&1), Some((&1, &"a")));\n/// assert_eq!(map.get_key_value(&2), None);\n/// ```\n#[inline]\npub fn get_key_value<Q>(&self, k: &Q) -> Option<(&K, &V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.get_inner(k) {\n            Some((key, value)) => Some((key, value)),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_key_value_mut': ['/// Returns the key-value pair corresponding to the supplied key, with a mutable reference to value.\n///\n/// The supplied key may be any borrowed form of the map\'s key type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the key type.\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(1, "a");\n/// let (k, v) = map.get_key_value_mut(&1).unwrap();\n/// assert_eq!(k, &1);\n/// assert_eq!(v, &mut "a");\n/// *v = "b";\n/// assert_eq!(map.get_key_value_mut(&1), Some((&1, &mut "b")));\n/// assert_eq!(map.get_key_value_mut(&2), None);\n/// ```\n#[inline]\npub fn get_key_value_mut<Q>(&mut self, k: &Q) -> Option<(&K, &mut V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.get_inner_mut(k) {\n            Some(&mut (ref key, ref mut value)) => Some((key, value)),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_many_key_value_mut': ['/// Attempts to get mutable references to `N` values in the map at once, with immutable\n/// references to the corresponding keys.\n///\n/// Returns an array of length `N` with the results of each query. For soundness, at most one\n/// mutable reference will be returned to any value. `None` will be used if the key is missing.\n///\n/// # Panics\n///\n/// Panics if any keys are overlapping.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut libraries = HashMap::new();\n/// libraries.insert("Bodleian Library".to_string(), 1602);\n/// libraries.insert("Athenum".to_string(), 1807);\n/// libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n/// libraries.insert("Library of Congress".to_string(), 1800);\n///\n/// let got = libraries.get_many_key_value_mut([\n///     "Bodleian Library",\n///     "Herzogin-Anna-Amalia-Bibliothek",\n/// ]);\n/// assert_eq!(\n///     got,\n///     [\n///         Some((&"Bodleian Library".to_string(), &mut 1602)),\n///         Some((&"Herzogin-Anna-Amalia-Bibliothek".to_string(), &mut 1691)),\n///     ],\n/// );\n/// // Missing keys result in None\n/// let got = libraries.get_many_key_value_mut([\n///     "Bodleian Library",\n///     "Gewandhaus",\n/// ]);\n/// assert_eq!(got, [Some((&"Bodleian Library".to_string(), &mut 1602)), None]);\n/// ```\n///\n/// ```should_panic\n/// use hashbrown::HashMap;\n///\n/// let mut libraries = HashMap::new();\n/// libraries.insert("Bodleian Library".to_string(), 1602);\n/// libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n///\n/// // Duplicate keys result in panic!\n/// let got = libraries.get_many_key_value_mut([\n///     "Bodleian Library",\n///     "Herzogin-Anna-Amalia-Bibliothek",\n///     "Herzogin-Anna-Amalia-Bibliothek",\n/// ]);\n/// ```\npub fn get_many_key_value_mut<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<(&\'_ K, &\'_ mut V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        self.get_many_mut_inner(ks)\n            .map(|res| res.map(|(k, v)| (&*k, v)))\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_many_key_value_unchecked_mut': ['/// Attempts to get mutable references to `N` values in the map at once, with immutable\n/// references to the corresponding keys, without validating that the values are unique.\n///\n/// Returns an array of length `N` with the results of each query. `None` will be returned if\n/// any of the keys are missing.\n///\n/// For a safe alternative see [`get_many_key_value_mut`](`HashMap::get_many_key_value_mut`).\n///\n/// # Safety\n///\n/// Calling this method with overlapping keys is *[undefined behavior]* even if the resulting\n/// references are not used.\n///\n/// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut libraries = HashMap::new();\n/// libraries.insert("Bodleian Library".to_string(), 1602);\n/// libraries.insert("Athenum".to_string(), 1807);\n/// libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n/// libraries.insert("Library of Congress".to_string(), 1800);\n///\n/// let got = libraries.get_many_key_value_mut([\n///     "Bodleian Library",\n///     "Herzogin-Anna-Amalia-Bibliothek",\n/// ]);\n/// assert_eq!(\n///     got,\n///     [\n///         Some((&"Bodleian Library".to_string(), &mut 1602)),\n///         Some((&"Herzogin-Anna-Amalia-Bibliothek".to_string(), &mut 1691)),\n///     ],\n/// );\n/// // Missing keys result in None\n/// let got = libraries.get_many_key_value_mut([\n///     "Bodleian Library",\n///     "Gewandhaus",\n/// ]);\n/// assert_eq!(\n///     got,\n///     [\n///         Some((&"Bodleian Library".to_string(), &mut 1602)),\n///         None,\n///     ],\n/// );\n/// ```\npub unsafe fn get_many_key_value_unchecked_mut<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<(&\'_ K, &\'_ mut V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        self.get_many_unchecked_mut_inner(ks)\n            .map(|res| res.map(|(k, v)| (&*k, v)))\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_many_mut': ['/// Attempts to get mutable references to `N` values in the map at once.\n///\n/// Returns an array of length `N` with the results of each query. For soundness, at most one\n/// mutable reference will be returned to any value. `None` will be used if the key is missing.\n///\n/// # Panics\n///\n/// Panics if any keys are overlapping.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut libraries = HashMap::new();\n/// libraries.insert("Bodleian Library".to_string(), 1602);\n/// libraries.insert("Athenum".to_string(), 1807);\n/// libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n/// libraries.insert("Library of Congress".to_string(), 1800);\n///\n/// // Get Athenum and Bodleian Library\n/// let [Some(a), Some(b)] = libraries.get_many_mut([\n///     "Athenum",\n///     "Bodleian Library",\n/// ]) else { panic!() };\n///\n/// // Assert values of Athenum and Library of Congress\n/// let got = libraries.get_many_mut([\n///     "Athenum",\n///     "Library of Congress",\n/// ]);\n/// assert_eq!(\n///     got,\n///     [\n///         Some(&mut 1807),\n///         Some(&mut 1800),\n///     ],\n/// );\n///\n/// // Missing keys result in None\n/// let got = libraries.get_many_mut([\n///     "Athenum",\n///     "New York Public Library",\n/// ]);\n/// assert_eq!(\n///     got,\n///     [\n///         Some(&mut 1807),\n///         None\n///     ]\n/// );\n/// ```\n///\n/// ```should_panic\n/// use hashbrown::HashMap;\n///\n/// let mut libraries = HashMap::new();\n/// libraries.insert("Athenum".to_string(), 1807);\n///\n/// // Duplicate keys panic!\n/// let got = libraries.get_many_mut([\n///     "Athenum",\n///     "Athenum",\n/// ]);\n/// ```\npub fn get_many_mut<Q, const N: usize>(&mut self, ks: [&Q; N]) -> [Option<&\'_ mut V>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        self.get_many_mut_inner(ks).map(|res| res.map(|(_, v)| v))\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_many_mut_inner': ["fn get_many_mut_inner<Q, const N: usize>(&mut self, ks: [&Q; N]) -> [Option<&'_ mut (K, V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        let hashes = self.build_hashes_inner(ks);\n        self.table\n            .get_many_mut(hashes, |i, (k, _)| ks[i].equivalent(k))\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_many_unchecked_mut': ['/// Attempts to get mutable references to `N` values in the map at once, without validating that\n/// the values are unique.\n///\n/// Returns an array of length `N` with the results of each query. `None` will be used if\n/// the key is missing.\n///\n/// For a safe alternative see [`get_many_mut`](`HashMap::get_many_mut`).\n///\n/// # Safety\n///\n/// Calling this method with overlapping keys is *[undefined behavior]* even if the resulting\n/// references are not used.\n///\n/// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut libraries = HashMap::new();\n/// libraries.insert("Bodleian Library".to_string(), 1602);\n/// libraries.insert("Athenum".to_string(), 1807);\n/// libraries.insert("Herzogin-Anna-Amalia-Bibliothek".to_string(), 1691);\n/// libraries.insert("Library of Congress".to_string(), 1800);\n///\n/// // SAFETY: The keys do not overlap.\n/// let [Some(a), Some(b)] = (unsafe { libraries.get_many_unchecked_mut([\n///     "Athenum",\n///     "Bodleian Library",\n/// ]) }) else { panic!() };\n///\n/// // SAFETY: The keys do not overlap.\n/// let got = unsafe { libraries.get_many_unchecked_mut([\n///     "Athenum",\n///     "Library of Congress",\n/// ]) };\n/// assert_eq!(\n///     got,\n///     [\n///         Some(&mut 1807),\n///         Some(&mut 1800),\n///     ],\n/// );\n///\n/// // SAFETY: The keys do not overlap.\n/// let got = unsafe { libraries.get_many_unchecked_mut([\n///     "Athenum",\n///     "New York Public Library",\n/// ]) };\n/// // Missing keys result in None\n/// assert_eq!(got, [Some(&mut 1807), None]);\n/// ```\npub unsafe fn get_many_unchecked_mut<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<&\'_ mut V>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        self.get_many_unchecked_mut_inner(ks)\n            .map(|res| res.map(|(_, v)| v))\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_many_unchecked_mut_inner': ["unsafe fn get_many_unchecked_mut_inner<Q, const N: usize>(\n        &mut self,\n        ks: [&Q; N],\n    ) -> [Option<&'_ mut (K, V)>; N]\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        let hashes = self.build_hashes_inner(ks);\n        self.table\n            .get_many_unchecked_mut(hashes, |i, (k, _)| ks[i].equivalent(k))\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::get_mut': ['/// Returns a mutable reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map\'s key type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the key type.\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert(1, "a");\n/// if let Some(x) = map.get_mut(&1) {\n///     *x = "b";\n/// }\n/// assert_eq!(map[&1], "b");\n///\n/// assert_eq!(map.get_mut(&2), None);\n/// ```\ninline\npub fn get_mut<Q>(&mut self, k: &Q) -> Option<&mut V>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.get_inner_mut(k) {\n            Some(&mut (_, ref mut v)) => Some(v),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::hasher': ["/// Returns a reference to the map's [`BuildHasher`].\n///\n/// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::DefaultHashBuilder;\n///\n/// let hasher = DefaultHashBuilder::default();\n/// let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n/// let hasher: &DefaultHashBuilder = map.hasher();\n/// ```\ninline\npub fn hasher(&self) -> &S{\n        &self.hash_builder\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::insert': ['/// Inserts a key-value pair into the map.\n///\n/// If the map did not have this key present, [`None`] is returned.\n///\n/// If the map did have this key present, the value is updated, and the old\n/// value is returned. The key is not updated, though; this matters for\n/// types that can be `==` without being identical. See the [`std::collections`]\n/// [module-level documentation] for more.\n///\n/// [`None`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n/// [`std::collections`]: https://doc.rust-lang.org/std/collections/index.html\n/// [module-level documentation]: https://doc.rust-lang.org/std/collections/index.html#insert-and-complex-keys\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// assert_eq!(map.insert(37, "a"), None);\n/// assert_eq!(map.is_empty(), false);\n///\n/// map.insert(37, "b");\n/// assert_eq!(map.insert(37, "c"), Some("b"));\n/// assert_eq!(map[&37], "c");\n/// ```\ninline\npub fn insert(&mut self, k: K, v: V) -> Option<V>{\n        let hash = make_hash::<K, S>(&self.hash_builder, &k);\n        match self.find_or_find_insert_slot(hash, &k) {\n            Ok(bucket) => Some(mem::replace(unsafe { &mut bucket.as_mut().1 }, v)),\n            Err(slot) => {\n                unsafe {\n                    self.table.insert_in_slot(hash, slot, (k, v));\n                }\n                None\n            }\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::insert_unique_unchecked': ['/// Insert a key-value pair into the map without checking\n/// if the key already exists in the map.\n///\n/// This operation is faster than regular insert, because it does not perform\n/// lookup before insertion.\n///\n/// This operation is useful during initial population of the map.\n/// For example, when constructing a map from another map, we know\n/// that keys are unique.\n///\n/// Returns a reference to the key and value just inserted.\n///\n/// # Safety\n///\n/// This operation is safe if a key does not exist in the map.\n///\n/// However, if a key exists in the map already, the behavior is unspecified:\n/// this operation may panic, loop forever, or any following operation with the map\n/// may panic, loop forever or return arbitrary result.\n///\n/// That said, this operation (and following operations) are guaranteed to\n/// not violate memory safety.\n///\n/// However this operation is still unsafe because the resulting `HashMap`\n/// may be passed to unsafe code which does expect the map to behave\n/// correctly, and would cause unsoundness as a result.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map1 = HashMap::new();\n/// assert_eq!(map1.insert(1, "a"), None);\n/// assert_eq!(map1.insert(2, "b"), None);\n/// assert_eq!(map1.insert(3, "c"), None);\n/// assert_eq!(map1.len(), 3);\n///\n/// let mut map2 = HashMap::new();\n///\n/// for (key, value) in map1.into_iter() {\n///     unsafe {\n///         map2.insert_unique_unchecked(key, value);\n///     }\n/// }\n///\n/// let (key, value) = unsafe { map2.insert_unique_unchecked(4, "d") };\n/// assert_eq!(key, &4);\n/// assert_eq!(value, &mut "d");\n/// *value = "e";\n///\n/// assert_eq!(map2[&1], "a");\n/// assert_eq!(map2[&2], "b");\n/// assert_eq!(map2[&3], "c");\n/// assert_eq!(map2[&4], "e");\n/// assert_eq!(map2.len(), 4);\n/// ```\ninline\npub unsafe fn insert_unique_unchecked(&mut self, k: K, v: V) -> (&K, &mut V){\n        let hash = make_hash::<K, S>(&self.hash_builder, &k);\n        let bucket = self\n            .table\n            .insert(hash, (k, v), make_hasher::<_, V, S>(&self.hash_builder));\n        let (k_ref, v_ref) = unsafe { bucket.as_mut() };\n        (k_ref, v_ref)\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::into_keys': ['/// Creates a consuming iterator visiting all the keys in arbitrary order.\n/// The map cannot be used after calling this.\n/// The iterator element type is `K`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert("a", 1);\n/// map.insert("b", 2);\n/// map.insert("c", 3);\n///\n/// let mut vec: Vec<&str> = map.into_keys().collect();\n///\n/// // The `IntoKeys` iterator produces keys in arbitrary order, so the\n/// // keys must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, ["a", "b", "c"]);\n/// ```\n#[inline]\npub fn into_keys(self) -> IntoKeys<K, V, A>{\n        IntoKeys {\n            inner: self.into_iter(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::into_values': ['/// Creates a consuming iterator visiting all the values in arbitrary order.\n/// The map cannot be used after calling this.\n/// The iterator element type is `V`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert("a", 1);\n/// map.insert("b", 2);\n/// map.insert("c", 3);\n///\n/// let mut vec: Vec<i32> = map.into_values().collect();\n///\n/// // The `IntoValues` iterator produces values in arbitrary order, so\n/// // the values must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [1, 2, 3]);\n/// ```\n#[inline]\npub fn into_values(self) -> IntoValues<K, V, A>{\n        IntoValues {\n            inner: self.into_iter(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::is_empty': ['/// Returns `true` if the map contains no elements.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut a = HashMap::new();\n/// assert!(a.is_empty());\n/// a.insert(1, "a");\n/// assert!(!a.is_empty());\n/// ```\ninline\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::iter': ['/// An iterator visiting all key-value pairs in arbitrary order.\n/// The iterator element type is `(&\'a K, &\'a V)`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert("a", 1);\n/// map.insert("b", 2);\n/// map.insert("c", 3);\n/// assert_eq!(map.len(), 3);\n/// let mut vec: Vec<(&str, i32)> = Vec::new();\n///\n/// for (key, val) in map.iter() {\n///     println!("key: {} val: {}", key, val);\n///     vec.push((*key, *val));\n/// }\n///\n/// // The `Iter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [("a", 1), ("b", 2), ("c", 3)]);\n///\n/// assert_eq!(map.len(), 3);\n/// ```\ninline\npub fn iter(&self) -> Iter<\'_, K, V>{\n        // Here we tie the lifetime of self to the iter.\n        unsafe {\n            Iter {\n                inner: self.table.iter(),\n                marker: PhantomData,\n            }\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::iter_mut': ['/// An iterator visiting all key-value pairs in arbitrary order,\n/// with mutable references to the values.\n/// The iterator element type is `(&\'a K, &\'a mut V)`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert("a", 1);\n/// map.insert("b", 2);\n/// map.insert("c", 3);\n///\n/// // Update all values\n/// for (_, val) in map.iter_mut() {\n///     *val *= 2;\n/// }\n///\n/// assert_eq!(map.len(), 3);\n/// let mut vec: Vec<(&str, i32)> = Vec::new();\n///\n/// for (key, val) in &map {\n///     println!("key: {} val: {}", key, val);\n///     vec.push((*key, *val));\n/// }\n///\n/// // The `Iter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [("a", 2), ("b", 4), ("c", 6)]);\n///\n/// assert_eq!(map.len(), 3);\n/// ```\ninline\npub fn iter_mut(&mut self) -> IterMut<\'_, K, V>{\n        // Here we tie the lifetime of self to the iter.\n        unsafe {\n            IterMut {\n                inner: self.table.iter(),\n                marker: PhantomData,\n            }\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::keys': ['/// An iterator visiting all keys in arbitrary order.\n/// The iterator element type is `&\'a K`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert("a", 1);\n/// map.insert("b", 2);\n/// map.insert("c", 3);\n/// assert_eq!(map.len(), 3);\n/// let mut vec: Vec<&str> = Vec::new();\n///\n/// for key in map.keys() {\n///     println!("{}", key);\n///     vec.push(*key);\n/// }\n///\n/// // The `Keys` iterator produces keys in arbitrary order, so the\n/// // keys must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, ["a", "b", "c"]);\n///\n/// assert_eq!(map.len(), 3);\n/// ```\ninline\npub fn keys(&self) -> Keys<\'_, K, V>{\n        Keys { inner: self.iter() }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::len': ['/// Returns the number of elements in the map.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut a = HashMap::new();\n/// assert_eq!(a.len(), 0);\n/// a.insert(1, "a");\n/// assert_eq!(a.len(), 1);\n/// ```\ninline\npub fn len(&self) -> usize{\n        self.table.len()\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::remove': ['/// Removes a key from the map, returning the value at the key if the key\n/// was previously in the map. Keeps the allocated memory for reuse.\n///\n/// The key may be any borrowed form of the map\'s key type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the key type.\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// // The map is empty\n/// assert!(map.is_empty() && map.capacity() == 0);\n///\n/// map.insert(1, "a");\n///\n/// assert_eq!(map.remove(&1), Some("a"));\n/// assert_eq!(map.remove(&1), None);\n///\n/// // Now map holds none elements\n/// assert!(map.is_empty());\n/// ```\ninline\npub fn remove<Q>(&mut self, k: &Q) -> Option<V>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.remove_entry(k) {\n            Some((_, v)) => Some(v),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::remove_entry': ['/// Removes a key from the map, returning the stored key and value if the\n/// key was previously in the map. Keeps the allocated memory for reuse.\n///\n/// The key may be any borrowed form of the map\'s key type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the key type.\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// // The map is empty\n/// assert!(map.is_empty() && map.capacity() == 0);\n///\n/// map.insert(1, "a");\n///\n/// assert_eq!(map.remove_entry(&1), Some((1, "a")));\n/// assert_eq!(map.remove(&1), None);\n///\n/// // Now map hold none elements\n/// assert!(map.is_empty());\n/// ```\ninline\npub fn remove_entry<Q>(&mut self, k: &Q) -> Option<(K, V)>\n    where\n        Q: Hash + Equivalent<K> + ?Sized,{\n        let hash = make_hash::<Q, S>(&self.hash_builder, k);\n        self.table.remove_entry(hash, equivalent_key(k))\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::reserve': ["/// Reserves capacity for at least `additional` more elements to be inserted\n/// in the `HashMap`. The collection may reserve more space to avoid\n/// frequent reallocations.\n///\n/// # Panics\n///\n/// Panics if the new capacity exceeds [`isize::MAX`] bytes and [`abort`] the program\n/// in case of allocation error. Use [`try_reserve`](HashMap::try_reserve) instead\n/// if you want to handle memory allocation failure.\n///\n/// [`isize::MAX`]: https://doc.rust-lang.org/std/primitive.isize.html\n/// [`abort`]: https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// let mut map: HashMap<&str, i32> = HashMap::new();\n/// // Map is empty and doesn't allocate memory\n/// assert_eq!(map.capacity(), 0);\n///\n/// map.reserve(10);\n///\n/// // And now map can hold at least 10 elements\n/// assert!(map.capacity() >= 10);\n/// ```\ninline\npub fn reserve(&mut self, additional: usize){\n        self.table\n            .reserve(additional, make_hasher::<_, V, S>(&self.hash_builder));\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::retain': ['/// Retains only the elements specified by the predicate. Keeps the\n/// allocated memory for reuse.\n///\n/// In other words, remove all pairs `(k, v)` such that `f(&k, &mut v)` returns `false`.\n/// The elements are visited in unsorted (and unspecified) order.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<i32, i32> = (0..8).map(|x|(x, x*10)).collect();\n/// assert_eq!(map.len(), 8);\n///\n/// map.retain(|&k, _| k % 2 == 0);\n///\n/// // We can see, that the number of elements inside map is changed.\n/// assert_eq!(map.len(), 4);\n///\n/// let mut vec: Vec<(i32, i32)> = map.iter().map(|(&k, &v)| (k, v)).collect();\n/// vec.sort_unstable();\n/// assert_eq!(vec, [(0, 0), (2, 20), (4, 40), (6, 60)]);\n/// ```\npub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&K, &mut V) -> bool,{\n        // Here we only use `iter` as a temporary, preventing use-after-free\n        unsafe {\n            for item in self.table.iter() {\n                let &mut (ref key, ref mut value) = item.as_mut();\n                if !f(key, value) {\n                    self.table.erase(item);\n                }\n            }\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::shrink_to': ['/// Shrinks the capacity of the map with a lower limit. It will drop\n/// down no lower than the supplied limit while maintaining the internal rules\n/// and possibly leaving some space in accordance with the resize policy.\n///\n/// This function does nothing if the current capacity is smaller than the\n/// supplied minimum capacity.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n/// assert!(map.capacity() >= 100);\n/// map.shrink_to(10);\n/// assert!(map.capacity() >= 10);\n/// map.shrink_to(0);\n/// assert!(map.capacity() >= 2);\n/// map.shrink_to(10);\n/// assert!(map.capacity() >= 2);\n/// ```\ninline\npub fn shrink_to(&mut self, min_capacity: usize){\n        self.table\n            .shrink_to(min_capacity, make_hasher::<_, V, S>(&self.hash_builder));\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::shrink_to_fit': ['/// Shrinks the capacity of the map as much as possible. It will drop\n/// down as much as possible while maintaining the internal rules\n/// and possibly leaving some space in accordance with the resize policy.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n/// assert!(map.capacity() >= 100);\n/// map.shrink_to_fit();\n/// assert!(map.capacity() >= 2);\n/// ```\ninline\npub fn shrink_to_fit(&mut self){\n        self.table\n            .shrink_to(0, make_hasher::<_, V, S>(&self.hash_builder));\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::try_insert': ['/// Tries to insert a key-value pair into the map, and returns\n/// a mutable reference to the value in the entry.\n///\n/// # Errors\n///\n/// If the map already had this key present, nothing is updated, and\n/// an error containing the occupied entry and the value is returned.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::OccupiedError;\n///\n/// let mut map = HashMap::new();\n/// assert_eq!(map.try_insert(37, "a").unwrap(), &"a");\n///\n/// match map.try_insert(37, "b") {\n///     Err(OccupiedError { entry, value }) => {\n///         assert_eq!(entry.key(), &37);\n///         assert_eq!(entry.get(), &"a");\n///         assert_eq!(value, "b");\n///     }\n///     _ => panic!()\n/// }\n/// ```\ninline\npub fn try_insert(\n        &mut self,\n        key: K,\n        value: V,\n    ) -> Result<&mut V, OccupiedError<\'_, K, V, S, A>>{\n        match self.entry(key) {\n            Entry::Occupied(entry) => Err(OccupiedError { entry, value }),\n            Entry::Vacant(entry) => Ok(entry.insert(value)),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::try_reserve': ['/// Tries to reserve capacity for at least `additional` more elements to be inserted\n/// in the given `HashMap<K,V>`. The collection may reserve more space to avoid\n/// frequent reallocations.\n///\n/// # Errors\n///\n/// If the capacity overflows, or the allocator reports a failure, then an error\n/// is returned.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, isize> = HashMap::new();\n/// // Map is empty and doesn\'t allocate memory\n/// assert_eq!(map.capacity(), 0);\n///\n/// map.try_reserve(10).expect("why is the test harness OOMing on 10 bytes?");\n///\n/// // And now map can hold at least 10 elements\n/// assert!(map.capacity() >= 10);\n/// ```\n/// If the capacity overflows, or the allocator reports a failure, then an error\n/// is returned:\n/// ```\n/// # fn test() {\n/// use hashbrown::HashMap;\n/// use hashbrown::TryReserveError;\n/// let mut map: HashMap<i32, i32> = HashMap::new();\n///\n/// match map.try_reserve(usize::MAX) {\n///     Err(error) => match error {\n///         TryReserveError::CapacityOverflow => {}\n///         _ => panic!("TryReserveError::AllocError ?"),\n///     },\n///     _ => panic!(),\n/// }\n/// # }\n/// # fn main() {\n/// #     #[cfg(not(miri))]\n/// #     test()\n/// # }\n/// ```\ninline\npub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError>{\n        self.table\n            .try_reserve(additional, make_hasher::<_, V, S>(&self.hash_builder))\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::values': ['/// An iterator visiting all values in arbitrary order.\n/// The iterator element type is `&\'a V`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.insert("a", 1);\n/// map.insert("b", 2);\n/// map.insert("c", 3);\n/// assert_eq!(map.len(), 3);\n/// let mut vec: Vec<i32> = Vec::new();\n///\n/// for val in map.values() {\n///     println!("{}", val);\n///     vec.push(*val);\n/// }\n///\n/// // The `Values` iterator produces values in arbitrary order, so the\n/// // values must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [1, 2, 3]);\n///\n/// assert_eq!(map.len(), 3);\n/// ```\ninline\npub fn values(&self) -> Values<\'_, K, V>{\n        Values { inner: self.iter() }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::values_mut': ['/// An iterator visiting all values mutably in arbitrary order.\n/// The iterator element type is `&\'a mut V`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n///\n/// map.insert("a", 1);\n/// map.insert("b", 2);\n/// map.insert("c", 3);\n///\n/// for val in map.values_mut() {\n///     *val = *val + 10;\n/// }\n///\n/// assert_eq!(map.len(), 3);\n/// let mut vec: Vec<i32> = Vec::new();\n///\n/// for val in map.values() {\n///     println!("{}", val);\n///     vec.push(*val);\n/// }\n///\n/// // The `Values` iterator produces values in arbitrary order, so the\n/// // values must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [11, 12, 13]);\n///\n/// assert_eq!(map.len(), 3);\n/// ```\ninline\npub fn values_mut(&mut self) -> ValuesMut<\'_, K, V>{\n        ValuesMut {\n            inner: self.iter_mut(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::with_capacity_and_hasher_in': ['/// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n/// to hash the keys. It will be allocated with the given allocator.\n///\n/// The hash map will be able to hold at least `capacity` elements without\n/// reallocating. If `capacity` is 0, the hash map will not allocate.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashMap`].\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::DefaultHashBuilder;\n///\n/// let s = DefaultHashBuilder::default();\n/// let mut map = HashMap::with_capacity_and_hasher(10, s);\n/// map.insert(1, 2);\n/// ```\ninline\npub fn with_capacity_and_hasher_in(capacity: usize, hash_builder: S, alloc: A) -> Self{\n        Self {\n            hash_builder,\n            table: RawTable::with_capacity_in(capacity, alloc),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S, A>::with_hasher_in': ['/// Creates an empty `HashMap` which will use the given hash builder to hash\n/// keys. It will be allocated with the given allocator.\n///\n/// The hash map is initially created with a capacity of 0, so it will not allocate until it\n/// is first inserted into.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashMap`].\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::DefaultHashBuilder;\n///\n/// let s = DefaultHashBuilder::default();\n/// let mut map = HashMap::with_hasher(s);\n/// map.insert(1, 2);\n/// ```\ninline\npub const fn with_hasher_in(hash_builder: S, alloc: A) -> Self{\n        Self {\n            hash_builder,\n            table: RawTable::new_in(alloc),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S>::with_capacity_and_hasher': ['/// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n/// to hash the keys.\n///\n/// The hash map will be able to hold at least `capacity` elements without\n/// reallocating. If `capacity` is 0, the hash map will not allocate.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashMap`].\n///\n/// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n/// the `HashMap` to be useful, see its documentation for details.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n/// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::DefaultHashBuilder;\n///\n/// let s = DefaultHashBuilder::default();\n/// let mut map = HashMap::with_capacity_and_hasher(10, s);\n/// assert_eq!(map.len(), 0);\n/// assert!(map.capacity() >= 10);\n///\n/// map.insert(1, 2);\n/// ```\ninline\npub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> Self{\n        Self {\n            hash_builder,\n            table: RawTable::with_capacity(capacity),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, S>::with_hasher': ['/// Creates an empty `HashMap` which will use the given hash builder to hash\n/// keys.\n///\n/// The hash map is initially created with a capacity of 0, so it will not\n/// allocate until it is first inserted into.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashMap`].\n///\n/// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n/// the `HashMap` to be useful, see its documentation for details.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n/// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::DefaultHashBuilder;\n///\n/// let s = DefaultHashBuilder::default();\n/// let mut map = HashMap::with_hasher(s);\n/// assert_eq!(map.len(), 0);\n/// assert_eq!(map.capacity(), 0);\n///\n/// map.insert(1, 2);\n/// ```\ninline\npub const fn with_hasher(hash_builder: S) -> Self{\n        Self {\n            hash_builder,\n            table: RawTable::new(),\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, foldhash::fast::RandomState, A>::new_in': ['/// Creates an empty `HashMap` using the given allocator.\n///\n/// The hash map is initially created with a capacity of 0, so it will not allocate until it\n/// is first inserted into.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashMap`], for example with\n/// [`with_hasher_in`](HashMap::with_hasher_in) method.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use bumpalo::Bump;\n///\n/// let bump = Bump::new();\n/// let mut map = HashMap::new_in(&bump);\n///\n/// // The created HashMap holds none elements\n/// assert_eq!(map.len(), 0);\n///\n/// // The created HashMap also doesn\'t allocate memory\n/// assert_eq!(map.capacity(), 0);\n///\n/// // Now we insert element inside created HashMap\n/// map.insert("One", 1);\n/// // We can see that the HashMap holds 1 element\n/// assert_eq!(map.len(), 1);\n/// // And it also allocates some capacity\n/// assert!(map.capacity() > 1);\n/// ```\ninline\npub fn new_in(alloc: A) -> Self{\n        Self::with_hasher_in(DefaultHashBuilder::default(), alloc)\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V, foldhash::fast::RandomState, A>::with_capacity_in': ['/// Creates an empty `HashMap` with the specified capacity using the given allocator.\n///\n/// The hash map will be able to hold at least `capacity` elements without\n/// reallocating. If `capacity` is 0, the hash map will not allocate.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashMap`], for example with\n/// [`with_capacity_and_hasher_in`](HashMap::with_capacity_and_hasher_in) method.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use bumpalo::Bump;\n///\n/// let bump = Bump::new();\n/// let mut map = HashMap::with_capacity_in(5, &bump);\n///\n/// // The created HashMap holds none elements\n/// assert_eq!(map.len(), 0);\n/// // But it can hold at least 5 elements without reallocating\n/// let empty_map_capacity = map.capacity();\n/// assert!(empty_map_capacity >= 5);\n///\n/// // Now we insert some 5 elements inside created HashMap\n/// map.insert("One",   1);\n/// map.insert("Two",   2);\n/// map.insert("Three", 3);\n/// map.insert("Four",  4);\n/// map.insert("Five",  5);\n///\n/// // We can see that the HashMap holds 5 elements\n/// assert_eq!(map.len(), 5);\n/// // But its capacity isn\'t changed\n/// assert_eq!(map.capacity(), empty_map_capacity)\n/// ```\ninline\npub fn with_capacity_in(capacity: usize, alloc: A) -> Self{\n        Self::with_capacity_and_hasher_in(capacity, DefaultHashBuilder::default(), alloc)\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V>::new': ['/// Creates an empty `HashMap`.\n///\n/// The hash map is initially created with a capacity of 0, so it will not allocate until it\n/// is first inserted into.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashMap`], for example with\n/// [`with_hasher`](HashMap::with_hasher) method.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// let mut map: HashMap<&str, i32> = HashMap::new();\n/// assert_eq!(map.len(), 0);\n/// assert_eq!(map.capacity(), 0);\n/// ```\ninline\npub fn new() -> Self{\n        Self::default()\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::HashMap::<K, V>::with_capacity': ['/// Creates an empty `HashMap` with the specified capacity.\n///\n/// The hash map will be able to hold at least `capacity` elements without\n/// reallocating. If `capacity` is 0, the hash map will not allocate.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashMap` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashMap`], for example with\n/// [`with_capacity_and_hasher`](HashMap::with_capacity_and_hasher) method.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// let mut map: HashMap<&str, i32> = HashMap::with_capacity(10);\n/// assert_eq!(map.len(), 0);\n/// assert!(map.capacity() >= 10);\n/// ```\ninline\npub fn with_capacity(capacity: usize) -> Self{\n        Self::with_capacity_and_hasher(capacity, DefaultHashBuilder::default())\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::IntoIter': ['/// An owning iterator over the entries of a `HashMap` in arbitrary order.\n/// The iterator element type is `(K, V)`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`HashMap`]\n/// (provided by the [`IntoIterator`] trait). See its documentation for more.\n/// The map cannot be used after calling that method.\n///\n/// [`into_iter`]: struct.HashMap.html#method.into_iter\n/// [`HashMap`]: struct.HashMap.html\n/// [`IntoIterator`]: https://doc.rust-lang.org/core/iter/trait.IntoIterator.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let map: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n///\n/// let mut iter = map.into_iter();\n/// let mut vec = vec![iter.next(), iter.next(), iter.next()];\n///\n/// // The `IntoIter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [Some((1, "a")), Some((2, "b")), Some((3, "c"))]);\n///\n/// // It is fused iterator\n/// assert_eq!(iter.next(), None);\n/// assert_eq!(iter.next(), None);\n/// ```\npub struct IntoIter<K, V, A: Allocator = Global> {\n    inner: RawIntoIter<(K, V), A>,\n}', 'Real(LocalPath("src/map.rs"))'], 'map::IntoIter::<K, V, A>::iter': ["/// Returns a iterator of references over the remaining items.\ninline\npub(super) fn iter(&self) -> Iter<'_, K, V>{\n        Iter {\n            inner: self.inner.iter(),\n            marker: PhantomData,\n        }\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::IntoKeys': ['/// An owning iterator over the keys of a `HashMap` in arbitrary order.\n/// The iterator element type is `K`.\n///\n/// This `struct` is created by the [`into_keys`] method on [`HashMap`].\n/// See its documentation for more.\n/// The map cannot be used after calling that method.\n///\n/// [`into_keys`]: struct.HashMap.html#method.into_keys\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let map: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n///\n/// let mut keys = map.into_keys();\n/// let mut vec = vec![keys.next(), keys.next(), keys.next()];\n///\n/// // The `IntoKeys` iterator produces keys in arbitrary order, so the\n/// // keys must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [Some(1), Some(2), Some(3)]);\n///\n/// // It is fused iterator\n/// assert_eq!(keys.next(), None);\n/// assert_eq!(keys.next(), None);\n/// ```\npub struct IntoKeys<K, V, A: Allocator = Global> {\n    inner: IntoIter<K, V, A>,\n}', 'Real(LocalPath("src/map.rs"))'], 'map::IntoValues': ['/// An owning iterator over the values of a `HashMap` in arbitrary order.\n/// The iterator element type is `V`.\n///\n/// This `struct` is created by the [`into_values`] method on [`HashMap`].\n/// See its documentation for more. The map cannot be used after calling that method.\n///\n/// [`into_values`]: struct.HashMap.html#method.into_values\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let map: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n///\n/// let mut values = map.into_values();\n/// let mut vec = vec![values.next(), values.next(), values.next()];\n///\n/// // The `IntoValues` iterator produces values in arbitrary order, so\n/// // the values must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [Some("a"), Some("b"), Some("c")]);\n///\n/// // It is fused iterator\n/// assert_eq!(values.next(), None);\n/// assert_eq!(values.next(), None);\n/// ```\npub struct IntoValues<K, V, A: Allocator = Global> {\n    inner: IntoIter<K, V, A>,\n}', 'Real(LocalPath("src/map.rs"))'], 'map::Iter': ['/// An iterator over the entries of a `HashMap` in arbitrary order.\n/// The iterator element type is `(&\'a K, &\'a V)`.\n///\n/// This `struct` is created by the [`iter`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`iter`]: struct.HashMap.html#method.iter\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let map: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n///\n/// let mut iter = map.iter();\n/// let mut vec = vec![iter.next(), iter.next(), iter.next()];\n///\n/// // The `Iter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [Some((&1, &"a")), Some((&2, &"b")), Some((&3, &"c"))]);\n///\n/// // It is fused iterator\n/// assert_eq!(iter.next(), None);\n/// assert_eq!(iter.next(), None);\n/// ```\npub struct Iter<\'a, K, V> {\n    inner: RawIter<(K, V)>,\n    marker: PhantomData<(&\'a K, &\'a V)>,\n}', 'Real(LocalPath("src/map.rs"))'], 'map::IterMut': ['/// A mutable iterator over the entries of a `HashMap` in arbitrary order.\n/// The iterator element type is `(&\'a K, &\'a mut V)`.\n///\n/// This `struct` is created by the [`iter_mut`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`iter_mut`]: struct.HashMap.html#method.iter_mut\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<_, _> = [(1, "One".to_owned()), (2, "Two".into())].into();\n///\n/// let mut iter = map.iter_mut();\n/// iter.next().map(|(_, v)| v.push_str(" Mississippi"));\n/// iter.next().map(|(_, v)| v.push_str(" Mississippi"));\n///\n/// // It is fused iterator\n/// assert_eq!(iter.next(), None);\n/// assert_eq!(iter.next(), None);\n///\n/// assert_eq!(map.get(&1).unwrap(), &"One Mississippi".to_owned());\n/// assert_eq!(map.get(&2).unwrap(), &"Two Mississippi".to_owned());\n/// ```\npub struct IterMut<\'a, K, V> {\n    inner: RawIter<(K, V)>,\n    // To ensure invariance with respect to V\n    marker: PhantomData<(&\'a K, &\'a mut V)>,\n}', 'Real(LocalPath("src/map.rs"))'], "map::IterMut::<'_, K, V>::iter": ["/// Returns a iterator of references over the remaining items.\ninline\npub(super) fn iter(&self) -> Iter<'_, K, V>{\n        Iter {\n            inner: self.inner.clone(),\n            marker: PhantomData,\n        }\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::Keys': ['/// An iterator over the keys of a `HashMap` in arbitrary order.\n/// The iterator element type is `&\'a K`.\n///\n/// This `struct` is created by the [`keys`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`keys`]: struct.HashMap.html#method.keys\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let map: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n///\n/// let mut keys = map.keys();\n/// let mut vec = vec![keys.next(), keys.next(), keys.next()];\n///\n/// // The `Keys` iterator produces keys in arbitrary order, so the\n/// // keys must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [Some(&1), Some(&2), Some(&3)]);\n///\n/// // It is fused iterator\n/// assert_eq!(keys.next(), None);\n/// assert_eq!(keys.next(), None);\n/// ```\npub struct Keys<\'a, K, V> {\n    inner: Iter<\'a, K, V>,\n}', 'Real(LocalPath("src/map.rs"))'], 'map::OccupiedEntry': ['/// A view into an occupied entry in a [`HashMap`].\n/// It is part of the [`Entry`] and [`EntryRef`] enums.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{Entry, HashMap, OccupiedEntry};\n///\n/// let mut map = HashMap::new();\n/// map.extend([("a", 10), ("b", 20), ("c", 30)]);\n///\n/// let _entry_o: OccupiedEntry<_, _, _> = map.entry("a").insert(100);\n/// assert_eq!(map.len(), 3);\n///\n/// // Existing key (insert and update)\n/// match map.entry("a") {\n///     Entry::Vacant(_) => unreachable!(),\n///     Entry::Occupied(mut view) => {\n///         assert_eq!(view.get(), &100);\n///         let v = view.get_mut();\n///         *v *= 10;\n///         assert_eq!(view.insert(1111), 1000);\n///     }\n/// }\n///\n/// assert_eq!(map[&"a"], 1111);\n/// assert_eq!(map.len(), 3);\n///\n/// // Existing key (take)\n/// match map.entry("c") {\n///     Entry::Vacant(_) => unreachable!(),\n///     Entry::Occupied(view) => {\n///         assert_eq!(view.remove_entry(), ("c", 30));\n///     }\n/// }\n/// assert_eq!(map.get(&"c"), None);\n/// assert_eq!(map.len(), 2);\n/// ```\npub struct OccupiedEntry<\'a, K, V, S = DefaultHashBuilder, A: Allocator = Global> {\n    hash: u64,\n    elem: Bucket<(K, V)>,\n    table: &\'a mut HashMap<K, V, S, A>,\n}', 'Real(LocalPath("src/map.rs"))'], "map::OccupiedEntry::<'a, K, V, S, A>::get": ['/// Gets a reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::Entry;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// map.entry("poneyland").or_insert(12);\n///\n/// match map.entry("poneyland") {\n///     Entry::Vacant(_) => panic!(),\n///     Entry::Occupied(entry) => assert_eq!(entry.get(), &12),\n/// }\n/// ```\ninline\npub fn get(&self) -> &V{\n        unsafe { &self.elem.as_ref().1 }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::OccupiedEntry::<'a, K, V, S, A>::get_mut": ['/// Gets a mutable reference to the value in the entry.\n///\n/// If you need a reference to the `OccupiedEntry` which may outlive the\n/// destruction of the `Entry` value, see [`into_mut`].\n///\n/// [`into_mut`]: #method.into_mut\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::Entry;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// map.entry("poneyland").or_insert(12);\n///\n/// assert_eq!(map["poneyland"], 12);\n/// if let Entry::Occupied(mut o) = map.entry("poneyland") {\n///     *o.get_mut() += 10;\n///     assert_eq!(*o.get(), 22);\n///\n///     // We can use the same Entry multiple times.\n///     *o.get_mut() += 2;\n/// }\n///\n/// assert_eq!(map["poneyland"], 24);\n/// ```\ninline\npub fn get_mut(&mut self) -> &mut V{\n        unsafe { &mut self.elem.as_mut().1 }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::OccupiedEntry::<'a, K, V, S, A>::insert": ['/// Sets the value of the entry, and returns the entry\'s old value.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::Entry;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// map.entry("poneyland").or_insert(12);\n///\n/// if let Entry::Occupied(mut o) = map.entry("poneyland") {\n///     assert_eq!(o.insert(15), 12);\n/// }\n///\n/// assert_eq!(map["poneyland"], 15);\n/// ```\ninline\npub fn insert(&mut self, value: V) -> V{\n        mem::replace(self.get_mut(), value)\n    }', 'Real(LocalPath("src/map.rs"))'], "map::OccupiedEntry::<'a, K, V, S, A>::into_mut": ['/// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n/// with a lifetime bound to the map itself.\n///\n/// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n///\n/// [`get_mut`]: #method.get_mut\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{Entry, HashMap};\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// map.entry("poneyland").or_insert(12);\n///\n/// assert_eq!(map["poneyland"], 12);\n///\n/// let value: &mut u32;\n/// match map.entry("poneyland") {\n///     Entry::Occupied(entry) => value = entry.into_mut(),\n///     Entry::Vacant(_) => panic!(),\n/// }\n/// *value += 10;\n///\n/// assert_eq!(map["poneyland"], 22);\n/// ```\ninline\npub fn into_mut(self) -> &\'a mut V{\n        unsafe { &mut self.elem.as_mut().1 }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::OccupiedEntry::<'a, K, V, S, A>::key": ['/// Gets a reference to the key in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{Entry, HashMap};\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// map.entry("poneyland").or_insert(12);\n///\n/// match map.entry("poneyland") {\n///     Entry::Vacant(_) => panic!(),\n///     Entry::Occupied(entry) => assert_eq!(entry.key(), &"poneyland"),\n/// }\n/// ```\ninline\npub fn key(&self) -> &K{\n        unsafe { &self.elem.as_ref().0 }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::OccupiedEntry::<'a, K, V, S, A>::remove": ['/// Takes the value out of the entry, and returns it.\n/// Keeps the allocated memory for reuse.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::Entry;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// // The map is empty\n/// assert!(map.is_empty() && map.capacity() == 0);\n///\n/// map.entry("poneyland").or_insert(12);\n///\n/// if let Entry::Occupied(o) = map.entry("poneyland") {\n///     assert_eq!(o.remove(), 12);\n/// }\n///\n/// assert_eq!(map.contains_key("poneyland"), false);\n/// // Now map hold none elements\n/// assert!(map.is_empty());\n/// ```\ninline\npub fn remove(self) -> V{\n        self.remove_entry().1\n    }', 'Real(LocalPath("src/map.rs"))'], "map::OccupiedEntry::<'a, K, V, S, A>::remove_entry": ['/// Take the ownership of the key and value from the map.\n/// Keeps the allocated memory for reuse.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::Entry;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// // The map is empty\n/// assert!(map.is_empty() && map.capacity() == 0);\n///\n/// map.entry("poneyland").or_insert(12);\n///\n/// if let Entry::Occupied(o) = map.entry("poneyland") {\n///     // We delete the entry from the map.\n///     assert_eq!(o.remove_entry(), ("poneyland", 12));\n/// }\n///\n/// assert_eq!(map.contains_key("poneyland"), false);\n/// // Now map hold none elements\n/// assert!(map.is_empty());\n/// ```\ninline\npub fn remove_entry(self) -> (K, V){\n        unsafe { self.table.table.remove(self.elem).0 }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::OccupiedEntry::<'a, K, V, S, A>::replace_entry_with": ['/// Provides shared access to the key and owned access to the value of\n/// the entry and allows to replace or remove it based on the\n/// value of the returned option.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::Entry;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// map.insert("poneyland", 42);\n///\n/// let entry = match map.entry("poneyland") {\n///     Entry::Occupied(e) => {\n///         e.replace_entry_with(|k, v| {\n///             assert_eq!(k, &"poneyland");\n///             assert_eq!(v, 42);\n///             Some(v + 1)\n///         })\n///     }\n///     Entry::Vacant(_) => panic!(),\n/// };\n///\n/// match entry {\n///     Entry::Occupied(e) => {\n///         assert_eq!(e.key(), &"poneyland");\n///         assert_eq!(e.get(), &43);\n///     }\n///     Entry::Vacant(_) => panic!(),\n/// }\n///\n/// assert_eq!(map["poneyland"], 43);\n///\n/// let entry = match map.entry("poneyland") {\n///     Entry::Occupied(e) => e.replace_entry_with(|_k, _v| None),\n///     Entry::Vacant(_) => panic!(),\n/// };\n///\n/// match entry {\n///     Entry::Vacant(e) => {\n///         assert_eq!(e.key(), &"poneyland");\n///     }\n///     Entry::Occupied(_) => panic!(),\n/// }\n///\n/// assert!(!map.contains_key("poneyland"));\n/// ```\ninline\npub fn replace_entry_with<F>(self, f: F) -> Entry<\'a, K, V, S, A>\n    where\n        F: FnOnce(&K, V) -> Option<V>,{\n        unsafe {\n            let mut spare_key = None;\n\n            self.table\n                .table\n                .replace_bucket_with(self.elem.clone(), |(key, value)| {\n                    if let Some(new_value) = f(&key, value) {\n                        Some((key, new_value))\n                    } else {\n                        spare_key = Some(key);\n                        None\n                    }\n                });\n\n            if let Some(key) = spare_key {\n                Entry::Vacant(VacantEntry {\n                    hash: self.hash,\n                    key,\n                    table: self.table,\n                })\n            } else {\n                Entry::Occupied(self)\n            }\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::OccupiedError': ['/// The error returned by [`try_insert`](HashMap::try_insert) when the key already exists.\n///\n/// Contains the occupied entry, and the value that was not inserted.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, OccupiedError};\n///\n/// let mut map: HashMap<_, _> = [("a", 10), ("b", 20)].into();\n///\n/// // try_insert method returns mutable reference to the value if keys are vacant,\n/// // but if the map did have key present, nothing is updated, and the provided\n/// // value is returned inside `Err(_)` variant\n/// match map.try_insert("a", 100) {\n///     Err(OccupiedError { mut entry, value }) => {\n///         assert_eq!(entry.key(), &"a");\n///         assert_eq!(value, 100);\n///         assert_eq!(entry.insert(100), 10)\n///     }\n///     _ => unreachable!(),\n/// }\n/// assert_eq!(map[&"a"], 100);\n/// ```\npub struct OccupiedError<\'a, K, V, S, A: Allocator = Global> {\n    /// The entry in the map that was already occupied.\n    pub entry: OccupiedEntry<\'a, K, V, S, A>,\n    /// The value which was not inserted, because the entry was already occupied.\n    pub value: V,\n}', 'Real(LocalPath("src/map.rs"))'], 'map::VacantEntry': ['/// A view into a vacant entry in a `HashMap`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{Entry, HashMap, VacantEntry};\n///\n/// let mut map = HashMap::<&str, i32>::new();\n///\n/// let entry_v: VacantEntry<_, _, _> = match map.entry("a") {\n///     Entry::Vacant(view) => view,\n///     Entry::Occupied(_) => unreachable!(),\n/// };\n/// entry_v.insert(10);\n/// assert!(map[&"a"] == 10 && map.len() == 1);\n///\n/// // Nonexistent key (insert and update)\n/// match map.entry("b") {\n///     Entry::Occupied(_) => unreachable!(),\n///     Entry::Vacant(view) => {\n///         let value = view.insert(2);\n///         assert_eq!(*value, 2);\n///         *value = 20;\n///     }\n/// }\n/// assert!(map[&"b"] == 20 && map.len() == 2);\n/// ```\npub struct VacantEntry<\'a, K, V, S = DefaultHashBuilder, A: Allocator = Global> {\n    hash: u64,\n    key: K,\n    table: &\'a mut HashMap<K, V, S, A>,\n}', 'Real(LocalPath("src/map.rs"))'], "map::VacantEntry::<'a, K, V, S, A>::insert": ['/// Sets the value of the entry with the [`VacantEntry`]\'s key,\n/// and returns a mutable reference to it.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::Entry;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// if let Entry::Vacant(o) = map.entry("poneyland") {\n///     o.insert(37);\n/// }\n/// assert_eq!(map["poneyland"], 37);\n/// ```\ninline\npub fn insert(self, value: V) -> &\'a mut V\n    where\n        K: Hash,\n        S: BuildHasher,{\n        let table = &mut self.table.table;\n        let entry = table.insert_entry(\n            self.hash,\n            (self.key, value),\n            make_hasher::<_, V, S>(&self.table.hash_builder),\n        );\n        &mut entry.1\n    }', 'Real(LocalPath("src/map.rs"))'], "map::VacantEntry::<'a, K, V, S, A>::insert_entry": ['/// Sets the value of the entry with the [`VacantEntry`]\'s key,\n/// and returns an [`OccupiedEntry`].\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::Entry;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// if let Entry::Vacant(v) = map.entry("poneyland") {\n///     let o = v.insert_entry(37);\n///     assert_eq!(o.get(), &37);\n/// }\n/// ```\ninline\npub fn insert_entry(self, value: V) -> OccupiedEntry<\'a, K, V, S, A>\n    where\n        K: Hash,\n        S: BuildHasher,{\n        let elem = self.table.table.insert(\n            self.hash,\n            (self.key, value),\n            make_hasher::<_, V, S>(&self.table.hash_builder),\n        );\n        OccupiedEntry {\n            hash: self.hash,\n            elem,\n            table: self.table,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::VacantEntry::<'a, K, V, S, A>::into_key": ['/// Take ownership of the key.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{Entry, HashMap};\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// match map.entry("poneyland") {\n///     Entry::Occupied(_) => panic!(),\n///     Entry::Vacant(v) => assert_eq!(v.into_key(), "poneyland"),\n/// }\n/// ```\ninline\npub fn into_key(self) -> K{\n        self.key\n    }', 'Real(LocalPath("src/map.rs"))'], "map::VacantEntry::<'a, K, V, S, A>::key": ['/// Gets a reference to the key that would be used when inserting a value\n/// through the `VacantEntry`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// assert_eq!(map.entry("poneyland").key(), &"poneyland");\n/// ```\ninline\npub fn key(&self) -> &K{\n        &self.key\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::VacantEntryRef': ['/// A view into a vacant entry in a `HashMap`.\n/// It is part of the [`EntryRef`] enum.\n///\n/// [`EntryRef`]: enum.EntryRef.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{EntryRef, HashMap, VacantEntryRef};\n///\n/// let mut map = HashMap::<String, i32>::new();\n///\n/// let entry_v: VacantEntryRef<_, _, _, _> = match map.entry_ref("a") {\n///     EntryRef::Vacant(view) => view,\n///     EntryRef::Occupied(_) => unreachable!(),\n/// };\n/// entry_v.insert(10);\n/// assert!(map["a"] == 10 && map.len() == 1);\n///\n/// // Nonexistent key (insert and update)\n/// match map.entry_ref("b") {\n///     EntryRef::Occupied(_) => unreachable!(),\n///     EntryRef::Vacant(view) => {\n///         let value = view.insert(2);\n///         assert_eq!(*value, 2);\n///         *value = 20;\n///     }\n/// }\n/// assert!(map["b"] == 20 && map.len() == 2);\n/// ```\npub struct VacantEntryRef<\'a, \'b, K, Q: ?Sized, V, S, A: Allocator = Global> {\n    hash: u64,\n    key: &\'b Q,\n    table: &\'a mut HashMap<K, V, S, A>,\n}', 'Real(LocalPath("src/map.rs"))'], "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::insert": ['/// Sets the value of the entry with the `VacantEntryRef`\'s key,\n/// and returns a mutable reference to it.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::EntryRef;\n///\n/// let mut map: HashMap<String, u32> = HashMap::new();\n/// let key: &str = "poneyland";\n///\n/// if let EntryRef::Vacant(o) = map.entry_ref(key) {\n///     o.insert(37);\n/// }\n/// assert_eq!(map["poneyland"], 37);\n/// ```\ninline\npub fn insert(self, value: V) -> &\'a mut V\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,{\n        let table = &mut self.table.table;\n        let entry = table.insert_entry(\n            self.hash,\n            (self.key.into(), value),\n            make_hasher::<_, V, S>(&self.table.hash_builder),\n        );\n        &mut entry.1\n    }', 'Real(LocalPath("src/map.rs"))'], "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::insert_entry": ['/// Sets the value of the entry with the [`VacantEntryRef`]\'s key,\n/// and returns an [`OccupiedEntry`].\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::EntryRef;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// if let EntryRef::Vacant(v) = map.entry_ref("poneyland") {\n///     let o = v.insert_entry(37);\n///     assert_eq!(o.get(), &37);\n/// }\n/// ```\ninline\npub fn insert_entry(self, value: V) -> OccupiedEntry<\'a, K, V, S, A>\n    where\n        K: Hash,\n        &\'b Q: Into<K>,\n        S: BuildHasher,{\n        let elem = self.table.table.insert(\n            self.hash,\n            (self.key.into(), value),\n            make_hasher::<_, V, S>(&self.table.hash_builder),\n        );\n        OccupiedEntry {\n            hash: self.hash,\n            elem,\n            table: self.table,\n        }\n    }', 'Real(LocalPath("src/map.rs"))'], "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::key": ['/// Gets a reference to the key that would be used when inserting a value\n/// through the `VacantEntryRef`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<String, u32> = HashMap::new();\n/// let key: &str = "poneyland";\n/// assert_eq!(map.entry_ref(key).key(), "poneyland");\n/// ```\ninline\npub fn key(&self) -> &\'b Q{\n        self.key\n    }', 'Real(LocalPath("src/map.rs"))'], 'map::Values': ['/// An iterator over the values of a `HashMap` in arbitrary order.\n/// The iterator element type is `&\'a V`.\n///\n/// This `struct` is created by the [`values`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`values`]: struct.HashMap.html#method.values\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let map: HashMap<_, _> = [(1, "a"), (2, "b"), (3, "c")].into();\n///\n/// let mut values = map.values();\n/// let mut vec = vec![values.next(), values.next(), values.next()];\n///\n/// // The `Values` iterator produces values in arbitrary order, so the\n/// // values must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [Some(&"a"), Some(&"b"), Some(&"c")]);\n///\n/// // It is fused iterator\n/// assert_eq!(values.next(), None);\n/// assert_eq!(values.next(), None);\n/// ```\npub struct Values<\'a, K, V> {\n    inner: Iter<\'a, K, V>,\n}', 'Real(LocalPath("src/map.rs"))'], 'map::ValuesMut': ['/// A mutable iterator over the values of a `HashMap` in arbitrary order.\n/// The iterator element type is `&\'a mut V`.\n///\n/// This `struct` is created by the [`values_mut`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`values_mut`]: struct.HashMap.html#method.values_mut\n/// [`HashMap`]: struct.HashMap.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<_, _> = [(1, "One".to_owned()), (2, "Two".into())].into();\n///\n/// let mut values = map.values_mut();\n/// values.next().map(|v| v.push_str(" Mississippi"));\n/// values.next().map(|v| v.push_str(" Mississippi"));\n///\n/// // It is fused iterator\n/// assert_eq!(values.next(), None);\n/// assert_eq!(values.next(), None);\n///\n/// assert_eq!(map.get(&1).unwrap(), &"One Mississippi".to_owned());\n/// assert_eq!(map.get(&2).unwrap(), &"Two Mississippi".to_owned());\n/// ```\npub struct ValuesMut<\'a, K, V> {\n    inner: IterMut<\'a, K, V>,\n}', 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance': ["#[allow(dead_code)]\nfn assert_covariance(){\n    fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8> {\n        v\n    }\n    fn map_val<'new>(v: HashMap<u8, &'static str>) -> HashMap<u8, &'new str> {\n        v\n    }\n    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, u8>) -> Iter<'a, &'new str, u8> {\n        v\n    }\n    fn iter_val<'a, 'new>(v: Iter<'a, u8, &'static str>) -> Iter<'a, u8, &'new str> {\n        v\n    }\n    fn into_iter_key<'new, A: Allocator>(\n        v: IntoIter<&'static str, u8, A>,\n    ) -> IntoIter<&'new str, u8, A> {\n        v\n    }\n    fn into_iter_val<'new, A: Allocator>(\n        v: IntoIter<u8, &'static str, A>,\n    ) -> IntoIter<u8, &'new str, A> {\n        v\n    }\n    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, u8>) -> Keys<'a, &'new str, u8> {\n        v\n    }\n    fn keys_val<'a, 'new>(v: Keys<'a, u8, &'static str>) -> Keys<'a, u8, &'new str> {\n        v\n    }\n    fn values_key<'a, 'new>(v: Values<'a, &'static str, u8>) -> Values<'a, &'new str, u8> {\n        v\n    }\n    fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str> {\n        v\n    }\n    fn drain<'new>(\n        d: Drain<'static, &'static str, &'static str>,\n    ) -> Drain<'new, &'new str, &'new str> {\n        d\n    }\n}", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::drain': ["fn drain<'new>(\n        d: Drain<'static, &'static str, &'static str>,\n    ) -> Drain<'new, &'new str, &'new str>{\n        d\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::into_iter_key': ["fn into_iter_key<'new, A: Allocator>(\n        v: IntoIter<&'static str, u8, A>,\n    ) -> IntoIter<&'new str, u8, A>{\n        v\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::into_iter_val': ["fn into_iter_val<'new, A: Allocator>(\n        v: IntoIter<u8, &'static str, A>,\n    ) -> IntoIter<u8, &'new str, A>{\n        v\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::iter_key': ["fn iter_key<'a, 'new>(v: Iter<'a, &'static str, u8>) -> Iter<'a, &'new str, u8>{\n        v\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::iter_val': ["fn iter_val<'a, 'new>(v: Iter<'a, u8, &'static str>) -> Iter<'a, u8, &'new str>{\n        v\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::keys_key': ["fn keys_key<'a, 'new>(v: Keys<'a, &'static str, u8>) -> Keys<'a, &'new str, u8>{\n        v\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::keys_val': ["fn keys_val<'a, 'new>(v: Keys<'a, u8, &'static str>) -> Keys<'a, u8, &'new str>{\n        v\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::map_key': ["fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8>{\n        v\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::map_val': ["fn map_val<'new>(v: HashMap<u8, &'static str>) -> HashMap<u8, &'new str>{\n        v\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::values_key': ["fn values_key<'a, 'new>(v: Values<'a, &'static str, u8>) -> Values<'a, &'new str, u8>{\n        v\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::assert_covariance::values_val': ["fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str>{\n        v\n    }", 'Real(LocalPath("src/map.rs"))'], 'map::equivalent': ["/// Ensures that a single closure type across uses of this which, in turn prevents multiple\n/// instances of any functions like `RawTable::reserve` from being generated\ninline\n#[allow(dead_code)]\npub(crate) fn equivalent<Q, K>(k: &Q) -> impl Fn(&K) -> bool + '_\nwhere\n    Q: Equivalent<K> + ?Sized,{\n    move |x| k.equivalent(x)\n}", 'Real(LocalPath("src/map.rs"))'], 'map::equivalent_key': ["/// Ensures that a single closure type across uses of this which, in turn prevents multiple\n/// instances of any functions like `RawTable::reserve` from being generated\ninline\npub(crate) fn equivalent_key<Q, K, V>(k: &Q) -> impl Fn(&(K, V)) -> bool + '_\nwhere\n    Q: Equivalent<K> + ?Sized,{\n    move |x| k.equivalent(&x.0)\n}", 'Real(LocalPath("src/map.rs"))'], 'map::make_hash': ['#[cfg(not(feature = "nightly"))]\ninline\npub(crate) fn make_hash<Q, S>(hash_builder: &S, val: &Q) -> u64\nwhere\n    Q: Hash + ?Sized,\n    S: BuildHasher,{\n    use core::hash::Hasher;\n    let mut state = hash_builder.build_hasher();\n    val.hash(&mut state);\n    state.finish()\n}', 'Real(LocalPath("src/map.rs"))'], 'map::make_hasher': ["/// Ensures that a single closure type across uses of this which, in turn prevents multiple\n/// instances of any functions like `RawTable::reserve` from being generated\ninline\npub(crate) fn make_hasher<Q, V, S>(hash_builder: &S) -> impl Fn(&(Q, V)) -> u64 + '_\nwhere\n    Q: Hash,\n    S: BuildHasher,{\n    move |val| make_hash::<Q, S>(hash_builder, &val.0)\n}", 'Real(LocalPath("src/map.rs"))'], 'raw::Bucket': ['/// A reference to a hash table bucket containing a `T`.\n///\n/// This is usually just a pointer to the element itself. However if the element\n/// is a ZST, then we instead track the index of the element in the table so\n/// that `erase` works properly.\npub struct Bucket<T> {\n    // Actually it is pointer to next element than element itself\n    // this is needed to maintain pointer arithmetic invariants\n    // keeping direct pointer to element introduces difficulty.\n    // Using `NonNull` for variance and niche layout\n    ptr: NonNull<T>,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Bucket::<T>::as_mut': ['/// Returns a unique mutable reference to the `value`.\n///\n/// # Safety\n///\n/// See [`NonNull::as_mut`] for safety concerns.\n///\n/// # Note\n///\n/// [`Hash`] and [`Eq`] on the new `T` value and its borrowed form *must* match\n/// those for the old `T` value, as the map will not re-evaluate where the new\n/// value should go, meaning the value may become "lost" if their location\n/// does not reflect their state.\n///\n/// [`NonNull::as_mut`]: https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.as_mut\n/// [`Hash`]: https://doc.rust-lang.org/core/hash/trait.Hash.html\n/// [`Eq`]: https://doc.rust-lang.org/core/cmp/trait.Eq.html\n#[inline]\npub unsafe fn as_mut<\'a>(&self) -> &\'a mut T{\n        &mut *self.as_ptr()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Bucket::<T>::as_non_null': ['/// Acquires the underlying non-null pointer `*mut T` to `data`.\n#[inline]\nfn as_non_null(&self) -> NonNull<T>{\n        // SAFETY: `self.ptr` is already a `NonNull`\n        unsafe { NonNull::new_unchecked(self.as_ptr()) }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Bucket::<T>::as_ptr': ['/// Acquires the underlying raw pointer `*mut T` to `data`.\n///\n/// # Note\n///\n/// If `T` is not [`Copy`], do not use `*mut T` methods that can cause calling the\n/// destructor of `T` (for example the [`<*mut T>::drop_in_place`] method), because\n/// for properly dropping the data we also need to clear `data` control bytes. If we\n/// drop data, but do not clear `data control byte` it leads to double drop when\n/// [`RawTable`] goes out of scope.\n///\n/// If you modify an already initialized `value`, so [`Hash`] and [`Eq`] on the new\n/// `T` value and its borrowed form *must* match those for the old `T` value, as the map\n/// will not re-evaluate where the new value should go, meaning the value may become\n/// "lost" if their location does not reflect their state.\n///\n/// [`RawTable`]: crate::raw::RawTable\n/// [`<*mut T>::drop_in_place`]: https://doc.rust-lang.org/core/primitive.pointer.html#method.drop_in_place\n/// [`Hash`]: https://doc.rust-lang.org/core/hash/trait.Hash.html\n/// [`Eq`]: https://doc.rust-lang.org/core/cmp/trait.Eq.html\n#[inline]\npub fn as_ptr(&self) -> *mut T{\n        if T::IS_ZERO_SIZED {\n            // Just return an arbitrary ZST pointer which is properly aligned\n            // invalid pointer is good enough for ZST\n            invalid_mut(mem::align_of::<T>())\n        } else {\n            unsafe { self.ptr.as_ptr().sub(1) }\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Bucket::<T>::as_ref': ["/// Returns a shared immutable reference to the `value`.\n///\n/// # Safety\n///\n/// See [`NonNull::as_ref`] for safety concerns.\n///\n/// [`NonNull::as_ref`]: https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.as_ref\n#[inline]\npub unsafe fn as_ref<'a>(&self) -> &'a T{\n        &*self.as_ptr()\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Bucket::<T>::drop': ['/// Executes the destructor (if any) of the pointed-to `data`.\n///\n/// # Safety\n///\n/// See [`ptr::drop_in_place`] for safety concerns.\n///\n/// You should use [`RawTable::erase`] instead of this function,\n/// or be careful with calling this function directly, because for\n/// properly dropping the data we need also clear `data` control bytes.\n/// If we drop data, but do not erase `data control byte` it leads to\n/// double drop when [`RawTable`] goes out of scope.\n///\n/// [`ptr::drop_in_place`]: https://doc.rust-lang.org/core/ptr/fn.drop_in_place.html\n/// [`RawTable`]: crate::raw::RawTable\n/// [`RawTable::erase`]: crate::raw::RawTable::erase\ninline\npub(crate) unsafe fn drop(&self){\n        self.as_ptr().drop_in_place();\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Bucket::<T>::from_base_index': ['/// Creates a [`Bucket`] that contain pointer to the data.\n/// The pointer calculation is performed by calculating the\n/// offset from given `base` pointer (convenience for\n/// `base.as_ptr().sub(index)`).\n///\n/// `index` is in units of `T`; e.g., an `index` of 3 represents a pointer\n/// offset of `3 * size_of::<T>()` bytes.\n///\n/// If the `T` is a ZST, then we instead track the index of the element\n/// in the table so that `erase` works properly (return\n/// `NonNull::new_unchecked((index + 1) as *mut T)`)\n///\n/// # Safety\n///\n/// If `mem::size_of::<T>() != 0`, then the safety rules are directly derived\n/// from the safety rules for [`<*mut T>::sub`] method of `*mut T` and the safety\n/// rules of [`NonNull::new_unchecked`] function.\n///\n/// Thus, in order to uphold the safety contracts for the [`<*mut T>::sub`] method\n/// and [`NonNull::new_unchecked`] function, as well as for the correct\n/// logic of the work of this crate, the following rules are necessary and\n/// sufficient:\n///\n/// * the `base` pointer must not be `dangling` and must points to the\n///   end of the first `value element` from the `data part` of the table, i.e.\n///   must be the pointer that returned by [`RawTable::data_end`] or by\n///   [`RawTableInner::data_end<T>`];\n///\n/// * `index` must not be greater than `RawTableInner.bucket_mask`, i.e.\n///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)`\n///   must be no greater than the number returned by the function\n///   [`RawTable::buckets`] or [`RawTableInner::buckets`].\n///\n/// If `mem::size_of::<T>() == 0`, then the only requirement is that the\n/// `index` must not be greater than `RawTableInner.bucket_mask`, i.e.\n/// `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)`\n/// must be no greater than the number returned by the function\n/// [`RawTable::buckets`] or [`RawTableInner::buckets`].\n///\n/// [`Bucket`]: crate::raw::Bucket\n/// [`<*mut T>::sub`]: https://doc.rust-lang.org/core/primitive.pointer.html#method.sub-1\n/// [`NonNull::new_unchecked`]: https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.new_unchecked\n/// [`RawTable::data_end`]: crate::raw::RawTable::data_end\n/// [`RawTableInner::data_end<T>`]: RawTableInner::data_end<T>\n/// [`RawTable::buckets`]: crate::raw::RawTable::buckets\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n#[inline]\nunsafe fn from_base_index(base: NonNull<T>, index: usize) -> Self{\n        // If mem::size_of::<T>() != 0 then return a pointer to an `element` in\n        // the data part of the table (we start counting from "0", so that\n        // in the expression T[last], the "last" index actually one less than the\n        // "buckets" number in the table, i.e. "last = RawTableInner.bucket_mask"):\n        //\n        //                   `from_base_index(base, 1).as_ptr()` returns a pointer that\n        //                   points here in the data part of the table\n        //                   (to the start of T1)\n        //                        |\n        //                        |        `base: NonNull<T>` must point here\n        //                        |         (to the end of T0 or to the start of C0)\n        //                        v         v\n        // [Padding], Tlast, ..., |T1|, T0, |C0, C1, ..., Clast\n        //                           ^\n        //                           `from_base_index(base, 1)` returns a pointer\n        //                           that points here in the data part of the table\n        //                           (to the end of T1)\n        //\n        // where: T0...Tlast - our stored data; C0...Clast - control bytes\n        // or metadata for data.\n        let ptr = if T::IS_ZERO_SIZED {\n            // won\'t overflow because index must be less than length (bucket_mask)\n            // and bucket_mask is guaranteed to be less than `isize::MAX`\n            // (see TableLayout::calculate_layout_for method)\n            invalid_mut(index + 1)\n        } else {\n            base.as_ptr().sub(index)\n        };\n        Self {\n            ptr: NonNull::new_unchecked(ptr),\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Bucket::<T>::next_n': ['/// Create a new [`Bucket`] that is offset from the `self` by the given\n/// `offset`. The pointer calculation is performed by calculating the\n/// offset from `self` pointer (convenience for `self.ptr.as_ptr().sub(offset)`).\n/// This function is used for iterators.\n///\n/// `offset` is in units of `T`; e.g., a `offset` of 3 represents a pointer\n/// offset of `3 * size_of::<T>()` bytes.\n///\n/// # Safety\n///\n/// If `mem::size_of::<T>() != 0`, then the safety rules are directly derived\n/// from the safety rules for [`<*mut T>::sub`] method of `*mut T` and safety\n/// rules of [`NonNull::new_unchecked`] function.\n///\n/// Thus, in order to uphold the safety contracts for [`<*mut T>::sub`] method\n/// and [`NonNull::new_unchecked`] function, as well as for the correct\n/// logic of the work of this crate, the following rules are necessary and\n/// sufficient:\n///\n/// * `self` contained pointer must not be `dangling`;\n///\n/// * `self.to_base_index() + offset` must not be greater than `RawTableInner.bucket_mask`,\n///   i.e. `(self.to_base_index() + offset) <= RawTableInner.bucket_mask` or, in other\n///   words, `self.to_base_index() + offset + 1` must be no greater than the number returned\n///   by the function [`RawTable::buckets`] or [`RawTableInner::buckets`].\n///\n/// If `mem::size_of::<T>() == 0`, then the only requirement is that the\n/// `self.to_base_index() + offset` must not be greater than `RawTableInner.bucket_mask`,\n/// i.e. `(self.to_base_index() + offset) <= RawTableInner.bucket_mask` or, in other words,\n/// `self.to_base_index() + offset + 1` must be no greater than the number returned by the\n/// function [`RawTable::buckets`] or [`RawTableInner::buckets`].\n///\n/// [`Bucket`]: crate::raw::Bucket\n/// [`<*mut T>::sub`]: https://doc.rust-lang.org/core/primitive.pointer.html#method.sub-1\n/// [`NonNull::new_unchecked`]: https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.new_unchecked\n/// [`RawTable::buckets`]: crate::raw::RawTable::buckets\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n#[inline]\nunsafe fn next_n(&self, offset: usize) -> Self{\n        let ptr = if T::IS_ZERO_SIZED {\n            // invalid pointer is good enough for ZST\n            invalid_mut(self.ptr.as_ptr() as usize + offset)\n        } else {\n            self.ptr.as_ptr().sub(offset)\n        };\n        Self {\n            ptr: NonNull::new_unchecked(ptr),\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Bucket::<T>::read': ['/// Reads the `value` from `self` without moving it. This leaves the\n/// memory in `self` unchanged.\n///\n/// # Safety\n///\n/// See [`ptr::read`] for safety concerns.\n///\n/// You should use [`RawTable::remove`] instead of this function,\n/// or be careful with calling this function directly, because compiler\n/// calls its destructor when the read `value` goes out of scope. It\n/// can cause double dropping when [`RawTable`] goes out of scope,\n/// because of not erased `data control byte`.\n///\n/// [`ptr::read`]: https://doc.rust-lang.org/core/ptr/fn.read.html\n/// [`RawTable`]: crate::raw::RawTable\n/// [`RawTable::remove`]: crate::raw::RawTable::remove\n#[inline]\npub(crate) unsafe fn read(&self) -> T{\n        self.as_ptr().read()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Bucket::<T>::to_base_index': ['/// Calculates the index of a [`Bucket`] as distance between two pointers\n/// (convenience for `base.as_ptr().offset_from(self.ptr.as_ptr()) as usize`).\n/// The returned value is in units of T: the distance in bytes divided by\n/// [`core::mem::size_of::<T>()`].\n///\n/// If the `T` is a ZST, then we return the index of the element in\n/// the table so that `erase` works properly (return `self.ptr.as_ptr() as usize - 1`).\n///\n/// This function is the inverse of [`from_base_index`].\n///\n/// # Safety\n///\n/// If `mem::size_of::<T>() != 0`, then the safety rules are directly derived\n/// from the safety rules for [`<*const T>::offset_from`] method of `*const T`.\n///\n/// Thus, in order to uphold the safety contracts for [`<*const T>::offset_from`]\n/// method, as well as for the correct logic of the work of this crate, the\n/// following rules are necessary and sufficient:\n///\n/// * `base` contained pointer must not be `dangling` and must point to the\n///   end of the first `element` from the `data part` of the table, i.e.\n///   must be a pointer that returns by [`RawTable::data_end`] or by\n///   [`RawTableInner::data_end<T>`];\n///\n/// * `self` also must not contain dangling pointer;\n///\n/// * both `self` and `base` must be created from the same [`RawTable`]\n///   (or [`RawTableInner`]).\n///\n/// If `mem::size_of::<T>() == 0`, this function is always safe.\n///\n/// [`Bucket`]: crate::raw::Bucket\n/// [`from_base_index`]: crate::raw::Bucket::from_base_index\n/// [`RawTable::data_end`]: crate::raw::RawTable::data_end\n/// [`RawTableInner::data_end<T>`]: RawTableInner::data_end<T>\n/// [`RawTable`]: crate::raw::RawTable\n/// [`RawTableInner`]: RawTableInner\n/// [`<*const T>::offset_from`]: https://doc.rust-lang.org/nightly/core/primitive.pointer.html#method.offset_from\n#[inline]\nunsafe fn to_base_index(&self, base: NonNull<T>) -> usize{\n        // If mem::size_of::<T>() != 0 then return an index under which we used to store the\n        // `element` in the data part of the table (we start counting from "0", so\n        // that in the expression T[last], the "last" index actually is one less than the\n        // "buckets" number in the table, i.e. "last = RawTableInner.bucket_mask").\n        // For example for 5th element in table calculation is performed like this:\n        //\n        //                        mem::size_of::<T>()\n        //                          |\n        //                          |         `self = from_base_index(base, 5)` that returns pointer\n        //                          |         that points here in the data part of the table\n        //                          |         (to the end of T5)\n        //                          |           |                    `base: NonNull<T>` must point here\n        //                          v           |                    (to the end of T0 or to the start of C0)\n        //                        /???\\         v                      v\n        // [Padding], Tlast, ..., |T10|, ..., T5|, T4, T3, T2, T1, T0, |C0, C1, C2, C3, C4, C5, ..., C10, ..., Clast\n        //                                      \\__________  __________/\n        //                                                 \\/\n        //                                     `bucket.to_base_index(base)` = 5\n        //                                     (base.as_ptr() as usize - self.ptr.as_ptr() as usize) / mem::size_of::<T>()\n        //\n        // where: T0...Tlast - our stored data; C0...Clast - control bytes or metadata for data.\n        if T::IS_ZERO_SIZED {\n            // this can not be UB\n            self.ptr.as_ptr() as usize - 1\n        } else {\n            offset_from(base.as_ptr(), self.ptr.as_ptr())\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Bucket::<T>::write': ['/// Overwrites a memory location with the given `value` without reading\n/// or dropping the old value (like [`ptr::write`] function).\n///\n/// # Safety\n///\n/// See [`ptr::write`] for safety concerns.\n///\n/// # Note\n///\n/// [`Hash`] and [`Eq`] on the new `T` value and its borrowed form *must* match\n/// those for the old `T` value, as the map will not re-evaluate where the new\n/// value should go, meaning the value may become "lost" if their location\n/// does not reflect their state.\n///\n/// [`ptr::write`]: https://doc.rust-lang.org/core/ptr/fn.write.html\n/// [`Hash`]: https://doc.rust-lang.org/core/hash/trait.Hash.html\n/// [`Eq`]: https://doc.rust-lang.org/core/cmp/trait.Eq.html\n#[inline]\npub(crate) unsafe fn write(&self, val: T){\n        self.as_ptr().write(val);\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Fallibility': ['/// Whether memory allocation errors should return an error or abort.\nenum Fallibility {\n    Fallible,\n    Infallible,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Fallibility::alloc_err': ['/// Error to return on allocation error.\ninline\nfn alloc_err(self, layout: Layout) -> TryReserveError{\n        match self {\n            Fallibility::Fallible => TryReserveError::AllocError { layout },\n            Fallibility::Infallible => handle_alloc_error(layout),\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::Fallibility::capacity_overflow': ['/// Error to return on capacity overflow.\ninline\nfn capacity_overflow(self) -> TryReserveError{\n        match self {\n            Fallibility::Fallible => TryReserveError::CapacityOverflow,\n            Fallibility::Infallible => panic!("Hash table capacity overflow"),\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::FullBucketsIndices': ["/// Iterator which returns an index of every full bucket in the table.\n///\n/// For maximum flexibility this iterator is not bound by a lifetime, but you\n/// must observe several rules when using it:\n/// - You must not free the hash table while iterating (including via growing/shrinking).\n/// - It is fine to erase a bucket that has been yielded by the iterator.\n/// - Erasing a bucket that has not yet been yielded by the iterator may still\n///   result in the iterator yielding index of that bucket.\n/// - It is unspecified whether an element inserted after the iterator was\n///   created will be yielded by that iterator.\n/// - The order in which the iterator yields indices of the buckets is unspecified\n///   and may change in the future.\npub(crate) struct FullBucketsIndices {\n    // Mask of full buckets in the current group. Bits are cleared from this\n    // mask as each element is processed.\n    current_group: BitMaskIter,\n\n    // Initial value of the bytes' indices of the current group (relative\n    // to the start of the control bytes).\n    group_first_index: usize,\n\n    // Pointer to the current group of control bytes,\n    // Must be aligned to the group size (Group::WIDTH).\n    ctrl: NonNull<u8>,\n\n    // Number of elements in the table.\n    items: usize,\n}", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::FullBucketsIndices::next_impl': ['/// Advances the iterator and returns the next value.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is\n/// [`Undefined Behavior`]:\n///\n/// * The [`RawTableInner`] / [`RawTable`] must be alive and not moved,\n///   i.e. table outlives the `FullBucketsIndices`;\n///\n/// * It never tries to iterate after getting all elements.\n///\n/// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline(always)]\nunsafe fn next_impl(&mut self) -> Option<usize>{\n        loop {\n            if let Some(index) = self.current_group.next() {\n                // The returned `self.group_first_index + index` will always\n                // be in the range `0..self.buckets()`. See explanation below.\n                return Some(self.group_first_index + index);\n            }\n\n            // SAFETY: The caller of this function ensures that:\n            //\n            // 1. It never tries to iterate after getting all the elements;\n            // 2. The table is alive and did not moved;\n            // 3. The first `self.ctrl` pointed to the start of the array of control bytes.\n            //\n            // Taking the above into account, we always stay within the bounds, because:\n            //\n            // 1. For tables smaller than the group width (self.buckets() <= Group::WIDTH),\n            //    we will never end up in the given branch, since we should have already\n            //    yielded all the elements of the table.\n            //\n            // 2. For tables larger than the group width. The number of buckets is a\n            //    power of two (2 ^ n), Group::WIDTH is also power of two (2 ^ k). Since\n            //    `(2 ^ n) > (2 ^ k)`, than `(2 ^ n) % (2 ^ k) = 0`. As we start from the\n            //    the start of the array of control bytes, and never try to iterate after\n            //    getting all the elements, the last `self.ctrl` will be equal to\n            //    the `self.buckets() - Group::WIDTH`, so `self.current_group.next()`\n            //    will always contains indices within the range `0..Group::WIDTH`,\n            //    and subsequent `self.group_first_index + index` will always return a\n            //    number less than `self.buckets()`.\n            self.ctrl = NonNull::new_unchecked(self.ctrl.as_ptr().add(Group::WIDTH));\n\n            // SAFETY: See explanation above.\n            self.current_group = Group::load_aligned(self.ctrl.as_ptr().cast())\n                .match_full()\n                .into_iter();\n            self.group_first_index += Group::WIDTH;\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::InsertSlot': ['/// A reference to an empty bucket into which an can be inserted.\npub struct InsertSlot {\n    index: usize,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::ProbeSeq': ['/// Probe sequence based on triangular numbers, which is guaranteed (since our\n/// table size is a power of two) to visit every group of elements exactly once.\n///\n/// A triangular probe has us jump by 1 more group every time. So first we\n/// jump by 1 group (meaning we just continue our linear scan), then 2 groups\n/// (skipping over 1 group), then 3 groups (skipping over 2 groups), and so on.\n///\n/// Proof that the probe will visit every group in the table:\n/// <https://fgiesen.wordpress.com/2015/02/22/triangular-numbers-mod-2n/>\nstruct ProbeSeq {\n    pos: usize,\n    stride: usize,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::ProbeSeq::move_next': ['#[inline]\nfn move_next(&mut self, bucket_mask: usize){\n        // We should have found an empty bucket by now and ended the probe.\n        debug_assert!(\n            self.stride <= bucket_mask,\n            "Went past end of probe sequence"\n        );\n\n        self.stride += Group::WIDTH;\n        self.pos += self.stride;\n        self.pos &= bucket_mask;\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawDrain': ["/// Iterator which consumes elements without freeing the table storage.\npub struct RawDrain<'a, T, A: Allocator = Global> {\n    iter: RawIter<T>,\n\n    // The table is moved into the iterator for the duration of the drain. This\n    // ensures that an empty table is left if the drain iterator is leaked\n    // without dropping.\n    table: RawTableInner,\n    orig_table: NonNull<RawTableInner>,\n\n    // We don't use a &'a mut RawTable<T> because we want RawDrain to be\n    // covariant over T.\n    marker: PhantomData<&'a RawTable<T, A>>,\n}", 'Real(LocalPath("src/raw/mod.rs"))'], "raw::RawDrain::<'_, T, A>::iter": ['inline\npub fn iter(&self) -> RawIter<T>{\n        self.iter.clone()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawExtractIf': ["pub(crate) struct RawExtractIf<'a, T, A: Allocator> {\n    pub iter: RawIter<T>,\n    pub table: &'a mut RawTable<T, A>,\n}", 'Real(LocalPath("src/raw/mod.rs"))'], "raw::RawExtractIf::<'_, T, A>::next": ['inline\npub(crate) fn next<F>(&mut self, mut f: F) -> Option<T>\n    where\n        F: FnMut(&mut T) -> bool,{\n        unsafe {\n            for item in &mut self.iter {\n                if f(item.as_mut()) {\n                    return Some(self.table.remove(item).0);\n                }\n            }\n        }\n        None\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIntoIter': ['/// Iterator which consumes a table and returns elements.\npub struct RawIntoIter<T, A: Allocator = Global> {\n    iter: RawIter<T>,\n    allocation: Option<(NonNull<u8>, Layout, A)>,\n    marker: PhantomData<T>,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIntoIter::<T, A>::iter': ['inline\npub fn iter(&self) -> RawIter<T>{\n        self.iter.clone()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIter': ['/// Iterator which returns a raw pointer to every full bucket in the table.\n///\n/// For maximum flexibility this iterator is not bound by a lifetime, but you\n/// must observe several rules when using it:\n/// - You must not free the hash table while iterating (including via growing/shrinking).\n/// - It is fine to erase a bucket that has been yielded by the iterator.\n/// - Erasing a bucket that has not yet been yielded by the iterator may still\n///   result in the iterator yielding that bucket (unless `reflect_remove` is called).\n/// - It is unspecified whether an element inserted after the iterator was\n///   created will be yielded by that iterator (unless `reflect_insert` is called).\n/// - The order in which the iterator yields bucket is unspecified and may\n///   change in the future.\npub struct RawIter<T> {\n    pub(crate) iter: RawIterRange<T>,\n    items: usize,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIter::<T>::drop_elements': ['unsafe fn drop_elements(&mut self){\n        if T::NEEDS_DROP && self.items != 0 {\n            for item in self {\n                item.drop();\n            }\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIterHash': ['/// Iterator over occupied buckets that could match a given hash.\n///\n/// `RawTable` only stores 7 bits of the hash value, so this iterator may return\n/// items that have a hash value different than the one provided. You should\n/// always validate the returned values before using them.\n///\n/// For maximum flexibility this iterator is not bound by a lifetime, but you\n/// must observe several rules when using it:\n/// - You must not free the hash table while iterating (including via growing/shrinking).\n/// - It is fine to erase a bucket that has been yielded by the iterator.\n/// - Erasing a bucket that has not yet been yielded by the iterator may still\n///   result in the iterator yielding that bucket.\n/// - It is unspecified whether an element inserted after the iterator was\n///   created will be yielded by that iterator.\n/// - The order in which the iterator yields buckets is unspecified and may\n///   change in the future.\npub struct RawIterHash<T> {\n    inner: RawIterHashInner,\n    _marker: PhantomData<T>,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIterHash::<T>::new': ['inline\nunsafe fn new<A: Allocator>(table: &RawTable<T, A>, hash: u64) -> Self{\n        RawIterHash {\n            inner: RawIterHashInner::new(&table.table, hash),\n            _marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIterHashInner': ["struct RawIterHashInner {\n    // See `RawTableInner`'s corresponding fields for details.\n    // We can't store a `*const RawTableInner` as it would get\n    // invalidated by the user calling `&mut` methods on `RawTable`.\n    bucket_mask: usize,\n    ctrl: NonNull<u8>,\n\n    // The top 7 bits of the hash.\n    tag_hash: Tag,\n\n    // The sequence of groups to probe in the search.\n    probe_seq: ProbeSeq,\n\n    group: Group,\n\n    // The elements within the group with a matching tag-hash.\n    bitmask: BitMaskIter,\n}", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIterHashInner::new': ['inline\nunsafe fn new(table: &RawTableInner, hash: u64) -> Self{\n        let tag_hash = Tag::full(hash);\n        let probe_seq = table.probe_seq(hash);\n        let group = Group::load(table.ctrl(probe_seq.pos));\n        let bitmask = group.match_tag(tag_hash).into_iter();\n\n        RawIterHashInner {\n            bucket_mask: table.bucket_mask,\n            ctrl: table.ctrl,\n            tag_hash,\n            probe_seq,\n            group,\n            bitmask,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIterRange': ['/// Iterator over a sub-range of a table. Unlike `RawIter` this iterator does\n/// not track an item count.\npub(crate) struct RawIterRange<T> {\n    // Mask of full buckets in the current group. Bits are cleared from this\n    // mask as each element is processed.\n    current_group: BitMaskIter,\n\n    // Pointer to the buckets for the current group.\n    data: Bucket<T>,\n\n    // Pointer to the next group of control bytes,\n    // Must be aligned to the group size.\n    next_ctrl: *const u8,\n\n    // Pointer one past the last control byte of this range.\n    end: *const u8,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIterRange::<T>::fold_impl': ["/// Folds every element into an accumulator by applying an operation,\n/// returning the final result.\n///\n/// `fold_impl()` takes three arguments: the number of items remaining in\n/// the iterator, an initial value, and a closure with two arguments: an\n/// 'accumulator', and an element. The closure returns the value that the\n/// accumulator should have for the next iteration.\n///\n/// The initial value is the value the accumulator will have on the first call.\n///\n/// After applying this closure to every element of the iterator, `fold_impl()`\n/// returns the accumulator.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is\n/// [`Undefined Behavior`]:\n///\n/// * The [`RawTableInner`] / [`RawTable`] must be alive and not moved,\n///   i.e. table outlives the `RawIterRange`;\n///\n/// * The provided `n` value must match the actual number of items\n///   in the table.\n///\n/// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[allow(clippy::while_let_on_iterator)]\ninline\nunsafe fn fold_impl<F, B>(mut self, mut n: usize, mut acc: B, mut f: F) -> B\n    where\n        F: FnMut(B, Bucket<T>) -> B,{\n        loop {\n            while let Some(index) = self.current_group.next() {\n                // The returned `index` will always be in the range `0..Group::WIDTH`,\n                // so that calling `self.data.next_n(index)` is safe (see detailed explanation below).\n                debug_assert!(n != 0);\n                let bucket = self.data.next_n(index);\n                acc = f(acc, bucket);\n                n -= 1;\n            }\n\n            if n == 0 {\n                return acc;\n            }\n\n            // SAFETY: The caller of this function ensures that:\n            //\n            // 1. The provided `n` value matches the actual number of items in the table;\n            // 2. The table is alive and did not moved.\n            //\n            // Taking the above into account, we always stay within the bounds, because:\n            //\n            // 1. For tables smaller than the group width (self.buckets() <= Group::WIDTH),\n            //    we will never end up in the given branch, since we should have already\n            //    yielded all the elements of the table.\n            //\n            // 2. For tables larger than the group width. The number of buckets is a\n            //    power of two (2 ^ n), Group::WIDTH is also power of two (2 ^ k). Since\n            //    `(2 ^ n) > (2 ^ k)`, than `(2 ^ n) % (2 ^ k) = 0`. As we start from the\n            //    start of the array of control bytes, and never try to iterate after\n            //    getting all the elements, the last `self.current_group` will read bytes\n            //    from the `self.buckets() - Group::WIDTH` index.  We know also that\n            //    `self.current_group.next()` will always return indices within the range\n            //    `0..Group::WIDTH`.\n            //\n            //    Knowing all of the above and taking into account that we are synchronizing\n            //    the `self.data` index with the index we used to read the `self.current_group`,\n            //    the subsequent `self.data.next_n(index)` will always return a bucket with\n            //    an index number less than `self.buckets()`.\n            //\n            //    The last `self.next_ctrl`, whose index would be `self.buckets()`, will never\n            //    actually be read, since we should have already yielded all the elements of\n            //    the table.\n            self.current_group = Group::load_aligned(self.next_ctrl.cast())\n                .match_full()\n                .into_iter();\n            self.data = self.data.next_n(Group::WIDTH);\n            self.next_ctrl = self.next_ctrl.add(Group::WIDTH);\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIterRange::<T>::new': ['/// Returns a `RawIterRange` covering a subset of a table.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is\n/// [`undefined behavior`]:\n///\n/// * `ctrl` must be [valid] for reads, i.e. table outlives the `RawIterRange`;\n///\n/// * `ctrl` must be properly aligned to the group size (`Group::WIDTH`);\n///\n/// * `ctrl` must point to the array of properly initialized control bytes;\n///\n/// * `data` must be the [`Bucket`] at the `ctrl` index in the table;\n///\n/// * the value of `len` must be less than or equal to the number of table buckets,\n///   and the returned value of `ctrl.as_ptr().add(len).offset_from(ctrl.as_ptr())`\n///   must be positive.\n///\n/// * The `ctrl.add(len)` pointer must be either in bounds or one\n///   byte past the end of the same [allocated table].\n///\n/// * The `len` must be a power of two.\n///\n/// [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\ninline\nunsafe fn new(ctrl: *const u8, data: Bucket<T>, len: usize) -> Self{\n        debug_assert_ne!(len, 0);\n        debug_assert_eq!(ctrl as usize % Group::WIDTH, 0);\n        // SAFETY: The caller must uphold the safety rules for the [`RawIterRange::new`]\n        let end = ctrl.add(len);\n\n        // Load the first group and advance ctrl to point to the next group\n        // SAFETY: The caller must uphold the safety rules for the [`RawIterRange::new`]\n        let current_group = Group::load_aligned(ctrl.cast()).match_full();\n        let next_ctrl = ctrl.add(Group::WIDTH);\n\n        Self {\n            current_group: current_group.into_iter(),\n            data,\n            next_ctrl,\n            end,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawIterRange::<T>::next_impl': ['/// # Safety\n/// If `DO_CHECK_PTR_RANGE` is false, caller must ensure that we never try to iterate\n/// after yielding all elements.\ninline\nunsafe fn next_impl<const DO_CHECK_PTR_RANGE: bool>(&mut self) -> Option<Bucket<T>>{\n        loop {\n            if let Some(index) = self.current_group.next() {\n                return Some(self.data.next_n(index));\n            }\n\n            if DO_CHECK_PTR_RANGE && self.next_ctrl >= self.end {\n                return None;\n            }\n\n            // We might read past self.end up to the next group boundary,\n            // but this is fine because it only occurs on tables smaller\n            // than the group size where the trailing control bytes are all\n            // EMPTY. On larger tables self.end is guaranteed to be aligned\n            // to the group size (since tables are power-of-two sized).\n            self.current_group = Group::load_aligned(self.next_ctrl.cast())\n                .match_full()\n                .into_iter();\n            self.data = self.data.next_n(Group::WIDTH);\n            self.next_ctrl = self.next_ctrl.add(Group::WIDTH);\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable': ['/// A raw hash table with an unsafe API.\npub struct RawTable<T, A: Allocator = Global> {\n    table: RawTableInner,\n    alloc: A,\n    // Tell dropck that we own instances of T.\n    marker: PhantomData<T>,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::allocation_size': ['/// Returns the total amount of memory allocated internally by the hash\n/// table, in bytes.\n///\n/// The returned number is informational only. It is intended to be\n/// primarily used for memory profiling.\n#[inline]\npub fn allocation_size(&self) -> usize{\n        // SAFETY: We use the same `table_layout` that was used to allocate\n        // this table.\n        unsafe { self.table.allocation_size_or_zero(Self::TABLE_LAYOUT) }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::allocator': ['/// Returns a reference to the underlying allocator.\n#[inline]\npub fn allocator(&self) -> &A{\n        &self.alloc\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::bucket': ['/// Returns a pointer to an element in the table.\n///\n/// The caller must ensure that the `RawTable` outlives the returned [`Bucket<T>`],\n/// otherwise using it may result in [`undefined behavior`].\n///\n/// # Safety\n///\n/// If `mem::size_of::<T>() != 0`, then the caller of this function must observe the\n/// following safety rules:\n///\n/// * The table must already be allocated;\n///\n/// * The `index` must not be greater than the number returned by the [`RawTable::buckets`]\n///   function, i.e. `(index + 1) <= self.buckets()`.\n///\n/// It is safe to call this function with index of zero (`index == 0`) on a table that has\n/// not been allocated, but using the returned [`Bucket`] results in [`undefined behavior`].\n///\n/// If `mem::size_of::<T>() == 0`, then the only requirement is that the `index` must\n/// not be greater than the number returned by the [`RawTable::buckets`] function, i.e.\n/// `(index + 1) <= self.buckets()`.\n///\n/// [`RawTable::buckets`]: RawTable::buckets\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\npub unsafe fn bucket(&self, index: usize) -> Bucket<T>{\n        // If mem::size_of::<T>() != 0 then return a pointer to the `element` in the `data part` of the table\n        // (we start counting from "0", so that in the expression T[n], the "n" index actually one less than\n        // the "buckets" number of our `RawTable`, i.e. "n = RawTable::buckets() - 1"):\n        //\n        //           `table.bucket(3).as_ptr()` returns a pointer that points here in the `data`\n        //           part of the `RawTable`, i.e. to the start of T3 (see `Bucket::as_ptr`)\n        //                  |\n        //                  |               `base = self.data_end()` points here\n        //                  |               (to the start of CT0 or to the end of T0)\n        //                  v                 v\n        // [Pad], T_n, ..., |T3|, T2, T1, T0, |CT0, CT1, CT2, CT3, ..., CT_n, CTa_0, CTa_1, ..., CTa_m\n        //                     ^                                              \\__________  __________/\n        //        `table.bucket(3)` returns a pointer that points                        \\/\n        //         here in the `data` part of the `RawTable` (to              additional control bytes\n        //         the end of T3)                                              `m = Group::WIDTH - 1`\n        //\n        // where: T0...T_n  - our stored data;\n        //        CT0...CT_n - control bytes or metadata for `data`;\n        //        CTa_0...CTa_m - additional control bytes (so that the search with loading `Group` bytes from\n        //                        the heap works properly, even if the result of `h1(hash) & self.table.bucket_mask`\n        //                        is equal to `self.table.bucket_mask`). See also `RawTableInner::set_ctrl` function.\n        //\n        // P.S. `h1(hash) & self.table.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n        // of buckets is a power of two, and `self.table.bucket_mask = self.buckets() - 1`.\n        debug_assert_ne!(self.table.bucket_mask, 0);\n        debug_assert!(index < self.buckets());\n        Bucket::from_base_index(self.data_end(), index)\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::bucket_index': ['/// Returns the index of a bucket from a `Bucket`.\n#[inline]\npub unsafe fn bucket_index(&self, bucket: &Bucket<T>) -> usize{\n        bucket.to_base_index(self.data_end())\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::buckets': ['/// Returns the number of buckets in the table.\n#[inline]\npub fn buckets(&self) -> usize{\n        self.table.bucket_mask + 1\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::capacity': ['/// Returns the number of elements the map can hold without reallocating.\n///\n/// This number is a lower bound; the table might be able to hold\n/// more, but is guaranteed to be able to hold at least this many.\n#[inline]\npub fn capacity(&self) -> usize{\n        self.table.items + self.table.growth_left\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::clear': ['/// Removes all elements from the table without freeing the backing memory.\ninline\npub fn clear(&mut self){\n        if self.is_empty() {\n            // Special case empty table to avoid surprising O(capacity) time.\n            return;\n        }\n        // Ensure that the table is reset even if one of the drops panic\n        let mut self_ = guard(self, |self_| self_.clear_no_drop());\n        unsafe {\n            // SAFETY: ScopeGuard sets to zero the `items` field of the table\n            // even in case of panic during the dropping of the elements so\n            // that there will be no double drop of the elements.\n            self_.table.drop_elements::<T>();\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::clear_no_drop': ['/// Marks all table buckets as empty without dropping their contents.\ninline\npub fn clear_no_drop(&mut self){\n        self.table.clear_no_drop();\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::clone_from_impl': ['/// Common code for `clone` and `clone_from`. Assumes:\n/// - `self.buckets() == source.buckets()`.\n/// - Any existing elements have been dropped.\n/// - The control bytes are not initialized yet.\ninline\nunsafe fn clone_from_impl(&mut self, source: &Self){\n        // Copy the control bytes unchanged. We do this in a single pass\n        source\n            .table\n            .ctrl(0)\n            .copy_to_nonoverlapping(self.table.ctrl(0), self.table.num_ctrl_bytes());\n\n        // The cloning of elements may panic, in which case we need\n        // to make sure we drop only the elements that have been\n        // cloned so far.\n        let mut guard = guard((0, &mut *self), |(index, self_)| {\n            if T::NEEDS_DROP {\n                for i in 0..*index {\n                    if self_.is_bucket_full(i) {\n                        self_.bucket(i).drop();\n                    }\n                }\n            }\n        });\n\n        for from in source.iter() {\n            let index = source.bucket_index(&from);\n            let to = guard.1.bucket(index);\n            to.write(from.as_ref().clone());\n\n            // Update the index in case we need to unwind.\n            guard.0 = index + 1;\n        }\n\n        // Successfully cloned all items, no need to clean up.\n        mem::forget(guard);\n\n        self.table.items = source.table.items;\n        self.table.growth_left = source.table.growth_left;\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::data_end': ['/// Returns pointer to one past last `data` element in the table as viewed from\n/// the start point of the allocation.\n///\n/// The caller must ensure that the `RawTable` outlives the returned [`NonNull<T>`],\n/// otherwise using it may result in [`undefined behavior`].\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\npub fn data_end(&self) -> NonNull<T>{\n        //                        `self.table.ctrl.cast()` returns pointer that\n        //                        points here (to the end of `T0`)\n        //                          \n        // [Pad], T_n, ..., T1, T0, |CT0, CT1, ..., CT_n|, CTa_0, CTa_1, ..., CTa_m\n        //                           \\________  ________/\n        //                                    \\/\n        //       `n = buckets - 1`, i.e. `RawTable::buckets() - 1`\n        //\n        // where: T0...T_n  - our stored data;\n        //        CT0...CT_n - control bytes or metadata for `data`.\n        //        CTa_0...CTa_m - additional control bytes, where `m = Group::WIDTH - 1` (so that the search\n        //                        with loading `Group` bytes from the heap works properly, even if the result\n        //                        of `h1(hash) & self.bucket_mask` is equal to `self.bucket_mask`). See also\n        //                        `RawTableInner::set_ctrl` function.\n        //\n        // P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n        // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n        self.table.ctrl.cast()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::drain': ["/// Returns an iterator which removes all elements from the table without\n/// freeing the memory.\ninline\npub fn drain(&mut self) -> RawDrain<'_, T, A>{\n        unsafe {\n            let iter = self.iter();\n            self.drain_iter_from(iter)\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::drain_iter_from': ["/// Returns an iterator which removes all elements from the table without\n/// freeing the memory.\n///\n/// Iteration starts at the provided iterator's current location.\n///\n/// It is up to the caller to ensure that the iterator is valid for this\n/// `RawTable` and covers all items that remain in the table.\ninline\npub unsafe fn drain_iter_from(&mut self, iter: RawIter<T>) -> RawDrain<'_, T, A>{\n        debug_assert_eq!(iter.len(), self.len());\n        RawDrain {\n            iter,\n            table: mem::replace(&mut self.table, RawTableInner::NEW),\n            orig_table: NonNull::from(&mut self.table),\n            marker: PhantomData,\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::erase': ['/// Erases an element from the table, dropping it in place.\ninline\n#[allow(clippy::needless_pass_by_value)]\npub unsafe fn erase(&mut self, item: Bucket<T>){\n        // Erase the element from the table first since drop might panic.\n        self.erase_no_drop(&item);\n        item.drop();\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::erase_no_drop': ['/// Erases an element from the table without dropping it.\ninline\nunsafe fn erase_no_drop(&mut self, item: &Bucket<T>){\n        let index = self.bucket_index(item);\n        self.table.erase(index);\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::find': ['/// Searches for an element in the table.\n#[inline]\npub fn find(&self, hash: u64, mut eq: impl FnMut(&T) -> bool) -> Option<Bucket<T>>{\n        unsafe {\n            // SAFETY:\n            // 1. The [`RawTableInner`] must already have properly initialized control bytes since we\n            //    will never expose `RawTable::new_uninitialized` in a public API.\n            // 1. The `find_inner` function returns the `index` of only the full bucket, which is in\n            //    the range `0..self.buckets()`, so calling `self.bucket(index)` and `Bucket::as_ref`\n            //    is safe.\n            let result = self\n                .table\n                .find_inner(hash, &mut |index| eq(self.bucket(index).as_ref()));\n\n            // Avoid `Option::map` because it bloats LLVM IR.\n            match result {\n                // SAFETY: See explanation above.\n                Some(index) => Some(self.bucket(index)),\n                None => None,\n            }\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::find_or_find_insert_slot': ['/// Searches for an element in the table. If the element is not found,\n/// returns `Err` with the position of a slot where an element with the\n/// same hash could be inserted.\n///\n/// This function may resize the table if additional space is required for\n/// inserting an element.\n#[inline]\npub fn find_or_find_insert_slot(\n        &mut self,\n        hash: u64,\n        mut eq: impl FnMut(&T) -> bool,\n        hasher: impl Fn(&T) -> u64,\n    ) -> Result<Bucket<T>, InsertSlot>{\n        self.reserve(1, hasher);\n\n        unsafe {\n            // SAFETY:\n            // 1. We know for sure that there is at least one empty `bucket` in the table.\n            // 2. The [`RawTableInner`] must already have properly initialized control bytes since we will\n            //    never expose `RawTable::new_uninitialized` in a public API.\n            // 3. The `find_or_find_insert_slot_inner` function returns the `index` of only the full bucket,\n            //    which is in the range `0..self.buckets()` (since there is at least one empty `bucket` in\n            //    the table), so calling `self.bucket(index)` and `Bucket::as_ref` is safe.\n            match self\n                .table\n                .find_or_find_insert_slot_inner(hash, &mut |index| eq(self.bucket(index).as_ref()))\n            {\n                // SAFETY: See explanation above.\n                Ok(index) => Ok(self.bucket(index)),\n                Err(slot) => Err(slot),\n            }\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::get': ['/// Gets a reference to an element in the table.\n#[inline]\npub fn get(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.find(hash, eq) {\n            Some(bucket) => Some(unsafe { bucket.as_ref() }),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::get_many_mut': ['/// Attempts to get mutable references to `N` entries in the table at once.\n///\n/// Returns an array of length `N` with the results of each query.\n///\n/// At most one mutable reference will be returned to any entry. `None` will be returned if any\n/// of the hashes are duplicates. `None` will be returned if the hash is not found.\n///\n/// The `eq` argument should be a closure such that `eq(i, k)` returns true if `k` is equal to\n/// the `i`th key to be looked up.\npub fn get_many_mut<const N: usize>(\n        &mut self,\n        hashes: [u64; N],\n        eq: impl FnMut(usize, &T) -> bool,\n    ) -> [Option<&\'_ mut T>; N]{\n        unsafe {\n            let ptrs = self.get_many_mut_pointers(hashes, eq);\n\n            for (i, cur) in ptrs.iter().enumerate() {\n                if cur.is_some() && ptrs[..i].contains(cur) {\n                    panic!("duplicate keys found");\n                }\n            }\n            // All bucket are distinct from all previous buckets so we\'re clear to return the result\n            // of the lookup.\n\n            ptrs.map(|ptr| ptr.map(|mut ptr| ptr.as_mut()))\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::get_many_mut_pointers': ['unsafe fn get_many_mut_pointers<const N: usize>(\n        &mut self,\n        hashes: [u64; N],\n        mut eq: impl FnMut(usize, &T) -> bool,\n    ) -> [Option<NonNull<T>>; N]{\n        array::from_fn(|i| {\n            self.find(hashes[i], |k| eq(i, k))\n                .map(|cur| cur.as_non_null())\n        })\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::get_many_unchecked_mut': ["pub unsafe fn get_many_unchecked_mut<const N: usize>(\n        &mut self,\n        hashes: [u64; N],\n        eq: impl FnMut(usize, &T) -> bool,\n    ) -> [Option<&'_ mut T>; N]{\n        let ptrs = self.get_many_mut_pointers(hashes, eq);\n        ptrs.map(|ptr| ptr.map(|mut ptr| ptr.as_mut()))\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::get_mut': ['/// Gets a mutable reference to an element in the table.\n#[inline]\npub fn get_mut(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&mut T>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.find(hash, eq) {\n            Some(bucket) => Some(unsafe { bucket.as_mut() }),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::insert': ['/// Inserts a new element into the table, and returns its raw bucket.\n///\n/// This does not check if the given element already exists in the table.\ninline\npub fn insert(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> Bucket<T>{\n        unsafe {\n            // SAFETY:\n            // 1. The [`RawTableInner`] must already have properly initialized control bytes since\n            //    we will never expose `RawTable::new_uninitialized` in a public API.\n            //\n            // 2. We reserve additional space (if necessary) right after calling this function.\n            let mut slot = self.table.find_insert_slot(hash);\n\n            // We can avoid growing the table once we have reached our load factor if we are replacing\n            // a tombstone. This works since the number of EMPTY slots does not change in this case.\n            //\n            // SAFETY: The function is guaranteed to return [`InsertSlot`] that contains an index\n            // in the range `0..=self.buckets()`.\n            let old_ctrl = *self.table.ctrl(slot.index);\n            if unlikely(self.table.growth_left == 0 && old_ctrl.special_is_empty()) {\n                self.reserve(1, hasher);\n                // SAFETY: We know for sure that `RawTableInner` has control bytes\n                // initialized and that there is extra space in the table.\n                slot = self.table.find_insert_slot(hash);\n            }\n\n            self.insert_in_slot(hash, slot, value)\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::insert_entry': ['/// Inserts a new element into the table, and returns a mutable reference to it.\n///\n/// This does not check if the given element already exists in the table.\ninline\npub fn insert_entry(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> &mut T{\n        unsafe { self.insert(hash, value, hasher).as_mut() }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::insert_in_slot': ['/// Inserts a new element into the table in the given slot, and returns its\n/// raw bucket.\n///\n/// # Safety\n///\n/// `slot` must point to a slot previously returned by\n/// `find_or_find_insert_slot`, and no mutation of the table must have\n/// occurred since that call.\n#[inline]\npub unsafe fn insert_in_slot(&mut self, hash: u64, slot: InsertSlot, value: T) -> Bucket<T>{\n        let old_ctrl = *self.table.ctrl(slot.index);\n        self.table.record_item_insert_at(slot.index, old_ctrl, hash);\n\n        let bucket = self.bucket(slot.index);\n        bucket.write(value);\n        bucket\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::into_allocation': ['/// Converts the table into a raw allocation. The contents of the table\n/// should be dropped using a `RawIter` before freeing the allocation.\ninline\npub(crate) fn into_allocation(self) -> Option<(NonNull<u8>, Layout, A)>{\n        let alloc = if self.table.is_empty_singleton() {\n            None\n        } else {\n            // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.\n            let (layout, ctrl_offset) =\n                match Self::TABLE_LAYOUT.calculate_layout_for(self.table.buckets()) {\n                    Some(lco) => lco,\n                    None => unsafe { hint::unreachable_unchecked() },\n                };\n            Some((\n                unsafe { NonNull::new_unchecked(self.table.ctrl.as_ptr().sub(ctrl_offset).cast()) },\n                layout,\n                unsafe { ptr::read(&self.alloc) },\n            ))\n        };\n        mem::forget(self);\n        alloc\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::into_iter_from': ["/// Returns an iterator which consumes all elements from the table.\n///\n/// Iteration starts at the provided iterator's current location.\n///\n/// It is up to the caller to ensure that the iterator is valid for this\n/// `RawTable` and covers all items that remain in the table.\npub unsafe fn into_iter_from(self, iter: RawIter<T>) -> RawIntoIter<T, A>{\n        debug_assert_eq!(iter.len(), self.len());\n\n        let allocation = self.into_allocation();\n        RawIntoIter {\n            iter,\n            allocation,\n            marker: PhantomData,\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::is_bucket_full': ['/// Checks whether the bucket at `index` is full.\n///\n/// # Safety\n///\n/// The caller must ensure `index` is less than the number of buckets.\n#[inline]\npub unsafe fn is_bucket_full(&self, index: usize) -> bool{\n        self.table.is_bucket_full(index)\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::is_empty': ['/// Returns `true` if the table contains no elements.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::iter': ['/// Returns an iterator over every element in the table. It is up to\n/// the caller to ensure that the `RawTable` outlives the `RawIter`.\n/// Because we cannot make the `next` method unsafe on the `RawIter`\n/// struct, we have to make the `iter` method unsafe.\n#[inline]\npub unsafe fn iter(&self) -> RawIter<T>{\n        // SAFETY:\n        // 1. The caller must uphold the safety contract for `iter` method.\n        // 2. The [`RawTableInner`] must already have properly initialized control bytes since\n        //    we will never expose RawTable::new_uninitialized in a public API.\n        self.table.iter()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::iter_hash': ['/// Returns an iterator over occupied buckets that could match a given hash.\n///\n/// `RawTable` only stores 7 bits of the hash value, so this iterator may\n/// return items that have a hash value different than the one provided. You\n/// should always validate the returned values before using them.\n///\n/// It is up to the caller to ensure that the `RawTable` outlives the\n/// `RawIterHash`. Because we cannot make the `next` method unsafe on the\n/// `RawIterHash` struct, we have to make the `iter_hash` method unsafe.\ninline\npub unsafe fn iter_hash(&self, hash: u64) -> RawIterHash<T>{\n        RawIterHash::new(self, hash)\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::len': ['/// Returns the number of elements in the table.\n#[inline]\npub fn len(&self) -> usize{\n        self.table.items\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::new_in': ['/// Creates a new empty hash table without allocating any memory, using the\n/// given allocator.\n///\n/// In effect this returns a table with exactly 1 bucket. However we can\n/// leave the data pointer dangling since that bucket is never written to\n/// due to our load factor forcing us to always have at least 1 free bucket.\n#[inline]\npub const fn new_in(alloc: A) -> Self{\n        Self {\n            table: RawTableInner::NEW,\n            alloc,\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::new_uninitialized': ['/// Allocates a new hash table with the given number of buckets.\n///\n/// The control bytes are left uninitialized.\ninline\nunsafe fn new_uninitialized(\n        alloc: A,\n        buckets: usize,\n        fallibility: Fallibility,\n    ) -> Result<Self, TryReserveError>{\n        debug_assert!(buckets.is_power_of_two());\n\n        Ok(Self {\n            table: RawTableInner::new_uninitialized(\n                &alloc,\n                Self::TABLE_LAYOUT,\n                buckets,\n                fallibility,\n            )?,\n            alloc,\n            marker: PhantomData,\n        })\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::remove': ['/// Removes an element from the table, returning it.\n///\n/// This also returns an `InsertSlot` pointing to the newly free bucket.\ninline\n#[allow(clippy::needless_pass_by_value)]\npub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot){\n        self.erase_no_drop(&item);\n        (\n            item.read(),\n            InsertSlot {\n                index: self.bucket_index(&item),\n            },\n        )\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::remove_entry': ['/// Finds and removes an element from the table, returning it.\ninline\npub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<T>{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.find(hash, eq) {\n            Some(bucket) => Some(unsafe { self.remove(bucket).0 }),\n            None => None,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::replace_bucket_with': ['/// Temporary removes a bucket, applying the given function to the removed\n/// element and optionally put back the returned value in the same bucket.\n///\n/// Returns `true` if the bucket still contains an element\n///\n/// This does not check if the given bucket is actually occupied.\ninline\npub unsafe fn replace_bucket_with<F>(&mut self, bucket: Bucket<T>, f: F) -> bool\n    where\n        F: FnOnce(T) -> Option<T>,{\n        let index = self.bucket_index(&bucket);\n        let old_ctrl = *self.table.ctrl(index);\n        debug_assert!(self.is_bucket_full(index));\n        let old_growth_left = self.table.growth_left;\n        let item = self.remove(bucket).0;\n        if let Some(new_item) = f(item) {\n            self.table.growth_left = old_growth_left;\n            self.table.set_ctrl(index, old_ctrl);\n            self.table.items += 1;\n            self.bucket(index).write(new_item);\n            true\n        } else {\n            false\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::reserve': ['/// Ensures that at least `additional` items can be inserted into the table\n/// without reallocation.\ninline\npub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64){\n        if unlikely(additional > self.table.growth_left) {\n            // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.\n            unsafe {\n                // SAFETY: The [`RawTableInner`] must already have properly initialized control\n                // bytes since we will never expose RawTable::new_uninitialized in a public API.\n                if self\n                    .reserve_rehash(additional, hasher, Fallibility::Infallible)\n                    .is_err()\n                {\n                    // SAFETY: All allocation errors will be caught inside `RawTableInner::reserve_rehash`.\n                    hint::unreachable_unchecked()\n                }\n            }\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::reserve_rehash': ['/// Out-of-line slow path for `reserve` and `try_reserve`.\n///\n/// # Safety\n///\n/// The [`RawTableInner`] must have properly initialized control bytes,\n/// otherwise calling this function results in [`undefined behavior`]\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[cold]\n#[inline(never)]\nunsafe fn reserve_rehash(\n        &mut self,\n        additional: usize,\n        hasher: impl Fn(&T) -> u64,\n        fallibility: Fallibility,\n    ) -> Result<(), TryReserveError>{\n        unsafe {\n            // SAFETY:\n            // 1. We know for sure that `alloc` and `layout` matches the [`Allocator`] and\n            //    [`TableLayout`] that were used to allocate this table.\n            // 2. The `drop` function is the actual drop function of the elements stored in\n            //    the table.\n            // 3. The caller ensures that the control bytes of the `RawTableInner`\n            //    are already initialized.\n            self.table.reserve_rehash_inner(\n                &self.alloc,\n                additional,\n                &|table, index| hasher(table.bucket::<T>(index).as_ref()),\n                fallibility,\n                Self::TABLE_LAYOUT,\n                if T::NEEDS_DROP {\n                    Some(|ptr| ptr::drop_in_place(ptr as *mut T))\n                } else {\n                    None\n                },\n            )\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::resize': ['/// Allocates a new table of a different size and moves the contents of the\n/// current table into it.\n///\n/// # Safety\n///\n/// The [`RawTableInner`] must have properly initialized control bytes,\n/// otherwise calling this function results in [`undefined behavior`]\n///\n/// The caller of this function must ensure that `capacity >= self.table.items`\n/// otherwise:\n///\n/// * If `self.table.items != 0`, calling of this function with `capacity`\n///   equal to 0 (`capacity == 0`) results in [`undefined behavior`].\n///\n/// * If `self.table.items > capacity_to_buckets(capacity, Self::TABLE_LAYOUT)`\n///   calling this function are never return (will loop infinitely).\n///\n/// See [`RawTableInner::find_insert_slot`] for more information.\n///\n/// [`RawTableInner::find_insert_slot`]: RawTableInner::find_insert_slot\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\nunsafe fn resize(\n        &mut self,\n        capacity: usize,\n        hasher: impl Fn(&T) -> u64,\n        fallibility: Fallibility,\n    ) -> Result<(), TryReserveError>{\n        // SAFETY:\n        // 1. The caller of this function guarantees that `capacity >= self.table.items`.\n        // 2. We know for sure that `alloc` and `layout` matches the [`Allocator`] and\n        //    [`TableLayout`] that were used to allocate this table.\n        // 3. The caller ensures that the control bytes of the `RawTableInner`\n        //    are already initialized.\n        self.table.resize_inner(\n            &self.alloc,\n            capacity,\n            &|table, index| hasher(table.bucket::<T>(index).as_ref()),\n            fallibility,\n            Self::TABLE_LAYOUT,\n        )\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::shrink_to': ["/// Shrinks the table to fit `max(self.len(), min_size)` elements.\ninline\npub fn shrink_to(&mut self, min_size: usize, hasher: impl Fn(&T) -> u64){\n        // Calculate the minimal number of elements that we need to reserve\n        // space for.\n        let min_size = usize::max(self.table.items, min_size);\n        if min_size == 0 {\n            let mut old_inner = mem::replace(&mut self.table, RawTableInner::NEW);\n            unsafe {\n                // SAFETY:\n                // 1. We call the function only once;\n                // 2. We know for sure that `alloc` and `table_layout` matches the [`Allocator`]\n                //    and [`TableLayout`] that were used to allocate this table.\n                // 3. If any elements' drop function panics, then there will only be a memory leak,\n                //    because we have replaced the inner table with a new one.\n                old_inner.drop_inner_table::<T, _>(&self.alloc, Self::TABLE_LAYOUT);\n            }\n            return;\n        }\n\n        // Calculate the number of buckets that we need for this number of\n        // elements. If the calculation overflows then the requested bucket\n        // count must be larger than what we have right and nothing needs to be\n        // done.\n        let min_buckets = match capacity_to_buckets(min_size, Self::TABLE_LAYOUT) {\n            Some(buckets) => buckets,\n            None => return,\n        };\n\n        // If we have more buckets than we need, shrink the table.\n        if min_buckets < self.buckets() {\n            // Fast path if the table is empty\n            if self.table.items == 0 {\n                let new_inner =\n                    RawTableInner::with_capacity(&self.alloc, Self::TABLE_LAYOUT, min_size);\n                let mut old_inner = mem::replace(&mut self.table, new_inner);\n                unsafe {\n                    // SAFETY:\n                    // 1. We call the function only once;\n                    // 2. We know for sure that `alloc` and `table_layout` matches the [`Allocator`]\n                    //    and [`TableLayout`] that were used to allocate this table.\n                    // 3. If any elements' drop function panics, then there will only be a memory leak,\n                    //    because we have replaced the inner table with a new one.\n                    old_inner.drop_inner_table::<T, _>(&self.alloc, Self::TABLE_LAYOUT);\n                }\n            } else {\n                // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.\n                unsafe {\n                    // SAFETY:\n                    // 1. We know for sure that `min_size >= self.table.items`.\n                    // 2. The [`RawTableInner`] must already have properly initialized control bytes since\n                    //    we will never expose RawTable::new_uninitialized in a public API.\n                    if self\n                        .resize(min_size, hasher, Fallibility::Infallible)\n                        .is_err()\n                    {\n                        // SAFETY: The result of calling the `resize` function cannot be an error\n                        // because `fallibility == Fallibility::Infallible.\n                        hint::unreachable_unchecked()\n                    }\n                }\n            }\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::try_reserve': ['/// Tries to ensure that at least `additional` items can be inserted into\n/// the table without reallocation.\ninline\npub fn try_reserve(\n        &mut self,\n        additional: usize,\n        hasher: impl Fn(&T) -> u64,\n    ) -> Result<(), TryReserveError>{\n        if additional > self.table.growth_left {\n            // SAFETY: The [`RawTableInner`] must already have properly initialized control\n            // bytes since we will never expose RawTable::new_uninitialized in a public API.\n            unsafe { self.reserve_rehash(additional, hasher, Fallibility::Fallible) }\n        } else {\n            Ok(())\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T, A>::with_capacity_in': ['/// Allocates a new hash table using the given allocator, with at least enough capacity for\n/// inserting the given number of elements without reallocating.\npub fn with_capacity_in(capacity: usize, alloc: A) -> Self{\n        Self {\n            table: RawTableInner::with_capacity(&alloc, Self::TABLE_LAYOUT, capacity),\n            alloc,\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T>::new': ['/// Creates a new empty hash table without allocating any memory.\n///\n/// In effect this returns a table with exactly 1 bucket. However we can\n/// leave the data pointer dangling since that bucket is never written to\n/// due to our load factor forcing us to always have at least 1 free bucket.\n#[inline]\npub const fn new() -> Self{\n        Self {\n            table: RawTableInner::NEW,\n            alloc: Global,\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTable::<T>::with_capacity': ['/// Allocates a new hash table with at least enough capacity for inserting\n/// the given number of elements without reallocating.\npub fn with_capacity(capacity: usize) -> Self{\n        Self::with_capacity_in(capacity, Global)\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableClone': ['/// Specialization of `clone_from` for `Copy` types\ntrait RawTableClone {\n    unsafe fn clone_from_spec(&mut self, source: &Self);\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner': ['/// Non-generic part of `RawTable` which allows functions to be instantiated only once regardless\n/// of how many different key-value types are used.\nstruct RawTableInner {\n    // Mask to get an index from a hash value. The value is one less than the\n    // number of buckets in the table.\n    bucket_mask: usize,\n\n    // [Padding], T_n, ..., T1, T0, C0, C1, ...\n    //                              ^ points here\n    ctrl: NonNull<u8>,\n\n    // Number of elements that can be inserted before we need to grow the table\n    growth_left: usize,\n\n    // Number of elements in the table, only really used by len()\n    items: usize,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::allocation_info': ['/// Returns a pointer to the allocated memory and the layout that was used to\n/// allocate the table.\n///\n/// # Safety\n///\n/// Caller of this function must observe the following safety rules:\n///\n/// * The [`RawTableInner`] has already been allocated, otherwise\n///   calling this function results in [`undefined behavior`]\n///\n/// * The `table_layout` must be the same [`TableLayout`] as the `TableLayout`\n///   that was used to allocate this table. Failure to comply with this condition\n///   may result in [`undefined behavior`].\n///\n/// See also [`GlobalAlloc::dealloc`] or [`Allocator::deallocate`] for more  information.\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n/// [`GlobalAlloc::dealloc`]: https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.dealloc\n/// [`Allocator::deallocate`]: https://doc.rust-lang.org/alloc/alloc/trait.Allocator.html#tymethod.deallocate\n#[inline]\nunsafe fn allocation_info(&self, table_layout: TableLayout) -> (NonNull<u8>, Layout){\n        debug_assert!(\n            !self.is_empty_singleton(),\n            "this function can only be called on non-empty tables"\n        );\n\n        // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.\n        let (layout, ctrl_offset) = match table_layout.calculate_layout_for(self.buckets()) {\n            Some(lco) => lco,\n            None => unsafe { hint::unreachable_unchecked() },\n        };\n        (\n            // SAFETY: The caller must uphold the safety contract for `allocation_info` method.\n            unsafe { NonNull::new_unchecked(self.ctrl.as_ptr().sub(ctrl_offset)) },\n            layout,\n        )\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::allocation_size_or_zero': ['/// Returns the total amount of memory allocated internally by the hash\n/// table, in bytes.\n///\n/// The returned number is informational only. It is intended to be\n/// primarily used for memory profiling.\n///\n/// # Safety\n///\n/// The `table_layout` must be the same [`TableLayout`] as the `TableLayout`\n/// that was used to allocate this table. Failure to comply with this condition\n/// may result in [`undefined behavior`].\n///\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn allocation_size_or_zero(&self, table_layout: TableLayout) -> usize{\n        if self.is_empty_singleton() {\n            0\n        } else {\n            // SAFETY:\n            // 1. We have checked that our table is allocated.\n            // 2. The caller ensures that `table_layout` matches the [`TableLayout`]\n            // that was used to allocate this table.\n            unsafe { self.allocation_info(table_layout).1.size() }\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::bucket': ['/// Returns a pointer to an element in the table (convenience for\n/// `Bucket::from_base_index(self.data_end::<T>(), index)`).\n///\n/// The caller must ensure that the `RawTableInner` outlives the returned [`Bucket<T>`],\n/// otherwise using it may result in [`undefined behavior`].\n///\n/// # Safety\n///\n/// If `mem::size_of::<T>() != 0`, then the safety rules are directly derived from the\n/// safety rules of the [`Bucket::from_base_index`] function. Therefore, when calling\n/// this function, the following safety rules must be observed:\n///\n/// * The table must already be allocated;\n///\n/// * The `index` must not be greater than the number returned by the [`RawTableInner::buckets`]\n///   function, i.e. `(index + 1) <= self.buckets()`.\n///\n/// * The type `T` must be the actual type of the elements stored in the table, otherwise\n///   using the returned [`Bucket`] may result in [`undefined behavior`].\n///\n/// It is safe to call this function with index of zero (`index == 0`) on a table that has\n/// not been allocated, but using the returned [`Bucket`] results in [`undefined behavior`].\n///\n/// If `mem::size_of::<T>() == 0`, then the only requirement is that the `index` must\n/// not be greater than the number returned by the [`RawTable::buckets`] function, i.e.\n/// `(index + 1) <= self.buckets()`.\n///\n/// ```none\n/// If mem::size_of::<T>() != 0 then return a pointer to the `element` in the `data part` of the table\n/// (we start counting from "0", so that in the expression T[n], the "n" index actually one less than\n/// the "buckets" number of our `RawTableInner`, i.e. "n = RawTableInner::buckets() - 1"):\n///\n///           `table.bucket(3).as_ptr()` returns a pointer that points here in the `data`\n///           part of the `RawTableInner`, i.e. to the start of T3 (see [`Bucket::as_ptr`])\n///                  |\n///                  |               `base = table.data_end::<T>()` points here\n///                  |               (to the start of CT0 or to the end of T0)\n///                  v                 v\n/// [Pad], T_n, ..., |T3|, T2, T1, T0, |CT0, CT1, CT2, CT3, ..., CT_n, CTa_0, CTa_1, ..., CTa_m\n///                     ^                                              \\__________  __________/\n///        `table.bucket(3)` returns a pointer that points                        \\/\n///         here in the `data` part of the `RawTableInner`             additional control bytes\n///         (to the end of T3)                                          `m = Group::WIDTH - 1`\n///\n/// where: T0...T_n  - our stored data;\n///        CT0...CT_n - control bytes or metadata for `data`;\n///        CTa_0...CTa_m - additional control bytes (so that the search with loading `Group` bytes from\n///                        the heap works properly, even if the result of `h1(hash) & self.bucket_mask`\n///                        is equal to `self.bucket_mask`). See also `RawTableInner::set_ctrl` function.\n///\n/// P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n/// of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n/// ```\n///\n/// [`Bucket::from_base_index`]: Bucket::from_base_index\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn bucket<T>(&self, index: usize) -> Bucket<T>{\n        debug_assert_ne!(self.bucket_mask, 0);\n        debug_assert!(index < self.buckets());\n        Bucket::from_base_index(self.data_end(), index)\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::bucket_ptr': ['/// Returns a raw `*mut u8` pointer to the start of the `data` element in the table\n/// (convenience for `self.data_end::<u8>().as_ptr().sub((index + 1) * size_of)`).\n///\n/// The caller must ensure that the `RawTableInner` outlives the returned `*mut u8`,\n/// otherwise using it may result in [`undefined behavior`].\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is [`undefined behavior`]:\n///\n/// * The table must already be allocated;\n///\n/// * The `index` must not be greater than the number returned by the [`RawTableInner::buckets`]\n///   function, i.e. `(index + 1) <= self.buckets()`;\n///\n/// * The `size_of` must be equal to the size of the elements stored in the table;\n///\n/// ```none\n/// If mem::size_of::<T>() != 0 then return a pointer to the `element` in the `data part` of the table\n/// (we start counting from "0", so that in the expression T[n], the "n" index actually one less than\n/// the "buckets" number of our `RawTableInner`, i.e. "n = RawTableInner::buckets() - 1"):\n///\n///           `table.bucket_ptr(3, mem::size_of::<T>())` returns a pointer that points here in the\n///           `data` part of the `RawTableInner`, i.e. to the start of T3\n///                  |\n///                  |               `base = table.data_end::<u8>()` points here\n///                  |               (to the start of CT0 or to the end of T0)\n///                  v                 v\n/// [Pad], T_n, ..., |T3|, T2, T1, T0, |CT0, CT1, CT2, CT3, ..., CT_n, CTa_0, CTa_1, ..., CTa_m\n///                                                                    \\__________  __________/\n///                                                                               \\/\n///                                                                    additional control bytes\n///                                                                     `m = Group::WIDTH - 1`\n///\n/// where: T0...T_n  - our stored data;\n///        CT0...CT_n - control bytes or metadata for `data`;\n///        CTa_0...CTa_m - additional control bytes (so that the search with loading `Group` bytes from\n///                        the heap works properly, even if the result of `h1(hash) & self.bucket_mask`\n///                        is equal to `self.bucket_mask`). See also `RawTableInner::set_ctrl` function.\n///\n/// P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n/// of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n/// ```\n///\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn bucket_ptr(&self, index: usize, size_of: usize) -> *mut u8{\n        debug_assert_ne!(self.bucket_mask, 0);\n        debug_assert!(index < self.buckets());\n        let base: *mut u8 = self.data_end().as_ptr();\n        base.sub((index + 1) * size_of)\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::buckets': ['#[inline]\nfn buckets(&self) -> usize{\n        self.bucket_mask + 1\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::clear_no_drop': ['/// Marks all table buckets as empty without dropping their contents.\n#[inline]\nfn clear_no_drop(&mut self){\n        if !self.is_empty_singleton() {\n            self.ctrl_slice().fill_empty();\n        }\n        self.items = 0;\n        self.growth_left = bucket_mask_to_capacity(self.bucket_mask);\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::ctrl': ['/// Returns a pointer to a control byte.\n///\n/// # Safety\n///\n/// For the allocated [`RawTableInner`], the result is [`Undefined Behavior`],\n/// if the `index` is greater than the `self.bucket_mask + 1 + Group::WIDTH`.\n/// In that case, calling this function with `index == self.bucket_mask + 1 + Group::WIDTH`\n/// will return a pointer to the end of the allocated table and it is useless on its own.\n///\n/// Calling this function with `index >= self.bucket_mask + 1 + Group::WIDTH` on a\n/// table that has not been allocated results in [`Undefined Behavior`].\n///\n/// So to satisfy both requirements you should always follow the rule that\n/// `index < self.bucket_mask + 1 + Group::WIDTH`\n///\n/// Calling this function on [`RawTableInner`] that are not already allocated is safe\n/// for read-only purpose.\n///\n/// See also [`Bucket::as_ptr()`] method, for more information about of properly removing\n/// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`Bucket::as_ptr()`]: Bucket::as_ptr()\n/// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn ctrl(&self, index: usize) -> *mut Tag{\n        debug_assert!(index < self.num_ctrl_bytes());\n        // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::ctrl`]\n        self.ctrl.as_ptr().add(index).cast()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::ctrl_slice': ["/// Gets the slice of all control bytes.\nfn ctrl_slice(&mut self) -> &mut [Tag]{\n        // SAFETY: We've intiailized all control bytes, and have the correct number.\n        unsafe { slice::from_raw_parts_mut(self.ctrl.as_ptr().cast(), self.num_ctrl_bytes()) }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::data_end': ['/// Returns pointer to one past last `data` element in the table as viewed from\n/// the start point of the allocation (convenience for `self.ctrl.cast()`).\n///\n/// This function actually returns a pointer to the end of the `data element` at\n/// index "0" (zero).\n///\n/// The caller must ensure that the `RawTableInner` outlives the returned [`NonNull<T>`],\n/// otherwise using it may result in [`undefined behavior`].\n///\n/// # Note\n///\n/// The type `T` must be the actual type of the elements stored in the table, otherwise\n/// using the returned [`NonNull<T>`] may result in [`undefined behavior`].\n///\n/// ```none\n///                        `table.data_end::<T>()` returns pointer that points here\n///                        (to the end of `T0`)\n///                          \n/// [Pad], T_n, ..., T1, T0, |CT0, CT1, ..., CT_n|, CTa_0, CTa_1, ..., CTa_m\n///                           \\________  ________/\n///                                    \\/\n///       `n = buckets - 1`, i.e. `RawTableInner::buckets() - 1`\n///\n/// where: T0...T_n  - our stored data;\n///        CT0...CT_n - control bytes or metadata for `data`.\n///        CTa_0...CTa_m - additional control bytes, where `m = Group::WIDTH - 1` (so that the search\n///                        with loading `Group` bytes from the heap works properly, even if the result\n///                        of `h1(hash) & self.bucket_mask` is equal to `self.bucket_mask`). See also\n///                        `RawTableInner::set_ctrl` function.\n///\n/// P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n/// of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n/// ```\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nfn data_end<T>(&self) -> NonNull<T>{\n        self.ctrl.cast()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::drop_elements': ['/// Executes the destructors (if any) of the values stored in the table.\n///\n/// # Note\n///\n/// This function does not erase the control bytes of the table and does\n/// not make any changes to the `items` or `growth_left` fields of the\n/// table. If necessary, the caller of this function must manually set\n/// up these table fields, for example using the [`clear_no_drop`] function.\n///\n/// Be careful during calling this function, because drop function of\n/// the elements can panic, and this can leave table in an inconsistent\n/// state.\n///\n/// # Safety\n///\n/// The type `T` must be the actual type of the elements stored in the table,\n/// otherwise calling this function may result in [`undefined behavior`].\n///\n/// If `T` is a type that should be dropped and **the table is not empty**,\n/// calling this function more than once results in [`undefined behavior`].\n///\n/// If `T` is not [`Copy`], attempting to use values stored in the table after\n/// calling this function may result in [`undefined behavior`].\n///\n/// It is safe to call this function on a table that has not been allocated,\n/// on a table with uninitialized control bytes, and on a table with no actual\n/// data but with `Full` control bytes if `self.items == 0`.\n///\n/// See also [`Bucket::drop`] / [`Bucket::as_ptr`] methods, for more information\n/// about of properly removing or saving `element` from / into the [`RawTable`] /\n/// [`RawTableInner`].\n///\n/// [`Bucket::drop`]: Bucket::drop\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`clear_no_drop`]: RawTableInner::clear_no_drop\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\nunsafe fn drop_elements<T>(&mut self){\n        // Check that `self.items != 0`. Protects against the possibility\n        // of creating an iterator on an table with uninitialized control bytes.\n        if T::NEEDS_DROP && self.items != 0 {\n            // SAFETY: We know for sure that RawTableInner will outlive the\n            // returned `RawIter` iterator, and the caller of this function\n            // must uphold the safety contract for `drop_elements` method.\n            for item in self.iter::<T>() {\n                // SAFETY: The caller must uphold the safety contract for\n                // `drop_elements` method.\n                item.drop();\n            }\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::drop_inner_table': ["/// Executes the destructors (if any) of the values stored in the table and than\n/// deallocates the table.\n///\n/// # Note\n///\n/// Calling this function automatically makes invalid (dangling) all instances of\n/// buckets ([`Bucket`]) and makes invalid (dangling) the `ctrl` field of the table.\n///\n/// This function does not make any changes to the `bucket_mask`, `items` or `growth_left`\n/// fields of the table. If necessary, the caller of this function must manually set\n/// up these table fields.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is [`undefined behavior`]:\n///\n/// * Calling this function more than once;\n///\n/// * The type `T` must be the actual type of the elements stored in the table.\n///\n/// * The `alloc` must be the same [`Allocator`] as the `Allocator` that was used\n///   to allocate this table.\n///\n/// * The `table_layout` must be the same [`TableLayout`] as the `TableLayout` that\n///   was used to allocate this table.\n///\n/// The caller of this function should pay attention to the possibility of the\n/// elements' drop function panicking, because this:\n///\n///    * May leave the table in an inconsistent state;\n///\n///    * Memory is never deallocated, so a memory leak may occur.\n///\n/// Attempt to use the `ctrl` field of the table (dereference) after calling this\n/// function results in [`undefined behavior`].\n///\n/// It is safe to call this function on a table that has not been allocated,\n/// on a table with uninitialized control bytes, and on a table with no actual\n/// data but with `Full` control bytes if `self.items == 0`.\n///\n/// See also [`RawTableInner::drop_elements`] or [`RawTableInner::free_buckets`]\n/// for more  information.\n///\n/// [`RawTableInner::drop_elements`]: RawTableInner::drop_elements\n/// [`RawTableInner::free_buckets`]: RawTableInner::free_buckets\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\nunsafe fn drop_inner_table<T, A: Allocator>(&mut self, alloc: &A, table_layout: TableLayout){\n        if !self.is_empty_singleton() {\n            unsafe {\n                // SAFETY: The caller must uphold the safety contract for `drop_inner_table` method.\n                self.drop_elements::<T>();\n                // SAFETY:\n                // 1. We have checked that our table is allocated.\n                // 2. The caller must uphold the safety contract for `drop_inner_table` method.\n                self.free_buckets(alloc, table_layout);\n            }\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::erase': ["/// Erases the [`Bucket`]'s control byte at the given index so that it does not\n/// triggered as full, decreases the `items` of the table and, if it can be done,\n/// increases `self.growth_left`.\n///\n/// This function does not actually erase / drop the [`Bucket`] itself, i.e. it\n/// does not make any changes to the `data` parts of the table. The caller of this\n/// function must take care to properly drop the `data`, otherwise calling this\n/// function may result in a memory leak.\n///\n/// # Safety\n///\n/// You must observe the following safety rules when calling this function:\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * It must be the full control byte at the given position;\n///\n/// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n///\n/// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n///\n/// Calling this function on a table with no elements is unspecified, but calling subsequent\n/// functions is likely to result in [`undefined behavior`] due to overflow subtraction\n/// (`self.items -= 1 cause overflow when self.items == 0`).\n///\n/// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n/// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn erase(&mut self, index: usize){\n        debug_assert!(self.is_bucket_full(index));\n\n        // This is the same as `index.wrapping_sub(Group::WIDTH) % self.buckets()` because\n        // the number of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n        let index_before = index.wrapping_sub(Group::WIDTH) & self.bucket_mask;\n        // SAFETY:\n        // - The caller must uphold the safety contract for `erase` method;\n        // - `index_before` is guaranteed to be in range due to masking with `self.bucket_mask`\n        let empty_before = Group::load(self.ctrl(index_before)).match_empty();\n        let empty_after = Group::load(self.ctrl(index)).match_empty();\n\n        // Inserting and searching in the map is performed by two key functions:\n        //\n        // - The `find_insert_slot` function that looks up the index of any `Tag::EMPTY` or `Tag::DELETED`\n        //   slot in a group to be able to insert. If it doesn't find an `Tag::EMPTY` or `Tag::DELETED`\n        //   slot immediately in the first group, it jumps to the next `Group` looking for it,\n        //   and so on until it has gone through all the groups in the control bytes.\n        //\n        // - The `find_inner` function that looks for the index of the desired element by looking\n        //   at all the `FULL` bytes in the group. If it did not find the element right away, and\n        //   there is no `Tag::EMPTY` byte in the group, then this means that the `find_insert_slot`\n        //   function may have found a suitable slot in the next group. Therefore, `find_inner`\n        //   jumps further, and if it does not find the desired element and again there is no `Tag::EMPTY`\n        //   byte, then it jumps further, and so on. The search stops only if `find_inner` function\n        //   finds the desired element or hits an `Tag::EMPTY` slot/byte.\n        //\n        // Accordingly, this leads to two consequences:\n        //\n        // - The map must have `Tag::EMPTY` slots (bytes);\n        //\n        // - You can't just mark the byte to be erased as `Tag::EMPTY`, because otherwise the `find_inner`\n        //   function may stumble upon an `Tag::EMPTY` byte before finding the desired element and stop\n        //   searching.\n        //\n        // Thus it is necessary to check all bytes after and before the erased element. If we are in\n        // a contiguous `Group` of `FULL` or `Tag::DELETED` bytes (the number of `FULL` or `Tag::DELETED` bytes\n        // before and after is greater than or equal to `Group::WIDTH`), then we must mark our byte as\n        // `Tag::DELETED` in order for the `find_inner` function to go further. On the other hand, if there\n        // is at least one `Tag::EMPTY` slot in the `Group`, then the `find_inner` function will still stumble\n        // upon an `Tag::EMPTY` byte, so we can safely mark our erased byte as `Tag::EMPTY` as well.\n        //\n        // Finally, since `index_before == (index.wrapping_sub(Group::WIDTH) & self.bucket_mask) == index`\n        // and given all of the above, tables smaller than the group width (self.buckets() < Group::WIDTH)\n        // cannot have `Tag::DELETED` bytes.\n        //\n        // Note that in this context `leading_zeros` refers to the bytes at the end of a group, while\n        // `trailing_zeros` refers to the bytes at the beginning of a group.\n        let ctrl = if empty_before.leading_zeros() + empty_after.trailing_zeros() >= Group::WIDTH {\n            Tag::DELETED\n        } else {\n            self.growth_left += 1;\n            Tag::EMPTY\n        };\n        // SAFETY: the caller must uphold the safety contract for `erase` method.\n        self.set_ctrl(index, ctrl);\n        self.items -= 1;\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::fallible_with_capacity': ['/// Attempts to allocate a new [`RawTableInner`] with at least enough\n/// capacity for inserting the given number of elements without reallocating.\n///\n/// All the control bytes are initialized with the [`Tag::EMPTY`] bytes.\n#[inline]\nfn fallible_with_capacity<A>(\n        alloc: &A,\n        table_layout: TableLayout,\n        capacity: usize,\n        fallibility: Fallibility,\n    ) -> Result<Self, TryReserveError>\n    where\n        A: Allocator,{\n        if capacity == 0 {\n            Ok(Self::NEW)\n        } else {\n            // SAFETY: We checked that we could successfully allocate the new table, and then\n            // initialized all control bytes with the constant `Tag::EMPTY` byte.\n            unsafe {\n                let buckets = capacity_to_buckets(capacity, table_layout)\n                    .ok_or_else(|| fallibility.capacity_overflow())?;\n\n                let mut result =\n                    Self::new_uninitialized(alloc, table_layout, buckets, fallibility)?;\n                // SAFETY: We checked that the table is allocated and therefore the table already has\n                // `self.bucket_mask + 1 + Group::WIDTH` number of control bytes (see TableLayout::calculate_layout_for)\n                // so writing `self.num_ctrl_bytes() == bucket_mask + 1 + Group::WIDTH` bytes is safe.\n                result.ctrl_slice().fill_empty();\n\n                Ok(result)\n            }\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::find_inner': ['/// Searches for an element in a table, returning the `index` of the found element.\n/// This uses dynamic dispatch to reduce the amount of code generated, but it is\n/// eliminated by LLVM optimizations.\n///\n/// This function does not make any changes to the `data` part of the table, or any\n/// changes to the `items` or `growth_left` field of the table.\n///\n/// The table must have at least 1 empty `bucket`, otherwise, if the\n/// `eq: &mut dyn FnMut(usize) -> bool` function does not return `true`,\n/// this function will also never return (will go into an infinite loop).\n///\n/// This function is guaranteed to provide the `eq: &mut dyn FnMut(usize) -> bool`\n/// function with only `FULL` buckets\' indices and return the `index` of the found\n/// element as `Some(index)`, so the index will always be in the range\n/// `0..self.buckets()`.\n///\n/// # Safety\n///\n/// The [`RawTableInner`] must have properly initialized control bytes otherwise calling\n/// this function results in [`undefined behavior`].\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline(always)]\nunsafe fn find_inner(&self, hash: u64, eq: &mut dyn FnMut(usize) -> bool) -> Option<usize>{\n        let tag_hash = Tag::full(hash);\n        let mut probe_seq = self.probe_seq(hash);\n\n        loop {\n            // SAFETY:\n            // * Caller of this function ensures that the control bytes are properly initialized.\n            //\n            // * `ProbeSeq.pos` cannot be greater than `self.bucket_mask = self.buckets() - 1`\n            //   of the table due to masking with `self.bucket_mask`.\n            //\n            // * Even if `ProbeSeq.pos` returns `position == self.bucket_mask`, it is safe to\n            //   call `Group::load` due to the extended control bytes range, which is\n            //  `self.bucket_mask + 1 + Group::WIDTH` (in fact, this means that the last control\n            //   byte will never be read for the allocated table);\n            //\n            // * Also, even if `RawTableInner` is not already allocated, `ProbeSeq.pos` will\n            //   always return "0" (zero), so Group::load will read unaligned `Group::static_empty()`\n            //   bytes, which is safe (see RawTableInner::new_in).\n            let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };\n\n            for bit in group.match_tag(tag_hash) {\n                // This is the same as `(probe_seq.pos + bit) % self.buckets()` because the number\n                // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n                let index = (probe_seq.pos + bit) & self.bucket_mask;\n\n                if likely(eq(index)) {\n                    return Some(index);\n                }\n            }\n\n            if likely(group.match_empty().any_bit_set()) {\n                return None;\n            }\n\n            probe_seq.move_next(self.bucket_mask);\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::find_insert_slot': ['/// Searches for an empty or deleted bucket which is suitable for inserting\n/// a new element, returning the `index` for the new [`Bucket`].\n///\n/// This function does not make any changes to the `data` part of the table, or any\n/// changes to the `items` or `growth_left` field of the table.\n///\n/// The table must have at least 1 empty or deleted `bucket`, otherwise this function\n/// will never return (will go into an infinite loop) for tables larger than the group\n/// width, or return an index outside of the table indices range if the table is less\n/// than the group width.\n///\n/// If there is at least 1 empty or deleted `bucket` in the table, the function is\n/// guaranteed to return [`InsertSlot`] with an index in the range `0..self.buckets()`,\n/// but in any case, if this function returns [`InsertSlot`], it will contain an index\n/// in the range `0..=self.buckets()`.\n///\n/// # Safety\n///\n/// The [`RawTableInner`] must have properly initialized control bytes otherwise calling\n/// this function results in [`undefined behavior`].\n///\n/// Attempt to write data at the [`InsertSlot`] returned by this function when the table is\n/// less than the group width and if there was not at least one empty or deleted bucket in\n/// the table will cause immediate [`undefined behavior`]. This is because in this case the\n/// function will return `self.bucket_mask + 1` as an index due to the trailing [`Tag::EMPTY`]\n/// control bytes outside the table range.\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn find_insert_slot(&self, hash: u64) -> InsertSlot{\n        let mut probe_seq = self.probe_seq(hash);\n        loop {\n            // SAFETY:\n            // * Caller of this function ensures that the control bytes are properly initialized.\n            //\n            // * `ProbeSeq.pos` cannot be greater than `self.bucket_mask = self.buckets() - 1`\n            //   of the table due to masking with `self.bucket_mask` and also because the number\n            //   of buckets is a power of two (see `self.probe_seq` function).\n            //\n            // * Even if `ProbeSeq.pos` returns `position == self.bucket_mask`, it is safe to\n            //   call `Group::load` due to the extended control bytes range, which is\n            //  `self.bucket_mask + 1 + Group::WIDTH` (in fact, this means that the last control\n            //   byte will never be read for the allocated table);\n            //\n            // * Also, even if `RawTableInner` is not already allocated, `ProbeSeq.pos` will\n            //   always return "0" (zero), so Group::load will read unaligned `Group::static_empty()`\n            //   bytes, which is safe (see RawTableInner::new).\n            let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };\n\n            let index = self.find_insert_slot_in_group(&group, &probe_seq);\n            if likely(index.is_some()) {\n                // SAFETY:\n                // * Caller of this function ensures that the control bytes are properly initialized.\n                //\n                // * We use this function with the slot / index found by `self.find_insert_slot_in_group`\n                unsafe {\n                    return self.fix_insert_slot(index.unwrap_unchecked());\n                }\n            }\n            probe_seq.move_next(self.bucket_mask);\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::find_insert_slot_in_group': ["/// Finds the position to insert something in a group.\n///\n/// **This may have false positives and must be fixed up with `fix_insert_slot`\n/// before it's used.**\n///\n/// The function is guaranteed to return the index of an empty or deleted [`Bucket`]\n/// in the range `0..self.buckets()` (`0..=self.bucket_mask`).\n#[inline]\nfn find_insert_slot_in_group(&self, group: &Group, probe_seq: &ProbeSeq) -> Option<usize>{\n        let bit = group.match_empty_or_deleted().lowest_set_bit();\n\n        if likely(bit.is_some()) {\n            // This is the same as `(probe_seq.pos + bit) % self.buckets()` because the number\n            // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n            Some((probe_seq.pos + bit.unwrap()) & self.bucket_mask)\n        } else {\n            None\n        }\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::find_or_find_insert_slot_inner': ['/// Searches for an element in the table, or a potential slot where that element could\n/// be inserted (an empty or deleted [`Bucket`] index).\n///\n/// This uses dynamic dispatch to reduce the amount of code generated, but that is\n/// eliminated by LLVM optimizations.\n///\n/// This function does not make any changes to the `data` part of the table, or any\n/// changes to the `items` or `growth_left` field of the table.\n///\n/// The table must have at least 1 empty or deleted `bucket`, otherwise, if the\n/// `eq: &mut dyn FnMut(usize) -> bool` function does not return `true`, this function\n/// will never return (will go into an infinite loop) for tables larger than the group\n/// width, or return an index outside of the table indices range if the table is less\n/// than the group width.\n///\n/// This function is guaranteed to provide the `eq: &mut dyn FnMut(usize) -> bool`\n/// function with only `FULL` buckets\' indices and return the `index` of the found\n/// element (as `Ok(index)`). If the element is not found and there is at least 1\n/// empty or deleted [`Bucket`] in the table, the function is guaranteed to return\n/// [`InsertSlot`] with an index in the range `0..self.buckets()`, but in any case,\n/// if this function returns [`InsertSlot`], it will contain an index in the range\n/// `0..=self.buckets()`.\n///\n/// # Safety\n///\n/// The [`RawTableInner`] must have properly initialized control bytes otherwise calling\n/// this function results in [`undefined behavior`].\n///\n/// Attempt to write data at the [`InsertSlot`] returned by this function when the table is\n/// less than the group width and if there was not at least one empty or deleted bucket in\n/// the table will cause immediate [`undefined behavior`]. This is because in this case the\n/// function will return `self.bucket_mask + 1` as an index due to the trailing [`Tag::EMPTY`]\n/// control bytes outside the table range.\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn find_or_find_insert_slot_inner(\n        &self,\n        hash: u64,\n        eq: &mut dyn FnMut(usize) -> bool,\n    ) -> Result<usize, InsertSlot>{\n        let mut insert_slot = None;\n\n        let tag_hash = Tag::full(hash);\n        let mut probe_seq = self.probe_seq(hash);\n\n        loop {\n            // SAFETY:\n            // * Caller of this function ensures that the control bytes are properly initialized.\n            //\n            // * `ProbeSeq.pos` cannot be greater than `self.bucket_mask = self.buckets() - 1`\n            //   of the table due to masking with `self.bucket_mask` and also because the number\n            //   of buckets is a power of two (see `self.probe_seq` function).\n            //\n            // * Even if `ProbeSeq.pos` returns `position == self.bucket_mask`, it is safe to\n            //   call `Group::load` due to the extended control bytes range, which is\n            //  `self.bucket_mask + 1 + Group::WIDTH` (in fact, this means that the last control\n            //   byte will never be read for the allocated table);\n            //\n            // * Also, even if `RawTableInner` is not already allocated, `ProbeSeq.pos` will\n            //   always return "0" (zero), so Group::load will read unaligned `Group::static_empty()`\n            //   bytes, which is safe (see RawTableInner::new).\n            let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };\n\n            for bit in group.match_tag(tag_hash) {\n                let index = (probe_seq.pos + bit) & self.bucket_mask;\n\n                if likely(eq(index)) {\n                    return Ok(index);\n                }\n            }\n\n            // We didn\'t find the element we were looking for in the group, try to get an\n            // insertion slot from the group if we don\'t have one yet.\n            if likely(insert_slot.is_none()) {\n                insert_slot = self.find_insert_slot_in_group(&group, &probe_seq);\n            }\n\n            if let Some(insert_slot) = insert_slot {\n                // Only stop the search if the group contains at least one empty element.\n                // Otherwise, the element that we are looking for might be in a following group.\n                if likely(group.match_empty().any_bit_set()) {\n                    // We must have found a insert slot by now, since the current group contains at\n                    // least one. For tables smaller than the group width, there will still be an\n                    // empty element in the current (and only) group due to the load factor.\n                    unsafe {\n                        // SAFETY:\n                        // * Caller of this function ensures that the control bytes are properly initialized.\n                        //\n                        // * We use this function with the slot / index found by `self.find_insert_slot_in_group`\n                        return Err(self.fix_insert_slot(insert_slot));\n                    }\n                }\n            }\n\n            probe_seq.move_next(self.bucket_mask);\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::fix_insert_slot': ['/// Fixes up an insertion slot returned by the [`RawTableInner::find_insert_slot_in_group`] method.\n///\n/// In tables smaller than the group width (`self.buckets() < Group::WIDTH`), trailing control\n/// bytes outside the range of the table are filled with [`Tag::EMPTY`] entries. These will unfortunately\n/// trigger a match of [`RawTableInner::find_insert_slot_in_group`] function. This is because\n/// the `Some(bit)` returned by `group.match_empty_or_deleted().lowest_set_bit()` after masking\n/// (`(probe_seq.pos + bit) & self.bucket_mask`) may point to a full bucket that is already occupied.\n/// We detect this situation here and perform a second scan starting at the beginning of the table.\n/// This second scan is guaranteed to find an empty slot (due to the load factor) before hitting the\n/// trailing control bytes (containing [`Tag::EMPTY`] bytes).\n///\n/// If this function is called correctly, it is guaranteed to return [`InsertSlot`] with an\n/// index of an empty or deleted bucket in the range `0..self.buckets()` (see `Warning` and\n/// `Safety`).\n///\n/// # Warning\n///\n/// The table must have at least 1 empty or deleted `bucket`, otherwise if the table is less than\n/// the group width (`self.buckets() < Group::WIDTH`) this function returns an index outside of the\n/// table indices range `0..self.buckets()` (`0..=self.bucket_mask`). Attempt to write data at that\n/// index will cause immediate [`undefined behavior`].\n///\n/// # Safety\n///\n/// The safety rules are directly derived from the safety rules for [`RawTableInner::ctrl`] method.\n/// Thus, in order to uphold those safety contracts, as well as for the correct logic of the work\n/// of this crate, the following rules are necessary and sufficient:\n///\n/// * The [`RawTableInner`] must have properly initialized control bytes otherwise calling this\n///   function results in [`undefined behavior`].\n///\n/// * This function must only be used on insertion slots found by [`RawTableInner::find_insert_slot_in_group`]\n///   (after the `find_insert_slot_in_group` function, but before insertion into the table).\n///\n/// * The `index` must not be greater than the `self.bucket_mask`, i.e. `(index + 1) <= self.buckets()`\n///   (this one is provided by the [`RawTableInner::find_insert_slot_in_group`] function).\n///\n/// Calling this function with an index not provided by [`RawTableInner::find_insert_slot_in_group`]\n/// may result in [`undefined behavior`] even if the index satisfies the safety rules of the\n/// [`RawTableInner::ctrl`] function (`index < self.bucket_mask + 1 + Group::WIDTH`).\n///\n/// [`RawTableInner::ctrl`]: RawTableInner::ctrl\n/// [`RawTableInner::find_insert_slot_in_group`]: RawTableInner::find_insert_slot_in_group\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn fix_insert_slot(&self, mut index: usize) -> InsertSlot{\n        // SAFETY: The caller of this function ensures that `index` is in the range `0..=self.bucket_mask`.\n        if unlikely(self.is_bucket_full(index)) {\n            debug_assert!(self.bucket_mask < Group::WIDTH);\n            // SAFETY:\n            //\n            // * Since the caller of this function ensures that the control bytes are properly\n            //   initialized and `ptr = self.ctrl(0)` points to the start of the array of control\n            //   bytes, therefore: `ctrl` is valid for reads, properly aligned to `Group::WIDTH`\n            //   and points to the properly initialized control bytes (see also\n            //   `TableLayout::calculate_layout_for` and `ptr::read`);\n            //\n            // * Because the caller of this function ensures that the index was provided by the\n            //   `self.find_insert_slot_in_group()` function, so for for tables larger than the\n            //   group width (self.buckets() >= Group::WIDTH), we will never end up in the given\n            //   branch, since `(probe_seq.pos + bit) & self.bucket_mask` in `find_insert_slot_in_group`\n            //   cannot return a full bucket index. For tables smaller than the group width, calling\n            //   the `unwrap_unchecked` function is also safe, as the trailing control bytes outside\n            //   the range of the table are filled with EMPTY bytes (and we know for sure that there\n            //   is at least one FULL bucket), so this second scan either finds an empty slot (due to\n            //   the load factor) or hits the trailing control bytes (containing EMPTY).\n            index = Group::load_aligned(self.ctrl(0))\n                .match_empty_or_deleted()\n                .lowest_set_bit()\n                .unwrap_unchecked();\n        }\n        InsertSlot { index }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::free_buckets': ['/// Deallocates the table without dropping any entries.\n///\n/// # Note\n///\n/// This function must be called only after [`drop_elements`](RawTableInner::drop_elements),\n/// else it can lead to leaking of memory. Also calling this function automatically\n/// makes invalid (dangling) all instances of buckets ([`Bucket`]) and makes invalid\n/// (dangling) the `ctrl` field of the table.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is [`Undefined Behavior`]:\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * The `alloc` must be the same [`Allocator`] as the `Allocator` that was used\n///   to allocate this table.\n///\n/// * The `table_layout` must be the same [`TableLayout`] as the `TableLayout` that was used\n///   to allocate this table.\n///\n/// See also [`GlobalAlloc::dealloc`] or [`Allocator::deallocate`] for more  information.\n///\n/// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n/// [`GlobalAlloc::dealloc`]: https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html#tymethod.dealloc\n/// [`Allocator::deallocate`]: https://doc.rust-lang.org/alloc/alloc/trait.Allocator.html#tymethod.deallocate\n#[inline]\nunsafe fn free_buckets<A>(&mut self, alloc: &A, table_layout: TableLayout)\n    where\n        A: Allocator,{\n        // SAFETY: The caller must uphold the safety contract for `free_buckets`\n        // method.\n        let (ptr, layout) = self.allocation_info(table_layout);\n        alloc.deallocate(ptr, layout);\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::full_buckets_indices': ['/// Returns an iterator over full buckets indices in the table.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * The caller has to ensure that the `RawTableInner` outlives the\n///   `FullBucketsIndices`. Because we cannot make the `next` method\n///   unsafe on the `FullBucketsIndices` struct, we have to make the\n///   `full_buckets_indices` method unsafe.\n///\n/// * The [`RawTableInner`] must have properly initialized control bytes.\n#[inline(always)]\nunsafe fn full_buckets_indices(&self) -> FullBucketsIndices{\n        // SAFETY:\n        // 1. Since the caller of this function ensures that the control bytes\n        //    are properly initialized and `self.ctrl(0)` points to the start\n        //    of the array of control bytes, therefore: `ctrl` is valid for reads,\n        //    properly aligned to `Group::WIDTH` and points to the properly initialized\n        //    control bytes.\n        // 2. The value of `items` is equal to the amount of data (values) added\n        //    to the table.\n        //\n        //                         `ctrl` points here (to the start\n        //                         of the first control byte `CT0`)\n        //                          \n        // [Pad], T_n, ..., T1, T0, |CT0, CT1, ..., CT_n|, Group::WIDTH\n        //                           \\________  ________/\n        //                                    \\/\n        //       `n = buckets - 1`, i.e. `RawTableInner::buckets() - 1`\n        //\n        // where: T0...T_n  - our stored data;\n        //        CT0...CT_n - control bytes or metadata for `data`.\n        let ctrl = NonNull::new_unchecked(self.ctrl(0).cast::<u8>());\n\n        FullBucketsIndices {\n            // Load the first group\n            // SAFETY: See explanation above.\n            current_group: Group::load_aligned(ctrl.as_ptr().cast())\n                .match_full()\n                .into_iter(),\n            group_first_index: 0,\n            ctrl,\n            items: self.items,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::is_bucket_full': ['/// Checks whether the bucket at `index` is full.\n///\n/// # Safety\n///\n/// The caller must ensure `index` is less than the number of buckets.\n#[inline]\nunsafe fn is_bucket_full(&self, index: usize) -> bool{\n        debug_assert!(index < self.buckets());\n        (*self.ctrl(index)).is_full()\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::is_empty_singleton': ['#[inline]\nfn is_empty_singleton(&self) -> bool{\n        self.bucket_mask == 0\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::is_in_same_group': ['#[inline]\nfn is_in_same_group(&self, i: usize, new_i: usize, hash: u64) -> bool{\n        let probe_seq_pos = self.probe_seq(hash).pos;\n        let probe_index =\n            |pos: usize| (pos.wrapping_sub(probe_seq_pos) & self.bucket_mask) / Group::WIDTH;\n        probe_index(i) == probe_index(new_i)\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::iter': ['/// Returns an iterator over every element in the table.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result\n/// is [`undefined behavior`]:\n///\n/// * The caller has to ensure that the `RawTableInner` outlives the\n///   `RawIter`. Because we cannot make the `next` method unsafe on\n///   the `RawIter` struct, we have to make the `iter` method unsafe.\n///\n/// * The [`RawTableInner`] must have properly initialized control bytes.\n///\n/// The type `T` must be the actual type of the elements stored in the table,\n/// otherwise using the returned [`RawIter`] results in [`undefined behavior`].\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn iter<T>(&self) -> RawIter<T>{\n        // SAFETY:\n        // 1. Since the caller of this function ensures that the control bytes\n        //    are properly initialized and `self.data_end()` points to the start\n        //    of the array of control bytes, therefore: `ctrl` is valid for reads,\n        //    properly aligned to `Group::WIDTH` and points to the properly initialized\n        //    control bytes.\n        // 2. `data` bucket index in the table is equal to the `ctrl` index (i.e.\n        //    equal to zero).\n        // 3. We pass the exact value of buckets of the table to the function.\n        //\n        //                         `ctrl` points here (to the start\n        //                         of the first control byte `CT0`)\n        //                          \n        // [Pad], T_n, ..., T1, T0, |CT0, CT1, ..., CT_n|, CTa_0, CTa_1, ..., CTa_m\n        //                           \\________  ________/\n        //                                    \\/\n        //       `n = buckets - 1`, i.e. `RawTableInner::buckets() - 1`\n        //\n        // where: T0...T_n  - our stored data;\n        //        CT0...CT_n - control bytes or metadata for `data`.\n        //        CTa_0...CTa_m - additional control bytes, where `m = Group::WIDTH - 1` (so that the search\n        //                        with loading `Group` bytes from the heap works properly, even if the result\n        //                        of `h1(hash) & self.bucket_mask` is equal to `self.bucket_mask`). See also\n        //                        `RawTableInner::set_ctrl` function.\n        //\n        // P.S. `h1(hash) & self.bucket_mask` is the same as `hash as usize % self.buckets()` because the number\n        // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n        let data = Bucket::from_base_index(self.data_end(), 0);\n        RawIter {\n            // SAFETY: See explanation above\n            iter: RawIterRange::new(self.ctrl.as_ptr(), data, self.buckets()),\n            items: self.items,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::new': ['/// Creates a new empty hash table without allocating any memory.\n///\n/// In effect this returns a table with exactly 1 bucket. However we can\n/// leave the data pointer dangling since that bucket is never accessed\n/// due to our load factor forcing us to always have at least 1 free bucket.\n#[inline]\nconst fn new() -> Self{\n        Self {\n            // Be careful to cast the entire slice to a raw pointer.\n            ctrl: unsafe {\n                NonNull::new_unchecked(Group::static_empty().as_ptr().cast_mut().cast())\n            },\n            bucket_mask: 0,\n            items: 0,\n            growth_left: 0,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::new_uninitialized': ['/// Allocates a new [`RawTableInner`] with the given number of buckets.\n/// The control bytes and buckets are left uninitialized.\n///\n/// # Safety\n///\n/// The caller of this function must ensure that the `buckets` is power of two\n/// and also initialize all control bytes of the length `self.bucket_mask + 1 +\n/// Group::WIDTH` with the [`Tag::EMPTY`] bytes.\n///\n/// See also [`Allocator`] API for other safety concerns.\n///\n/// [`Allocator`]: https://doc.rust-lang.org/alloc/alloc/trait.Allocator.html\ninline\nunsafe fn new_uninitialized<A>(\n        alloc: &A,\n        table_layout: TableLayout,\n        buckets: usize,\n        fallibility: Fallibility,\n    ) -> Result<Self, TryReserveError>\n    where\n        A: Allocator,{\n        debug_assert!(buckets.is_power_of_two());\n\n        // Avoid `Option::ok_or_else` because it bloats LLVM IR.\n        let (layout, ctrl_offset) = match table_layout.calculate_layout_for(buckets) {\n            Some(lco) => lco,\n            None => return Err(fallibility.capacity_overflow()),\n        };\n\n        let ptr: NonNull<u8> = match do_alloc(alloc, layout) {\n            Ok(block) => block.cast(),\n            Err(_) => return Err(fallibility.alloc_err(layout)),\n        };\n\n        // SAFETY: null pointer will be caught in above check\n        let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));\n        Ok(Self {\n            ctrl,\n            bucket_mask: buckets - 1,\n            items: 0,\n            growth_left: bucket_mask_to_capacity(buckets - 1),\n        })\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::num_ctrl_bytes': ['#[inline]\nfn num_ctrl_bytes(&self) -> usize{\n        self.bucket_mask + 1 + Group::WIDTH\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::prepare_insert_slot': ['/// Searches for an empty or deleted bucket which is suitable for inserting a new\n/// element and sets the hash for that slot. Returns an index of that slot and the\n/// old control byte stored in the found index.\n///\n/// This function does not check if the given element exists in the table. Also,\n/// this function does not check if there is enough space in the table to insert\n/// a new element. The caller of the function must make sure that the table has at\n/// least 1 empty or deleted `bucket`, otherwise this function will never return\n/// (will go into an infinite loop) for tables larger than the group width, or\n/// return an index outside of the table indices range if the table is less than\n/// the group width.\n///\n/// If there is at least 1 empty or deleted `bucket` in the table, the function is\n/// guaranteed to return an `index` in the range `0..self.buckets()`, but in any case,\n/// if this function returns an `index` it will be in the range `0..=self.buckets()`.\n///\n/// This function does not make any changes to the `data` parts of the table,\n/// or any changes to the `items` or `growth_left` field of the table.\n///\n/// # Safety\n///\n/// The safety rules are directly derived from the safety rules for the\n/// [`RawTableInner::set_ctrl_hash`] and [`RawTableInner::find_insert_slot`] methods.\n/// Thus, in order to uphold the safety contracts for that methods, as well as for\n/// the correct logic of the work of this crate, you must observe the following rules\n/// when calling this function:\n///\n/// * The [`RawTableInner`] has already been allocated and has properly initialized\n///   control bytes otherwise calling this function results in [`undefined behavior`].\n///\n/// * The caller of this function must ensure that the "data" parts of the table\n///   will have an entry in the returned index (matching the given hash) right\n///   after calling this function.\n///\n/// Attempt to write data at the `index` returned by this function when the table is\n/// less than the group width and if there was not at least one empty or deleted bucket in\n/// the table will cause immediate [`undefined behavior`]. This is because in this case the\n/// function will return `self.bucket_mask + 1` as an index due to the trailing [`Tag::EMPTY`]\n/// control bytes outside the table range.\n///\n/// The caller must independently increase the `items` field of the table, and also,\n/// if the old control byte was [`Tag::EMPTY`], then decrease the table\'s `growth_left`\n/// field, and do not change it if the old control byte was [`Tag::DELETED`].\n///\n/// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n/// or saving `element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n/// [`RawTableInner::ctrl`]: RawTableInner::ctrl\n/// [`RawTableInner::set_ctrl_hash`]: RawTableInner::set_ctrl_hash\n/// [`RawTableInner::find_insert_slot`]: RawTableInner::find_insert_slot\n#[inline]\nunsafe fn prepare_insert_slot(&mut self, hash: u64) -> (usize, Tag){\n        // SAFETY: Caller of this function ensures that the control bytes are properly initialized.\n        let index: usize = self.find_insert_slot(hash).index;\n        // SAFETY:\n        // 1. The `find_insert_slot` function either returns an `index` less than or\n        //    equal to `self.buckets() = self.bucket_mask + 1` of the table, or never\n        //    returns if it cannot find an empty or deleted slot.\n        // 2. The caller of this function guarantees that the table has already been\n        //    allocated\n        let old_ctrl = *self.ctrl(index);\n        self.set_ctrl_hash(index, hash);\n        (index, old_ctrl)\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::prepare_rehash_in_place': ['/// Prepares for rehashing data in place (that is, without allocating new memory).\n/// Converts all full index `control bytes` to `Tag::DELETED` and all `Tag::DELETED` control\n/// bytes to `Tag::EMPTY`, i.e. performs the following conversion:\n///\n/// - `Tag::EMPTY` control bytes   -> `Tag::EMPTY`;\n/// - `Tag::DELETED` control bytes -> `Tag::EMPTY`;\n/// - `FULL` control bytes    -> `Tag::DELETED`.\n///\n/// This function does not make any changes to the `data` parts of the table,\n/// or any changes to the `items` or `growth_left` field of the table.\n///\n/// # Safety\n///\n/// You must observe the following safety rules when calling this function:\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * The caller of this function must convert the `Tag::DELETED` bytes back to `FULL`\n///   bytes when re-inserting them into their ideal position (which was impossible\n///   to do during the first insert due to tombstones). If the caller does not do\n///   this, then calling this function may result in a memory leak.\n///\n/// * The [`RawTableInner`] must have properly initialized control bytes otherwise\n///   calling this function results in [`undefined behavior`].\n///\n/// Calling this function on a table that has not been allocated results in\n/// [`undefined behavior`].\n///\n/// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n/// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[allow(clippy::mut_mut)]\n#[inline]\nunsafe fn prepare_rehash_in_place(&mut self){\n        // Bulk convert all full control bytes to DELETED, and all DELETED control bytes to EMPTY.\n        // This effectively frees up all buckets containing a DELETED entry.\n        //\n        // SAFETY:\n        // 1. `i` is guaranteed to be within bounds since we are iterating from zero to `buckets - 1`;\n        // 2. Even if `i` will be `i == self.bucket_mask`, it is safe to call `Group::load_aligned`\n        //    due to the extended control bytes range, which is `self.bucket_mask + 1 + Group::WIDTH`;\n        // 3. The caller of this function guarantees that [`RawTableInner`] has already been allocated;\n        // 4. We can use `Group::load_aligned` and `Group::store_aligned` here since we start from 0\n        //    and go to the end with a step equal to `Group::WIDTH` (see TableLayout::calculate_layout_for).\n        for i in (0..self.buckets()).step_by(Group::WIDTH) {\n            let group = Group::load_aligned(self.ctrl(i));\n            let group = group.convert_special_to_empty_and_full_to_deleted();\n            group.store_aligned(self.ctrl(i));\n        }\n\n        // Fix up the trailing control bytes. See the comments in set_ctrl\n        // for the handling of tables smaller than the group width.\n        //\n        // SAFETY: The caller of this function guarantees that [`RawTableInner`]\n        // has already been allocated\n        if unlikely(self.buckets() < Group::WIDTH) {\n            // SAFETY: We have `self.bucket_mask + 1 + Group::WIDTH` number of control bytes,\n            // so copying `self.buckets() == self.bucket_mask + 1` bytes with offset equal to\n            // `Group::WIDTH` is safe\n            self.ctrl(0)\n                .copy_to(self.ctrl(Group::WIDTH), self.buckets());\n        } else {\n            // SAFETY: We have `self.bucket_mask + 1 + Group::WIDTH` number of\n            // control bytes,so copying `Group::WIDTH` bytes with offset equal\n            // to `self.buckets() == self.bucket_mask + 1` is safe\n            self.ctrl(0)\n                .copy_to(self.ctrl(self.buckets()), Group::WIDTH);\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::prepare_resize': ["/// Attempts to allocate a new hash table with at least enough capacity\n/// for inserting the given number of elements without reallocating,\n/// and return it inside `ScopeGuard` to protect against panic in the hash\n/// function.\n///\n/// # Note\n///\n/// It is recommended (but not required):\n///\n/// * That the new table's `capacity` be greater than or equal to `self.items`.\n///\n/// * The `alloc` is the same [`Allocator`] as the `Allocator` used\n///   to allocate this table.\n///\n/// * The `table_layout` is the same [`TableLayout`] as the `TableLayout` used\n///   to allocate this table.\n///\n/// If `table_layout` does not match the `TableLayout` that was used to allocate\n/// this table, then using `mem::swap` with the `self` and the new table returned\n/// by this function results in [`undefined behavior`].\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[allow(clippy::mut_mut)]\n#[inline]\nfn prepare_resize<'a, A>(\n        &self,\n        alloc: &'a A,\n        table_layout: TableLayout,\n        capacity: usize,\n        fallibility: Fallibility,\n    ) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self) + 'a>, TryReserveError>\n    where\n        A: Allocator,{\n        debug_assert!(self.items <= capacity);\n\n        // Allocate and initialize the new table.\n        let new_table =\n            RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, fallibility)?;\n\n        // The hash function may panic, in which case we simply free the new\n        // table without dropping any elements that may have been copied into\n        // it.\n        //\n        // This guard is also used to free the old table on success, see\n        // the comment at the bottom of this function.\n        Ok(guard(new_table, move |self_| {\n            if !self_.is_empty_singleton() {\n                // SAFETY:\n                // 1. We have checked that our table is allocated.\n                // 2. We know for sure that the `alloc` and `table_layout` matches the\n                //    [`Allocator`] and [`TableLayout`] used to allocate this table.\n                unsafe { self_.free_buckets(alloc, table_layout) };\n            }\n        }))\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::probe_seq': ['/// Returns an iterator-like object for a probe sequence on the table.\n///\n/// This iterator never terminates, but is guaranteed to visit each bucket\n/// group exactly once. The loop using `probe_seq` must terminate upon\n/// reaching a group containing an empty bucket.\n#[inline]\nfn probe_seq(&self, hash: u64) -> ProbeSeq{\n        ProbeSeq {\n            // This is the same as `hash as usize % self.buckets()` because the number\n            // of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n            pos: h1(hash) & self.bucket_mask,\n            stride: 0,\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::record_item_insert_at': ['#[inline]\nunsafe fn record_item_insert_at(&mut self, index: usize, old_ctrl: Tag, hash: u64){\n        self.growth_left -= usize::from(old_ctrl.special_is_empty());\n        self.set_ctrl_hash(index, hash);\n        self.items += 1;\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::rehash_in_place': ["/// Rehashes the contents of the table in place (i.e. without changing the\n/// allocation).\n///\n/// If `hasher` panics then some the table's contents may be lost.\n///\n/// This uses dynamic dispatch to reduce the amount of\n/// code generated, but it is eliminated by LLVM optimizations when inlined.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is [`undefined behavior`]:\n///\n/// * The `size_of` must be equal to the size of the elements stored in the table;\n///\n/// * The `drop` function (`fn(*mut u8)`) must be the actual drop function of\n///   the elements stored in the table.\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * The [`RawTableInner`] must have properly initialized control bytes.\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[allow(clippy::inline_always)]\ninline(always)\nunsafe fn rehash_in_place(\n        &mut self,\n        hasher: &dyn Fn(&mut Self, usize) -> u64,\n        size_of: usize,\n        drop: Option<unsafe fn(*mut u8)>,\n    ){\n        // If the hash function panics then properly clean up any elements\n        // that we haven't rehashed yet. We unfortunately can't preserve the\n        // element since we lost their hash and have no way of recovering it\n        // without risking another panic.\n        self.prepare_rehash_in_place();\n\n        let mut guard = guard(self, move |self_| {\n            if let Some(drop) = drop {\n                for i in 0..self_.buckets() {\n                    if *self_.ctrl(i) == Tag::DELETED {\n                        self_.set_ctrl(i, Tag::EMPTY);\n                        drop(self_.bucket_ptr(i, size_of));\n                        self_.items -= 1;\n                    }\n                }\n            }\n            self_.growth_left = bucket_mask_to_capacity(self_.bucket_mask) - self_.items;\n        });\n\n        // At this point, DELETED elements are elements that we haven't\n        // rehashed yet. Find them and re-insert them at their ideal\n        // position.\n        'outer: for i in 0..guard.buckets() {\n            if *guard.ctrl(i) != Tag::DELETED {\n                continue;\n            }\n\n            let i_p = guard.bucket_ptr(i, size_of);\n\n            'inner: loop {\n                // Hash the current item\n                let hash = hasher(*guard, i);\n\n                // Search for a suitable place to put it\n                //\n                // SAFETY: Caller of this function ensures that the control bytes\n                // are properly initialized.\n                let new_i = guard.find_insert_slot(hash).index;\n\n                // Probing works by scanning through all of the control\n                // bytes in groups, which may not be aligned to the group\n                // size. If both the new and old position fall within the\n                // same unaligned group, then there is no benefit in moving\n                // it and we can just continue to the next item.\n                if likely(guard.is_in_same_group(i, new_i, hash)) {\n                    guard.set_ctrl_hash(i, hash);\n                    continue 'outer;\n                }\n\n                let new_i_p = guard.bucket_ptr(new_i, size_of);\n\n                // We are moving the current item to a new position. Write\n                // our H2 to the control byte of the new position.\n                let prev_ctrl = guard.replace_ctrl_hash(new_i, hash);\n                if prev_ctrl == Tag::EMPTY {\n                    guard.set_ctrl(i, Tag::EMPTY);\n                    // If the target slot is empty, simply move the current\n                    // element into the new slot and clear the old control\n                    // byte.\n                    ptr::copy_nonoverlapping(i_p, new_i_p, size_of);\n                    continue 'outer;\n                } else {\n                    // If the target slot is occupied, swap the two elements\n                    // and then continue processing the element that we just\n                    // swapped into the old slot.\n                    debug_assert_eq!(prev_ctrl, Tag::DELETED);\n                    ptr::swap_nonoverlapping(i_p, new_i_p, size_of);\n                    continue 'inner;\n                }\n            }\n        }\n\n        guard.growth_left = bucket_mask_to_capacity(guard.bucket_mask) - guard.items;\n\n        mem::forget(guard);\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::replace_ctrl_hash': ['/// Replaces the hash in the control byte at the given index with the provided one,\n/// and possibly also replicates the new control byte at the end of the array of control\n/// bytes, returning the old control byte.\n///\n/// This function does not make any changes to the `data` parts of the table,\n/// or any changes to the `items` or `growth_left` field of the table.\n///\n/// # Safety\n///\n/// The safety rules are directly derived from the safety rules for [`RawTableInner::set_ctrl_hash`]\n/// and [`RawTableInner::ctrl`] methods. Thus, in order to uphold the safety contracts for both\n/// methods, you must observe the following rules when calling this function:\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n///\n/// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n///\n/// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n/// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`RawTableInner::set_ctrl_hash`]: RawTableInner::set_ctrl_hash\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn replace_ctrl_hash(&mut self, index: usize, hash: u64) -> Tag{\n        // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::replace_ctrl_hash`]\n        let prev_ctrl = *self.ctrl(index);\n        self.set_ctrl_hash(index, hash);\n        prev_ctrl\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::reserve_rehash_inner': ['/// Reserves or rehashes to make room for `additional` more elements.\n///\n/// This uses dynamic dispatch to reduce the amount of\n/// code generated, but it is eliminated by LLVM optimizations when inlined.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is\n/// [`undefined behavior`]:\n///\n/// * The `alloc` must be the same [`Allocator`] as the `Allocator` used\n///   to allocate this table.\n///\n/// * The `layout` must be the same [`TableLayout`] as the `TableLayout`\n///   used to allocate this table.\n///\n/// * The `drop` function (`fn(*mut u8)`) must be the actual drop function of\n///   the elements stored in the table.\n///\n/// * The [`RawTableInner`] must have properly initialized control bytes.\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[allow(clippy::inline_always)]\n#[inline(always)]\nunsafe fn reserve_rehash_inner<A>(\n        &mut self,\n        alloc: &A,\n        additional: usize,\n        hasher: &dyn Fn(&mut Self, usize) -> u64,\n        fallibility: Fallibility,\n        layout: TableLayout,\n        drop: Option<unsafe fn(*mut u8)>,\n    ) -> Result<(), TryReserveError>\n    where\n        A: Allocator,{\n        // Avoid `Option::ok_or_else` because it bloats LLVM IR.\n        let new_items = match self.items.checked_add(additional) {\n            Some(new_items) => new_items,\n            None => return Err(fallibility.capacity_overflow()),\n        };\n        let full_capacity = bucket_mask_to_capacity(self.bucket_mask);\n        if new_items <= full_capacity / 2 {\n            // Rehash in-place without re-allocating if we have plenty of spare\n            // capacity that is locked up due to DELETED entries.\n\n            // SAFETY:\n            // 1. We know for sure that `[`RawTableInner`]` has already been allocated\n            //    (since new_items <= full_capacity / 2);\n            // 2. The caller ensures that `drop` function is the actual drop function of\n            //    the elements stored in the table.\n            // 3. The caller ensures that `layout` matches the [`TableLayout`] that was\n            //    used to allocate this table.\n            // 4. The caller ensures that the control bytes of the `RawTableInner`\n            //    are already initialized.\n            self.rehash_in_place(hasher, layout.size, drop);\n            Ok(())\n        } else {\n            // Otherwise, conservatively resize to at least the next size up\n            // to avoid churning deletes into frequent rehashes.\n            //\n            // SAFETY:\n            // 1. We know for sure that `capacity >= self.items`.\n            // 2. The caller ensures that `alloc` and `layout` matches the [`Allocator`] and\n            //    [`TableLayout`] that were used to allocate this table.\n            // 3. The caller ensures that the control bytes of the `RawTableInner`\n            //    are already initialized.\n            self.resize_inner(\n                alloc,\n                usize::max(new_items, full_capacity + 1),\n                hasher,\n                fallibility,\n                layout,\n            )\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::resize_inner': ["/// Allocates a new table of a different size and moves the contents of the\n/// current table into it.\n///\n/// This uses dynamic dispatch to reduce the amount of\n/// code generated, but it is eliminated by LLVM optimizations when inlined.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is\n/// [`undefined behavior`]:\n///\n/// * The `alloc` must be the same [`Allocator`] as the `Allocator` used\n///   to allocate this table;\n///\n/// * The `layout` must be the same [`TableLayout`] as the `TableLayout`\n///   used to allocate this table;\n///\n/// * The [`RawTableInner`] must have properly initialized control bytes.\n///\n/// The caller of this function must ensure that `capacity >= self.items`\n/// otherwise:\n///\n/// * If `self.items != 0`, calling of this function with `capacity == 0`\n///   results in [`undefined behavior`].\n///\n/// * If `capacity_to_buckets(capacity) < Group::WIDTH` and\n///   `self.items > capacity_to_buckets(capacity)` calling this function\n///   results in [`undefined behavior`].\n///\n/// * If `capacity_to_buckets(capacity) >= Group::WIDTH` and\n///   `self.items > capacity_to_buckets(capacity)` calling this function\n///   are never return (will go into an infinite loop).\n///\n/// Note: It is recommended (but not required) that the new table's `capacity`\n/// be greater than or equal to `self.items`. In case if `capacity <= self.items`\n/// this function can never return. See [`RawTableInner::find_insert_slot`] for\n/// more information.\n///\n/// [`RawTableInner::find_insert_slot`]: RawTableInner::find_insert_slot\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[allow(clippy::inline_always)]\n#[inline(always)]\nunsafe fn resize_inner<A>(\n        &mut self,\n        alloc: &A,\n        capacity: usize,\n        hasher: &dyn Fn(&mut Self, usize) -> u64,\n        fallibility: Fallibility,\n        layout: TableLayout,\n    ) -> Result<(), TryReserveError>\n    where\n        A: Allocator,{\n        // SAFETY: We know for sure that `alloc` and `layout` matches the [`Allocator`] and [`TableLayout`]\n        // that were used to allocate this table.\n        let mut new_table = self.prepare_resize(alloc, layout, capacity, fallibility)?;\n\n        // SAFETY: We know for sure that RawTableInner will outlive the\n        // returned `FullBucketsIndices` iterator, and the caller of this\n        // function ensures that the control bytes are properly initialized.\n        for full_byte_index in self.full_buckets_indices() {\n            // This may panic.\n            let hash = hasher(self, full_byte_index);\n\n            // SAFETY:\n            // We can use a simpler version of insert() here since:\n            // 1. There are no DELETED entries.\n            // 2. We know there is enough space in the table.\n            // 3. All elements are unique.\n            // 4. The caller of this function guarantees that `capacity > 0`\n            //    so `new_table` must already have some allocated memory.\n            // 5. We set `growth_left` and `items` fields of the new table\n            //    after the loop.\n            // 6. We insert into the table, at the returned index, the data\n            //    matching the given hash immediately after calling this function.\n            let (new_index, _) = new_table.prepare_insert_slot(hash);\n\n            // SAFETY:\n            //\n            // * `src` is valid for reads of `layout.size` bytes, since the\n            //   table is alive and the `full_byte_index` is guaranteed to be\n            //   within bounds (see `FullBucketsIndices::next_impl`);\n            //\n            // * `dst` is valid for writes of `layout.size` bytes, since the\n            //   caller ensures that `table_layout` matches the [`TableLayout`]\n            //   that was used to allocate old table and we have the `new_index`\n            //   returned by `prepare_insert_slot`.\n            //\n            // * Both `src` and `dst` are properly aligned.\n            //\n            // * Both `src` and `dst` point to different region of memory.\n            ptr::copy_nonoverlapping(\n                self.bucket_ptr(full_byte_index, layout.size),\n                new_table.bucket_ptr(new_index, layout.size),\n                layout.size,\n            );\n        }\n\n        // The hash function didn't panic, so we can safely set the\n        // `growth_left` and `items` fields of the new table.\n        new_table.growth_left -= self.items;\n        new_table.items = self.items;\n\n        // We successfully copied all elements without panicking. Now replace\n        // self with the new table. The old table will have its memory freed but\n        // the items will not be dropped (since they have been moved into the\n        // new table).\n        // SAFETY: The caller ensures that `table_layout` matches the [`TableLayout`]\n        // that was used to allocate this table.\n        mem::swap(self, &mut new_table);\n\n        Ok(())\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::set_ctrl': ['/// Sets a control byte, and possibly also the replicated control byte at\n/// the end of the array.\n///\n/// This function does not make any changes to the `data` parts of the table,\n/// or any changes to the `items` or `growth_left` field of the table.\n///\n/// # Safety\n///\n/// You must observe the following safety rules when calling this function:\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n///\n/// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n///\n/// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n/// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn set_ctrl(&mut self, index: usize, ctrl: Tag){\n        // Replicate the first Group::WIDTH control bytes at the end of\n        // the array without using a branch. If the tables smaller than\n        // the group width (self.buckets() < Group::WIDTH),\n        // `index2 = Group::WIDTH + index`, otherwise `index2` is:\n        //\n        // - If index >= Group::WIDTH then index == index2.\n        // - Otherwise index2 == self.bucket_mask + 1 + index.\n        //\n        // The very last replicated control byte is never actually read because\n        // we mask the initial index for unaligned loads, but we write it\n        // anyways because it makes the set_ctrl implementation simpler.\n        //\n        // If there are fewer buckets than Group::WIDTH then this code will\n        // replicate the buckets at the end of the trailing group. For example\n        // with 2 buckets and a group size of 4, the control bytes will look\n        // like this:\n        //\n        //     Real    |             Replicated\n        // ---------------------------------------------\n        // | [A] | [B] | [Tag::EMPTY] | [EMPTY] | [A] | [B] |\n        // ---------------------------------------------\n\n        // This is the same as `(index.wrapping_sub(Group::WIDTH)) % self.buckets() + Group::WIDTH`\n        // because the number of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n        let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;\n\n        // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::set_ctrl`]\n        *self.ctrl(index) = ctrl;\n        *self.ctrl(index2) = ctrl;\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::set_ctrl_hash': ['/// Sets a control byte to the hash, and possibly also the replicated control byte at\n/// the end of the array.\n///\n/// This function does not make any changes to the `data` parts of the table,\n/// or any changes to the `items` or `growth_left` field of the table.\n///\n/// # Safety\n///\n/// The safety rules are directly derived from the safety rules for [`RawTableInner::set_ctrl`]\n/// method. Thus, in order to uphold the safety contracts for the method, you must observe the\n/// following rules when calling this function:\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n///\n/// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n///\n/// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n/// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`RawTableInner::set_ctrl`]: RawTableInner::set_ctrl\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n#[inline]\nunsafe fn set_ctrl_hash(&mut self, index: usize, hash: u64){\n        // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::set_ctrl_hash`]\n        self.set_ctrl(index, Tag::full(hash));\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::RawTableInner::with_capacity': ['/// Allocates a new [`RawTableInner`] with at least enough capacity for inserting\n/// the given number of elements without reallocating.\n///\n/// Panics if the new capacity exceeds [`isize::MAX`] bytes and [`abort`] the program\n/// in case of allocation error. Use [`fallible_with_capacity`] instead if you want to\n/// handle memory allocation failure.\n///\n/// All the control bytes are initialized with the [`Tag::EMPTY`] bytes.\n///\n/// [`fallible_with_capacity`]: RawTableInner::fallible_with_capacity\n/// [`abort`]: https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html\nfn with_capacity<A>(alloc: &A, table_layout: TableLayout, capacity: usize) -> Self\n    where\n        A: Allocator,{\n        // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.\n        match Self::fallible_with_capacity(alloc, table_layout, capacity, Fallibility::Infallible) {\n            Ok(table_inner) => table_inner,\n            // SAFETY: All allocation errors will be caught inside `RawTableInner::new_uninitialized`.\n            Err(_) => unsafe { hint::unreachable_unchecked() },\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::SizedTypeProperties': ['trait SizedTypeProperties: Sized {\n    const IS_ZERO_SIZED: bool = mem::size_of::<Self>() == 0;\n    const NEEDS_DROP: bool = mem::needs_drop::<Self>();\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::TableLayout': ['/// Helper which allows the max calculation for `ctrl_align` to be statically computed for each `T`\n/// while keeping the rest of `calculate_layout_for` independent of `T`\nstruct TableLayout {\n    size: usize,\n    ctrl_align: usize,\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::TableLayout::calculate_layout_for': ["#[inline]\nfn calculate_layout_for(self, buckets: usize) -> Option<(Layout, usize)>{\n        debug_assert!(buckets.is_power_of_two());\n\n        let TableLayout { size, ctrl_align } = self;\n        // Manual layout calculation since Layout methods are not yet stable.\n        let ctrl_offset =\n            size.checked_mul(buckets)?.checked_add(ctrl_align - 1)? & !(ctrl_align - 1);\n        let len = ctrl_offset.checked_add(buckets + Group::WIDTH)?;\n\n        // We need an additional check to ensure that the allocation doesn't\n        // exceed `isize::MAX` (https://github.com/rust-lang/rust/pull/95295).\n        if len > isize::MAX as usize - (ctrl_align - 1) {\n            return None;\n        }\n\n        Some((\n            unsafe { Layout::from_size_align_unchecked(len, ctrl_align) },\n            ctrl_offset,\n        ))\n    }", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::TableLayout::new': ['#[inline]\nconst fn new<T>() -> Self{\n        let layout = Layout::new::<T>();\n        Self {\n            size: layout.size(),\n            ctrl_align: if layout.align() > Group::WIDTH {\n                layout.align()\n            } else {\n                Group::WIDTH\n            },\n        }\n    }', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::alloc::inner::do_alloc': ['#[allow(clippy::map_err_ignore)]\npub(crate) fn do_alloc<A: Allocator>(alloc: &A, layout: Layout) -> Result<NonNull<u8>, ()>{\n        match alloc.allocate(layout) {\n            Ok(ptr) => Ok(ptr.cast()),\n            Err(_) => Err(()),\n        }\n    }', 'Real(LocalPath("src/raw/alloc.rs"))'], 'raw::bucket_mask_to_capacity': ['/// Returns the maximum effective capacity for the given bucket mask, taking\n/// the maximum load factor into account.\n#[inline]\nfn bucket_mask_to_capacity(bucket_mask: usize) -> usize{\n    if bucket_mask < 8 {\n        // For tables with 1/2/4/8 buckets, we always reserve one empty slot.\n        // Keep in mind that the bucket mask is one less than the bucket count.\n        bucket_mask\n    } else {\n        // For larger tables we reserve 12.5% of the slots as empty.\n        ((bucket_mask + 1) / 8) * 7\n    }\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::capacity_to_buckets': ["/// Returns the number of buckets needed to hold the given number of items,\n/// taking the maximum load factor into account.\n///\n/// Returns `None` if an overflow occurs.\ninline\nfn capacity_to_buckets(cap: usize, table_layout: TableLayout) -> Option<usize>{\n    debug_assert_ne!(cap, 0);\n\n    // For small tables we require at least 1 empty bucket so that lookups are\n    // guaranteed to terminate if an element doesn't exist in the table.\n    if cap < 15 {\n        // Consider a small TableLayout like { size: 1, ctrl_align: 16 } on a\n        // platform with Group::WIDTH of 16 (like x86_64 with SSE2). For small\n        // bucket sizes, this ends up wasting quite a few bytes just to pad to\n        // the relatively larger ctrl_align:\n        //\n        // | capacity | buckets | bytes allocated | bytes per item |\n        // | -------- | ------- | --------------- | -------------- |\n        // |        3 |       4 |              36 | (Yikes!)  12.0 |\n        // |        7 |       8 |              40 | (Poor)     5.7 |\n        // |       14 |      16 |              48 |            3.4 |\n        // |       28 |      32 |              80 |            3.3 |\n        //\n        // In general, buckets * table_layout.size >= table_layout.ctrl_align\n        // must be true to avoid these edges. This is implemented by adjusting\n        // the minimum capacity upwards for small items. This code only needs\n        // to handle ctrl_align which are less than or equal to Group::WIDTH,\n        // because valid layout sizes are always a multiple of the alignment,\n        // so anything with alignment over the Group::WIDTH won't hit this edge\n        // case.\n\n        // This is brittle, e.g. if we ever add 32 byte groups, it will select\n        // 3 regardless of the table_layout.size.\n        let min_cap = match (Group::WIDTH, table_layout.size) {\n            (16, 0..=1) => 14,\n            (16, 2..=3) => 7,\n            (8, 0..=1) => 7,\n            _ => 3,\n        };\n        let cap = min_cap.max(cap);\n        // We don't bother with a table size of 2 buckets since that can only\n        // hold a single element. Instead, we skip directly to a 4 bucket table\n        // which can hold 3 elements.\n        return Some(if cap < 4 {\n            4\n        } else if cap < 8 {\n            8\n        } else {\n            16\n        });\n    }\n\n    // Otherwise require 1/8 buckets to be empty (87.5% load)\n    //\n    // Be careful when modifying this, calculate_layout relies on the\n    // overflow check here.\n    let adjusted_cap = cap.checked_mul(8)? / 7;\n\n    // Any overflows will have been caught by the checked_mul. Also, any\n    // rounding errors from the division above will be cleaned up by\n    // next_power_of_two (which can't overflow because of the previous division).\n    Some(adjusted_cap.next_power_of_two())\n}", 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::h1': ['/// Primary hash function, used to select the initial bucket to probe from.\n#[inline]\n#[allow(clippy::cast_possible_truncation)]\nfn h1(hash: u64) -> usize{\n    // On 32-bit platforms we simply ignore the higher hash bits.\n    hash as usize\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw::offset_from': ['#[inline]\nunsafe fn offset_from<T>(to: *const T, from: *const T) -> usize{\n    to.offset_from(from) as usize\n}', 'Real(LocalPath("src/raw/mod.rs"))'], 'raw_entry::<impl map::HashMap<K, V, S, A>>::raw_entry': ['/// Creates a raw immutable entry builder for the `HashMap`.\n///\n/// Raw entries provide the lowest level of control for searching and\n/// manipulating a map. They must be manually initialized with a hash and\n/// then manually searched.\n///\n/// This is useful for\n/// * Hash memoization\n/// * Using a search key that doesn\'t work with the Borrow trait\n/// * Using custom comparison logic without newtype wrappers\n///\n/// Unless you are in such a situation, higher-level and more foolproof APIs like\n/// `get` should be preferred.\n///\n/// Immutable raw entries have very limited use; you might instead want `raw_entry_mut`.\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::HashMap;\n///\n/// let mut map = HashMap::new();\n/// map.extend([("a", 100), ("b", 200), ("c", 300)]);\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// for k in ["a", "b", "c", "d", "e", "f"] {\n///     let hash = compute_hash(map.hasher(), k);\n///     let v = map.get(&k).cloned();\n///     let kv = v.as_ref().map(|v| (&k, v));\n///\n///     println!("Key: {} and value: {:?}", k, v);\n///\n///     assert_eq!(map.raw_entry().from_key(&k), kv);\n///     assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n///     assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n/// }\n/// ```\ninline\npub fn raw_entry(&self) -> RawEntryBuilder<\'_, K, V, S, A>{\n        RawEntryBuilder { map: self }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], 'raw_entry::<impl map::HashMap<K, V, S, A>>::raw_entry_mut': ['/// Creates a raw entry builder for the `HashMap`.\n///\n/// Raw entries provide the lowest level of control for searching and\n/// manipulating a map. They must be manually initialized with a hash and\n/// then manually searched. After this, insertions into a vacant entry\n/// still require an owned key to be provided.\n///\n/// Raw entries are useful for such exotic situations as:\n///\n/// * Hash memoization\n/// * Deferring the creation of an owned key until it is known to be required\n/// * Using a search key that doesn\'t work with the Borrow trait\n/// * Using custom comparison logic without newtype wrappers\n///\n/// Because raw entries provide much more low-level control, it\'s much easier\n/// to put the `HashMap` into an inconsistent state which, while memory-safe,\n/// will cause the map to produce seemingly random results. Higher-level and\n/// more foolproof APIs like `entry` should be preferred when possible.\n///\n/// In particular, the hash used to initialized the raw entry must still be\n/// consistent with the hash of the key that is ultimately stored in the entry.\n/// This is because implementations of `HashMap` may need to recompute hashes\n/// when resizing, at which point only the keys are available.\n///\n/// Raw entries give mutable access to the keys. This must not be used\n/// to modify how the key would compare or hash, as the map will not re-evaluate\n/// where the key should go, meaning the keys may become "lost" if their\n/// location does not reflect their state. For instance, if you change a key\n/// so that the map now contains keys which compare equal, search may start\n/// acting erratically, with two keys randomly masking each other. Implementations\n/// are free to assume this doesn\'t happen (within the limits of memory-safety).\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map = HashMap::new();\n/// map.extend([("a", 100), ("b", 200), ("c", 300)]);\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// // Existing key (insert and update)\n/// match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => unreachable!(),\n///     RawEntryMut::Occupied(mut view) => {\n///         assert_eq!(view.get(), &100);\n///         let v = view.get_mut();\n///         let new_v = (*v) * 10;\n///         *v = new_v;\n///         assert_eq!(view.insert(1111), 1000);\n///     }\n/// }\n///\n/// assert_eq!(map[&"a"], 1111);\n/// assert_eq!(map.len(), 3);\n///\n/// // Existing key (take)\n/// let hash = compute_hash(map.hasher(), &"c");\n/// match map.raw_entry_mut().from_key_hashed_nocheck(hash, &"c") {\n///     RawEntryMut::Vacant(_) => unreachable!(),\n///     RawEntryMut::Occupied(view) => {\n///         assert_eq!(view.remove_entry(), ("c", 300));\n///     }\n/// }\n/// assert_eq!(map.raw_entry().from_key(&"c"), None);\n/// assert_eq!(map.len(), 2);\n///\n/// // Nonexistent key (insert and update)\n/// let key = "d";\n/// let hash = compute_hash(map.hasher(), &key);\n/// match map.raw_entry_mut().from_hash(hash, |q| *q == key) {\n///     RawEntryMut::Occupied(_) => unreachable!(),\n///     RawEntryMut::Vacant(view) => {\n///         let (k, value) = view.insert("d", 4000);\n///         assert_eq!((*k, *value), ("d", 4000));\n///         *value = 40000;\n///     }\n/// }\n/// assert_eq!(map[&"d"], 40000);\n/// assert_eq!(map.len(), 3);\n///\n/// match map.raw_entry_mut().from_hash(hash, |q| *q == key) {\n///     RawEntryMut::Vacant(_) => unreachable!(),\n///     RawEntryMut::Occupied(view) => {\n///         assert_eq!(view.remove_entry(), ("d", 40000));\n///     }\n/// }\n/// assert_eq!(map.get(&"d"), None);\n/// assert_eq!(map.len(), 2);\n/// ```\ninline\npub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<\'_, K, V, S, A>{\n        RawEntryBuilderMut { map: self }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], 'raw_entry::RawEntryBuilder': ['/// A builder for computing where in a [`HashMap`] a key-value pair would be stored.\n///\n/// See the [`HashMap::raw_entry`] docs for usage examples.\n///\n/// [`HashMap::raw_entry`]: struct.HashMap.html#method.raw_entry\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryBuilder};\n/// use core::hash::{BuildHasher, Hash};\n///\n/// let mut map = HashMap::new();\n/// map.extend([(1, 10), (2, 20), (3, 30)]);\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// for k in 0..6 {\n///     let hash = compute_hash(map.hasher(), &k);\n///     let v = map.get(&k).cloned();\n///     let kv = v.as_ref().map(|v| (&k, v));\n///\n///     println!("Key: {} and value: {:?}", k, v);\n///     let builder: RawEntryBuilder<_, _, _> = map.raw_entry();\n///     assert_eq!(builder.from_key(&k), kv);\n///     assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n///     assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n/// }\n/// ```\npub struct RawEntryBuilder<\'a, K, V, S, A: Allocator = Global> {\n    map: &\'a HashMap<K, V, S, A>,\n}', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_hash": ['/// Access an immutable entry by hash and matching function.\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::HashMap;\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// let map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n/// let key = "a";\n/// let hash = compute_hash(map.hasher(), &key);\n/// assert_eq!(map.raw_entry().from_hash(hash, |k| k == &key), Some((&"a", &100)));\n/// ```\ninline\n#[allow(clippy::wrong_self_convention)]\npub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&\'a K, &\'a V)>\n    where\n        F: FnMut(&K) -> bool,{\n        self.search(hash, is_match)\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_key": ['/// Access an immutable entry by key.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n/// let key = "a";\n/// assert_eq!(map.raw_entry().from_key(&key), Some((&"a", &100)));\n/// ```\ninline\n#[allow(clippy::wrong_self_convention)]\npub fn from_key<Q>(self, k: &Q) -> Option<(&\'a K, &\'a V)>\n    where\n        S: BuildHasher,\n        Q: Hash + Equivalent<K> + ?Sized,{\n        let hash = make_hash::<Q, S>(&self.map.hash_builder, k);\n        self.from_key_hashed_nocheck(hash, k)\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_key_hashed_nocheck": ['/// Access an immutable entry by a key and its hash.\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::HashMap;\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// let map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n/// let key = "a";\n/// let hash = compute_hash(map.hasher(), &key);\n/// assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &key), Some((&"a", &100)));\n/// ```\ninline\n#[allow(clippy::wrong_self_convention)]\npub fn from_key_hashed_nocheck<Q>(self, hash: u64, k: &Q) -> Option<(&\'a K, &\'a V)>\n    where\n        Q: Equivalent<K> + ?Sized,{\n        self.from_hash(hash, equivalent(k))\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::search": ["inline\nfn search<F>(self, hash: u64, mut is_match: F) -> Option<(&'a K, &'a V)>\n    where\n        F: FnMut(&K) -> bool,{\n        match self.map.table.get(hash, |(k, _)| is_match(k)) {\n            Some((key, value)) => Some((key, value)),\n            None => None,\n        }\n    }", 'Real(LocalPath("src/raw_entry.rs"))'], 'raw_entry::RawEntryBuilderMut': ['/// A builder for computing where in a [`HashMap`] a key-value pair would be stored.\n///\n/// See the [`HashMap::raw_entry_mut`] docs for usage examples.\n///\n/// [`HashMap::raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{RawEntryBuilderMut, RawEntryMut::Vacant, RawEntryMut::Occupied};\n/// use hashbrown::HashMap;\n/// use core::hash::{BuildHasher, Hash};\n///\n/// let mut map = HashMap::new();\n/// map.extend([(1, 11), (2, 12), (3, 13), (4, 14), (5, 15), (6, 16)]);\n/// assert_eq!(map.len(), 6);\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// let builder: RawEntryBuilderMut<_, _, _> = map.raw_entry_mut();\n///\n/// // Existing key\n/// match builder.from_key(&6) {\n///     Vacant(_) => unreachable!(),\n///     Occupied(view) => assert_eq!(view.get(), &16),\n/// }\n///\n/// for key in 0..12 {\n///     let hash = compute_hash(map.hasher(), &key);\n///     let value = map.get(&key).cloned();\n///     let key_value = value.as_ref().map(|v| (&key, v));\n///\n///     println!("Key: {} and value: {:?}", key, value);\n///\n///     match map.raw_entry_mut().from_key(&key) {\n///         Occupied(mut o) => assert_eq!(Some(o.get_key_value()), key_value),\n///         Vacant(_) => assert_eq!(value, None),\n///     }\n///     match map.raw_entry_mut().from_key_hashed_nocheck(hash, &key) {\n///         Occupied(mut o) => assert_eq!(Some(o.get_key_value()), key_value),\n///         Vacant(_) => assert_eq!(value, None),\n///     }\n///     match map.raw_entry_mut().from_hash(hash, |q| *q == key) {\n///         Occupied(mut o) => assert_eq!(Some(o.get_key_value()), key_value),\n///         Vacant(_) => assert_eq!(value, None),\n///     }\n/// }\n///\n/// assert_eq!(map.len(), 6);\n/// ```\npub struct RawEntryBuilderMut<\'a, K, V, S, A: Allocator = Global> {\n    map: &\'a mut HashMap<K, V, S, A>,\n}', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_hash": ['/// Creates a `RawEntryMut` from the given hash and matching function.\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// let key = "a";\n/// let hash = compute_hash(map.hasher(), &key);\n/// let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_hash(hash, |k| k == &key);\n/// entry.insert(key, 100);\n/// assert_eq!(map[&"a"], 100);\n/// ```\ninline\n#[allow(clippy::wrong_self_convention)]\npub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<\'a, K, V, S, A>\n    where\n        for<\'b> F: FnMut(&\'b K) -> bool,{\n        self.search(hash, is_match)\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_key": ['/// Creates a `RawEntryMut` from the given key.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// let key = "a";\n/// let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_key(&key);\n/// entry.insert(key, 100);\n/// assert_eq!(map[&"a"], 100);\n/// ```\ninline\n#[allow(clippy::wrong_self_convention)]\npub fn from_key<Q>(self, k: &Q) -> RawEntryMut<\'a, K, V, S, A>\n    where\n        S: BuildHasher,\n        Q: Hash + Equivalent<K> + ?Sized,{\n        let hash = make_hash::<Q, S>(&self.map.hash_builder, k);\n        self.from_key_hashed_nocheck(hash, k)\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_key_hashed_nocheck": ['/// Creates a `RawEntryMut` from the given key and its hash.\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// let key = "a";\n/// let hash = compute_hash(map.hasher(), &key);\n/// let entry: RawEntryMut<&str, u32, _> = map.raw_entry_mut().from_key_hashed_nocheck(hash, &key);\n/// entry.insert(key, 100);\n/// assert_eq!(map[&"a"], 100);\n/// ```\n#[inline]\n#[allow(clippy::wrong_self_convention)]\npub fn from_key_hashed_nocheck<Q>(self, hash: u64, k: &Q) -> RawEntryMut<\'a, K, V, S, A>\n    where\n        Q: Equivalent<K> + ?Sized,{\n        self.from_hash(hash, equivalent(k))\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::search": ["inline\nfn search<F>(self, hash: u64, mut is_match: F) -> RawEntryMut<'a, K, V, S, A>\n    where\n        for<'b> F: FnMut(&'b K) -> bool,{\n        match self.map.table.find(hash, |(k, _)| is_match(k)) {\n            Some(elem) => RawEntryMut::Occupied(RawOccupiedEntryMut {\n                elem,\n                table: &mut self.map.table,\n                hash_builder: &self.map.hash_builder,\n            }),\n            None => RawEntryMut::Vacant(RawVacantEntryMut {\n                table: &mut self.map.table,\n                hash_builder: &self.map.hash_builder,\n            }),\n        }\n    }", 'Real(LocalPath("src/raw_entry.rs"))'], 'raw_entry::RawEntryMut': ['/// A view into a single entry in a map, which may either be vacant or occupied.\n///\n/// This is a lower-level version of [`Entry`].\n///\n/// This `enum` is constructed through the [`raw_entry_mut`] method on [`HashMap`],\n/// then calling one of the methods of that [`RawEntryBuilderMut`].\n///\n/// [`HashMap`]: struct.HashMap.html\n/// [`Entry`]: enum.Entry.html\n/// [`raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n/// [`RawEntryBuilderMut`]: struct.RawEntryBuilderMut.html\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::hash_map::{HashMap, RawEntryMut, RawOccupiedEntryMut};\n///\n/// let mut map = HashMap::new();\n/// map.extend([(\'a\', 1), (\'b\', 2), (\'c\', 3)]);\n/// assert_eq!(map.len(), 3);\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// // Existing key (insert)\n/// let raw: RawEntryMut<_, _, _> = map.raw_entry_mut().from_key(&\'a\');\n/// let _raw_o: RawOccupiedEntryMut<_, _, _> = raw.insert(\'a\', 10);\n/// assert_eq!(map.len(), 3);\n///\n/// // Nonexistent key (insert)\n/// map.raw_entry_mut().from_key(&\'d\').insert(\'d\', 40);\n/// assert_eq!(map.len(), 4);\n///\n/// // Existing key (or_insert)\n/// let hash = compute_hash(map.hasher(), &\'b\');\n/// let kv = map\n///     .raw_entry_mut()\n///     .from_key_hashed_nocheck(hash, &\'b\')\n///     .or_insert(\'b\', 20);\n/// assert_eq!(kv, (&mut \'b\', &mut 2));\n/// *kv.1 = 20;\n/// assert_eq!(map.len(), 4);\n///\n/// // Nonexistent key (or_insert)\n/// let hash = compute_hash(map.hasher(), &\'e\');\n/// let kv = map\n///     .raw_entry_mut()\n///     .from_key_hashed_nocheck(hash, &\'e\')\n///     .or_insert(\'e\', 50);\n/// assert_eq!(kv, (&mut \'e\', &mut 50));\n/// assert_eq!(map.len(), 5);\n///\n/// // Existing key (or_insert_with)\n/// let hash = compute_hash(map.hasher(), &\'c\');\n/// let kv = map\n///     .raw_entry_mut()\n///     .from_hash(hash, |q| q == &\'c\')\n///     .or_insert_with(|| (\'c\', 30));\n/// assert_eq!(kv, (&mut \'c\', &mut 3));\n/// *kv.1 = 30;\n/// assert_eq!(map.len(), 5);\n///\n/// // Nonexistent key (or_insert_with)\n/// let hash = compute_hash(map.hasher(), &\'f\');\n/// let kv = map\n///     .raw_entry_mut()\n///     .from_hash(hash, |q| q == &\'f\')\n///     .or_insert_with(|| (\'f\', 60));\n/// assert_eq!(kv, (&mut \'f\', &mut 60));\n/// assert_eq!(map.len(), 6);\n///\n/// println!("Our HashMap: {:?}", map);\n///\n/// let mut vec: Vec<_> = map.iter().map(|(&k, &v)| (k, v)).collect();\n/// // The `Iter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [(\'a\', 10), (\'b\', 20), (\'c\', 30), (\'d\', 40), (\'e\', 50), (\'f\', 60)]);\n/// ```\npub enum RawEntryMut<\'a, K, V, S, A: Allocator = Global> {\n    /// An occupied entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::{hash_map::RawEntryMut, HashMap};\n    /// let mut map: HashMap<_, _> = [("a", 100), ("b", 200)].into();\n    ///\n    /// match map.raw_entry_mut().from_key(&"a") {\n    ///     RawEntryMut::Vacant(_) => unreachable!(),\n    ///     RawEntryMut::Occupied(_) => { }\n    /// }\n    /// ```\n    Occupied(RawOccupiedEntryMut<\'a, K, V, S, A>),\n    /// A vacant entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::{hash_map::RawEntryMut, HashMap};\n    /// let mut map: HashMap<&str, i32> = HashMap::new();\n    ///\n    /// match map.raw_entry_mut().from_key("a") {\n    ///     RawEntryMut::Occupied(_) => unreachable!(),\n    ///     RawEntryMut::Vacant(_) => { }\n    /// }\n    /// ```\n    Vacant(RawVacantEntryMut<\'a, K, V, S, A>),\n}', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryMut::<'a, K, V, S, A>::and_modify": ['/// Provides in-place mutable access to an occupied entry before any\n/// potential inserts into the map.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// map.raw_entry_mut()\n///    .from_key("poneyland")\n///    .and_modify(|_k, v| { *v += 1 })\n///    .or_insert("poneyland", 42);\n/// assert_eq!(map["poneyland"], 42);\n///\n/// map.raw_entry_mut()\n///    .from_key("poneyland")\n///    .and_modify(|_k, v| { *v += 1 })\n///    .or_insert("poneyland", 0);\n/// assert_eq!(map["poneyland"], 43);\n/// ```\ninline\npub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut K, &mut V),{\n        match self {\n            RawEntryMut::Occupied(mut entry) => {\n                {\n                    let (k, v) = entry.get_key_value_mut();\n                    f(k, v);\n                }\n                RawEntryMut::Occupied(entry)\n            }\n            RawEntryMut::Vacant(entry) => RawEntryMut::Vacant(entry),\n        }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryMut::<'a, K, V, S, A>::and_replace_entry_with": ['/// Provides shared access to the key and owned access to the value of\n/// an occupied entry and allows to replace or remove it based on the\n/// value of the returned option.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n/// use hashbrown::hash_map::RawEntryMut;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// let entry = map\n///     .raw_entry_mut()\n///     .from_key("poneyland")\n///     .and_replace_entry_with(|_k, _v| panic!());\n///\n/// match entry {\n///     RawEntryMut::Vacant(_) => {},\n///     RawEntryMut::Occupied(_) => panic!(),\n/// }\n///\n/// map.insert("poneyland", 42);\n///\n/// let entry = map\n///     .raw_entry_mut()\n///     .from_key("poneyland")\n///     .and_replace_entry_with(|k, v| {\n///         assert_eq!(k, &"poneyland");\n///         assert_eq!(v, 42);\n///         Some(v + 1)\n///     });\n///\n/// match entry {\n///     RawEntryMut::Occupied(e) => {\n///         assert_eq!(e.key(), &"poneyland");\n///         assert_eq!(e.get(), &43);\n///     },\n///     RawEntryMut::Vacant(_) => panic!(),\n/// }\n///\n/// assert_eq!(map["poneyland"], 43);\n///\n/// let entry = map\n///     .raw_entry_mut()\n///     .from_key("poneyland")\n///     .and_replace_entry_with(|_k, _v| None);\n///\n/// match entry {\n///     RawEntryMut::Vacant(_) => {},\n///     RawEntryMut::Occupied(_) => panic!(),\n/// }\n///\n/// assert!(!map.contains_key("poneyland"));\n/// ```\ninline\npub fn and_replace_entry_with<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&K, V) -> Option<V>,{\n        match self {\n            RawEntryMut::Occupied(entry) => entry.replace_entry_with(f),\n            RawEntryMut::Vacant(_) => self,\n        }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryMut::<'a, K, V, S, A>::insert": ['/// Sets the value of the entry, and returns a `RawOccupiedEntryMut`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// let entry = map.raw_entry_mut().from_key("horseyland").insert("horseyland", 37);\n///\n/// assert_eq!(entry.remove_entry(), ("horseyland", 37));\n/// ```\ninline\npub fn insert(self, key: K, value: V) -> RawOccupiedEntryMut<\'a, K, V, S, A>\n    where\n        K: Hash,\n        S: BuildHasher,{\n        match self {\n            RawEntryMut::Occupied(mut entry) => {\n                entry.insert(value);\n                entry\n            }\n            RawEntryMut::Vacant(entry) => entry.insert_entry(key, value),\n        }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryMut::<'a, K, V, S, A>::or_insert": ['/// Ensures a value is in the entry by inserting the default if empty, and returns\n/// mutable references to the key and value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n///\n/// map.raw_entry_mut().from_key("poneyland").or_insert("poneyland", 3);\n/// assert_eq!(map["poneyland"], 3);\n///\n/// *map.raw_entry_mut().from_key("poneyland").or_insert("poneyland", 10).1 *= 2;\n/// assert_eq!(map["poneyland"], 6);\n/// ```\ninline\npub fn or_insert(self, default_key: K, default_val: V) -> (&\'a mut K, &\'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,{\n        match self {\n            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n            RawEntryMut::Vacant(entry) => entry.insert(default_key, default_val),\n        }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawEntryMut::<'a, K, V, S, A>::or_insert_with": ['/// Ensures a value is in the entry by inserting the result of the default function if empty,\n/// and returns mutable references to the key and value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<&str, String> = HashMap::new();\n///\n/// map.raw_entry_mut().from_key("poneyland").or_insert_with(|| {\n///     ("poneyland", "hoho".to_string())\n/// });\n///\n/// assert_eq!(map["poneyland"], "hoho".to_string());\n/// ```\ninline\npub fn or_insert_with<F>(self, default: F) -> (&\'a mut K, &\'a mut V)\n    where\n        F: FnOnce() -> (K, V),\n        K: Hash,\n        S: BuildHasher,{\n        match self {\n            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n            RawEntryMut::Vacant(entry) => {\n                let (k, v) = default();\n                entry.insert(k, v)\n            }\n        }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], 'raw_entry::RawOccupiedEntryMut': ['/// A view into an occupied entry in a `HashMap`.\n/// It is part of the [`RawEntryMut`] enum.\n///\n/// [`RawEntryMut`]: enum.RawEntryMut.html\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::hash_map::{HashMap, RawEntryMut, RawOccupiedEntryMut};\n///\n/// let mut map = HashMap::new();\n/// map.extend([("a", 10), ("b", 20), ("c", 30)]);\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// let _raw_o: RawOccupiedEntryMut<_, _, _> = map.raw_entry_mut().from_key(&"a").insert("a", 100);\n/// assert_eq!(map.len(), 3);\n///\n/// // Existing key (insert and update)\n/// match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => unreachable!(),\n///     RawEntryMut::Occupied(mut view) => {\n///         assert_eq!(view.get(), &100);\n///         let v = view.get_mut();\n///         let new_v = (*v) * 10;\n///         *v = new_v;\n///         assert_eq!(view.insert(1111), 1000);\n///     }\n/// }\n///\n/// assert_eq!(map[&"a"], 1111);\n/// assert_eq!(map.len(), 3);\n///\n/// // Existing key (take)\n/// let hash = compute_hash(map.hasher(), &"c");\n/// match map.raw_entry_mut().from_key_hashed_nocheck(hash, &"c") {\n///     RawEntryMut::Vacant(_) => unreachable!(),\n///     RawEntryMut::Occupied(view) => {\n///         assert_eq!(view.remove_entry(), ("c", 30));\n///     }\n/// }\n/// assert_eq!(map.raw_entry().from_key(&"c"), None);\n/// assert_eq!(map.len(), 2);\n///\n/// let hash = compute_hash(map.hasher(), &"b");\n/// match map.raw_entry_mut().from_hash(hash, |q| *q == "b") {\n///     RawEntryMut::Vacant(_) => unreachable!(),\n///     RawEntryMut::Occupied(view) => {\n///         assert_eq!(view.remove_entry(), ("b", 20));\n///     }\n/// }\n/// assert_eq!(map.get(&"b"), None);\n/// assert_eq!(map.len(), 1);\n/// ```\npub struct RawOccupiedEntryMut<\'a, K, V, S, A: Allocator = Global> {\n    elem: Bucket<(K, V)>,\n    table: &\'a mut RawTable<(K, V), A>,\n    hash_builder: &\'a S,\n}', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get": ['/// Gets a reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n///\n/// match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(o) => assert_eq!(o.get(), &100),\n/// }\n/// ```\ninline\npub fn get(&self) -> &V{\n        unsafe { &self.elem.as_ref().1 }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_key_value": ['/// Gets a reference to the key and value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n///\n/// match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(o) => assert_eq!(o.get_key_value(), (&"a", &100)),\n/// }\n/// ```\ninline\npub fn get_key_value(&self) -> (&K, &V){\n        unsafe {\n            let (key, value) = self.elem.as_ref();\n            (key, value)\n        }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_key_value_mut": ['/// Gets a mutable reference to the key and value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n/// use std::rc::Rc;\n///\n/// let key_one = Rc::new("a");\n/// let key_two = Rc::new("a");\n///\n/// let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n/// map.insert(key_one.clone(), 10);\n///\n/// assert_eq!(map[&key_one], 10);\n/// assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n///\n/// match map.raw_entry_mut().from_key(&key_one) {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(mut o) => {\n///         let (inside_key, inside_value) = o.get_key_value_mut();\n///         *inside_key = key_two.clone();\n///         *inside_value = 100;\n///     }\n/// }\n/// assert_eq!(map[&key_two], 100);\n/// assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n/// ```\ninline\npub fn get_key_value_mut(&mut self) -> (&mut K, &mut V){\n        unsafe {\n            let &mut (ref mut key, ref mut value) = self.elem.as_mut();\n            (key, value)\n        }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_mut": ['/// Gets a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n///\n/// match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(mut o) => *o.get_mut() += 900,\n/// }\n///\n/// assert_eq!(map[&"a"], 1000);\n/// ```\ninline\npub fn get_mut(&mut self) -> &mut V{\n        unsafe { &mut self.elem.as_mut().1 }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::insert": ['/// Sets the value of the entry, and returns the entry\'s old value.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n///\n/// match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(mut o) => assert_eq!(o.insert(1000), 100),\n/// }\n///\n/// assert_eq!(map[&"a"], 1000);\n/// ```\ninline\npub fn insert(&mut self, value: V) -> V{\n        mem::replace(self.get_mut(), value)\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::insert_key": ['/// Sets the value of the entry, and returns the entry\'s old value.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n/// use std::rc::Rc;\n///\n/// let key_one = Rc::new("a");\n/// let key_two = Rc::new("a");\n///\n/// let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n/// map.insert(key_one.clone(), 10);\n///\n/// assert_eq!(map[&key_one], 10);\n/// assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n///\n/// match map.raw_entry_mut().from_key(&key_one) {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(mut o) => {\n///         let old_key = o.insert_key(key_two.clone());\n///         assert!(Rc::ptr_eq(&old_key, &key_one));\n///     }\n/// }\n/// assert_eq!(map[&key_two], 10);\n/// assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n/// ```\ninline\npub fn insert_key(&mut self, key: K) -> K{\n        mem::replace(self.key_mut(), key)\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_key": ['/// Converts the entry into a mutable reference to the key in the entry\n/// with a lifetime bound to the map itself.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n/// use std::rc::Rc;\n///\n/// let key_one = Rc::new("a");\n/// let key_two = Rc::new("a");\n///\n/// let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n/// map.insert(key_one.clone(), 10);\n///\n/// assert_eq!(map[&key_one], 10);\n/// assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n///\n/// let inside_key: &mut Rc<&str>;\n///\n/// match map.raw_entry_mut().from_key(&key_one) {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(o) => inside_key = o.into_key(),\n/// }\n/// *inside_key = key_two.clone();\n///\n/// assert_eq!(map[&key_two], 10);\n/// assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n/// ```\ninline\npub fn into_key(self) -> &\'a mut K{\n        unsafe { &mut self.elem.as_mut().0 }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_key_value": ['/// Converts the `OccupiedEntry` into a mutable reference to the key and value in the entry\n/// with a lifetime bound to the map itself.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n/// use std::rc::Rc;\n///\n/// let key_one = Rc::new("a");\n/// let key_two = Rc::new("a");\n///\n/// let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n/// map.insert(key_one.clone(), 10);\n///\n/// assert_eq!(map[&key_one], 10);\n/// assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n///\n/// let inside_key: &mut Rc<&str>;\n/// let inside_value: &mut u32;\n/// match map.raw_entry_mut().from_key(&key_one) {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(o) => {\n///         let tuple = o.into_key_value();\n///         inside_key = tuple.0;\n///         inside_value = tuple.1;\n///     }\n/// }\n/// *inside_key = key_two.clone();\n/// *inside_value = 100;\n/// assert_eq!(map[&key_two], 100);\n/// assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n/// ```\ninline\npub fn into_key_value(self) -> (&\'a mut K, &\'a mut V){\n        unsafe {\n            let &mut (ref mut key, ref mut value) = self.elem.as_mut();\n            (key, value)\n        }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_mut": ['/// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n/// with a lifetime bound to the map itself.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n///\n/// let value: &mut u32;\n///\n/// match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(o) => value = o.into_mut(),\n/// }\n/// *value += 900;\n///\n/// assert_eq!(map[&"a"], 1000);\n/// ```\ninline\npub fn into_mut(self) -> &\'a mut V{\n        unsafe { &mut self.elem.as_mut().1 }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::key": ['/// Gets a reference to the key in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n///\n/// match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(o) => assert_eq!(o.key(), &"a")\n/// }\n/// ```\ninline\npub fn key(&self) -> &K{\n        unsafe { &self.elem.as_ref().0 }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::key_mut": ['/// Gets a mutable reference to the key in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n/// use std::rc::Rc;\n///\n/// let key_one = Rc::new("a");\n/// let key_two = Rc::new("a");\n///\n/// let mut map: HashMap<Rc<&str>, u32> = HashMap::new();\n/// map.insert(key_one.clone(), 10);\n///\n/// assert_eq!(map[&key_one], 10);\n/// assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);\n///\n/// match map.raw_entry_mut().from_key(&key_one) {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(mut o) => {\n///         *o.key_mut() = key_two.clone();\n///     }\n/// }\n/// assert_eq!(map[&key_two], 10);\n/// assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);\n/// ```\ninline\npub fn key_mut(&mut self) -> &mut K{\n        unsafe { &mut self.elem.as_mut().0 }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::remove": ['/// Takes the value out of the entry, and returns it.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n///\n/// match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(o) => assert_eq!(o.remove(), 100),\n/// }\n/// assert_eq!(map.get(&"a"), None);\n/// ```\ninline\npub fn remove(self) -> V{\n        self.remove_entry().1\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::remove_entry": ['/// Take the ownership of the key and value from the map.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n///\n/// match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(o) => assert_eq!(o.remove_entry(), ("a", 100)),\n/// }\n/// assert_eq!(map.get(&"a"), None);\n/// ```\ninline\npub fn remove_entry(self) -> (K, V){\n        unsafe { self.table.remove(self.elem).0 }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::replace_entry_with": ['/// Provides shared access to the key and owned access to the value of\n/// the entry and allows to replace or remove it based on the\n/// value of the returned option.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n///\n/// let raw_entry = match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(o) => o.replace_entry_with(|k, v| {\n///         assert_eq!(k, &"a");\n///         assert_eq!(v, 100);\n///         Some(v + 900)\n///     }),\n/// };\n/// let raw_entry = match raw_entry {\n///     RawEntryMut::Vacant(_) => panic!(),\n///     RawEntryMut::Occupied(o) => o.replace_entry_with(|k, v| {\n///         assert_eq!(k, &"a");\n///         assert_eq!(v, 1000);\n///         None\n///     }),\n/// };\n/// match raw_entry {\n///     RawEntryMut::Vacant(_) => { },\n///     RawEntryMut::Occupied(_) => panic!(),\n/// };\n/// assert_eq!(map.get(&"a"), None);\n/// ```\ninline\npub fn replace_entry_with<F>(self, f: F) -> RawEntryMut<\'a, K, V, S, A>\n    where\n        F: FnOnce(&K, V) -> Option<V>,{\n        unsafe {\n            let still_occupied = self\n                .table\n                .replace_bucket_with(self.elem.clone(), |(key, value)| {\n                    f(&key, value).map(|new_value| (key, new_value))\n                });\n\n            if still_occupied {\n                RawEntryMut::Occupied(self)\n            } else {\n                RawEntryMut::Vacant(RawVacantEntryMut {\n                    table: self.table,\n                    hash_builder: self.hash_builder,\n                })\n            }\n        }\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], 'raw_entry::RawVacantEntryMut': ['/// A view into a vacant entry in a `HashMap`.\n/// It is part of the [`RawEntryMut`] enum.\n///\n/// [`RawEntryMut`]: enum.RawEntryMut.html\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::hash_map::{HashMap, RawEntryMut, RawVacantEntryMut};\n///\n/// let mut map = HashMap::<&str, i32>::new();\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// let raw_v: RawVacantEntryMut<_, _, _> = match map.raw_entry_mut().from_key(&"a") {\n///     RawEntryMut::Vacant(view) => view,\n///     RawEntryMut::Occupied(_) => unreachable!(),\n/// };\n/// raw_v.insert("a", 10);\n/// assert!(map[&"a"] == 10 && map.len() == 1);\n///\n/// // Nonexistent key (insert and update)\n/// let hash = compute_hash(map.hasher(), &"b");\n/// match map.raw_entry_mut().from_key_hashed_nocheck(hash, &"b") {\n///     RawEntryMut::Occupied(_) => unreachable!(),\n///     RawEntryMut::Vacant(view) => {\n///         let (k, value) = view.insert("b", 2);\n///         assert_eq!((*k, *value), ("b", 2));\n///         *value = 20;\n///     }\n/// }\n/// assert!(map[&"b"] == 20 && map.len() == 2);\n///\n/// let hash = compute_hash(map.hasher(), &"c");\n/// match map.raw_entry_mut().from_hash(hash, |q| *q == "c") {\n///     RawEntryMut::Occupied(_) => unreachable!(),\n///     RawEntryMut::Vacant(view) => {\n///         assert_eq!(view.insert("c", 30), (&mut "c", &mut 30));\n///     }\n/// }\n/// assert!(map[&"c"] == 30 && map.len() == 3);\n/// ```\npub struct RawVacantEntryMut<\'a, K, V, S, A: Allocator = Global> {\n    table: &\'a mut RawTable<(K, V), A>,\n    hash_builder: &\'a S,\n}', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert": ['/// Sets the value of the entry with the `VacantEntry`\'s key,\n/// and returns a mutable reference to it.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n///\n/// match map.raw_entry_mut().from_key(&"c") {\n///     RawEntryMut::Occupied(_) => panic!(),\n///     RawEntryMut::Vacant(v) => assert_eq!(v.insert("c", 300), (&mut "c", &mut 300)),\n/// }\n///\n/// assert_eq!(map[&"c"], 300);\n/// ```\ninline\npub fn insert(self, key: K, value: V) -> (&\'a mut K, &\'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,{\n        let hash = make_hash::<K, S>(self.hash_builder, &key);\n        self.insert_hashed_nocheck(hash, key, value)\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_entry": ["inline\nfn insert_entry(self, key: K, value: V) -> RawOccupiedEntryMut<'a, K, V, S, A>\n    where\n        K: Hash,\n        S: BuildHasher,{\n        let hash = make_hash::<K, S>(self.hash_builder, &key);\n        let elem = self.table.insert(\n            hash,\n            (key, value),\n            make_hasher::<_, V, S>(self.hash_builder),\n        );\n        RawOccupiedEntryMut {\n            elem,\n            table: self.table,\n            hash_builder: self.hash_builder,\n        }\n    }", 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_hashed_nocheck": ['/// Sets the value of the entry with the `VacantEntry`\'s key,\n/// and returns a mutable reference to it.\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// fn compute_hash<K: Hash + ?Sized, S: BuildHasher>(hash_builder: &S, key: &K) -> u64 {\n///     use core::hash::Hasher;\n///     let mut state = hash_builder.build_hasher();\n///     key.hash(&mut state);\n///     state.finish()\n/// }\n///\n/// let mut map: HashMap<&str, u32> = [("a", 100), ("b", 200)].into();\n/// let key = "c";\n/// let hash = compute_hash(map.hasher(), &key);\n///\n/// match map.raw_entry_mut().from_key_hashed_nocheck(hash, &key) {\n///     RawEntryMut::Occupied(_) => panic!(),\n///     RawEntryMut::Vacant(v) => assert_eq!(\n///         v.insert_hashed_nocheck(hash, key, 300),\n///         (&mut "c", &mut 300)\n///     ),\n/// }\n///\n/// assert_eq!(map[&"c"], 300);\n/// ```\ninline\n#[allow(clippy::shadow_unrelated)]\npub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&\'a mut K, &\'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,{\n        let &mut (ref mut k, ref mut v) = self.table.insert_entry(\n            hash,\n            (key, value),\n            make_hasher::<_, V, S>(self.hash_builder),\n        );\n        (k, v)\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_with_hasher": ['/// Set the value of an entry with a custom hasher function.\n///\n/// # Examples\n///\n/// ```\n/// use core::hash::{BuildHasher, Hash};\n/// use hashbrown::hash_map::{HashMap, RawEntryMut};\n///\n/// fn make_hasher<K, S>(hash_builder: &S) -> impl Fn(&K) -> u64 + \'_\n/// where\n///     K: Hash + ?Sized,\n///     S: BuildHasher,\n/// {\n///     move |key: &K| {\n///         use core::hash::Hasher;\n///         let mut state = hash_builder.build_hasher();\n///         key.hash(&mut state);\n///         state.finish()\n///     }\n/// }\n///\n/// let mut map: HashMap<&str, u32> = HashMap::new();\n/// let key = "a";\n/// let hash_builder = map.hasher().clone();\n/// let hash = make_hasher(&hash_builder)(&key);\n///\n/// match map.raw_entry_mut().from_hash(hash, |q| q == &key) {\n///     RawEntryMut::Occupied(_) => panic!(),\n///     RawEntryMut::Vacant(v) => assert_eq!(\n///         v.insert_with_hasher(hash, key, 100, make_hasher(&hash_builder)),\n///         (&mut "a", &mut 100)\n///     ),\n/// }\n/// map.extend([("b", 200), ("c", 300), ("d", 400), ("e", 500), ("f", 600)]);\n/// assert_eq!(map[&"a"], 100);\n/// ```\ninline\npub fn insert_with_hasher<H>(\n        self,\n        hash: u64,\n        key: K,\n        value: V,\n        hasher: H,\n    ) -> (&\'a mut K, &\'a mut V)\n    where\n        H: Fn(&K) -> u64,{\n        let &mut (ref mut k, ref mut v) = self\n            .table\n            .insert_entry(hash, (key, value), |x| hasher(&x.0));\n        (k, v)\n    }', 'Real(LocalPath("src/raw_entry.rs"))'], 'scopeguard::ScopeGuard': ['pub struct ScopeGuard<T, F>\nwhere\n    F: FnMut(&mut T),\n{\n    dropfn: F,\n    value: T,\n}', 'Real(LocalPath("src/scopeguard.rs"))'], 'scopeguard::ScopeGuard::<T, F>::into_inner': ["#[inline]\npub fn into_inner(guard: Self) -> T{\n        // Cannot move out of Drop-implementing types, so\n        // ptr::read the value out of a ManuallyDrop<Self>\n        // Don't use mem::forget as that might invalidate value\n        let guard = ManuallyDrop::new(guard);\n        unsafe {\n            let value = ptr::read(&guard.value);\n            // read the closure so that it is dropped\n            let _ = ptr::read(&guard.dropfn);\n            value\n        }\n    }", 'Real(LocalPath("src/scopeguard.rs"))'], 'scopeguard::guard': ['#[inline]\npub fn guard<T, F>(value: T, dropfn: F) -> ScopeGuard<T, F>\nwhere\n    F: FnMut(&mut T),{\n    ScopeGuard { dropfn, value }\n}', 'Real(LocalPath("src/scopeguard.rs"))'], 'set::Difference': ["/// A lazy iterator producing elements in the difference of `HashSet`s.\n///\n/// This `struct` is created by the [`difference`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`difference`]: struct.HashSet.html#method.difference\npub struct Difference<'a, T, S, A: Allocator = Global> {\n    // iterator of the first set\n    iter: Iter<'a, T>,\n    // the second set\n    other: &'a HashSet<T, S, A>,\n}", 'Real(LocalPath("src/set.rs"))'], 'set::Drain': ["/// A draining iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`drain`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`drain`]: struct.HashSet.html#method.drain\npub struct Drain<'a, K, A: Allocator = Global> {\n    iter: map::Drain<'a, K, (), A>,\n}", 'Real(LocalPath("src/set.rs"))'], 'set::Entry': ['/// A view into a single entry in a set, which may either be vacant or occupied.\n///\n/// This `enum` is constructed from the [`entry`] method on [`HashSet`].\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`entry`]: struct.HashSet.html#method.entry\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_set::{Entry, HashSet, OccupiedEntry};\n///\n/// let mut set = HashSet::new();\n/// set.extend(["a", "b", "c"]);\n/// assert_eq!(set.len(), 3);\n///\n/// // Existing value (insert)\n/// let entry: Entry<_, _> = set.entry("a");\n/// let _raw_o: OccupiedEntry<_, _> = entry.insert();\n/// assert_eq!(set.len(), 3);\n/// // Nonexistent value (insert)\n/// set.entry("d").insert();\n///\n/// // Existing value (or_insert)\n/// set.entry("b").or_insert();\n/// // Nonexistent value (or_insert)\n/// set.entry("e").or_insert();\n///\n/// println!("Our HashSet: {:?}", set);\n///\n/// let mut vec: Vec<_> = set.iter().copied().collect();\n/// // The `Iter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, ["a", "b", "c", "d", "e"]);\n/// ```\npub enum Entry<\'a, T, S, A = Global>\nwhere\n    A: Allocator,\n{\n    /// An occupied entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_set::{Entry, HashSet};\n    /// let mut set: HashSet<_> = ["a", "b"].into();\n    ///\n    /// match set.entry("a") {\n    ///     Entry::Vacant(_) => unreachable!(),\n    ///     Entry::Occupied(_) => { }\n    /// }\n    /// ```\n    Occupied(OccupiedEntry<\'a, T, S, A>),\n\n    /// A vacant entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use hashbrown::hash_set::{Entry, HashSet};\n    /// let mut set: HashSet<&str> = HashSet::new();\n    ///\n    /// match set.entry("a") {\n    ///     Entry::Occupied(_) => unreachable!(),\n    ///     Entry::Vacant(_) => { }\n    /// }\n    /// ```\n    Vacant(VacantEntry<\'a, T, S, A>),\n}', 'Real(LocalPath("src/set.rs"))'], "set::Entry::<'a, T, S, A>::get": ['/// Returns a reference to this entry\'s value.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set: HashSet<&str> = HashSet::new();\n/// set.entry("poneyland").or_insert();\n/// // existing key\n/// assert_eq!(set.entry("poneyland").get(), &"poneyland");\n/// // nonexistent key\n/// assert_eq!(set.entry("horseland").get(), &"horseland");\n/// ```\ninline\npub fn get(&self) -> &T{\n        match *self {\n            Entry::Occupied(ref entry) => entry.get(),\n            Entry::Vacant(ref entry) => entry.get(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "set::Entry::<'a, T, S, A>::insert": ['/// Sets the value of the entry, and returns an `OccupiedEntry`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set: HashSet<&str> = HashSet::new();\n/// let entry = set.entry("horseyland").insert();\n///\n/// assert_eq!(entry.get(), &"horseyland");\n/// ```\ninline\npub fn insert(self) -> OccupiedEntry<\'a, T, S, A>\n    where\n        T: Hash,\n        S: BuildHasher,{\n        match self {\n            Entry::Occupied(entry) => entry,\n            Entry::Vacant(entry) => entry.insert(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "set::Entry::<'a, T, S, A>::or_insert": ['/// Ensures a value is in the entry by inserting if it was vacant.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set: HashSet<&str> = HashSet::new();\n///\n/// // nonexistent key\n/// set.entry("poneyland").or_insert();\n/// assert!(set.contains("poneyland"));\n///\n/// // existing key\n/// set.entry("poneyland").or_insert();\n/// assert!(set.contains("poneyland"));\n/// assert_eq!(set.len(), 1);\n/// ```\ninline\npub fn or_insert(self)\n    where\n        T: Hash,\n        S: BuildHasher,{\n        if let Entry::Vacant(entry) = self {\n            entry.insert();\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::ExtractIf': ['/// A draining iterator over entries of a `HashSet` which don\'t satisfy the predicate `f`.\n///\n/// This `struct` is created by the [`extract_if`] method on [`HashSet`]. See its\n/// documentation for more.\n///\n/// [`extract_if`]: struct.HashSet.html#method.extract_if\n/// [`HashSet`]: struct.HashSet.html\n#[must_use = "Iterators are lazy unless consumed"]\npub struct ExtractIf<\'a, K, F, A: Allocator = Global> {\n    f: F,\n    inner: RawExtractIf<\'a, (K, ()), A>,\n}', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet': ['/// A hash set implemented as a `HashMap` where the value is `()`.\n///\n/// As with the [`HashMap`] type, a `HashSet` requires that the elements\n/// implement the [`Eq`] and [`Hash`] traits. This can frequently be achieved by\n/// using `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself,\n/// it is important that the following property holds:\n///\n/// ```text\n/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must be equal.\n///\n///\n/// It is a logic error for an item to be modified in such a way that the\n/// item\'s hash, as determined by the [`Hash`] trait, or its equality, as\n/// determined by the [`Eq`] trait, changes while it is in the set. This is\n/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or\n/// unsafe code.\n///\n/// It is also a logic error for the [`Hash`] implementation of a key to panic.\n/// This is generally only possible if the trait is implemented manually. If a\n/// panic does occur then the contents of the `HashSet` may become corrupted and\n/// some items may be dropped from the table.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `HashSet<String>` in this example).\n/// let mut books = HashSet::new();\n///\n/// // Add some books.\n/// books.insert("A Dance With Dragons".to_string());\n/// books.insert("To Kill a Mockingbird".to_string());\n/// books.insert("The Odyssey".to_string());\n/// books.insert("The Great Gatsby".to_string());\n///\n/// // Check for a specific one.\n/// if !books.contains("The Winds of Winter") {\n///     println!("We have {} books, but The Winds of Winter ain\'t one.",\n///              books.len());\n/// }\n///\n/// // Remove a book.\n/// books.remove("The Odyssey");\n///\n/// // Iterate over everything.\n/// for book in &books {\n///     println!("{}", book);\n/// }\n/// ```\n///\n/// The easiest way to use `HashSet` with a custom type is to derive\n/// [`Eq`] and [`Hash`]. We must also derive [`PartialEq`]. This will in the\n/// future be implied by [`Eq`].\n///\n/// ```\n/// use hashbrown::HashSet;\n/// #[derive(Hash, Eq, PartialEq, Debug)]\n/// struct Viking {\n///     name: String,\n///     power: usize,\n/// }\n///\n/// let mut vikings = HashSet::new();\n///\n/// vikings.insert(Viking { name: "Einar".to_string(), power: 9 });\n/// vikings.insert(Viking { name: "Einar".to_string(), power: 9 });\n/// vikings.insert(Viking { name: "Olaf".to_string(), power: 4 });\n/// vikings.insert(Viking { name: "Harald".to_string(), power: 8 });\n///\n/// // Use derived implementation to print the vikings.\n/// for x in &vikings {\n///     println!("{:?}", x);\n/// }\n/// ```\n///\n/// A `HashSet` with fixed list of elements can be initialized from an array:\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let viking_names: HashSet<&\'static str> =\n///     [ "Einar", "Olaf", "Harald" ].into_iter().collect();\n/// // use the values stored in the set\n/// ```\n///\n/// [`Cell`]: https://doc.rust-lang.org/std/cell/struct.Cell.html\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n/// [`HashMap`]: struct.HashMap.html\n/// [`PartialEq`]: https://doc.rust-lang.org/std/cmp/trait.PartialEq.html\n/// [`RefCell`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html\npub struct HashSet<T, S = DefaultHashBuilder, A: Allocator = Global> {\n    pub(crate) map: HashMap<T, (), S, A>,\n}', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::allocation_size': ['/// Returns the total amount of memory allocated internally by the hash\n/// set, in bytes.\n///\n/// The returned number is informational only. It is intended to be\n/// primarily used for memory profiling.\n#[inline]\npub fn allocation_size(&self) -> usize{\n        self.map.allocation_size()\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::allocator': ['/// Returns a reference to the underlying allocator.\n#[inline]\npub fn allocator(&self) -> &A{\n        self.map.allocator()\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::capacity': ['/// Returns the number of elements the set can hold without reallocating.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let set: HashSet<i32> = HashSet::with_capacity(100);\n/// assert!(set.capacity() >= 100);\n/// ```\ninline\npub fn capacity(&self) -> usize{\n        self.map.capacity()\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::clear': ['/// Clears the set, removing all values.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut v = HashSet::new();\n/// v.insert(1);\n/// v.clear();\n/// assert!(v.is_empty());\n/// ```\ninline\npub fn clear(&mut self){\n        self.map.clear();\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::contains': ["/// Returns `true` if the set contains a value.\n///\n/// The value may be any borrowed form of the set's value type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the value type.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// assert_eq!(set.contains(&1), true);\n/// assert_eq!(set.contains(&4), false);\n/// ```\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\ninline\npub fn contains<Q>(&self, value: &Q) -> bool\n    where\n        Q: Hash + Equivalent<T> + ?Sized,{\n        self.map.contains_key(value)\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::difference': ['/// Visits the values representing the difference,\n/// i.e., the values that are in `self` but not in `other`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n///\n/// // Can be seen as `a - b`.\n/// for x in a.difference(&b) {\n///     println!("{}", x); // Print 1\n/// }\n///\n/// let diff: HashSet<_> = a.difference(&b).collect();\n/// assert_eq!(diff, [1].iter().collect());\n///\n/// // Note that difference is not symmetric,\n/// // and `b - a` means something else:\n/// let diff: HashSet<_> = b.difference(&a).collect();\n/// assert_eq!(diff, [4].iter().collect());\n/// ```\ninline\npub fn difference<\'a>(&\'a self, other: &\'a Self) -> Difference<\'a, T, S, A>{\n        Difference {\n            iter: self.iter(),\n            other,\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::drain': ['/// Clears the set, returning all elements in an iterator.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// assert!(!set.is_empty());\n///\n/// // print 1, 2, 3 in an arbitrary order\n/// for i in set.drain() {\n///     println!("{}", i);\n/// }\n///\n/// assert!(set.is_empty());\n/// ```\ninline\npub fn drain(&mut self) -> Drain<\'_, T, A>{\n        Drain {\n            iter: self.map.drain(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::entry': ['/// Gets the given value\'s corresponding entry in the set for in-place manipulation.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// use hashbrown::hash_set::Entry::*;\n///\n/// let mut singles = HashSet::new();\n/// let mut dupes = HashSet::new();\n///\n/// for ch in "a short treatise on fungi".chars() {\n///     if let Vacant(dupe_entry) = dupes.entry(ch) {\n///         // We haven\'t already seen a duplicate, so\n///         // check if we\'ve at least seen it once.\n///         match singles.entry(ch) {\n///             Vacant(single_entry) => {\n///                 // We found a new character for the first time.\n///                 single_entry.insert();\n///             }\n///             Occupied(single_entry) => {\n///                 // We\'ve already seen this once, "move" it to dupes.\n///                 single_entry.remove();\n///                 dupe_entry.insert();\n///             }\n///         }\n///     }\n/// }\n///\n/// assert!(!singles.contains(&\'t\') && dupes.contains(&\'t\'));\n/// assert!(singles.contains(&\'u\') && !dupes.contains(&\'u\'));\n/// assert!(!singles.contains(&\'v\') && !dupes.contains(&\'v\'));\n/// ```\ninline\npub fn entry(&mut self, value: T) -> Entry<\'_, T, S, A>{\n        match self.map.entry(value) {\n            map::Entry::Occupied(entry) => Entry::Occupied(OccupiedEntry { inner: entry }),\n            map::Entry::Vacant(entry) => Entry::Vacant(VacantEntry { inner: entry }),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::extract_if': ["/// Drains elements which are true under the given predicate,\n/// and returns an iterator over the removed items.\n///\n/// In other words, move all elements `e` such that `f(&e)` returns `true` out\n/// into another iterator.\n///\n/// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n/// or the iteration short-circuits, then the remaining elements will be retained.\n/// Use [`retain()`] with a negated predicate if you do not need the returned iterator.\n///\n/// [`retain()`]: HashSet::retain\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set: HashSet<i32> = (0..8).collect();\n/// let drained: HashSet<i32> = set.extract_if(|v| v % 2 == 0).collect();\n///\n/// let mut evens = drained.into_iter().collect::<Vec<_>>();\n/// let mut odds = set.into_iter().collect::<Vec<_>>();\n/// evens.sort();\n/// odds.sort();\n///\n/// assert_eq!(evens, vec![0, 2, 4, 6]);\n/// assert_eq!(odds, vec![1, 3, 5, 7]);\n/// ```\ninline\npub fn extract_if<F>(&mut self, f: F) -> ExtractIf<'_, T, F, A>\n    where\n        F: FnMut(&T) -> bool,{\n        ExtractIf {\n            f,\n            inner: RawExtractIf {\n                iter: unsafe { self.map.table.iter() },\n                table: &mut self.map.table,\n            },\n        }\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::get': ["/// Returns a reference to the value in the set, if any, that is equal to the given value.\n///\n/// The value may be any borrowed form of the set's value type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the value type.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let set: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// assert_eq!(set.get(&2), Some(&2));\n/// assert_eq!(set.get(&4), None);\n/// ```\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\ninline\npub fn get<Q>(&self, value: &Q) -> Option<&T>\n    where\n        Q: Hash + Equivalent<T> + ?Sized,{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.map.get_key_value(value) {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::get_or_insert': ['/// Inserts the given `value` into the set if it is not present, then\n/// returns a reference to the value in the set.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// assert_eq!(set.len(), 3);\n/// assert_eq!(set.get_or_insert(2), &2);\n/// assert_eq!(set.get_or_insert(100), &100);\n/// assert_eq!(set.len(), 4); // 100 was inserted\n/// ```\ninline\npub fn get_or_insert(&mut self, value: T) -> &T{\n        let hash = make_hash(&self.map.hash_builder, &value);\n        let bucket = match self.map.find_or_find_insert_slot(hash, &value) {\n            Ok(bucket) => bucket,\n            Err(slot) => unsafe { self.map.table.insert_in_slot(hash, slot, (value, ())) },\n        };\n        unsafe { &bucket.as_ref().0 }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::get_or_insert_with': ['/// Inserts a value computed from `f` into the set if the given `value` is\n/// not present, then returns a reference to the value in the set.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set: HashSet<String> = ["cat", "dog", "horse"]\n///     .iter().map(|&pet| pet.to_owned()).collect();\n///\n/// assert_eq!(set.len(), 3);\n/// for &pet in &["cat", "dog", "fish"] {\n///     let value = set.get_or_insert_with(pet, str::to_owned);\n///     assert_eq!(value, pet);\n/// }\n/// assert_eq!(set.len(), 4); // a new "fish" was inserted\n/// ```\n///\n/// The following example will panic because the new value doesn\'t match.\n///\n/// ```should_panic\n/// let mut set = hashbrown::HashSet::new();\n/// set.get_or_insert_with("rust", |_| String::new());\n/// ```\ninline\npub fn get_or_insert_with<Q, F>(&mut self, value: &Q, f: F) -> &T\n    where\n        Q: Hash + Equivalent<T> + ?Sized,\n        F: FnOnce(&Q) -> T,{\n        let hash = make_hash(&self.map.hash_builder, value);\n        let bucket = match self.map.find_or_find_insert_slot(hash, value) {\n            Ok(bucket) => bucket,\n            Err(slot) => {\n                let new = f(value);\n                assert!(value.equivalent(&new), "new value is not equivalent");\n                unsafe { self.map.table.insert_in_slot(hash, slot, (new, ())) }\n            }\n        };\n        unsafe { &bucket.as_ref().0 }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::hasher': ["/// Returns a reference to the set's [`BuildHasher`].\n///\n/// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// use hashbrown::DefaultHashBuilder;\n///\n/// let hasher = DefaultHashBuilder::default();\n/// let set: HashSet<i32> = HashSet::with_hasher(hasher);\n/// let hasher: &DefaultHashBuilder = set.hasher();\n/// ```\ninline\npub fn hasher(&self) -> &S{\n        self.map.hasher()\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::insert': ['/// Adds a value to the set.\n///\n/// If the set did not have this value present, `true` is returned.\n///\n/// If the set did have this value present, `false` is returned.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set = HashSet::new();\n///\n/// assert_eq!(set.insert(2), true);\n/// assert_eq!(set.insert(2), false);\n/// assert_eq!(set.len(), 1);\n/// ```\ninline\npub fn insert(&mut self, value: T) -> bool{\n        self.map.insert(value, ()).is_none()\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::insert_unique_unchecked': ['/// Insert a value the set without checking if the value already exists in the set.\n///\n/// This operation is faster than regular insert, because it does not perform\n/// lookup before insertion.\n///\n/// This operation is useful during initial population of the set.\n/// For example, when constructing a set from another set, we know\n/// that values are unique.\n///\n/// # Safety\n///\n/// This operation is safe if a value does not exist in the set.\n///\n/// However, if a value exists in the set already, the behavior is unspecified:\n/// this operation may panic, loop forever, or any following operation with the set\n/// may panic, loop forever or return arbitrary result.\n///\n/// That said, this operation (and following operations) are guaranteed to\n/// not violate memory safety.\n///\n/// However this operation is still unsafe because the resulting `HashSet`\n/// may be passed to unsafe code which does expect the set to behave\n/// correctly, and would cause unsoundness as a result.\ninline\npub unsafe fn insert_unique_unchecked(&mut self, value: T) -> &T{\n        self.map.insert_unique_unchecked(value, ()).0\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::intersection': ['/// Visits the values representing the intersection,\n/// i.e., the values that are both in `self` and `other`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n///\n/// // Print 2, 3 in arbitrary order.\n/// for x in a.intersection(&b) {\n///     println!("{}", x);\n/// }\n///\n/// let intersection: HashSet<_> = a.intersection(&b).collect();\n/// assert_eq!(intersection, [2, 3].iter().collect());\n/// ```\ninline\npub fn intersection<\'a>(&\'a self, other: &\'a Self) -> Intersection<\'a, T, S, A>{\n        let (smaller, larger) = if self.len() <= other.len() {\n            (self, other)\n        } else {\n            (other, self)\n        };\n        Intersection {\n            iter: smaller.iter(),\n            other: larger,\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::is_disjoint': ['/// Returns `true` if `self` has no elements in common with `other`.\n/// This is equivalent to checking for an empty intersection.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// let mut b = HashSet::new();\n///\n/// assert_eq!(a.is_disjoint(&b), true);\n/// b.insert(4);\n/// assert_eq!(a.is_disjoint(&b), true);\n/// b.insert(1);\n/// assert_eq!(a.is_disjoint(&b), false);\n/// ```\npub fn is_disjoint(&self, other: &Self) -> bool{\n        self.intersection(other).next().is_none()\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::is_empty': ['/// Returns `true` if the set contains no elements.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut v = HashSet::new();\n/// assert!(v.is_empty());\n/// v.insert(1);\n/// assert!(!v.is_empty());\n/// ```\ninline\npub fn is_empty(&self) -> bool{\n        self.map.is_empty()\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::is_subset': ['/// Returns `true` if the set is a subset of another,\n/// i.e., `other` contains at least all the values in `self`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let sup: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// let mut set = HashSet::new();\n///\n/// assert_eq!(set.is_subset(&sup), true);\n/// set.insert(2);\n/// assert_eq!(set.is_subset(&sup), true);\n/// set.insert(4);\n/// assert_eq!(set.is_subset(&sup), false);\n/// ```\npub fn is_subset(&self, other: &Self) -> bool{\n        self.len() <= other.len() && self.iter().all(|v| other.contains(v))\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::is_superset': ['/// Returns `true` if the set is a superset of another,\n/// i.e., `self` contains at least all the values in `other`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let sub: HashSet<_> = [1, 2].into_iter().collect();\n/// let mut set = HashSet::new();\n///\n/// assert_eq!(set.is_superset(&sub), false);\n///\n/// set.insert(0);\n/// set.insert(1);\n/// assert_eq!(set.is_superset(&sub), false);\n///\n/// set.insert(2);\n/// assert_eq!(set.is_superset(&sub), true);\n/// ```\ninline\npub fn is_superset(&self, other: &Self) -> bool{\n        other.is_subset(self)\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::iter': ['/// An iterator visiting all elements in arbitrary order.\n/// The iterator element type is `&\'a T`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let mut set = HashSet::new();\n/// set.insert("a");\n/// set.insert("b");\n///\n/// // Will print in an arbitrary order.\n/// for x in set.iter() {\n///     println!("{}", x);\n/// }\n/// ```\ninline\npub fn iter(&self) -> Iter<\'_, T>{\n        Iter {\n            iter: self.map.keys(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::len': ['/// Returns the number of elements in the set.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut v = HashSet::new();\n/// assert_eq!(v.len(), 0);\n/// v.insert(1);\n/// assert_eq!(v.len(), 1);\n/// ```\ninline\npub fn len(&self) -> usize{\n        self.map.len()\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::remove': ["/// Removes a value from the set. Returns whether the value was\n/// present in the set.\n///\n/// The value may be any borrowed form of the set's value type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the value type.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set = HashSet::new();\n///\n/// set.insert(2);\n/// assert_eq!(set.remove(&2), true);\n/// assert_eq!(set.remove(&2), false);\n/// ```\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\ninline\npub fn remove<Q>(&mut self, value: &Q) -> bool\n    where\n        Q: Hash + Equivalent<T> + ?Sized,{\n        self.map.remove(value).is_some()\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::replace': ['/// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n/// one. Returns the replaced value.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set = HashSet::new();\n/// set.insert(Vec::<i32>::new());\n///\n/// assert_eq!(set.get(&[][..]).unwrap().capacity(), 0);\n/// set.replace(Vec::with_capacity(10));\n/// assert_eq!(set.get(&[][..]).unwrap().capacity(), 10);\n/// ```\ninline\npub fn replace(&mut self, value: T) -> Option<T>{\n        let hash = make_hash(&self.map.hash_builder, &value);\n        match self.map.find_or_find_insert_slot(hash, &value) {\n            Ok(bucket) => Some(mem::replace(unsafe { &mut bucket.as_mut().0 }, value)),\n            Err(slot) => {\n                unsafe {\n                    self.map.table.insert_in_slot(hash, slot, (value, ()));\n                }\n                None\n            }\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::reserve': ['/// Reserves capacity for at least `additional` more elements to be inserted\n/// in the `HashSet`. The collection may reserve more space to avoid\n/// frequent reallocations.\n///\n/// # Panics\n///\n/// Panics if the new capacity exceeds [`isize::MAX`] bytes and [`abort`] the program\n/// in case of allocation error. Use [`try_reserve`](HashSet::try_reserve) instead\n/// if you want to handle memory allocation failure.\n///\n/// [`isize::MAX`]: https://doc.rust-lang.org/std/primitive.isize.html\n/// [`abort`]: https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let mut set: HashSet<i32> = HashSet::new();\n/// set.reserve(10);\n/// assert!(set.capacity() >= 10);\n/// ```\ninline\npub fn reserve(&mut self, additional: usize){\n        self.map.reserve(additional);\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::retain': ['/// Retains only the elements specified by the predicate.\n///\n/// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let xs = [1,2,3,4,5,6];\n/// let mut set: HashSet<i32> = xs.into_iter().collect();\n/// set.retain(|&k| k % 2 == 0);\n/// assert_eq!(set.len(), 3);\n/// ```\npub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> bool,{\n        self.map.retain(|k, _| f(k));\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::shrink_to': ['/// Shrinks the capacity of the set with a lower limit. It will drop\n/// down no lower than the supplied limit while maintaining the internal rules\n/// and possibly leaving some space in accordance with the resize policy.\n///\n/// Panics if the current capacity is smaller than the supplied\n/// minimum capacity.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set = HashSet::with_capacity(100);\n/// set.insert(1);\n/// set.insert(2);\n/// assert!(set.capacity() >= 100);\n/// set.shrink_to(10);\n/// assert!(set.capacity() >= 10);\n/// set.shrink_to(0);\n/// assert!(set.capacity() >= 2);\n/// ```\ninline\npub fn shrink_to(&mut self, min_capacity: usize){\n        self.map.shrink_to(min_capacity);\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::shrink_to_fit': ['/// Shrinks the capacity of the set as much as possible. It will drop\n/// down as much as possible while maintaining the internal rules\n/// and possibly leaving some space in accordance with the resize policy.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set = HashSet::with_capacity(100);\n/// set.insert(1);\n/// set.insert(2);\n/// assert!(set.capacity() >= 100);\n/// set.shrink_to_fit();\n/// assert!(set.capacity() >= 2);\n/// ```\ninline\npub fn shrink_to_fit(&mut self){\n        self.map.shrink_to_fit();\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::symmetric_difference': ['/// Visits the values representing the symmetric difference,\n/// i.e., the values that are in `self` or in `other` but not in both.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n///\n/// // Print 1, 4 in arbitrary order.\n/// for x in a.symmetric_difference(&b) {\n///     println!("{}", x);\n/// }\n///\n/// let diff1: HashSet<_> = a.symmetric_difference(&b).collect();\n/// let diff2: HashSet<_> = b.symmetric_difference(&a).collect();\n///\n/// assert_eq!(diff1, diff2);\n/// assert_eq!(diff1, [1, 4].iter().collect());\n/// ```\ninline\npub fn symmetric_difference<\'a>(&\'a self, other: &\'a Self) -> SymmetricDifference<\'a, T, S, A>{\n        SymmetricDifference {\n            iter: self.difference(other).chain(other.difference(self)),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::take': ["/// Removes and returns the value in the set, if any, that is equal to the given one.\n///\n/// The value may be any borrowed form of the set's value type, but\n/// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n/// the value type.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// assert_eq!(set.take(&2), Some(2));\n/// assert_eq!(set.take(&2), None);\n/// ```\n///\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\ninline\npub fn take<Q>(&mut self, value: &Q) -> Option<T>\n    where\n        Q: Hash + Equivalent<T> + ?Sized,{\n        // Avoid `Option::map` because it bloats LLVM IR.\n        match self.map.remove_entry(value) {\n            Some((k, _)) => Some(k),\n            None => None,\n        }\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::try_reserve': ['/// Tries to reserve capacity for at least `additional` more elements to be inserted\n/// in the given `HashSet<K,V>`. The collection may reserve more space to avoid\n/// frequent reallocations.\n///\n/// # Errors\n///\n/// If the capacity overflows, or the allocator reports a failure, then an error\n/// is returned.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let mut set: HashSet<i32> = HashSet::new();\n/// set.try_reserve(10).expect("why is the test harness OOMing on 10 bytes?");\n/// ```\ninline\npub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError>{\n        self.map.try_reserve(additional)\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::union': ['/// Visits the values representing the union,\n/// i.e., all the values in `self` or `other`, without duplicates.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let a: HashSet<_> = [1, 2, 3].into_iter().collect();\n/// let b: HashSet<_> = [4, 2, 3, 4].into_iter().collect();\n///\n/// // Print 1, 2, 3, 4 in arbitrary order.\n/// for x in a.union(&b) {\n///     println!("{}", x);\n/// }\n///\n/// let union: HashSet<_> = a.union(&b).collect();\n/// assert_eq!(union, [1, 2, 3, 4].iter().collect());\n/// ```\ninline\npub fn union<\'a>(&\'a self, other: &\'a Self) -> Union<\'a, T, S, A>{\n        // We\'ll iterate one set in full, and only the remaining difference from the other.\n        // Use the smaller set for the difference in order to reduce hash lookups.\n        let (smaller, larger) = if self.len() <= other.len() {\n            (self, other)\n        } else {\n            (other, self)\n        };\n        Union {\n            iter: larger.iter().chain(smaller.difference(larger)),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::with_capacity_and_hasher_in': ['/// Creates an empty `HashSet` with the specified capacity, using\n/// `hasher` to hash the keys.\n///\n/// The hash set will be able to hold at least `capacity` elements without\n/// reallocating. If `capacity` is 0, the hash set will not allocate.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashSet`].\n///\n/// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n/// the `HashSet` to be useful, see its documentation for details.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n/// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// use hashbrown::DefaultHashBuilder;\n///\n/// let s = DefaultHashBuilder::default();\n/// let mut set = HashSet::with_capacity_and_hasher(10, s);\n/// set.insert(1);\n/// ```\ninline\npub fn with_capacity_and_hasher_in(capacity: usize, hasher: S, alloc: A) -> Self{\n        Self {\n            map: HashMap::with_capacity_and_hasher_in(capacity, hasher, alloc),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S, A>::with_hasher_in': ['/// Creates a new empty hash set which will use the given hasher to hash\n/// keys.\n///\n/// The hash set is initially created with a capacity of 0, so it will not\n/// allocate until it is first inserted into.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashSet`].\n///\n/// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n/// the `HashSet` to be useful, see its documentation for details.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n/// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// use hashbrown::DefaultHashBuilder;\n///\n/// let s = DefaultHashBuilder::default();\n/// let mut set = HashSet::with_hasher(s);\n/// set.insert(2);\n/// ```\ninline\npub const fn with_hasher_in(hasher: S, alloc: A) -> Self{\n        Self {\n            map: HashMap::with_hasher_in(hasher, alloc),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S>::with_capacity_and_hasher': ['/// Creates an empty `HashSet` with the specified capacity, using\n/// `hasher` to hash the keys.\n///\n/// The hash set will be able to hold at least `capacity` elements without\n/// reallocating. If `capacity` is 0, the hash set will not allocate.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashSet`].\n///\n/// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n/// the `HashSet` to be useful, see its documentation for details.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n/// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// use hashbrown::DefaultHashBuilder;\n///\n/// let s = DefaultHashBuilder::default();\n/// let mut set = HashSet::with_capacity_and_hasher(10, s);\n/// set.insert(1);\n/// ```\ninline\npub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> Self{\n        Self {\n            map: HashMap::with_capacity_and_hasher(capacity, hasher),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, S>::with_hasher': ['/// Creates a new empty hash set which will use the given hasher to hash\n/// keys.\n///\n/// The hash set is initially created with a capacity of 0, so it will not\n/// allocate until it is first inserted into.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashSet`].\n///\n/// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n/// the `HashSet` to be useful, see its documentation for details.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n/// [`BuildHasher`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// use hashbrown::DefaultHashBuilder;\n///\n/// let s = DefaultHashBuilder::default();\n/// let mut set = HashSet::with_hasher(s);\n/// set.insert(2);\n/// ```\ninline\npub const fn with_hasher(hasher: S) -> Self{\n        Self {\n            map: HashMap::with_hasher(hasher),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, foldhash::fast::RandomState, A>::new_in': ['/// Creates an empty `HashSet`.\n///\n/// The hash set is initially created with a capacity of 0, so it will not allocate until it\n/// is first inserted into.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashSet`], for example with\n/// [`with_hasher_in`](HashSet::with_hasher_in) method.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let set: HashSet<i32> = HashSet::new();\n/// ```\ninline\npub fn new_in(alloc: A) -> Self{\n        Self {\n            map: HashMap::new_in(alloc),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T, foldhash::fast::RandomState, A>::with_capacity_in': ['/// Creates an empty `HashSet` with the specified capacity.\n///\n/// The hash set will be able to hold at least `capacity` elements without\n/// reallocating. If `capacity` is 0, the hash set will not allocate.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashSet`], for example with\n/// [`with_capacity_and_hasher_in`](HashSet::with_capacity_and_hasher_in) method.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let set: HashSet<i32> = HashSet::with_capacity(10);\n/// assert!(set.capacity() >= 10);\n/// ```\ninline\npub fn with_capacity_in(capacity: usize, alloc: A) -> Self{\n        Self {\n            map: HashMap::with_capacity_in(capacity, alloc),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T>::new': ['/// Creates an empty `HashSet`.\n///\n/// The hash set is initially created with a capacity of 0, so it will not allocate until it\n/// is first inserted into.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashSet`], for example with\n/// [`with_hasher`](HashSet::with_hasher) method.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let set: HashSet<i32> = HashSet::new();\n/// ```\ninline\npub fn new() -> Self{\n        Self {\n            map: HashMap::new(),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::HashSet::<T>::with_capacity': ['/// Creates an empty `HashSet` with the specified capacity.\n///\n/// The hash set will be able to hold at least `capacity` elements without\n/// reallocating. If `capacity` is 0, the hash set will not allocate.\n///\n/// # HashDoS resistance\n///\n/// The `hash_builder` normally use a fixed key by default and that does\n/// not allow the `HashSet` to be protected against attacks such as [`HashDoS`].\n/// Users who require HashDoS resistance should explicitly use\n/// [`std::collections::hash_map::RandomState`]\n/// as the hasher when creating a [`HashSet`], for example with\n/// [`with_capacity_and_hasher`](HashSet::with_capacity_and_hasher) method.\n///\n/// [`HashDoS`]: https://en.wikipedia.org/wiki/Collision_attack\n/// [`std::collections::hash_map::RandomState`]: https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// let set: HashSet<i32> = HashSet::with_capacity(10);\n/// assert!(set.capacity() >= 10);\n/// ```\ninline\npub fn with_capacity(capacity: usize) -> Self{\n        Self {\n            map: HashMap::with_capacity(capacity),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::Intersection': ["/// A lazy iterator producing elements in the intersection of `HashSet`s.\n///\n/// This `struct` is created by the [`intersection`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`intersection`]: struct.HashSet.html#method.intersection\npub struct Intersection<'a, T, S, A: Allocator = Global> {\n    // iterator of the first set\n    iter: Iter<'a, T>,\n    // the second set\n    other: &'a HashSet<T, S, A>,\n}", 'Real(LocalPath("src/set.rs"))'], 'set::IntoIter': ['/// An owning iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`HashSet`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`into_iter`]: struct.HashSet.html#method.into_iter\npub struct IntoIter<K, A: Allocator = Global> {\n    iter: map::IntoIter<K, (), A>,\n}', 'Real(LocalPath("src/set.rs"))'], 'set::Iter': ["/// An iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`iter`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`iter`]: struct.HashSet.html#method.iter\npub struct Iter<'a, K> {\n    iter: Keys<'a, K, ()>,\n}", 'Real(LocalPath("src/set.rs"))'], 'set::OccupiedEntry': ['/// A view into an occupied entry in a `HashSet`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_set::{Entry, HashSet, OccupiedEntry};\n///\n/// let mut set = HashSet::new();\n/// set.extend(["a", "b", "c"]);\n///\n/// let _entry_o: OccupiedEntry<_, _> = set.entry("a").insert();\n/// assert_eq!(set.len(), 3);\n///\n/// // Existing key\n/// match set.entry("a") {\n///     Entry::Vacant(_) => unreachable!(),\n///     Entry::Occupied(view) => {\n///         assert_eq!(view.get(), &"a");\n///     }\n/// }\n///\n/// assert_eq!(set.len(), 3);\n///\n/// // Existing key (take)\n/// match set.entry("c") {\n///     Entry::Vacant(_) => unreachable!(),\n///     Entry::Occupied(view) => {\n///         assert_eq!(view.remove(), "c");\n///     }\n/// }\n/// assert_eq!(set.get(&"c"), None);\n/// assert_eq!(set.len(), 2);\n/// ```\npub struct OccupiedEntry<\'a, T, S, A: Allocator = Global> {\n    inner: map::OccupiedEntry<\'a, T, (), S, A>,\n}', 'Real(LocalPath("src/set.rs"))'], "set::OccupiedEntry::<'_, T, S, A>::get": ['/// Gets a reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_set::{Entry, HashSet};\n///\n/// let mut set: HashSet<&str> = HashSet::new();\n/// set.entry("poneyland").or_insert();\n///\n/// match set.entry("poneyland") {\n///     Entry::Vacant(_) => panic!(),\n///     Entry::Occupied(entry) => assert_eq!(entry.get(), &"poneyland"),\n/// }\n/// ```\ninline\npub fn get(&self) -> &T{\n        self.inner.key()\n    }', 'Real(LocalPath("src/set.rs"))'], "set::OccupiedEntry::<'_, T, S, A>::remove": ['/// Takes the value out of the entry, and returns it.\n/// Keeps the allocated memory for reuse.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// use hashbrown::hash_set::Entry;\n///\n/// let mut set: HashSet<&str> = HashSet::new();\n/// // The set is empty\n/// assert!(set.is_empty() && set.capacity() == 0);\n///\n/// set.entry("poneyland").or_insert();\n/// let capacity_before_remove = set.capacity();\n///\n/// if let Entry::Occupied(o) = set.entry("poneyland") {\n///     assert_eq!(o.remove(), "poneyland");\n/// }\n///\n/// assert_eq!(set.contains("poneyland"), false);\n/// // Now set hold none elements but capacity is equal to the old one\n/// assert!(set.len() == 0 && set.capacity() == capacity_before_remove);\n/// ```\ninline\npub fn remove(self) -> T{\n        self.inner.remove_entry().0\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::SymmetricDifference': ["/// A lazy iterator producing elements in the symmetric difference of `HashSet`s.\n///\n/// This `struct` is created by the [`symmetric_difference`] method on\n/// [`HashSet`]. See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`symmetric_difference`]: struct.HashSet.html#method.symmetric_difference\npub struct SymmetricDifference<'a, T, S, A: Allocator = Global> {\n    iter: Chain<Difference<'a, T, S, A>, Difference<'a, T, S, A>>,\n}", 'Real(LocalPath("src/set.rs"))'], 'set::Union': ["/// A lazy iterator producing elements in the union of `HashSet`s.\n///\n/// This `struct` is created by the [`union`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`union`]: struct.HashSet.html#method.union\npub struct Union<'a, T, S, A: Allocator = Global> {\n    iter: Chain<Iter<'a, T>, Difference<'a, T, S, A>>,\n}", 'Real(LocalPath("src/set.rs"))'], 'set::VacantEntry': ['/// A view into a vacant entry in a `HashSet`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_set::{Entry, HashSet, VacantEntry};\n///\n/// let mut set = HashSet::<&str>::new();\n///\n/// let entry_v: VacantEntry<_, _> = match set.entry("a") {\n///     Entry::Vacant(view) => view,\n///     Entry::Occupied(_) => unreachable!(),\n/// };\n/// entry_v.insert();\n/// assert!(set.contains("a") && set.len() == 1);\n///\n/// // Nonexistent key (insert)\n/// match set.entry("b") {\n///     Entry::Vacant(view) => { view.insert(); },\n///     Entry::Occupied(_) => unreachable!(),\n/// }\n/// assert!(set.contains("b") && set.len() == 2);\n/// ```\npub struct VacantEntry<\'a, T, S, A: Allocator = Global> {\n    inner: map::VacantEntry<\'a, T, (), S, A>,\n}', 'Real(LocalPath("src/set.rs"))'], "set::VacantEntry::<'a, T, S, A>::get": ['/// Gets a reference to the value that would be used when inserting\n/// through the `VacantEntry`.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n///\n/// let mut set: HashSet<&str> = HashSet::new();\n/// assert_eq!(set.entry("poneyland").get(), &"poneyland");\n/// ```\ninline\npub fn get(&self) -> &T{\n        self.inner.key()\n    }', 'Real(LocalPath("src/set.rs"))'], "set::VacantEntry::<'a, T, S, A>::insert": ['/// Sets the value of the entry with the `VacantEntry`\'s value.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// use hashbrown::hash_set::Entry;\n///\n/// let mut set: HashSet<&str> = HashSet::new();\n///\n/// if let Entry::Vacant(o) = set.entry("poneyland") {\n///     o.insert();\n/// }\n/// assert!(set.contains("poneyland"));\n/// ```\ninline\npub fn insert(self) -> OccupiedEntry<\'a, T, S, A>\n    where\n        T: Hash,\n        S: BuildHasher,{\n        OccupiedEntry {\n            inner: self.inner.insert_entry(()),\n        }\n    }', 'Real(LocalPath("src/set.rs"))'], "set::VacantEntry::<'a, T, S, A>::into_value": ['/// Take ownership of the value.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::hash_set::{Entry, HashSet};\n///\n/// let mut set: HashSet<&str> = HashSet::new();\n///\n/// match set.entry("poneyland") {\n///     Entry::Occupied(_) => panic!(),\n///     Entry::Vacant(v) => assert_eq!(v.into_value(), "poneyland"),\n/// }\n/// ```\ninline\npub fn into_value(self) -> T{\n        self.inner.into_key()\n    }', 'Real(LocalPath("src/set.rs"))'], 'set::assert_covariance': ["#[allow(dead_code)]\nfn assert_covariance(){\n    fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str> {\n        v\n    }\n    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> {\n        v\n    }\n    fn into_iter<'new, A: Allocator>(v: IntoIter<&'static str, A>) -> IntoIter<&'new str, A> {\n        v\n    }\n    fn difference<'a, 'new, A: Allocator>(\n        v: Difference<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> Difference<'a, &'new str, DefaultHashBuilder, A> {\n        v\n    }\n    fn symmetric_difference<'a, 'new, A: Allocator>(\n        v: SymmetricDifference<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> SymmetricDifference<'a, &'new str, DefaultHashBuilder, A> {\n        v\n    }\n    fn intersection<'a, 'new, A: Allocator>(\n        v: Intersection<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> Intersection<'a, &'new str, DefaultHashBuilder, A> {\n        v\n    }\n    fn union<'a, 'new, A: Allocator>(\n        v: Union<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> Union<'a, &'new str, DefaultHashBuilder, A> {\n        v\n    }\n    fn drain<'new, A: Allocator>(d: Drain<'static, &'static str, A>) -> Drain<'new, &'new str, A> {\n        d\n    }\n}", 'Real(LocalPath("src/set.rs"))'], 'set::assert_covariance::difference': ["fn difference<'a, 'new, A: Allocator>(\n        v: Difference<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> Difference<'a, &'new str, DefaultHashBuilder, A>{\n        v\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::assert_covariance::drain': ["fn drain<'new, A: Allocator>(d: Drain<'static, &'static str, A>) -> Drain<'new, &'new str, A>{\n        d\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::assert_covariance::intersection': ["fn intersection<'a, 'new, A: Allocator>(\n        v: Intersection<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> Intersection<'a, &'new str, DefaultHashBuilder, A>{\n        v\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::assert_covariance::into_iter': ["fn into_iter<'new, A: Allocator>(v: IntoIter<&'static str, A>) -> IntoIter<&'new str, A>{\n        v\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::assert_covariance::iter': ["fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str>{\n        v\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::assert_covariance::set': ["fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str>{\n        v\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::assert_covariance::symmetric_difference': ["fn symmetric_difference<'a, 'new, A: Allocator>(\n        v: SymmetricDifference<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> SymmetricDifference<'a, &'new str, DefaultHashBuilder, A>{\n        v\n    }", 'Real(LocalPath("src/set.rs"))'], 'set::assert_covariance::union': ["fn union<'a, 'new, A: Allocator>(\n        v: Union<'a, &'static str, DefaultHashBuilder, A>,\n    ) -> Union<'a, &'new str, DefaultHashBuilder, A>{\n        v\n    }", 'Real(LocalPath("src/set.rs"))'], 'table::AbsentEntry': ['/// Type representing the absence of an entry, as returned by [`HashTable::find_entry`].\n///\n/// This type only exists due to [limitations] in Rust\'s NLL borrow checker. In\n/// the future, `find_entry` will return an `Option<OccupiedEntry>` and this\n/// type will be removed.\n///\n/// [limitations]: https://smallcultfollowing.com/babysteps/blog/2018/06/15/mir-based-borrow-check-nll-status-update/#polonius\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::{AbsentEntry, Entry};\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<&str> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n///\n/// let entry_v: AbsentEntry<_, _> = table.find_entry(hasher(&"a"), |&x| x == "a").unwrap_err();\n/// entry_v\n///     .into_table()\n///     .insert_unique(hasher(&"a"), "a", hasher);\n/// assert!(table.find(hasher(&"a"), |&x| x == "a").is_some() && table.len() == 1);\n///\n/// // Nonexistent key (insert)\n/// match table.entry(hasher(&"b"), |&x| x == "b", hasher) {\n///     Entry::Vacant(view) => {\n///         view.insert("b");\n///     }\n///     Entry::Occupied(_) => unreachable!(),\n/// }\n/// assert!(table.find(hasher(&"b"), |&x| x == "b").is_some() && table.len() == 2);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub struct AbsentEntry<\'a, T, A = Global>\nwhere\n    A: Allocator,\n{\n    table: &\'a mut HashTable<T, A>,\n}', 'Real(LocalPath("src/table.rs"))'], "table::AbsentEntry::<'a, T, A>::into_table": ["/// Converts the `AbsentEntry` into a mutable reference to the underlying\n/// table.\npub fn into_table(self) -> &'a mut HashTable<T, A>{\n        self.table\n    }", 'Real(LocalPath("src/table.rs"))'], 'table::Drain': ["/// A draining iterator over the items of a `HashTable`.\n///\n/// This `struct` is created by the [`drain`] method on [`HashTable`].\n/// See its documentation for more.\n///\n/// [`HashTable`]: struct.HashTable.html\n/// [`drain`]: struct.HashTable.html#method.drain\npub struct Drain<'a, T, A: Allocator = Global> {\n    inner: RawDrain<'a, T, A>,\n}", 'Real(LocalPath("src/table.rs"))'], 'table::Entry': ['/// A view into a single entry in a table, which may either be vacant or occupied.\n///\n/// This `enum` is constructed from the [`entry`] method on [`HashTable`].\n///\n/// [`HashTable`]: struct.HashTable.html\n/// [`entry`]: struct.HashTable.html#method.entry\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::{Entry, OccupiedEntry};\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// for x in ["a", "b", "c"] {\n///     table.insert_unique(hasher(&x), x, hasher);\n/// }\n/// assert_eq!(table.len(), 3);\n///\n/// // Existing value (insert)\n/// let entry: Entry<_> = table.entry(hasher(&"a"), |&x| x == "a", hasher);\n/// let _raw_o: OccupiedEntry<_, _> = entry.insert("a");\n/// assert_eq!(table.len(), 3);\n/// // Nonexistent value (insert)\n/// table.entry(hasher(&"d"), |&x| x == "d", hasher).insert("d");\n///\n/// // Existing value (or_insert)\n/// table\n///     .entry(hasher(&"b"), |&x| x == "b", hasher)\n///     .or_insert("b");\n/// // Nonexistent value (or_insert)\n/// table\n///     .entry(hasher(&"e"), |&x| x == "e", hasher)\n///     .or_insert("e");\n///\n/// println!("Our HashTable: {:?}", table);\n///\n/// let mut vec: Vec<_> = table.iter().copied().collect();\n/// // The `Iter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, ["a", "b", "c", "d", "e"]);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub enum Entry<\'a, T, A = Global>\nwhere\n    A: Allocator,\n{\n    /// An occupied entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::hash_table::{Entry, OccupiedEntry};\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    /// for x in ["a", "b"] {\n    ///     table.insert_unique(hasher(&x), x, hasher);\n    /// }\n    ///\n    /// match table.entry(hasher(&"a"), |&x| x == "a", hasher) {\n    ///     Entry::Vacant(_) => unreachable!(),\n    ///     Entry::Occupied(_) => {}\n    /// }\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    Occupied(OccupiedEntry<\'a, T, A>),\n\n    /// A vacant entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[cfg(feature = "nightly")]\n    /// # fn test() {\n    /// use hashbrown::hash_table::{Entry, OccupiedEntry};\n    /// use hashbrown::{HashTable, DefaultHashBuilder};\n    /// use std::hash::BuildHasher;\n    ///\n    /// let mut table = HashTable::<&str>::new();\n    /// let hasher = DefaultHashBuilder::default();\n    /// let hasher = |val: &_| hasher.hash_one(val);\n    ///\n    /// match table.entry(hasher(&"a"), |&x| x == "a", hasher) {\n    ///     Entry::Vacant(_) => {}\n    ///     Entry::Occupied(_) => unreachable!(),\n    /// }\n    /// # }\n    /// # fn main() {\n    /// #     #[cfg(feature = "nightly")]\n    /// #     test()\n    /// # }\n    /// ```\n    Vacant(VacantEntry<\'a, T, A>),\n}', 'Real(LocalPath("src/table.rs"))'], "table::Entry::<'a, T, A>::and_modify": ['/// Provides in-place mutable access to an occupied entry before any\n/// potential inserts into the table.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<(&str, u32)> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n///\n/// table\n///     .entry(\n///         hasher(&"poneyland"),\n///         |&(x, _)| x == "poneyland",\n///         |(k, _)| hasher(&k),\n///     )\n///     .and_modify(|(_, v)| *v += 1)\n///     .or_insert(("poneyland", 42));\n/// assert_eq!(\n///     table.find(hasher(&"poneyland"), |&(k, _)| k == "poneyland"),\n///     Some(&("poneyland", 42))\n/// );\n///\n/// table\n///     .entry(\n///         hasher(&"poneyland"),\n///         |&(x, _)| x == "poneyland",\n///         |(k, _)| hasher(&k),\n///     )\n///     .and_modify(|(_, v)| *v += 1)\n///     .or_insert(("poneyland", 42));\n/// assert_eq!(\n///     table.find(hasher(&"poneyland"), |&(k, _)| k == "poneyland"),\n///     Some(&("poneyland", 43))\n/// );\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn and_modify(self, f: impl FnOnce(&mut T)) -> Self{\n        match self {\n            Entry::Occupied(mut entry) => {\n                f(entry.get_mut());\n                Entry::Occupied(entry)\n            }\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "table::Entry::<'a, T, A>::insert": ['/// Sets the value of the entry, replacing any existing value if there is\n/// one, and returns an [`OccupiedEntry`].\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<&str> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n///\n/// let entry = table\n///     .entry(hasher(&"horseyland"), |&x| x == "horseyland", hasher)\n///     .insert("horseyland");\n///\n/// assert_eq!(entry.get(), &"horseyland");\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn insert(self, value: T) -> OccupiedEntry<\'a, T, A>{\n        match self {\n            Entry::Occupied(mut entry) => {\n                *entry.get_mut() = value;\n                entry\n            }\n            Entry::Vacant(entry) => entry.insert(value),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "table::Entry::<'a, T, A>::or_insert": ['/// Ensures a value is in the entry by inserting if it was vacant.\n///\n/// Returns an [`OccupiedEntry`] pointing to the now-occupied entry.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<&str> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n///\n/// // nonexistent key\n/// table\n///     .entry(hasher(&"poneyland"), |&x| x == "poneyland", hasher)\n///     .or_insert("poneyland");\n/// assert!(table\n///     .find(hasher(&"poneyland"), |&x| x == "poneyland")\n///     .is_some());\n///\n/// // existing key\n/// table\n///     .entry(hasher(&"poneyland"), |&x| x == "poneyland", hasher)\n///     .or_insert("poneyland");\n/// assert!(table\n///     .find(hasher(&"poneyland"), |&x| x == "poneyland")\n///     .is_some());\n/// assert_eq!(table.len(), 1);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn or_insert(self, default: T) -> OccupiedEntry<\'a, T, A>{\n        match self {\n            Entry::Occupied(entry) => entry,\n            Entry::Vacant(entry) => entry.insert(default),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "table::Entry::<'a, T, A>::or_insert_with": ['/// Ensures a value is in the entry by inserting the result of the default function if empty..\n///\n/// Returns an [`OccupiedEntry`] pointing to the now-occupied entry.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<String> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n///\n/// table\n///     .entry(hasher("poneyland"), |x| x == "poneyland", |val| hasher(val))\n///     .or_insert_with(|| "poneyland".to_string());\n///\n/// assert!(table\n///     .find(hasher(&"poneyland"), |x| x == "poneyland")\n///     .is_some());\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn or_insert_with(self, default: impl FnOnce() -> T) -> OccupiedEntry<\'a, T, A>{\n        match self {\n            Entry::Occupied(entry) => entry,\n            Entry::Vacant(entry) => entry.insert(default()),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::ExtractIf': ['/// A draining iterator over entries of a `HashTable` which don\'t satisfy the predicate `f`.\n///\n/// This `struct` is created by [`HashTable::extract_if`]. See its\n/// documentation for more.\n#[must_use = "Iterators are lazy unless consumed"]\npub struct ExtractIf<\'a, T, F, A: Allocator = Global> {\n    f: F,\n    inner: RawExtractIf<\'a, T, A>,\n}', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable': ["/// Low-level hash table with explicit hashing.\n///\n/// The primary use case for this type over [`HashMap`] or [`HashSet`] is to\n/// support types that do not implement the [`Hash`] and [`Eq`] traits, but\n/// instead require additional data not contained in the key itself to compute a\n/// hash and compare two elements for equality.\n///\n/// Examples of when this can be useful include:\n/// - An `IndexMap` implementation where indices into a `Vec` are stored as\n///   elements in a `HashTable<usize>`. Hashing and comparing the elements\n///   requires indexing the associated `Vec` to get the actual value referred to\n///   by the index.\n/// - Avoiding re-computing a hash when it is already known.\n/// - Mutating the key of an element in a way that doesn't affect its hash.\n///\n/// To achieve this, `HashTable` methods that search for an element in the table\n/// require a hash value and equality function to be explicitly passed in as\n/// arguments. The method will then iterate over the elements with the given\n/// hash and call the equality function on each of them, until a match is found.\n///\n/// In most cases, a `HashTable` will not be exposed directly in an API. It will\n/// instead be wrapped in a helper type which handles the work of calculating\n/// hash values and comparing elements.\n///\n/// Due to its low-level nature, this type provides fewer guarantees than\n/// [`HashMap`] and [`HashSet`]. Specifically, the API allows you to shoot\n/// yourself in the foot by having multiple elements with identical keys in the\n/// table. The table itself will still function correctly and lookups will\n/// arbitrarily return one of the matching elements. However you should avoid\n/// doing this because it changes the runtime of hash table operations from\n/// `O(1)` to `O(k)` where `k` is the number of duplicate entries.\n///\n/// [`HashMap`]: super::HashMap\n/// [`HashSet`]: super::HashSet\n/// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n/// [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\npub struct HashTable<T, A = Global>\nwhere\n    A: Allocator,\n{\n    pub(crate) raw: RawTable<T, A>,\n}", 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::allocation_size': ['/// Returns the total amount of memory allocated internally by the hash\n/// table, in bytes.\n///\n/// The returned number is informational only. It is intended to be\n/// primarily used for memory profiling.\n#[inline]\npub fn allocation_size(&self) -> usize{\n        self.raw.allocation_size()\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::allocator': ['/// Returns a reference to the underlying allocator.\npub fn allocator(&self) -> &A{\n        self.raw.allocator()\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::capacity': ['/// Returns the number of elements the table can hold without reallocating.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashTable;\n/// let table: HashTable<i32> = HashTable::with_capacity(100);\n/// assert!(table.capacity() >= 100);\n/// ```\npub fn capacity(&self) -> usize{\n        self.raw.capacity()\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::clear': ['/// Clears the table, removing all values.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut v = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// v.insert_unique(hasher(&1), 1, hasher);\n/// v.clear();\n/// assert!(v.is_empty());\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn clear(&mut self){\n        self.raw.clear();\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::drain': ['/// Clears the set, returning all elements in an iterator.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// for x in 1..=3 {\n///     table.insert_unique(hasher(&x), x, hasher);\n/// }\n/// assert!(!table.is_empty());\n///\n/// // print 1, 2, 3 in an arbitrary order\n/// for i in table.drain() {\n///     println!("{}", i);\n/// }\n///\n/// assert!(table.is_empty());\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn drain(&mut self) -> Drain<\'_, T, A>{\n        Drain {\n            inner: self.raw.drain(),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::entry': ['/// Returns an `Entry` for an entry in the table with the given hash\n/// and which satisfies the equality function passed.\n///\n/// This can be used to remove the entry from the table, or insert a new\n/// entry with the given hash if one doesn\'t already exist.\n///\n/// This method will call `eq` for all entries with the given hash, but may\n/// also call it for entries with a different hash. `eq` should only return\n/// true for the desired entry, at which point the search is stopped.\n///\n/// This method may grow the table in preparation for an insertion. Call\n/// [`HashTable::find_entry`] if this is undesirable.\n///\n/// `hasher` is called if entries need to be moved or copied to a new table.\n/// This must return the same hash value that each entry was inserted with.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::Entry;\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&1), (1, "a"), |val| hasher(&val.0));\n/// if let Entry::Occupied(entry) = table.entry(hasher(&1), |val| val.0 == 1, |val| hasher(&val.0))\n/// {\n///     entry.remove();\n/// }\n/// if let Entry::Vacant(entry) = table.entry(hasher(&2), |val| val.0 == 2, |val| hasher(&val.0)) {\n///     entry.insert((2, "b"));\n/// }\n/// assert_eq!(table.find(hasher(&1), |val| val.0 == 1), None);\n/// assert_eq!(table.find(hasher(&2), |val| val.0 == 2), Some(&(2, "b")));\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\ninline\npub fn entry(\n        &mut self,\n        hash: u64,\n        eq: impl FnMut(&T) -> bool,\n        hasher: impl Fn(&T) -> u64,\n    ) -> Entry<\'_, T, A>{\n        match self.raw.find_or_find_insert_slot(hash, eq, hasher) {\n            Ok(bucket) => Entry::Occupied(OccupiedEntry {\n                hash,\n                bucket,\n                table: self,\n            }),\n            Err(insert_slot) => Entry::Vacant(VacantEntry {\n                hash,\n                insert_slot,\n                table: self,\n            }),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::extract_if': ['/// Drains elements which are true under the given predicate,\n/// and returns an iterator over the removed items.\n///\n/// In other words, move all elements `e` such that `f(&e)` returns `true` out\n/// into another iterator.\n///\n/// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n/// or the iteration short-circuits, then the remaining elements will be retained.\n/// Use [`retain()`] with a negated predicate if you do not need the returned iterator.\n///\n/// [`retain()`]: HashTable::retain\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// for x in 0..8 {\n///     table.insert_unique(hasher(&x), x, hasher);\n/// }\n/// let drained: Vec<i32> = table.extract_if(|&mut v| v % 2 == 0).collect();\n///\n/// let mut evens = drained.into_iter().collect::<Vec<_>>();\n/// let mut odds = table.into_iter().collect::<Vec<_>>();\n/// evens.sort();\n/// odds.sort();\n///\n/// assert_eq!(evens, vec![0, 2, 4, 6]);\n/// assert_eq!(odds, vec![1, 3, 5, 7]);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn extract_if<F>(&mut self, f: F) -> ExtractIf<\'_, T, F, A>\n    where\n        F: FnMut(&mut T) -> bool,{\n        ExtractIf {\n            f,\n            inner: RawExtractIf {\n                iter: unsafe { self.raw.iter() },\n                table: &mut self.raw,\n            },\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::find': ['/// Returns a reference to an entry in the table with the given hash and\n/// which satisfies the equality function passed.\n///\n/// This method will call `eq` for all entries with the given hash, but may\n/// also call it for entries with a different hash. `eq` should only return\n/// true for the desired entry, at which point the search is stopped.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&1), 1, hasher);\n/// table.insert_unique(hasher(&2), 2, hasher);\n/// table.insert_unique(hasher(&3), 3, hasher);\n/// assert_eq!(table.find(hasher(&2), |&val| val == 2), Some(&2));\n/// assert_eq!(table.find(hasher(&4), |&val| val == 4), None);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn find(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T>{\n        self.raw.get(hash, eq)\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::find_entry': ['/// Returns an `OccupiedEntry` for an entry in the table with the given hash\n/// and which satisfies the equality function passed.\n///\n/// This can be used to remove the entry from the table. Call\n/// [`HashTable::entry`] instead if you wish to insert an entry if the\n/// lookup fails.\n///\n/// This method will call `eq` for all entries with the given hash, but may\n/// also call it for entries with a different hash. `eq` should only return\n/// true for the desired entry, at which point the search is stopped.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&1), (1, "a"), |val| hasher(&val.0));\n/// if let Ok(entry) = table.find_entry(hasher(&1), |val| val.0 == 1) {\n///     entry.remove();\n/// }\n/// assert_eq!(table.find(hasher(&1), |val| val.0 == 1), None);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\ninline\npub fn find_entry(\n        &mut self,\n        hash: u64,\n        eq: impl FnMut(&T) -> bool,\n    ) -> Result<OccupiedEntry<\'_, T, A>, AbsentEntry<\'_, T, A>>{\n        match self.raw.find(hash, eq) {\n            Some(bucket) => Ok(OccupiedEntry {\n                hash,\n                bucket,\n                table: self,\n            }),\n            None => Err(AbsentEntry { table: self }),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::find_mut': ['/// Returns a mutable reference to an entry in the table with the given hash\n/// and which satisfies the equality function passed.\n///\n/// This method will call `eq` for all entries with the given hash, but may\n/// also call it for entries with a different hash. `eq` should only return\n/// true for the desired entry, at which point the search is stopped.\n///\n/// When mutating an entry, you should ensure that it still retains the same\n/// hash value as when it was inserted, otherwise lookups of that entry may\n/// fail to find it.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&1), (1, "a"), |val| hasher(&val.0));\n/// if let Some(val) = table.find_mut(hasher(&1), |val| val.0 == 1) {\n///     val.1 = "b";\n/// }\n/// assert_eq!(table.find(hasher(&1), |val| val.0 == 1), Some(&(1, "b")));\n/// assert_eq!(table.find(hasher(&2), |val| val.0 == 2), None);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn find_mut(&mut self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&mut T>{\n        self.raw.get_mut(hash, eq)\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::get_many_mut': ['/// Attempts to get mutable references to `N` values in the map at once.\n///\n/// The `eq` argument should be a closure such that `eq(i, k)` returns true if `k` is equal to\n/// the `i`th key to be looked up.\n///\n/// Returns an array of length `N` with the results of each query. For soundness, at most one\n/// mutable reference will be returned to any value. `None` will be used if the key is missing.\n///\n/// # Panics\n///\n/// Panics if any keys are overlapping.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::Entry;\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut libraries: HashTable<(&str, u32)> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// for (k, v) in [\n///     ("Bodleian Library", 1602),\n///     ("Athenum", 1807),\n///     ("Herzogin-Anna-Amalia-Bibliothek", 1691),\n///     ("Library of Congress", 1800),\n/// ] {\n///     libraries.insert_unique(hasher(&k), (k, v), |(k, _)| hasher(&k));\n/// }\n///\n/// let keys = ["Athenum", "Library of Congress"];\n/// let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n/// assert_eq!(\n///     got,\n///     [Some(&mut ("Athenum", 1807)), Some(&mut ("Library of Congress", 1800))],\n/// );\n///\n/// // Missing keys result in None\n/// let keys = ["Athenum", "New York Public Library"];\n/// let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n/// assert_eq!(got, [Some(&mut ("Athenum", 1807)), None]);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\n///\n/// ```should_panic\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// # use hashbrown::{HashTable, DefaultHashBuilder};\n/// # use std::hash::BuildHasher;\n///\n/// let mut libraries: HashTable<(&str, u32)> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// for (k, v) in [\n///     ("Athenum", 1807),\n///     ("Library of Congress", 1800),\n/// ] {\n///     libraries.insert_unique(hasher(&k), (k, v), |(k, _)| hasher(&k));\n/// }\n///\n/// // Duplicate keys result in a panic!\n/// let keys = ["Athenum", "Athenum"];\n/// let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test();\n/// #     #[cfg(not(feature = "nightly"))]\n/// #     panic!();\n/// # }\n/// ```\npub fn get_many_mut<const N: usize>(\n        &mut self,\n        hashes: [u64; N],\n        eq: impl FnMut(usize, &T) -> bool,\n    ) -> [Option<&\'_ mut T>; N]{\n        self.raw.get_many_mut(hashes, eq)\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::get_many_unchecked_mut': ['/// Attempts to get mutable references to `N` values in the map at once, without validating that\n/// the values are unique.\n///\n/// The `eq` argument should be a closure such that `eq(i, k)` returns true if `k` is equal to\n/// the `i`th key to be looked up.\n///\n/// Returns an array of length `N` with the results of each query. `None` will be returned if\n/// any of the keys are missing.\n///\n/// For a safe alternative see [`get_many_mut`](`HashTable::get_many_mut`).\n///\n/// # Safety\n///\n/// Calling this method with overlapping keys is *[undefined behavior]* even if the resulting\n/// references are not used.\n///\n/// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::Entry;\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut libraries: HashTable<(&str, u32)> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// for (k, v) in [\n///     ("Bodleian Library", 1602),\n///     ("Athenum", 1807),\n///     ("Herzogin-Anna-Amalia-Bibliothek", 1691),\n///     ("Library of Congress", 1800),\n/// ] {\n///     libraries.insert_unique(hasher(&k), (k, v), |(k, _)| hasher(&k));\n/// }\n///\n/// let keys = ["Athenum", "Library of Congress"];\n/// let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n/// assert_eq!(\n///     got,\n///     [Some(&mut ("Athenum", 1807)), Some(&mut ("Library of Congress", 1800))],\n/// );\n///\n/// // Missing keys result in None\n/// let keys = ["Athenum", "New York Public Library"];\n/// let got = libraries.get_many_mut(keys.map(|k| hasher(&k)), |i, val| keys[i] == val.0);\n/// assert_eq!(got, [Some(&mut ("Athenum", 1807)), None]);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub unsafe fn get_many_unchecked_mut<const N: usize>(\n        &mut self,\n        hashes: [u64; N],\n        eq: impl FnMut(usize, &T) -> bool,\n    ) -> [Option<&\'_ mut T>; N]{\n        self.raw.get_many_unchecked_mut(hashes, eq)\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::insert_unique': ['/// Inserts an element into the `HashTable` with the given hash value, but\n/// without checking whether an equivalent element already exists within the\n/// table.\n///\n/// `hasher` is called if entries need to be moved or copied to a new table.\n/// This must return the same hash value that each entry was inserted with.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut v = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// v.insert_unique(hasher(&1), 1, hasher);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn insert_unique(\n        &mut self,\n        hash: u64,\n        value: T,\n        hasher: impl Fn(&T) -> u64,\n    ) -> OccupiedEntry<\'_, T, A>{\n        let bucket = self.raw.insert(hash, value, hasher);\n        OccupiedEntry {\n            hash,\n            bucket,\n            table: self,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::is_empty': ['/// Returns `true` if the set contains no elements.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// let mut v = HashTable::new();\n/// assert!(v.is_empty());\n/// v.insert_unique(hasher(&1), 1, hasher);\n/// assert!(!v.is_empty());\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn is_empty(&self) -> bool{\n        self.raw.is_empty()\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::iter': ['/// An iterator visiting all elements in arbitrary order.\n/// The iterator element type is `&\'a T`.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&"a"), "b", hasher);\n/// table.insert_unique(hasher(&"b"), "b", hasher);\n///\n/// // Will print in an arbitrary order.\n/// for x in table.iter() {\n///     println!("{}", x);\n/// }\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn iter(&self) -> Iter<\'_, T>{\n        Iter {\n            inner: unsafe { self.raw.iter() },\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::iter_hash': ['/// An iterator visiting all elements which may match a hash.\n/// The iterator element type is `&\'a T`.\n///\n/// This iterator may return elements from the table that have a hash value\n/// different than the one provided. You should always validate the returned\n/// values before using them.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&"a"), "a", hasher);\n/// table.insert_unique(hasher(&"a"), "b", hasher);\n/// table.insert_unique(hasher(&"b"), "c", hasher);\n///\n/// // Will print "a" and "b" (and possibly "c") in an arbitrary order.\n/// for x in table.iter_hash(hasher(&"a")) {\n///     println!("{}", x);\n/// }\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn iter_hash(&self, hash: u64) -> IterHash<\'_, T>{\n        IterHash {\n            inner: unsafe { self.raw.iter_hash(hash) },\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::iter_hash_mut': ['/// A mutable iterator visiting all elements which may match a hash.\n/// The iterator element type is `&\'a mut T`.\n///\n/// This iterator may return elements from the table that have a hash value\n/// different than the one provided. You should always validate the returned\n/// values before using them.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&1), 2, hasher);\n/// table.insert_unique(hasher(&1), 3, hasher);\n/// table.insert_unique(hasher(&2), 5, hasher);\n///\n/// // Update matching values\n/// for val in table.iter_hash_mut(hasher(&1)) {\n///     *val *= 2;\n/// }\n///\n/// assert_eq!(table.len(), 3);\n/// let mut vec: Vec<i32> = Vec::new();\n///\n/// for val in &table {\n///     println!("val: {}", val);\n///     vec.push(*val);\n/// }\n///\n/// // The values will contain 4 and 6 and may contain either 5 or 10.\n/// assert!(vec.contains(&4));\n/// assert!(vec.contains(&6));\n///\n/// assert_eq!(table.len(), 3);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn iter_hash_mut(&mut self, hash: u64) -> IterHashMut<\'_, T>{\n        IterHashMut {\n            inner: unsafe { self.raw.iter_hash(hash) },\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::iter_mut': ['/// An iterator visiting all elements in arbitrary order,\n/// with mutable references to the elements.\n/// The iterator element type is `&\'a mut T`.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&1), 1, hasher);\n/// table.insert_unique(hasher(&2), 2, hasher);\n/// table.insert_unique(hasher(&3), 3, hasher);\n///\n/// // Update all values\n/// for val in table.iter_mut() {\n///     *val *= 2;\n/// }\n///\n/// assert_eq!(table.len(), 3);\n/// let mut vec: Vec<i32> = Vec::new();\n///\n/// for val in &table {\n///     println!("val: {}", val);\n///     vec.push(*val);\n/// }\n///\n/// // The `Iter` iterator produces items in arbitrary order, so the\n/// // items must be sorted to test them against a sorted array.\n/// vec.sort_unstable();\n/// assert_eq!(vec, [2, 4, 6]);\n///\n/// assert_eq!(table.len(), 3);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn iter_mut(&mut self) -> IterMut<\'_, T>{\n        IterMut {\n            inner: unsafe { self.raw.iter() },\n            marker: PhantomData,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::len': ['/// Returns the number of elements in the table.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// let mut v = HashTable::new();\n/// assert_eq!(v.len(), 0);\n/// v.insert_unique(hasher(&1), 1, hasher);\n/// assert_eq!(v.len(), 1);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn len(&self) -> usize{\n        self.raw.len()\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::new_in': ['/// Creates an empty `HashTable` using the given allocator.\n///\n/// The hash table is initially created with a capacity of 0, so it will not allocate until it\n/// is first inserted into.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use bumpalo::Bump;\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let bump = Bump::new();\n/// let mut table = HashTable::new_in(&bump);\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n///\n/// // The created HashTable holds none elements\n/// assert_eq!(table.len(), 0);\n///\n/// // The created HashTable also doesn\'t allocate memory\n/// assert_eq!(table.capacity(), 0);\n///\n/// // Now we insert element inside created HashTable\n/// table.insert_unique(hasher(&"One"), "One", hasher);\n/// // We can see that the HashTable holds 1 element\n/// assert_eq!(table.len(), 1);\n/// // And it also allocates some capacity\n/// assert!(table.capacity() > 1);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub const fn new_in(alloc: A) -> Self{\n        Self {\n            raw: RawTable::new_in(alloc),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::reserve': ['/// Reserves capacity for at least `additional` more elements to be inserted\n/// in the `HashTable`. The collection may reserve more space to avoid\n/// frequent reallocations.\n///\n/// `hasher` is called if entries need to be moved or copied to a new table.\n/// This must return the same hash value that each entry was inserted with.\n///\n/// # Panics\n///\n/// Panics if the new capacity exceeds [`isize::MAX`] bytes and [`abort`] the program\n/// in case of allocation error. Use [`try_reserve`](HashTable::try_reserve) instead\n/// if you want to handle memory allocation failure.\n///\n/// [`isize::MAX`]: https://doc.rust-lang.org/std/primitive.isize.html\n/// [`abort`]: https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<i32> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.reserve(10, hasher);\n/// assert!(table.capacity() >= 10);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64){\n        self.raw.reserve(additional, hasher)\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::retain': ['/// Retains only the elements specified by the predicate.\n///\n/// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// for x in 1..=6 {\n///     table.insert_unique(hasher(&x), x, hasher);\n/// }\n/// table.retain(|&mut x| x % 2 == 0);\n/// assert_eq!(table.len(), 3);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn retain(&mut self, mut f: impl FnMut(&mut T) -> bool){\n        // Here we only use `iter` as a temporary, preventing use-after-free\n        unsafe {\n            for item in self.raw.iter() {\n                if !f(item.as_mut()) {\n                    self.raw.erase(item);\n                }\n            }\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::shrink_to': ['/// Shrinks the capacity of the table with a lower limit. It will drop\n/// down no lower than the supplied limit while maintaining the internal rules\n/// and possibly leaving some space in accordance with the resize policy.\n///\n/// `hasher` is called if entries need to be moved or copied to a new table.\n/// This must return the same hash value that each entry was inserted with.\n///\n/// Panics if the current capacity is smaller than the supplied\n/// minimum capacity.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::with_capacity(100);\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&1), 1, hasher);\n/// table.insert_unique(hasher(&2), 2, hasher);\n/// assert!(table.capacity() >= 100);\n/// table.shrink_to(10, hasher);\n/// assert!(table.capacity() >= 10);\n/// table.shrink_to(0, hasher);\n/// assert!(table.capacity() >= 2);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn shrink_to(&mut self, min_capacity: usize, hasher: impl Fn(&T) -> u64){\n        self.raw.shrink_to(min_capacity, hasher);\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::shrink_to_fit': ['/// Shrinks the capacity of the table as much as possible. It will drop\n/// down as much as possible while maintaining the internal rules\n/// and possibly leaving some space in accordance with the resize policy.\n///\n/// `hasher` is called if entries need to be moved or copied to a new table.\n/// This must return the same hash value that each entry was inserted with.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::with_capacity(100);\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&1), 1, hasher);\n/// table.insert_unique(hasher(&2), 2, hasher);\n/// assert!(table.capacity() >= 100);\n/// table.shrink_to_fit(hasher);\n/// assert!(table.capacity() >= 2);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn shrink_to_fit(&mut self, hasher: impl Fn(&T) -> u64){\n        self.raw.shrink_to(self.len(), hasher)\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::try_reserve': ['/// Tries to reserve capacity for at least `additional` more elements to be inserted\n/// in the given `HashTable`. The collection may reserve more space to avoid\n/// frequent reallocations.\n///\n/// `hasher` is called if entries need to be moved or copied to a new table.\n/// This must return the same hash value that each entry was inserted with.\n///\n/// # Errors\n///\n/// If the capacity overflows, or the allocator reports a failure, then an error\n/// is returned.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<i32> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table\n///     .try_reserve(10, hasher)\n///     .expect("why is the test harness OOMing on 10 bytes?");\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn try_reserve(\n        &mut self,\n        additional: usize,\n        hasher: impl Fn(&T) -> u64,\n    ) -> Result<(), TryReserveError>{\n        self.raw.try_reserve(additional, hasher)\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T, A>::with_capacity_in': ['/// Creates an empty `HashTable` with the specified capacity using the given allocator.\n///\n/// The hash table will be able to hold at least `capacity` elements without\n/// reallocating. If `capacity` is 0, the hash table will not allocate.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use bumpalo::Bump;\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let bump = Bump::new();\n/// let mut table = HashTable::with_capacity_in(5, &bump);\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n///\n/// // The created HashTable holds none elements\n/// assert_eq!(table.len(), 0);\n/// // But it can hold at least 5 elements without reallocating\n/// let empty_map_capacity = table.capacity();\n/// assert!(empty_map_capacity >= 5);\n///\n/// // Now we insert some 5 elements inside created HashTable\n/// table.insert_unique(hasher(&"One"), "One", hasher);\n/// table.insert_unique(hasher(&"Two"), "Two", hasher);\n/// table.insert_unique(hasher(&"Three"), "Three", hasher);\n/// table.insert_unique(hasher(&"Four"), "Four", hasher);\n/// table.insert_unique(hasher(&"Five"), "Five", hasher);\n///\n/// // We can see that the HashTable holds 5 elements\n/// assert_eq!(table.len(), 5);\n/// // But its capacity isn\'t changed\n/// assert_eq!(table.capacity(), empty_map_capacity)\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn with_capacity_in(capacity: usize, alloc: A) -> Self{\n        Self {\n            raw: RawTable::with_capacity_in(capacity, alloc),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T>::new': ['/// Creates an empty `HashTable`.\n///\n/// The hash table is initially created with a capacity of 0, so it will not allocate until it\n/// is first inserted into.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashTable;\n/// let mut table: HashTable<&str> = HashTable::new();\n/// assert_eq!(table.len(), 0);\n/// assert_eq!(table.capacity(), 0);\n/// ```\npub const fn new() -> Self{\n        Self {\n            raw: RawTable::new(),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::HashTable::<T>::with_capacity': ['/// Creates an empty `HashTable` with the specified capacity.\n///\n/// The hash table will be able to hold at least `capacity` elements without\n/// reallocating. If `capacity` is 0, the hash table will not allocate.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashTable;\n/// let mut table: HashTable<&str> = HashTable::with_capacity(10);\n/// assert_eq!(table.len(), 0);\n/// assert!(table.capacity() >= 10);\n/// ```\npub fn with_capacity(capacity: usize) -> Self{\n        Self {\n            raw: RawTable::with_capacity(capacity),\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::IntoIter': ['/// An owning iterator over the entries of a `HashTable` in arbitrary order.\n/// The iterator element type is `T`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`HashTable`]\n/// (provided by the [`IntoIterator`] trait). See its documentation for more.\n/// The table cannot be used after calling that method.\n///\n/// [`into_iter`]: struct.HashTable.html#method.into_iter\n/// [`HashTable`]: struct.HashTable.html\n/// [`IntoIterator`]: https://doc.rust-lang.org/core/iter/trait.IntoIterator.html\npub struct IntoIter<T, A = Global>\nwhere\n    A: Allocator,\n{\n    inner: RawIntoIter<T, A>,\n}', 'Real(LocalPath("src/table.rs"))'], 'table::Iter': ["/// An iterator over the entries of a `HashTable` in arbitrary order.\n/// The iterator element type is `&'a T`.\n///\n/// This `struct` is created by the [`iter`] method on [`HashTable`]. See its\n/// documentation for more.\n///\n/// [`iter`]: struct.HashTable.html#method.iter\n/// [`HashTable`]: struct.HashTable.html\npub struct Iter<'a, T> {\n    inner: RawIter<T>,\n    marker: PhantomData<&'a T>,\n}", 'Real(LocalPath("src/table.rs"))'], 'table::IterHash': ["/// An iterator over the entries of a `HashTable` that could match a given hash.\n/// The iterator element type is `&'a T`.\n///\n/// This `struct` is created by the [`iter_hash`] method on [`HashTable`]. See its\n/// documentation for more.\n///\n/// [`iter_hash`]: struct.HashTable.html#method.iter_hash\n/// [`HashTable`]: struct.HashTable.html\npub struct IterHash<'a, T> {\n    inner: RawIterHash<T>,\n    marker: PhantomData<&'a T>,\n}", 'Real(LocalPath("src/table.rs"))'], 'table::IterHashMut': ["/// A mutable iterator over the entries of a `HashTable` that could match a given hash.\n/// The iterator element type is `&'a mut T`.\n///\n/// This `struct` is created by the [`iter_hash_mut`] method on [`HashTable`]. See its\n/// documentation for more.\n///\n/// [`iter_hash_mut`]: struct.HashTable.html#method.iter_hash_mut\n/// [`HashTable`]: struct.HashTable.html\npub struct IterHashMut<'a, T> {\n    inner: RawIterHash<T>,\n    marker: PhantomData<&'a mut T>,\n}", 'Real(LocalPath("src/table.rs"))'], 'table::IterMut': ["/// A mutable iterator over the entries of a `HashTable` in arbitrary order.\n/// The iterator element type is `&'a mut T`.\n///\n/// This `struct` is created by the [`iter_mut`] method on [`HashTable`]. See its\n/// documentation for more.\n///\n/// [`iter_mut`]: struct.HashTable.html#method.iter_mut\n/// [`HashTable`]: struct.HashTable.html\npub struct IterMut<'a, T> {\n    inner: RawIter<T>,\n    marker: PhantomData<&'a mut T>,\n}", 'Real(LocalPath("src/table.rs"))'], 'table::OccupiedEntry': ['/// A view into an occupied entry in a `HashTable`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::{Entry, OccupiedEntry};\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// for x in ["a", "b", "c"] {\n///     table.insert_unique(hasher(&x), x, hasher);\n/// }\n/// assert_eq!(table.len(), 3);\n///\n/// let _entry_o: OccupiedEntry<_, _> = table.find_entry(hasher(&"a"), |&x| x == "a").unwrap();\n/// assert_eq!(table.len(), 3);\n///\n/// // Existing key\n/// match table.entry(hasher(&"a"), |&x| x == "a", hasher) {\n///     Entry::Vacant(_) => unreachable!(),\n///     Entry::Occupied(view) => {\n///         assert_eq!(view.get(), &"a");\n///     }\n/// }\n///\n/// assert_eq!(table.len(), 3);\n///\n/// // Existing key (take)\n/// match table.entry(hasher(&"c"), |&x| x == "c", hasher) {\n///     Entry::Vacant(_) => unreachable!(),\n///     Entry::Occupied(view) => {\n///         assert_eq!(view.remove().0, "c");\n///     }\n/// }\n/// assert_eq!(table.find(hasher(&"c"), |&x| x == "c"), None);\n/// assert_eq!(table.len(), 2);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub struct OccupiedEntry<\'a, T, A = Global>\nwhere\n    A: Allocator,\n{\n    hash: u64,\n    bucket: Bucket<T>,\n    table: &\'a mut HashTable<T, A>,\n}', 'Real(LocalPath("src/table.rs"))'], "table::OccupiedEntry::<'a, T, A>::get": ['/// Gets a reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::Entry;\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<&str> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&"poneyland"), "poneyland", hasher);\n///\n/// match table.entry(hasher(&"poneyland"), |&x| x == "poneyland", hasher) {\n///     Entry::Vacant(_) => panic!(),\n///     Entry::Occupied(entry) => assert_eq!(entry.get(), &"poneyland"),\n/// }\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\n#[inline]\npub fn get(&self) -> &T{\n        unsafe { self.bucket.as_ref() }\n    }', 'Real(LocalPath("src/table.rs"))'], "table::OccupiedEntry::<'a, T, A>::get_mut": ['/// Gets a mutable reference to the value in the entry.\n///\n/// If you need a reference to the `OccupiedEntry` which may outlive the\n/// destruction of the `Entry` value, see [`into_mut`].\n///\n/// [`into_mut`]: #method.into_mut\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::Entry;\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<(&str, u32)> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&"poneyland"), ("poneyland", 12), |(k, _)| hasher(&k));\n///\n/// assert_eq!(\n///     table.find(hasher(&"poneyland"), |&(x, _)| x == "poneyland",),\n///     Some(&("poneyland", 12))\n/// );\n///\n/// if let Entry::Occupied(mut o) = table.entry(\n///     hasher(&"poneyland"),\n///     |&(x, _)| x == "poneyland",\n///     |(k, _)| hasher(&k),\n/// ) {\n///     o.get_mut().1 += 10;\n///     assert_eq!(o.get().1, 22);\n///\n///     // We can use the same Entry multiple times.\n///     o.get_mut().1 += 2;\n/// }\n///\n/// assert_eq!(\n///     table.find(hasher(&"poneyland"), |&(x, _)| x == "poneyland",),\n///     Some(&("poneyland", 24))\n/// );\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\n#[inline]\npub fn get_mut(&mut self) -> &mut T{\n        unsafe { self.bucket.as_mut() }\n    }', 'Real(LocalPath("src/table.rs"))'], "table::OccupiedEntry::<'a, T, A>::into_mut": ['/// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n/// with a lifetime bound to the table itself.\n///\n/// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n///\n/// [`get_mut`]: #method.get_mut\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::Entry;\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<(&str, u32)> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// table.insert_unique(hasher(&"poneyland"), ("poneyland", 12), |(k, _)| hasher(&k));\n///\n/// assert_eq!(\n///     table.find(hasher(&"poneyland"), |&(x, _)| x == "poneyland",),\n///     Some(&("poneyland", 12))\n/// );\n///\n/// let value: &mut (&str, u32);\n/// match table.entry(\n///     hasher(&"poneyland"),\n///     |&(x, _)| x == "poneyland",\n///     |(k, _)| hasher(&k),\n/// ) {\n///     Entry::Occupied(entry) => value = entry.into_mut(),\n///     Entry::Vacant(_) => panic!(),\n/// }\n/// value.1 += 10;\n///\n/// assert_eq!(\n///     table.find(hasher(&"poneyland"), |&(x, _)| x == "poneyland",),\n///     Some(&("poneyland", 22))\n/// );\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub fn into_mut(self) -> &\'a mut T{\n        unsafe { self.bucket.as_mut() }\n    }', 'Real(LocalPath("src/table.rs"))'], "table::OccupiedEntry::<'a, T, A>::into_table": ["/// Converts the `OccupiedEntry` into a mutable reference to the underlying\n/// table.\npub fn into_table(self) -> &'a mut HashTable<T, A>{\n        self.table\n    }", 'Real(LocalPath("src/table.rs"))'], "table::OccupiedEntry::<'a, T, A>::remove": ['/// Takes the value out of the entry, and returns it along with a\n/// `VacantEntry` that can be used to insert another value with the same\n/// hash as the one that was just removed.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::Entry;\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<&str> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// // The table is empty\n/// assert!(table.is_empty() && table.capacity() == 0);\n///\n/// table.insert_unique(hasher(&"poneyland"), "poneyland", hasher);\n/// let capacity_before_remove = table.capacity();\n///\n/// if let Entry::Occupied(o) = table.entry(hasher(&"poneyland"), |&x| x == "poneyland", hasher) {\n///     assert_eq!(o.remove().0, "poneyland");\n/// }\n///\n/// assert!(table\n///     .find(hasher(&"poneyland"), |&x| x == "poneyland")\n///     .is_none());\n/// // Now table hold none elements but capacity is equal to the old one\n/// assert!(table.len() == 0 && table.capacity() == capacity_before_remove);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\ninline\npub fn remove(self) -> (T, VacantEntry<\'a, T, A>){\n        let (val, slot) = unsafe { self.table.raw.remove(self.bucket) };\n        (\n            val,\n            VacantEntry {\n                hash: self.hash,\n                insert_slot: slot,\n                table: self.table,\n            },\n        )\n    }', 'Real(LocalPath("src/table.rs"))'], 'table::VacantEntry': ['/// A view into a vacant entry in a `HashTable`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::{Entry, VacantEntry};\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<&str> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n///\n/// let entry_v: VacantEntry<_, _> = match table.entry(hasher(&"a"), |&x| x == "a", hasher) {\n///     Entry::Vacant(view) => view,\n///     Entry::Occupied(_) => unreachable!(),\n/// };\n/// entry_v.insert("a");\n/// assert!(table.find(hasher(&"a"), |&x| x == "a").is_some() && table.len() == 1);\n///\n/// // Nonexistent key (insert)\n/// match table.entry(hasher(&"b"), |&x| x == "b", hasher) {\n///     Entry::Vacant(view) => {\n///         view.insert("b");\n///     }\n///     Entry::Occupied(_) => unreachable!(),\n/// }\n/// assert!(table.find(hasher(&"b"), |&x| x == "b").is_some() && table.len() == 2);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\npub struct VacantEntry<\'a, T, A = Global>\nwhere\n    A: Allocator,\n{\n    hash: u64,\n    insert_slot: InsertSlot,\n    table: &\'a mut HashTable<T, A>,\n}', 'Real(LocalPath("src/table.rs"))'], "table::VacantEntry::<'a, T, A>::insert": ['/// Inserts a new element into the table with the hash that was used to\n/// obtain the `VacantEntry`.\n///\n/// An `OccupiedEntry` is returned for the newly inserted element.\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = "nightly")]\n/// # fn test() {\n/// use hashbrown::hash_table::Entry;\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table: HashTable<&str> = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n///\n/// if let Entry::Vacant(o) = table.entry(hasher(&"poneyland"), |&x| x == "poneyland", hasher) {\n///     o.insert("poneyland");\n/// }\n/// assert_eq!(\n///     table.find(hasher(&"poneyland"), |&x| x == "poneyland"),\n///     Some(&"poneyland")\n/// );\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = "nightly")]\n/// #     test()\n/// # }\n/// ```\n#[inline]\npub fn insert(self, value: T) -> OccupiedEntry<\'a, T, A>{\n        let bucket = unsafe {\n            self.table\n                .raw\n                .insert_in_slot(self.hash, self.insert_slot, value)\n        };\n        OccupiedEntry {\n            hash: self.hash,\n            bucket,\n            table: self.table,\n        }\n    }', 'Real(LocalPath("src/table.rs"))'], "table::VacantEntry::<'a, T, A>::into_table": ["/// Converts the `VacantEntry` into a mutable reference to the underlying\n/// table.\npub fn into_table(self) -> &'a mut HashTable<T, A>{\n        self.table\n    }", 'Real(LocalPath("src/table.rs"))'], 'util::invalid_mut': ['#[inline(always)]\n#[allow(clippy::useless_transmute)]\npub(crate) fn invalid_mut<T>(addr: usize) -> *mut T{\n    unsafe { core::mem::transmute(addr) }\n}', 'Real(LocalPath("src/util.rs"))']}, 'struct_constructor': {'&\'^0.Named(DefId(0:2705 ~ hashbrown[38f8]::raw::{impl#12}::ctrl_slice::\'_), "\'_") mut [control::tag::Tag]': ['ctrl_slice'], "&'static [control::tag::Tag; UnevaluatedConst { def: DefId(0:2511 ~ hashbrown[38f8]::control::group::sse2::{impl#0}::static_empty::{constant#0}), args: [] }]": ['static_empty'], '(&\'^0.Named(DefId(0:2845 ~ hashbrown[38f8]::map::{impl#5}::insert_unique_unchecked::\'_), "\'_") K/#0, &\'^0.Named(DefId(0:2845 ~ hashbrown[38f8]::map::{impl#5}::insert_unique_unchecked::\'_), "\'_") mut V/#1)': ['insert_unique_unchecked'], '(&\'^0.Named(DefId(0:3024 ~ hashbrown[38f8]::raw_entry::{impl#7}::get_key_value::\'_), "\'_") K/#1, &\'^0.Named(DefId(0:3024 ~ hashbrown[38f8]::raw_entry::{impl#7}::get_key_value::\'_), "\'_") V/#2)': ['get_key_value'], '(&\'^0.Named(DefId(0:3025 ~ hashbrown[38f8]::raw_entry::{impl#7}::get_key_value_mut::\'_), "\'_") mut K/#1, &\'^0.Named(DefId(0:3025 ~ hashbrown[38f8]::raw_entry::{impl#7}::get_key_value_mut::\'_), "\'_") mut V/#2)': ['get_key_value_mut'], "(&'a/#0 mut K/#1, &'a/#0 mut V/#2)": ['insert', 'insert_hashed_nocheck', 'insert_with_hasher', 'into_key_value', 'or_insert', 'or_insert_with'], '(K/#1, V/#2)': ['remove_entry'], '(T/#0, raw::InsertSlot)': ['remove'], "(T/#1, table::VacantEntry<'a/#0, T/#1, A/#2>)": ['remove'], '(core::ptr::NonNull<u8>, core::alloc::Layout)': ['allocation_info'], '(usize, control::tag::Tag)': ['prepare_insert_slot'], '(usize, core::option::Option<usize>)': ['size_hint'], '*mut control::tag::Tag': ['ctrl'], '*mut u8': ['bucket_ptr'], 'Alias(Opaque, AliasTy { args: [Q/#0, K/#1, \'^0.Named(DefId(0:2785 ~ hashbrown[38f8]::map::equivalent::\'_), "\'_")], def_id: DefId(0:2786 ~ hashbrown[38f8]::map::equivalent::{opaque#0}) })': ['equivalent'], 'Alias(Opaque, AliasTy { args: [Q/#0, K/#1, V/#2, \'^0.Named(DefId(0:2781 ~ hashbrown[38f8]::map::equivalent_key::\'_), "\'_")], def_id: DefId(0:2782 ~ hashbrown[38f8]::map::equivalent_key::{opaque#0}) })': ['equivalent_key'], 'Alias(Opaque, AliasTy { args: [Q/#0, V/#1, S/#2, \'^0.Named(DefId(0:2777 ~ hashbrown[38f8]::map::make_hasher::\'_), "\'_")], def_id: DefId(0:2778 ~ hashbrown[38f8]::map::make_hasher::{opaque#0}) })': ['make_hasher'], 'TryReserveError': ['alloc_err', 'capacity_overflow', 'clone'], '[core::option::Option<&\'^0.Named(DefId(0:2659 ~ hashbrown[38f8]::raw::{impl#8}::get_many_mut::\'_), "\'_") mut T/#0>; N/#2]': ['get_many_mut'], '[core::option::Option<&\'^0.Named(DefId(0:2662 ~ hashbrown[38f8]::raw::{impl#8}::get_many_unchecked_mut::\'_), "\'_") mut T/#0>; N/#2]': ['get_many_unchecked_mut'], '[core::option::Option<&\'^0.Named(DefId(0:2828 ~ hashbrown[38f8]::map::{impl#5}::get_many_mut::\'_), "\'_") mut V/#1>; N/#5]': ['get_many_mut'], '[core::option::Option<&\'^0.Named(DefId(0:2830 ~ hashbrown[38f8]::map::{impl#5}::get_many_unchecked_mut::\'_), "\'_") mut V/#1>; N/#5]': ['get_many_unchecked_mut'], '[core::option::Option<&\'^0.Named(DefId(0:2836 ~ hashbrown[38f8]::map::{impl#5}::get_many_mut_inner::\'_), "\'_") mut (K/#0, V/#1)>; N/#5]': ['get_many_mut_inner'], '[core::option::Option<&\'^0.Named(DefId(0:2838 ~ hashbrown[38f8]::map::{impl#5}::get_many_unchecked_mut_inner::\'_), "\'_") mut (K/#0, V/#1)>; N/#5]': ['get_many_unchecked_mut_inner'], '[core::option::Option<&\'^0.Named(DefId(0:3262 ~ hashbrown[38f8]::table::{impl#1}::get_many_mut::\'_), "\'_") mut T/#0>; N/#2]': ['get_many_mut'], '[core::option::Option<&\'^0.Named(DefId(0:3265 ~ hashbrown[38f8]::table::{impl#1}::get_many_unchecked_mut::\'_), "\'_") mut T/#0>; N/#2]': ['get_many_unchecked_mut'], '[core::option::Option<(&\'^0.Named(DefId(0:2832 ~ hashbrown[38f8]::map::{impl#5}::get_many_key_value_mut::\'_), "\'_") K/#0, &\'^0.Named(DefId(0:2832 ~ hashbrown[38f8]::map::{impl#5}::get_many_key_value_mut::\'_), "\'_") mut V/#1)>; N/#5]': ['get_many_key_value_mut'], '[core::option::Option<(&\'^0.Named(DefId(0:2834 ~ hashbrown[38f8]::map::{impl#5}::get_many_key_value_unchecked_mut::\'_), "\'_") K/#0, &\'^0.Named(DefId(0:2834 ~ hashbrown[38f8]::map::{impl#5}::get_many_key_value_unchecked_mut::\'_), "\'_") mut V/#1)>; N/#5]': ['get_many_key_value_unchecked_mut'], '[core::option::Option<core::ptr::NonNull<T/#0>>; N/#2]': ['get_many_mut_pointers'], '[u64; N/#5]': ['build_hashes_inner'], 'bool': ['any_bit_set', 'contains', 'contains_key', 'eq', 'insert', 'is_bucket_full', 'is_disjoint', 'is_empty', 'is_empty_singleton', 'is_full', 'is_in_same_group', 'is_special', 'is_subset', 'is_superset', 'remove', 'replace_bucket_with', 'special_is_empty'], 'control::bitmask::BitMask': ['clone', 'match_empty', 'match_empty_or_deleted', 'match_full', 'match_tag'], 'control::bitmask::BitMaskIter': ['clone', 'into_iter'], 'control::group::sse2::Group': ['clone', 'load', 'load_aligned'], 'control::tag::Tag': ['clone', 'full', 'replace_ctrl_hash'], 'core::option::Option': ['calculate_layout_for', 'capacity_to_buckets', 'find', 'find_inner', 'find_insert_slot_in_group', 'find_mut', 'from_hash', 'from_key', 'from_key_hashed_nocheck', 'get', 'get_inner', 'get_inner_mut', 'get_key_value', 'get_key_value_mut', 'get_mut', 'insert', 'into_allocation', 'lowest_set_bit', 'next', 'next_impl', 'remove', 'remove_entry', 'replace', 'search', 'take'], 'core::ptr::NonNull': ['as_non_null', 'data_end'], 'core::result::Result': ['do_alloc', 'fallible_with_capacity', 'find_entry', 'find_or_find_insert_slot', 'find_or_find_insert_slot_inner', 'fmt', 'new_uninitialized', 'prepare_resize', 'reserve_rehash', 'reserve_rehash_inner', 'resize', 'resize_inner', 'try_insert', 'try_reserve'], 'map::Drain': ['drain'], 'map::Entry': ['entry', 'replace_entry_with'], 'map::EntryRef': ['entry_ref'], 'map::ExtractIf': ['extract_if'], 'map::HashMap': ['clone', 'default', 'from', 'from_iter', 'new', 'new_in', 'with_capacity', 'with_capacity_and_hasher', 'with_capacity_and_hasher_in', 'with_capacity_in', 'with_hasher', 'with_hasher_in'], 'map::IntoIter': ['default', 'into_iter'], 'map::IntoKeys': ['default', 'into_keys'], 'map::IntoValues': ['default', 'into_values'], 'map::Iter': ['clone', 'default', 'into_iter', 'iter'], 'map::IterMut': ['default', 'into_iter', 'iter_mut'], 'map::Keys': ['clone', 'default', 'keys'], 'map::OccupiedEntry': ['insert', 'insert_entry'], 'map::Values': ['clone', 'default', 'values'], 'map::ValuesMut': ['default', 'values_mut'], 'raw::Bucket': ['bucket', 'clone', 'from_base_index', 'insert', 'insert_in_slot', 'next_n'], 'raw::Fallibility': ['clone'], 'raw::FullBucketsIndices': ['full_buckets_indices'], 'raw::InsertSlot': ['find_insert_slot', 'fix_insert_slot'], 'raw::ProbeSeq': ['clone', 'probe_seq'], 'raw::RawDrain': ['drain', 'drain_iter_from'], 'raw::RawIntoIter': ['default', 'into_iter', 'into_iter_from'], 'raw::RawIter': ['clone', 'default', 'iter'], 'raw::RawIterHash': ['clone', 'default', 'iter_hash', 'new'], 'raw::RawIterHashInner': ['clone', 'new'], 'raw::RawIterRange': ['clone', 'new'], 'raw::RawTable': ['clone', 'default', 'new', 'new_in', 'with_capacity', 'with_capacity_in'], 'raw::RawTableInner': ['new', 'with_capacity'], 'raw::TableLayout': ['clone', 'new'], 'raw_entry::RawEntryBuilder': ['raw_entry'], 'raw_entry::RawEntryBuilderMut': ['raw_entry_mut'], 'raw_entry::RawEntryMut': ['from_hash', 'from_key', 'from_key_hashed_nocheck', 'replace_entry_with', 'search'], 'raw_entry::RawOccupiedEntryMut': ['insert', 'insert_entry'], 'scopeguard::ScopeGuard': ['guard'], 'set::Difference': ['clone', 'difference'], 'set::Drain': ['drain'], 'set::Entry': ['entry'], 'set::ExtractIf': ['extract_if'], 'set::HashSet': ['bitand', 'bitor', 'bitxor', 'clone', 'default', 'from', 'from_iter', 'new', 'new_in', 'sub', 'with_capacity', 'with_capacity_and_hasher', 'with_capacity_and_hasher_in', 'with_capacity_in', 'with_hasher', 'with_hasher_in'], 'set::Intersection': ['clone', 'intersection'], 'set::IntoIter': ['default', 'into_iter'], 'set::Iter': ['clone', 'default', 'into_iter', 'iter'], 'set::OccupiedEntry': ['insert'], 'set::SymmetricDifference': ['clone', 'symmetric_difference'], 'set::Union': ['clone', 'union'], 'table::Drain': ['drain'], 'table::Entry': ['entry'], 'table::ExtractIf': ['extract_if'], 'table::HashTable': ['clone', 'default', 'new', 'new_in', 'with_capacity', 'with_capacity_in'], 'table::IntoIter': ['default', 'into_iter'], 'table::Iter': ['clone', 'default', 'into_iter', 'iter'], 'table::IterHash': ['clone', 'default', 'iter_hash'], 'table::IterHashMut': ['default', 'iter_hash_mut'], 'table::IterMut': ['default', 'into_iter', 'iter_mut'], 'table::OccupiedEntry': ['insert', 'insert_unique', 'or_insert', 'or_insert_with'], 'u64': ['make_hash'], 'usize': ['allocation_size', 'allocation_size_or_zero', 'bucket_index', 'buckets', 'capacity', 'h1', 'leading_zeros', 'len', 'nonzero_trailing_zeros', 'num_ctrl_bytes', 'offset_from', 'to_base_index', 'trailing_zeros']}, 'struct_to_trait': {'<T as raw::SizedTypeProperties>::T': ['raw::SizedTypeProperties'], 'TryReserveError': ['core::clone::Clone', 'core::cmp::Eq', 'core::cmp::PartialEq', 'core::fmt::Debug', 'core::marker::StructuralPartialEq'], 'control::bitmask::BitMask': ['core::clone::Clone', 'core::iter::IntoIterator', 'core::marker::Copy'], 'control::bitmask::BitMaskIter': ['core::clone::Clone', 'core::iter::Iterator'], 'control::group::sse2::Group': ['core::clone::Clone', 'core::marker::Copy'], 'control::tag::Tag': ['core::clone::Clone', 'core::cmp::Eq', 'core::cmp::PartialEq', 'core::fmt::Debug', 'core::marker::Copy', 'core::marker::StructuralPartialEq'], 'map::Drain': ['core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'map::Entry': ['core::fmt::Debug'], 'map::EntryRef': ['core::fmt::Debug'], 'map::ExtractIf': ['core::iter::FusedIterator', 'core::iter::Iterator'], 'map::HashMap': ['core::clone::Clone', 'core::cmp::Eq', 'core::cmp::PartialEq', 'core::convert::From', 'core::default::Default', 'core::fmt::Debug', 'core::iter::Extend', 'core::iter::FromIterator', 'core::iter::IntoIterator', 'core::ops::Index'], 'map::IntoIter': ['core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'map::IntoKeys': ['core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'map::IntoValues': ['core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'map::Iter': ['core::clone::Clone', 'core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'map::IterMut': ['core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator', 'core::marker::Send'], 'map::Keys': ['core::clone::Clone', 'core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'map::OccupiedEntry': ['core::fmt::Debug', 'core::marker::Send', 'core::marker::Sync'], 'map::OccupiedError': ['core::fmt::Debug', 'core::fmt::Display'], 'map::VacantEntry': ['core::fmt::Debug'], 'map::VacantEntryRef': ['core::fmt::Debug'], 'map::Values': ['core::clone::Clone', 'core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'map::ValuesMut': ['core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'raw::Bucket': ['core::clone::Clone', 'core::marker::Send'], 'raw::Fallibility': ['core::clone::Clone', 'core::marker::Copy'], 'raw::FullBucketsIndices': ['core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'raw::ProbeSeq': ['core::clone::Clone'], 'raw::RawDrain': ['core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator', 'core::marker::Send', 'core::marker::Sync', 'core::ops::Drop'], 'raw::RawIntoIter': ['core::default::Default', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator', 'core::marker::Send', 'core::marker::Sync', 'core::ops::Drop'], 'raw::RawIter': ['core::clone::Clone', 'core::default::Default', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'raw::RawIterHash': ['core::clone::Clone', 'core::default::Default', 'core::iter::Iterator'], 'raw::RawIterHashInner': ['core::clone::Clone', 'core::iter::Iterator'], 'raw::RawIterRange': ['core::clone::Clone', 'core::iter::FusedIterator', 'core::iter::Iterator', 'core::marker::Send', 'core::marker::Sync'], 'raw::RawTable': ['core::clone::Clone', 'core::default::Default', 'core::iter::IntoIterator', 'core::marker::Send', 'core::marker::Sync', 'core::ops::Drop', 'raw::RawTableClone'], 'raw::TableLayout': ['core::clone::Clone', 'core::marker::Copy'], 'raw_entry::RawEntryBuilder': ['core::fmt::Debug'], 'raw_entry::RawEntryBuilderMut': ['core::fmt::Debug'], 'raw_entry::RawEntryMut': ['core::fmt::Debug'], 'raw_entry::RawOccupiedEntryMut': ['core::fmt::Debug', 'core::marker::Send', 'core::marker::Sync'], 'raw_entry::RawVacantEntryMut': ['core::fmt::Debug'], 'scopeguard::ScopeGuard': ['core::ops::Deref', 'core::ops::DerefMut', 'core::ops::Drop'], 'set::Difference': ['core::clone::Clone', 'core::fmt::Debug', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'set::Drain': ['core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'set::Entry': ['core::fmt::Debug'], 'set::ExtractIf': ['core::iter::FusedIterator', 'core::iter::Iterator'], 'set::HashSet': ['core::clone::Clone', 'core::cmp::Eq', 'core::cmp::PartialEq', 'core::convert::From', 'core::default::Default', 'core::fmt::Debug', 'core::iter::Extend', 'core::iter::FromIterator', 'core::iter::IntoIterator', 'core::ops::BitAndAssign', 'core::ops::BitOrAssign', 'core::ops::BitXorAssign', 'core::ops::SubAssign'], 'set::Intersection': ['core::clone::Clone', 'core::fmt::Debug', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'set::IntoIter': ['core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'set::Iter': ['core::clone::Clone', 'core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'set::OccupiedEntry': ['core::fmt::Debug'], 'set::SymmetricDifference': ['core::clone::Clone', 'core::fmt::Debug', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'set::Union': ['core::clone::Clone', 'core::fmt::Debug', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'set::VacantEntry': ['core::fmt::Debug'], 'table::AbsentEntry': ['core::fmt::Debug'], 'table::Drain': ['core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'table::Entry': ['core::fmt::Debug'], 'table::ExtractIf': ['core::iter::FusedIterator', 'core::iter::Iterator'], 'table::HashTable': ['core::clone::Clone', 'core::default::Default', 'core::fmt::Debug', 'core::iter::IntoIterator'], 'table::IntoIter': ['core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'table::Iter': ['core::clone::Clone', 'core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'table::IterHash': ['core::clone::Clone', 'core::default::Default', 'core::fmt::Debug', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'table::IterHashMut': ['core::default::Default', 'core::fmt::Debug', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'table::IterMut': ['core::default::Default', 'core::fmt::Debug', 'core::iter::ExactSizeIterator', 'core::iter::FusedIterator', 'core::iter::Iterator'], 'table::OccupiedEntry': ['core::fmt::Debug', 'core::marker::Send', 'core::marker::Sync'], 'table::VacantEntry': ['core::fmt::Debug']}, 'targets': {"<&'a map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/map.rs"))', 'core::iter::IntoIterator'], "<&'a mut map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/map.rs"))', 'core::iter::IntoIterator'], "<&'a mut table::HashTable<T, A> as core::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/table.rs"))', 'core::iter::IntoIterator'], "<&'a set::HashSet<T, S, A> as core::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/set.rs"))', 'core::iter::IntoIterator'], "<&'a table::HashTable<T, A> as core::iter::IntoIterator>::into_iter": ['into_iter', 'Real(LocalPath("src/table.rs"))', 'core::iter::IntoIterator'], '<&set::HashSet<T, S, A> as core::ops::BitAnd<&set::HashSet<T, S, A>>>::bitand': ['bitand', 'Real(LocalPath("src/set.rs"))', 'core::ops::BitAnd'], '<&set::HashSet<T, S, A> as core::ops::BitOr<&set::HashSet<T, S, A>>>::bitor': ['bitor', 'Real(LocalPath("src/set.rs"))', 'core::ops::BitOr'], '<&set::HashSet<T, S, A> as core::ops::BitXor<&set::HashSet<T, S, A>>>::bitxor': ['bitxor', 'Real(LocalPath("src/set.rs"))', 'core::ops::BitXor'], '<&set::HashSet<T, S, A> as core::ops::Sub<&set::HashSet<T, S, A>>>::sub': ['sub', 'Real(LocalPath("src/set.rs"))', 'core::ops::Sub'], '<[control::tag::Tag] as control::tag::TagSliceExt>::fill_tag': ['fill_tag', 'Real(LocalPath("src/control/tag.rs"))', 'control::tag::TagSliceExt'], '<control::bitmask::BitMask as core::iter::IntoIterator>::into_iter': ['into_iter', 'Real(LocalPath("src/control/bitmask.rs"))', 'core::iter::IntoIterator'], '<control::bitmask::BitMaskIter as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/control/bitmask.rs"))', 'core::iter::Iterator'], '<control::tag::Tag as core::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/control/tag.rs"))', 'core::fmt::Debug'], "<map::Drain<'_, K, V, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::Drain<'_, K, V, A> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/map.rs"))', 'core::iter::ExactSizeIterator'], "<map::Drain<'_, K, V, A> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Drain<'_, K, V, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Drain<'_, K, V, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Entry<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::EntryRef<'_, '_, K, Q, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::ExtractIf<'_, K, V, F, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::ExtractIf<'_, K, V, F, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], '<map::HashMap<K, V, S, A> as core::clone::Clone>::clone': ['clone', 'Real(LocalPath("src/map.rs"))', 'core::clone::Clone'], '<map::HashMap<K, V, S, A> as core::clone::Clone>::clone_from': ['clone_from', 'Real(LocalPath("src/map.rs"))', 'core::clone::Clone'], '<map::HashMap<K, V, S, A> as core::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("src/map.rs"))', 'core::cmp::PartialEq'], '<map::HashMap<K, V, S, A> as core::default::Default>::default': ['default', 'Real(LocalPath("src/map.rs"))', 'core::default::Default'], '<map::HashMap<K, V, S, A> as core::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::HashMap<K, V, S, A> as core::iter::Extend<&'a (K, V)>>::extend": ['extend', 'Real(LocalPath("src/map.rs"))', 'core::iter::Extend'], "<map::HashMap<K, V, S, A> as core::iter::Extend<(&'a K, &'a V)>>::extend": ['extend', 'Real(LocalPath("src/map.rs"))', 'core::iter::Extend'], '<map::HashMap<K, V, S, A> as core::iter::Extend<(K, V)>>::extend': ['extend', 'Real(LocalPath("src/map.rs"))', 'core::iter::Extend'], '<map::HashMap<K, V, S, A> as core::iter::FromIterator<(K, V)>>::from_iter': ['from_iter', 'Real(LocalPath("src/map.rs"))', 'core::iter::FromIterator'], '<map::HashMap<K, V, S, A> as core::iter::IntoIterator>::into_iter': ['into_iter', 'Real(LocalPath("src/map.rs"))', 'core::iter::IntoIterator'], '<map::HashMap<K, V, S, A> as core::ops::Index<&Q>>::index': ['index', 'Real(LocalPath("src/map.rs"))', 'core::ops::Index'], '<map::HashMap<K, V, foldhash::fast::RandomState, A> as core::convert::From<[(K, V); N]>>::from': ['from', 'Real(LocalPath("src/map.rs"))', 'core::convert::From'], '<map::IntoIter<K, V, A> as core::default::Default>::default': ['default', 'Real(LocalPath("src/map.rs"))', 'core::default::Default'], '<map::IntoIter<K, V, A> as core::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], '<map::IntoIter<K, V, A> as core::iter::ExactSizeIterator>::len': ['len', 'Real(LocalPath("src/map.rs"))', 'core::iter::ExactSizeIterator'], '<map::IntoIter<K, V, A> as core::iter::Iterator>::fold': ['fold', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], '<map::IntoIter<K, V, A> as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], '<map::IntoIter<K, V, A> as core::iter::Iterator>::size_hint': ['size_hint', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], '<map::IntoKeys<K, V, A> as core::default::Default>::default': ['default', 'Real(LocalPath("src/map.rs"))', 'core::default::Default'], '<map::IntoKeys<K, V, A> as core::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], '<map::IntoKeys<K, V, A> as core::iter::ExactSizeIterator>::len': ['len', 'Real(LocalPath("src/map.rs"))', 'core::iter::ExactSizeIterator'], '<map::IntoKeys<K, V, A> as core::iter::Iterator>::fold': ['fold', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], '<map::IntoKeys<K, V, A> as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], '<map::IntoKeys<K, V, A> as core::iter::Iterator>::size_hint': ['size_hint', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], '<map::IntoValues<K, V, A> as core::default::Default>::default': ['default', 'Real(LocalPath("src/map.rs"))', 'core::default::Default'], '<map::IntoValues<K, V, A> as core::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], '<map::IntoValues<K, V, A> as core::iter::ExactSizeIterator>::len': ['len', 'Real(LocalPath("src/map.rs"))', 'core::iter::ExactSizeIterator'], '<map::IntoValues<K, V, A> as core::iter::Iterator>::fold': ['fold', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], '<map::IntoValues<K, V, A> as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], '<map::IntoValues<K, V, A> as core::iter::Iterator>::size_hint': ['size_hint', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Iter<'_, K, V> as core::clone::Clone>::clone": ['clone', 'Real(LocalPath("src/map.rs"))', 'core::clone::Clone'], "<map::Iter<'_, K, V> as core::default::Default>::default": ['default', 'Real(LocalPath("src/map.rs"))', 'core::default::Default'], "<map::Iter<'_, K, V> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::Iter<'_, K, V> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/map.rs"))', 'core::iter::ExactSizeIterator'], "<map::Iter<'a, K, V> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Iter<'a, K, V> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Iter<'a, K, V> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::IterMut<'_, K, V> as core::default::Default>::default": ['default', 'Real(LocalPath("src/map.rs"))', 'core::default::Default'], "<map::IterMut<'_, K, V> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::IterMut<'_, K, V> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/map.rs"))', 'core::iter::ExactSizeIterator'], "<map::IterMut<'a, K, V> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::IterMut<'a, K, V> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::IterMut<'a, K, V> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Keys<'_, K, V> as core::clone::Clone>::clone": ['clone', 'Real(LocalPath("src/map.rs"))', 'core::clone::Clone'], "<map::Keys<'_, K, V> as core::default::Default>::default": ['default', 'Real(LocalPath("src/map.rs"))', 'core::default::Default'], "<map::Keys<'_, K, V> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::Keys<'_, K, V> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/map.rs"))', 'core::iter::ExactSizeIterator'], "<map::Keys<'a, K, V> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Keys<'a, K, V> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Keys<'a, K, V> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::OccupiedEntry<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::OccupiedError<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::OccupiedError<'_, K, V, S, A> as core::fmt::Display>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Display'], "<map::VacantEntry<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::VacantEntryRef<'_, '_, K, Q, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::Values<'_, K, V> as core::clone::Clone>::clone": ['clone', 'Real(LocalPath("src/map.rs"))', 'core::clone::Clone'], "<map::Values<'_, K, V> as core::default::Default>::default": ['default', 'Real(LocalPath("src/map.rs"))', 'core::default::Default'], "<map::Values<'_, K, V> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::Values<'_, K, V> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/map.rs"))', 'core::iter::ExactSizeIterator'], "<map::Values<'a, K, V> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Values<'a, K, V> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::Values<'a, K, V> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::ValuesMut<'_, K, V> as core::default::Default>::default": ['default', 'Real(LocalPath("src/map.rs"))', 'core::default::Default'], "<map::ValuesMut<'_, K, V> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/map.rs"))', 'core::fmt::Debug'], "<map::ValuesMut<'_, K, V> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/map.rs"))', 'core::iter::ExactSizeIterator'], "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], "<map::ValuesMut<'a, K, V> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/map.rs"))', 'core::iter::Iterator'], '<raw::Bucket<T> as core::clone::Clone>::clone': ['clone', 'Real(LocalPath("src/raw/mod.rs"))', 'core::clone::Clone'], '<raw::FullBucketsIndices as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], '<raw::FullBucketsIndices as core::iter::Iterator>::size_hint': ['size_hint', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], "<raw::RawDrain<'_, T, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], "<raw::RawDrain<'_, T, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], "<raw::RawDrain<'_, T, A> as core::ops::Drop>::drop": ['drop', 'Real(LocalPath("src/raw/mod.rs"))', 'core::ops::Drop'], '<raw::RawIntoIter<T, A> as core::default::Default>::default': ['default', 'Real(LocalPath("src/raw/mod.rs"))', 'core::default::Default'], '<raw::RawIntoIter<T, A> as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], '<raw::RawIntoIter<T, A> as core::iter::Iterator>::size_hint': ['size_hint', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], '<raw::RawIntoIter<T, A> as core::ops::Drop>::drop': ['drop', 'Real(LocalPath("src/raw/mod.rs"))', 'core::ops::Drop'], '<raw::RawIter<T> as core::clone::Clone>::clone': ['clone', 'Real(LocalPath("src/raw/mod.rs"))', 'core::clone::Clone'], '<raw::RawIter<T> as core::default::Default>::default': ['default', 'Real(LocalPath("src/raw/mod.rs"))', 'core::default::Default'], '<raw::RawIter<T> as core::iter::Iterator>::fold': ['fold', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], '<raw::RawIter<T> as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], '<raw::RawIter<T> as core::iter::Iterator>::size_hint': ['size_hint', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], '<raw::RawIterHash<T> as core::clone::Clone>::clone': ['clone', 'Real(LocalPath("src/raw/mod.rs"))', 'core::clone::Clone'], '<raw::RawIterHash<T> as core::default::Default>::default': ['default', 'Real(LocalPath("src/raw/mod.rs"))', 'core::default::Default'], '<raw::RawIterHash<T> as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], '<raw::RawIterHashInner as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], '<raw::RawIterRange<T> as core::clone::Clone>::clone': ['clone', 'Real(LocalPath("src/raw/mod.rs"))', 'core::clone::Clone'], '<raw::RawIterRange<T> as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], '<raw::RawIterRange<T> as core::iter::Iterator>::size_hint': ['size_hint', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::Iterator'], '<raw::RawTable<T, A> as core::clone::Clone>::clone': ['clone', 'Real(LocalPath("src/raw/mod.rs"))', 'core::clone::Clone'], '<raw::RawTable<T, A> as core::clone::Clone>::clone_from': ['clone_from', 'Real(LocalPath("src/raw/mod.rs"))', 'core::clone::Clone'], '<raw::RawTable<T, A> as core::default::Default>::default': ['default', 'Real(LocalPath("src/raw/mod.rs"))', 'core::default::Default'], '<raw::RawTable<T, A> as core::iter::IntoIterator>::into_iter': ['into_iter', 'Real(LocalPath("src/raw/mod.rs"))', 'core::iter::IntoIterator'], '<raw::RawTable<T, A> as core::ops::Drop>::drop': ['drop', 'Real(LocalPath("src/raw/mod.rs"))', 'core::ops::Drop'], '<raw::RawTable<T, A> as raw::RawTableClone>::clone_from_spec': ['clone_from_spec', 'Real(LocalPath("src/raw/mod.rs"))', 'raw::RawTableClone'], "<raw_entry::RawEntryBuilder<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/raw_entry.rs"))', 'core::fmt::Debug'], "<raw_entry::RawEntryBuilderMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/raw_entry.rs"))', 'core::fmt::Debug'], "<raw_entry::RawEntryMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/raw_entry.rs"))', 'core::fmt::Debug'], "<raw_entry::RawOccupiedEntryMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/raw_entry.rs"))', 'core::fmt::Debug'], "<raw_entry::RawVacantEntryMut<'_, K, V, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/raw_entry.rs"))', 'core::fmt::Debug'], '<scopeguard::ScopeGuard<T, F> as core::ops::Deref>::deref': ['deref', 'Real(LocalPath("src/scopeguard.rs"))', 'core::ops::Deref'], '<scopeguard::ScopeGuard<T, F> as core::ops::DerefMut>::deref_mut': ['deref_mut', 'Real(LocalPath("src/scopeguard.rs"))', 'core::ops::DerefMut'], '<scopeguard::ScopeGuard<T, F> as core::ops::Drop>::drop': ['drop', 'Real(LocalPath("src/scopeguard.rs"))', 'core::ops::Drop'], "<set::Difference<'_, T, S, A> as core::clone::Clone>::clone": ['clone', 'Real(LocalPath("src/set.rs"))', 'core::clone::Clone'], "<set::Difference<'_, T, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], "<set::Difference<'a, T, S, A> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Difference<'a, T, S, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Difference<'a, T, S, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Drain<'_, K, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], "<set::Drain<'_, K, A> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/set.rs"))', 'core::iter::ExactSizeIterator'], "<set::Drain<'_, K, A> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Drain<'_, K, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Drain<'_, K, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Entry<'_, T, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], "<set::ExtractIf<'_, K, F, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::ExtractIf<'_, K, F, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], '<set::HashSet<T, S, A> as core::clone::Clone>::clone': ['clone', 'Real(LocalPath("src/set.rs"))', 'core::clone::Clone'], '<set::HashSet<T, S, A> as core::clone::Clone>::clone_from': ['clone_from', 'Real(LocalPath("src/set.rs"))', 'core::clone::Clone'], '<set::HashSet<T, S, A> as core::cmp::PartialEq>::eq': ['eq', 'Real(LocalPath("src/set.rs"))', 'core::cmp::PartialEq'], '<set::HashSet<T, S, A> as core::convert::From<map::HashMap<T, (), S, A>>>::from': ['from', 'Real(LocalPath("src/set.rs"))', 'core::convert::From'], '<set::HashSet<T, S, A> as core::default::Default>::default': ['default', 'Real(LocalPath("src/set.rs"))', 'core::default::Default'], '<set::HashSet<T, S, A> as core::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], "<set::HashSet<T, S, A> as core::iter::Extend<&'a T>>::extend": ['extend', 'Real(LocalPath("src/set.rs"))', 'core::iter::Extend'], '<set::HashSet<T, S, A> as core::iter::Extend<T>>::extend': ['extend', 'Real(LocalPath("src/set.rs"))', 'core::iter::Extend'], '<set::HashSet<T, S, A> as core::iter::FromIterator<T>>::from_iter': ['from_iter', 'Real(LocalPath("src/set.rs"))', 'core::iter::FromIterator'], '<set::HashSet<T, S, A> as core::iter::IntoIterator>::into_iter': ['into_iter', 'Real(LocalPath("src/set.rs"))', 'core::iter::IntoIterator'], '<set::HashSet<T, S, A> as core::ops::BitAndAssign<&set::HashSet<T, S, A>>>::bitand_assign': ['bitand_assign', 'Real(LocalPath("src/set.rs"))', 'core::ops::BitAndAssign'], '<set::HashSet<T, S, A> as core::ops::BitOrAssign<&set::HashSet<T, S, A>>>::bitor_assign': ['bitor_assign', 'Real(LocalPath("src/set.rs"))', 'core::ops::BitOrAssign'], '<set::HashSet<T, S, A> as core::ops::BitXorAssign<&set::HashSet<T, S, A>>>::bitxor_assign': ['bitxor_assign', 'Real(LocalPath("src/set.rs"))', 'core::ops::BitXorAssign'], '<set::HashSet<T, S, A> as core::ops::SubAssign<&set::HashSet<T, S, A>>>::sub_assign': ['sub_assign', 'Real(LocalPath("src/set.rs"))', 'core::ops::SubAssign'], '<set::HashSet<T, foldhash::fast::RandomState, A> as core::convert::From<[T; N]>>::from': ['from', 'Real(LocalPath("src/set.rs"))', 'core::convert::From'], "<set::Intersection<'_, T, S, A> as core::clone::Clone>::clone": ['clone', 'Real(LocalPath("src/set.rs"))', 'core::clone::Clone'], "<set::Intersection<'_, T, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Intersection<'a, T, S, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], '<set::IntoIter<K, A> as core::default::Default>::default': ['default', 'Real(LocalPath("src/set.rs"))', 'core::default::Default'], '<set::IntoIter<K, A> as core::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], '<set::IntoIter<K, A> as core::iter::ExactSizeIterator>::len': ['len', 'Real(LocalPath("src/set.rs"))', 'core::iter::ExactSizeIterator'], '<set::IntoIter<K, A> as core::iter::Iterator>::fold': ['fold', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], '<set::IntoIter<K, A> as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], '<set::IntoIter<K, A> as core::iter::Iterator>::size_hint': ['size_hint', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Iter<'_, K> as core::clone::Clone>::clone": ['clone', 'Real(LocalPath("src/set.rs"))', 'core::clone::Clone'], "<set::Iter<'_, K> as core::default::Default>::default": ['default', 'Real(LocalPath("src/set.rs"))', 'core::default::Default'], "<set::Iter<'_, K> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], "<set::Iter<'_, K> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/set.rs"))', 'core::iter::ExactSizeIterator'], "<set::Iter<'a, K> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Iter<'a, K> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Iter<'a, K> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::OccupiedEntry<'_, T, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], "<set::SymmetricDifference<'_, T, S, A> as core::clone::Clone>::clone": ['clone', 'Real(LocalPath("src/set.rs"))', 'core::clone::Clone'], "<set::SymmetricDifference<'_, T, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::SymmetricDifference<'a, T, S, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Union<'_, T, S, A> as core::clone::Clone>::clone": ['clone', 'Real(LocalPath("src/set.rs"))', 'core::clone::Clone'], "<set::Union<'_, T, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], "<set::Union<'a, T, S, A> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Union<'a, T, S, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::Union<'a, T, S, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/set.rs"))', 'core::iter::Iterator'], "<set::VacantEntry<'_, T, S, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/set.rs"))', 'core::fmt::Debug'], "<table::AbsentEntry<'_, T, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], "<table::Drain<'_, T, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], "<table::Drain<'_, T, A> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/table.rs"))', 'core::iter::ExactSizeIterator'], "<table::Drain<'_, T, A> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::Drain<'_, T, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::Drain<'_, T, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::Entry<'_, T, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], "<table::ExtractIf<'_, T, F, A> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::ExtractIf<'_, T, F, A> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], '<table::HashTable<T, A> as core::clone::Clone>::clone': ['clone', 'Real(LocalPath("src/table.rs"))', 'core::clone::Clone'], '<table::HashTable<T, A> as core::default::Default>::default': ['default', 'Real(LocalPath("src/table.rs"))', 'core::default::Default'], '<table::HashTable<T, A> as core::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], '<table::HashTable<T, A> as core::iter::IntoIterator>::into_iter': ['into_iter', 'Real(LocalPath("src/table.rs"))', 'core::iter::IntoIterator'], '<table::IntoIter<T, A> as core::default::Default>::default': ['default', 'Real(LocalPath("src/table.rs"))', 'core::default::Default'], '<table::IntoIter<T, A> as core::fmt::Debug>::fmt': ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], '<table::IntoIter<T, A> as core::iter::ExactSizeIterator>::len': ['len', 'Real(LocalPath("src/table.rs"))', 'core::iter::ExactSizeIterator'], '<table::IntoIter<T, A> as core::iter::Iterator>::fold': ['fold', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], '<table::IntoIter<T, A> as core::iter::Iterator>::next': ['next', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], '<table::IntoIter<T, A> as core::iter::Iterator>::size_hint': ['size_hint', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::Iter<'_, T> as core::default::Default>::default": ['default', 'Real(LocalPath("src/table.rs"))', 'core::default::Default'], "<table::Iter<'_, T> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], "<table::Iter<'_, T> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/table.rs"))', 'core::iter::ExactSizeIterator'], "<table::Iter<'a, T> as core::clone::Clone>::clone": ['clone', 'Real(LocalPath("src/table.rs"))', 'core::clone::Clone'], "<table::Iter<'a, T> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::Iter<'a, T> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::Iter<'a, T> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::IterHash<'_, T> as core::default::Default>::default": ['default', 'Real(LocalPath("src/table.rs"))', 'core::default::Default'], "<table::IterHash<'_, T> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], "<table::IterHash<'a, T> as core::clone::Clone>::clone": ['clone', 'Real(LocalPath("src/table.rs"))', 'core::clone::Clone'], "<table::IterHash<'a, T> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::IterHash<'a, T> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::IterHashMut<'_, T> as core::default::Default>::default": ['default', 'Real(LocalPath("src/table.rs"))', 'core::default::Default'], "<table::IterHashMut<'_, T> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], "<table::IterHashMut<'a, T> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::IterHashMut<'a, T> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::IterMut<'_, T> as core::default::Default>::default": ['default', 'Real(LocalPath("src/table.rs"))', 'core::default::Default'], "<table::IterMut<'_, T> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], "<table::IterMut<'_, T> as core::iter::ExactSizeIterator>::len": ['len', 'Real(LocalPath("src/table.rs"))', 'core::iter::ExactSizeIterator'], "<table::IterMut<'a, T> as core::iter::Iterator>::fold": ['fold', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::IterMut<'a, T> as core::iter::Iterator>::next": ['next', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::IterMut<'a, T> as core::iter::Iterator>::size_hint": ['size_hint', 'Real(LocalPath("src/table.rs"))', 'core::iter::Iterator'], "<table::OccupiedEntry<'_, T, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], "<table::VacantEntry<'_, T, A> as core::fmt::Debug>::fmt": ['fmt', 'Real(LocalPath("src/table.rs"))', 'core::fmt::Debug'], 'control::bitmask::BitMask::any_bit_set': ['any_bit_set', 'Real(LocalPath("src/control/bitmask.rs"))', ''], 'control::bitmask::BitMask::invert': ['invert', 'Real(LocalPath("src/control/bitmask.rs"))', ''], 'control::bitmask::BitMask::leading_zeros': ['leading_zeros', 'Real(LocalPath("src/control/bitmask.rs"))', ''], 'control::bitmask::BitMask::lowest_set_bit': ['lowest_set_bit', 'Real(LocalPath("src/control/bitmask.rs"))', ''], 'control::bitmask::BitMask::nonzero_trailing_zeros': ['nonzero_trailing_zeros', 'Real(LocalPath("src/control/bitmask.rs"))', ''], 'control::bitmask::BitMask::remove_lowest_bit': ['remove_lowest_bit', 'Real(LocalPath("src/control/bitmask.rs"))', ''], 'control::bitmask::BitMask::trailing_zeros': ['trailing_zeros', 'Real(LocalPath("src/control/bitmask.rs"))', ''], 'control::group::sse2::Group::convert_special_to_empty_and_full_to_deleted': ['convert_special_to_empty_and_full_to_deleted', 'Real(LocalPath("src/control/group/sse2.rs"))', ''], 'control::group::sse2::Group::load': ['load', 'Real(LocalPath("src/control/group/sse2.rs"))', ''], 'control::group::sse2::Group::load_aligned': ['load_aligned', 'Real(LocalPath("src/control/group/sse2.rs"))', ''], 'control::group::sse2::Group::match_empty': ['match_empty', 'Real(LocalPath("src/control/group/sse2.rs"))', ''], 'control::group::sse2::Group::match_empty_or_deleted': ['match_empty_or_deleted', 'Real(LocalPath("src/control/group/sse2.rs"))', ''], 'control::group::sse2::Group::match_full': ['match_full', 'Real(LocalPath("src/control/group/sse2.rs"))', ''], 'control::group::sse2::Group::match_tag': ['match_tag', 'Real(LocalPath("src/control/group/sse2.rs"))', ''], 'control::group::sse2::Group::static_empty': ['static_empty', 'Real(LocalPath("src/control/group/sse2.rs"))', ''], 'control::group::sse2::Group::store_aligned': ['store_aligned', 'Real(LocalPath("src/control/group/sse2.rs"))', ''], 'control::tag::Tag::full': ['full', 'Real(LocalPath("src/control/tag.rs"))', ''], 'control::tag::Tag::is_full': ['is_full', 'Real(LocalPath("src/control/tag.rs"))', ''], 'control::tag::Tag::is_special': ['is_special', 'Real(LocalPath("src/control/tag.rs"))', ''], 'control::tag::Tag::special_is_empty': ['special_is_empty', 'Real(LocalPath("src/control/tag.rs"))', ''], 'control::tag::TagSliceExt::fill_empty': ['fill_empty', 'Real(LocalPath("src/control/tag.rs"))', ''], "map::Drain::<'_, K, V, A>::iter": ['iter', 'Real(LocalPath("src/map.rs"))', ''], "map::Entry::<'a, K, V, S, A>::and_modify": ['and_modify', 'Real(LocalPath("src/map.rs"))', ''], "map::Entry::<'a, K, V, S, A>::and_replace_entry_with": ['and_replace_entry_with', 'Real(LocalPath("src/map.rs"))', ''], "map::Entry::<'a, K, V, S, A>::insert": ['insert', 'Real(LocalPath("src/map.rs"))', ''], "map::Entry::<'a, K, V, S, A>::key": ['key', 'Real(LocalPath("src/map.rs"))', ''], "map::Entry::<'a, K, V, S, A>::or_default": ['or_default', 'Real(LocalPath("src/map.rs"))', ''], "map::Entry::<'a, K, V, S, A>::or_insert": ['or_insert', 'Real(LocalPath("src/map.rs"))', ''], "map::Entry::<'a, K, V, S, A>::or_insert_with": ['or_insert_with', 'Real(LocalPath("src/map.rs"))', ''], "map::Entry::<'a, K, V, S, A>::or_insert_with_key": ['or_insert_with_key', 'Real(LocalPath("src/map.rs"))', ''], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::and_modify": ['and_modify', 'Real(LocalPath("src/map.rs"))', ''], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::insert": ['insert', 'Real(LocalPath("src/map.rs"))', ''], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::key": ['key', 'Real(LocalPath("src/map.rs"))', ''], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_default": ['or_default', 'Real(LocalPath("src/map.rs"))', ''], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert": ['or_insert', 'Real(LocalPath("src/map.rs"))', ''], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert_with": ['or_insert_with', 'Real(LocalPath("src/map.rs"))', ''], "map::EntryRef::<'a, 'b, K, Q, V, S, A>::or_insert_with_key": ['or_insert_with_key', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::allocation_size': ['allocation_size', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::allocator': ['allocator', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::build_hashes_inner': ['build_hashes_inner', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::capacity': ['capacity', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::clear': ['clear', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::contains_key': ['contains_key', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::drain': ['drain', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::entry': ['entry', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::entry_ref': ['entry_ref', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::extract_if': ['extract_if', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::find_or_find_insert_slot': ['find_or_find_insert_slot', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get': ['get', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_inner': ['get_inner', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_inner_mut': ['get_inner_mut', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_key_value': ['get_key_value', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_key_value_mut': ['get_key_value_mut', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_many_key_value_mut': ['get_many_key_value_mut', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_many_key_value_unchecked_mut': ['get_many_key_value_unchecked_mut', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_many_mut': ['get_many_mut', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_many_mut_inner': ['get_many_mut_inner', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_many_unchecked_mut': ['get_many_unchecked_mut', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_many_unchecked_mut_inner': ['get_many_unchecked_mut_inner', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::get_mut': ['get_mut', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::hasher': ['hasher', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::insert': ['insert', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::insert_unique_unchecked': ['insert_unique_unchecked', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::into_keys': ['into_keys', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::into_values': ['into_values', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::is_empty': ['is_empty', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::iter': ['iter', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::iter_mut': ['iter_mut', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::keys': ['keys', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::len': ['len', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::remove': ['remove', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::remove_entry': ['remove_entry', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::reserve': ['reserve', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::retain': ['retain', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::shrink_to': ['shrink_to', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::shrink_to_fit': ['shrink_to_fit', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::try_insert': ['try_insert', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::try_reserve': ['try_reserve', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::values': ['values', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::values_mut': ['values_mut', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::with_capacity_and_hasher_in': ['with_capacity_and_hasher_in', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S, A>::with_hasher_in': ['with_hasher_in', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S>::with_capacity_and_hasher': ['with_capacity_and_hasher', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, S>::with_hasher': ['with_hasher', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, foldhash::fast::RandomState, A>::new_in': ['new_in', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V, foldhash::fast::RandomState, A>::with_capacity_in': ['with_capacity_in', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V>::new': ['new', 'Real(LocalPath("src/map.rs"))', ''], 'map::HashMap::<K, V>::with_capacity': ['with_capacity', 'Real(LocalPath("src/map.rs"))', ''], 'map::IntoIter::<K, V, A>::iter': ['iter', 'Real(LocalPath("src/map.rs"))', ''], "map::IterMut::<'_, K, V>::iter": ['iter', 'Real(LocalPath("src/map.rs"))', ''], "map::OccupiedEntry::<'a, K, V, S, A>::get": ['get', 'Real(LocalPath("src/map.rs"))', ''], "map::OccupiedEntry::<'a, K, V, S, A>::get_mut": ['get_mut', 'Real(LocalPath("src/map.rs"))', ''], "map::OccupiedEntry::<'a, K, V, S, A>::insert": ['insert', 'Real(LocalPath("src/map.rs"))', ''], "map::OccupiedEntry::<'a, K, V, S, A>::into_mut": ['into_mut', 'Real(LocalPath("src/map.rs"))', ''], "map::OccupiedEntry::<'a, K, V, S, A>::key": ['key', 'Real(LocalPath("src/map.rs"))', ''], "map::OccupiedEntry::<'a, K, V, S, A>::remove": ['remove', 'Real(LocalPath("src/map.rs"))', ''], "map::OccupiedEntry::<'a, K, V, S, A>::remove_entry": ['remove_entry', 'Real(LocalPath("src/map.rs"))', ''], "map::OccupiedEntry::<'a, K, V, S, A>::replace_entry_with": ['replace_entry_with', 'Real(LocalPath("src/map.rs"))', ''], "map::VacantEntry::<'a, K, V, S, A>::insert": ['insert', 'Real(LocalPath("src/map.rs"))', ''], "map::VacantEntry::<'a, K, V, S, A>::insert_entry": ['insert_entry', 'Real(LocalPath("src/map.rs"))', ''], "map::VacantEntry::<'a, K, V, S, A>::into_key": ['into_key', 'Real(LocalPath("src/map.rs"))', ''], "map::VacantEntry::<'a, K, V, S, A>::key": ['key', 'Real(LocalPath("src/map.rs"))', ''], "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::insert": ['insert', 'Real(LocalPath("src/map.rs"))', ''], "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::insert_entry": ['insert_entry', 'Real(LocalPath("src/map.rs"))', ''], "map::VacantEntryRef::<'a, 'b, K, Q, V, S, A>::key": ['key', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance': ['assert_covariance', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::drain': ['drain', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::into_iter_key': ['into_iter_key', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::into_iter_val': ['into_iter_val', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::iter_key': ['iter_key', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::iter_val': ['iter_val', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::keys_key': ['keys_key', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::keys_val': ['keys_val', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::map_key': ['map_key', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::map_val': ['map_val', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::values_key': ['values_key', 'Real(LocalPath("src/map.rs"))', ''], 'map::assert_covariance::values_val': ['values_val', 'Real(LocalPath("src/map.rs"))', ''], 'map::equivalent': ['equivalent', 'Real(LocalPath("src/map.rs"))', ''], 'map::equivalent_key': ['equivalent_key', 'Real(LocalPath("src/map.rs"))', ''], 'map::make_hash': ['make_hash', 'Real(LocalPath("src/map.rs"))', ''], 'map::make_hasher': ['make_hasher', 'Real(LocalPath("src/map.rs"))', ''], 'raw::Bucket::<T>::as_mut': ['as_mut', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Bucket::<T>::as_non_null': ['as_non_null', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Bucket::<T>::as_ptr': ['as_ptr', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Bucket::<T>::as_ref': ['as_ref', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Bucket::<T>::drop': ['drop', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Bucket::<T>::from_base_index': ['from_base_index', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Bucket::<T>::next_n': ['next_n', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Bucket::<T>::read': ['read', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Bucket::<T>::to_base_index': ['to_base_index', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Bucket::<T>::write': ['write', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Fallibility::alloc_err': ['alloc_err', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::Fallibility::capacity_overflow': ['capacity_overflow', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::FullBucketsIndices::next_impl': ['next_impl', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::ProbeSeq::move_next': ['move_next', 'Real(LocalPath("src/raw/mod.rs"))', ''], "raw::RawDrain::<'_, T, A>::iter": ['iter', 'Real(LocalPath("src/raw/mod.rs"))', ''], "raw::RawExtractIf::<'_, T, A>::next": ['next', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawIntoIter::<T, A>::iter': ['iter', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawIter::<T>::drop_elements': ['drop_elements', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawIterHash::<T>::new': ['new', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawIterHashInner::new': ['new', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawIterRange::<T>::fold_impl': ['fold_impl', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawIterRange::<T>::new': ['new', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawIterRange::<T>::next_impl': ['next_impl', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::allocation_size': ['allocation_size', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::allocator': ['allocator', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::bucket': ['bucket', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::bucket_index': ['bucket_index', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::buckets': ['buckets', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::capacity': ['capacity', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::clear': ['clear', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::clear_no_drop': ['clear_no_drop', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::clone_from_impl': ['clone_from_impl', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::data_end': ['data_end', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::drain': ['drain', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::drain_iter_from': ['drain_iter_from', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::erase': ['erase', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::erase_no_drop': ['erase_no_drop', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::find': ['find', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::find_or_find_insert_slot': ['find_or_find_insert_slot', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::get': ['get', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::get_many_mut': ['get_many_mut', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::get_many_mut_pointers': ['get_many_mut_pointers', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::get_many_unchecked_mut': ['get_many_unchecked_mut', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::get_mut': ['get_mut', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::insert': ['insert', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::insert_entry': ['insert_entry', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::insert_in_slot': ['insert_in_slot', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::into_allocation': ['into_allocation', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::into_iter_from': ['into_iter_from', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::is_bucket_full': ['is_bucket_full', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::is_empty': ['is_empty', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::iter': ['iter', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::iter_hash': ['iter_hash', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::len': ['len', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::new_in': ['new_in', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::new_uninitialized': ['new_uninitialized', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::remove': ['remove', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::remove_entry': ['remove_entry', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::replace_bucket_with': ['replace_bucket_with', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::reserve': ['reserve', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::reserve_rehash': ['reserve_rehash', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::resize': ['resize', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::shrink_to': ['shrink_to', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::try_reserve': ['try_reserve', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T, A>::with_capacity_in': ['with_capacity_in', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T>::new': ['new', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTable::<T>::with_capacity': ['with_capacity', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::allocation_info': ['allocation_info', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::allocation_size_or_zero': ['allocation_size_or_zero', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::bucket': ['bucket', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::bucket_ptr': ['bucket_ptr', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::buckets': ['buckets', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::clear_no_drop': ['clear_no_drop', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::ctrl': ['ctrl', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::ctrl_slice': ['ctrl_slice', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::data_end': ['data_end', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::drop_elements': ['drop_elements', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::drop_inner_table': ['drop_inner_table', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::erase': ['erase', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::fallible_with_capacity': ['fallible_with_capacity', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::find_inner': ['find_inner', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::find_insert_slot': ['find_insert_slot', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::find_insert_slot_in_group': ['find_insert_slot_in_group', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::find_or_find_insert_slot_inner': ['find_or_find_insert_slot_inner', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::fix_insert_slot': ['fix_insert_slot', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::free_buckets': ['free_buckets', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::full_buckets_indices': ['full_buckets_indices', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::is_bucket_full': ['is_bucket_full', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::is_empty_singleton': ['is_empty_singleton', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::is_in_same_group': ['is_in_same_group', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::iter': ['iter', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::new': ['new', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::new_uninitialized': ['new_uninitialized', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::num_ctrl_bytes': ['num_ctrl_bytes', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::prepare_insert_slot': ['prepare_insert_slot', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::prepare_rehash_in_place': ['prepare_rehash_in_place', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::prepare_resize': ['prepare_resize', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::probe_seq': ['probe_seq', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::record_item_insert_at': ['record_item_insert_at', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::rehash_in_place': ['rehash_in_place', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::replace_ctrl_hash': ['replace_ctrl_hash', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::reserve_rehash_inner': ['reserve_rehash_inner', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::resize_inner': ['resize_inner', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::set_ctrl': ['set_ctrl', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::set_ctrl_hash': ['set_ctrl_hash', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::RawTableInner::with_capacity': ['with_capacity', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::TableLayout::calculate_layout_for': ['calculate_layout_for', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::TableLayout::new': ['new', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::alloc::inner::do_alloc': ['do_alloc', 'Real(LocalPath("src/raw/alloc.rs"))', ''], 'raw::bucket_mask_to_capacity': ['bucket_mask_to_capacity', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::capacity_to_buckets': ['capacity_to_buckets', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::h1': ['h1', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw::offset_from': ['offset_from', 'Real(LocalPath("src/raw/mod.rs"))', ''], 'raw_entry::<impl map::HashMap<K, V, S, A>>::raw_entry': ['raw_entry', 'Real(LocalPath("src/raw_entry.rs"))', ''], 'raw_entry::<impl map::HashMap<K, V, S, A>>::raw_entry_mut': ['raw_entry_mut', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_hash": ['from_hash', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_key": ['from_key', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::from_key_hashed_nocheck": ['from_key_hashed_nocheck', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryBuilder::<'a, K, V, S, A>::search": ['search', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_hash": ['from_hash', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_key": ['from_key', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::from_key_hashed_nocheck": ['from_key_hashed_nocheck', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryBuilderMut::<'a, K, V, S, A>::search": ['search', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryMut::<'a, K, V, S, A>::and_modify": ['and_modify', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryMut::<'a, K, V, S, A>::and_replace_entry_with": ['and_replace_entry_with', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryMut::<'a, K, V, S, A>::insert": ['insert', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryMut::<'a, K, V, S, A>::or_insert": ['or_insert', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawEntryMut::<'a, K, V, S, A>::or_insert_with": ['or_insert_with', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get": ['get', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_key_value": ['get_key_value', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_key_value_mut": ['get_key_value_mut', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::get_mut": ['get_mut', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::insert": ['insert', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::insert_key": ['insert_key', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_key": ['into_key', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_key_value": ['into_key_value', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::into_mut": ['into_mut', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::key": ['key', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::key_mut": ['key_mut', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::remove": ['remove', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::remove_entry": ['remove_entry', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawOccupiedEntryMut::<'a, K, V, S, A>::replace_entry_with": ['replace_entry_with', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert": ['insert', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_entry": ['insert_entry', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_hashed_nocheck": ['insert_hashed_nocheck', 'Real(LocalPath("src/raw_entry.rs"))', ''], "raw_entry::RawVacantEntryMut::<'a, K, V, S, A>::insert_with_hasher": ['insert_with_hasher', 'Real(LocalPath("src/raw_entry.rs"))', ''], 'scopeguard::ScopeGuard::<T, F>::into_inner': ['into_inner', 'Real(LocalPath("src/scopeguard.rs"))', ''], 'scopeguard::guard': ['guard', 'Real(LocalPath("src/scopeguard.rs"))', ''], "set::Entry::<'a, T, S, A>::get": ['get', 'Real(LocalPath("src/set.rs"))', ''], "set::Entry::<'a, T, S, A>::insert": ['insert', 'Real(LocalPath("src/set.rs"))', ''], "set::Entry::<'a, T, S, A>::or_insert": ['or_insert', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::allocation_size': ['allocation_size', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::allocator': ['allocator', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::capacity': ['capacity', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::clear': ['clear', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::contains': ['contains', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::difference': ['difference', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::drain': ['drain', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::entry': ['entry', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::extract_if': ['extract_if', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::get': ['get', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::get_or_insert': ['get_or_insert', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::get_or_insert_with': ['get_or_insert_with', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::hasher': ['hasher', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::insert': ['insert', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::insert_unique_unchecked': ['insert_unique_unchecked', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::intersection': ['intersection', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::is_disjoint': ['is_disjoint', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::is_empty': ['is_empty', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::is_subset': ['is_subset', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::is_superset': ['is_superset', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::iter': ['iter', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::len': ['len', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::remove': ['remove', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::replace': ['replace', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::reserve': ['reserve', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::retain': ['retain', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::shrink_to': ['shrink_to', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::shrink_to_fit': ['shrink_to_fit', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::symmetric_difference': ['symmetric_difference', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::take': ['take', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::try_reserve': ['try_reserve', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::union': ['union', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::with_capacity_and_hasher_in': ['with_capacity_and_hasher_in', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S, A>::with_hasher_in': ['with_hasher_in', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S>::with_capacity_and_hasher': ['with_capacity_and_hasher', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, S>::with_hasher': ['with_hasher', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, foldhash::fast::RandomState, A>::new_in': ['new_in', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T, foldhash::fast::RandomState, A>::with_capacity_in': ['with_capacity_in', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T>::new': ['new', 'Real(LocalPath("src/set.rs"))', ''], 'set::HashSet::<T>::with_capacity': ['with_capacity', 'Real(LocalPath("src/set.rs"))', ''], "set::OccupiedEntry::<'_, T, S, A>::get": ['get', 'Real(LocalPath("src/set.rs"))', ''], "set::OccupiedEntry::<'_, T, S, A>::remove": ['remove', 'Real(LocalPath("src/set.rs"))', ''], "set::VacantEntry::<'a, T, S, A>::get": ['get', 'Real(LocalPath("src/set.rs"))', ''], "set::VacantEntry::<'a, T, S, A>::insert": ['insert', 'Real(LocalPath("src/set.rs"))', ''], "set::VacantEntry::<'a, T, S, A>::into_value": ['into_value', 'Real(LocalPath("src/set.rs"))', ''], 'set::assert_covariance': ['assert_covariance', 'Real(LocalPath("src/set.rs"))', ''], 'set::assert_covariance::difference': ['difference', 'Real(LocalPath("src/set.rs"))', ''], 'set::assert_covariance::drain': ['drain', 'Real(LocalPath("src/set.rs"))', ''], 'set::assert_covariance::intersection': ['intersection', 'Real(LocalPath("src/set.rs"))', ''], 'set::assert_covariance::into_iter': ['into_iter', 'Real(LocalPath("src/set.rs"))', ''], 'set::assert_covariance::iter': ['iter', 'Real(LocalPath("src/set.rs"))', ''], 'set::assert_covariance::set': ['set', 'Real(LocalPath("src/set.rs"))', ''], 'set::assert_covariance::symmetric_difference': ['symmetric_difference', 'Real(LocalPath("src/set.rs"))', ''], 'set::assert_covariance::union': ['union', 'Real(LocalPath("src/set.rs"))', ''], "table::AbsentEntry::<'a, T, A>::into_table": ['into_table', 'Real(LocalPath("src/table.rs"))', ''], "table::Entry::<'a, T, A>::and_modify": ['and_modify', 'Real(LocalPath("src/table.rs"))', ''], "table::Entry::<'a, T, A>::insert": ['insert', 'Real(LocalPath("src/table.rs"))', ''], "table::Entry::<'a, T, A>::or_insert": ['or_insert', 'Real(LocalPath("src/table.rs"))', ''], "table::Entry::<'a, T, A>::or_insert_with": ['or_insert_with', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::allocation_size': ['allocation_size', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::allocator': ['allocator', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::capacity': ['capacity', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::clear': ['clear', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::drain': ['drain', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::entry': ['entry', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::extract_if': ['extract_if', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::find': ['find', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::find_entry': ['find_entry', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::find_mut': ['find_mut', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::get_many_mut': ['get_many_mut', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::get_many_unchecked_mut': ['get_many_unchecked_mut', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::insert_unique': ['insert_unique', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::is_empty': ['is_empty', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::iter': ['iter', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::iter_hash': ['iter_hash', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::iter_hash_mut': ['iter_hash_mut', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::iter_mut': ['iter_mut', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::len': ['len', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::new_in': ['new_in', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::reserve': ['reserve', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::retain': ['retain', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::shrink_to': ['shrink_to', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::shrink_to_fit': ['shrink_to_fit', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::try_reserve': ['try_reserve', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T, A>::with_capacity_in': ['with_capacity_in', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T>::new': ['new', 'Real(LocalPath("src/table.rs"))', ''], 'table::HashTable::<T>::with_capacity': ['with_capacity', 'Real(LocalPath("src/table.rs"))', ''], "table::OccupiedEntry::<'a, T, A>::get": ['get', 'Real(LocalPath("src/table.rs"))', ''], "table::OccupiedEntry::<'a, T, A>::get_mut": ['get_mut', 'Real(LocalPath("src/table.rs"))', ''], "table::OccupiedEntry::<'a, T, A>::into_mut": ['into_mut', 'Real(LocalPath("src/table.rs"))', ''], "table::OccupiedEntry::<'a, T, A>::into_table": ['into_table', 'Real(LocalPath("src/table.rs"))', ''], "table::OccupiedEntry::<'a, T, A>::remove": ['remove', 'Real(LocalPath("src/table.rs"))', ''], "table::VacantEntry::<'a, T, A>::insert": ['insert', 'Real(LocalPath("src/table.rs"))', ''], "table::VacantEntry::<'a, T, A>::into_table": ['into_table', 'Real(LocalPath("src/table.rs"))', ''], 'util::invalid_mut': ['invalid_mut', 'Real(LocalPath("src/util.rs"))', '']}, 'trait_to_struct': {'core::clone::Clone': ['TryReserveError', 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter', 'control::group::sse2::Group', 'control::tag::Tag', 'map::HashMap', 'map::Iter', 'map::Keys', 'map::Values', 'raw::Bucket', 'raw::Fallibility', 'raw::ProbeSeq', 'raw::RawIter', 'raw::RawIterHash', 'raw::RawIterHashInner', 'raw::RawIterRange', 'raw::RawTable', 'raw::TableLayout', 'set::Difference', 'set::HashSet', 'set::Intersection', 'set::Iter', 'set::SymmetricDifference', 'set::Union', 'table::HashTable', 'table::Iter', 'table::IterHash'], 'core::cmp::Eq': ['TryReserveError', 'control::tag::Tag', 'map::HashMap', 'set::HashSet'], 'core::cmp::PartialEq': ['TryReserveError', 'control::tag::Tag', 'map::HashMap', 'set::HashSet'], 'core::convert::From': ['map::HashMap', 'set::HashSet'], 'core::default::Default': ['map::HashMap', 'map::IntoIter', 'map::IntoKeys', 'map::IntoValues', 'map::Iter', 'map::IterMut', 'map::Keys', 'map::Values', 'map::ValuesMut', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterHash', 'raw::RawTable', 'set::HashSet', 'set::IntoIter', 'set::Iter', 'table::HashTable', 'table::IntoIter', 'table::Iter', 'table::IterHash', 'table::IterHashMut', 'table::IterMut'], 'core::fmt::Debug': ['TryReserveError', 'control::tag::Tag', 'map::Drain', 'map::Entry', 'map::EntryRef', 'map::HashMap', 'map::IntoIter', 'map::IntoKeys', 'map::IntoValues', 'map::Iter', 'map::IterMut', 'map::Keys', 'map::OccupiedEntry', 'map::OccupiedError', 'map::VacantEntry', 'map::VacantEntryRef', 'map::Values', 'map::ValuesMut', 'raw_entry::RawEntryBuilder', 'raw_entry::RawEntryBuilderMut', 'raw_entry::RawEntryMut', 'raw_entry::RawOccupiedEntryMut', 'raw_entry::RawVacantEntryMut', 'set::Difference', 'set::Drain', 'set::Entry', 'set::HashSet', 'set::Intersection', 'set::IntoIter', 'set::Iter', 'set::OccupiedEntry', 'set::SymmetricDifference', 'set::Union', 'set::VacantEntry', 'table::AbsentEntry', 'table::Drain', 'table::Entry', 'table::HashTable', 'table::IntoIter', 'table::Iter', 'table::IterHash', 'table::IterHashMut', 'table::IterMut', 'table::OccupiedEntry', 'table::VacantEntry'], 'core::fmt::Display': ['map::OccupiedError'], 'core::iter::ExactSizeIterator': ['map::Drain', 'map::IntoIter', 'map::IntoKeys', 'map::IntoValues', 'map::Iter', 'map::IterMut', 'map::Keys', 'map::Values', 'map::ValuesMut', 'raw::FullBucketsIndices', 'raw::RawDrain', 'raw::RawIntoIter', 'raw::RawIter', 'set::Drain', 'set::IntoIter', 'set::Iter', 'table::Drain', 'table::IntoIter', 'table::Iter', 'table::IterMut'], 'core::iter::Extend': ['map::HashMap', 'set::HashSet'], 'core::iter::FromIterator': ['map::HashMap', 'set::HashSet'], 'core::iter::FusedIterator': ['map::Drain', 'map::ExtractIf', 'map::IntoIter', 'map::IntoKeys', 'map::IntoValues', 'map::Iter', 'map::IterMut', 'map::Keys', 'map::Values', 'map::ValuesMut', 'raw::FullBucketsIndices', 'raw::RawDrain', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterRange', 'set::Difference', 'set::Drain', 'set::ExtractIf', 'set::Intersection', 'set::IntoIter', 'set::Iter', 'set::SymmetricDifference', 'set::Union', 'table::Drain', 'table::ExtractIf', 'table::IntoIter', 'table::Iter', 'table::IterHash', 'table::IterHashMut', 'table::IterMut'], 'core::iter::IntoIterator': ['control::bitmask::BitMask', 'map::HashMap', 'raw::RawTable', 'set::HashSet', 'table::HashTable'], 'core::iter::Iterator': ['control::bitmask::BitMaskIter', 'map::Drain', 'map::ExtractIf', 'map::IntoIter', 'map::IntoKeys', 'map::IntoValues', 'map::Iter', 'map::IterMut', 'map::Keys', 'map::Values', 'map::ValuesMut', 'raw::FullBucketsIndices', 'raw::RawDrain', 'raw::RawIntoIter', 'raw::RawIter', 'raw::RawIterHash', 'raw::RawIterHashInner', 'raw::RawIterRange', 'set::Difference', 'set::Drain', 'set::ExtractIf', 'set::Intersection', 'set::IntoIter', 'set::Iter', 'set::SymmetricDifference', 'set::Union', 'table::Drain', 'table::ExtractIf', 'table::IntoIter', 'table::Iter', 'table::IterHash', 'table::IterHashMut', 'table::IterMut'], 'core::marker::Copy': ['control::bitmask::BitMask', 'control::group::sse2::Group', 'control::tag::Tag', 'raw::Fallibility', 'raw::TableLayout'], 'core::marker::Send': ['map::IterMut', 'map::OccupiedEntry', 'raw::Bucket', 'raw::RawDrain', 'raw::RawIntoIter', 'raw::RawIterRange', 'raw::RawTable', 'raw_entry::RawOccupiedEntryMut', 'table::OccupiedEntry'], 'core::marker::StructuralPartialEq': ['TryReserveError', 'control::tag::Tag'], 'core::marker::Sync': ['map::OccupiedEntry', 'raw::RawDrain', 'raw::RawIntoIter', 'raw::RawIterRange', 'raw::RawTable', 'raw_entry::RawOccupiedEntryMut', 'table::OccupiedEntry'], 'core::ops::BitAndAssign': ['set::HashSet'], 'core::ops::BitOrAssign': ['set::HashSet'], 'core::ops::BitXorAssign': ['set::HashSet'], 'core::ops::Deref': ['scopeguard::ScopeGuard'], 'core::ops::DerefMut': ['scopeguard::ScopeGuard'], 'core::ops::Drop': ['raw::RawDrain', 'raw::RawIntoIter', 'raw::RawTable', 'scopeguard::ScopeGuard'], 'core::ops::Index': ['map::HashMap'], 'core::ops::SubAssign': ['set::HashSet'], 'raw::RawTableClone': ['raw::RawTable'], 'raw::SizedTypeProperties': ['<T as raw::SizedTypeProperties>::T']}, 'type_to_def_path': {'TryReserveError': 'TryReserveError', 'control::bitmask::BitMask': 'control::bitmask::BitMask', 'control::bitmask::BitMaskIter': 'control::bitmask::BitMaskIter', 'control::group::sse2::Group': 'control::group::sse2::Group', 'control::group::sse2::Group::static_empty::AlignedTags': 'control::group::sse2::Group::static_empty::AlignedTags', 'control::tag::Tag': 'control::tag::Tag', "map::Drain<'a, K, V, A>": 'map::Drain', "map::Entry<'a, K, V, S, A>": 'map::Entry', "map::EntryRef<'a, 'b, K, Q, V, S, A>": 'map::EntryRef', "map::ExtractIf<'a, K, V, F, A>": 'map::ExtractIf', 'map::HashMap<K, V, S, A>': 'map::HashMap', 'map::IntoIter<K, V, A>': 'map::IntoIter', 'map::IntoKeys<K, V, A>': 'map::IntoKeys', 'map::IntoValues<K, V, A>': 'map::IntoValues', "map::Iter<'a, K, V>": 'map::Iter', "map::IterMut<'a, K, V>": 'map::IterMut', "map::Keys<'a, K, V>": 'map::Keys', "map::OccupiedEntry<'a, K, V, S, A>": 'map::OccupiedEntry', "map::OccupiedError<'a, K, V, S, A>": 'map::OccupiedError', "map::VacantEntry<'a, K, V, S, A>": 'map::VacantEntry', "map::VacantEntryRef<'a, 'b, K, Q, V, S, A>": 'map::VacantEntryRef', "map::Values<'a, K, V>": 'map::Values', "map::ValuesMut<'a, K, V>": 'map::ValuesMut', 'raw::Bucket<T>': 'raw::Bucket', 'raw::Fallibility': 'raw::Fallibility', 'raw::FullBucketsIndices': 'raw::FullBucketsIndices', 'raw::InsertSlot': 'raw::InsertSlot', 'raw::ProbeSeq': 'raw::ProbeSeq', "raw::RawDrain<'a, T, A>": 'raw::RawDrain', "raw::RawExtractIf<'a, T, A>": 'raw::RawExtractIf', 'raw::RawIntoIter<T, A>': 'raw::RawIntoIter', 'raw::RawIter<T>': 'raw::RawIter', 'raw::RawIterHash<T>': 'raw::RawIterHash', 'raw::RawIterHashInner': 'raw::RawIterHashInner', 'raw::RawIterRange<T>': 'raw::RawIterRange', 'raw::RawTable<T, A>': 'raw::RawTable', 'raw::RawTableInner': 'raw::RawTableInner', 'raw::TableLayout': 'raw::TableLayout', "raw_entry::RawEntryBuilder<'a, K, V, S, A>": 'raw_entry::RawEntryBuilder', "raw_entry::RawEntryBuilderMut<'a, K, V, S, A>": 'raw_entry::RawEntryBuilderMut', "raw_entry::RawEntryMut<'a, K, V, S, A>": 'raw_entry::RawEntryMut', "raw_entry::RawOccupiedEntryMut<'a, K, V, S, A>": 'raw_entry::RawOccupiedEntryMut', "raw_entry::RawVacantEntryMut<'a, K, V, S, A>": 'raw_entry::RawVacantEntryMut', 'scopeguard::ScopeGuard<T, F>': 'scopeguard::ScopeGuard', "set::Difference<'a, T, S, A>": 'set::Difference', "set::Drain<'a, K, A>": 'set::Drain', "set::Entry<'a, T, S, A>": 'set::Entry', "set::ExtractIf<'a, K, F, A>": 'set::ExtractIf', 'set::HashSet<T, S, A>': 'set::HashSet', "set::Intersection<'a, T, S, A>": 'set::Intersection', 'set::IntoIter<K, A>': 'set::IntoIter', "set::Iter<'a, K>": 'set::Iter', "set::OccupiedEntry<'a, T, S, A>": 'set::OccupiedEntry', "set::SymmetricDifference<'a, T, S, A>": 'set::SymmetricDifference', "set::Union<'a, T, S, A>": 'set::Union', "set::VacantEntry<'a, T, S, A>": 'set::VacantEntry', "table::AbsentEntry<'a, T, A>": 'table::AbsentEntry', "table::Drain<'a, T, A>": 'table::Drain', "table::Entry<'a, T, A>": 'table::Entry', "table::ExtractIf<'a, T, F, A>": 'table::ExtractIf', 'table::HashTable<T, A>': 'table::HashTable', 'table::IntoIter<T, A>': 'table::IntoIter', "table::Iter<'a, T>": 'table::Iter', "table::IterHash<'a, T>": 'table::IterHash', "table::IterHashMut<'a, T>": 'table::IterHashMut', "table::IterMut<'a, T>": 'table::IterMut', "table::OccupiedEntry<'a, T, A>": 'table::OccupiedEntry', "table::VacantEntry<'a, T, A>": 'table::VacantEntry'}}, 'hashbrown', 'hashbrown') finished, time: 5577.616280312999s
