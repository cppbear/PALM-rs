{"dependencies":{"<&'a StringWrapper<'b> as std::iter::IntoIterator>::into_iter":["StringWrapper"],"<GrowingHashmapChar<ValueType> as std::default::Default>::default":["GrowingHashmapChar","std::marker::Sized","std::option::Option"],"<GrowingHashmapMapElemChar<ValueType> as std::clone::Clone>::clone":["GrowingHashmapMapElemChar","std::marker::Sized"],"<GrowingHashmapMapElemChar<ValueType> as std::default::Default>::default":["GrowingHashmapMapElemChar","std::marker::Sized"],"<HybridGrowingHashmapChar<ValueType> as std::default::Default>::default":["GrowingHashmapChar","HybridGrowingHashmapChar","std::marker::Sized","std::option::Option"],"<RowId as std::clone::Clone>::clone":["RowId"],"<RowId as std::cmp::Eq>::assert_receiver_is_total_eq":["RowId"],"<RowId as std::cmp::PartialEq>::eq":["RowId"],"<RowId as std::default::Default>::default":["RowId"],"<StrSimError as std::cmp::PartialEq>::eq":["StrSimError"],"<StrSimError as std::fmt::Debug>::fmt":["StrSimError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<StrSimError as std::fmt::Display>::fmt":["StrSimError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"GrowingHashmapChar":["GrowingHashmapChar","std::marker::Sized","std::option::Option"],"GrowingHashmapChar::<ValueType>::allocate":["GrowingHashmapChar","std::marker::Sized","std::option::Option"],"GrowingHashmapChar::<ValueType>::get":["GrowingHashmapChar","std::marker::Sized","std::option::Option"],"GrowingHashmapChar::<ValueType>::get_mut":["GrowingHashmapChar","std::marker::Sized","std::option::Option"],"GrowingHashmapChar::<ValueType>::grow":["GrowingHashmapChar","std::marker::Sized","std::option::Option"],"GrowingHashmapChar::<ValueType>::lookup":["GrowingHashmapChar","std::marker::Sized","std::option::Option"],"GrowingHashmapMapElemChar":["GrowingHashmapMapElemChar","std::marker::Sized"],"HybridGrowingHashmapChar":["GrowingHashmapChar","HybridGrowingHashmapChar","std::marker::Sized","std::option::Option"],"HybridGrowingHashmapChar::<ValueType>::get":["GrowingHashmapChar","HybridGrowingHashmapChar","std::marker::Sized","std::option::Option"],"HybridGrowingHashmapChar::<ValueType>::get_mut":["GrowingHashmapChar","HybridGrowingHashmapChar","std::marker::Sized","std::option::Option"],"RowId":["RowId"],"StrSimError":["StrSimError"],"StringWrapper":["StringWrapper"],"bigrams":[],"damerau_levenshtein":[],"damerau_levenshtein_impl":["GrowingHashmapMapElemChar","std::clone::Clone","std::iter::Iterator","std::marker::Sized"],"flat_index":[],"generic_damerau_levenshtein":["GrowingHashmapMapElemChar","RowId","std::clone::Clone","std::cmp::Eq","std::hash::Hash","std::marker::Sized"],"generic_hamming":["RowId","std::cmp::PartialEq","std::iter::IntoIterator","std::marker::Sized","std::result::Result"],"generic_jaro":["RowId","std::cmp::PartialEq","std::iter::IntoIterator","std::marker::Sized"],"generic_jaro_winkler":["RowId","std::cmp::PartialEq","std::iter::IntoIterator","std::marker::Sized"],"generic_levenshtein":["RowId","std::cmp::PartialEq","std::iter::IntoIterator","std::marker::Sized"],"hamming":["std::marker::Sized","std::result::Result"],"jaro":[],"jaro_winkler":[],"levenshtein":[],"normalized_damerau_levenshtein":[],"normalized_levenshtein":[],"osa_distance":[],"sorensen_dice":[]},"glob_path_import":{},"self_to_fn":{"GrowingHashmapChar":["impl<ValueType> Default for GrowingHashmapChar<ValueType>\nwhere\n    ValueType: Default + Clone + Eq,\n{\n    fn default() -> Self {\n        Self {\n            used: 0,\n            fill: 0,\n            mask: -1,\n            map: None,\n        }\n    }\n}","impl<ValueType> GrowingHashmapChar<ValueType>\nwhere\n    ValueType: Default + Clone + Eq + Copy,\n{\n    fn get(&self, key: u32) -> ValueType {\n        self.map\n            .as_ref()\n            .map_or_else(|| Default::default(), |map| map[self.lookup(key)].value)\n    }\n\n    fn get_mut(&mut self, key: u32) -> &mut ValueType {\n        if self.map.is_none() {\n            self.allocate();\n        }\n\n        let mut i = self.lookup(key);\n        if self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\")[i]\n            .value\n            == Default::default()\n        {\n            self.fill += 1;\n            // resize when 2/3 full\n            if self.fill * 3 >= (self.mask + 1) * 2 {\n                self.grow((self.used + 1) * 2);\n                i = self.lookup(key);\n            }\n\n            self.used += 1;\n        }\n\n        let elem = &mut self\n            .map\n            .as_mut()\n            .expect(\"map should have been created above\")[i];\n        elem.key = key;\n        &mut elem.value\n    }\n\n    fn allocate(&mut self) {\n        self.mask = 8 - 1;\n        self.map = Some(vec![GrowingHashmapMapElemChar::default(); 8]);\n    }\n\n    /// lookup key inside the hashmap using a similar collision resolution\n    /// strategy to `CPython` and `Ruby`\n    fn lookup(&self, key: u32) -> usize {\n        let hash = key;\n        let mut i = hash as usize & self.mask as usize;\n\n        let map = self\n            .map\n            .as_ref()\n            .expect(\"callers have to ensure map is allocated\");\n\n        if map[i].value == Default::default() || map[i].key == key {\n            return i;\n        }\n\n        let mut perturb = key;\n        loop {\n            i = (i * 5 + perturb as usize + 1) & self.mask as usize;\n\n            if map[i].value == Default::default() || map[i].key == key {\n                return i;\n            }\n\n            perturb >>= 5;\n        }\n    }\n\n    fn grow(&mut self, min_used: i32) {\n        let mut new_size = self.mask + 1;\n        while new_size <= min_used {\n            new_size <<= 1;\n        }\n\n        self.fill = self.used;\n        self.mask = new_size - 1;\n\n        let old_map = std::mem::replace(\n            self.map\n                .as_mut()\n                .expect(\"callers have to ensure map is allocated\"),\n            vec![GrowingHashmapMapElemChar::<ValueType>::default(); new_size as usize],\n        );\n\n        for elem in old_map {\n            if elem.value != Default::default() {\n                let j = self.lookup(elem.key);\n                let new_elem = &mut self.map.as_mut().expect(\"map created above\")[j];\n                new_elem.key = elem.key;\n                new_elem.value = elem.value;\n                self.used -= 1;\n                if self.used == 0 {\n                    break;\n                }\n            }\n        }\n\n        self.used = self.fill;\n    }\n}"],"GrowingHashmapMapElemChar":["Clone","Default"],"HybridGrowingHashmapChar":["impl<ValueType> Default for HybridGrowingHashmapChar<ValueType>\nwhere\n    ValueType: Default + Clone + Copy + Eq,\n{\n    fn default() -> Self {\n        HybridGrowingHashmapChar {\n            map: GrowingHashmapChar::default(),\n            extended_ascii: [Default::default(); 256],\n        }\n    }\n}","impl<ValueType> HybridGrowingHashmapChar<ValueType>\nwhere\n    ValueType: Default + Clone + Copy + Eq,\n{\n    fn get(&self, key: char) -> ValueType {\n        let value = key as u32;\n        if value <= 255 {\n            let val_u8 = u8::try_from(value).expect(\"we check the bounds above\");\n            self.extended_ascii[usize::from(val_u8)]\n        } else {\n            self.map.get(value)\n        }\n    }\n\n    fn get_mut(&mut self, key: char) -> &mut ValueType {\n        let value = key as u32;\n        if value <= 255 {\n            let val_u8 = u8::try_from(value).expect(\"we check the bounds above\");\n            &mut self.extended_ascii[usize::from(val_u8)]\n        } else {\n            self.map.get_mut(value)\n        }\n    }\n}"],"RowId":["Clone","Copy","Eq","PartialEq","impl Default for RowId {\n    fn default() -> Self {\n        Self { val: -1 }\n    }\n}"],"StrSimError":["Debug","PartialEq","impl Display for StrSimError {\n    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result<(), fmt::Error> {\n        let text = match self {\n            StrSimError::DifferentLengthArgs => \"Differing length arguments provided\",\n        };\n\n        write!(fmt, \"{}\", text)\n    }\n}","impl Error for StrSimError {}"]},"single_path_import":{},"srcs":{"<&'a StringWrapper<'b> as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.0.chars()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<GrowingHashmapChar<ValueType> as std::default::Default>::default":["fn default() -> Self{\n        Self {\n            used: 0,\n            fill: 0,\n            mask: -1,\n            map: None,\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<HybridGrowingHashmapChar<ValueType> as std::default::Default>::default":["fn default() -> Self{\n        HybridGrowingHashmapChar {\n            map: GrowingHashmapChar::default(),\n            extended_ascii: [Default::default(); 256],\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<RowId as std::default::Default>::default":["fn default() -> Self{\n        Self { val: -1 }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<StrSimError as std::fmt::Display>::fmt":["fn fmt(&self, fmt: &mut Formatter<'_>) -> Result<(), fmt::Error>{\n        let text = match self {\n            StrSimError::DifferentLengthArgs => \"Differing length arguments provided\",\n        };\n\n        write!(fmt, \"{}\", text)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GrowingHashmapChar":["/// specialized hashmap to store user provided types\n/// this implementation relies on a couple of base assumptions in order to simplify the implementation\n/// - the hashmap does not have an upper limit of included items\n/// - the default value for the `ValueType` can be used as a dummy value to indicate an empty cell\n/// - elements can't be removed\n/// - only allocates memory on first write access.\n///   This improves performance for hashmaps that are never written to\nstruct GrowingHashmapChar<ValueType> {\n    used: i32,\n    fill: i32,\n    mask: i32,\n    map: Option<Vec<GrowingHashmapMapElemChar<ValueType>>>,\n}","Real(LocalPath(\"src/lib.rs\"))"],"GrowingHashmapChar::<ValueType>::allocate":["fn allocate(&mut self){\n        self.mask = 8 - 1;\n        self.map = Some(vec![GrowingHashmapMapElemChar::default(); 8]);\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GrowingHashmapChar::<ValueType>::get":["fn get(&self, key: u32) -> ValueType{\n        self.map\n            .as_ref()\n            .map_or_else(|| Default::default(), |map| map[self.lookup(key)].value)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GrowingHashmapChar::<ValueType>::get_mut":["fn get_mut(&mut self, key: u32) -> &mut ValueType{\n        if self.map.is_none() {\n            self.allocate();\n        }\n\n        let mut i = self.lookup(key);\n        if self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\")[i]\n            .value\n            == Default::default()\n        {\n            self.fill += 1;\n            // resize when 2/3 full\n            if self.fill * 3 >= (self.mask + 1) * 2 {\n                self.grow((self.used + 1) * 2);\n                i = self.lookup(key);\n            }\n\n            self.used += 1;\n        }\n\n        let elem = &mut self\n            .map\n            .as_mut()\n            .expect(\"map should have been created above\")[i];\n        elem.key = key;\n        &mut elem.value\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GrowingHashmapChar::<ValueType>::grow":["fn grow(&mut self, min_used: i32){\n        let mut new_size = self.mask + 1;\n        while new_size <= min_used {\n            new_size <<= 1;\n        }\n\n        self.fill = self.used;\n        self.mask = new_size - 1;\n\n        let old_map = std::mem::replace(\n            self.map\n                .as_mut()\n                .expect(\"callers have to ensure map is allocated\"),\n            vec![GrowingHashmapMapElemChar::<ValueType>::default(); new_size as usize],\n        );\n\n        for elem in old_map {\n            if elem.value != Default::default() {\n                let j = self.lookup(elem.key);\n                let new_elem = &mut self.map.as_mut().expect(\"map created above\")[j];\n                new_elem.key = elem.key;\n                new_elem.value = elem.value;\n                self.used -= 1;\n                if self.used == 0 {\n                    break;\n                }\n            }\n        }\n\n        self.used = self.fill;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GrowingHashmapChar::<ValueType>::lookup":["/// lookup key inside the hashmap using a similar collision resolution\n/// strategy to `CPython` and `Ruby`\nfn lookup(&self, key: u32) -> usize{\n        let hash = key;\n        let mut i = hash as usize & self.mask as usize;\n\n        let map = self\n            .map\n            .as_ref()\n            .expect(\"callers have to ensure map is allocated\");\n\n        if map[i].value == Default::default() || map[i].key == key {\n            return i;\n        }\n\n        let mut perturb = key;\n        loop {\n            i = (i * 5 + perturb as usize + 1) & self.mask as usize;\n\n            if map[i].value == Default::default() || map[i].key == key {\n                return i;\n            }\n\n            perturb >>= 5;\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"GrowingHashmapMapElemChar":["struct GrowingHashmapMapElemChar<ValueType> {\n    key: u32,\n    value: ValueType,\n}","Real(LocalPath(\"src/lib.rs\"))"],"HybridGrowingHashmapChar":["struct HybridGrowingHashmapChar<ValueType> {\n    map: GrowingHashmapChar<ValueType>,\n    extended_ascii: [ValueType; 256],\n}","Real(LocalPath(\"src/lib.rs\"))"],"HybridGrowingHashmapChar::<ValueType>::get":["fn get(&self, key: char) -> ValueType{\n        let value = key as u32;\n        if value <= 255 {\n            let val_u8 = u8::try_from(value).expect(\"we check the bounds above\");\n            self.extended_ascii[usize::from(val_u8)]\n        } else {\n            self.map.get(value)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"HybridGrowingHashmapChar::<ValueType>::get_mut":["fn get_mut(&mut self, key: char) -> &mut ValueType{\n        let value = key as u32;\n        if value <= 255 {\n            let val_u8 = u8::try_from(value).expect(\"we check the bounds above\");\n            &mut self.extended_ascii[usize::from(val_u8)]\n        } else {\n            self.map.get_mut(value)\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"RowId":["struct RowId {\n    val: isize,\n}","Real(LocalPath(\"src/lib.rs\"))"],"StrSimError":["pub enum StrSimError {\n    DifferentLengthArgs,\n}","Real(LocalPath(\"src/lib.rs\"))"],"StringWrapper":["struct StringWrapper<'a>(&'a str);","Real(LocalPath(\"src/lib.rs\"))"],"bigrams":["/// Returns an Iterator of char tuples.\nfn bigrams(s: &str) -> impl Iterator<Item = (char, char)> + '_{\n    s.chars().zip(s.chars().skip(1))\n}","Real(LocalPath(\"src/lib.rs\"))"],"damerau_levenshtein":["/// Like optimal string alignment, but substrings can be edited an unlimited\n/// number of times, and the triangle inequality holds.\n///\n/// ```\n/// use strsim::damerau_levenshtein;\n///\n/// assert_eq!(2, damerau_levenshtein(\"ab\", \"bca\"));\n/// ```\npub fn damerau_levenshtein(a: &str, b: &str) -> usize{\n    damerau_levenshtein_impl(a.chars(), a.chars().count(), b.chars(), b.chars().count())\n}","Real(LocalPath(\"src/lib.rs\"))"],"damerau_levenshtein_impl":["fn damerau_levenshtein_impl<Iter1, Iter2>(s1: Iter1, len1: usize, s2: Iter2, len2: usize) -> usize\nwhere\n    Iter1: Iterator<Item = char> + Clone,\n    Iter2: Iterator<Item = char> + Clone,{\n    // The implementations is based on the paper\n    // `Linear space string correction algorithm using the Damerau-Levenshtein distance`\n    // from Chunchun Zhao and Sartaj Sahni\n    //\n    // It has a runtime complexity of `O(N*M)` and a memory usage of `O(N+M)`.\n    let max_val = max(len1, len2) as isize + 1;\n\n    let mut last_row_id = HybridGrowingHashmapChar::<RowId>::default();\n\n    let size = len2 + 2;\n    let mut fr = vec![max_val; size];\n    let mut r1 = vec![max_val; size];\n    let mut r: Vec<isize> = (max_val..max_val + 1)\n        .chain(0..(size - 1) as isize)\n        .collect();\n\n    for (i, ch1) in s1.enumerate().map(|(i, ch1)| (i + 1, ch1)) {\n        mem::swap(&mut r, &mut r1);\n        let mut last_col_id: isize = -1;\n        let mut last_i2l1 = r[1];\n        r[1] = i as isize;\n        let mut t = max_val;\n\n        for (j, ch2) in s2.clone().enumerate().map(|(j, ch2)| (j + 1, ch2)) {\n            let diag = r1[j] + isize::from(ch1 != ch2);\n            let left = r[j] + 1;\n            let up = r1[j + 1] + 1;\n            let mut temp = min(diag, min(left, up));\n\n            if ch1 == ch2 {\n                last_col_id = j as isize; // last occurence of s1_i\n                fr[j + 1] = r1[j - 1]; // save H_k-1,j-2\n                t = last_i2l1; // save H_i-2,l-1\n            } else {\n                let k = last_row_id.get(ch2).val;\n                let l = last_col_id;\n\n                if j as isize - l == 1 {\n                    let transpose = fr[j + 1] + (i as isize - k);\n                    temp = min(temp, transpose);\n                } else if i as isize - k == 1 {\n                    let transpose = t + (j as isize - l);\n                    temp = min(temp, transpose);\n                }\n            }\n\n            last_i2l1 = r[j + 1];\n            r[j + 1] = temp;\n        }\n        last_row_id.get_mut(ch1).val = i as isize;\n    }\n\n    r[len2 + 1] as usize\n}","Real(LocalPath(\"src/lib.rs\"))"],"flat_index":["fn flat_index(i: usize, j: usize, width: usize) -> usize{\n    j * width + i\n}","Real(LocalPath(\"src/lib.rs\"))"],"generic_damerau_levenshtein":["/// Like optimal string alignment, but substrings can be edited an unlimited\n/// number of times, and the triangle inequality holds.\n///\n/// ```\n/// use strsim::generic_damerau_levenshtein;\n///\n/// assert_eq!(2, generic_damerau_levenshtein(&[1,2], &[2,3,1]));\n/// ```\npub fn generic_damerau_levenshtein<Elem>(a_elems: &[Elem], b_elems: &[Elem]) -> usize\nwhere\n    Elem: Eq + Hash + Clone,{\n    let a_len = a_elems.len();\n    let b_len = b_elems.len();\n\n    if a_len == 0 {\n        return b_len;\n    }\n    if b_len == 0 {\n        return a_len;\n    }\n\n    let width = a_len + 2;\n    let mut distances = vec![0; (a_len + 2) * (b_len + 2)];\n    let max_distance = a_len + b_len;\n    distances[0] = max_distance;\n\n    for i in 0..(a_len + 1) {\n        distances[flat_index(i + 1, 0, width)] = max_distance;\n        distances[flat_index(i + 1, 1, width)] = i;\n    }\n\n    for j in 0..(b_len + 1) {\n        distances[flat_index(0, j + 1, width)] = max_distance;\n        distances[flat_index(1, j + 1, width)] = j;\n    }\n\n    let mut elems: HashMap<Elem, usize> = HashMap::with_capacity(64);\n\n    for i in 1..(a_len + 1) {\n        let mut db = 0;\n\n        for j in 1..(b_len + 1) {\n            let k = match elems.get(&b_elems[j - 1]) {\n                Some(&value) => value,\n                None => 0,\n            };\n\n            let insertion_cost = distances[flat_index(i, j + 1, width)] + 1;\n            let deletion_cost = distances[flat_index(i + 1, j, width)] + 1;\n            let transposition_cost =\n                distances[flat_index(k, db, width)] + (i - k - 1) + 1 + (j - db - 1);\n\n            let mut substitution_cost = distances[flat_index(i, j, width)] + 1;\n            if a_elems[i - 1] == b_elems[j - 1] {\n                db = j;\n                substitution_cost -= 1;\n            }\n\n            distances[flat_index(i + 1, j + 1, width)] = min(\n                substitution_cost,\n                min(insertion_cost, min(deletion_cost, transposition_cost)),\n            );\n        }\n\n        elems.insert(a_elems[i - 1].clone(), i);\n    }\n\n    distances[flat_index(a_len + 1, b_len + 1, width)]\n}","Real(LocalPath(\"src/lib.rs\"))"],"generic_hamming":["/// Calculates the number of positions in the two sequences where the elements\n/// differ. Returns an error if the sequences have different lengths.\npub fn generic_hamming<Iter1, Iter2, Elem1, Elem2>(a: Iter1, b: Iter2) -> HammingResult\nwhere\n    Iter1: IntoIterator<Item = Elem1>,\n    Iter2: IntoIterator<Item = Elem2>,\n    Elem1: PartialEq<Elem2>,{\n    let (mut ita, mut itb) = (a.into_iter(), b.into_iter());\n    let mut count = 0;\n    loop {\n        match (ita.next(), itb.next()) {\n            (Some(x), Some(y)) => {\n                if x != y {\n                    count += 1;\n                }\n            }\n            (None, None) => return Ok(count),\n            _ => return Err(StrSimError::DifferentLengthArgs),\n        }\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"generic_jaro":["/// Calculates the Jaro similarity between two sequences. The returned value\n/// is between 0.0 and 1.0 (higher value means more similar).\npub fn generic_jaro<'a, 'b, Iter1, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> f64\nwhere\n    &'a Iter1: IntoIterator<Item = Elem1>,\n    &'b Iter2: IntoIterator<Item = Elem2>,\n    Elem1: PartialEq<Elem2>,{\n    let a_len = a.into_iter().count();\n    let b_len = b.into_iter().count();\n\n    if a_len == 0 && b_len == 0 {\n        return 1.0;\n    } else if a_len == 0 || b_len == 0 {\n        return 0.0;\n    }\n\n    let mut search_range = max(a_len, b_len) / 2;\n    search_range = search_range.saturating_sub(1);\n\n    // combine memory allocations to reduce runtime\n    let mut flags_memory = vec![false; a_len + b_len];\n    let (a_flags, b_flags) = flags_memory.split_at_mut(a_len);\n\n    let mut matches = 0_usize;\n\n    for (i, a_elem) in a.into_iter().enumerate() {\n        // prevent integer wrapping\n        let min_bound = if i > search_range {\n            i - search_range\n        } else {\n            0\n        };\n\n        let max_bound = min(b_len, i + search_range + 1);\n\n        for (j, b_elem) in b.into_iter().enumerate().take(max_bound) {\n            if min_bound <= j && a_elem == b_elem && !b_flags[j] {\n                a_flags[i] = true;\n                b_flags[j] = true;\n                matches += 1;\n                break;\n            }\n        }\n    }\n\n    let mut transpositions = 0_usize;\n    if matches != 0 {\n        let mut b_iter = b_flags.iter().zip(b);\n        for (a_flag, ch1) in a_flags.iter().zip(a) {\n            if *a_flag {\n                loop {\n                    if let Some((b_flag, ch2)) = b_iter.next() {\n                        if !*b_flag {\n                            continue;\n                        }\n\n                        if ch1 != ch2 {\n                            transpositions += 1;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    transpositions /= 2;\n\n    if matches == 0 {\n        0.0\n    } else {\n        ((matches as f64 / a_len as f64)\n            + (matches as f64 / b_len as f64)\n            + ((matches - transpositions) as f64 / matches as f64))\n            / 3.0\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"generic_jaro_winkler":["/// Like Jaro but gives a boost to sequences that have a common prefix.\npub fn generic_jaro_winkler<'a, 'b, Iter1, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> f64\nwhere\n    &'a Iter1: IntoIterator<Item = Elem1>,\n    &'b Iter2: IntoIterator<Item = Elem2>,\n    Elem1: PartialEq<Elem2>,{\n    let sim = generic_jaro(a, b);\n\n    if sim > 0.7 {\n        let prefix_length = a\n            .into_iter()\n            .take(4)\n            .zip(b)\n            .take_while(|(a_elem, b_elem)| a_elem == b_elem)\n            .count();\n\n        sim + 0.1 * prefix_length as f64 * (1.0 - sim)\n    } else {\n        sim\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"generic_levenshtein":["/// Calculates the minimum number of insertions, deletions, and substitutions\n/// required to change one sequence into the other.\n///\n/// ```\n/// use strsim::generic_levenshtein;\n///\n/// assert_eq!(3, generic_levenshtein(&[1,2,3], &[1,2,3,4,5,6]));\n/// ```\npub fn generic_levenshtein<'a, 'b, Iter1, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> usize\nwhere\n    &'a Iter1: IntoIterator<Item = Elem1>,\n    &'b Iter2: IntoIterator<Item = Elem2>,\n    Elem1: PartialEq<Elem2>,{\n    let b_len = b.into_iter().count();\n\n    let mut cache: Vec<usize> = (1..b_len + 1).collect();\n\n    let mut result = b_len;\n\n    for (i, a_elem) in a.into_iter().enumerate() {\n        result = i + 1;\n        let mut distance_b = i;\n\n        for (j, b_elem) in b.into_iter().enumerate() {\n            let cost = usize::from(a_elem != b_elem);\n            let distance_a = distance_b + cost;\n            distance_b = cache[j];\n            result = min(result + 1, min(distance_a, distance_b + 1));\n            cache[j] = result;\n        }\n    }\n\n    result\n}","Real(LocalPath(\"src/lib.rs\"))"],"hamming":["/// Calculates the number of positions in the two strings where the characters\n/// differ. Returns an error if the strings have different lengths.\n///\n/// ```\n/// use strsim::{hamming, StrSimError::DifferentLengthArgs};\n///\n/// assert_eq!(Ok(3), hamming(\"hamming\", \"hammers\"));\n///\n/// assert_eq!(Err(DifferentLengthArgs), hamming(\"hamming\", \"ham\"));\n/// ```\npub fn hamming(a: &str, b: &str) -> HammingResult{\n    generic_hamming(a.chars(), b.chars())\n}","Real(LocalPath(\"src/lib.rs\"))"],"jaro":["/// Calculates the Jaro similarity between two strings. The returned value\n/// is between 0.0 and 1.0 (higher value means more similar).\n///\n/// ```\n/// use strsim::jaro;\n///\n/// assert!((0.392 - jaro(\"Friedrich Nietzsche\", \"Jean-Paul Sartre\")).abs() <\n///         0.001);\n/// ```\npub fn jaro(a: &str, b: &str) -> f64{\n    generic_jaro(&StringWrapper(a), &StringWrapper(b))\n}","Real(LocalPath(\"src/lib.rs\"))"],"jaro_winkler":["/// Like Jaro but gives a boost to strings that have a common prefix.\n///\n/// ```\n/// use strsim::jaro_winkler;\n///\n/// assert!((0.866 - jaro_winkler(\"cheeseburger\", \"cheese fries\")).abs() <\n///         0.001);\n/// ```\npub fn jaro_winkler(a: &str, b: &str) -> f64{\n    generic_jaro_winkler(&StringWrapper(a), &StringWrapper(b))\n}","Real(LocalPath(\"src/lib.rs\"))"],"levenshtein":["/// Calculates the minimum number of insertions, deletions, and substitutions\n/// required to change one string into the other.\n///\n/// ```\n/// use strsim::levenshtein;\n///\n/// assert_eq!(3, levenshtein(\"kitten\", \"sitting\"));\n/// ```\npub fn levenshtein(a: &str, b: &str) -> usize{\n    generic_levenshtein(&StringWrapper(a), &StringWrapper(b))\n}","Real(LocalPath(\"src/lib.rs\"))"],"normalized_damerau_levenshtein":["/// Calculates a normalized score of the Damerau–Levenshtein algorithm between\n/// 0.0 and 1.0 (inclusive), where 1.0 means the strings are the same.\n///\n/// ```\n/// use strsim::normalized_damerau_levenshtein;\n///\n/// assert!((normalized_damerau_levenshtein(\"levenshtein\", \"löwenbräu\") - 0.27272).abs() < 0.00001);\n/// assert!((normalized_damerau_levenshtein(\"\", \"\") - 1.0).abs() < 0.00001);\n/// assert!(normalized_damerau_levenshtein(\"\", \"flower\").abs() < 0.00001);\n/// assert!(normalized_damerau_levenshtein(\"tree\", \"\").abs() < 0.00001);\n/// assert!((normalized_damerau_levenshtein(\"sunglasses\", \"sunglasses\") - 1.0).abs() < 0.00001);\n/// ```\npub fn normalized_damerau_levenshtein(a: &str, b: &str) -> f64{\n    if a.is_empty() && b.is_empty() {\n        return 1.0;\n    }\n\n    let len1 = a.chars().count();\n    let len2 = b.chars().count();\n    let dist = damerau_levenshtein_impl(a.chars(), len1, b.chars(), len2);\n    1.0 - (dist as f64) / (max(len1, len2) as f64)\n}","Real(LocalPath(\"src/lib.rs\"))"],"normalized_levenshtein":["/// Calculates a normalized score of the Levenshtein algorithm between 0.0 and\n/// 1.0 (inclusive), where 1.0 means the strings are the same.\n///\n/// ```\n/// use strsim::normalized_levenshtein;\n///\n/// assert!((normalized_levenshtein(\"kitten\", \"sitting\") - 0.57142).abs() < 0.00001);\n/// assert!((normalized_levenshtein(\"\", \"\") - 1.0).abs() < 0.00001);\n/// assert!(normalized_levenshtein(\"\", \"second\").abs() < 0.00001);\n/// assert!(normalized_levenshtein(\"first\", \"\").abs() < 0.00001);\n/// assert!((normalized_levenshtein(\"string\", \"string\") - 1.0).abs() < 0.00001);\n/// ```\npub fn normalized_levenshtein(a: &str, b: &str) -> f64{\n    if a.is_empty() && b.is_empty() {\n        return 1.0;\n    }\n    1.0 - (levenshtein(a, b) as f64) / (a.chars().count().max(b.chars().count()) as f64)\n}","Real(LocalPath(\"src/lib.rs\"))"],"osa_distance":["/// Like Levenshtein but allows for adjacent transpositions. Each substring can\n/// only be edited once.\n///\n/// ```\n/// use strsim::osa_distance;\n///\n/// assert_eq!(3, osa_distance(\"ab\", \"bca\"));\n/// ```\npub fn osa_distance(a: &str, b: &str) -> usize{\n    let b_len = b.chars().count();\n    // 0..=b_len behaves like 0..b_len.saturating_add(1) which could be a different size\n    // this leads to significantly worse code gen when swapping the vectors below\n    let mut prev_two_distances: Vec<usize> = (0..b_len + 1).collect();\n    let mut prev_distances: Vec<usize> = (0..b_len + 1).collect();\n    let mut curr_distances: Vec<usize> = vec![0; b_len + 1];\n\n    let mut prev_a_char = char::MAX;\n    let mut prev_b_char = char::MAX;\n\n    for (i, a_char) in a.chars().enumerate() {\n        curr_distances[0] = i + 1;\n\n        for (j, b_char) in b.chars().enumerate() {\n            let cost = usize::from(a_char != b_char);\n            curr_distances[j + 1] = min(\n                curr_distances[j] + 1,\n                min(prev_distances[j + 1] + 1, prev_distances[j] + cost),\n            );\n            if i > 0 && j > 0 && a_char != b_char && a_char == prev_b_char && b_char == prev_a_char\n            {\n                curr_distances[j + 1] = min(curr_distances[j + 1], prev_two_distances[j - 1] + 1);\n            }\n\n            prev_b_char = b_char;\n        }\n\n        mem::swap(&mut prev_two_distances, &mut prev_distances);\n        mem::swap(&mut prev_distances, &mut curr_distances);\n        prev_a_char = a_char;\n    }\n\n    // access prev_distances instead of curr_distances since we swapped\n    // them above. In case a is empty this would still contain the correct value\n    // from initializing the last element to b_len\n    prev_distances[b_len]\n}","Real(LocalPath(\"src/lib.rs\"))"],"sorensen_dice":["/// Calculates a Sørensen-Dice similarity distance using bigrams.\n/// See <https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient>.\n///\n/// ```\n/// use strsim::sorensen_dice;\n///\n/// assert_eq!(1.0, sorensen_dice(\"\", \"\"));\n/// assert_eq!(0.0, sorensen_dice(\"\", \"a\"));\n/// assert_eq!(0.0, sorensen_dice(\"french\", \"quebec\"));\n/// assert_eq!(1.0, sorensen_dice(\"ferris\", \"ferris\"));\n/// assert_eq!(0.8888888888888888, sorensen_dice(\"feris\", \"ferris\"));\n/// ```\npub fn sorensen_dice(a: &str, b: &str) -> f64{\n    // implementation guided by\n    // https://github.com/aceakash/string-similarity/blob/f83ba3cd7bae874c20c429774e911ae8cff8bced/src/index.js#L6\n\n    let a: String = a.chars().filter(|&x| !char::is_whitespace(x)).collect();\n    let b: String = b.chars().filter(|&x| !char::is_whitespace(x)).collect();\n\n    if a == b {\n        return 1.0;\n    }\n\n    if a.len() < 2 || b.len() < 2 {\n        return 0.0;\n    }\n\n    let mut a_bigrams: HashMap<(char, char), usize> = HashMap::new();\n\n    for bigram in bigrams(&a) {\n        *a_bigrams.entry(bigram).or_insert(0) += 1;\n    }\n\n    let mut intersection_size = 0_usize;\n\n    for bigram in bigrams(&b) {\n        a_bigrams.entry(bigram).and_modify(|bi| {\n            if *bi > 0 {\n                *bi -= 1;\n                intersection_size += 1;\n            }\n        });\n    }\n\n    (2 * intersection_size) as f64 / (a.len() + b.len() - 2) as f64\n}","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"Alias(Opaque, AliasTy { args: ['^0.Named(DefId(0:168 ~ strsim[6cc7]::bigrams::'_), \"'_\")], def_id: DefId(0:169 ~ strsim[6cc7]::bigrams::{opaque#0}) })":["bigrams"],"Alias(Projection, AliasTy { args: [&'a/#0 StringWrapper<'b/#1>], def_id: DefId(2:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })":["into_iter"],"GrowingHashmapChar":["default"],"GrowingHashmapMapElemChar":["clone","default"],"HybridGrowingHashmapChar":["default"],"RowId":["clone","default"],"bool":["eq"],"f64":["generic_jaro","generic_jaro_winkler","jaro","jaro_winkler","normalized_damerau_levenshtein","normalized_levenshtein","sorensen_dice"],"usize":["damerau_levenshtein","generic_damerau_levenshtein","generic_hamming","generic_levenshtein","hamming","levenshtein","lookup","osa_distance"]},"struct_to_trait":{"GrowingHashmapChar":["std::default::Default"],"GrowingHashmapMapElemChar":["std::clone::Clone","std::default::Default"],"HybridGrowingHashmapChar":["std::default::Default"],"RowId":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::marker::Copy","std::marker::StructuralPartialEq"],"StrSimError":["std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralPartialEq"]},"targets":{"<&'a StringWrapper<'b> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/lib.rs\"))","std::iter::IntoIterator"],"<GrowingHashmapChar<ValueType> as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<HybridGrowingHashmapChar<ValueType> as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<RowId as std::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","std::default::Default"],"<StrSimError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"GrowingHashmapChar::<ValueType>::allocate":["allocate","Real(LocalPath(\"src/lib.rs\"))",""],"GrowingHashmapChar::<ValueType>::get":["get","Real(LocalPath(\"src/lib.rs\"))",""],"GrowingHashmapChar::<ValueType>::get_mut":["get_mut","Real(LocalPath(\"src/lib.rs\"))",""],"GrowingHashmapChar::<ValueType>::grow":["grow","Real(LocalPath(\"src/lib.rs\"))",""],"GrowingHashmapChar::<ValueType>::lookup":["lookup","Real(LocalPath(\"src/lib.rs\"))",""],"HybridGrowingHashmapChar::<ValueType>::get":["get","Real(LocalPath(\"src/lib.rs\"))",""],"HybridGrowingHashmapChar::<ValueType>::get_mut":["get_mut","Real(LocalPath(\"src/lib.rs\"))",""],"bigrams":["bigrams","Real(LocalPath(\"src/lib.rs\"))",""],"damerau_levenshtein":["damerau_levenshtein","Real(LocalPath(\"src/lib.rs\"))",""],"damerau_levenshtein_impl":["damerau_levenshtein_impl","Real(LocalPath(\"src/lib.rs\"))",""],"flat_index":["flat_index","Real(LocalPath(\"src/lib.rs\"))",""],"generic_damerau_levenshtein":["generic_damerau_levenshtein","Real(LocalPath(\"src/lib.rs\"))",""],"generic_hamming":["generic_hamming","Real(LocalPath(\"src/lib.rs\"))",""],"generic_jaro":["generic_jaro","Real(LocalPath(\"src/lib.rs\"))",""],"generic_jaro_winkler":["generic_jaro_winkler","Real(LocalPath(\"src/lib.rs\"))",""],"generic_levenshtein":["generic_levenshtein","Real(LocalPath(\"src/lib.rs\"))",""],"hamming":["hamming","Real(LocalPath(\"src/lib.rs\"))",""],"jaro":["jaro","Real(LocalPath(\"src/lib.rs\"))",""],"jaro_winkler":["jaro_winkler","Real(LocalPath(\"src/lib.rs\"))",""],"levenshtein":["levenshtein","Real(LocalPath(\"src/lib.rs\"))",""],"normalized_damerau_levenshtein":["normalized_damerau_levenshtein","Real(LocalPath(\"src/lib.rs\"))",""],"normalized_levenshtein":["normalized_levenshtein","Real(LocalPath(\"src/lib.rs\"))",""],"osa_distance":["osa_distance","Real(LocalPath(\"src/lib.rs\"))",""],"sorensen_dice":["sorensen_dice","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["GrowingHashmapMapElemChar","RowId"],"std::cmp::Eq":["RowId"],"std::cmp::PartialEq":["RowId","StrSimError"],"std::default::Default":["GrowingHashmapChar","GrowingHashmapMapElemChar","HybridGrowingHashmapChar","RowId"],"std::error::Error":["StrSimError"],"std::fmt::Debug":["StrSimError"],"std::fmt::Display":["StrSimError"],"std::marker::Copy":["RowId"],"std::marker::StructuralPartialEq":["RowId","StrSimError"]},"type_to_def_path":{"GrowingHashmapChar<ValueType>":"GrowingHashmapChar","GrowingHashmapMapElemChar<ValueType>":"GrowingHashmapMapElemChar","HybridGrowingHashmapChar<ValueType>":"HybridGrowingHashmapChar","RowId":"RowId","StrSimError":"StrSimError","StringWrapper<'a>":"StringWrapper"}}