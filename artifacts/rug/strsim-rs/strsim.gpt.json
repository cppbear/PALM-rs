{"<&'a StringWrapper<'b> as std::iter::IntoIterator>::into_iter": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use strsim::StringWrapper;\n\n    #[test]\n    fn test_into_iter() {\n        let string_wrapper = StringWrapper(\"hello\");\n        let mut iterator = string_wrapper.into_iter();\n\n        assert_eq!(iterator.next(), Some('h'));\n        assert_eq!(iterator.next(), Some('e'));\n        assert_eq!(iterator.next(), Some('l'));\n        assert_eq!(iterator.next(), Some('l'));\n        assert_eq!(iterator.next(), Some('o'));\n        assert_eq!(iterator.next(), None);\n    }\n\n    #[test]\n    fn test_empty_string() {\n        let string_wrapper = StringWrapper(\"\");\n        let mut iterator = string_wrapper.into_iter();\n\n        assert_eq!(iterator.next(), None);\n    }\n}\n```", "<GrowingHashmapChar<ValueType> as std::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::default::Default;\n\n    #[test]\n    fn test_default_growth_hashmap() {\n        let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar::default();\n        assert_eq!(hashmap.used, 0);\n        assert_eq!(hashmap.fill, 0);\n        assert_eq!(hashmap.mask, -1);\n        assert!(hashmap.map.is_none());\n    }\n\n    #[test]\n    fn test_default_growth_hashmap_with_string() {\n        let hashmap: GrowingHashmapChar<String> = GrowingHashmapChar::default();\n        assert_eq!(hashmap.used, 0);\n        assert_eq!(hashmap.fill, 0);\n        assert_eq!(hashmap.mask, -1);\n        assert!(hashmap.map.is_none());\n    }\n}\n```", "<HybridGrowingHashmapChar<ValueType> as std::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::default::Default;\n\n    #[derive(Default, Clone, Copy, PartialEq, Eq)]\n    struct DummyValue;\n\n    #[test]\n    fn test_hybrid_growing_hashmap_char_default() {\n        let hashmap: HybridGrowingHashmapChar<DummyValue> = HybridGrowingHashmapChar::default();\n        \n        // Check that the used count in the map is 0\n        assert_eq!(hashmap.map.used, 0);\n        \n        // Check that the fill count in the map is 0\n        assert_eq!(hashmap.map.fill, 0);\n        \n        // Check that the mask is -1 (initialized state)\n        assert_eq!(hashmap.map.mask, -1);\n        \n        // Check that the map is None\n        assert!(hashmap.map.map.is_none());\n        \n        // Check that all extended ASCII entries are Default::default()\n        for value in hashmap.extended_ascii.iter() {\n            assert_eq!(*value, DummyValue);\n        }\n    }\n}\n```", "<RowId as std::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_row_id_default() {\n        let row_id = RowId::default();\n        assert_eq!(row_id.val, -1);\n    }\n}\n```", "GrowingHashmapChar::<ValueType>::allocate": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[derive(Default, Clone, PartialEq, Eq)]\n    struct TestValue {\n        value: i32,\n    }\n\n    #[derive(Default)]\n    struct GrowingHashmapMapElemChar<ValueType> {\n        key: u32,\n        value: ValueType,\n    }\n\n    #[test]\n    fn test_allocate_initializes_map_and_mask() {\n        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();\n        hashmap.allocate();\n\n        assert_eq!(hashmap.mask, 7); // 8 - 1\n        assert!(hashmap.map.is_some());\n        let map = hashmap.map.as_ref().unwrap();\n        assert_eq!(map.len(), 8);\n        for elem in map {\n            assert_eq!(elem.value, TestValue::default());\n        }\n    }\n\n    #[test]\n    fn test_allocate_does_not_double_allocate() {\n        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();\n        hashmap.allocate();\n        let old_mask = hashmap.mask;\n        let old_map = hashmap.map.clone();\n\n        hashmap.allocate();\n\n        assert_eq!(hashmap.mask, old_mask);\n        assert_eq!(hashmap.map, old_map);\n    }\n}\n```", "GrowingHashmapChar::<ValueType>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::default::Default;\n\n    #[derive(Default, Clone, Copy, Eq, PartialEq)]\n    struct TestValue {\n        value: i32,\n    }\n\n    #[derive(Default)]\n    struct GrowingHashmapMapElemChar<ValueType> {\n        key: u32,\n        value: ValueType,\n    }\n\n    #[test]\n    fn test_get_with_empty_map() {\n        let hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();\n        let result = hashmap.get(0);\n        assert_eq!(result, TestValue::default());\n    }\n\n    #[test]\n    fn test_get_with_non_empty_map() {\n        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();\n        hashmap.get_mut(1).value = TestValue { value: 42 }; // Insert a value\n        let result = hashmap.get(1);\n        assert_eq!(result, TestValue { value: 42 });\n    }\n\n    #[test]\n    fn test_get_non_existent() {\n        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();\n        hashmap.get_mut(2).value = TestValue { value: 100 }; // Insert a value\n        let result = hashmap.get(3);\n        assert_eq!(result, TestValue::default());\n    }\n}\n```", "GrowingHashmapChar::<ValueType>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[derive(Default, Clone, Copy, PartialEq, Eq)]\n    struct TestValue {\n        value: i32,\n    }\n    \n    #[derive(Default)]\n    struct GrowingHashmapMapElemChar<ValueType> {\n        key: u32,\n        value: ValueType,\n    }\n\n    #[test]\n    fn test_get_mut_new_key() {\n        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();\n        let value = hashmap.get_mut(1);\n        value.value = 42;\n        \n        assert_eq!(hashmap.get(1).value, 42);\n    }\n\n    #[test]\n    fn test_get_mut_existing_key() {\n        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();\n        {\n            let value = hashmap.get_mut(1);\n            value.value = 42;\n        }\n        {\n            let value = hashmap.get_mut(1);\n            value.value += 5;\n        }\n        \n        assert_eq!(hashmap.get(1).value, 47);\n    }\n\n    #[test]\n    fn test_get_mut_resizing() {\n        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();\n        for i in 0..10 {\n            let value = hashmap.get_mut(i);\n            value.value = i as i32;\n        }\n\n        for i in 0..10 {\n            assert_eq!(hashmap.get(i).value, i as i32);\n        }\n    }\n}\n```", "GrowingHashmapChar::<ValueType>::grow": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::default::Default;\n\n    #[derive(Default, Clone, PartialEq, Eq)]\n    struct TestValue {\n        data: i32,\n    }\n\n    #[derive(Default, Clone)]\n    struct GrowingHashmapMapElemChar<ValueType> {\n        key: u32,\n        value: ValueType,\n    }\n\n    #[test]\n    fn test_grow() {\n        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();\n        hashmap.allocate();\n        \n        // Add some elements to trigger a growth\n        for i in 0..6 {\n            hashmap.get_mut(i).data = i;\n        }\n\n        let old_mask = hashmap.mask;\n        hashmap.grow(6);\n\n        // Assert that the mask size has increased\n        assert!(hashmap.mask > old_mask);\n        assert_eq!(hashmap.fill, 6);\n        assert_eq!(hashmap.used, 6);\n\n        // Verify if the elements are still present after grow\n        for i in 0..6 {\n            assert_eq!(hashmap.get(i).data, i);\n        }\n    }\n}\n```", "GrowingHashmapChar::<ValueType>::lookup": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::default::Default;\n\n    #[derive(Default, Clone, PartialEq, Eq)]\n    struct TestValue {\n        pub value: usize,\n    }\n\n    #[derive(Default)]\n    struct GrowingHashmapMapElemChar<ValueType> {\n        pub key: u32,\n        pub value: ValueType,\n    }\n\n    #[test]\n    fn test_lookup_empty_map() {\n        let hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();\n        let key = 42;\n        let index = hashmap.lookup(key);\n        assert_eq!(index, 0);\n    }\n\n    #[test]\n    fn test_lookup_existing_key() {\n        let mut hashmap = GrowingHashmapChar::<TestValue>::default();\n        hashmap.allocate();\n        hashmap.get_mut(42).value = 1;  // Insert key 42\n        let index = hashmap.lookup(42);\n        assert_eq!(index, 0);\n        assert_eq!(hashmap.get(42).value, 1);\n    }\n\n    #[test]\n    fn test_lookup_collisions() {\n        let mut hashmap = GrowingHashmapChar::<TestValue>::default();\n        hashmap.allocate();\n        hashmap.get_mut(43).value = 1;  // Insert key 43\n        hashmap.get_mut(42).value = 2;  // Insert key 42\n        let index1 = hashmap.lookup(43);\n        let index2 = hashmap.lookup(42);\n        assert!(index1 != index2); // Check they are in different indices\n        assert_eq!(hashmap.get(43).value, 1);\n        assert_eq!(hashmap.get(42).value, 2);\n    }\n\n    #[test]\n    fn test_lookup_non_existing_key() {\n        let mut hashmap = GrowingHashmapChar::<TestValue>::default();\n        hashmap.allocate();\n        hashmap.get_mut(42).value = 1;  // Insert key 42\n        let index = hashmap.lookup(99);  // Look for non-existing key 99\n        assert_ne!(index, 0);  // Ensure it does not point to the same index\n    }\n}\n```", "HybridGrowingHashmapChar::<ValueType>::get": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_hybrid_growing_hashmap_char_get_extended_ascii() {\n        let mut hashmap: HybridGrowingHashmapChar<i32> = HybridGrowingHashmapChar::default();\n        \n        // Test for a character within the extended ASCII range\n        let key = 'A'; // ASCII value 65\n        hashmap.extended_ascii[65] = 42; // Assign a value\n        assert_eq!(hashmap.get(key), 42);\n        \n        // Test for a character not in the extended ASCII range\n        let key = '\u03a9'; // Unicode character\n        assert_eq!(hashmap.get(key), 0); // Default value for i32\n    }\n\n    #[test]\n    fn test_hybrid_growing_hashmap_char_get_above_ascii() {\n        let hashmap: HybridGrowingHashmapChar<i32> = HybridGrowingHashmapChar::default();\n        \n        // Test for a character outside the extended ASCII range\n        let key = '\u00ff'; // ASCII value 255\n        assert_eq!(hashmap.get(key), 0); // Default value for i32\n    }\n\n    #[test]\n    fn test_hybrid_growing_hashmap_char_get_mut() {\n        let mut hashmap: HybridGrowingHashmapChar<i32> = HybridGrowingHashmapChar::default();\n        \n        // Test for a character within the extended ASCII range\n        let key = 'B'; // ASCII value 66\n        {\n            let value = hashmap.get_mut(key);\n            *value = 100; // Assign value\n        }\n        assert_eq!(hashmap.get(key), 100);\n\n        // Test mut for a character not in the extended ASCII range\n        let key = '\u03a9'; // Unicode character\n        {\n            let value = hashmap.get_mut(key);\n            *value = 200; // Assign value\n        }\n        assert_eq!(hashmap.get(key), 200);\n    }\n}\n```", "HybridGrowingHashmapChar::<ValueType>::get_mut": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::default::Default;\n\n    #[test]\n    fn test_get_mut_extended_ascii() {\n        let mut hashmap: HybridGrowingHashmapChar<i32> = HybridGrowingHashmapChar::default();\n\n        // Test for an ASCII char\n        let value = hashmap.get_mut('a');\n        *value = 10;\n        assert_eq!(hashmap.get('a'), 10);\n    }\n\n    #[test]\n    fn test_get_mut_non_ascii() {\n        let mut hashmap: HybridGrowingHashmapChar<i32> = HybridGrowingHashmapChar::default();\n\n        // Test for a non-ASCII char\n        let value = hashmap.get_mut('\u017e');\n        *value = 20;\n\n        // Ensure that this value is stored correctly\n        assert_eq!(hashmap.get('\u017e'), 20);\n    }\n\n    #[test]\n    fn test_get_mut_overwrite_extended_ascii() {\n        let mut hashmap: HybridGrowingHashmapChar<i32> = HybridGrowingHashmapChar::default();\n\n        // Initially set value for ASCII character 'b'\n        let value1 = hashmap.get_mut('b');\n        *value1 = 30;\n\n        // Overwrite the value\n        let value2 = hashmap.get_mut('b');\n        *value2 = 40;\n\n        assert_eq!(hashmap.get('b'), 40);\n    }\n}\n```", "bigrams": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_bigrams_empty_string() {\n        let result: Vec<(char, char)> = bigrams(\"\").collect();\n        assert_eq!(result, vec![]);\n    }\n\n    #[test]\n    fn test_bigrams_single_char() {\n        let result: Vec<(char, char)> = bigrams(\"a\").collect();\n        assert_eq!(result, vec![]);\n    }\n\n    #[test]\n    fn test_bigrams_two_chars() {\n        let result: Vec<(char, char)> = bigrams(\"ab\").collect();\n        assert_eq!(result, vec![('a', 'b')]);\n    }\n\n    #[test]\n    fn test_bigrams_multiple_chars() {\n        let result: Vec<(char, char)> = bigrams(\"hello\").collect();\n        assert_eq!(result, vec![('h', 'e'), ('e', 'l'), ('l', 'l'), ('l', 'o')]);\n    }\n\n    #[test]\n    fn test_bigrams_repeated_chars() {\n        let result: Vec<(char, char)> = bigrams(\"aa\").collect();\n        assert_eq!(result, vec![('a', 'a')]);\n    }\n}\n```", "damerau_levenshtein": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use strsim::damerau_levenshtein;\n\n    #[test]\n    fn test_damerau_levenshtein() {\n        assert_eq!(damerau_levenshtein(\"ab\", \"bca\"), 2);\n        assert_eq!(damerau_levenshtein(\"kitten\", \"sitting\"), 3);\n        assert_eq!(damerau_levenshtein(\"flaw\", \"lawn\"), 2);\n        assert_eq!(damerau_levenshtein(\"hello\", \"hallo\"), 1);\n        assert_eq!(damerau_levenshtein(\"test\", \"test\"), 0);\n        assert_eq!(damerau_levenshtein(\"\", \"nonempty\"), 9);\n        assert_eq!(damerau_levenshtein(\"nonempty\", \"\"), 9);\n        assert_eq!(damerau_levenshtein(\"\", \"\"), 0);\n    }\n}\n```", "damerau_levenshtein_impl": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::iter::Iterator;\n\n    #[test]\n    fn test_damerau_levenshtein_impl() {\n        let s1 = \"kitten\".chars();\n        let s2 = \"sitting\".chars();\n        let result = damerau_levenshtein_impl(s1.clone(), s1.clone().count(), s2.clone(), s2.clone().count());\n        assert_eq!(result, 3);\n\n        let s1 = \"flaw\".chars();\n        let s2 = \"lawn\".chars();\n        let result = damerau_levenshtein_impl(s1.clone(), s1.clone().count(), s2.clone(), s2.clone().count());\n        assert_eq!(result, 2);\n\n        let s1 = \"example\".chars();\n        let s2 = \"samples\".chars();\n        let result = damerau_levenshtein_impl(s1.clone(), s1.clone().count(), s2.clone(), s2.clone().count());\n        assert_eq!(result, 3);\n\n        let s1 = \"\".chars();\n        let s2 = \"hello\".chars();\n        let result = damerau_levenshtein_impl(s1.clone(), s1.clone().count(), s2.clone(), s2.clone().count());\n        assert_eq!(result, 5);\n\n        let s1 = \"test\".chars();\n        let s2 = \"test\".chars();\n        let result = damerau_levenshtein_impl(s1.clone(), s1.clone().count(), s2.clone(), s2.clone().count());\n        assert_eq!(result, 0);\n\n        let s1 = \"kitten\".chars();\n        let s2 = \"kittin\".chars();\n        let result = damerau_levenshtein_impl(s1.clone(), s1.clone().count(), s2.clone(), s2.clone().count());\n        assert_eq!(result, 1);\n    }\n}\n```", "flat_index": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_flat_index() {\n        assert_eq!(flat_index(0, 0, 10), 0);\n        assert_eq!(flat_index(1, 0, 10), 1);\n        assert_eq!(flat_index(0, 1, 10), 10);\n        assert_eq!(flat_index(1, 1, 10), 11);\n        assert_eq!(flat_index(9, 1, 10), 19);\n        assert_eq!(flat_index(0, 2, 10), 20);\n        assert_eq!(flat_index(9, 2, 10), 29);\n        assert_eq!(flat_index(1, 3, 10), 31);\n        assert_eq!(flat_index(5, 5, 10), 55);\n    }\n}\n```", "generic_damerau_levenshtein": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_generic_damerau_levenshtein_basic() {\n        assert_eq!(generic_damerau_levenshtein(&[1, 2], &[2, 3, 1]), 2);\n    }\n\n    #[test]\n    fn test_generic_damerau_levenshtein_identical() {\n        assert_eq!(generic_damerau_levenshtein(&[1, 2, 3], &[1, 2, 3]), 0);\n    }\n\n    #[test]\n    fn test_generic_damerau_levenshtein_insertion() {\n        assert_eq!(generic_damerau_levenshtein(&[1], &[1, 2]), 1);\n    }\n\n    #[test]\n    fn test_generic_damerau_levenshtein_deletion() {\n        assert_eq!(generic_damerau_levenshtein(&[1, 2], &[1]), 1);\n    }\n\n    #[test]\n    fn test_generic_damerau_levenshtein_substitution() {\n        assert_eq!(generic_damerau_levenshtein(&[1, 2], &[2, 1]), 2);\n    }\n\n    #[test]\n    fn test_generic_damerau_levenshtein_transposition() {\n        assert_eq!(generic_damerau_levenshtein(&[1, 2, 3], &[2, 1, 3]), 1);\n    }\n\n    #[test]\n    fn test_generic_damerau_levenshtein_empty() {\n        assert_eq!(generic_damerau_levenshtein(&[], &[1]), 1);\n        assert_eq!(generic_damerau_levenshtein(&[1], &[]), 1);\n    }\n}\n```", "generic_hamming": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::vec;\n\n    #[test]\n    fn test_generic_hamming_equal_sequences() {\n        let a = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 3 }];\n        let b = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 3 }];\n        let result = generic_hamming(a, b);\n        assert_eq!(result, Ok(0));\n    }\n\n    #[test]\n    fn test_generic_hamming_different_sequences() {\n        let a = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 3 }];\n        let b = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 4 }];\n        let result = generic_hamming(a, b);\n        assert_eq!(result, Ok(1));\n    }\n\n    #[test]\n    fn test_generic_hamming_different_lengths() {\n        let a = vec![RowId { val: 1 }, RowId { val: 2 }];\n        let b = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 3 }];\n        let result = generic_hamming(a, b);\n        assert_eq!(result, Err(StrSimError::DifferentLengthArgs));\n    }\n\n    #[test]\n    fn test_generic_hamming_empty_sequences() {\n        let a: Vec<RowId> = vec![];\n        let b: Vec<RowId> = vec![];\n        let result = generic_hamming(a, b);\n        assert_eq!(result, Ok(0));\n    }\n\n    #[test]\n    fn test_generic_hamming_one_empty_one_non_empty() {\n        let a = vec![RowId { val: 1 }];\n        let b: Vec<RowId> = vec![];\n        let result = generic_hamming(a, b);\n        assert_eq!(result, Err(StrSimError::DifferentLengthArgs));\n    }\n}\n```", "generic_jaro": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::RowId;\n\n    #[test]\n    fn test_generic_jaro_identical_sequences() {\n        let a = vec![RowId { val: 1 }, RowId { val: 2 }];\n        let b = vec![RowId { val: 1 }, RowId { val: 2 }];\n        assert_eq!(generic_jaro(&a, &b), 1.0);\n    }\n\n    #[test]\n    fn test_generic_jaro_different_sequences() {\n        let a = vec![RowId { val: 1 }, RowId { val: 2 }];\n        let b = vec![RowId { val: 2 }, RowId { val: 3 }];\n        assert!(generic_jaro(&a, &b) < 1.0);\n    }\n\n    #[test]\n    fn test_generic_jaro_empty_sequences() {\n        let a: Vec<RowId> = vec![];\n        let b: Vec<RowId> = vec![];\n        assert_eq!(generic_jaro(&a, &b), 1.0);\n    }\n\n    #[test]\n    fn test_generic_jaro_one_empty_sequence() {\n        let a = vec![RowId { val: 1 }, RowId { val: 2 }];\n        let b: Vec<RowId> = vec![];\n        assert_eq!(generic_jaro(&a, &b), 0.0);\n    }\n\n    #[test]\n    fn test_generic_jaro_partial_matches() {\n        let a = vec![RowId { val: 1 }, RowId { val: 2 }];\n        let b = vec![RowId { val: 1 }, RowId { val: 3 }];\n        assert!(generic_jaro(&a, &b) > 0.0);\n    }\n}\n```", "generic_jaro_winkler": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::RowId;\n\n    #[test]\n    fn test_generic_jaro_winkler_with_identical_sequences() {\n        let seq_a = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 3 }];\n        let seq_b = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 3 }];\n        let similarity = generic_jaro_winkler(&seq_a, &seq_b);\n        assert_eq!(similarity, 1.0);\n    }\n\n    #[test]\n    fn test_generic_jaro_winkler_with_different_sequences() {\n        let seq_a = vec![RowId { val: 1 }, RowId { val: 2 }];\n        let seq_b = vec![RowId { val: 3 }, RowId { val: 4 }];\n        let similarity = generic_jaro_winkler(&seq_a, &seq_b);\n        assert_eq!(similarity, generic_jaro(&seq_a, &seq_b)); // Expected similarity using generic_jaro\n    }\n\n    #[test]\n    fn test_generic_jaro_winkler_with_partial_match() {\n        let seq_a = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 3 }];\n        let seq_b = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 4 }];\n        let similarity = generic_jaro_winkler(&seq_a, &seq_b);\n        assert!(similarity > 0.0);\n        assert!(similarity < 1.0);\n    }\n\n    #[test]\n    fn test_generic_jaro_winkler_with_prefix_boost() {\n        let seq_a = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 3 }];\n        let seq_b = vec![RowId { val: 1 }, RowId { val: 2 }, RowId { val: 5 }];\n        let similarity = generic_jaro_winkler(&seq_a, &seq_b);\n        assert!(similarity > generic_jaro(&seq_a, &seq_b));\n    }\n\n    #[test]\n    fn test_generic_jaro_winkler_with_no_similarity() {\n        let seq_a = vec![RowId { val: 1 }];\n        let seq_b = vec![RowId { val: 2 }];\n        let similarity = generic_jaro_winkler(&seq_a, &seq_b);\n        assert_eq!(similarity, generic_jaro(&seq_a, &seq_b)); // Expected similarity using generic_jaro\n    }\n}\n```", "generic_levenshtein": "```rust\n#[cfg(test)]\nmod tests {\n    use super::generic_levenshtein;\n\n    #[derive(Clone, Eq, PartialEq, Debug)]\n    struct RowId {\n        val: isize,\n    }\n\n    impl Default for RowId {\n        fn default() -> Self {\n            Self { val: -1 }\n        }\n    }\n\n    #[test]\n    fn test_generic_levenshtein_basic() {\n        assert_eq!(3, generic_levenshtein(&[1, 2, 3], &[1, 2, 3, 4, 5, 6]));\n    }\n\n    #[test]\n    fn test_generic_levenshtein_identical() {\n        assert_eq!(0, generic_levenshtein(&[1, 2, 3], &[1, 2, 3]));\n    }\n\n    #[test]\n    fn test_generic_levenshtein_insertions() {\n        assert_eq!(2, generic_levenshtein(&[1, 2], &[1, 2, 3, 4]));\n    }\n\n    #[test]\n    fn test_generic_levenshtein_deletions() {\n        assert_eq!(2, generic_levenshtein(&[1, 2, 3, 4], &[1, 2]));\n    }\n\n    #[test]\n    fn test_generic_levenshtein_substitutions() {\n        assert_eq!(1, generic_levenshtein(&[1, 2, 3], &[3, 2, 1]));\n    }\n\n    #[test]\n    fn test_generic_levenshtein_empty() {\n        assert_eq!(3, generic_levenshtein(&[], &[1, 2, 3]));\n        assert_eq!(3, generic_levenshtein(&[1, 2, 3], &[]));\n    }\n\n    #[test]\n    fn test_generic_levenshtein_rowid() {\n        let a: &[RowId] = &[RowId { val: 1 }, RowId { val: 2 }];\n        let b: &[RowId] = &[RowId { val: 1 }, RowId { val: 2 }, RowId { val: 3 }];\n        assert_eq!(1, generic_levenshtein(a, b));\n    }\n}\n```", "hamming": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use strsim::{hamming, StrSimError::DifferentLengthArgs};\n\n    #[test]\n    fn test_hamming_equal_length_different_chars() {\n        assert_eq!(Ok(3), hamming(\"hamming\", \"hammers\"));\n    }\n\n    #[test]\n    fn test_hamming_equal_length_same_chars() {\n        assert_eq!(Ok(0), hamming(\"hamming\", \"hamming\"));\n    }\n\n    #[test]\n    fn test_hamming_different_length() {\n        assert_eq!(Err(DifferentLengthArgs), hamming(\"hamming\", \"ham\"));\n    }\n\n    #[test]\n    fn test_hamming_empty_strings() {\n        assert_eq!(Ok(0), hamming(\"\", \"\"));\n    }\n\n    #[test]\n    fn test_hamming_one_empty_string() {\n        assert_eq!(Err(DifferentLengthArgs), hamming(\"hamming\", \"\"));\n        assert_eq!(Err(DifferentLengthArgs), hamming(\"\", \"hamming\"));\n    }\n}\n```", "jaro": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_jaro_similarity_equal_strings() {\n        assert!((1.0 - jaro(\"test\", \"test\")).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_jaro_similarity_different_strings() {\n        assert!((0.0 - jaro(\"abc\", \"xyz\")).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_jaro_similarity_partial_match() {\n        assert!((0.666 - jaro(\"abc\", \"ab\")).abs() < 0.001);\n        assert!((0.392 - jaro(\"Friedrich Nietzsche\", \"Jean-Paul Sartre\")).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_jaro_similarity_with_spaces() {\n        assert!((0.5 - jaro(\"hello world\", \"hello\")).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_jaro_similarity_with_empty_strings() {\n        assert!((0.0 - jaro(\"\", \"test\")).abs() < 0.001);\n        assert!((0.0 - jaro(\"test\", \"\")).abs() < 0.001);\n        assert!((1.0 - jaro(\"\", \"\")).abs() < 0.001);\n    }\n}\n```", "jaro_winkler": "```rust\n#[cfg(test)]\nmod tests {\n    use super::jaro_winkler;\n\n    #[test]\n    fn test_jaro_winkler_equal_strings() {\n        let result = jaro_winkler(\"test\", \"test\");\n        assert!((1.0 - result).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_jaro_winkler_similar_strings() {\n        let result = jaro_winkler(\"cheeseburger\", \"cheese fries\");\n        assert!((0.866 - result).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_jaro_winkler_different_strings() {\n        let result = jaro_winkler(\"cat\", \"dog\");\n        assert!((0.0 - result).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_jaro_winkler_partial_match() {\n        let result = jaro_winkler(\"hello\", \"hallo\");\n        assert!((0.88 - result).abs() < 0.01);\n    }\n\n    #[test]\n    fn test_jaro_winkler_empty_strings() {\n        let result = jaro_winkler(\"\", \"\");\n        assert!((1.0 - result).abs() < 0.001);\n    }\n}\n```", "levenshtein": "```rust\n#[cfg(test)]\nmod tests {\n    use super::levenshtein;\n\n    #[test]\n    fn test_levenshtein_same_strings() {\n        assert_eq!(levenshtein(\"hello\", \"hello\"), 0);\n    }\n\n    #[test]\n    fn test_levenshtein_one_insertion() {\n        assert_eq!(levenshtein(\"hello\", \"helloo\"), 1);\n    }\n\n    #[test]\n    fn test_levenshtein_one_deletion() {\n        assert_eq!(levenshtein(\"hello\", \"hell\"), 1);\n    }\n\n    #[test]\n    fn test_levenshtein_one_substitution() {\n        assert_eq!(levenshtein(\"hello\", \"hxllo\"), 1);\n    }\n\n    #[test]\n    fn test_levenshtein_multiple_operations() {\n        assert_eq!(levenshtein(\"kitten\", \"sitting\"), 3);\n    }\n\n    #[test]\n    fn test_levenshtein_empty_strings() {\n        assert_eq!(levenshtein(\"\", \"\"), 0);\n        assert_eq!(levenshtein(\"hello\", \"\"), 5);\n        assert_eq!(levenshtein(\"\", \"hello\"), 5);\n    }\n\n    #[test]\n    fn test_levenshtein_identical_strings() {\n        assert_eq!(levenshtein(\"test\", \"test\"), 0);\n    }\n\n    #[test]\n    fn test_levenshtein_case_difference() {\n        assert_eq!(levenshtein(\"Test\", \"test\"), 1);\n    }\n\n    #[test]\n    fn test_levenshtein_large_difference() {\n        assert_eq!(levenshtein(\"abcdefg\", \"hijklmnop\"), 14);\n    }\n}\n```", "normalized_damerau_levenshtein": "```rust\n#[cfg(test)]\nmod tests {\n    use super::normalized_damerau_levenshtein;\n\n    #[test]\n    fn test_normalized_damerau_levenshtein() {\n        assert!((normalized_damerau_levenshtein(\"levenshtein\", \"l\u00f6wenbr\u00e4u\") - 0.27272).abs() < 0.00001);\n        assert!((normalized_damerau_levenshtein(\"\", \"\") - 1.0).abs() < 0.00001);\n        assert!(normalized_damerau_levenshtein(\"\", \"flower\").abs() < 0.00001);\n        assert!(normalized_damerau_levenshtein(\"tree\", \"\").abs() < 0.00001);\n        assert!((normalized_damerau_levenshtein(\"sunglasses\", \"sunglasses\") - 1.0).abs() < 0.00001);\n    }\n}\n```", "normalized_levenshtein": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_normalized_levenshtein() {\n        assert!((normalized_levenshtein(\"kitten\", \"sitting\") - 0.57142).abs() < 0.00001);\n        assert!((normalized_levenshtein(\"\", \"\") - 1.0).abs() < 0.00001);\n        assert!(normalized_levenshtein(\"\", \"second\").abs() < 0.00001);\n        assert!(normalized_levenshtein(\"first\", \"\").abs() < 0.00001);\n        assert!((normalized_levenshtein(\"string\", \"string\") - 1.0).abs() < 0.00001);\n    }\n}\n```", "osa_distance": "```rust\n#[cfg(test)]\nmod tests {\n    use super::osa_distance;\n\n    #[test]\n    fn test_osa_distance_identical_strings() {\n        assert_eq!(osa_distance(\"test\", \"test\"), 0);\n    }\n\n    #[test]\n    fn test_osa_distance_different_length_strings() {\n        assert_eq!(osa_distance(\"abc\", \"ab\"), 1);\n        assert_eq!(osa_distance(\"ab\", \"abc\"), 1);\n    }\n\n    #[test]\n    fn test_osa_distance_transpositions() {\n        assert_eq!(osa_distance(\"ab\", \"ba\"), 1);\n        assert_eq!(osa_distance(\"abc\", \"acb\"), 1);\n        assert_eq!(osa_distance(\"abcd\", \"abdc\"), 1);\n    }\n\n    #[test]\n    fn test_osa_distance_multi_edits() {\n        assert_eq!(osa_distance(\"abc\", \"xyz\"), 3);\n        assert_eq!(osa_distance(\"horse\", \"ros\"), 3);\n        assert_eq!(osa_distance(\"kitten\", \"sitting\"), 5);\n    }\n\n    #[test]\n    fn test_osa_distance_empty_strings() {\n        assert_eq!(osa_distance(\"\", \"\"), 0);\n        assert_eq!(osa_distance(\"abc\", \"\"), 3);\n        assert_eq!(osa_distance(\"\", \"abc\"), 3);\n    }\n\n    #[test]\n    fn test_osa_distance_single_character() {\n        assert_eq!(osa_distance(\"a\", \"a\"), 0);\n        assert_eq!(osa_distance(\"a\", \"b\"), 1);\n        assert_eq!(osa_distance(\"a\", \"\"), 1);\n        assert_eq!(osa_distance(\"\", \"a\"), 1);\n    }\n}\n```", "sorensen_dice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sorensen_dice() {\n        assert_eq!(1.0, sorensen_dice(\"\", \"\"));\n        assert_eq!(0.0, sorensen_dice(\"\", \"a\"));\n        assert_eq!(0.0, sorensen_dice(\"french\", \"quebec\"));\n        assert_eq!(1.0, sorensen_dice(\"ferris\", \"ferris\"));\n        assert_eq!(0.8888888888888888, sorensen_dice(\"feris\", \"ferris\"));\n    }\n}\n```"}