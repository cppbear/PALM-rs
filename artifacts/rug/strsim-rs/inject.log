inject succeed strsim-rs strsim <&'a StringWrapper<'b> as std::iter::IntoIterator>::into_iter
inject succeed strsim-rs strsim <GrowingHashmapChar<ValueType> as std::default::Default>::default
========================================
inject err <HybridGrowingHashmapChar<ValueType> as std::default::Default>::default src/lib.rs default

#[cfg(test)]
mod tests_llm_16_3 {
    use super::*;

use crate::*;
    use std::default::Default;

    #[derive(Default, Clone, Copy, PartialEq, Eq)]
    struct DummyValue;

    #[test]
    fn test_hybrid_growing_hashmap_char_default() {
        let hashmap: HybridGrowingHashmapChar<DummyValue> = HybridGrowingHashmapChar::default();
        
        // Check that the used count in the map is 0
        assert_eq!(hashmap.map.used, 0);
        
        // Check that the fill count in the map is 0
        assert_eq!(hashmap.map.fill, 0);
        
        // Check that the mask is -1 (initialized state)
        assert_eq!(hashmap.map.mask, -1);
        
        // Check that the map is None
        assert!(hashmap.map.map.is_none());
        
        // Check that all extended ASCII entries are Default::default()
        for value in hashmap.extended_ascii.iter() {
            assert_eq!(*value, DummyValue);
        }
    }
}

{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `super::*`\n    --> src/lib.rs:1311:9\n     |\n1311 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"`#[warn(unused_imports)]` on by default","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37266,"byte_start":37253,"column_end":18,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":18,"highlight_start":5,"text":"    use super::*;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `super::*`","spans":[{"byte_end":37265,"byte_start":37257,"column_end":17,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":17,"highlight_start":9,"text":"    use super::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1313:5\n     |\n1313 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37282,"byte_start":37268,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1314,"line_start":1313,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use crate::StringWrapper;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":37280,"byte_start":37272,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1313,"line_start":1313,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1342:5\n     |\n1342 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38014,"byte_start":38000,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1343,"line_start":1342,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38012,"byte_start":38004,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1342,"line_start":1342,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1368:5\n     |\n1368 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38706,"byte_start":38692,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1369,"line_start":1368,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38704,"byte_start":38696,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1368,"line_start":1368,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rlib","/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `DummyValue` doesn't implement `Debug`\n    --> src/lib.rs:1392:13\n     |\n1392 |             assert_eq!(*value, DummyValue);\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `DummyValue` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `DummyValue`\n     = note: add `#[derive(Debug)]` to `DummyValue` or manually `impl Debug for DummyValue`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `DummyValue` with `#[derive(Debug)]`\n     |\n1372 +     #[derive(Debug)]\n1373 |     struct DummyValue;\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `DummyValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `DummyValue` or manually `impl Debug for DummyValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"consider annotating `DummyValue` with `#[derive(Debug)]`","rendered":null,"spans":[{"byte_end":38793,"byte_start":38793,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1372,"line_start":1372,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct DummyValue;"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`DummyValue` doesn't implement `Debug`","spans":[{"byte_end":1629,"byte_start":1619,"column_end":70,"column_start":60,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39555,"byte_start":39525,"column_end":43,"column_start":13,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1392,"line_start":1392,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":13,"text":"            assert_eq!(*value, DummyValue);"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`DummyValue` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":70,"highlight_start":60,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `DummyValue` doesn't implement `Debug`\n    --> src/lib.rs:1392:13\n     |\n1392 |             assert_eq!(*value, DummyValue);\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `DummyValue` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `DummyValue`\n     = note: add `#[derive(Debug)]` to `DummyValue` or manually `impl Debug for DummyValue`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `DummyValue` with `#[derive(Debug)]`\n     |\n1372 +     #[derive(Debug)]\n1373 |     struct DummyValue;\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `DummyValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `DummyValue` or manually `impl Debug for DummyValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"consider annotating `DummyValue` with `#[derive(Debug)]`","rendered":null,"spans":[{"byte_end":38793,"byte_start":38793,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1372,"line_start":1372,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct DummyValue;"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`DummyValue` doesn't implement `Debug`","spans":[{"byte_end":1642,"byte_start":1631,"column_end":83,"column_start":72,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39555,"byte_start":39525,"column_end":43,"column_start":13,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1392,"line_start":1392,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":13,"text":"            assert_eq!(*value, DummyValue);"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`DummyValue` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":83,"highlight_start":72,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error: aborting due to 2 previous errors; 4 warnings emitted\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"aborting due to 2 previous errors; 4 warnings emitted","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"For more information about this error, try `rustc --explain E0277`.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"For more information about this error, try `rustc --explain E0277`.","spans":[]}}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"lib","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/tests/lib.rs","edition":"2021","doc":false,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/lib-2bbdf63c70c07263"],"executable":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/lib-2bbdf63c70c07263","fresh":false}
{"reason":"build-finished","success":false}

inject succeed strsim-rs strsim <RowId as std::default::Default>::default
========================================
inject err GrowingHashmapChar::<ValueType>::allocate src/lib.rs allocate

#[cfg(test)]
mod tests_llm_16_6 {
    use super::*;

use crate::*;
    
    #[derive(Default, Clone, PartialEq, Eq)]
    struct TestValue {
        value: i32,
    }

    #[derive(Default)]
    struct GrowingHashmapMapElemChar<ValueType> {
        key: u32,
        value: ValueType,
    }

    #[test]
    fn test_allocate_initializes_map_and_mask() {
        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();
        hashmap.allocate();

        assert_eq!(hashmap.mask, 7); // 8 - 1
        assert!(hashmap.map.is_some());
        let map = hashmap.map.as_ref().unwrap();
        assert_eq!(map.len(), 8);
        for elem in map {
            assert_eq!(elem.value, TestValue::default());
        }
    }

    #[test]
    fn test_allocate_does_not_double_allocate() {
        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();
        hashmap.allocate();
        let old_mask = hashmap.mask;
        let old_map = hashmap.map.clone();

        hashmap.allocate();

        assert_eq!(hashmap.mask, old_mask);
        assert_eq!(hashmap.map, old_map);
    }
}

{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `super::*`\n    --> src/lib.rs:1311:9\n     |\n1311 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"`#[warn(unused_imports)]` on by default","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37266,"byte_start":37253,"column_end":18,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":18,"highlight_start":5,"text":"    use super::*;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `super::*`","spans":[{"byte_end":37265,"byte_start":37257,"column_end":17,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":17,"highlight_start":9,"text":"    use super::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1313:5\n     |\n1313 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37282,"byte_start":37268,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1314,"line_start":1313,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use crate::StringWrapper;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":37280,"byte_start":37272,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1313,"line_start":1313,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1342:5\n     |\n1342 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38014,"byte_start":38000,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1343,"line_start":1342,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38012,"byte_start":38004,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1342,"line_start":1342,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1368:5\n     |\n1368 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38706,"byte_start":38692,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1369,"line_start":1368,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":""}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38704,"byte_start":38696,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1368,"line_start":1368,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1381:5\n     |\n1381 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38901,"byte_start":38887,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1382,"line_start":1381,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    "}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38899,"byte_start":38891,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1381,"line_start":1381,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1397:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `allocate` not found for this struct\n...\n1384 |     struct TestValue {\n     |     ---------------- doesn't satisfy `TestValue: Copy`\n...\n1397 |         hashmap.allocate();\n     |                 ^^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `TestValue` with `#[derive(Clone, Copy)]`\n     |\n1384 +     #[derive(Clone, Copy)]\n1385 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":38955,"byte_start":38955,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1384,"line_start":1384,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":39299,"byte_start":39291,"column_end":25,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1397,"line_start":1397,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":25,"highlight_start":17,"text":"        hashmap.allocate();"}]},{"byte_end":38971,"byte_start":38955,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `TestValue: Copy`","line_end":1384,"line_start":1384,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `allocate` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `TestValue` doesn't implement `Debug`\n    --> src/lib.rs:1404:13\n     |\n1404 |             assert_eq!(elem.value, TestValue::default());\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `TestValue` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `TestValue`\n     = note: add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `TestValue` with `#[derive(Debug)]`\n     |\n1384 +     #[derive(Debug)]\n1385 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Debug)]`","rendered":null,"spans":[{"byte_end":38955,"byte_start":38955,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1384,"line_start":1384,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`TestValue` doesn't implement `Debug`","spans":[{"byte_end":1629,"byte_start":1619,"column_end":70,"column_start":60,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39555,"byte_start":39511,"column_end":57,"column_start":13,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1404,"line_start":1404,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":57,"highlight_start":13,"text":"            assert_eq!(elem.value, TestValue::default());"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`TestValue` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":70,"highlight_start":60,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `TestValue` doesn't implement `Debug`\n    --> src/lib.rs:1404:13\n     |\n1404 |             assert_eq!(elem.value, TestValue::default());\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `TestValue` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `TestValue`\n     = note: add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `TestValue` with `#[derive(Debug)]`\n     |\n1384 +     #[derive(Debug)]\n1385 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Debug)]`","rendered":null,"spans":[{"byte_end":38955,"byte_start":38955,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1384,"line_start":1384,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`TestValue` doesn't implement `Debug`","spans":[{"byte_end":1642,"byte_start":1631,"column_end":83,"column_start":72,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39555,"byte_start":39511,"column_end":57,"column_start":13,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1404,"line_start":1404,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":57,"highlight_start":13,"text":"            assert_eq!(elem.value, TestValue::default());"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`TestValue` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":83,"highlight_start":72,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1411:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `allocate` not found for this struct\n...\n1384 |     struct TestValue {\n     |     ---------------- doesn't satisfy `TestValue: Copy`\n...\n1411 |         hashmap.allocate();\n     |                 ^^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `TestValue` with `#[derive(Clone, Copy)]`\n     |\n1384 +     #[derive(Clone, Copy)]\n1385 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":38955,"byte_start":38955,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1384,"line_start":1384,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":39748,"byte_start":39740,"column_end":25,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1411,"line_start":1411,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":25,"highlight_start":17,"text":"        hashmap.allocate();"}]},{"byte_end":38971,"byte_start":38955,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `TestValue: Copy`","line_end":1384,"line_start":1384,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `allocate` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1415:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `allocate` not found for this struct\n...\n1384 |     struct TestValue {\n     |     ---------------- doesn't satisfy `TestValue: Copy`\n...\n1415 |         hashmap.allocate();\n     |                 ^^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `TestValue` with `#[derive(Clone, Copy)]`\n     |\n1384 +     #[derive(Clone, Copy)]\n1385 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":38955,"byte_start":38955,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1384,"line_start":1384,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":39857,"byte_start":39849,"column_end":25,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1415,"line_start":1415,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":25,"highlight_start":17,"text":"        hashmap.allocate();"}]},{"byte_end":38971,"byte_start":38955,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `TestValue: Copy`","line_end":1384,"line_start":1384,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `allocate` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0369]: binary operation `==` cannot be applied to type `Option<Vec<GrowingHashmapMapElemChar<TestValue>>>`\n    --> src/lib.rs:1418:9\n     |\n1418 |         assert_eq!(hashmap.map, old_map);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |         |\n     |         Option<Vec<GrowingHashmapMapElemChar<TestValue>>>\n     |         Option<Vec<GrowingHashmapMapElemChar<TestValue>>>\n     |\nnote: an implementation of `PartialEq` might be missing for `GrowingHashmapMapElemChar<TestValue>`\n    --> src/lib.rs:428:1\n     |\n428  | struct GrowingHashmapMapElemChar<ValueType> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<TestValue>` with `#[derive(PartialEq)]`\n     |\n428  + #[derive(PartialEq)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"an implementation of `PartialEq` might be missing for `GrowingHashmapMapElemChar<TestValue>`","rendered":null,"spans":[{"byte_end":12762,"byte_start":12719,"column_end":44,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"must implement `PartialEq`","line_end":428,"line_start":428,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":44,"highlight_start":1,"text":"struct GrowingHashmapMapElemChar<ValueType> {"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `GrowingHashmapMapElemChar<TestValue>` with `#[derive(PartialEq)]`","rendered":null,"spans":[{"byte_end":12719,"byte_start":12719,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":428,"line_start":428,"suggested_replacement":"#[derive(PartialEq)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":1,"highlight_start":1,"text":"struct GrowingHashmapMapElemChar<ValueType> {"}]}]}],"code":{"code":"E0369","explanation":"A binary operation was attempted on a type which doesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\"Your text\".to_owned()`.\n"},"level":"error","message":"binary operation `==` cannot be applied to type `Option<Vec<GrowingHashmapMapElemChar<TestValue>>>`","spans":[{"byte_end":1239,"byte_start":1230,"column_end":31,"column_start":22,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39946,"byte_start":39914,"column_end":41,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1418,"line_start":1418,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":41,"highlight_start":9,"text":"        assert_eq!(hashmap.map, old_map);"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":"Option<Vec<GrowingHashmapMapElemChar<TestValue>>>","line_end":40,"line_start":40,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":31,"highlight_start":22,"text":"                if !(*left_val == *right_val) {"}]},{"byte_end":1253,"byte_start":1243,"column_end":45,"column_start":35,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39946,"byte_start":39914,"column_end":41,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1418,"line_start":1418,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":41,"highlight_start":9,"text":"        assert_eq!(hashmap.map, old_map);"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":"Option<Vec<GrowingHashmapMapElemChar<TestValue>>>","line_end":40,"line_start":40,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":45,"highlight_start":35,"text":"                if !(*left_val == *right_val) {"}]},{"byte_end":1242,"byte_start":1240,"column_end":34,"column_start":32,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39946,"byte_start":39914,"column_end":41,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1418,"line_start":1418,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":41,"highlight_start":9,"text":"        assert_eq!(hashmap.map, old_map);"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":null,"line_end":40,"line_start":40,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":34,"highlight_start":32,"text":"                if !(*left_val == *right_val) {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `GrowingHashmapMapElemChar<TestValue>` doesn't implement `Debug`\n    --> src/lib.rs:1418:9\n     |\n1418 |         assert_eq!(hashmap.map, old_map);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<TestValue>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<TestValue>`, which is required by `Option<Vec<GrowingHashmapMapElemChar<TestValue>>>: Debug`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<TestValue>` or manually `impl Debug for GrowingHashmapMapElemChar<TestValue>`\n     = help: the trait `Debug` is implemented for `Option<T>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<TestValue>`, which is required by `Option<Vec<GrowingHashmapMapElemChar<TestValue>>>: Debug`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<TestValue>` or manually `impl Debug for GrowingHashmapMapElemChar<TestValue>`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"the trait `Debug` is implemented for `Option<T>`","rendered":null,"spans":[]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`GrowingHashmapMapElemChar<TestValue>` doesn't implement `Debug`","spans":[{"byte_end":1629,"byte_start":1619,"column_end":70,"column_start":60,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39946,"byte_start":39914,"column_end":41,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1418,"line_start":1418,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":41,"highlight_start":9,"text":"        assert_eq!(hashmap.map, old_map);"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`GrowingHashmapMapElemChar<TestValue>` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":70,"highlight_start":60,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `GrowingHashmapMapElemChar<TestValue>` doesn't implement `Debug`\n    --> src/lib.rs:1418:9\n     |\n1418 |         assert_eq!(hashmap.map, old_map);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<TestValue>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<TestValue>`, which is required by `Option<Vec<GrowingHashmapMapElemChar<TestValue>>>: Debug`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<TestValue>` or manually `impl Debug for GrowingHashmapMapElemChar<TestValue>`\n     = help: the trait `Debug` is implemented for `Option<T>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<TestValue>`, which is required by `Option<Vec<GrowingHashmapMapElemChar<TestValue>>>: Debug`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<TestValue>` or manually `impl Debug for GrowingHashmapMapElemChar<TestValue>`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"the trait `Debug` is implemented for `Option<T>`","rendered":null,"spans":[]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`GrowingHashmapMapElemChar<TestValue>` doesn't implement `Debug`","spans":[{"byte_end":1642,"byte_start":1631,"column_end":83,"column_start":72,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39946,"byte_start":39914,"column_end":41,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1418,"line_start":1418,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":41,"highlight_start":9,"text":"        assert_eq!(hashmap.map, old_map);"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`GrowingHashmapMapElemChar<TestValue>` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":83,"highlight_start":72,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error: aborting due to 8 previous errors; 5 warnings emitted\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"aborting due to 8 previous errors; 5 warnings emitted","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"Some errors have detailed explanations: E0277, E0369, E0599.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"Some errors have detailed explanations: E0277, E0369, E0599.","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"For more information about an error, try `rustc --explain E0277`.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"For more information about an error, try `rustc --explain E0277`.","spans":[]}}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rlib","/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rmeta"],"executable":null,"fresh":false}
{"reason":"build-finished","success":false}

========================================
inject err GrowingHashmapChar::<ValueType>::get src/lib.rs get

#[cfg(test)]
mod tests_llm_16_7 {
    use super::*;

use crate::*;
    use std::default::Default;

    #[derive(Default, Clone, Copy, Eq, PartialEq)]
    struct TestValue {
        value: i32,
    }

    #[derive(Default)]
    struct GrowingHashmapMapElemChar<ValueType> {
        key: u32,
        value: ValueType,
    }

    #[test]
    fn test_get_with_empty_map() {
        let hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();
        let result = hashmap.get(0);
        assert_eq!(result, TestValue::default());
    }

    #[test]
    fn test_get_with_non_empty_map() {
        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();
        hashmap.get_mut(1).value = TestValue { value: 42 }; // Insert a value
        let result = hashmap.get(1);
        assert_eq!(result, TestValue { value: 42 });
    }

    #[test]
    fn test_get_non_existent() {
        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();
        hashmap.get_mut(2).value = TestValue { value: 100 }; // Insert a value
        let result = hashmap.get(3);
        assert_eq!(result, TestValue::default());
    }
}

{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `super::*`\n    --> src/lib.rs:1311:9\n     |\n1311 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"`#[warn(unused_imports)]` on by default","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37266,"byte_start":37253,"column_end":18,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":18,"highlight_start":5,"text":"    use super::*;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `super::*`","spans":[{"byte_end":37265,"byte_start":37257,"column_end":17,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":17,"highlight_start":9,"text":"    use super::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1313:5\n     |\n1313 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37282,"byte_start":37268,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1314,"line_start":1313,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use crate::StringWrapper;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":37280,"byte_start":37272,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1313,"line_start":1313,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1342:5\n     |\n1342 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38014,"byte_start":38000,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1343,"line_start":1342,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38012,"byte_start":38004,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1342,"line_start":1342,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1368:5\n     |\n1368 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38706,"byte_start":38692,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1369,"line_start":1368,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":""}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38704,"byte_start":38696,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1368,"line_start":1368,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1381:5\n     |\n1381 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38901,"byte_start":38887,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1382,"line_start":1381,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38899,"byte_start":38891,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1381,"line_start":1381,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rlib","/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"lib","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/tests/lib.rs","edition":"2021","doc":false,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/lib-2bbdf63c70c07263"],"executable":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/lib-2bbdf63c70c07263","fresh":false}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `TestValue` doesn't implement `Debug`\n    --> src/lib.rs:1399:9\n     |\n1399 |         assert_eq!(result, TestValue::default());\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `TestValue` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `TestValue`\n     = note: add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `TestValue` with `#[derive(Debug)]`\n     |\n1385 +     #[derive(Debug)]\n1386 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Debug)]`","rendered":null,"spans":[{"byte_end":38988,"byte_start":38988,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1385,"line_start":1385,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`TestValue` doesn't implement `Debug`","spans":[{"byte_end":1629,"byte_start":1619,"column_end":70,"column_start":60,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39374,"byte_start":39334,"column_end":49,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1399,"line_start":1399,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":49,"highlight_start":9,"text":"        assert_eq!(result, TestValue::default());"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`TestValue` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":70,"highlight_start":60,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `TestValue` doesn't implement `Debug`\n    --> src/lib.rs:1399:9\n     |\n1399 |         assert_eq!(result, TestValue::default());\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `TestValue` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `TestValue`\n     = note: add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `TestValue` with `#[derive(Debug)]`\n     |\n1385 +     #[derive(Debug)]\n1386 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Debug)]`","rendered":null,"spans":[{"byte_end":38988,"byte_start":38988,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1385,"line_start":1385,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`TestValue` doesn't implement `Debug`","spans":[{"byte_end":1642,"byte_start":1631,"column_end":83,"column_start":72,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39374,"byte_start":39334,"column_end":49,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1399,"line_start":1399,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":49,"highlight_start":9,"text":"        assert_eq!(result, TestValue::default());"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`TestValue` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":83,"highlight_start":72,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0308]: mismatched types\n    --> src/lib.rs:1405:36\n     |\n1405 |         hashmap.get_mut(1).value = TestValue { value: 42 }; // Insert a value\n     |         ------------------------   ^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `TestValue`\n     |         |\n     |         expected due to the type of this binding\n\n","$message_type":"diagnostic","children":[],"code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","message":"mismatched types","spans":[{"byte_end":39580,"byte_start":39557,"column_end":59,"column_start":36,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"expected `i32`, found `TestValue`","line_end":1405,"line_start":1405,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":59,"highlight_start":36,"text":"        hashmap.get_mut(1).value = TestValue { value: 42 }; // Insert a value"}]},{"byte_end":39554,"byte_start":39530,"column_end":33,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"expected due to the type of this binding","line_end":1405,"line_start":1405,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":33,"highlight_start":9,"text":"        hashmap.get_mut(1).value = TestValue { value: 42 }; // Insert a value"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `TestValue` doesn't implement `Debug`\n    --> src/lib.rs:1407:9\n     |\n1407 |         assert_eq!(result, TestValue { value: 42 });\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `TestValue` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `TestValue`\n     = note: add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `TestValue` with `#[derive(Debug)]`\n     |\n1385 +     #[derive(Debug)]\n1386 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Debug)]`","rendered":null,"spans":[{"byte_end":38988,"byte_start":38988,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1385,"line_start":1385,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`TestValue` doesn't implement `Debug`","spans":[{"byte_end":1629,"byte_start":1619,"column_end":70,"column_start":60,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39688,"byte_start":39645,"column_end":52,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1407,"line_start":1407,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":52,"highlight_start":9,"text":"        assert_eq!(result, TestValue { value: 42 });"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`TestValue` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":70,"highlight_start":60,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `TestValue` doesn't implement `Debug`\n    --> src/lib.rs:1407:9\n     |\n1407 |         assert_eq!(result, TestValue { value: 42 });\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `TestValue` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `TestValue`\n     = note: add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `TestValue` with `#[derive(Debug)]`\n     |\n1385 +     #[derive(Debug)]\n1386 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Debug)]`","rendered":null,"spans":[{"byte_end":38988,"byte_start":38988,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1385,"line_start":1385,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`TestValue` doesn't implement `Debug`","spans":[{"byte_end":1642,"byte_start":1631,"column_end":83,"column_start":72,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39688,"byte_start":39645,"column_end":52,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1407,"line_start":1407,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":52,"highlight_start":9,"text":"        assert_eq!(result, TestValue { value: 42 });"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`TestValue` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":83,"highlight_start":72,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0308]: mismatched types\n    --> src/lib.rs:1413:36\n     |\n1413 |         hashmap.get_mut(2).value = TestValue { value: 100 }; // Insert a value\n     |         ------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `TestValue`\n     |         |\n     |         expected due to the type of this binding\n\n","$message_type":"diagnostic","children":[],"code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","message":"mismatched types","spans":[{"byte_end":39889,"byte_start":39865,"column_end":60,"column_start":36,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"expected `i32`, found `TestValue`","line_end":1413,"line_start":1413,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":60,"highlight_start":36,"text":"        hashmap.get_mut(2).value = TestValue { value: 100 }; // Insert a value"}]},{"byte_end":39862,"byte_start":39838,"column_end":33,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"expected due to the type of this binding","line_end":1413,"line_start":1413,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":33,"highlight_start":9,"text":"        hashmap.get_mut(2).value = TestValue { value: 100 }; // Insert a value"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `TestValue` doesn't implement `Debug`\n    --> src/lib.rs:1415:9\n     |\n1415 |         assert_eq!(result, TestValue::default());\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `TestValue` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `TestValue`\n     = note: add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `TestValue` with `#[derive(Debug)]`\n     |\n1385 +     #[derive(Debug)]\n1386 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Debug)]`","rendered":null,"spans":[{"byte_end":38988,"byte_start":38988,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1385,"line_start":1385,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`TestValue` doesn't implement `Debug`","spans":[{"byte_end":1629,"byte_start":1619,"column_end":70,"column_start":60,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39994,"byte_start":39954,"column_end":49,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1415,"line_start":1415,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":49,"highlight_start":9,"text":"        assert_eq!(result, TestValue::default());"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`TestValue` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":70,"highlight_start":60,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: `TestValue` doesn't implement `Debug`\n    --> src/lib.rs:1415:9\n     |\n1415 |         assert_eq!(result, TestValue::default());\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `TestValue` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `TestValue`\n     = note: add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `TestValue` with `#[derive(Debug)]`\n     |\n1385 +     #[derive(Debug)]\n1386 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Debug` is not implemented for `TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"add `#[derive(Debug)]` to `TestValue` or manually `impl Debug for TestValue`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"consider annotating `TestValue` with `#[derive(Debug)]`","rendered":null,"spans":[{"byte_end":38988,"byte_start":38988,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1385,"line_start":1385,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"`TestValue` doesn't implement `Debug`","spans":[{"byte_end":1642,"byte_start":1631,"column_end":83,"column_start":72,"expansion":{"def_site_span":{"byte_end":1092,"byte_start":1070,"column_end":23,"column_start":1,"expansion":null,"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":false,"label":null,"line_end":36,"line_start":36,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":23,"highlight_start":1,"text":"macro_rules! assert_eq {"}]},"macro_decl_name":"assert_eq!","span":{"byte_end":39994,"byte_start":39954,"column_end":49,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":null,"line_end":1415,"line_start":1415,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":49,"highlight_start":9,"text":"        assert_eq!(result, TestValue::default());"}]}},"file_name":"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs","is_primary":true,"label":"`TestValue` cannot be formatted using `{:?}`","line_end":45,"line_start":45,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":83,"highlight_start":72,"text":"                    $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error: aborting due to 8 previous errors; 5 warnings emitted\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"aborting due to 8 previous errors; 5 warnings emitted","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"Some errors have detailed explanations: E0277, E0308.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"Some errors have detailed explanations: E0277, E0308.","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"For more information about an error, try `rustc --explain E0277`.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"For more information about an error, try `rustc --explain E0277`.","spans":[]}}
{"reason":"build-finished","success":false}

inject succeed strsim-rs strsim GrowingHashmapChar::<ValueType>::get_mut
========================================
inject err GrowingHashmapChar::<ValueType>::grow src/lib.rs grow

#[cfg(test)]
mod tests_llm_16_9 {
    use super::*;

use crate::*;
    use std::default::Default;

    #[derive(Default, Clone, PartialEq, Eq)]
    struct TestValue {
        data: i32,
    }

    #[derive(Default, Clone)]
    struct GrowingHashmapMapElemChar<ValueType> {
        key: u32,
        value: ValueType,
    }

    #[test]
    fn test_grow() {
        let mut hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();
        hashmap.allocate();
        
        // Add some elements to trigger a growth
        for i in 0..6 {
            hashmap.get_mut(i).data = i;
        }

        let old_mask = hashmap.mask;
        hashmap.grow(6);

        // Assert that the mask size has increased
        assert!(hashmap.mask > old_mask);
        assert_eq!(hashmap.fill, 6);
        assert_eq!(hashmap.used, 6);

        // Verify if the elements are still present after grow
        for i in 0..6 {
            assert_eq!(hashmap.get(i).data, i);
        }
    }
}

{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `super::*`\n    --> src/lib.rs:1311:9\n     |\n1311 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"`#[warn(unused_imports)]` on by default","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37266,"byte_start":37253,"column_end":18,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":18,"highlight_start":5,"text":"    use super::*;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `super::*`","spans":[{"byte_end":37265,"byte_start":37257,"column_end":17,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":17,"highlight_start":9,"text":"    use super::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1313:5\n     |\n1313 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37282,"byte_start":37268,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1314,"line_start":1313,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use crate::StringWrapper;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":37280,"byte_start":37272,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1313,"line_start":1313,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1342:5\n     |\n1342 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38014,"byte_start":38000,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1343,"line_start":1342,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38012,"byte_start":38004,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1342,"line_start":1342,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1368:5\n     |\n1368 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38706,"byte_start":38692,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1369,"line_start":1368,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":""}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38704,"byte_start":38696,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1368,"line_start":1368,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1381:5\n     |\n1381 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38901,"byte_start":38887,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1382,"line_start":1381,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    #[derive(Default, Clone, Copy, PartialEq, Eq)]"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38899,"byte_start":38891,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1381,"line_start":1381,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1435:5\n     |\n1435 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":40193,"byte_start":40179,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1436,"line_start":1435,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":40191,"byte_start":40183,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1435,"line_start":1435,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rlib","/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1452:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `allocate` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_9::TestValue: Copy`\n...\n1452 |         hashmap.allocate();\n     |                 ^^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_9::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_9::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_9::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_9::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40274,"byte_start":40274,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":40595,"byte_start":40587,"column_end":25,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1452,"line_start":1452,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":25,"highlight_start":17,"text":"        hashmap.allocate();"}]},{"byte_end":40290,"byte_start":40274,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_9::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `allocate` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `get_mut` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1456:21\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `get_mut` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_9::TestValue: Copy`\n...\n1456 |             hashmap.get_mut(i).data = i;\n     |                     ^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_9::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_9::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_9::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_9::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40274,"byte_start":40274,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `get_mut` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":40708,"byte_start":40701,"column_end":28,"column_start":21,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1456,"line_start":1456,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":28,"highlight_start":21,"text":"            hashmap.get_mut(i).data = i;"}]},{"byte_end":40290,"byte_start":40274,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_9::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `get_mut` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `grow` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1460:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `grow` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_9::TestValue: Copy`\n...\n1460 |         hashmap.grow(6);\n     |                 ^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_9::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_9::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_9::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_9::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40274,"byte_start":40274,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `grow` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":40790,"byte_start":40786,"column_end":21,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1460,"line_start":1460,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":17,"text":"        hashmap.grow(6);"}]},{"byte_end":40290,"byte_start":40274,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_9::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `grow` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `get` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1469:32\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `get` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_9::TestValue: Copy`\n...\n1469 |             assert_eq!(hashmap.get(i).data, i);\n     |                                ^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_9::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_9::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_9::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_9::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40274,"byte_start":40274,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `get` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41085,"byte_start":41082,"column_end":35,"column_start":32,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1469,"line_start":1469,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":35,"highlight_start":32,"text":"            assert_eq!(hashmap.get(i).data, i);"}]},{"byte_end":40290,"byte_start":40274,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_9::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `get` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error: aborting due to 4 previous errors; 6 warnings emitted\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"aborting due to 4 previous errors; 6 warnings emitted","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"For more information about this error, try `rustc --explain E0599`.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"For more information about this error, try `rustc --explain E0599`.","spans":[]}}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"lib","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/tests/lib.rs","edition":"2021","doc":false,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/lib-2bbdf63c70c07263"],"executable":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/lib-2bbdf63c70c07263","fresh":false}
{"reason":"build-finished","success":false}

========================================
inject err GrowingHashmapChar::<ValueType>::lookup src/lib.rs lookup

#[cfg(test)]
mod tests_llm_16_10 {
    use super::*;

use crate::*;
    use std::default::Default;

    #[derive(Default, Clone, PartialEq, Eq)]
    struct TestValue {
        pub value: usize,
    }

    #[derive(Default)]
    struct GrowingHashmapMapElemChar<ValueType> {
        pub key: u32,
        pub value: ValueType,
    }

    #[test]
    fn test_lookup_empty_map() {
        let hashmap: GrowingHashmapChar<TestValue> = GrowingHashmapChar::default();
        let key = 42;
        let index = hashmap.lookup(key);
        assert_eq!(index, 0);
    }

    #[test]
    fn test_lookup_existing_key() {
        let mut hashmap = GrowingHashmapChar::<TestValue>::default();
        hashmap.allocate();
        hashmap.get_mut(42).value = 1;  // Insert key 42
        let index = hashmap.lookup(42);
        assert_eq!(index, 0);
        assert_eq!(hashmap.get(42).value, 1);
    }

    #[test]
    fn test_lookup_collisions() {
        let mut hashmap = GrowingHashmapChar::<TestValue>::default();
        hashmap.allocate();
        hashmap.get_mut(43).value = 1;  // Insert key 43
        hashmap.get_mut(42).value = 2;  // Insert key 42
        let index1 = hashmap.lookup(43);
        let index2 = hashmap.lookup(42);
        assert!(index1 != index2); // Check they are in different indices
        assert_eq!(hashmap.get(43).value, 1);
        assert_eq!(hashmap.get(42).value, 2);
    }

    #[test]
    fn test_lookup_non_existing_key() {
        let mut hashmap = GrowingHashmapChar::<TestValue>::default();
        hashmap.allocate();
        hashmap.get_mut(42).value = 1;  // Insert key 42
        let index = hashmap.lookup(99);  // Look for non-existing key 99
        assert_ne!(index, 0);  // Ensure it does not point to the same index
    }
}

{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `super::*`\n    --> src/lib.rs:1311:9\n     |\n1311 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"`#[warn(unused_imports)]` on by default","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37266,"byte_start":37253,"column_end":18,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":18,"highlight_start":5,"text":"    use super::*;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `super::*`","spans":[{"byte_end":37265,"byte_start":37257,"column_end":17,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":17,"highlight_start":9,"text":"    use super::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1313:5\n     |\n1313 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37282,"byte_start":37268,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1314,"line_start":1313,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use crate::StringWrapper;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":37280,"byte_start":37272,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1313,"line_start":1313,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1342:5\n     |\n1342 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38014,"byte_start":38000,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1343,"line_start":1342,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38012,"byte_start":38004,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1342,"line_start":1342,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1368:5\n     |\n1368 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38706,"byte_start":38692,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1369,"line_start":1368,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":""}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38704,"byte_start":38696,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1368,"line_start":1368,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1381:5\n     |\n1381 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38901,"byte_start":38887,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1382,"line_start":1381,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    #[derive(Default, Clone, Copy, PartialEq, Eq)]"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38899,"byte_start":38891,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1381,"line_start":1381,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1435:5\n     |\n1435 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":40194,"byte_start":40180,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1436,"line_start":1435,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":40192,"byte_start":40184,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1435,"line_start":1435,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `lookup` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1453:29\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `lookup` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1453 |         let index = hashmap.lookup(key);\n     |                             ^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `lookup` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":40644,"byte_start":40638,"column_end":35,"column_start":29,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1453,"line_start":1453,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":35,"highlight_start":29,"text":"        let index = hashmap.lookup(key);"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `lookup` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1460:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `allocate` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1460 |         hashmap.allocate();\n     |                 ^^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":40830,"byte_start":40822,"column_end":25,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1460,"line_start":1460,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":25,"highlight_start":17,"text":"        hashmap.allocate();"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `allocate` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `get_mut` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1461:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `get_mut` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1461 |         hashmap.get_mut(42).value = 1;  // Insert key 42\n     |                 ^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `get_mut` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":40857,"byte_start":40850,"column_end":24,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1461,"line_start":1461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":24,"highlight_start":17,"text":"        hashmap.get_mut(42).value = 1;  // Insert key 42"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `get_mut` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `lookup` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1462:29\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `lookup` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1462 |         let index = hashmap.lookup(42);\n     |                             ^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `lookup` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":40925,"byte_start":40919,"column_end":35,"column_start":29,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1462,"line_start":1462,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":35,"highlight_start":29,"text":"        let index = hashmap.lookup(42);"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `lookup` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `get` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1464:28\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `get` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1464 |         assert_eq!(hashmap.get(42).value, 1);\n     |                            ^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `get` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":40991,"byte_start":40988,"column_end":31,"column_start":28,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1464,"line_start":1464,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":31,"highlight_start":28,"text":"        assert_eq!(hashmap.get(42).value, 1);"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `get` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rlib","/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1470:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `allocate` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1470 |         hashmap.allocate();\n     |                 ^^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41154,"byte_start":41146,"column_end":25,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1470,"line_start":1470,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":25,"highlight_start":17,"text":"        hashmap.allocate();"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `allocate` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `get_mut` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1471:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `get_mut` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1471 |         hashmap.get_mut(43).value = 1;  // Insert key 43\n     |                 ^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `get_mut` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41181,"byte_start":41174,"column_end":24,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1471,"line_start":1471,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":24,"highlight_start":17,"text":"        hashmap.get_mut(43).value = 1;  // Insert key 43"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `get_mut` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `get_mut` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1472:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `get_mut` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1472 |         hashmap.get_mut(42).value = 2;  // Insert key 42\n     |                 ^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `get_mut` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41238,"byte_start":41231,"column_end":24,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1472,"line_start":1472,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":24,"highlight_start":17,"text":"        hashmap.get_mut(42).value = 2;  // Insert key 42"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `get_mut` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `lookup` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1473:30\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `lookup` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1473 |         let index1 = hashmap.lookup(43);\n     |                              ^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `lookup` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41307,"byte_start":41301,"column_end":36,"column_start":30,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1473,"line_start":1473,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":36,"highlight_start":30,"text":"        let index1 = hashmap.lookup(43);"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `lookup` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `lookup` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1474:30\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `lookup` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1474 |         let index2 = hashmap.lookup(42);\n     |                              ^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `lookup` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41348,"byte_start":41342,"column_end":36,"column_start":30,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1474,"line_start":1474,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":36,"highlight_start":30,"text":"        let index2 = hashmap.lookup(42);"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `lookup` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `get` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1476:28\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `get` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1476 |         assert_eq!(hashmap.get(43).value, 1);\n     |                            ^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `get` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41458,"byte_start":41455,"column_end":31,"column_start":28,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1476,"line_start":1476,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":31,"highlight_start":28,"text":"        assert_eq!(hashmap.get(43).value, 1);"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `get` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `get` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1477:28\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `get` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1477 |         assert_eq!(hashmap.get(42).value, 2);\n     |                            ^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `get` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41504,"byte_start":41501,"column_end":31,"column_start":28,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1477,"line_start":1477,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":31,"highlight_start":28,"text":"        assert_eq!(hashmap.get(42).value, 2);"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `get` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1483:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `allocate` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1483 |         hashmap.allocate();\n     |                 ^^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `allocate` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41673,"byte_start":41665,"column_end":25,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1483,"line_start":1483,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":25,"highlight_start":17,"text":"        hashmap.allocate();"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `allocate` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `get_mut` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1484:17\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `get_mut` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1484 |         hashmap.get_mut(42).value = 1;  // Insert key 42\n     |                 ^^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `get_mut` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41700,"byte_start":41693,"column_end":24,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1484,"line_start":1484,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":24,"highlight_start":17,"text":"        hashmap.get_mut(42).value = 1;  // Insert key 42"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `get_mut` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0599]: the method `lookup` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied\n    --> src/lib.rs:1485:29\n     |\n440  | struct GrowingHashmapChar<ValueType> {\n     | ------------------------------------ method `lookup` not found for this struct\n...\n1439 |     struct TestValue {\n     |     ---------------- doesn't satisfy `tests_llm_16_10::TestValue: Copy`\n...\n1485 |         let index = hashmap.lookup(99);  // Look for non-existing key 99\n     |                             ^^^^^^ method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds\n     |\nnote: trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied\n    --> src/lib.rs:463:39\n     |\n461  | impl<ValueType> GrowingHashmapChar<ValueType>\n     |                 -----------------------------\n462  | where\n463  |     ValueType: Default + Clone + Eq + Copy,\n     |                                       ^^^^ unsatisfied trait bound introduced here\nhelp: consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`\n     |\n1439 +     #[derive(Clone, Copy)]\n1440 |     struct TestValue {\n     |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"trait bound `tests_llm_16_10::TestValue: Copy` was not satisfied","rendered":null,"spans":[{"byte_end":13770,"byte_start":13766,"column_end":43,"column_start":39,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"unsatisfied trait bound introduced here","line_end":463,"line_start":463,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":39,"text":"    ValueType: Default + Clone + Eq + Copy,"}]},{"byte_end":13721,"byte_start":13692,"column_end":46,"column_start":17,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"","line_end":461,"line_start":461,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":17,"text":"impl<ValueType> GrowingHashmapChar<ValueType>"}]}]},{"children":[],"code":null,"level":"help","message":"consider annotating `tests_llm_16_10::TestValue` with `#[derive(Clone, Copy)]`","rendered":null,"spans":[{"byte_end":40275,"byte_start":40275,"column_end":5,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1439,"line_start":1439,"suggested_replacement":"#[derive(Clone, Copy)]\n","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":5,"highlight_start":5,"text":"    struct TestValue {"}]}]}],"code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","message":"the method `lookup` exists for struct `GrowingHashmapChar<TestValue>`, but its trait bounds were not satisfied","spans":[{"byte_end":41768,"byte_start":41762,"column_end":35,"column_start":29,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"method cannot be called on `GrowingHashmapChar<TestValue>` due to unsatisfied trait bounds","line_end":1485,"line_start":1485,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":35,"highlight_start":29,"text":"        let index = hashmap.lookup(99);  // Look for non-existing key 99"}]},{"byte_end":40291,"byte_start":40275,"column_end":21,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"doesn't satisfy `tests_llm_16_10::TestValue: Copy`","line_end":1439,"line_start":1439,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":21,"highlight_start":5,"text":"    struct TestValue {"}]},{"byte_end":13314,"byte_start":13278,"column_end":37,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"method `lookup` not found for this struct","line_end":440,"line_start":440,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":37,"highlight_start":1,"text":"struct GrowingHashmapChar<ValueType> {"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error: aborting due to 15 previous errors; 6 warnings emitted\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"aborting due to 15 previous errors; 6 warnings emitted","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"For more information about this error, try `rustc --explain E0599`.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"For more information about this error, try `rustc --explain E0599`.","spans":[]}}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"lib","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/tests/lib.rs","edition":"2021","doc":false,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/lib-2bbdf63c70c07263"],"executable":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/lib-2bbdf63c70c07263","fresh":false}
{"reason":"build-finished","success":false}

inject succeed strsim-rs strsim HybridGrowingHashmapChar::<ValueType>::get
inject succeed strsim-rs strsim HybridGrowingHashmapChar::<ValueType>::get_mut
inject succeed strsim-rs strsim bigrams
inject succeed strsim-rs strsim damerau_levenshtein
inject succeed strsim-rs strsim damerau_levenshtein_impl
inject succeed strsim-rs strsim flat_index
inject succeed strsim-rs strsim generic_damerau_levenshtein
inject succeed strsim-rs strsim generic_hamming
inject succeed strsim-rs strsim generic_jaro
inject succeed strsim-rs strsim generic_jaro_winkler
========================================
inject err generic_levenshtein src/lib.rs generic_levenshtein

#[cfg(test)]
mod tests_llm_16_21 {
    use crate::generic_levenshtein;

    #[derive(Clone, Eq, PartialEq, Debug)]
    struct RowId {
        val: isize,
    }

    impl Default for RowId {
        fn default() -> Self {
            Self { val: -1 }
        }
    }

    #[test]
    fn test_generic_levenshtein_basic() {
        assert_eq!(3, generic_levenshtein(&[1, 2, 3], &[1, 2, 3, 4, 5, 6]));
    }

    #[test]
    fn test_generic_levenshtein_identical() {
        assert_eq!(0, generic_levenshtein(&[1, 2, 3], &[1, 2, 3]));
    }

    #[test]
    fn test_generic_levenshtein_insertions() {
        assert_eq!(2, generic_levenshtein(&[1, 2], &[1, 2, 3, 4]));
    }

    #[test]
    fn test_generic_levenshtein_deletions() {
        assert_eq!(2, generic_levenshtein(&[1, 2, 3, 4], &[1, 2]));
    }

    #[test]
    fn test_generic_levenshtein_substitutions() {
        assert_eq!(1, generic_levenshtein(&[1, 2, 3], &[3, 2, 1]));
    }

    #[test]
    fn test_generic_levenshtein_empty() {
        assert_eq!(3, generic_levenshtein(&[], &[1, 2, 3]));
        assert_eq!(3, generic_levenshtein(&[1, 2, 3], &[]));
    }

    #[test]
    fn test_generic_levenshtein_rowid() {
        let a: &[RowId] = &[RowId { val: 1 }, RowId { val: 2 }];
        let b: &[RowId] = &[RowId { val: 1 }, RowId { val: 2 }, RowId { val: 3 }];
        assert_eq!(1, generic_levenshtein(a, b));
    }
}

{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":false},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rlib","/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/libstrsim-bb7de0032fe2f47b.rmeta"],"executable":null,"fresh":false}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `super::*`\n    --> src/lib.rs:1311:9\n     |\n1311 |     use super::*;\n     |         ^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"`#[warn(unused_imports)]` on by default","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37266,"byte_start":37253,"column_end":18,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":18,"highlight_start":5,"text":"    use super::*;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `super::*`","spans":[{"byte_end":37265,"byte_start":37257,"column_end":17,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1311,"line_start":1311,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":17,"highlight_start":9,"text":"    use super::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1313:5\n     |\n1313 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":37282,"byte_start":37268,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1314,"line_start":1313,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use crate::StringWrapper;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":37280,"byte_start":37272,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1313,"line_start":1313,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1342:5\n     |\n1342 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38014,"byte_start":38000,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1343,"line_start":1342,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38012,"byte_start":38004,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1342,"line_start":1342,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1368:5\n     |\n1368 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38706,"byte_start":38692,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1369,"line_start":1368,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":""}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38704,"byte_start":38696,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1368,"line_start":1368,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1381:5\n     |\n1381 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":38901,"byte_start":38887,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1382,"line_start":1381,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    #[derive(Default, Clone, Copy, PartialEq, Eq)]"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":38899,"byte_start":38891,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1381,"line_start":1381,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1435:5\n     |\n1435 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":40194,"byte_start":40180,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1436,"line_start":1435,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":""}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":40192,"byte_start":40184,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1435,"line_start":1435,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1486:5\n     |\n1486 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":41887,"byte_start":41873,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1487,"line_start":1486,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::default::Default;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":41885,"byte_start":41877,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1486,"line_start":1486,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1531:5\n     |\n1531 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":43051,"byte_start":43037,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1532,"line_start":1531,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":""}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":43049,"byte_start":43041,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1531,"line_start":1531,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `super::*`\n    --> src/lib.rs:1566:9\n     |\n1566 |     use super::*;\n     |         ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":43957,"byte_start":43944,"column_end":18,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1566,"line_start":1566,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":18,"highlight_start":5,"text":"    use super::*;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `super::*`","spans":[{"byte_end":43956,"byte_start":43948,"column_end":17,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1566,"line_start":1566,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":17,"highlight_start":9,"text":"    use super::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1568:5\n     |\n1568 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":43973,"byte_start":43959,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1569,"line_start":1568,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use crate::damerau_levenshtein;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":43971,"byte_start":43963,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1568,"line_start":1568,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1588:5\n     |\n1588 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":44611,"byte_start":44597,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1589,"line_start":1588,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::iter::Iterator;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":44609,"byte_start":44601,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1588,"line_start":1588,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1629:5\n     |\n1629 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":46036,"byte_start":46022,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1630,"line_start":1629,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":""}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":46034,"byte_start":46026,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1629,"line_start":1629,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1649:5\n     |\n1649 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":46565,"byte_start":46551,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1650,"line_start":1649,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::collections::HashMap;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":46563,"byte_start":46555,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1649,"line_start":1649,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `std::collections::HashMap`\n    --> src/lib.rs:1650:9\n     |\n1650 |     use std::collections::HashMap;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":46599,"byte_start":46569,"column_end":35,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1650,"line_start":1650,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":35,"highlight_start":5,"text":"    use std::collections::HashMap;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `std::collections::HashMap`","spans":[{"byte_end":46598,"byte_start":46573,"column_end":34,"column_start":9,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1650,"line_start":1650,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":34,"highlight_start":9,"text":"    use std::collections::HashMap;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1693:5\n     |\n1693 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":47735,"byte_start":47721,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1694,"line_start":1693,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use std::vec;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":47733,"byte_start":47725,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1693,"line_start":1693,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1741:5\n     |\n1741 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":49218,"byte_start":49204,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1742,"line_start":1741,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use crate::RowId;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":49216,"byte_start":49208,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1741,"line_start":1741,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"warning: unused import: `crate::*`\n    --> src/lib.rs:1784:5\n     |\n1784 | use crate::*;\n     |     ^^^^^^^^\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove the whole `use` item","rendered":null,"spans":[{"byte_end":50387,"byte_start":50373,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1785,"line_start":1784,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":14,"highlight_start":1,"text":"use crate::*;"},{"highlight_end":1,"highlight_start":1,"text":"    use crate::RowId;"}]}]}],"code":{"code":"unused_imports","explanation":null},"level":"warning","message":"unused import: `crate::*`","spans":[{"byte_end":50385,"byte_start":50377,"column_end":13,"column_start":5,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1784,"line_start":1784,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":5,"text":"use crate::*;"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0282]: type annotations needed\n    --> src/lib.rs:1871:23\n     |\n1871 |         assert_eq!(3, generic_levenshtein(&[], &[1, 2, 3]));\n     |                       ^^^^^^^^^^^^^^^^^^^ --- type must be known at this point\n     |                       |\n     |                       cannot infer type of the type parameter `Iter1` declared on the function `generic_levenshtein`\n     |\nhelp: consider specifying the generic arguments\n     |\n1871 |         assert_eq!(3, generic_levenshtein::<[_; 0], [i32; 3], &T, &i32>(&[], &[1, 2, 3]));\n     |                                          ++++++++++++++++++++++++++++++\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"consider specifying the generic arguments","rendered":null,"spans":[{"byte_end":53217,"byte_start":53217,"column_end":42,"column_start":42,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":1871,"line_start":1871,"suggested_replacement":"::<[_; 0], [i32; 3], &T, &i32>","suggestion_applicability":"HasPlaceholders","text":[{"highlight_end":42,"highlight_start":42,"text":"        assert_eq!(3, generic_levenshtein(&[], &[1, 2, 3]));"}]}]}],"code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","message":"type annotations needed","spans":[{"byte_end":53221,"byte_start":53218,"column_end":46,"column_start":43,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"type must be known at this point","line_end":1871,"line_start":1871,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":46,"highlight_start":43,"text":"        assert_eq!(3, generic_levenshtein(&[], &[1, 2, 3]));"}]},{"byte_end":53217,"byte_start":53198,"column_end":42,"column_start":23,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"cannot infer type of the type parameter `Iter1` declared on the function `generic_levenshtein`","line_end":1871,"line_start":1871,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":42,"highlight_start":23,"text":"        assert_eq!(3, generic_levenshtein(&[], &[1, 2, 3]));"}]}]}}
{"reason":"compiler-artifact","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["test"],"crate_types":["bin"],"name":"lib","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/tests/lib.rs","edition":"2021","doc":false,"doctest":false,"test":true},"profile":{"opt_level":"0","debuginfo":2,"debug_assertions":true,"overflow_checks":true,"test":true},"features":[],"filenames":["/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/lib-2bbdf63c70c07263"],"executable":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/target/debug/deps/lib-2bbdf63c70c07263","fresh":false}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: the size for values of type `[tests_llm_16_21::RowId]` cannot be known at compilation time\n    --> src/lib.rs:1879:43\n     |\n1879 |         assert_eq!(1, generic_levenshtein(a, b));\n     |                       ------------------- ^ doesn't have a size known at compile-time\n     |                       |\n     |                       required by a bound introduced by this call\n     |\n     = help: the trait `Sized` is not implemented for `[tests_llm_16_21::RowId]`\nnote: required by an implicit `Sized` bound in `generic_levenshtein`\n    --> src/lib.rs:233:36\n     |\n233  | pub fn generic_levenshtein<'a, 'b, Iter1, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> usize\n     |                                    ^^^^^ required by the implicit `Sized` requirement on this type parameter in `generic_levenshtein`\nhelp: consider relaxing the implicit `Sized` restriction\n     |\n233  | pub fn generic_levenshtein<'a, 'b, Iter1: ?Sized, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> usize\n     |                                         ++++++++\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Sized` is not implemented for `[tests_llm_16_21::RowId]`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"required by an implicit `Sized` bound in `generic_levenshtein`","rendered":null,"spans":[{"byte_end":6611,"byte_start":6606,"column_end":41,"column_start":36,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"required by the implicit `Sized` requirement on this type parameter in `generic_levenshtein`","line_end":233,"line_start":233,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":41,"highlight_start":36,"text":"pub fn generic_levenshtein<'a, 'b, Iter1, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> usize"}]}]},{"children":[],"code":null,"level":"help","message":"consider relaxing the implicit `Sized` restriction","rendered":null,"spans":[{"byte_end":6611,"byte_start":6611,"column_end":41,"column_start":41,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":233,"line_start":233,"suggested_replacement":": ?Sized","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":41,"highlight_start":41,"text":"pub fn generic_levenshtein<'a, 'b, Iter1, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> usize"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"the size for values of type `[tests_llm_16_21::RowId]` cannot be known at compilation time","spans":[{"byte_end":53550,"byte_start":53549,"column_end":44,"column_start":43,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"doesn't have a size known at compile-time","line_end":1879,"line_start":1879,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":44,"highlight_start":43,"text":"        assert_eq!(1, generic_levenshtein(a, b));"}]},{"byte_end":53548,"byte_start":53529,"column_end":42,"column_start":23,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"required by a bound introduced by this call","line_end":1879,"line_start":1879,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":42,"highlight_start":23,"text":"        assert_eq!(1, generic_levenshtein(a, b));"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error[E0277]: the size for values of type `[tests_llm_16_21::RowId]` cannot be known at compilation time\n    --> src/lib.rs:1879:46\n     |\n1879 |         assert_eq!(1, generic_levenshtein(a, b));\n     |                       -------------------    ^ doesn't have a size known at compile-time\n     |                       |\n     |                       required by a bound introduced by this call\n     |\n     = help: the trait `Sized` is not implemented for `[tests_llm_16_21::RowId]`\nnote: required by an implicit `Sized` bound in `generic_levenshtein`\n    --> src/lib.rs:233:43\n     |\n233  | pub fn generic_levenshtein<'a, 'b, Iter1, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> usize\n     |                                           ^^^^^ required by the implicit `Sized` requirement on this type parameter in `generic_levenshtein`\nhelp: consider relaxing the implicit `Sized` restriction\n     |\n233  | pub fn generic_levenshtein<'a, 'b, Iter1, Iter2: ?Sized, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> usize\n     |                                                ++++++++\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"the trait `Sized` is not implemented for `[tests_llm_16_21::RowId]`","rendered":null,"spans":[]},{"children":[],"code":null,"level":"note","message":"required by an implicit `Sized` bound in `generic_levenshtein`","rendered":null,"spans":[{"byte_end":6618,"byte_start":6613,"column_end":48,"column_start":43,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"required by the implicit `Sized` requirement on this type parameter in `generic_levenshtein`","line_end":233,"line_start":233,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":48,"highlight_start":43,"text":"pub fn generic_levenshtein<'a, 'b, Iter1, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> usize"}]}]},{"children":[],"code":null,"level":"help","message":"consider relaxing the implicit `Sized` restriction","rendered":null,"spans":[{"byte_end":6618,"byte_start":6618,"column_end":48,"column_start":48,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":null,"line_end":233,"line_start":233,"suggested_replacement":": ?Sized","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":48,"highlight_start":48,"text":"pub fn generic_levenshtein<'a, 'b, Iter1, Iter2, Elem1, Elem2>(a: &'a Iter1, b: &'b Iter2) -> usize"}]}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","message":"the size for values of type `[tests_llm_16_21::RowId]` cannot be known at compilation time","spans":[{"byte_end":53553,"byte_start":53552,"column_end":47,"column_start":46,"expansion":null,"file_name":"src/lib.rs","is_primary":true,"label":"doesn't have a size known at compile-time","line_end":1879,"line_start":1879,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":47,"highlight_start":46,"text":"        assert_eq!(1, generic_levenshtein(a, b));"}]},{"byte_end":53548,"byte_start":53529,"column_end":42,"column_start":23,"expansion":null,"file_name":"src/lib.rs","is_primary":false,"label":"required by a bound introduced by this call","line_end":1879,"line_start":1879,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":42,"highlight_start":23,"text":"        assert_eq!(1, generic_levenshtein(a, b));"}]}]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"error: aborting due to 3 previous errors; 17 warnings emitted\n\n","$message_type":"diagnostic","children":[],"code":null,"level":"error","message":"aborting due to 3 previous errors; 17 warnings emitted","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"Some errors have detailed explanations: E0277, E0282.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"Some errors have detailed explanations: E0277, E0282.","spans":[]}}
{"reason":"compiler-message","package_id":"path+file:///home/abezbm/rust-utgen-test-crates-rug/strsim-rs#strsim@0.11.1","manifest_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/Cargo.toml","target":{"kind":["lib"],"crate_types":["lib"],"name":"strsim","src_path":"/home/abezbm/rust-utgen-test-crates-rug/strsim-rs/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true},"message":{"rendered":"For more information about an error, try `rustc --explain E0277`.\n","$message_type":"diagnostic","children":[],"code":null,"level":"failure-note","message":"For more information about an error, try `rustc --explain E0277`.","spans":[]}}
{"reason":"build-finished","success":false}

inject succeed strsim-rs strsim hamming
inject succeed strsim-rs strsim jaro
inject succeed strsim-rs strsim jaro_winkler
inject succeed strsim-rs strsim levenshtein
inject succeed strsim-rs strsim normalized_damerau_levenshtein
inject succeed strsim-rs strsim normalized_levenshtein
inject succeed strsim-rs strsim osa_distance
inject succeed strsim-rs strsim sorensen_dice
strsim-rs 22 28
