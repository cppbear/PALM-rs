{"<&mut S as write::encoder_string_writer::StrConsumer>::consume": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::write::encoder_string_writer::StrConsumer;\n\n    struct MockStrConsumer {\n        consumed: String,\n    }\n\n    impl StrConsumer for MockStrConsumer {\n        fn consume(&mut self, buf: &str) {\n            self.consumed.push_str(buf);\n        }\n    }\n\n    #[test]\n    fn test_consume() {\n        let mut mock = MockStrConsumer {\n            consumed: String::new(),\n        };\n\n        let input = \"Hello, World!\";\n        mock.consume(input);\n        assert_eq!(mock.consumed, \"Hello, World!\");\n    }\n}\n```", "<alphabet::Alphabet as std::convert::TryFrom<&str>>::try_from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::convert::TryFrom;\n\n    #[test]\n    fn test_try_from_valid_input() {\n        let input = \"valid_input\";\n        let result = Alphabet::try_from(input);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_try_from_invalid_input() {\n        let input = \"invalid_input\";\n        let result = Alphabet::try_from(input);\n        assert!(result.is_err());\n    }\n}\n```", "<chunked_encoder::StringSink<'a> as chunked_encoder::Sink>::write_encoded_bytes": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::chunked_encoder::{StringSink, Sink};\n\n    #[test]\n    fn test_write_encoded_bytes() {\n        let mut s = String::new();\n        let mut sink = StringSink::new(&mut s);\n        let input = b\"Hello, World!\";\n        \n        let result = sink.write_encoded_bytes(input);\n        \n        assert!(result.is_ok());\n        assert_eq!(s, \"Hello, World!\");\n    }\n\n    #[test]\n    fn test_write_encoded_bytes_invalid_utf8() {\n        let mut s = String::new();\n        let mut sink = StringSink::new(&mut s);\n        let input = &[0, 159, 146, 150]; // Invalid UTF-8 sequence\n        \n        let result = sink.write_encoded_bytes(input);\n        \n        assert!(result.is_err());\n    }\n}\n```", "<decode::DecodeSliceError as std::convert::From<decode::DecodeError>>::from": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::decode::{DecodeError, DecodeSliceError};\n\n    #[test]\n    fn test_from_invalid_byte() {\n        let error = DecodeError::InvalidByte(5, b'A');\n        let slice_error: DecodeSliceError = DecodeSliceError::from(error);\n        match slice_error {\n            DecodeSliceError::DecodeError(ref err) => match err {\n                DecodeError::InvalidByte(index, byte) => {\n                    assert_eq!(*index, 5);\n                    assert_eq!(*byte, b'A');\n                }\n                _ => panic!(\"Expected DecodeError::InvalidByte\"),\n            },\n            _ => panic!(\"Expected DecodeSliceError::DecodeError\"),\n        }\n    }\n\n    #[test]\n    fn test_from_invalid_length() {\n        let error = DecodeError::InvalidLength(3);\n        let slice_error: DecodeSliceError = DecodeSliceError::from(error);\n        match slice_error {\n            DecodeSliceError::DecodeError(ref err) => match err {\n                DecodeError::InvalidLength(len) => assert_eq!(*len, 3),\n                _ => panic!(\"Expected DecodeError::InvalidLength\"),\n            },\n            _ => panic!(\"Expected DecodeSliceError::DecodeError\"),\n        }\n    }\n\n    #[test]\n    fn test_from_invalid_last_symbol() {\n        let error = DecodeError::InvalidLastSymbol(7, b'Z');\n        let slice_error: DecodeSliceError = DecodeSliceError::from(error);\n        match slice_error {\n            DecodeSliceError::DecodeError(ref err) => match err {\n                DecodeError::InvalidLastSymbol(index, byte) => {\n                    assert_eq!(*index, 7);\n                    assert_eq!(*byte, b'Z');\n                }\n                _ => panic!(\"Expected DecodeError::InvalidLastSymbol\"),\n            },\n            _ => panic!(\"Expected DecodeSliceError::DecodeError\"),\n        }\n    }\n\n    #[test]\n    fn test_from_invalid_padding() {\n        let error = DecodeError::InvalidPadding;\n        let slice_error: DecodeSliceError = DecodeSliceError::from(error);\n        match slice_error {\n            DecodeSliceError::DecodeError(ref err) => match err {\n                DecodeError::InvalidPadding => {},\n                _ => panic!(\"Expected DecodeError::InvalidPadding\"),\n            },\n            _ => panic!(\"Expected DecodeSliceError::DecodeError\"),\n        }\n    }\n}\n```", "<decode::DecodeSliceError as std::error::Error>::source": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::error::Error;\n\n    #[test]\n    fn test_source_decode_error() {\n        let decode_error = DecodeError::InvalidByte(1, b'A');\n        let decode_slice_error = DecodeSliceError::from(decode_error);\n\n        if let Some(source) = decode_slice_error.source() {\n            assert_eq!(source.to_string(), \"Invalid symbol 65, offset 1.\");\n            assert!(source.is::<DecodeError>());\n        } else {\n            panic!(\"Expected a source for DecodeSliceError::DecodeError.\");\n        }\n    }\n\n    #[test]\n    fn test_source_output_slice_too_small() {\n        let decode_slice_error = DecodeSliceError::OutputSliceTooSmall;\n\n        assert!(decode_slice_error.source().is_none());\n    }\n}\n```", "<display::FormatterSink<'a, 'b> as chunked_encoder::Sink>::write_encoded_bytes": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fmt::{self, Formatter};\n\n    struct MockFormatter {\n        output: String,\n    }\n\n    impl MockFormatter {\n        fn new() -> Self {\n            MockFormatter { output: String::new() }\n        }\n    }\n\n    impl Formatter<'_> for MockFormatter {\n        fn write_str(&mut self, s: &str) -> fmt::Result {\n            self.output.push_str(s);\n            Ok(())\n        }\n    }\n\n    #[test]\n    fn test_write_encoded_bytes_valid_utf8() {\n        let mut mock_formatter = MockFormatter::new();\n        let mut sink = FormatterSink { f: &mut mock_formatter };\n\n        let encoded_bytes = b\"Valid base64 data\";\n        let result = sink.write_encoded_bytes(encoded_bytes);\n\n        assert!(result.is_ok());\n        assert_eq!(mock_formatter.output, \"Valid base64 data\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"base64 data was not utf8\")]\n    fn test_write_encoded_bytes_invalid_utf8() {\n        let mut mock_formatter = MockFormatter::new();\n        let mut sink = FormatterSink { f: &mut mock_formatter };\n\n        let encoded_bytes = &[0, 159, 146, 150]; // Invalid UTF-8 sequence\n        let _result = sink.write_encoded_bytes(encoded_bytes);\n    }\n}\n```", "<engine::general_purpose::GeneralPurpose as engine::Engine>::config": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    use crate::engine::DecodePaddingMode;\n\n    #[test]\n    fn test_config() {\n        let config = GeneralPurposeConfig::new();\n        let engine = GeneralPurpose::new(&Alphabet::STANDARD, config.clone());\n\n        assert_eq!(engine.config().encode_padding(), config.encode_padding());\n        assert_eq!(engine.config().decode_allow_trailing_bits, config.decode_allow_trailing_bits);\n        assert_eq!(engine.config().decode_padding_mode, config.decode_padding_mode);\n    }\n\n    #[test]\n    fn test_config_with_custom_padding() {\n        let config = GeneralPurposeConfig::new().with_encode_padding(false);\n        let engine = GeneralPurpose::new(&Alphabet::STANDARD, config.clone());\n\n        assert_eq!(engine.config().encode_padding(), false);\n        assert_eq!(engine.config().decode_allow_trailing_bits, config.decode_allow_trailing_bits);\n        assert_eq!(engine.config().decode_padding_mode, config.decode_padding_mode);\n    }\n\n    #[test]\n    fn test_config_with_custom_padding_mode() {\n        let config = GeneralPurposeConfig::new().with_decode_padding_mode(DecodePaddingMode::Indifferent);\n        let engine = GeneralPurpose::new(&Alphabet::STANDARD, config.clone());\n\n        assert_eq!(engine.config().encode_padding(), config.encode_padding());\n        assert_eq!(engine.config().decode_allow_trailing_bits, config.decode_allow_trailing_bits);\n        assert_eq!(engine.config().decode_padding_mode, DecodePaddingMode::Indifferent);\n    }\n}\n```", "<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_decode": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    use crate::engine::DecodePaddingMode;\n    use crate::engine::DecodeSliceError;\n    use crate::engine::DecodeMetadata;\n\n    #[test]\n    fn test_internal_decode_valid_input() {\n        let config = GeneralPurposeConfig::new();\n        let engine = GeneralPurpose::new(&crate::Alphabet::STANDARD, config);\n        let input = b\"SGVsbG8gV29ybGQ=\";\n        let mut output = vec![0; 11]; // \"Hello World\" is 11 bytes\n        let estimate = engine.internal_decoded_len_estimate(input.len());\n\n        let result: Result<DecodeMetadata, DecodeSliceError> = engine.internal_decode(input, &mut output, estimate);\n        \n        assert!(result.is_ok());\n        assert_eq!(&output[..11], b\"Hello World\");\n    }\n\n    #[test]\n    fn test_internal_decode_invalid_input() {\n        let config = GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::RequireCanonical);\n        let engine = GeneralPurpose::new(&crate::Alphabet::STANDARD, config);\n        let input = b\"SGVsbG8gV29ybGQ\"; // Missing padding\n        let mut output = vec![0; 11];\n        let estimate = engine.internal_decoded_len_estimate(input.len());\n\n        let result: Result<DecodeMetadata, DecodeSliceError> = engine.internal_decode(input, &mut output, estimate);\n        \n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_internal_decode_no_padding() {\n        let config = GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::RequireNone);\n        let engine = GeneralPurpose::new(&crate::Alphabet::STANDARD, config);\n        let input = b\"SGVsbG8gV29ybGQ\"; // No padding is okay\n        let mut output = vec![0; 11];\n        let estimate = engine.internal_decoded_len_estimate(input.len());\n\n        let result: Result<DecodeMetadata, DecodeSliceError> = engine.internal_decode(input, &mut output, estimate);\n        \n        assert!(result.is_ok());\n        assert_eq!(&output[..11], b\"Hello World\");\n    }\n}\n```", "<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_decoded_len_estimate": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n\n    #[test]\n    fn test_internal_decoded_len_estimate() {\n        let config = GeneralPurposeConfig::default();\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, config);\n        \n        let input_len = 10;\n        let estimate = engine.internal_decoded_len_estimate(input_len);\n        \n        // Assuming the GeneralPurposeEstimate is public and has an appropriate way to get the value\n        // Replace the following line with an appropriate way to retrieve the length from estimate\n        let estimated_len = estimate.length(); // Example, adjust based on actual implementation\n        assert_eq!(estimated_len, 10);  // Adjust the value based on the expected behavior\n    }\n}\n```", "<engine::general_purpose::GeneralPurpose as engine::Engine>::internal_encode": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    use engine::DecodePaddingMode;\n\n    #[test]\n    fn test_internal_encode() {\n        let alphabet = base64::Alphabet::STANDARD;\n        let config = GeneralPurposeConfig::new();\n        let encoder = GeneralPurpose::new(&alphabet, config);\n        \n        let input = b\"Hello, World!\";\n        let mut output = vec![0u8; 24]; // Sufficient size for output\n        let encoded_length = encoder.internal_encode(input, &mut output);\n        \n        assert_eq!(encoded_length, 20);\n        assert_eq!(&output[..encoded_length], b\"SGVsbG8sIFdvcmxkIQ==\");\n    }\n\n    #[test]\n    fn test_internal_encode_with_padding() {\n        let alphabet = base64::Alphabet::STANDARD;\n        let config = GeneralPurposeConfig::new()\n            .with_encode_padding(true);\n        let encoder = GeneralPurpose::new(&alphabet, config);\n        \n        let input = b\"Hello\";\n        let mut output = vec![0u8; 8]; // Sufficient size for output\n        let encoded_length = encoder.internal_encode(input, &mut output);\n        \n        assert_eq!(encoded_length, 8);\n        assert_eq!(&output[..encoded_length], b\"SGVs\");\n    }\n\n    #[test]\n    fn test_internal_encode_without_padding() {\n        let alphabet = base64::Alphabet::STANDARD;\n        let config = GeneralPurposeConfig::new()\n            .with_encode_padding(false);\n        let encoder = GeneralPurpose::new(&alphabet, config);\n        \n        let input = b\"Hello\";\n        let mut output = vec![0u8; 8]; // Sufficient size for output\n        let encoded_length = encoder.internal_encode(input, &mut output);\n        \n        assert_eq!(encoded_length, 7);\n        assert_eq!(&output[..encoded_length], b\"SGVsbw\");\n    }\n\n    #[test]\n    fn test_internal_encode_empty_input() {\n        let alphabet = base64::Alphabet::STANDARD;\n        let config = GeneralPurposeConfig::new();\n        let encoder = GeneralPurpose::new(&alphabet, config);\n        \n        let input: &[u8] = b\"\";\n        let mut output = vec![0u8; 4]; // Sufficient size for output\n        let encoded_length = encoder.internal_encode(input, &mut output);\n        \n        assert_eq!(encoded_length, 0);\n    }\n}\n```", "<engine::general_purpose::GeneralPurposeConfig as engine::Config>::encode_padding": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::GeneralPurposeConfig;\n\n    #[test]\n    fn test_encode_padding_default_true() {\n        let config = GeneralPurposeConfig::new();\n        assert!(config.encode_padding());\n    }\n\n    #[test]\n    fn test_encode_padding_with_padding_true() {\n        let config = GeneralPurposeConfig::new().with_encode_padding(true);\n        assert!(config.encode_padding());\n    }\n\n    #[test]\n    fn test_encode_padding_with_padding_false() {\n        let config = GeneralPurposeConfig::new().with_encode_padding(false);\n        assert!(!config.encode_padding());\n    }\n}\n```", "<engine::general_purpose::GeneralPurposeConfig as std::default::Default>::default": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose::GeneralPurposeConfig;\n\n    #[test]\n    fn test_default() {\n        let config = GeneralPurposeConfig::default();\n        assert_eq!(config.encode_padding(), true);\n        assert_eq!(config.decode_allow_trailing_bits, false);\n        assert_eq!(config.decode_padding_mode, DecodePaddingMode::RequireCanonical);\n    }\n}\n```", "<engine::general_purpose::decode::GeneralPurposeEstimate as engine::DecodeEstimate>::decoded_len_estimate": "```rust\n#[cfg(test)]\nmod tests {\n    use super::engine::general_purpose::decode::GeneralPurposeEstimate;\n    use super::engine::DecodeEstimate;\n\n    #[test]\n    fn test_decoded_len_estimate() {\n        let estimate = GeneralPurposeEstimate::new(4);\n        assert_eq!(estimate.decoded_len_estimate(), 3);\n\n        let estimate = GeneralPurposeEstimate::new(8);\n        assert_eq!(estimate.decoded_len_estimate(), 6);\n\n        let estimate = GeneralPurposeEstimate::new(10);\n        assert_eq!(estimate.decoded_len_estimate(), 9);\n\n        let estimate = GeneralPurposeEstimate::new(11);\n        assert_eq!(estimate.decoded_len_estimate(), 9);\n        \n        let estimate = GeneralPurposeEstimate::new(0);\n        assert_eq!(estimate.decoded_len_estimate(), 0);\n    }\n}\n```", "<read::decoder::DecoderReader<'e, E, R> as std::io::Read>::read": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_decoder_reader_read_success() {\n        let input_data = b\"YXNkZg==\"; // Base64 for \"asdf\"\n        let mut cursor = Cursor::new(input_data);\n        let engine = &general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(&mut cursor, engine);\n        \n        let mut output_buf = vec![0; 4]; // Buffer for the decoded output\n        let bytes_read = decoder.read(&mut output_buf).unwrap();\n        \n        assert_eq!(bytes_read, 4);\n        assert_eq!(&output_buf[..bytes_read], b\"asdf\");\n    }\n\n    #[test]\n    fn test_decoder_reader_read_empty() {\n        let input_data = b\"\"; // Empty input\n        let mut cursor = Cursor::new(input_data);\n        let engine = &general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(&mut cursor, engine);\n        \n        let mut output_buf = vec![0; 4]; // Buffer for the decoded output\n        let bytes_read = decoder.read(&mut output_buf).unwrap();\n        \n        assert_eq!(bytes_read, 0); // No bytes should be read\n    }\n\n    #[test]\n    fn test_decoder_reader_read_invalid_data() {\n        let input_data = b\"INVALID_BASE64\"; // Invalid base64\n        let mut cursor = Cursor::new(input_data);\n        let engine = &general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(&mut cursor, engine);\n        \n        let mut output_buf = vec![0; 4]; // Buffer for the decoded output\n        let result = decoder.read(&mut output_buf);\n        \n        assert!(result.is_err()); // Should return an error\n    }\n\n    #[test]\n    fn test_decoder_reader_read_partial_data() {\n        let input_data = b\"YXNk\"; // Base64 for \"as\"\n        let mut cursor = Cursor::new(input_data);\n        let engine = &general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(&mut cursor, engine);\n        \n        let mut output_buf = vec![0; 3]; // Buffer for the decoded output\n        let bytes_read = decoder.read(&mut output_buf).unwrap();\n        \n        assert_eq!(bytes_read, 2); // Should decode \"as\"\n        assert_eq!(&output_buf[..bytes_read], b\"as\");\n    }\n}\n```", "<std::string::String as write::encoder_string_writer::StrConsumer>::consume": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // Make sure to import necessary items from the parent module\n    use std::string::String; // Import the String from the standard library\n\n    #[test]\n    fn test_consume() {\n        let mut s = String::new();\n        let input = \"Hello, \";\n        \n        s.consume(input);\n        \n        assert_eq!(s, \"Hello, \");\n        \n        let additional_input = \"world!\";\n        s.consume(additional_input);\n        \n        assert_eq!(s, \"Hello, world!\");\n    }\n}\n```", "<write::encoder::EncoderWriter<'e, E, W> as std::io::Write>::flush": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{engine::general_purpose, write::EncoderWriter};\n    use std::io::Cursor;\n\n    #[test]\n    fn test_flush_function() {\n        let data = b\"hello world\";\n        let mut buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(Cursor::new(&mut buffer), &general_purpose::STANDARD);\n\n        // Write some data to the encoder\n        encoder.write_all(data).expect(\"Failed to write data\");\n\n        // Flush the encoder\n        encoder.flush().expect(\"Failed to flush the encoder\");\n\n        // Retrieve the encoded result\n        let encoded = encoder.finish().expect(\"Failed to finish encoder\");\n\n        // Validate the encoded output\n        assert_eq!(encoded, b\"aGVsbG8gd29ybGQ=\");\n    }\n\n    #[test]\n    fn test_flush_with_error_handling() {\n        let data = b\"test\";\n        let mut mock_writer = MockWriter::new();\n        let mut encoder = EncoderWriter::new(mock_writer, &general_purpose::STANDARD);\n\n        // Write data to encoder\n        encoder.write_all(data).expect(\"Failed to write to encoder\");\n\n        // Flush the encoder\n        let result = encoder.flush();\n\n        // Check if flush returned an error\n        assert!(result.is_err());\n    }\n\n    struct MockWriter {\n        flush_called: bool,\n    }\n\n    impl MockWriter {\n        fn new() -> Self {\n            MockWriter { flush_called: false }\n        }\n    }\n\n    impl std::io::Write for MockWriter {\n        fn write(&mut self, _buf: &[u8]) -> std::io::Result<usize> {\n            Ok(4) // simulate successful write\n        }\n\n        fn flush(&mut self) -> std::io::Result<()> {\n            self.flush_called = true;\n            Err(std::io::Error::new(std::io::ErrorKind::Other, \"Flush error\")) // simulate an error\n        }\n    }\n}\n```", "<write::encoder::EncoderWriter<'e, E, W> as std::io::Write>::write": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn test_write_empty_input() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        let result = writer.write(&[]);\n        assert_eq!(result, Ok(0));\n    }\n\n    #[test]\n    fn test_write_single_byte() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        let result = writer.write(&[0x61]); // 'a'\n        assert_eq!(result, Ok(1));\n        writer.finish().unwrap();\n        assert_eq!(&vec[..], b\"YQ==\"); // Base64 encoding of 'a'\n    }\n\n    #[test]\n    fn test_write_multiple_bytes() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        let result = writer.write(b\"abc\");\n        assert_eq!(result, Ok(3));\n        writer.finish().unwrap();\n        assert_eq!(&vec[..], b\"YWJj\"); // Base64 encoding of 'abc'\n    }\n\n    #[test]\n    fn test_write_partial_chunk() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        let result1 = writer.write(b\"ab\"); // 2 bytes\n        assert_eq!(result1, Ok(2));\n        let result2 = writer.write(b\"c\"); // 1 byte\n        assert_eq!(result2, Ok(1));\n        writer.finish().unwrap();\n        assert_eq!(&vec[..], b\"YWJj\"); // Base64 encoding of 'abc'\n    }\n\n    #[test]\n    fn test_write_large_input() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        let data = b\"Hello, world!\"; // 13 bytes\n        let result = writer.write(data);\n        assert_eq!(result, Ok(13));\n        writer.finish().unwrap();\n        assert_eq!(&vec[..], b\"SGVsbG8sIHdvcmxkIQ==\"); // Base64 encoding of 'Hello, world!'\n    }\n\n    #[test]\n    fn test_write_after_finish() {\n        let mut vec = Vec::new();\n        let engine = general_purpose::STANDARD;\n        let mut writer = EncoderWriter::new(&mut vec, &engine);\n        writer.finish().unwrap();\n        let result = writer.write(b\"test\");\n        assert!(result.is_err());\n    }\n}\n```", "<write::encoder::EncoderWriter<'e, E, W> as std::ops::Drop>::drop": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn test_encoder_writer_drop_when_panicked() {\n        let output: Vec<u8> = Vec::new();\n        let engine = &general_purpose::STANDARD;\n        let mut encoder_writer = EncoderWriter::new(Cursor::new(output), engine);\n\n        encoder_writer.panicked = true; // Simulating panic\n        encoder_writer.drop(); // Call drop directly\n        // No assert; we just want to ensure it does not panic\n    }\n\n    #[test]\n    fn test_encoder_writer_drop_without_panicked() {\n        let output: Vec<u8> = Vec::new();\n        let engine = &general_purpose::STANDARD;\n        let mut encoder_writer = EncoderWriter::new(Cursor::new(output), engine);\n\n        encoder_writer.panicked = false; // Simulating normal operation\n\n        encoder_writer.drop(); // Call drop directly\n        // We can assert that encoder_writer now has a None delegate\n        assert!(encoder_writer.delegate.is_none());\n    }\n\n    #[test]\n    fn test_encoder_writer_drop_with_remaining_input() {\n        let output: Vec<u8> = Vec::new();\n        let engine = &general_purpose::STANDARD;\n        let mut encoder_writer = EncoderWriter::new(Cursor::new(output), engine);\n\n        encoder_writer.extra_input_occupied_len = 1; // Simulating leftover input\n        encoder_writer.panicked = false; // Simulating normal operation\n\n        encoder_writer.drop(); // Call drop directly\n        // We can check if drop handled the leftover input correctly\n        // Here we need to ensure that write_final_leftovers() was called, but this requires\n        // a bit of refactoring of the drop and write_final_leftovers to return some checkable result.\n    }\n}\n```", "<write::encoder_string_writer::EncoderStringWriter<'e, E, S> as std::io::Write>::flush": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_flush() {\n        let engine = &general_purpose::STANDARD;\n        let mut buf = String::new();\n        let mut encoder = base64::write::EncoderStringWriter::from_consumer(&mut buf, engine);\n        \n        encoder.write_all(b\"test\").unwrap();\n        encoder.flush().unwrap(); // Call flush to ensure encoding is complete\n\n        assert_eq!(buf, \"dGVzdA==\"); // Validate the base64-encoded output\n    }\n\n    #[test]\n    fn test_flush_empty() {\n        let engine = &general_purpose::STANDARD;\n        let mut buf = String::new();\n        let mut encoder = base64::write::EncoderStringWriter::from_consumer(&mut buf, engine);\n        \n        encoder.flush().unwrap(); // Should work even if nothing was written\n\n        assert!(buf.is_empty()); // Validate that buffer is still empty\n    }\n\n    #[test]\n    fn test_flush_with_data() {\n        let engine = &general_purpose::STANDARD;\n        let mut buf = String::new();\n        let mut encoder = base64::write::EncoderStringWriter::from_consumer(&mut buf, engine);\n        \n        encoder.write_all(b\"data\").unwrap();\n        encoder.flush().unwrap(); // Should flush the written data\n\n        assert_eq!(buf, \"ZGF0YQ==\"); // Check that the encoded data is correct\n    }\n}\n```", "<write::encoder_string_writer::EncoderStringWriter<'e, E, S> as std::io::Write>::write": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_write() {\n        let mut encoder = base64::write::EncoderStringWriter::new(&general_purpose::STANDARD);\n        let input = b\"hello\";\n        \n        let result = encoder.write(input);\n        \n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), input.len());\n        \n        let b64_string = encoder.into_inner();\n        assert_eq!(b64_string, \"aGVsbG8=\");\n    }\n\n    #[test]\n    fn test_write_empty() {\n        let mut encoder = base64::write::EncoderStringWriter::new(&general_purpose::STANDARD);\n        let input: &[u8] = &[];\n\n        let result = encoder.write(input);\n        \n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), input.len());\n        \n        let b64_string = encoder.into_inner();\n        assert_eq!(b64_string, \"\");\n    }\n\n    #[test]\n    fn test_write_partial() {\n        let mut encoder = base64::write::EncoderStringWriter::new(&general_purpose::STANDARD);\n        let input = b\"hello, world\";\n        \n        let _ = encoder.write(&input[0..5]);  // Write \"hello\"\n        let b64_string = encoder.into_inner();\n        assert_eq!(b64_string, \"aGVsbG8=\");\n        \n        let _ = encoder.write(&input[5..]); // Write \", world\"\n        let b64_string = encoder.into_inner();\n        assert_eq!(b64_string, \"aGVsbG8sIHdvcmxk\");\n    }\n\n    #[test]\n    fn test_write_multiple() {\n        let mut encoder = base64::write::EncoderStringWriter::new(&general_purpose::STANDARD);\n        \n        let inputs = vec![b\"first\", b\" second\", b\" third\"];\n        for input in inputs {\n            encoder.write_all(input).expect(\"Writing failed\");\n        }\n\n        let b64_string = encoder.into_inner();\n        assert_eq!(b64_string, \"Zmlyc3Qgc2Vjb25kIHRoa\");\n    }\n}\n```", "<write::encoder_string_writer::Utf8SingleCodeUnitWriter<S> as std::io::Write>::flush": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n\n    #[test]\n    fn test_flush() {\n        let mut string = String::new();\n        let mut writer = Utf8SingleCodeUnitWriter { str_consumer: string };\n\n        // Call flush and check the result\n        let result = writer.flush();\n\n        // Ensure flush returns Ok(())\n        assert!(result.is_ok());\n    }\n}\n```", "<write::encoder_string_writer::Utf8SingleCodeUnitWriter<S> as std::io::Write>::write": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n\n    #[test]\n    fn test_utf8_single_code_unit_writer() {\n        let mut string_consumer = String::new();\n        let mut writer = Utf8SingleCodeUnitWriter { str_consumer: string_consumer };\n\n        let input = b\"Hello, World!\";\n        let result = writer.write(input).expect(\"Failed to write\");\n\n        assert_eq!(result, input.len());\n        assert_eq!(writer.str_consumer, \"Hello, World!\");\n    }\n\n    #[test]\n    fn test_invalid_utf8() {\n        let mut string_consumer = String::new();\n        let mut writer = Utf8SingleCodeUnitWriter { str_consumer: string_consumer };\n\n        let invalid_input = [0, 159, 146, 150]; // invalid UTF-8 bytes\n        let write_result = writer.write(&invalid_input);\n        \n        assert!(write_result.is_err());\n    }\n}\n```", "alphabet::Alphabet::as_str": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::alphabet::Alphabet;\n\n    #[test]\n    fn test_as_str() {\n        let alphabet_str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        let alphabet = Alphabet::new(alphabet_str).unwrap();\n        \n        assert_eq!(alphabet.as_str(), alphabet_str);\n    }\n\n    #[test]\n    fn test_as_str_invalid_alphabet() {\n        let alphabet_str = \"INVALID_ALPHABET_LENGTH\"; // length is not 64\n        let result = Alphabet::new(alphabet_str);\n        \n        assert!(result.is_err());\n        \n        let alphabet_str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; // contains '='\n        let result = Alphabet::new(alphabet_str);\n        \n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_as_str_with_custom_alphabet() {\n        let custom_alphabet_str = \"ABCDEFGHIJKLMNOPQRSTUVWXYSZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        let alphabet = Alphabet::new(custom_alphabet_str).unwrap();\n        \n        assert_eq!(alphabet.as_str(), custom_alphabet_str);\n    }\n}\n```", "alphabet::Alphabet::from_str_unchecked": "```rust\n#[cfg(test)]\nmod tests {\n    use super::Alphabet;\n\n    #[test]\n    fn test_from_str_unchecked_valid() {\n        const ALPHABET_STR: &str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        let alphabet = Alphabet::from_str_unchecked(ALPHABET_STR);\n        assert_eq!(alphabet.as_str(), ALPHABET_STR);\n    }\n\n    #[test]\n    fn test_from_str_unchecked_empty() {\n        const ALPHABET_STR: &str = \"                                                                  \";\n        let alphabet = Alphabet::from_str_unchecked(ALPHABET_STR);\n        assert_eq!(alphabet.as_str(), ALPHABET_STR);\n    }\n\n    #[test]\n    fn test_from_str_unchecked_repeated_chars() {\n        const ALPHABET_STR: &str = \"ABCDEFGHIJKLMNOABCDEFGHIJKLMNOABCDEFGHJKLMNOABCDEFGHIJKLMNO\"; // Invalid for base64\n        let alphabet = Alphabet::from_str_unchecked(ALPHABET_STR);\n        assert_eq!(alphabet.as_str(), ALPHABET_STR);\n    }\n}\n```", "alphabet::Alphabet::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::alphabet::{Alphabet, ParseAlphabetError};\n\n    #[test]\n    fn test_new_valid_alphabet() {\n        let alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        let result = Alphabet::new(alphabet);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_new_invalid_length() {\n        let alphabet = \"Short\";\n        let result = Alphabet::new(alphabet);\n        assert_eq!(result, Err(ParseAlphabetError::InvalidLength));\n    }\n\n    #[test]\n    fn test_new_unprintable_byte() {\n        let alphabet = \"ABCDEFGHIJKLMNO\\x00QRSTUVWXYYZabcdefgh\";\n        let result = Alphabet::new(alphabet);\n        assert_eq!(result, Err(ParseAlphabetError::UnprintableByte(0)));\n    }\n\n    #[test]\n    fn test_new_reserved_byte() {\n        let alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789=\";\n        let result = Alphabet::new(alphabet);\n        assert_eq!(result, Err(ParseAlphabetError::ReservedByte(b'=')));\n    }\n\n    #[test]\n    fn test_new_duplicated_byte() {\n        let alphabet = \"ABCDEFGHIJKLMABCDE0123456789+/\";\n        let result = Alphabet::new(alphabet);\n        assert_eq!(result, Err(ParseAlphabetError::DuplicatedByte(b'A')));\n    }\n}\n```", "chunked_encoder::ChunkedEncoder::<'e, E>::encode": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::chunked_encoder::{ChunkedEncoder, StringSink};\n    use crate::engine::{general_purpose::GeneralPurpose, GeneralPurposeConfig};\n\n    #[test]\n    fn test_encode() {\n        let engine = GeneralPurpose::new(&crate::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let encoder = ChunkedEncoder::new(&engine);\n        \n        let input_data = b\"Hello, world!\";\n        let mut output_string = String::new();\n        let mut sink = StringSink::new(&mut output_string);\n\n        let result = encoder.encode(input_data, &mut sink);\n        \n        assert!(result.is_ok());\n        assert_eq!(output_string, \"SGVsbG8sIHdvcmxkIQ==\");\n    }\n\n    #[test]\n    fn test_encode_empty() {\n        let engine = GeneralPurpose::new(&crate::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let encoder = ChunkedEncoder::new(&engine);\n\n        let input_data: &[u8] = &[];\n        let mut output_string = String::new();\n        let mut sink = StringSink::new(&mut output_string);\n\n        let result = encoder.encode(input_data, &mut sink);\n\n        assert!(result.is_ok());\n        assert_eq!(output_string, \"\");\n    }\n\n    #[test]\n    fn test_encode_with_padding() {\n        let engine = GeneralPurpose::new(&crate::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let encoder = ChunkedEncoder::new(&engine);\n\n        let input_data = b\"abc\"; // 3 bytes => 4 base64 characters\n        let mut output_string = String::new();\n        let mut sink = StringSink::new(&mut output_string);\n\n        let result = encoder.encode(input_data, &mut sink);\n\n        assert!(result.is_ok());\n        assert_eq!(output_string, \"YWJj\");\n    }\n\n    #[test]\n    fn test_encode_without_padding() {\n        let config = GeneralPurposeConfig::new().with_encode_padding(false);\n        let engine = GeneralPurpose::new(&crate::alphabet::STANDARD, config);\n        let encoder = ChunkedEncoder::new(&engine);\n\n        let input_data = b\"abc\"; // 3 bytes => 4 base64 characters\n        let mut output_string = String::new();\n        let mut sink = StringSink::new(&mut output_string);\n\n        let result = encoder.encode(input_data, &mut sink);\n\n        assert!(result.is_ok());\n        assert_eq!(output_string, \"YWJj\");\n    }\n}\n```", "chunked_encoder::ChunkedEncoder::<'e, E>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose, GeneralPurpose, GeneralPurposeConfig};\n    \n    #[test]\n    fn test_chunked_encoder_new() {\n        let config = GeneralPurposeConfig::default();\n        let engine = GeneralPurpose::new(&general_purpose::STANDARD, config);\n        \n        let chunked_encoder = ChunkedEncoder::new(&engine);\n        \n        assert_eq!(chunked_encoder.engine.config().encode_padding(), true);\n        assert_eq!(chunked_encoder.engine as *const _, &engine as *const _);\n    }\n}\n```", "chunked_encoder::StringSink::<'a>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::chunked_encoder::{StringSink, Sink};\n\n    #[test]\n    fn test_string_sink_new() {\n        let mut test_string = String::new();\n        let mut string_sink = StringSink::new(&mut test_string);\n\n        assert_eq!(test_string, \"\");\n\n        let bytes = b\"Hello, \";\n        string_sink.write_encoded_bytes(bytes).unwrap();\n        assert_eq!(test_string, \"Hello, \");\n\n        let more_bytes = b\"world!\";\n        string_sink.write_encoded_bytes(more_bytes).unwrap();\n        assert_eq!(test_string, \"Hello, world!\");\n    }\n}\n```", "decode::decode": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{decode, DecodeError};\n\n    #[test]\n    fn test_decode_valid_base64() {\n        let input = \"SGVsbG8gV29ybGQ=\";\n        let expected = b\"Hello World\";\n        let result = decode(input).unwrap();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_decode_invalid_base64() {\n        let input = \"!!invalid!!\";\n        let result = decode(input);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_decode_empty() {\n        let input = \"\";\n        let result = decode(input).unwrap();\n        assert_eq!(result, b\"\");\n    }\n\n    #[test]\n    fn test_decode_with_padding() {\n        let input = \"U29tZSBkYXRh\";\n        let expected = b\"Some data\";\n        let result = decode(input).unwrap();\n        assert_eq!(result, expected);\n    }\n}\n```", "decode::decode_engine": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n    use base64::engine::Engine;\n    use base64::DecodeError;\n\n    #[test]\n    fn test_decode_engine_valid() {\n        let engine = general_purpose::STANDARD;\n        let input = \"SGVsbG8gd29ybGQ=\"; // \"Hello world\" in base64\n        let expected_output = b\"Hello world\";\n\n        let result = decode_engine(input, &engine);\n        assert_eq!(result.is_ok(), true);\n        assert_eq!(result.unwrap(), expected_output.to_vec());\n    }\n\n    #[test]\n    fn test_decode_engine_invalid() {\n        let engine = general_purpose::STANDARD;\n        let input = \"SGVsbG8gd29ybGQ\"; // Invalid base64 (missing padding)\n\n        let result = decode_engine(input, &engine);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), DecodeError::InvalidLastSymbol);\n    }\n\n    #[test]\n    fn test_decode_engine_with_trailing_bits() {\n        let engine = general_purpose::STANDARD;\n        let input = \"SGVsbG8gd29ybGQ=\"; // \"Hello world\" in base64\n        let expected_output = b\"Hello world\";\n\n        // Allow trailing bits\n        let config = general_purpose::GeneralPurposeConfig::new()\n            .with_decode_allow_trailing_bits(true);\n        let engine_with_trailing_bits = general_purpose::GeneralPurpose::new(&general_purpose::STANDARD.encode_table, config);\n        let result = decode_engine(input, &engine_with_trailing_bits);\n        \n        assert_eq!(result.is_ok(), true);\n        assert_eq!(result.unwrap(), expected_output.to_vec());\n    }\n}\n```", "decode::decode_engine_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose};\n\n    #[test]\n    fn test_decode_engine_slice() {\n        let engine = general_purpose::STANDARD;\n        let input = \"aGVsbG8gd29ybGR+Cg==\";\n        let mut output = vec![0u8; 16]; // Allocate enough space for the output\n        let result = decode_engine_slice(input, &mut output, &engine);\n\n        assert!(result.is_ok());\n        let bytes_written = result.unwrap();\n        assert_eq!(bytes_written, 13);\n        assert_eq!(&output[..bytes_written], b\"hello world\\n\");\n    }\n\n    #[test]\n    fn test_decode_engine_slice_with_canonical_padding() {\n        let config = engine::GeneralPurposeConfig::new().with_decode_padding_mode(DecodePaddingMode::RequireCanonical);\n        let engine = engine::GeneralPurpose::new(&engine::alphabet::STANDARD, config);\n        let input = \"aGVsbG8gd29ybGR+Cg==\";\n        let mut output = vec![0u8; 16];\n        \n        let result = decode_engine_slice(input, &mut output, &engine);\n\n        assert!(result.is_ok());\n        let bytes_written = result.unwrap();\n        assert_eq!(bytes_written, 13);\n        assert_eq!(&output[..bytes_written], b\"hello world\\n\");\n    }\n\n    #[test]\n    fn test_decode_engine_slice_no_padding() {\n        let config = engine::GeneralPurposeConfig::new().with_decode_padding(false);\n        let engine = engine::GeneralPurpose::new(&engine::alphabet::STANDARD, config);\n        let input = \"aGVsbG8gd29ybGR\";\n        let mut output = vec![0u8; 16];\n        \n        let result = decode_engine_slice(input, &mut output, &engine);\n\n        assert!(result.is_ok());\n        let bytes_written = result.unwrap();\n        assert_eq!(bytes_written, 12);\n        assert_eq!(&output[..bytes_written], b\"hello world\");\n    }\n\n    #[test]\n    fn test_decode_engine_slice_with_trailing_bits() {\n        let config = engine::GeneralPurposeConfig::new().with_decode_allow_trailing_bits(true);\n        let engine = engine::GeneralPurpose::new(&engine::alphabet::STANDARD, config);\n        let input = \"aGVsbG8gd29ybGR+Cg==\";\n        let mut output = vec![0u8; 16];\n        \n        let result = decode_engine_slice(input, &mut output, &engine);\n\n        assert!(result.is_ok());\n        let bytes_written = result.unwrap();\n        assert_eq!(bytes_written, 13);\n        assert_eq!(&output[..bytes_written], b\"hello world\\n\");\n    }\n}\n```", "decode::decode_engine_vec": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_decode_engine_vec() {\n        let input = \"aGVsbG8gd29ybGR+Cg==\";\n        let mut buffer = Vec::new();\n        \n        let engine = general_purpose::STANDARD;\n        \n        let result = decode_engine_vec(input, &mut buffer, &engine);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b\"hello world\\n\");\n    }\n\n    #[test]\n    fn test_decode_engine_vec_invalid() {\n        let input = \"Invalid base64\";\n        let mut buffer = Vec::new();\n        \n        let engine = general_purpose::STANDARD;\n        \n        let result = decode_engine_vec(input, &mut buffer, &engine);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_decode_engine_vec_with_custom_engine() {\n        let input = \"aGVsbG8gaW50ZXJuZXR-Cg\";\n        let mut buffer = Vec::new();\n        \n        let engine = general_purpose::GeneralPurpose::new(&base64::alphabet::URL_SAFE, general_purpose::NO_PAD);\n        \n        let result = decode_engine_vec(input, &mut buffer, &engine);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b\"hello internet\\n\");\n    }\n}\n```", "decode::decoded_len_estimate": "```rust\n#[cfg(test)]\nmod tests {\n    use super::decoded_len_estimate;\n\n    #[test]\n    fn test_decoded_len_estimate() {\n        assert_eq!(3, decoded_len_estimate(1));\n        assert_eq!(3, decoded_len_estimate(2));\n        assert_eq!(3, decoded_len_estimate(3));\n        assert_eq!(3, decoded_len_estimate(4));\n        assert_eq!(6, decoded_len_estimate(5));\n        assert_eq!(6, decoded_len_estimate(6));\n        assert_eq!(9, decoded_len_estimate(9));\n        assert_eq!(12, decoded_len_estimate(12));\n        assert_eq!(15, decoded_len_estimate(15));\n    }\n}\n```", "display::Base64Display::<'a, 'e, E>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose};\n    \n    #[test]\n    fn test_base64_display_new() {\n        let bytes: &[u8] = b\"hello world\";\n        let engine = general_purpose::STANDARD;\n        \n        let base64_display = Base64Display::new(bytes, &engine);\n        \n        assert_eq!(base64_display.bytes, bytes);\n        // Additional checks can be added here if necessary\n    }\n    \n    #[test]\n    fn test_base64_display_display() {\n        let bytes: &[u8] = b\"hello world\";\n        let engine = general_purpose::STANDARD;\n        let base64_display = Base64Display::new(bytes, &engine);\n        \n        let output = format!(\"{}\", base64_display);\n        assert_eq!(output, \"aGVsbG8gd29ybGQ=\"); // Check the expected Base64 output\n    }\n}\n```", "encode::add_padding": "```rust\n#[cfg(test)]\nmod tests {\n    use super::encode::add_padding;\n\n    const PAD_BYTE: u8 = b'=';\n\n    #[test]\n    fn test_add_padding_no_padding_needed() {\n        let mut output = [0u8; 2];\n        let padding = add_padding(4, &mut output);\n        assert_eq!(padding, 0);\n        assert_eq!(&output[..padding], &[]);\n    }\n\n    #[test]\n    fn test_add_padding_one_byte_padding() {\n        let mut output = [0u8; 2];\n        let padding = add_padding(3, &mut output);\n        assert_eq!(padding, 1);\n        assert_eq!(output[..padding], [PAD_BYTE]);\n    }\n\n    #[test]\n    fn test_add_padding_two_byte_padding() {\n        let mut output = [0u8; 2];\n        let padding = add_padding(2, &mut output);\n        assert_eq!(padding, 2);\n        assert_eq!(output[..padding], [PAD_BYTE, PAD_BYTE]);\n    }\n\n    #[test]\n    fn test_add_padding_three_byte_padding() {\n        let mut output = [0u8; 2];\n        let padding = add_padding(1, &mut output);\n        assert_eq!(padding, 3);\n        assert_eq!(output[..padding], [PAD_BYTE, PAD_BYTE]);\n    }\n}\n```", "encode::encode": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::encode;\n\n    #[test]\n    fn test_encode() {\n        assert_eq!(encode(\"Hello, World!\"), \"SGVsbG8sIFdvcmxkIQ==\");\n        assert_eq!(encode(b\"Hello, World!\"), \"SGVsbG8sIFdvcmxkIQ==\");\n        assert_eq!(encode(\"\"), \"\");\n        assert_eq!(encode(b\"\"), \"\");\n        assert_eq!(encode(\"Rust\"), \"UnVzdA==\");\n        assert_eq!(encode(\"base64\"), \"YmFzZTY0\");\n    }\n}\n```", "encode::encode_engine": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose};\n\n    #[test]\n    fn test_encode_engine_with_standard_engine() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"hello world\";\n        let expected_output = \"aGVsbG8gd29ybGQ=\";\n        let output = encode_engine(input, &engine);\n        assert_eq!(output, expected_output);\n    }\n\n    #[test]\n    fn test_encode_engine_with_custom_engine() {\n        const CUSTOM_ENGINE: engine::GeneralPurpose =\n            engine::GeneralPurpose::new(&base64::alphabet::URL_SAFE, general_purpose::NO_PAD);\n        let input = b\"hello world\";\n        let expected_output = \"aGVsbG8gd29ybGQ\";\n        let output = encode_engine(input, &CUSTOM_ENGINE);\n        assert_eq!(output, expected_output);\n    }\n\n    #[test]\n    fn test_encode_engine_empty_string() {\n        let engine = general_purpose::STANDARD;\n        let input: &[u8] = b\"\";\n        let expected_output = \"\"; // Empty string should encode to an empty output\n        let output = encode_engine(input, &engine);\n        assert_eq!(output, expected_output);\n    }\n}\n```", "encode::encode_engine_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n\n    #[test]\n    fn test_encode_engine_slice() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b\"hello world\";\n        let mut output_buf = vec![0; 24]; // Buffer size based on expected encoded length\n\n        let result = encode_engine_slice(input, &mut output_buf, &engine).unwrap();\n        \n        let expected_output = \"aGVsbG8gd29ybGQ=\"; // Base64 encoded result for \"hello world\"\n        assert_eq!(result, expected_output.len());\n        assert_eq!(String::from_utf8_lossy(&output_buf[..result]), expected_output);\n    }\n\n    #[test]\n    fn test_encode_engine_slice_output_buffer_too_small() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b\"hello world\";\n        let mut output_buf = vec![0; 10]; // Too small buffer\n\n        let result = encode_engine_slice(input, &mut output_buf, &engine);\n        \n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), EncodeSliceError::OutputSliceTooSmall);\n    }\n}\n```", "encode::encode_engine_string": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose};\n\n    #[test]\n    fn test_encode_engine_string() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"hello world\";\n        let mut output = String::new();\n\n        encode_engine_string(input, &mut output, &engine);\n\n        assert_eq!(output, \"aGVsbG8gd29ybGQ=\");\n    }\n\n    #[test]\n    fn test_encode_engine_string_no_padding() {\n        let engine = general_purpose::GeneralPurpose::new(&base64::alphabet::URL_SAFE, general_purpose::NO_PAD);\n        let input = b\"hello\";\n        let mut output = String::new();\n\n        encode_engine_string(input, &mut output, &engine);\n\n        assert_eq!(output, \"aGVsbG8\");\n    }\n\n    #[test]\n    fn test_empty_string() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"\";\n        let mut output = String::new();\n\n        encode_engine_string(input, &mut output, &engine);\n\n        assert_eq!(output, \"\");\n    }\n}\n```", "encode::encode_with_padding": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    \n    #[test]\n    fn test_encode_with_padding() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b\"hello\";\n        let expected_encoded_size = 8; // Base64 encoding for \"hello\" is \"aGVsbG8=\"\n\n        let mut output = vec![0; expected_encoded_size];\n        \n        encode_with_padding(input, &mut output, &engine, expected_encoded_size);\n\n        // Assert output is correct\n        assert_eq!(output, b\"aGVsbG8=\");\n    }\n\n    #[test]\n    fn test_encode_with_no_padding() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::new().with_encode_padding(false));\n        let input = b\"hello\";\n        let expected_encoded_size = 8; // Base64 encoding for \"hello\" is \"aGVsbG8=\" but without padding \"aGVsbG8\"\n\n        let mut output = vec![0; expected_encoded_size];\n        \n        encode_with_padding(input, &mut output, &engine, expected_encoded_size);\n\n        // Assert output is correct without padding\n        assert_eq!(output, b\"aGVsbG8\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_encoded_size_mismatch() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b\"hello\";\n        let expected_encoded_size = 10; // Mismatch expected size\n\n        let mut output = vec![0; 8]; // Correct size is 8\n        \n        encode_with_padding(input, &mut output, &engine, expected_encoded_size);\n    }\n\n    #[test]\n    fn test_empty_input() {\n        let engine = GeneralPurpose::new(&base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b\"\";\n        let expected_encoded_size = 0; // No output for empty input\n\n        let mut output = vec![0; expected_encoded_size];\n        \n        encode_with_padding(input, &mut output, &engine, expected_encoded_size);\n\n        // Assert output is empty\n        assert_eq!(output, &[]);\n    }\n}\n```", "encode::encoded_len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::encode::encoded_len;\n\n    #[test]\n    fn test_encoded_len_no_padding() {\n        assert_eq!(encoded_len(0, false), Some(0));\n        assert_eq!(encoded_len(1, false), Some(2));\n        assert_eq!(encoded_len(2, false), Some(3));\n        assert_eq!(encoded_len(3, false), Some(4));\n        assert_eq!(encoded_len(4, false), Some(6));\n        assert_eq!(encoded_len(6, false), Some(8));\n    }\n\n    #[test]\n    fn test_encoded_len_with_padding() {\n        assert_eq!(encoded_len(0, true), Some(0));\n        assert_eq!(encoded_len(1, true), Some(4));\n        assert_eq!(encoded_len(2, true), Some(4));\n        assert_eq!(encoded_len(3, true), Some(4));\n        assert_eq!(encoded_len(4, true), Some(8));\n        assert_eq!(encoded_len(6, true), Some(8));\n    }\n\n    #[test]\n    fn test_encoded_len_large_input() {\n        assert_eq!(encoded_len(usize::MAX - 1, false), None);\n        assert_eq!(encoded_len(usize::MAX - 2, true), None);\n    }\n}\n```", "engine::DecodeMetadata::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_decode_metadata_new() {\n        // Test case 1: No padding\n        let metadata = DecodeMetadata::new(10, None);\n        assert_eq!(metadata.decoded_len, 10);\n        assert_eq!(metadata.padding_offset, None);\n\n        // Test case 2: With padding\n        let metadata = DecodeMetadata::new(10, Some(2));\n        assert_eq!(metadata.decoded_len, 10);\n        assert_eq!(metadata.padding_offset, Some(2));\n\n        // Test case 3: Zero decoded bytes\n        let metadata = DecodeMetadata::new(0, Some(0));\n        assert_eq!(metadata.decoded_len, 0);\n        assert_eq!(metadata.padding_offset, Some(0));\n\n        // Test case 4: Large decoded bytes\n        let metadata = DecodeMetadata::new(usize::MAX, None);\n        assert_eq!(metadata.decoded_len, usize::MAX);\n        assert_eq!(metadata.padding_offset, None);\n    }\n}\n```", "engine::Engine::decode": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{engine::{self, general_purpose}, alphabet};\n\n    #[test]\n    fn test_standard_decode() {\n        let input = \"aGVsbG8gd29ybGR+Cg==\";\n        let expected = b\"hello world\\n\".to_vec();\n        let result = general_purpose::STANDARD.decode(input).unwrap();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_url_safe_decode() {\n        let input = \"aGVsbG8gaW50ZXJuZXR-Cg\";\n        let expected = b\"hello interner\\n\".to_vec();\n        let engine = engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);\n        let result = engine.decode(input).unwrap();\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_decode_invalid_input() {\n        let input = \"!!!invalid base64!!!\";\n        let result = general_purpose::STANDARD.decode(input);\n        assert!(result.is_err()); // Expecting an error due to invalid input\n    }\n}\n```", "engine::Engine::decode::inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose, DecodePaddingMode};\n\n    #[test]\n    fn test_general_purpose_decode() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"aGVsbG8gd29ybGR+Cg==\"; // \"hello world\\n\"\n        let expected_output = b\"hello world\\n\";\n        \n        let result = engine.decode(input).expect(\"Decoding failed\");\n        assert_eq!(result.as_slice(), expected_output);\n    }\n\n    #[test]\n    fn test_decode_with_no_padding() {\n        let config = engine::GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::RequireNone);\n        let engine = engine::GeneralPurpose::new(&base64::alphabet::STANDARD, config);\n        \n        let input = b\"aGVsbG8gaW50ZXJuZXR-Cg\"; // \"hello internet\\n\"\n        let expected_output = b\"hello internet\\n\";\n        \n        let result = engine.decode(input).expect(\"Decoding failed\");\n        assert_eq!(result.as_slice(), expected_output);\n    }\n\n    #[test]\n    fn test_decode_with_indifferent_padding() {\n        let config = engine::GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::Indifferent);\n        let engine = engine::GeneralPurpose::new(&base64::alphabet::STANDARD, config);\n        \n        let input = b\"aGVsbG8gd29ybGR+Cg\"; // \"hello world\\n\"\n        let expected_output = b\"hello world\\n\";\n        \n        let result = engine.decode(input).expect(\"Decoding failed\");\n        assert_eq!(result.as_slice(), expected_output);\n    }\n\n    #[test]\n    fn test_decode_error_with_invalid_input() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"invalid-base64\"; // Invalid base64 input\n        \n        let result = engine.decode(input);\n        assert!(result.is_err(), \"Decoding should have failed\");\n    }\n\n    #[test]\n    fn test_decode_empty_input() {\n        let engine = general_purpose::STANDARD;\n        let input: &[u8] = b\"\"; // Empty input\n        \n        let result = engine.decode(input).expect(\"Decoding failed\");\n        assert!(result.is_empty(), \"Decoding empty input should yield empty Vec\");\n    }\n}\n```", "engine::Engine::decode_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::Engine;\n    use base64::engine::DecodeSliceError;\n\n    #[test]\n    fn test_decode_slice_success() {\n        let engine = Engine::new(); // Assuming a way to create an Engine, replace with actual constructor\n        let input = b\"SGVsbG8sIFdvcmxkIQ==\"; // Base64 for \"Hello, World!\"\n        let mut output = vec![0u8; 13]; // Length of \"Hello, World!\"\n        \n        let result = engine.decode_slice(input, &mut output);\n        \n        assert_eq!(result, Ok(13));\n        assert_eq!(output, b\"Hello, World!\");\n    }\n\n    #[test]\n    fn test_decode_slice_error_small_output() {\n        let engine = Engine::new(); // Assuming a way to create an Engine, replace with actual constructor\n        let input = b\"SGVsbG8sIFdvcmxkIQ==\"; // Base64 for \"Hello, World!\"\n        let mut output = vec![0u8; 5]; // Insufficient length\n        \n        let result = engine.decode_slice(input, &mut output);\n        \n        assert!(result.is_err());\n        match result {\n            Err(DecodeSliceError::OutputTooSmall) => {},\n            _ => panic!(\"Expected DecodeSliceError::OutputTooSmall\"),\n        }\n    }\n}\n```", "engine::Engine::decode_slice::inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose};\n    use base64::DecodeSliceError;\n\n    #[test]\n    fn test_inner_decode_success() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"SGVsbG8gd29ybGQ=\"; // \"Hello world\"\n        let mut output = vec![0; 11]; // Sized according to expected output length\n\n        let result = inner(&engine, input, &mut output);\n        assert!(result.is_ok());\n        assert_eq!(&output, b\"Hello world\");\n    }\n\n    #[test]\n    fn test_inner_decode_invalid_padding() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"SGVsbG8gd29ybGQ==\"; // Invalid padding\n\n        let mut output = vec![0; 11]; // Sized according to expected output length\n\n        let result = inner(&engine, input, &mut output);\n        assert!(result.is_err());\n        assert_eq!(result.err(), Some(DecodeSliceError::DecodeError(_)));\n    }\n\n    #[test]\n    fn test_inner_decode_output_size_too_small() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"SGVsbG8gd29ybGQ=\"; // \"Hello world\"\n        let mut output = vec![0; 5]; // Sized too small\n\n        let result = inner(&engine, input, &mut output);\n        assert!(result.is_err());\n        assert_eq!(result.err(), Some(DecodeSliceError::OutputSliceTooSmall));\n    }\n}\n```", "engine::Engine::decode_slice_unchecked": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{Engine, DecodeError};\n\n    struct MockEngine;\n\n    impl Engine for MockEngine {\n        // Implement necessary methods for the Engine trait\n    }\n\n    #[test]\n    fn test_decode_slice_unchecked_valid() {\n        let engine = MockEngine;\n        let input = b\"SGVsbG8sIHdvcmxkIQ==\"; // Base64 for \"Hello, world!\"\n        let mut output = [0u8; 13]; // Expected output size\n        let result = engine.decode_slice_unchecked(input, &mut output);\n        \n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), 13);\n        assert_eq!(&output[..], b\"Hello, world!\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"Output slice is too small\")]\n    fn test_decode_slice_unchecked_too_small_output() {\n        let engine = MockEngine;\n        let input = b\"SGVsbG8sIHdvcmxkIQ==\"; // Base64 for \"Hello, world!\"\n        let mut output = [0u8; 5]; // Expected output size too small\n        engine.decode_slice_unchecked(input, &mut output).unwrap();\n    }\n\n    #[test]\n    fn test_decode_slice_unchecked_empty_input() {\n        let engine = MockEngine;\n        let input = b\"\"; // Empty input\n        let mut output = [0u8; 0]; // Empty output\n        let result = engine.decode_slice_unchecked(input, &mut output);\n        \n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), 0);\n    }\n}\n```", "engine::Engine::decode_slice_unchecked::inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    use base64::engine::DecodePaddingMode;\n\n    #[test]\n    fn test_inner_valid_decoding() {\n        let engine = GeneralPurpose::new(base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b\"aGVsbG8gd29ybGQ=\"; // \"hello world\" in base64\n        let mut output = vec![0; 11]; // allocate sufficient space for \"hello world\" (11 bytes)\n\n        let result = inner(&engine, input, &mut output);\n        assert_eq!(result, Ok(11));\n        assert_eq!(output, b\"hello world\");\n    }\n\n    #[test]\n    fn test_inner_too_small_output() {\n        let engine = GeneralPurpose::new(base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b\"aGVsbG8gd29ybGQ=\"; // \"hello world\" in base64\n        let mut output = vec![0; 5]; // insufficient space for \"hello world\"\n\n        let result = inner(&engine, input, &mut output);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_inner_invalid_input() {\n        let engine = GeneralPurpose::new(base64::alphabet::STANDARD, GeneralPurposeConfig::default());\n        let input = b\"invalid_base64\"; // Invalid base64\n        let mut output = vec![0; 11]; // allocate sufficient space for decoding\n\n        let result = inner(&engine, input, &mut output);\n        assert!(result.is_err());\n    }\n}\n```", "engine::Engine::decode_vec": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{Engine as _, alphabet, engine::{self, general_purpose}};\n\n    #[test]\n    fn test_decode_vec_standard_engine() {\n        let mut buffer = Vec::new();\n        let result = general_purpose::STANDARD.decode_vec(\"aGVsbG8gd29ybGR+Cg==\", &mut buffer);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b\"hello world\\n\");\n    }\n\n    #[test]\n    fn test_decode_vec_custom_engine() {\n        const CUSTOM_ENGINE: engine::GeneralPurpose =\n            engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::PAD);\n        let mut buffer = Vec::new();\n        let result = CUSTOM_ENGINE.decode_vec(\"aGVsbG8gaW50ZXJuZXR-Cg==\", &mut buffer);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b\"hello internet\\n\");\n    }\n\n    #[test]\n    fn test_decode_vec_empty_input() {\n        let mut buffer = Vec::new();\n        let result = general_purpose::STANDARD.decode_vec(\"\", &mut buffer);\n        assert!(result.is_ok());\n        assert!(buffer.is_empty());\n    }\n\n    #[test]\n    fn test_decode_vec_invalid_input() {\n        let mut buffer = Vec::new();\n        let result = general_purpose::STANDARD.decode_vec(\"%%%invalid%%%\", &mut buffer);\n        assert!(result.is_err());\n    }\n}\n```", "engine::Engine::decode_vec::inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::{self, general_purpose};\n    use crate::engine::DecodePaddingMode;\n\n    #[test]\n    fn test_inner_decoding_success() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"aGVsbG8gd29ybGR+Cg==\";\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b\"hello world\\n\");\n    }\n\n    #[test]\n    fn test_inner_decoding_with_padding() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"aGVsbG8gd29ybGR+Cg==\"; // Base64 for \"hello world\\n\"\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b\"hello world\\n\");\n    }\n\n    #[test]\n    fn test_inner_decoding_no_padding() {\n        let config = general_purpose::GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::RequireNone);\n        let engine = general_purpose::GeneralPurpose::new(&general_purpose::STANDARD.decode_table, config);\n        let input = b\"aGVsbG8gd29ybGR+Cg==\"; // Base64 for \"hello world\\n\"\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_ok());\n        assert_eq!(buffer, b\"hello world\\n\");\n    }\n\n    #[test]\n    fn test_inner_decoding_invalid_padding() {\n        let config = general_purpose::GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::RequireCanonical);\n        let engine = general_purpose::GeneralPurpose::new(&general_purpose::STANDARD.decode_table, config);\n        let input = b\"aGVsbG8gd29ybGR+Cg\"; // Invalid Base64 without proper padding\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_inner_decoding_empty_input() {\n        let engine = general_purpose::STANDARD;\n        let input: &[u8] = b\"\"; // Empty input\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_ok());\n        assert!(buffer.is_empty());\n    }\n\n    #[test]\n    fn test_inner_decoding_invalid_input() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"!!invalid$$\"; // Invalid Base64\n        let mut buffer = Vec::new();\n\n        let result = engine.decode_vec(input, &mut buffer);\n        assert!(result.is_err());\n    }\n}\n```", "engine::Engine::encode": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{engine::{self, general_purpose}, alphabet};\n\n    #[test]\n    fn test_encode_standard() {\n        let input = b\"hello world~\";\n        let expected = \"aGVsbG8gd29ybGQ~\";\n        let result = general_purpose::STANDARD.encode(input);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_encode_custom_engine() {\n        const CUSTOM_ENGINE: engine::GeneralPurpose =\n            engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);\n        let input = b\"hello internet~\";\n        let expected = \"aGVsbG8gaW50ZXJuZXQ~\";\n        let result = CUSTOM_ENGINE.encode(input);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_encode_empty_input() {\n        let input = b\"\";\n        let expected = \"\";\n        let result = general_purpose::STANDARD.encode(input);\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_encode_special_characters() {\n        let input = b\"hello & welcome @ 2023!\";\n        let expected = \"aGVsbG8gJiB3ZWxjb21lICMgMjAyMw~\";\n        let result = general_purpose::STANDARD.encode(input);\n        assert_eq!(result, expected);\n    }\n}\n```", "engine::Engine::encode::inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_inner_encode() {\n        let engine = general_purpose::STANDARD;\n        let input = b\"hello world\";\n        let expected_output = \"aGVsbG8gd29ybGQ=\"; // Expected base64 output with padding\n        let encoded = engine.encode(input);\n        assert_eq!(encoded, expected_output);\n    }\n\n    #[test]\n    fn test_inner_encode_empty() {\n        let engine = general_purpose::STANDARD;\n        let input: &[u8] = &[];\n        let expected_output = \"\"; // Expected output for an empty input\n        let encoded = engine.encode(input);\n        assert_eq!(encoded, expected_output);\n    }\n\n    #[test]\n    fn test_inner_encode_no_padding() {\n        let config = general_purpose::GeneralPurposeConfig::new().with_encode_padding(false);\n        let engine = general_purpose::GeneralPurpose::new(&general_purpose::STANDARD.encode_table, config);\n        let input = b\"hello world\";\n        let expected_output = \"aGVsbG8gd29ybGQ\"; // Expected base64 output without padding\n        let encoded = engine.encode(input);\n        assert_eq!(encoded, expected_output);\n    }\n\n    #[test]\n    fn test_inner_encode_invalid_utf8() {\n        let engine = general_purpose::STANDARD;\n        let input = [0xFF, 0xFF, 0xFF]; // Invalid UTF-8 sequence\n        let result = std::panic::catch_unwind(|| {\n            engine.encode(&input)\n        });\n        assert!(result.is_err());\n    }\n}\n```", "engine::Engine::encode_slice": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{engine::general_purpose, Engine};\n\n    #[test]\n    fn test_encode_slice_success() {\n        let s = b\"hello internet!\";\n        let mut buf = vec![0u8; s.len() * 4 / 3 + 4]; // Ensure buffer is large enough\n        let bytes_written = general_purpose::STANDARD.encode_slice(s, &mut buf).unwrap();\n        buf.truncate(bytes_written);\n        assert_eq!(s, general_purpose::STANDARD.decode(&buf).unwrap().as_slice());\n    }\n\n    #[test]\n    fn test_encode_slice_too_small_buffer() {\n        let s = b\"hello\";\n        let mut buf = vec![0u8; 5]; // Insufficient buffer size\n        let result = general_purpose::STANDARD.encode_slice(s, &mut buf);\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap(), EncodeSliceError::OutputSliceTooSmall);\n    }\n\n    #[test]\n    fn test_encode_slice_empty_input() {\n        let s: &[u8] = &[];\n        let mut buf = vec![0u8; 4]; // Minimum buffer size for base64\n        let bytes_written = general_purpose::STANDARD.encode_slice(s, &mut buf).unwrap();\n        buf.truncate(bytes_written);\n        assert_eq!(buf, b\"\");\n    }\n}\n```", "engine::Engine::encode_slice::inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose::GeneralPurpose};\n\n    #[test]\n    fn test_inner_encode_success() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = b\"hello\";\n        let mut output_buf = vec![0; 8]; // Expected output size for base64\n        let result = inner(&engine, input, &mut output_buf);\n        assert!(result.is_ok());\n        let encoded_size = result.unwrap();\n        let expected_output = \"aGVsbG8=\".as_bytes();\n        assert_eq!(&output_buf[..encoded_size], expected_output);\n    }\n\n    #[test]\n    fn test_inner_encode_output_buffer_too_small() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = b\"hello\";\n        let mut output_buf = vec![0; 5]; // Too small for base64 encoding of \"hello\"\n        let result = inner(&engine, input, &mut output_buf);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), EncodeSliceError::OutputSliceTooSmall);\n    }\n\n    #[test]\n    fn test_inner_encode_empty_input() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input: &[u8] = &[];\n        let mut output_buf = vec![0; 4]; // Expected output size for empty input is 0\n        let result = inner(&engine, input, &mut output_buf);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), 0);\n    }\n}\n```", "engine::Engine::encode_string": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::{engine::{self, general_purpose}, alphabet};\n\n    #[test]\n    fn test_encode_string_standard() {\n        let mut output_buf = String::new();\n        general_purpose::STANDARD.encode_string(b\"hello world~\", &mut output_buf);\n        assert_eq!(output_buf, \"aGVsbG8gd29ybGQ~\"); // Example base64 encoded output\n    }\n\n    #[test]\n    fn test_encode_string_custom() {\n        const CUSTOM_ENGINE: engine::GeneralPurpose =\n            engine::GeneralPurpose::new(&alphabet::URL_SAFE, general_purpose::NO_PAD);\n        let mut output_buf = String::new();\n        CUSTOM_ENGINE.encode_string(b\"hello internet~\", &mut output_buf);\n        assert_eq!(output_buf, \"aGVsbG8gaW50ZXJuZXQ~\"); // Example base64 encoded output\n    }\n\n    #[test]\n    fn test_encode_string_empty() {\n        let mut output_buf = String::new();\n        general_purpose::STANDARD.encode_string(b\"\", &mut output_buf);\n        assert_eq!(output_buf, \"\"); // Empty input should produce empty output\n    }\n\n    #[test]\n    fn test_encode_string_non_ascii() {\n        let mut output_buf = String::new();\n        general_purpose::STANDARD.encode_string(b\"hello \ud83c\udf0d\", &mut output_buf);\n        assert_eq!(output_buf, \"aGVsbG8g8J+YgPCf\"); // Example base64 encoded output\n    }\n}\n```", "engine::Engine::encode_string::inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{self, general_purpose::GeneralPurpose, DecodePaddingMode};\n\n    #[test]\n    fn test_encode_string() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = b\"hello, world!\";\n        let mut output = String::new();\n        \n        engine.encode_string(input, &mut output);\n        \n        assert_eq!(output, \"aGVsbG8sIHdvcmxkIQ==\");\n    }\n\n    #[test]\n    fn test_encode_string_with_no_padding() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::new().with_encode_padding(false));\n        let input = b\"hello, world!\";\n        let mut output = String::new();\n        \n        engine.encode_string(input, &mut output);\n        \n        assert_eq!(output, \"aGVsbG8sIHdvcmxkIQ\");\n    }\n\n    #[test]\n    fn test_empty_string() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = b\"\";\n        let mut output = String::new();\n        \n        engine.encode_string(input, &mut output);\n        \n        assert_eq!(output, \"\");\n    }\n\n    #[test]\n    fn test_unicode_string() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = \"\u3053\u3093\u306b\u3061\u306f\".as_bytes();\n        let mut output = String::new();\n        \n        engine.encode_string(input, &mut output);\n        \n        assert_eq!(output, \"44GT44KT44Go44K44K544Oz\");\n    }\n\n    #[test]\n    fn test_large_input() {\n        let engine = GeneralPurpose::new(&engine::alphabet::STANDARD, engine::GeneralPurposeConfig::default());\n        let input = vec![b'a'; 1000];\n        let mut output = String::new();\n        \n        engine.encode_string(&input, &mut output);\n        \n        assert_eq!(output.len(), 1334); // 1000 bytes of 'a's produce 1334 base64 characters\n    }\n}\n```", "engine::general_purpose::GeneralPurpose::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::alphabet::Alphabet;\n    use base64::engine::general_purpose::{GeneralPurpose, GeneralPurposeConfig};\n    use base64::engine::DecodePaddingMode;\n\n    #[test]\n    fn test_general_purpose_new() {\n        let alphabet = Alphabet::new(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\").unwrap();\n        let config = GeneralPurposeConfig::new()\n            .with_encode_padding(true)\n            .with_decode_padding_mode(DecodePaddingMode::RequireCanonical);\n        \n        let engine = GeneralPurpose::new(&alphabet, config);\n        \n        assert_eq!(engine.config().encode_padding(), true);\n        assert_eq!(engine.config().decode_padding_mode, DecodePaddingMode::RequireCanonical);\n    }\n\n    #[test]\n    fn test_general_purpose_new_invalid_alphabet() {\n        assert!(Alphabet::new(\"Not a valid alphabet!\").is_err());\n    }\n\n    #[test]\n    fn test_general_purpose_new_empty_alphabet() {\n        assert!(Alphabet::new(\"\").is_err());\n    }\n}\n```", "engine::general_purpose::GeneralPurposeConfig::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::{DecodePaddingMode, GeneralPurposeConfig};\n\n    #[test]\n    fn test_general_purpose_config_new() {\n        let config = GeneralPurposeConfig::new();\n        \n        assert_eq!(config.encode_padding(), true);\n        assert_eq!(config.decode_allow_trailing_bits, false);\n        assert_eq!(config.decode_padding_mode, DecodePaddingMode::RequireCanonical);\n    }\n}\n```", "engine::general_purpose::GeneralPurposeConfig::with_decode_allow_trailing_bits": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use engine::general_purpose::GeneralPurposeConfig;\n\n    #[test]\n    fn test_with_decode_allow_trailing_bits() {\n        let config = GeneralPurposeConfig::new();\n        \n        // Test allowing trailing bits\n        let updated_config = config.with_decode_allow_trailing_bits(true);\n        assert_eq!(updated_config.decode_allow_trailing_bits, true);\n        \n        // Test not allowing trailing bits\n        let updated_config = config.with_decode_allow_trailing_bits(false);\n        assert_eq!(updated_config.decode_allow_trailing_bits, false);\n    }\n}\n```", "engine::general_purpose::GeneralPurposeConfig::with_decode_padding_mode": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use engine::general_purpose::GeneralPurposeConfig;\n    use engine::DecodePaddingMode;\n\n    #[test]\n    fn test_with_decode_padding_mode_indifferent() {\n        let config = GeneralPurposeConfig::new();\n        let updated_config = config.with_decode_padding_mode(DecodePaddingMode::Indifferent);\n        assert_eq!(updated_config.decode_padding_mode, DecodePaddingMode::Indifferent);\n    }\n\n    #[test]\n    fn test_with_decode_padding_mode_require_canonical() {\n        let config = GeneralPurposeConfig::new();\n        let updated_config = config.with_decode_padding_mode(DecodePaddingMode::RequireCanonical);\n        assert_eq!(updated_config.decode_padding_mode, DecodePaddingMode::RequireCanonical);\n    }\n\n    #[test]\n    fn test_with_decode_padding_mode_require_none() {\n        let config = GeneralPurposeConfig::new();\n        let updated_config = config.with_decode_padding_mode(DecodePaddingMode::RequireNone);\n        assert_eq!(updated_config.decode_padding_mode, DecodePaddingMode::RequireNone);\n    }\n\n    #[test]\n    fn test_with_decode_padding_mode_chain() {\n        let config = GeneralPurposeConfig::new()\n            .with_decode_padding_mode(DecodePaddingMode::Indifferent)\n            .with_decode_padding_mode(DecodePaddingMode::RequireNone);\n        assert_eq!(config.decode_padding_mode, DecodePaddingMode::RequireNone);\n    }\n}\n```", "engine::general_purpose::GeneralPurposeConfig::with_encode_padding": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::GeneralPurposeConfig;\n\n    #[test]\n    fn test_with_encode_padding() {\n        let config = GeneralPurposeConfig::new();\n\n        // Test with padding enabled\n        let config_with_padding = config.with_encode_padding(true);\n        assert_eq!(config_with_padding.encode_padding, true);\n\n        // Test with padding disabled\n        let config_without_padding = config.with_encode_padding(false);\n        assert_eq!(config_without_padding.encode_padding, false);\n    }\n}\n```", "engine::general_purpose::decode::GeneralPurposeEstimate::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::engine::general_purpose::decode::GeneralPurposeEstimate;\n\n    #[test]\n    fn test_new() {\n        let encoded_len = 4;\n        let estimate = GeneralPurposeEstimate::new(encoded_len);\n        assert_eq!(estimate.rem, 0);\n        assert_eq!(estimate.conservative_decoded_len, 3);\n        \n        let encoded_len = 5;\n        let estimate = GeneralPurposeEstimate::new(encoded_len);\n        assert_eq!(estimate.rem, 1);\n        assert_eq!(estimate.conservative_decoded_len, 6);\n        \n        let encoded_len = 6;\n        let estimate = GeneralPurposeEstimate::new(encoded_len);\n        assert_eq!(estimate.rem, 2);\n        assert_eq!(estimate.conservative_decoded_len, 6);\n        \n        let encoded_len = 7;\n        let estimate = GeneralPurposeEstimate::new(encoded_len);\n        assert_eq!(estimate.rem, 3);\n        assert_eq!(estimate.conservative_decoded_len, 9);\n        \n        let encoded_len = 8;\n        let estimate = GeneralPurposeEstimate::new(encoded_len);\n        assert_eq!(estimate.rem, 0);\n        assert_eq!(estimate.conservative_decoded_len, 6);\n    }\n}\n```", "engine::general_purpose::decode::complete_quads_len": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::decode::complete_quads_len;\n    use crate::engine::general_purpose::decode::{DecodeSliceError, DecodeError, PAD_BYTE, INVALID_VALUE};\n\n    #[test]\n    fn test_complete_quads_len() {\n        let decode_table: [u8; 256] = [\n            INVALID_VALUE; 256\n        ];\n\n        // Valid case with complete quads\n        let input = b\"QUJDRA==\"; // Length 8, 6 complete bytes\n        let input_len_rem = 2;\n        let output_len = 5; // 6 bytes input should decode to 5 bytes output\n        assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Ok(6));\n\n        // Valid case with incomplete quads, one valid byte\n        let input = b\"QUJDRA=\"; // Length 7\n        let input_len_rem = 1;\n        let output_len = 5;\n        assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Ok(6));\n\n        // Invalid case: output length too small\n        let input = b\"QUJDRA=\";\n        let input_len_rem = 1;\n        let output_len = 4; // Not enough space\n        assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Err(DecodeSliceError::OutputSliceTooSmall));\n\n        // Invalid case: trailing invalid byte\n        let decode_table: [u8; 256] = {\n            let mut table = [INVALID_VALUE; 256];\n            table[b'Q' as usize] = 16; // Set valid decode values for testing\n            table[b'U' as usize] = 20;\n            table[b'J' as usize] = 9;\n            table[b'D' as usize] = 3;\n            table\n        };\n\n        let input = b\"QUJDRA\\xFF\"; // Invalid trailing byte\n        let input_len_rem = 1;\n        let output_len = 5;\n        assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Err(DecodeError::InvalidByte(6, 0xFF).into()));\n    }\n}\n```", "engine::general_purpose::decode::decode_chunk_4": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::decode::{decode_chunk_4, DecodeError};\n\n    const DECODE_TABLE: [u8; 256] = [ /* your decode table values here */ ];\n    const INVALID_VALUE: u8 = 255; // Assuming 255 represents an invalid value\n\n    #[test]\n    fn test_decode_chunk_4_valid_input() {\n        let input = b\"QUJD\"; // Base64 encoding of \"ABC\"\n        let mut output = [0u8; 3];\n\n        let result = decode_chunk_4(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_ok());\n        assert_eq!(&output, b\"ABC\");\n    }\n\n    #[test]\n    fn test_decode_chunk_4_invalid_input() {\n        let input = b\"QUJ*\"; // Invalid Base64 input\n        let mut output = [0u8; 3];\n\n        let result = decode_chunk_4(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_err());\n        if let Err(DecodeError::InvalidByte(index, byte)) = result {\n            assert_eq!(index, 3);\n            assert_eq!(byte, b'*');\n        } else {\n            panic!(\"Expected an InvalidByte error\");\n        }\n    }\n\n    #[test]\n    fn test_decode_chunk_4_partial_input() {\n        let input = b\"QU\"; // Incomplete Base64 input\n        let mut output = [0u8; 3];\n\n        let result = decode_chunk_4(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_err());\n        // Check that the error is due to the input length.\n    }\n}\n```", "engine::general_purpose::decode::decode_chunk_8": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::general_purpose::decode::decode_chunk_8;\n\n    const DECODE_TABLE: [u8; 256] = [\n        // Initialize with example values; actual values should correspond to your base64 alphabet\n        // for example, base64 standard values\n        // 0-25: 'A'-'Z' -> 0-25\n        // 26-51: 'a'-'z' -> 26-51\n        // 52-61: '0'-'9' -> 52-61\n        // 62: '+' -> 62\n        // 63: '/' -> 63\n        // Any other byte should be INVALID_VALUE\n        // Add values accordingly...\n    ];\n    \n    const INVALID_VALUE: u8 = 255; // or whatever your INVALID_VALUE is\n\n    #[test]\n    fn test_decode_chunk_8_valid() {\n        let input = b\"QmFzZTY0\"; // Base64 for \"Base64\"\n        let mut output = [0u8; 6];\n        let result = decode_chunk_8(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_ok());\n        assert_eq!(&output[..], b\"Base64\"); // Example output; adjust according to actual expected\n    }\n\n    #[test]\n    fn test_decode_chunk_8_invalid_byte() {\n        let input = b\"QmFzZ\"&[0u8]; // Invalid character\n        let mut output = [0u8; 6];\n        let result = decode_chunk_8(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_decode_chunk_8_invalid_length() {\n        let input = b\"QmFz\"; // Insufficient length\n        let mut output = [0u8; 6];\n        let result = decode_chunk_8(input, 0, &DECODE_TABLE, &mut output);\n        assert!(result.is_err());\n    }\n}\n```", "engine::general_purpose::decode::decode_helper": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::{decode::decode_helper, DecodePaddingMode, general_purpose::GeneralPurposeEstimate};\n\n    #[test]\n    fn test_decode_helper() {\n        let input: &[u8] = b\"SGVsbG8gV29ybGQ=\"; // \"Hello World\" in base64\n        let estimate = GeneralPurposeEstimate::new(input.len());\n        let mut output = vec![0u8; estimate.decoded_len_estimate()];\n        let decode_table = base64::engine::general_purpose::TABLE; // Assuming the decode table is accessible in this context\n        let decode_allow_trailing_bits = true; // Assuming this edge case\n        let padding_mode = DecodePaddingMode::RequireCanonical;\n\n        let result = decode_helper(input, &estimate, &mut output, decode_table, decode_allow_trailing_bits, padding_mode);\n\n        assert!(result.is_ok());\n        let metadata = result.unwrap();\n        assert_eq!(metadata.len, 11); // Length of \"Hello World\"\n        assert_eq!(&output[..11], b\"Hello World\"); // Check the output\n    }\n    \n    #[test]\n    fn test_decode_helper_with_invalid_input() {\n        let input: &[u8] = b\"SGVsbG8gV29ybGQ\"; // Invalid base64 input (missing padding)\n        let estimate = GeneralPurposeEstimate::new(input.len());\n        let mut output = vec![0u8; estimate.decoded_len_estimate()];\n        let decode_table = base64::engine::general_purpose::TABLE;\n        let decode_allow_trailing_bits = false;\n        let padding_mode = DecodePaddingMode::RequireCanonical;\n\n        let result = decode_helper(input, &estimate, &mut output, decode_table, decode_allow_trailing_bits, padding_mode);\n\n        assert!(result.is_err());\n    }\n}\n```", "engine::general_purpose::decode_suffix::decode_suffix": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::engine::DecodePaddingMode;\n\n    #[test]\n    fn test_decode_suffix_valid() {\n        let input = b\"QUJDRA==\"; // Base64 for \"ABCD\"\n        let input_index = 0;\n        let mut output = [0u8; 4];\n        let output_index = 0;\n        let decode_table = [0; 256]; // Populate with actual decode values\n        let decode_allow_trailing_bits = false;\n        let padding_mode = DecodePaddingMode::RequireCanonical;\n\n        let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);\n        assert!(result.is_ok());\n        let metadata = result.unwrap();\n        assert_eq!(metadata.total_bytes, 4);\n        assert_eq!(output, b\"ABCD\");\n    }\n\n    #[test]\n    fn test_decode_suffix_invalid_padding() {\n        let input = b\"QUJDRA==A\"; // Invalid padding\n        let input_index = 0;\n        let mut output = [0u8; 4];\n        let output_index = 0;\n        let decode_table = [0; 256]; // Populate with actual decode values\n        let decode_allow_trailing_bits = false;\n        let padding_mode = DecodePaddingMode::RequireCanonical;\n\n        let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_decode_suffix_with_trailing_bits() {\n        let input = b\"QUJDRA\"; // Valid input, but with trailing bits\n        let input_index = 0;\n        let mut output = [0u8; 4];\n        let output_index = 0;\n        let decode_table = [0; 256]; // Populate with actual decode values\n        let decode_allow_trailing_bits = false;\n        let padding_mode = DecodePaddingMode::RequireNone;\n\n        let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_decode_suffix_indifferent_padding() {\n        let input = b\"QUJDRA==\"; // Base64 for \"ABCD\"\n        let input_index = 0;\n        let mut output = [0u8; 4];\n        let output_index = 0;\n        let decode_table = [0; 256]; // Populate with actual decode values\n        let decode_allow_trailing_bits = false;\n        let padding_mode = DecodePaddingMode::Indifferent;\n\n        let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);\n        assert!(result.is_ok());\n        let metadata = result.unwrap();\n        assert_eq!(metadata.total_bytes, 4);\n        assert_eq!(output, b\"ABCD\");\n    }\n}\n```", "engine::general_purpose::decode_table": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::alphabet::Alphabet;\n\n    #[test]\n    fn test_decode_table_valid_alphabet() {\n        let alphabet = Alphabet::new(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\").unwrap();\n        let table = decode_table(&alphabet);\n        \n        // Check if the table has the correct mappings for the alphabet\n        for (index, &symbol) in alphabet.symbols.iter().enumerate() {\n            assert_eq!(table[symbol as usize], index as u8);\n        }\n\n        // Check if invalid symbols return INVALID_VALUE\n        for byte in 0..256 {\n            if byte < 65 || (byte > 90 && byte < 97) || (byte > 122 && byte < 48) || byte > 57 {\n                assert_eq!(table[byte], INVALID_VALUE);\n            }\n        }\n    }\n\n    #[test]\n    fn test_decode_table_custom_alphabet() {\n        let custom_alphabet = \"ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba9876543210/=\";\n        let alphabet = Alphabet::new(custom_alphabet).unwrap();\n        let table = decode_table(&alphabet);\n        \n        // Check if the table has the correct mappings for the custom alphabet\n        for (index, &symbol) in alphabet.symbols.iter().enumerate() {\n            assert_eq!(table[symbol as usize], index as u8);\n        }\n\n        // Check if invalid symbols return INVALID_VALUE\n        for byte in 0..256 {\n            if !alphabet.symbols.iter().any(|&x| x == byte) {\n                assert_eq!(table[byte], INVALID_VALUE);\n            }\n        }\n    }\n\n    #[test]\n    fn test_decode_table_invalid_alphabet() {\n        // Test with an alphabet with duplicates\n        let invalid_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefgh\";\n        assert!(Alphabet::new(invalid_alphabet).is_err());\n    }\n}\n```", "engine::general_purpose::encode_table": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::alphabet::Alphabet;\n\n    #[test]\n    fn test_encode_table() {\n        let alphabet = Alphabet::new(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\").unwrap();\n        let expected_table: [u8; 64] = [\n            b'A', b'B', b'C', b'D', b'E', b'F', b'G', b'H',\n            b'I', b'J', b'K', b'L', b'M', b'N', b'O', b'P',\n            b'Q', b'R', b'S', b'T', b'U', b'V', b'W', b'X',\n            b'Y', b'Z', b'a', b'b', b'c', b'd', b'e', b'f',\n            b'g', b'h', b'i', b'j', b'k', b'l', b'm', b'n',\n            b'o', b'p', b'q', b'r', b's', b't', b'u', b'v',\n            b'w', b'x', b'y', b'z', b'0', b'1', b'2', b'3',\n            b'4', b'5', b'6', b'7', b'8', b'9', b'+', b'/',\n        ];\n\n        let table = encode_table(&alphabet);\n        assert_eq!(table, expected_table);\n    }\n}\n```", "engine::general_purpose::read_u64": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_read_u64() {\n        let input: &[u8] = &[0, 0, 0, 0, 0, 0, 0, 1]; // represents 1 in big-endian\n        let result = read_u64(input);\n        assert_eq!(result, 1);\n\n        let input: &[u8] = &[0, 0, 0, 0, 0, 0, 0, 255]; // represents 255 in big-endian\n        let result = read_u64(input);\n        assert_eq!(result, 255);\n\n        let input: &[u8] = &[0, 0, 0, 0, 1, 0, 0, 0]; // represents 16777216 in big-endian\n        let result = read_u64(input);\n        assert_eq!(result, 16777216);\n\n        let input: &[u8] = &[255, 255, 255, 255, 255, 255, 255, 255]; // represents maximum u64 value\n        let result = read_u64(input);\n        assert_eq!(result, u64::MAX);\n\n        let input: &[u8] = &[0, 0, 0, 0, 0, 0, 0, 0]; // represents 0 in big-endian\n        let result = read_u64(input);\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_read_u64_panic_on_short_slice() {\n        let input: &[u8] = &[0, 0, 0]; // Less than 8 bytes\n        let _result = read_u64(input);\n    }\n}\n```", "read::decoder::DecoderReader::<'e, E, R>::decode_to_buf": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn test_decode_to_buf_success() {\n        let input_data = b\"YW55IGNhbm7igJlzIGNvbW1vbmx5IG5vdCBhIHZhbGlkIHN0YXdlLg==\"; // \"any cano\u00eb is commonly not a valid stave.\"\n        let expected_output = b\"any cano\u00eb is commonly not a valid stave.\";\n        let mut cursor = Cursor::new(input_data);\n        let engine = general_purpose::STANDARD;\n\n        let mut decoder = DecoderReader::new(&mut cursor, &engine);\n        let mut output_buf = vec![0; 64]; // Set output buffer size\n        \n        let decoded_len = decoder.decode_to_buf(input_data.len(), &mut output_buf).expect(\"Decoding failed\");\n        assert_eq!(decoded_len, expected_output.len());\n        assert_eq!(&output_buf[..decoded_len], expected_output);\n    }\n\n    #[test]\n    #[should_panic(expected = \"panics if `buf` is too small\")]\n    fn test_decode_to_buf_panic_on_small_buf() {\n        let input_data = b\"YW55IGNhbm7igJlzIGNvbW1vbmx5IG5vdCBhIHZhbGlkIHN0YXdlLg==\";\n        let mut cursor = Cursor::new(input_data);\n        let engine = general_purpose::STANDARD;\n\n        let mut decoder = DecoderReader::new(&mut cursor, &engine);\n        let mut output_buf = [0; 1]; // Too small buffer\n        \n        let _ = decoder.decode_to_buf(input_data.len(), &mut output_buf);\n    }\n\n    #[test]\n    fn test_decode_to_buf_padding_error() {\n        let input_data = b\"YW55IGNhbm7igJlzIGNvbW1vbmx5IG5vdCBhIHZhbGlkIHN0YXdlLg==\"; // Properly padded\n        let mut cursor = Cursor::new(input_data);\n        let engine = general_purpose::STANDARD;\n\n        let mut decoder = DecoderReader::new(&mut cursor, &engine);\n        let mut output_buf = vec![0; 64];\n\n        // Decode the initial valid part\n        let _ = decoder.decode_to_buf(input_data.len() / 4 * 4, &mut output_buf).expect(\"Decoding failed\");\n        \n        // Simulate an error case with invalid padding\n        let invalid_input_data = b\"YW55IGNhbm7igJlzIGNvbW1vbmx5IG5vdCBhIHZhbGlk==\"; // Invalid padding\n        let invalid_cursor = Cursor::new(invalid_input_data);\n        let mut invalid_decoder = DecoderReader::new(&mut invalid_cursor, &engine);\n        \n        let result = invalid_decoder.decode_to_buf(invalid_input_data.len(), &mut output_buf);\n        assert!(result.is_err(), \"Expected error due to invalid padding\");\n    }\n}\n```", "read::decoder::DecoderReader::<'e, E, R>::flush_decoded_buf": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn test_flush_decoded_buf() {\n        let data = b\"Hello, World!\";\n        let engine = engine::general_purpose::STANDARD;\n        let mut cursor = Cursor::new(data);\n        let mut decoder = read::DecoderReader::new(&mut cursor, &engine);\n        let mut decoded_buffer = [0u8; 32];\n        decoder.decoded_chunk_buffer[..data.len()].copy_from_slice(data);\n        decoder.decoded_len = data.len();\n        decoder.decoded_offset = 0;\n\n        let result = decoder.flush_decoded_buf(&mut decoded_buffer[..]);\n        assert!(result.is_ok());\n        let copied_bytes = result.unwrap();\n        assert_eq!(copied_bytes, data.len());\n        assert_eq!(&decoded_buffer[..copied_bytes], data);\n        assert_eq!(decoder.decoded_len, 0);\n        assert_eq!(decoder.decoded_offset, decoded_buffer.len());\n    }\n\n    #[test]\n    fn test_flush_decoded_buf_partial_copy() {\n        let data = b\"Hello, World!\";\n        let engine = engine::general_purpose::STANDARD;\n        let mut cursor = Cursor::new(data);\n        let mut decoder = read::DecoderReader::new(&mut cursor, &engine);\n        let mut decoded_buffer = [0u8; 5];\n        decoder.decoded_chunk_buffer[..data.len()].copy_from_slice(data);\n        decoder.decoded_len = data.len();\n        decoder.decoded_offset = 0;\n\n        let result = decoder.flush_decoded_buf(&mut decoded_buffer[..]);\n        assert!(result.is_ok());\n        let copied_bytes = result.unwrap();\n        assert_eq!(copied_bytes, decoded_buffer.len());\n        assert_eq!(&decoded_buffer[..], b\"Hello\");\n        assert_eq!(decoder.decoded_len, data.len() - copied_bytes);\n        assert_eq!(decoder.decoded_offset, copied_bytes);\n    }\n\n    #[test]\n    fn test_flush_decoded_buf_empty_buffer() {\n        let data = b\"Hello, World!\";\n        let engine = engine::general_purpose::STANDARD;\n        let mut cursor = Cursor::new(data);\n        let mut decoder = read::DecoderReader::new(&mut cursor, &engine);\n        let mut decoded_buffer = [0u8; 0]; // empty buffer\n        decoder.decoded_chunk_buffer[..data.len()].copy_from_slice(data);\n        decoder.decoded_len = data.len();\n        decoder.decoded_offset = 0;\n\n        let result = decoder.flush_decoded_buf(&mut decoded_buffer[..]);\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap().kind(), io::ErrorKind::InvalidInput);\n    }\n\n    #[test]\n    fn test_flush_decoded_buf_no_data() {\n        let engine = engine::general_purpose::STANDARD;\n        let mut cursor = Cursor::new(b\"\");\n        let mut decoder = read::DecoderReader::new(&mut cursor, &engine);\n        let mut decoded_buffer = [0u8; 5];\n        decoder.decoded_len = 0; // no data to flush\n        decoder.decoded_offset = 0;\n\n        let result = decoder.flush_decoded_buf(&mut decoded_buffer[..]);\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap().kind(), io::ErrorKind::InvalidInput);\n    }\n}\n```", "read::decoder::DecoderReader::<'e, E, R>::into_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_into_inner() {\n        let data = b\"YXNkZg==\"; // base64 for \"asdf\"\n        let cursor = Cursor::new(data);\n        let engine = &general_purpose::STANDARD;\n\n        let decoder = DecoderReader::new(cursor, engine);\n        let inner_reader = decoder.into_inner();\n\n        let mut result = Vec::new();\n        inner_reader.read_to_end(&mut result).unwrap();\n        assert_eq!(data.to_vec(), result);\n    }\n}\n```", "read::decoder::DecoderReader::<'e, E, R>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_decoder_reader_new() {\n        let data = b\"YXNkZg==\"; // \"asdf\" in base64\n        let cursor = Cursor::new(data);\n        let engine = &general_purpose::STANDARD;\n\n        // Create a new DecoderReader\n        let decoder_reader = DecoderReader::new(cursor, engine);\n\n        // Check that properties are initialized correctly\n        assert_eq!(decoder_reader.b64_offset, 0);\n        assert_eq!(decoder_reader.b64_len, 0);\n        assert_eq!(decoder_reader.decoded_offset, 0);\n        assert_eq!(decoder_reader.decoded_len, 0);\n        assert_eq!(decoder_reader.input_consumed_len, 0);\n        assert!(decoder_reader.padding_offset.is_none());\n    }\n}\n```", "read::decoder::DecoderReader::<'e, E, R>::read_from_delegate": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_read_from_delegate() {\n        let input = b\"YXNkZg==\"; // Base64 representation of \"asdf\"\n        let cursor = Cursor::new(input);\n        let engine = general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(cursor, &engine);\n        let mut buffer = [0u8; 8]; // Buffer to read decoded bytes\n\n        // The read_from_delegate method should read base64 data into b64_buffer\n        let bytes_read = decoder.read_from_delegate().unwrap();\n\n        // Ensure that the number of bytes read is as expected\n        assert!(bytes_read > 0);\n        assert_eq!(bytes_read, input.len());\n\n        // Now decode the data that was read\n        let decoded_bytes = decoder.decode_to_buf(bytes_read, &mut buffer).unwrap();\n        \n        // Check that the decoded bytes match expected result\n        assert_eq!(&buffer[..decoded_bytes], b\"asdf\");\n    }\n\n    #[test]\n    fn test_read_from_delegate_buffer_overflow() {\n        let input = b\"YXNkZg==\"; // Base64 representation of \"asdf\"\n        let cursor = Cursor::new(input);\n        let engine = general_purpose::STANDARD;\n        let mut decoder = DecoderReader::new(cursor, &engine);\n\n        // Fill the b64_buffer manually to trigger overflow assertions\n        decoder.b64_offset = BUF_SIZE - 1; // Assuming BUF_SIZE is the expected buffer size\n        decoder.b64_len = 1; // Pretend we have one byte in the buffer\n\n        let result = decoder.read_from_delegate();\n\n        // Check if the overflow condition is handled\n        assert!(result.is_err());\n    }\n}\n```", "write::encoder::EncoderWriter::<'e, E, W>::finish": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use crate::engine::general_purpose;\n\n    #[test]\n    fn test_finish_success() {\n        let input = b\"hello\";\n        let buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(buffer, &general_purpose::STANDARD);\n\n        encoder.write_all(input).unwrap();\n        let finished_writer = encoder.finish().unwrap();\n\n        let encoded = finished_writer;\n        assert_eq!(encoded, b\"aGVsbG8=\");\n    }\n\n    #[test]\n    fn test_finish_called_twice() {\n        let input = b\"hello\";\n        let buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(buffer, &general_purpose::STANDARD);\n\n        encoder.write_all(input).unwrap();\n        let _ = encoder.finish().unwrap();\n\n        let result = std::panic::catch_unwind(|| {\n            encoder.finish().unwrap();\n        });\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_finish_no_write_before_finish() {\n        let buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(buffer, &general_purpose::STANDARD);\n\n        let result = encoder.finish();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_finish_with_extra_input() {\n        let input = b\"he\";\n        let buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(buffer, &general_purpose::STANDARD);\n\n        encoder.write_all(input).unwrap();\n        let finished_writer = encoder.finish().unwrap();\n\n        let encoded = finished_writer;\n        assert_eq!(encoded, b\"aGU=\");\n    }\n\n    #[test]\n    fn test_finish_with_unbuffered_writer() {\n        let input = b\"test input\";\n        let cursor = Cursor::new(Vec::new());\n        let mut encoder = EncoderWriter::new(cursor, &general_purpose::STANDARD);\n\n        encoder.write_all(input).unwrap();\n        let finished_writer = encoder.finish().unwrap();\n\n        let encoded = finished_writer;\n        assert_eq!(encoded, b\"dGVzdCBpbnB1dA==\");\n    }\n}\n```", "write::encoder::EncoderWriter::<'e, E, W>::into_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*; // assuming EncoderWriter is in the same module\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_into_inner() {\n        let data = b\"test data\";\n        let mut buffer = Vec::new();\n        let mut encoder = EncoderWriter::new(Cursor::new(&mut buffer), &general_purpose::STANDARD);\n\n        // Write data to the encoder\n        encoder.write_all(data).unwrap();\n        \n        // Ensure that calling into_inner does not panic after finish\n        let inner_writer = encoder.finish().unwrap();\n        \n        // Obtain the inner buffer\n        let returned = encoder.into_inner(); // Should panic if we call this again after finish\n        \n        // Check that we can still use the inner writer\n        let result = String::from_utf8(returned.into_inner().into_inner().into_inner().into_inner().into_inner().to_vec().unwrap();\n        assert_eq!(result, \"dGVzdCBkYXRh\"); // Base64 encoded string\n    }\n\n    #[test]\n    #[should_panic(expected = \"Encoder has already had finish() called\")]\n    fn test_into_inner_panics_after_finish() {\n        let data = b\"test data\";\n        let buffer = Vec::new();\n        let encoder = EncoderWriter::new(Cursor::new(&mut buffer), &general_purpose::STANDARD);\n\n        // Write data to the encoder\n        encoder.write_all(data).unwrap();\n        \n        // Call finish to complete the write\n        let _ = encoder.finish().unwrap();\n        \n        // This call should panic\n        let _ = encoder.into_inner();\n    }\n}\n```", "write::encoder::EncoderWriter::<'e, E, W>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_encoder_writer_new() {\n        // Create a dummy writer (cursor over a vector).\n        let writer = Cursor::new(Vec::new());\n        // Create a new GeneralPurpose engine.\n        let engine = general_purpose::STANDARD;\n\n        // Create a new EncoderWriter.\n        let encoder = EncoderWriter::new(writer, &engine);\n\n        // Assert properties of the EncoderWriter.\n        assert!(encoder.delegate.is_some());\n        assert_eq!(encoder.extra_input_occupied_len, 0);\n        assert_eq!(encoder.output_occupied_len, 0);\n        assert!(!encoder.panicked);\n    }\n}\n```", "write::encoder::EncoderWriter::<'e, E, W>::write_all_encoded_output": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::{self, general_purpose};\n\n    #[test]\n    fn test_write_all_encoded_output_empty() {\n        let mut writer = Cursor::new(Vec::new());\n        let mut encoder = EncoderWriter::new(writer, &general_purpose::STANDARD);\n\n        let result = encoder.write_all_encoded_output();\n        assert!(result.is_ok());\n        assert_eq!(encoder.output_occupied_len, 0);\n    }\n\n    #[test]\n    fn test_write_all_encoded_output_partial() {\n        let mut writer = Cursor::new(Vec::new());\n        let mut encoder = EncoderWriter::new(writer, &general_purpose::STANDARD);\n\n        // Simulate adding to output\n        encoder.output_occupied_len = 4; // Pretend we have 4 bytes ready\n        encoder.output[..4].copy_from_slice(b\"abcd\"); // Sample output\n\n        let result = encoder.write_all_encoded_output();\n        assert!(result.is_ok());\n        assert_eq!(encoder.output_occupied_len, 0);\n    }\n\n    #[test]\n    fn test_write_all_encoded_output_interrupted() {\n        let mut writer = Cursor::new(Vec::new());\n        let mut encoder = EncoderWriter::new(writer, &general_purpose::STANDARD);\n\n        // Mock behavior of writer to return interrupted error\n        encoder.output_occupied_len = 4; // Pretend we have 4 bytes ready\n        encoder.output[..4].copy_from_slice(b\"abcd\"); // Sample output\n\n        // Simulate interrupted error\n        encoder.write_to_delegate = |_current_output_len| {\n            Err(std::io::Error::new(std::io::ErrorKind::Interrupted, \"interrupted\"))\n        };\n\n        let result = encoder.write_all_encoded_output();\n        assert!(result.is_ok());\n        assert_eq!(encoder.output_occupied_len, 4); // Should still have 4 bytes to write\n    }\n\n    #[test]\n    fn test_write_all_encoded_output_io_error() {\n        let mut writer = Cursor::new(Vec::new());\n        let mut encoder = EncoderWriter::new(writer, &general_purpose::STANDARD);\n\n        // Mock behavior of writer to return an actual IO error\n        encoder.output_occupied_len = 4; // Pretend we have 4 bytes ready\n        encoder.output[..4].copy_from_slice(b\"abcd\"); // Sample output\n\n        encoder.write_to_delegate = |_current_output_len| {\n            Err(std::io::Error::new(std::io::ErrorKind::Other, \"IO error\"))\n        };\n\n        let result = encoder.write_all_encoded_output();\n        assert!(result.is_err());\n        assert_eq!(encoder.output_occupied_len, 4); // Should still have 4 bytes to write\n    }\n}\n```", "write::encoder::EncoderWriter::<'e, E, W>::write_final_leftovers": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_write_final_leftovers_empty() {\n        let mut writer = EncoderWriter::new(Cursor::new(Vec::new()), &general_purpose::STANDARD);\n        writer.extra_input_occupied_len = 0;\n        let result = writer.write_final_leftovers();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_write_final_leftovers_with_extra_input() {\n        let mut writer = EncoderWriter::new(Cursor::new(Vec::new()), &general_purpose::STANDARD);\n        writer.extra_input_occupied_len = 2;\n        writer.extra_input[..2].copy_from_slice(&[0b01100001, 0b01100010]); // \"ab\"\n        writer.output_occupied_len = 0;\n\n        let result = writer.write_final_leftovers();\n        assert!(result.is_ok());\n        let output = writer.output[..writer.output_occupied_len].to_vec();\n        assert_eq!(output, b\"YWI=\"); // Check that \"ab\" is encoded correctly\n    }\n\n    #[test]\n    fn test_write_final_leftovers_with_non_empty_output() {\n        let mut writer = EncoderWriter::new(Cursor::new(Vec::new()), &general_purpose::STANDARD);\n        writer.output_occupied_len = 4;\n        writer.output[..4].copy_from_slice(b\"YWI=\"); // Pre-fill output with \"YWI=\"\n\n        let result = writer.write_final_leftovers();\n        assert!(result.is_ok());\n        // Output should still contain \"YWI=\" if encoded correctly\n        assert_eq!(writer.output[..4], b\"YWI=\");\n    }\n\n    #[test]\n    fn test_write_final_leftovers_with_no_delegate() {\n        let mut writer = EncoderWriter::new(Cursor::new(Vec::new()), &general_purpose::STANDARD);\n        writer.delegate = None; // Simulate finishing process\n        let result = writer.write_final_leftovers();\n        assert!(result.is_ok());\n    }\n}\n```", "write::encoder::EncoderWriter::<'e, E, W>::write_to_delegate": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::{Cursor, Write};\n\n    struct MockWriter {\n        buffer: Vec<u8>,\n        write_fail: bool,\n    }\n\n    impl MockWriter {\n        fn new() -> Self {\n            MockWriter {\n                buffer: Vec::new(),\n                write_fail: false,\n            }\n        }\n\n        fn set_write_fail(&mut self, fail: bool) {\n            self.write_fail = fail;\n        }\n\n        fn get_buffer(&self) -> Vec<u8> {\n            self.buffer.clone()\n        }\n    }\n\n    impl Write for MockWriter {\n        fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n            if self.write_fail {\n                Err(std::io::Error::new(std::io::ErrorKind::Other, \"Write failed\"))\n            } else {\n                self.buffer.extend_from_slice(buf);\n                Ok(buf.len())\n            }\n        }\n\n        fn flush(&mut self) -> std::io::Result<()> {\n            Ok(())\n        }\n    }\n\n    #[test]\n    fn test_write_to_delegate_success() {\n        let engine = general_purpose::STANDARD;\n        let mut mock_writer = MockWriter::new();\n        let mut encoder = EncoderWriter::new(&mut mock_writer, &engine);\n\n        encoder.output[..8].copy_from_slice(b\"testdata\");\n        encoder.output_occupied_len = 8;\n\n        let result = encoder.write_to_delegate(8);\n        assert!(result.is_ok());\n        assert_eq!(mock_writer.get_buffer(), b\"testdata\");\n        assert_eq!(encoder.output_occupied_len, 0);\n    }\n\n    #[test]\n    fn test_write_to_delegate_partial_write() {\n        let engine = general_purpose::STANDARD;\n        let mut mock_writer = MockWriter::new();\n        let mut encoder = EncoderWriter::new(&mut mock_writer, &engine);\n\n        encoder.output[..8].copy_from_slice(b\"testdata\");\n        encoder.output_occupied_len = 8;\n\n        mock_writer.set_write_fail(true);\n        let result = encoder.write_to_delegate(8);\n        assert!(result.is_err());\n        assert_eq!(encoder.output_occupied_len, 8);\n    }\n\n    #[test]\n    fn test_write_to_delegate_resize_buffer() {\n        let engine = general_purpose::STANDARD;\n        let mut mock_writer = MockWriter::new();\n        let mut encoder = EncoderWriter::new(&mut mock_writer, &engine);\n\n        encoder.output[..10].copy_from_slice(b\"longdataxx\");\n        encoder.output_occupied_len = 10;\n\n        let result = encoder.write_to_delegate(10);\n        assert!(result.is_ok());\n        assert_eq!(encoder.output_occupied_len, 0);\n    }\n\n    #[test]\n    fn test_write_to_delegate_consume_partial() {\n        let engine = general_purpose::STANDARD;\n        let mut mock_writer = MockWriter::new();\n        let mut encoder = EncoderWriter::new(&mut mock_writer, &engine);\n\n        encoder.output[..8].copy_from_slice(b\"testdata\");\n        encoder.output_occupied_len = 8;\n\n        // Mock writing of only 5 bytes\n        mock_writer.set_write_fail(false);\n        let result = encoder.write_to_delegate(8);\n        assert!(result.is_ok());\n        assert_eq!(encoder.output_occupied_len, 3); // 8 - 5 = 3 bytes left\n    }\n}\n```", "write::encoder_string_writer::EncoderStringWriter::<'e, E, S>::from_consumer": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::string::String;\n    use base64::engine::{self, general_purpose};\n    \n    #[test]\n    fn test_from_consumer() {\n        let mut output_string = String::new();\n        let engine = general_purpose::STANDARD;\n\n        // Create an EncoderStringWriter from a String consumer\n        let encoder = EncoderStringWriter::from_consumer(&mut output_string, &engine);\n\n        // Ensure the encoder is not empty (just a basic instantiation test)\n        assert!(encoder.encoder.delegate.is_some());\n\n        // Write some data\n        let data = b\"hello\";\n        encoder.write_all(data).unwrap();\n\n        // Finish and obtain the result\n        encoder.into_inner();\n\n        // Validate the output\n        assert_eq!(output_string, \"aGVsbG8=\"); // base64 of \"hello\"\n    }\n\n    #[test]\n    fn test_from_consumer_with_existing_string() {\n        let mut output_string = String::from(\"Base64 Encoded: \");\n        let engine = general_purpose::STANDARD;\n\n        // Create an EncoderStringWriter that will append to the existing string\n        let mut encoder = EncoderStringWriter::from_consumer(&mut output_string, &engine);\n        \n        // Write some data\n        let data = b\"world\";\n        encoder.write_all(data).unwrap();\n\n        // Finish and obtain the result\n        encoder.into_inner();\n\n        // Validate the output\n        assert_eq!(output_string, \"Base64 Encoded: d29ybGQ=\"); // base64 of \"world\"\n    }\n}\n```", "write::encoder_string_writer::EncoderStringWriter::<'e, E, S>::into_inner": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::{general_purpose, Engine};\n\n    #[test]\n    fn test_into_inner() {\n        let engine = &general_purpose::STANDARD;\n        let mut encoder = EncoderStringWriter::new(engine);\n        \n        encoder.write_all(b\"test\").unwrap();\n        let result = encoder.into_inner();\n\n        assert_eq!(result, \"dGVzdA==\");\n    }\n\n    #[test]\n    fn test_into_inner_with_existing_string() {\n        let engine = &general_purpose::STANDARD;\n        let mut output = String::from(\"Encoded: \");\n        let mut encoder = EncoderStringWriter::from_consumer(&mut output, engine);\n        \n        encoder.write_all(b\"hello\").unwrap();\n        let result = encoder.into_inner();\n\n        assert_eq!(result, \"Encoded: aGVsbG8=\");\n    }\n}\n```", "write::encoder_string_writer::EncoderStringWriter::<'e, E, std::string::String>::new": "```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use base64::engine::general_purpose;\n\n    #[test]\n    fn test_encoder_string_writer_new() {\n        let engine = general_purpose::STANDARD;\n        let writer = EncoderStringWriter::new(&engine);\n\n        // assert that the writer is created successfully\n        assert!(writer.encoder.delegate.is_some());\n        assert_eq!(writer.encoder.extra_input_occupied_len, 0);\n        assert_eq!(writer.encoder.output_occupied_len, 0);\n    }\n}\n```"}