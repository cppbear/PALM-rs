{"dependencies":{"<&Borrowed as distr::uniform::SampleBorrow<Borrowed>>::borrow":[],"<&D as distr::distribution::Distribution<T>>::sample":["<R as rng::Rng>::R","rng::Rng"],"<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::borrow":[],"<[T; N] as rng::Fill>::fill":["<R as rng::Rng>::R","rng::Rng"],"<[T] as seq::slice::IndexedRandom>::len":[],"<[T] as seq::slice::SliceRandom>::partial_shuffle":["<R as rng::Rng>::R","rng::Rng"],"<[T] as seq::slice::SliceRandom>::shuffle":["<R as rng::Rng>::R","rng::Rng"],"<[bool] as rng::Fill>::fill":["<R as rng::Rng>::R","rng::Rng"],"<[char] as rng::Fill>::fill":["<R as rng::Rng>::R","rng::Rng"],"<[f32] as rng::Fill>::fill":["<R as rng::Rng>::R","rng::Rng"],"<[f64] as rng::Fill>::fill":["<R as rng::Rng>::R","rng::Rng"],"<[u8] as rng::Fill>::fill":["<R as rng::Rng>::R","rng::Rng"],"<bool as distr::utils::BoolAsSIMD>::any":[],"<core::ops::Range<T> as distr::uniform::SampleRange<T>>::is_empty":["core::marker::Sized","core::ops::Range"],"<core::ops::Range<T> as distr::uniform::SampleRange<T>>::sample_single":["core::marker::Sized","core::ops::Range","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeInclusive<T> as distr::uniform::SampleRange<T>>::is_empty":["core::marker::Sized","core::ops::RangeInclusive"],"<core::ops::RangeInclusive<T> as distr::uniform::SampleRange<T>>::sample_single":["core::marker::Sized","core::ops::RangeInclusive","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeTo<u128> as distr::uniform::SampleRange<u128>>::is_empty":["core::marker::Sized","core::ops::RangeTo"],"<core::ops::RangeTo<u128> as distr::uniform::SampleRange<u128>>::sample_single":["core::marker::Sized","core::ops::RangeTo","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeTo<u16> as distr::uniform::SampleRange<u16>>::is_empty":["core::marker::Sized","core::ops::RangeTo"],"<core::ops::RangeTo<u16> as distr::uniform::SampleRange<u16>>::sample_single":["core::marker::Sized","core::ops::RangeTo","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeTo<u32> as distr::uniform::SampleRange<u32>>::is_empty":["core::marker::Sized","core::ops::RangeTo"],"<core::ops::RangeTo<u32> as distr::uniform::SampleRange<u32>>::sample_single":["core::marker::Sized","core::ops::RangeTo","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeTo<u64> as distr::uniform::SampleRange<u64>>::is_empty":["core::marker::Sized","core::ops::RangeTo"],"<core::ops::RangeTo<u64> as distr::uniform::SampleRange<u64>>::sample_single":["core::marker::Sized","core::ops::RangeTo","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeTo<u8> as distr::uniform::SampleRange<u8>>::is_empty":["core::marker::Sized","core::ops::RangeTo"],"<core::ops::RangeTo<u8> as distr::uniform::SampleRange<u8>>::sample_single":["core::marker::Sized","core::ops::RangeTo","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeTo<usize> as distr::uniform::SampleRange<usize>>::is_empty":["core::marker::Sized","core::ops::RangeTo"],"<core::ops::RangeTo<usize> as distr::uniform::SampleRange<usize>>::sample_single":["core::marker::Sized","core::ops::RangeTo","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeToInclusive<u128> as distr::uniform::SampleRange<u128>>::is_empty":["core::marker::Sized","core::ops::RangeToInclusive"],"<core::ops::RangeToInclusive<u128> as distr::uniform::SampleRange<u128>>::sample_single":["core::marker::Sized","core::ops::RangeToInclusive","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeToInclusive<u16> as distr::uniform::SampleRange<u16>>::is_empty":["core::marker::Sized","core::ops::RangeToInclusive"],"<core::ops::RangeToInclusive<u16> as distr::uniform::SampleRange<u16>>::sample_single":["core::marker::Sized","core::ops::RangeToInclusive","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeToInclusive<u32> as distr::uniform::SampleRange<u32>>::is_empty":["core::marker::Sized","core::ops::RangeToInclusive"],"<core::ops::RangeToInclusive<u32> as distr::uniform::SampleRange<u32>>::sample_single":["core::marker::Sized","core::ops::RangeToInclusive","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeToInclusive<u64> as distr::uniform::SampleRange<u64>>::is_empty":["core::marker::Sized","core::ops::RangeToInclusive"],"<core::ops::RangeToInclusive<u64> as distr::uniform::SampleRange<u64>>::sample_single":["core::marker::Sized","core::ops::RangeToInclusive","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeToInclusive<u8> as distr::uniform::SampleRange<u8>>::is_empty":["core::marker::Sized","core::ops::RangeToInclusive"],"<core::ops::RangeToInclusive<u8> as distr::uniform::SampleRange<u8>>::sample_single":["core::marker::Sized","core::ops::RangeToInclusive","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<core::ops::RangeToInclusive<usize> as distr::uniform::SampleRange<usize>>::is_empty":["core::marker::Sized","core::ops::RangeToInclusive"],"<core::ops::RangeToInclusive<usize> as distr::uniform::SampleRange<usize>>::sample_single":["core::marker::Sized","core::ops::RangeToInclusive","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"<distr::StandardUniform as core::clone::Clone>::clone":["distr::StandardUniform"],"<distr::StandardUniform as core::default::Default>::default":["distr::StandardUniform"],"<distr::StandardUniform as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::StandardUniform"],"<distr::bernoulli::Bernoulli as core::clone::Clone>::clone":["distr::bernoulli::Bernoulli"],"<distr::bernoulli::Bernoulli as core::cmp::PartialEq>::eq":["distr::bernoulli::Bernoulli"],"<distr::bernoulli::Bernoulli as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::bernoulli::Bernoulli"],"<distr::bernoulli::Bernoulli as distr::distribution::Distribution<bool>>::sample":["<R as rng::Rng>::R","distr::bernoulli::Bernoulli","rng::Rng"],"<distr::bernoulli::BernoulliError as core::clone::Clone>::clone":["distr::bernoulli::BernoulliError"],"<distr::bernoulli::BernoulliError as core::cmp::Eq>::assert_receiver_is_total_eq":["distr::bernoulli::BernoulliError"],"<distr::bernoulli::BernoulliError as core::cmp::PartialEq>::eq":["distr::bernoulli::BernoulliError"],"<distr::bernoulli::BernoulliError as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::bernoulli::BernoulliError"],"<distr::bernoulli::BernoulliError as core::fmt::Display>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::bernoulli::BernoulliError"],"<distr::distribution::Iter<D, R, T> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::PhantomData","core::marker::Sized","core::result::Result","distr::distribution::Iter"],"<distr::distribution::Iter<D, R, T> as core::iter::Iterator>::next":["core::marker::PhantomData","core::marker::Sized","core::option::Option","distr::distribution::Iter"],"<distr::distribution::Iter<D, R, T> as core::iter::Iterator>::size_hint":["core::marker::PhantomData","core::marker::Sized","core::option::Option","distr::distribution::Iter"],"<distr::distribution::Map<D, F, T, S> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::PhantomData","core::marker::Sized","core::result::Result","distr::distribution::Map"],"<distr::distribution::Map<D, F, T, S> as distr::distribution::Distribution<S>>::sample":["<R as rng::Rng>::R","core::marker::PhantomData","core::marker::Sized","distr::distribution::Map","rng::Rng"],"<distr::float::Open01 as core::clone::Clone>::clone":["distr::float::Open01"],"<distr::float::Open01 as core::default::Default>::default":["distr::float::Open01"],"<distr::float::Open01 as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::float::Open01"],"<distr::float::Open01 as distr::distribution::Distribution<f32>>::sample":["<R as rng::Rng>::R","distr::float::Open01","rng::Rng"],"<distr::float::Open01 as distr::distribution::Distribution<f64>>::sample":["<R as rng::Rng>::R","distr::float::Open01","rng::Rng"],"<distr::float::OpenClosed01 as core::clone::Clone>::clone":["distr::float::OpenClosed01"],"<distr::float::OpenClosed01 as core::default::Default>::default":["distr::float::OpenClosed01"],"<distr::float::OpenClosed01 as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::float::OpenClosed01"],"<distr::float::OpenClosed01 as distr::distribution::Distribution<f32>>::sample":["<R as rng::Rng>::R","distr::float::OpenClosed01","rng::Rng"],"<distr::float::OpenClosed01 as distr::distribution::Distribution<f64>>::sample":["<R as rng::Rng>::R","distr::float::OpenClosed01","rng::Rng"],"<distr::other::Alphabetic as core::clone::Clone>::clone":["distr::other::Alphabetic"],"<distr::other::Alphabetic as core::default::Default>::default":["distr::other::Alphabetic"],"<distr::other::Alphabetic as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::other::Alphabetic"],"<distr::other::Alphabetic as distr::distribution::Distribution<u8>>::sample":["<R as rng::Rng>::R","distr::other::Alphabetic","rng::Rng"],"<distr::other::Alphabetic as distr::distribution::SampleString>::append_string":["<R as rng::Rng>::R","alloc::string::String","distr::other::Alphabetic","rng::Rng"],"<distr::other::Alphanumeric as core::clone::Clone>::clone":["distr::other::Alphanumeric"],"<distr::other::Alphanumeric as core::default::Default>::default":["distr::other::Alphanumeric"],"<distr::other::Alphanumeric as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::other::Alphanumeric"],"<distr::other::Alphanumeric as distr::distribution::Distribution<u8>>::sample":["<R as rng::Rng>::R","distr::other::Alphanumeric","rng::Rng"],"<distr::other::Alphanumeric as distr::distribution::SampleString>::append_string":["<R as rng::Rng>::R","alloc::string::String","distr::other::Alphanumeric","rng::Rng"],"<distr::slice::Choose<'_, char> as distr::distribution::SampleString>::append_string":["<R as rng::Rng>::R","alloc::string::String","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::slice::Choose","distr::uniform::int::UniformUsize","rng::Rng"],"<distr::slice::Choose<'a, T> as core::clone::Clone>::clone":["core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::slice::Choose","distr::uniform::int::UniformUsize"],"<distr::slice::Choose<'a, T> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","core::result::Result","distr::slice::Choose","distr::uniform::int::UniformUsize"],"<distr::slice::Choose<'a, T> as distr::distribution::Distribution<&'a T>>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::slice::Choose","distr::uniform::int::UniformUsize","rng::Rng"],"<distr::slice::Empty as core::clone::Clone>::clone":["distr::slice::Empty"],"<distr::slice::Empty as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::slice::Empty"],"<distr::slice::Empty as core::fmt::Display>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::slice::Empty"],"<distr::uniform::Error as core::clone::Clone>::clone":["distr::uniform::Error"],"<distr::uniform::Error as core::cmp::Eq>::assert_receiver_is_total_eq":["distr::uniform::Error"],"<distr::uniform::Error as core::cmp::PartialEq>::eq":["distr::uniform::Error"],"<distr::uniform::Error as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::uniform::Error"],"<distr::uniform::Error as core::fmt::Display>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::uniform::Error"],"<distr::uniform::Uniform<X> as core::clone::Clone>::clone":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform"],"<distr::uniform::Uniform<X> as core::cmp::Eq>::assert_receiver_is_total_eq":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform"],"<distr::uniform::Uniform<X> as core::cmp::PartialEq>::eq":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform"],"<distr::uniform::Uniform<X> as core::convert::TryFrom<core::ops::Range<X>>>::try_from":["core::marker::Sized","core::ops::Range","core::result::Result"],"<distr::uniform::Uniform<X> as core::convert::TryFrom<core::ops::RangeInclusive<X>>>::try_from":["core::marker::Sized","core::ops::RangeInclusive","core::result::Result"],"<distr::uniform::Uniform<X> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform"],"<distr::uniform::Uniform<X> as distr::distribution::Distribution<X>>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","rng::Rng"],"<distr::uniform::float::UniformFloat<X> as core::clone::Clone>::clone":["core::marker::Sized","distr::uniform::float::UniformFloat"],"<distr::uniform::float::UniformFloat<X> as core::cmp::PartialEq>::eq":["core::marker::Sized","distr::uniform::float::UniformFloat"],"<distr::uniform::float::UniformFloat<X> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::uniform::float::UniformFloat"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::float::UniformFloat","rng::Rng"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::float::UniformFloat","rng::Rng"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<X> as core::clone::Clone>::clone":["core::marker::Sized","distr::uniform::int::UniformInt"],"<distr::uniform::int::UniformInt<X> as core::cmp::Eq>::assert_receiver_is_total_eq":["core::marker::Sized","distr::uniform::int::UniformInt"],"<distr::uniform::int::UniformInt<X> as core::cmp::PartialEq>::eq":["core::marker::Sized","distr::uniform::int::UniformInt"],"<distr::uniform::int::UniformInt<X> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::uniform::int::UniformInt"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","rng::Rng"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","rng::Rng"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","rng::Rng"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","rng::Rng"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","rng::Rng"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","rng::Rng"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","rng::Rng"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","rng::Rng"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","rng::Rng"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","rng::Rng"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformUsize as core::clone::Clone>::clone":["distr::uniform::int::UniformUsize"],"<distr::uniform::int::UniformUsize as core::cmp::Eq>::assert_receiver_is_total_eq":["distr::uniform::int::UniformUsize"],"<distr::uniform::int::UniformUsize as core::cmp::PartialEq>::eq":["distr::uniform::int::UniformUsize"],"<distr::uniform::int::UniformUsize as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::uniform::int::UniformUsize"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","distr::uniform::int::UniformUsize","rng::Rng"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"<distr::uniform::other::UniformChar as core::clone::Clone>::clone":["core::marker::Sized","distr::uniform::int::UniformInt","distr::uniform::other::UniformChar"],"<distr::uniform::other::UniformChar as core::cmp::Eq>::assert_receiver_is_total_eq":["core::marker::Sized","distr::uniform::int::UniformInt","distr::uniform::other::UniformChar"],"<distr::uniform::other::UniformChar as core::cmp::PartialEq>::eq":["core::marker::Sized","distr::uniform::int::UniformInt","distr::uniform::other::UniformChar"],"<distr::uniform::other::UniformChar as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::uniform::int::UniformInt","distr::uniform::other::UniformChar"],"<distr::uniform::other::UniformChar as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::other::UniformChar as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::other::UniformChar as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","distr::uniform::int::UniformInt","distr::uniform::other::UniformChar","rng::Rng"],"<distr::uniform::other::UniformDuration as core::clone::Clone>::clone":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode"],"<distr::uniform::other::UniformDuration as core::cmp::Eq>::assert_receiver_is_total_eq":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode"],"<distr::uniform::other::UniformDuration as core::cmp::PartialEq>::eq":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode"],"<distr::uniform::other::UniformDuration as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode"],"<distr::uniform::other::UniformDuration as distr::uniform::UniformSampler>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::other::UniformDuration as distr::uniform::UniformSampler>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"<distr::uniform::other::UniformDuration as distr::uniform::UniformSampler>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode","rng::Rng"],"<distr::uniform::other::UniformDurationMode as core::clone::Clone>::clone":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDurationMode"],"<distr::uniform::other::UniformDurationMode as core::cmp::Eq>::assert_receiver_is_total_eq":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDurationMode"],"<distr::uniform::other::UniformDurationMode as core::cmp::PartialEq>::eq":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDurationMode"],"<distr::uniform::other::UniformDurationMode as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDurationMode"],"<distr::weighted::Error as core::clone::Clone>::clone":["distr::weighted::Error"],"<distr::weighted::Error as core::cmp::Eq>::assert_receiver_is_total_eq":["distr::weighted::Error"],"<distr::weighted::Error as core::cmp::PartialEq>::eq":["distr::weighted::Error"],"<distr::weighted::Error as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::weighted::Error"],"<distr::weighted::Error as core::fmt::Display>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","distr::weighted::Error"],"<distr::weighted::weighted_index::WeightedIndex<X> as core::clone::Clone>::clone":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","seq::index_::sample_efraimidis_spirakis::Element"],"<distr::weighted::weighted_index::WeightedIndex<X> as core::cmp::PartialEq>::eq":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","seq::index_::sample_efraimidis_spirakis::Element"],"<distr::weighted::weighted_index::WeightedIndex<X> as core::fmt::Debug>::fmt":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::fmt::Formatter","core::marker::Sized","core::result::Result","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","seq::index_::sample_efraimidis_spirakis::Element"],"<distr::weighted::weighted_index::WeightedIndex<X> as distr::distribution::Distribution<usize>>::sample":["<R as rng::Rng>::R","alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","rng::Rng","seq::index_::sample_efraimidis_spirakis::Element"],"<distr::weighted::weighted_index::WeightedIndexIter<'_, X> as core::clone::Clone>::clone":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","distr::weighted::weighted_index::WeightedIndexIter","seq::index_::sample_efraimidis_spirakis::Element"],"<distr::weighted::weighted_index::WeightedIndexIter<'_, X> as core::fmt::Debug>::fmt":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::fmt::Formatter","core::marker::Sized","core::result::Result","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","distr::weighted::weighted_index::WeightedIndexIter","seq::index_::sample_efraimidis_spirakis::Element"],"<distr::weighted::weighted_index::WeightedIndexIter<'_, X> as core::iter::Iterator>::next":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::marker::Sized","core::option::Option","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","distr::weighted::weighted_index::WeightedIndexIter","seq::index_::sample_efraimidis_spirakis::Element"],"<f32 as distr::utils::FloatSIMDUtils>::all_finite":[],"<f32 as distr::utils::FloatSIMDUtils>::all_le":[],"<f32 as distr::utils::FloatSIMDUtils>::all_lt":[],"<f32 as distr::utils::FloatSIMDUtils>::cast_from_int":[],"<f32 as distr::utils::FloatSIMDUtils>::decrease_masked":[],"<f32 as distr::utils::FloatSIMDUtils>::gt_mask":[],"<f32 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<f64 as distr::utils::FloatSIMDUtils>::all_finite":[],"<f64 as distr::utils::FloatSIMDUtils>::all_le":[],"<f64 as distr::utils::FloatSIMDUtils>::all_lt":[],"<f64 as distr::utils::FloatSIMDUtils>::cast_from_int":[],"<f64 as distr::utils::FloatSIMDUtils>::decrease_masked":[],"<f64 as distr::utils::FloatSIMDUtils>::gt_mask":[],"<f64 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<i128 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<i16 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<i32 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<i64 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<i8 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<isize as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<rngs::mock::StepRng as core::clone::Clone>::clone":["rngs::mock::StepRng"],"<rngs::mock::StepRng as core::cmp::Eq>::assert_receiver_is_total_eq":["rngs::mock::StepRng"],"<rngs::mock::StepRng as core::cmp::PartialEq>::eq":["rngs::mock::StepRng"],"<rngs::mock::StepRng as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","rngs::mock::StepRng"],"<rngs::mock::StepRng as rand_core::RngCore>::fill_bytes":["rngs::mock::StepRng"],"<rngs::mock::StepRng as rand_core::RngCore>::next_u32":["rngs::mock::StepRng"],"<rngs::mock::StepRng as rand_core::RngCore>::next_u64":["rngs::mock::StepRng"],"<rngs::reseeding::ReseedingCore<R, Rsdr> as core::clone::Clone>::clone":["core::marker::Sized","rngs::reseeding::ReseedingCore"],"<rngs::reseeding::ReseedingCore<R, Rsdr> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","rngs::reseeding::ReseedingCore"],"<rngs::reseeding::ReseedingCore<R, Rsdr> as rand_core::block::BlockRngCore>::generate":["core::marker::Sized","rngs::reseeding::ReseedingCore"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as core::clone::Clone>::clone":["core::marker::Sized","rand_core::SeedableRng","rand_core::TryRngCore","rand_core::block::BlockRng","rand_core::block::BlockRngCore","rngs::reseeding::ReseedingCore","rngs::reseeding::ReseedingRng","rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","rand_core::SeedableRng","rand_core::TryRngCore","rand_core::block::BlockRng","rand_core::block::BlockRngCore","rngs::reseeding::ReseedingCore","rngs::reseeding::ReseedingRng","rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as rand_core::RngCore>::fill_bytes":["core::marker::Sized","rand_core::SeedableRng","rand_core::TryRngCore","rand_core::block::BlockRng","rand_core::block::BlockRngCore","rngs::reseeding::ReseedingCore","rngs::reseeding::ReseedingRng","rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as rand_core::RngCore>::next_u32":["core::marker::Sized","rand_core::SeedableRng","rand_core::TryRngCore","rand_core::block::BlockRng","rand_core::block::BlockRngCore","rngs::reseeding::ReseedingCore","rngs::reseeding::ReseedingRng","rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as rand_core::RngCore>::next_u64":["core::marker::Sized","rand_core::SeedableRng","rand_core::TryRngCore","rand_core::block::BlockRng","rand_core::block::BlockRngCore","rngs::reseeding::ReseedingCore","rngs::reseeding::ReseedingRng","rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::small::SmallRng as core::clone::Clone>::clone":["rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::small::SmallRng as core::cmp::Eq>::assert_receiver_is_total_eq":["rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::small::SmallRng as core::cmp::PartialEq>::eq":["rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::small::SmallRng as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::small::SmallRng as rand_core::RngCore>::fill_bytes":["rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::small::SmallRng as rand_core::RngCore>::next_u32":["rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::small::SmallRng as rand_core::RngCore>::next_u64":["rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::small::SmallRng as rand_core::SeedableRng>::from_seed":["rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::small::SmallRng as rand_core::SeedableRng>::seed_from_u64":["rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::std::StdRng as core::clone::Clone>::clone":["rand_chacha::ChaCha12Rng","rngs::std::StdRng"],"<rngs::std::StdRng as core::cmp::Eq>::assert_receiver_is_total_eq":["rand_chacha::ChaCha12Rng","rngs::std::StdRng"],"<rngs::std::StdRng as core::cmp::PartialEq>::eq":["rand_chacha::ChaCha12Rng","rngs::std::StdRng"],"<rngs::std::StdRng as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","rand_chacha::ChaCha12Rng","rngs::std::StdRng"],"<rngs::std::StdRng as rand_core::RngCore>::fill_bytes":["rand_chacha::ChaCha12Rng","rngs::std::StdRng"],"<rngs::std::StdRng as rand_core::RngCore>::next_u32":["rand_chacha::ChaCha12Rng","rngs::std::StdRng"],"<rngs::std::StdRng as rand_core::RngCore>::next_u64":["rand_chacha::ChaCha12Rng","rngs::std::StdRng"],"<rngs::std::StdRng as rand_core::SeedableRng>::from_seed":["rand_chacha::ChaCha12Rng","rngs::std::StdRng"],"<rngs::thread::ThreadRng as core::clone::Clone>::clone":["alloc::rc::Rc","core::alloc::Allocator","core::marker::Sized","rngs::thread::ThreadRng"],"<rngs::thread::ThreadRng as core::default::Default>::default":["alloc::rc::Rc","core::alloc::Allocator","core::marker::Sized","rngs::thread::ThreadRng"],"<rngs::thread::ThreadRng as core::fmt::Debug>::fmt":["alloc::rc::Rc","core::alloc::Allocator","core::fmt::Formatter","core::marker::Sized","core::result::Result","rngs::thread::ThreadRng"],"<rngs::thread::ThreadRng as rand_core::RngCore>::fill_bytes":["alloc::rc::Rc","core::alloc::Allocator","core::marker::Sized","rngs::thread::ThreadRng"],"<rngs::thread::ThreadRng as rand_core::RngCore>::next_u32":["alloc::rc::Rc","core::alloc::Allocator","core::marker::Sized","rngs::thread::ThreadRng"],"<rngs::thread::ThreadRng as rand_core::RngCore>::next_u64":["alloc::rc::Rc","core::alloc::Allocator","core::marker::Sized","rngs::thread::ThreadRng"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as core::clone::Clone>::clone":["rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as core::cmp::Eq>::assert_receiver_is_total_eq":["rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as core::cmp::PartialEq>::eq":["rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::fill_bytes":["rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::next_u32":["rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::next_u64":["rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::SeedableRng>::from_seed":["rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::SeedableRng>::seed_from_u64":["rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"<seq::index_::IndexVec as core::clone::Clone>::clone":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVec"],"<seq::index_::IndexVec as core::cmp::PartialEq>::eq":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVec"],"<seq::index_::IndexVec as core::convert::From<alloc::vec::Vec<u32>>>::from":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVec"],"<seq::index_::IndexVec as core::convert::From<alloc::vec::Vec<u64>>>::from":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVec"],"<seq::index_::IndexVec as core::fmt::Debug>::fmt":["alloc::vec::Vec","core::alloc::Allocator","core::fmt::Formatter","core::marker::Sized","core::result::Result","seq::index_::IndexVec"],"<seq::index_::IndexVec as core::iter::IntoIterator>::into_iter":["alloc::vec::IntoIter","alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVec","seq::index_::IndexVecIntoIter"],"<seq::index_::IndexVecIntoIter as core::clone::Clone>::clone":["alloc::vec::IntoIter","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVecIntoIter"],"<seq::index_::IndexVecIntoIter as core::fmt::Debug>::fmt":["alloc::vec::IntoIter","core::alloc::Allocator","core::fmt::Formatter","core::marker::Sized","core::result::Result","seq::index_::IndexVecIntoIter"],"<seq::index_::IndexVecIntoIter as core::iter::Iterator>::next":["alloc::vec::IntoIter","core::alloc::Allocator","core::marker::Sized","core::option::Option","seq::index_::IndexVecIntoIter"],"<seq::index_::IndexVecIntoIter as core::iter::Iterator>::size_hint":["alloc::vec::IntoIter","core::alloc::Allocator","core::marker::Sized","core::option::Option","seq::index_::IndexVecIntoIter"],"<seq::index_::IndexVecIter<'_> as core::iter::Iterator>::next":["core::marker::Sized","core::option::Option","core::slice::Iter","seq::index_::IndexVecIter"],"<seq::index_::IndexVecIter<'_> as core::iter::Iterator>::size_hint":["core::marker::Sized","core::option::Option","core::slice::Iter","seq::index_::IndexVecIter"],"<seq::index_::IndexVecIter<'a> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","core::slice::Iter","seq::index_::IndexVecIter"],"<seq::index_::sample_efraimidis_spirakis::Element<N> as core::cmp::Ord>::cmp":["core::cmp::Ordering","core::marker::Sized","seq::index_::sample_efraimidis_spirakis::Element"],"<seq::index_::sample_efraimidis_spirakis::Element<N> as core::cmp::PartialEq>::eq":["core::marker::Sized","seq::index_::sample_efraimidis_spirakis::Element"],"<seq::index_::sample_efraimidis_spirakis::Element<N> as core::cmp::PartialOrd>::partial_cmp":["core::marker::Sized","core::option::Option","seq::index_::sample_efraimidis_spirakis::Element"],"<seq::slice::SliceChooseIter<'a, S, T> as core::fmt::Debug>::fmt":["alloc::vec::IntoIter","core::alloc::Allocator","core::fmt::Formatter","core::marker::PhantomData","core::marker::Sized","core::result::Result","seq::index_::IndexVecIntoIter","seq::slice::SliceChooseIter"],"<seq::slice::SliceChooseIter<'a, S, T> as core::iter::ExactSizeIterator>::len":["alloc::vec::IntoIter","core::alloc::Allocator","core::marker::PhantomData","core::marker::Sized","seq::index_::IndexVecIntoIter","seq::slice::SliceChooseIter"],"<seq::slice::SliceChooseIter<'a, S, T> as core::iter::Iterator>::next":["alloc::vec::IntoIter","core::alloc::Allocator","core::marker::PhantomData","core::marker::Sized","core::option::Option","seq::index_::IndexVecIntoIter","seq::slice::SliceChooseIter"],"<seq::slice::SliceChooseIter<'a, S, T> as core::iter::Iterator>::size_hint":["alloc::vec::IntoIter","core::alloc::Allocator","core::marker::PhantomData","core::marker::Sized","core::option::Option","seq::index_::IndexVecIntoIter","seq::slice::SliceChooseIter"],"<u128 as distr::utils::WideningMultiply>::wmul":[],"<u128 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<u16 as distr::utils::WideningMultiply>::wmul":[],"<u16 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<u32 as distr::float::IntoFloat>::into_float_with_exponent":[],"<u32 as distr::utils::WideningMultiply>::wmul":[],"<u32 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<u32 as seq::index_::UInt>::as_usize":[],"<u32 as seq::index_::UInt>::one":[],"<u32 as seq::index_::UInt>::zero":[],"<u64 as distr::float::IntoFloat>::into_float_with_exponent":[],"<u64 as distr::utils::WideningMultiply>::wmul":[],"<u64 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<u64 as seq::index_::UInt>::as_usize":[],"<u64 as seq::index_::UInt>::one":[],"<u64 as seq::index_::UInt>::zero":[],"<u8 as distr::utils::WideningMultiply>::wmul":[],"<u8 as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"<usize as distr::utils::WideningMultiply>::wmul":[],"<usize as distr::weighted::Weight>::checked_add_assign":["core::marker::Sized","core::result::Result"],"distr::StandardUniform":["distr::StandardUniform"],"distr::bernoulli::Bernoulli":["distr::bernoulli::Bernoulli"],"distr::bernoulli::Bernoulli::from_ratio":["core::marker::Sized","core::result::Result"],"distr::bernoulli::Bernoulli::new":["core::marker::Sized","core::result::Result"],"distr::bernoulli::Bernoulli::p":["distr::bernoulli::Bernoulli"],"distr::bernoulli::BernoulliError":["distr::bernoulli::BernoulliError"],"distr::distribution::Distribution::map":["core::marker::PhantomData","core::marker::Sized","core::ops::Fn","distr::distribution::Map"],"distr::distribution::Distribution::sample":["<R as rng::Rng>::R","rng::Rng"],"distr::distribution::Distribution::sample_iter":["<R as rng::Rng>::R","core::marker::PhantomData","core::marker::Sized","distr::distribution::Iter","rng::Rng"],"distr::distribution::Iter":["core::marker::PhantomData","core::marker::Sized","distr::distribution::Iter"],"distr::distribution::Map":["core::marker::PhantomData","core::marker::Sized","distr::distribution::Map"],"distr::distribution::SampleString::append_string":["<R as rng::Rng>::R","alloc::string::String","rng::Rng"],"distr::distribution::SampleString::sample_string":["<R as rng::Rng>::R","alloc::string::String","rng::Rng"],"distr::float::<impl distr::distribution::Distribution<f32> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::float::<impl distr::distribution::Distribution<f64> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::float::IntoFloat::into_float_with_exponent":[],"distr::float::Open01":["distr::float::Open01"],"distr::float::OpenClosed01":["distr::float::OpenClosed01"],"distr::integer::<impl distr::distribution::Distribution<core::arch::x86_64::__m128i> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::arch::x86_64::__m128i","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::arch::x86_64::__m256i> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::arch::x86_64::__m256i","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i128>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i16>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i32>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i64>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i8>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u128>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u16>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u32>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u64>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u8>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<i128> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<i16> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<i32> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<i64> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<i8> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<u128> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<u16> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<u32> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<u64> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::integer::<impl distr::distribution::Distribution<u8> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<()> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B, C)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I, J)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I, J, K)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I, J, K, L)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<(A,)> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<[T; N]> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<bool> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<char> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::Distribution<core::num::Wrapping<T>> for distr::StandardUniform>::sample":["<R as rng::Rng>::R","core::marker::Sized","core::num::Wrapping","distr::StandardUniform","rng::Rng"],"distr::other::<impl distr::distribution::SampleString for distr::StandardUniform>::append_string":["<R as rng::Rng>::R","alloc::string::String","distr::StandardUniform","rng::Rng"],"distr::other::Alphabetic":["distr::other::Alphabetic"],"distr::other::Alphanumeric":["distr::other::Alphanumeric"],"distr::slice::Choose":["core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::slice::Choose","distr::uniform::int::UniformUsize"],"distr::slice::Choose::<'a, T>::new":["core::marker::Sized","core::result::Result"],"distr::slice::Choose::<'a, T>::num_choices":["core::marker::Sized","core::num::NonZero","core::num::ZeroablePrimitive","distr::slice::Choose","distr::uniform::int::UniformUsize"],"distr::slice::Empty":["distr::slice::Empty"],"distr::uniform::Error":["distr::uniform::Error"],"distr::uniform::SampleBorrow::borrow":[],"distr::uniform::SampleRange::is_empty":[],"distr::uniform::SampleRange::sample_single":["core::marker::Sized","core::result::Result","rand_core::RngCore","rngs::mock::StepRng"],"distr::uniform::Uniform":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform"],"distr::uniform::Uniform::<X>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"distr::uniform::Uniform::<X>::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"distr::uniform::UniformSampler::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"distr::uniform::UniformSampler::new_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow"],"distr::uniform::UniformSampler::sample":["<R as rng::Rng>::R","rng::Rng"],"distr::uniform::UniformSampler::sample_single":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"distr::uniform::UniformSampler::sample_single_inclusive":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","rng::Rng"],"distr::uniform::float::UniformFloat":["core::marker::Sized","distr::uniform::float::UniformFloat"],"distr::uniform::float::UniformFloat::<f32>::new_bounded":["core::marker::Sized","distr::uniform::float::UniformFloat"],"distr::uniform::float::UniformFloat::<f64>::new_bounded":["core::marker::Sized","distr::uniform::float::UniformFloat"],"distr::uniform::int::UniformInt":["core::marker::Sized","distr::uniform::int::UniformInt"],"distr::uniform::int::UniformUsize":["distr::uniform::int::UniformUsize"],"distr::uniform::other::<impl distr::distribution::SampleString for distr::uniform::Uniform<char>>::append_string":["<R as rng::Rng>::R","alloc::string::String","core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","rng::Rng"],"distr::uniform::other::UniformChar":["core::marker::Sized","distr::uniform::int::UniformInt","distr::uniform::other::UniformChar"],"distr::uniform::other::UniformDuration":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode"],"distr::uniform::other::UniformDurationMode":["core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::uniform::Uniform","distr::uniform::other::UniformDurationMode"],"distr::uniform::other::char_to_comp_u32":[],"distr::utils::BoolAsSIMD::any":[],"distr::utils::FloatAsSIMD::splat":[],"distr::utils::FloatSIMDUtils::all_finite":[],"distr::utils::FloatSIMDUtils::all_le":[],"distr::utils::FloatSIMDUtils::all_lt":[],"distr::utils::FloatSIMDUtils::cast_from_int":[],"distr::utils::FloatSIMDUtils::decrease_masked":[],"distr::utils::FloatSIMDUtils::gt_mask":[],"distr::utils::IntAsSIMD::splat":[],"distr::utils::WideningMultiply::wmul":[],"distr::weighted::Error":["distr::weighted::Error"],"distr::weighted::Weight::checked_add_assign":["core::marker::Sized","core::result::Result"],"distr::weighted::weighted_index::WeightedIndex":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","seq::index_::sample_efraimidis_spirakis::Element"],"distr::weighted::weighted_index::WeightedIndex::<X>::new":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","alloc::vec::Vec","core::alloc::Allocator","core::iter::IntoIterator","core::marker::Sized","core::result::Result","distr::uniform::SampleBorrow","distr::weighted::Weight","seq::index_::IndexVec"],"distr::weighted::weighted_index::WeightedIndex::<X>::total_weight":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","seq::index_::sample_efraimidis_spirakis::Element"],"distr::weighted::weighted_index::WeightedIndex::<X>::update_weights":["alloc::vec::Vec","core::alloc::Allocator","core::clone::Clone","core::cmp::PartialOrd","core::default::Default","core::marker::Sized","core::ops::AddAssign","core::ops::SubAssign","core::result::Result","core::time::Duration","distr::StandardUniform","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","seq::index_::sample_efraimidis_spirakis::Element"],"distr::weighted::weighted_index::WeightedIndex::<X>::weight":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::marker::Sized","core::ops::SubAssign","core::option::Option","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","seq::index_::sample_efraimidis_spirakis::Element"],"distr::weighted::weighted_index::WeightedIndex::<X>::weights":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::marker::Sized","core::ops::SubAssign","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","distr::weighted::weighted_index::WeightedIndexIter","seq::index_::sample_efraimidis_spirakis::Element"],"distr::weighted::weighted_index::WeightedIndexIter":["alloc::vec::Vec","core::alloc::Allocator","core::cmp::PartialOrd","core::marker::Sized","core::time::Duration","distr::uniform::SampleUniform","distr::weighted::weighted_index::WeightedIndex","distr::weighted::weighted_index::WeightedIndexIter","seq::index_::sample_efraimidis_spirakis::Element"],"fill":["rng::Fill"],"random":["core::marker::Sized","distr::StandardUniform","distr::distribution::Distribution"],"random_bool":[],"random_iter":["core::marker::PhantomData","core::marker::Sized","distr::StandardUniform","distr::distribution::Distribution","distr::distribution::Iter"],"random_range":["core::marker::Sized","core::ops::Range","core::time::Duration","distr::uniform::SampleRange","distr::uniform::SampleUniform"],"random_ratio":[],"rng::Fill::fill":["<R as rng::Rng>::R","rng::Rng"],"rng::Rng::fill":["rng::Fill"],"rng::Rng::gen":["core::marker::Sized","distr::StandardUniform","distr::distribution::Distribution"],"rng::Rng::gen_bool":[],"rng::Rng::gen_range":["core::marker::Sized","core::ops::Range","core::time::Duration","distr::uniform::SampleRange","distr::uniform::SampleUniform"],"rng::Rng::gen_ratio":[],"rng::Rng::random":["core::marker::Sized","distr::StandardUniform","distr::distribution::Distribution"],"rng::Rng::random_bool":[],"rng::Rng::random_iter":["core::marker::PhantomData","core::marker::Sized","distr::StandardUniform","distr::distribution::Distribution","distr::distribution::Iter"],"rng::Rng::random_range":["core::marker::Sized","core::ops::Range","core::time::Duration","distr::uniform::SampleRange","distr::uniform::SampleUniform"],"rng::Rng::random_ratio":[],"rng::Rng::sample":["core::marker::Sized","distr::StandardUniform","distr::distribution::Distribution"],"rng::Rng::sample_iter":["core::marker::PhantomData","core::marker::Sized","distr::StandardUniform","distr::distribution::Distribution","distr::distribution::Iter"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i128>]>::fill":["<R as rng::Rng>::R","core::marker::Sized","core::num::Wrapping","rng::Rng"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i16>]>::fill":["<R as rng::Rng>::R","core::marker::Sized","core::num::Wrapping","rng::Rng"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i32>]>::fill":["<R as rng::Rng>::R","core::marker::Sized","core::num::Wrapping","rng::Rng"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i64>]>::fill":["<R as rng::Rng>::R","core::marker::Sized","core::num::Wrapping","rng::Rng"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i8>]>::fill":["<R as rng::Rng>::R","core::marker::Sized","core::num::Wrapping","rng::Rng"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u128>]>::fill":["<R as rng::Rng>::R","core::marker::Sized","core::num::Wrapping","rng::Rng"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u16>]>::fill":["<R as rng::Rng>::R","core::marker::Sized","core::num::Wrapping","rng::Rng"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u32>]>::fill":["<R as rng::Rng>::R","core::marker::Sized","core::num::Wrapping","rng::Rng"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u64>]>::fill":["<R as rng::Rng>::R","core::marker::Sized","core::num::Wrapping","rng::Rng"],"rng::_::<impl rng::Fill for [i128]>::fill":["<R as rng::Rng>::R","rng::Rng"],"rng::_::<impl rng::Fill for [i16]>::fill":["<R as rng::Rng>::R","rng::Rng"],"rng::_::<impl rng::Fill for [i32]>::fill":["<R as rng::Rng>::R","rng::Rng"],"rng::_::<impl rng::Fill for [i64]>::fill":["<R as rng::Rng>::R","rng::Rng"],"rng::_::<impl rng::Fill for [i8]>::fill":["<R as rng::Rng>::R","rng::Rng"],"rng::_::<impl rng::Fill for [u128]>::fill":["<R as rng::Rng>::R","rng::Rng"],"rng::_::<impl rng::Fill for [u16]>::fill":["<R as rng::Rng>::R","rng::Rng"],"rng::_::<impl rng::Fill for [u32]>::fill":["<R as rng::Rng>::R","rng::Rng"],"rng::_::<impl rng::Fill for [u64]>::fill":["<R as rng::Rng>::R","rng::Rng"],"rng::__unsafe":[],"rngs::mock::StepRng":["rngs::mock::StepRng"],"rngs::mock::StepRng::new":["rngs::mock::StepRng"],"rngs::reseeding::ReseedingCore":["core::marker::Sized","rngs::reseeding::ReseedingCore"],"rngs::reseeding::ReseedingCore::<R, Rsdr>::new":["core::marker::Sized","core::result::Result"],"rngs::reseeding::ReseedingCore::<R, Rsdr>::reseed":["core::marker::Sized","core::result::Result","rngs::reseeding::ReseedingCore"],"rngs::reseeding::ReseedingCore::<R, Rsdr>::reseed_and_generate":["core::marker::Sized","rngs::reseeding::ReseedingCore"],"rngs::reseeding::ReseedingRng":["core::marker::Sized","rand_core::SeedableRng","rand_core::TryRngCore","rand_core::block::BlockRng","rand_core::block::BlockRngCore","rngs::reseeding::ReseedingCore","rngs::reseeding::ReseedingRng","rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"rngs::reseeding::ReseedingRng::<R, Rsdr>::new":["core::marker::Sized","core::result::Result"],"rngs::reseeding::ReseedingRng::<R, Rsdr>::reseed":["core::marker::Sized","core::result::Result","rand_core::SeedableRng","rand_core::TryRngCore","rand_core::block::BlockRng","rand_core::block::BlockRngCore","rngs::reseeding::ReseedingCore","rngs::reseeding::ReseedingRng","rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"rngs::small::SmallRng":["rngs::small::SmallRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"rngs::std::StdRng":["rand_chacha::ChaCha12Rng","rngs::std::StdRng"],"rngs::thread::THREAD_RNG_KEY::__init":["alloc::rc::Rc","core::alloc::Allocator","core::marker::Sized"],"rngs::thread::ThreadRng":["alloc::rc::Rc","core::alloc::Allocator","core::marker::Sized","rngs::thread::ThreadRng"],"rngs::thread::ThreadRng::reseed":["alloc::rc::Rc","core::alloc::Allocator","core::marker::Sized","core::result::Result","rngs::thread::ThreadRng"],"rngs::thread::rng":["alloc::rc::Rc","core::alloc::Allocator","core::marker::Sized","rngs::thread::ThreadRng"],"rngs::xoshiro256plusplus::Xoshiro256PlusPlus":["rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"seq::coin_flipper::CoinFlipper":["core::marker::Sized","rand_core::RngCore","rngs::mock::StepRng","seq::coin_flipper::CoinFlipper"],"seq::coin_flipper::CoinFlipper::<R>::flip_c_heads":["core::marker::Sized","rand_core::RngCore","rngs::mock::StepRng","seq::coin_flipper::CoinFlipper"],"seq::coin_flipper::CoinFlipper::<R>::new":["core::marker::Sized","rand_core::RngCore","rngs::mock::StepRng","seq::coin_flipper::CoinFlipper"],"seq::coin_flipper::CoinFlipper::<R>::random_ratio":["core::marker::Sized","rand_core::RngCore","rngs::mock::StepRng","seq::coin_flipper::CoinFlipper"],"seq::coin_flipper::CoinFlipper::<R>::random_ratio_one_over":["core::marker::Sized","rand_core::RngCore","rngs::mock::StepRng","seq::coin_flipper::CoinFlipper"],"seq::increasing_uniform::IncreasingUniform":["core::marker::Sized","rand_core::RngCore","rngs::mock::StepRng","seq::increasing_uniform::IncreasingUniform"],"seq::increasing_uniform::IncreasingUniform::<R>::new":["core::marker::Sized","rand_core::RngCore","rngs::mock::StepRng","seq::increasing_uniform::IncreasingUniform"],"seq::increasing_uniform::IncreasingUniform::<R>::next_index":["core::marker::Sized","rand_core::RngCore","rngs::mock::StepRng","seq::increasing_uniform::IncreasingUniform"],"seq::increasing_uniform::calculate_bound_u32":[],"seq::increasing_uniform::calculate_bound_u32::inner":[],"seq::index::sample_array":["<R as rng::Rng>::R","core::marker::Sized","core::option::Option","rng::Rng"],"seq::index_::IndexVec":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVec"],"seq::index_::IndexVec::index":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVec"],"seq::index_::IndexVec::into_vec":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVec"],"seq::index_::IndexVec::is_empty":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVec"],"seq::index_::IndexVec::iter":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","core::slice::Iter","seq::index_::IndexVec","seq::index_::IndexVecIter"],"seq::index_::IndexVec::len":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVec"],"seq::index_::IndexVecIntoIter":["alloc::vec::IntoIter","core::alloc::Allocator","core::marker::Sized","seq::index_::IndexVecIntoIter"],"seq::index_::IndexVecIter":["core::marker::Sized","core::slice::Iter","seq::index_::IndexVecIter"],"seq::index_::UInt::as_usize":[],"seq::index_::UInt::one":[],"seq::index_::UInt::zero":[],"seq::index_::sample":["<R as rng::Rng>::R","alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","rng::Rng","seq::index_::IndexVec"],"seq::index_::sample_efraimidis_spirakis":["<R as rng::Rng>::R","alloc::vec::Vec","core::alloc::Allocator","core::convert::From","core::convert::Into","core::marker::Sized","core::ops::Fn","core::result::Result","rng::Rng","seq::index_::IndexVec","seq::index_::UInt"],"seq::index_::sample_efraimidis_spirakis::Element":["core::marker::Sized","seq::index_::sample_efraimidis_spirakis::Element"],"seq::index_::sample_floyd":["<R as rng::Rng>::R","alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","rng::Rng","seq::index_::IndexVec"],"seq::index_::sample_inplace":["<R as rng::Rng>::R","alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","rng::Rng","seq::index_::IndexVec"],"seq::index_::sample_rejection":["<R as rng::Rng>::R","alloc::vec::Vec","core::alloc::Allocator","core::convert::From","core::marker::Sized","rng::Rng","seq::index_::IndexVec","seq::index_::UInt"],"seq::index_::sample_weighted":["<R as rng::Rng>::R","core::convert::Into","core::marker::Sized","core::ops::Fn","core::result::Result","rng::Rng"],"seq::iterator::IteratorRandom::choose":["<R as rng::Rng>::R","core::marker::Sized","core::option::Option","rng::Rng"],"seq::iterator::IteratorRandom::choose_multiple":["<R as rng::Rng>::R","alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","rng::Rng"],"seq::iterator::IteratorRandom::choose_multiple_fill":["<R as rng::Rng>::R","rng::Rng"],"seq::iterator::IteratorRandom::choose_stable":["<R as rng::Rng>::R","core::marker::Sized","core::option::Option","rng::Rng"],"seq::slice::IndexedMutRandom::choose_mut":["<R as rng::Rng>::R","core::marker::Sized","core::option::Option","rng::Rng"],"seq::slice::IndexedMutRandom::choose_weighted_mut":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::cmp::PartialOrd","core::marker::Sized","core::ops::Fn","core::result::Result","core::time::Duration","distr::uniform::SampleBorrow","distr::uniform::SampleUniform","distr::weighted::Weight","rng::Rng","seq::index_::sample_efraimidis_spirakis::Element"],"seq::slice::IndexedRandom::choose":["<R as rng::Rng>::R","core::marker::Sized","core::option::Option","rng::Rng"],"seq::slice::IndexedRandom::choose_multiple":["<R as rng::Rng>::R","alloc::vec::IntoIter","core::alloc::Allocator","core::marker::PhantomData","core::marker::Sized","rng::Rng","seq::index_::IndexVecIntoIter","seq::slice::SliceChooseIter"],"seq::slice::IndexedRandom::choose_multiple_array":["<R as rng::Rng>::R","core::clone::Clone","core::marker::Sized","core::option::Option","distr::StandardUniform","rng::Rng"],"seq::slice::IndexedRandom::choose_multiple_weighted":["<R as rng::Rng>::R","core::convert::Into","core::marker::Sized","core::ops::Fn","core::result::Result","rng::Rng"],"seq::slice::IndexedRandom::choose_weighted":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed","<R as rng::Rng>::R","core::cmp::PartialOrd","core::marker::Sized","core::ops::Fn","core::result::Result","core::time::Duration","distr::uniform::SampleBorrow","distr::uniform::SampleUniform","distr::weighted::Weight","rng::Rng","seq::index_::sample_efraimidis_spirakis::Element"],"seq::slice::IndexedRandom::is_empty":[],"seq::slice::IndexedRandom::len":[],"seq::slice::SliceChooseIter":["alloc::vec::IntoIter","core::alloc::Allocator","core::marker::PhantomData","core::marker::Sized","seq::index_::IndexVecIntoIter","seq::slice::SliceChooseIter"],"seq::slice::SliceRandom::partial_shuffle":["<R as rng::Rng>::R","core::marker::Sized","rng::Rng"],"seq::slice::SliceRandom::shuffle":["<R as rng::Rng>::R","rng::Rng"],"thread_rng":["alloc::rc::Rc","core::alloc::Allocator","core::marker::Sized","rngs::thread::ThreadRng"]},"glob_path_import":{"seq::index_":"seq::index::"},"self_to_fn":{"<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed":["impl<Borrowed> SampleBorrow<Borrowed> for Borrowed\nwhere\n    Borrowed: SampleUniform,\n{\n    #[inline(always)]\n    fn borrow(&self) -> &Borrowed {\n        self\n    }\n}"],"<I as seq::iterator::IteratorRandom>::I":["impl<I> IteratorRandom for I where I: Iterator + Sized {}"],"<IR as seq::slice::IndexedMutRandom>::IR":["impl<IR: IndexedRandom + IndexMut<usize> + ?Sized> IndexedMutRandom for IR {}"],"<R as rng::Rng>::R":["impl<R: RngCore + ?Sized> Rng for R {}"],"core::ops::Range":["impl<T: SampleUniform + PartialOrd> SampleRange<T> for Range<T> {\n    #[inline]\n    fn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<T, Error> {\n        T::Sampler::sample_single(self.start, self.end, rng)\n    }\n\n    #[inline]\n    fn is_empty(&self) -> bool {\n        !(self.start < self.end)\n    }\n}"],"core::ops::RangeInclusive":["impl<T: SampleUniform + PartialOrd> SampleRange<T> for RangeInclusive<T> {\n    #[inline]\n    fn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<T, Error> {\n        T::Sampler::sample_single_inclusive(self.start(), self.end(), rng)\n    }\n\n    #[inline]\n    fn is_empty(&self) -> bool {\n        !(self.start() <= self.end())\n    }\n}"],"core::ops::RangeTo":["impl SampleRange<$t> for RangeTo<$t> {\n            #[inline]\n            fn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error> {\n                <$t as SampleUniform>::Sampler::sample_single(0, self.end, rng)\n            }\n\n            #[inline]\n            fn is_empty(&self) -> bool {\n                0 == self.end\n            }\n        }"],"core::ops::RangeToInclusive":["impl SampleRange<$t> for RangeToInclusive<$t> {\n            #[inline]\n            fn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error> {\n                <$t as SampleUniform>::Sampler::sample_single_inclusive(0, self.end, rng)\n            }\n\n            #[inline]\n            fn is_empty(&self) -> bool {\n                false\n            }\n        }"],"core::time::Duration":["impl SampleUniform for Duration {\n    type Sampler = UniformDuration;\n}"],"distr::StandardUniform":["Clone","Copy","Debug","Default","impl Distribution<$ty> for StandardUniform {\n            #[inline]\n            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty {\n                rng.random::<$uty>() as $ty\n            }\n        }","impl Distribution<$ty> for StandardUniform {\n            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty {\n                // Multiply-based method; 24/53 random bits; [0, 1) interval.\n                // We use the most significant bits because for simple RNGs\n                // those are usually more random.\n                let float_size = mem::size_of::<$f_scalar>() as $u_scalar * 8;\n                let precision = $fraction_bits + 1;\n                let scale = 1.0 / ((1 as $u_scalar << precision) as $f_scalar);\n\n                let value: $uty = rng.random();\n                let value = value >> $uty::splat(float_size - precision);\n                $ty::splat(scale) * $ty::cast_from_int(value)\n            }\n        }","impl Distribution<$ty> for StandardUniform {\n            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty {\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }\n        }","impl Distribution<__m128i> for StandardUniform {\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> __m128i {\n        // NOTE: It's tempting to use the u128 impl here, but confusingly this\n        // results in different code (return via rdx, r10 instead of rax, rdx\n        // with u128 impl) and is much slower (+130 time). This version calls\n        // impls::fill_bytes_via_next but performs well.\n\n        let mut buf = [0_u8; core::mem::size_of::<__m128i>()];\n        rng.fill_bytes(&mut buf);\n        // x86 is little endian so no need for conversion\n\n        // SAFETY: All byte sequences of `buf` represent values of the output type.\n        unsafe { core::mem::transmute(buf) }\n    }\n}","impl Distribution<__m256i> for StandardUniform {\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> __m256i {\n        let mut buf = [0_u8; core::mem::size_of::<__m256i>()];\n        rng.fill_bytes(&mut buf);\n        // x86 is little endian so no need for conversion\n\n        // SAFETY: All byte sequences of `buf` represent values of the output type.\n        unsafe { core::mem::transmute(buf) }\n    }\n}","impl Distribution<bool> for StandardUniform {\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> bool {\n        // We can compare against an arbitrary bit of an u32 to get a bool.\n        // Because the least significant bits of a lower quality RNG can have\n        // simple patterns, we compare against the most significant bit. This is\n        // easiest done using a sign test.\n        (rng.next_u32() as i32) < 0\n    }\n}","impl Distribution<char> for StandardUniform {\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> char {\n        // A valid `char` is either in the interval `[0, 0xD800)` or\n        // `(0xDFFF, 0x11_0000)`. All `char`s must therefore be in\n        // `[0, 0x11_0000)` but not in the \"gap\" `[0xD800, 0xDFFF]` which is\n        // reserved for surrogates. This is the size of that gap.\n        const GAP_SIZE: u32 = 0xDFFF - 0xD800 + 1;\n\n        // Uniform::new(0, 0x11_0000 - GAP_SIZE) can also be used, but it\n        // seemed slower.\n        let range = Uniform::new(GAP_SIZE, 0x11_0000).unwrap();\n\n        let mut n = range.sample(rng);\n        if n <= 0xDFFF {\n            n -= GAP_SIZE;\n        }\n        // SAFETY: We ensure above that `n` represents a `char`.\n        unsafe { char::from_u32_unchecked(n) }\n    }\n}","impl Distribution<u128> for StandardUniform {\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u128 {\n        // Use LE; we explicitly generate one value before the next.\n        let x = u128::from(rng.next_u64());\n        let y = u128::from(rng.next_u64());\n        (y << 64) | x\n    }\n}","impl Distribution<u16> for StandardUniform {\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u16 {\n        rng.next_u32() as u16\n    }\n}","impl Distribution<u32> for StandardUniform {\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u32 {\n        rng.next_u32()\n    }\n}","impl Distribution<u64> for StandardUniform {\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u64 {\n        rng.next_u64()\n    }\n}","impl Distribution<u8> for StandardUniform {\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u8 {\n        rng.next_u32() as u8\n    }\n}","impl SampleString for StandardUniform {\n    fn append_string<R: Rng + ?Sized>(&self, rng: &mut R, s: &mut String, len: usize) {\n        // A char is encoded with at most four bytes, thus this reservation is\n        // guaranteed to be sufficient. We do not shrink_to_fit afterwards so\n        // that repeated usage on the same `String` buffer does not reallocate.\n        s.reserve(4 * len);\n        s.extend(Distribution::<char>::sample_iter(self, rng).take(len));\n    }\n}","impl< $($tyvar,)* > Distribution<($($tyvar,)*)> for StandardUniform\n        where $(\n            StandardUniform: Distribution< $tyvar >,\n        )*\n        {\n            #[inline]\n            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ) {\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }\n        }","impl<T, const N: usize> Distribution<[T; N]> for StandardUniform\nwhere\n    StandardUniform: Distribution<T>,\n{\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> [T; N] {\n        array::from_fn(|_| rng.random())\n    }\n}","impl<T> Distribution<Wrapping<T>> for StandardUniform\nwhere\n    StandardUniform: Distribution<T>,\n{\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Wrapping<T> {\n        Wrapping(rng.random())\n    }\n}"],"distr::bernoulli::Bernoulli":["Clone","Copy","Debug","PartialEq","impl Bernoulli {\n    /// Construct a new `Bernoulli` with the given probability of success `p`.\n    ///\n    /// # Precision\n    ///\n    /// For `p = 1.0`, the resulting distribution will always generate true.\n    /// For `p = 0.0`, the resulting distribution will always generate false.\n    ///\n    /// This method is accurate for any input `p` in the range `[0, 1]` which is\n    /// a multiple of 2<sup>-64</sup>. (Note that not all multiples of\n    /// 2<sup>-64</sup> in `[0, 1]` can be represented as a `f64`.)\n    #[inline]\n    pub fn new(p: f64) -> Result<Bernoulli, BernoulliError> {\n        if !(0.0..1.0).contains(&p) {\n            if p == 1.0 {\n                return Ok(Bernoulli { p_int: ALWAYS_TRUE });\n            }\n            return Err(BernoulliError::InvalidProbability);\n        }\n        Ok(Bernoulli {\n            p_int: (p * SCALE) as u64,\n        })\n    }\n\n    /// Construct a new `Bernoulli` with the probability of success of\n    /// `numerator`-in-`denominator`. I.e. `new_ratio(2, 3)` will return\n    /// a `Bernoulli` with a 2-in-3 chance, or about 67%, of returning `true`.\n    ///\n    /// return `true`. If `numerator == 0` it will always return `false`.\n    /// For `numerator > denominator` and `denominator == 0`, this returns an\n    /// error. Otherwise, for `numerator == denominator`, samples are always\n    /// true; for `numerator == 0` samples are always false.\n    #[inline]\n    pub fn from_ratio(numerator: u32, denominator: u32) -> Result<Bernoulli, BernoulliError> {\n        if numerator > denominator || denominator == 0 {\n            return Err(BernoulliError::InvalidProbability);\n        }\n        if numerator == denominator {\n            return Ok(Bernoulli { p_int: ALWAYS_TRUE });\n        }\n        let p_int = ((f64::from(numerator) / f64::from(denominator)) * SCALE) as u64;\n        Ok(Bernoulli { p_int })\n    }\n\n    #[inline]\n    /// Returns the probability (`p`) of the distribution.\n    ///\n    /// This value may differ slightly from the input due to loss of precision.\n    pub fn p(&self) -> f64 {\n        if self.p_int == ALWAYS_TRUE {\n            1.0\n        } else {\n            (self.p_int as f64) / SCALE\n        }\n    }\n}","impl Distribution<bool> for Bernoulli {\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> bool {\n        // Make sure to always return true for p = 1.0.\n        if self.p_int == ALWAYS_TRUE {\n            return true;\n        }\n        let v: u64 = rng.random();\n        v < self.p_int\n    }\n}"],"distr::bernoulli::BernoulliError":["Clone","Copy","Debug","Eq","PartialEq","impl fmt::Display for BernoulliError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(match self {\n            BernoulliError::InvalidProbability => \"p is outside [0, 1] in Bernoulli distribution\",\n        })\n    }\n}","impl std::error::Error for BernoulliError {}"],"distr::distribution::Iter":["Debug","impl<D, R, T> Iterator for Iter<D, R, T>\nwhere\n    D: Distribution<T>,\n    R: Rng,\n{\n    type Item = T;\n\n    #[inline(always)]\n    fn next(&mut self) -> Option<T> {\n        // Here, self.rng may be a reference, but we must take &mut anyway.\n        // Even if sample could take an R: Rng by value, we would need to do this\n        // since Rng is not copyable and we cannot enforce that this is \"reborrowable\".\n        Some(self.distr.sample(&mut self.rng))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (usize::MAX, None)\n    }\n}","impl<D, R, T> iter::FusedIterator for Iter<D, R, T>\nwhere\n    D: Distribution<T>,\n    R: Rng,\n{\n}"],"distr::distribution::Map":["Debug","impl<D, F, T, S> Distribution<S> for Map<D, F, T, S>\nwhere\n    D: Distribution<T>,\n    F: Fn(T) -> S,\n{\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> S {\n        (self.func)(self.distr.sample(rng))\n    }\n}"],"distr::float::Open01":["Clone","Copy","Debug","Default","impl Distribution<$ty> for Open01 {\n            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty {\n                // Transmute-based method; 23/52 random bits; (0, 1) interval.\n                // We use the most significant bits because for simple RNGs\n                // those are usually more random.\n                let float_size = mem::size_of::<$f_scalar>() as $u_scalar * 8;\n\n                let value: $uty = rng.random();\n                let fraction = value >> $uty::splat(float_size - $fraction_bits);\n                fraction.into_float_with_exponent(0) - $ty::splat(1.0 - $f_scalar::EPSILON / 2.0)\n            }\n        }"],"distr::float::OpenClosed01":["Clone","Copy","Debug","Default","impl Distribution<$ty> for OpenClosed01 {\n            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty {\n                // Multiply-based method; 24/53 random bits; (0, 1] interval.\n                // We use the most significant bits because for simple RNGs\n                // those are usually more random.\n                let float_size = mem::size_of::<$f_scalar>() as $u_scalar * 8;\n                let precision = $fraction_bits + 1;\n                let scale = 1.0 / ((1 as $u_scalar << precision) as $f_scalar);\n\n                let value: $uty = rng.random();\n                let value = value >> $uty::splat(float_size - precision);\n                // Add 1 to shift up; will not overflow because of right-shift:\n                $ty::splat(scale) * $ty::cast_from_int(value + $uty::splat(1))\n            }\n        }"],"distr::other::Alphabetic":["Clone","Copy","Debug","Default","impl Distribution<u8> for Alphabetic {\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u8 {\n        const RANGE: u8 = 26 + 26;\n\n        let offset = rng.random_range(0..RANGE) + b'A';\n\n        // Account for upper-cases\n        offset + (offset > b'Z') as u8 * (b'a' - b'Z' - 1)\n    }\n}","impl SampleString for Alphabetic {\n    fn append_string<R: Rng + ?Sized>(&self, rng: &mut R, string: &mut String, len: usize) {\n        // SAFETY: With this distribution we guarantee that we're working with valid ASCII\n        // characters.\n        // See [#1590](https://github.com/rust-random/rand/issues/1590).\n        unsafe {\n            let v = string.as_mut_vec();\n            v.reserve_exact(len);\n            v.extend(self.sample_iter(rng).take(len));\n        }\n    }\n}"],"distr::other::Alphanumeric":["Clone","Copy","Debug","Default","impl Distribution<u8> for Alphanumeric {\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u8 {\n        const RANGE: u32 = 26 + 26 + 10;\n        const GEN_ASCII_STR_CHARSET: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                abcdefghijklmnopqrstuvwxyz\\\n                0123456789\";\n        // We can pick from 62 characters. This is so close to a power of 2, 64,\n        // that we can do better than `Uniform`. Use a simple bitshift and\n        // rejection sampling. We do not use a bitmask, because for small RNGs\n        // the most significant bits are usually of higher quality.\n        loop {\n            let var = rng.next_u32() >> (32 - 6);\n            if var < RANGE {\n                return GEN_ASCII_STR_CHARSET[var as usize];\n            }\n        }\n    }\n}","impl SampleString for Alphanumeric {\n    fn append_string<R: Rng + ?Sized>(&self, rng: &mut R, string: &mut String, len: usize) {\n        // SAFETY: `self` only samples alphanumeric characters, which are valid UTF-8.\n        unsafe {\n            let v = string.as_mut_vec();\n            v.extend(\n                self.sample_iter(rng)\n                    .take(len)\n                    .inspect(|b| debug_assert!(b.is_ascii_alphanumeric())),\n            );\n        }\n    }\n}"],"distr::slice::Choose":["Clone","Copy","Debug","impl super::SampleString for Choose<'_, char> {\n    fn append_string<R: crate::Rng + ?Sized>(&self, rng: &mut R, string: &mut String, len: usize) {\n        // Get the max char length to minimize extra space.\n        // Limit this check to avoid searching for long slice.\n        let max_char_len = if self.slice.len() < 200 {\n            self.slice\n                .iter()\n                .try_fold(1, |max_len, char| {\n                    // When the current max_len is 4, the result max_char_len will be 4.\n                    Some(max_len.max(char.len_utf8())).filter(|len| *len < 4)\n                })\n                .unwrap_or(4)\n        } else {\n            4\n        };\n\n        // Split the extension of string to reuse the unused capacities.\n        // Skip the split for small length or only ascii slice.\n        let mut extend_len = if max_char_len == 1 || len < 100 {\n            len\n        } else {\n            len / 4\n        };\n        let mut remain_len = len;\n        while extend_len > 0 {\n            string.reserve(max_char_len * extend_len);\n            string.extend(self.sample_iter(&mut *rng).take(extend_len));\n            remain_len -= extend_len;\n            extend_len = extend_len.min(remain_len);\n        }\n    }\n}","impl<'a, T> Choose<'a, T> {\n    /// Create a new `Choose` instance which samples uniformly from the slice.\n    ///\n    /// Returns error [`Empty`] if the slice is empty.\n    pub fn new(slice: &'a [T]) -> Result<Self, Empty> {\n        let num_choices = NonZeroUsize::new(slice.len()).ok_or(Empty)?;\n\n        Ok(Self {\n            slice,\n            range: UniformUsize::new(0, num_choices.get()).unwrap(),\n            num_choices,\n        })\n    }\n\n    /// Returns the count of choices in this distribution\n    pub fn num_choices(&self) -> NonZeroUsize {\n        self.num_choices\n    }\n}","impl<'a, T> Distribution<&'a T> for Choose<'a, T> {\n    fn sample<R: crate::Rng + ?Sized>(&self, rng: &mut R) -> &'a T {\n        let idx = self.range.sample(rng);\n\n        debug_assert!(\n            idx < self.slice.len(),\n            \"Uniform::new(0, {}) somehow returned {}\",\n            self.slice.len(),\n            idx\n        );\n\n        // Safety: at construction time, it was ensured that the slice was\n        // non-empty, and that the `Uniform` range produces values in range\n        // for the slice\n        unsafe { self.slice.get_unchecked(idx) }\n    }\n}"],"distr::slice::Empty":["Clone","Copy","Debug","impl core::fmt::Display for Empty {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        write!(\n            f,\n            \"Tried to create a `rand::distr::slice::Choose` with an empty slice\"\n        )\n    }\n}","impl std::error::Error for Empty {}"],"distr::uniform::Error":["Clone","Copy","Debug","Eq","PartialEq","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(match self {\n            Error::EmptyRange => \"low > high (or equal if exclusive) in uniform distribution\",\n            Error::NonFinite => \"Non-finite range in uniform distribution\",\n        })\n    }\n}","impl std::error::Error for Error {}"],"distr::uniform::Uniform":["Clone","Copy","Debug","Eq","PartialEq","impl crate::distr::SampleString for Uniform<char> {\n    fn append_string<R: Rng + ?Sized>(\n        &self,\n        rng: &mut R,\n        string: &mut alloc::string::String,\n        len: usize,\n    ) {\n        // Getting the hi value to assume the required length to reserve in string.\n        let mut hi = self.0.sampler.low + self.0.sampler.range - 1;\n        if hi >= CHAR_SURROGATE_START {\n            hi += CHAR_SURROGATE_LEN;\n        }\n        // Get the utf8 length of hi to minimize extra space.\n        let max_char_len = char::from_u32(hi).map(char::len_utf8).unwrap_or(4);\n        string.reserve(max_char_len * len);\n        string.extend(self.sample_iter(rng).take(len))\n    }\n}","impl<X: SampleUniform> Distribution<X> for Uniform<X> {\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> X {\n        self.0.sample(rng)\n    }\n}","impl<X: SampleUniform> TryFrom<Range<X>> for Uniform<X> {\n    type Error = Error;\n\n    fn try_from(r: Range<X>) -> Result<Uniform<X>, Error> {\n        Uniform::new(r.start, r.end)\n    }\n}","impl<X: SampleUniform> TryFrom<RangeInclusive<X>> for Uniform<X> {\n    type Error = Error;\n\n    fn try_from(r: ::core::ops::RangeInclusive<X>) -> Result<Uniform<X>, Error> {\n        Uniform::new_inclusive(r.start(), r.end())\n    }\n}","impl<X: SampleUniform> Uniform<X> {\n    /// Create a new `Uniform` instance, which samples uniformly from the half\n    /// open range `[low, high)` (excluding `high`).\n    ///\n    /// For discrete types (e.g. integers), samples will always be strictly less\n    /// than `high`. For (approximations of) continuous types (e.g. `f32`, `f64`),\n    /// samples may equal `high` due to loss of precision but may not be\n    /// greater than `high`.\n    ///\n    /// Fails if `low >= high`, or if `low`, `high` or the range `high - low` is\n    /// non-finite. In release mode, only the range is checked.\n    pub fn new<B1, B2>(low: B1, high: B2) -> Result<Uniform<X>, Error>\n    where\n        B1: SampleBorrow<X> + Sized,\n        B2: SampleBorrow<X> + Sized,\n    {\n        X::Sampler::new(low, high).map(Uniform)\n    }\n\n    /// Create a new `Uniform` instance, which samples uniformly from the closed\n    /// range `[low, high]` (inclusive).\n    ///\n    /// Fails if `low > high`, or if `low`, `high` or the range `high - low` is\n    /// non-finite. In release mode, only the range is checked.\n    pub fn new_inclusive<B1, B2>(low: B1, high: B2) -> Result<Uniform<X>, Error>\n    where\n        B1: SampleBorrow<X> + Sized,\n        B2: SampleBorrow<X> + Sized,\n    {\n        X::Sampler::new_inclusive(low, high).map(Uniform)\n    }\n}"],"distr::uniform::float::UniformFloat":["Clone","Copy","Debug","PartialEq","impl UniformFloat<$ty> {\n            /// Construct, reducing `scale` as required to ensure that rounding\n            /// can never yield values greater than `high`.\n            ///\n            /// Note: though it may be tempting to use a variant of this method\n            /// to ensure that samples from `[low, high)` are always strictly\n            /// less than `high`, this approach may be very slow where\n            /// `scale.abs()` is much smaller than `high.abs()`\n            /// (example: `low=0.99999999997819644, high=1.`).\n            fn new_bounded(low: $ty, high: $ty, mut scale: $ty) -> Self {\n                let max_rand = <$ty>::splat(1.0 as $f_scalar - $f_scalar::EPSILON);\n\n                loop {\n                    let mask = (scale * max_rand + low).gt_mask(high);\n                    if !mask.any() {\n                        break;\n                    }\n                    scale = scale.decrease_masked(mask);\n                }\n\n                debug_assert!(<$ty>::splat(0.0).all_le(scale));\n\n                UniformFloat { low, scale }\n            }\n        }","impl UniformSampler for UniformFloat<$ty> {\n            type X = $ty;\n\n            fn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,\n            {\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                #[cfg(debug_assertions)]\n                if !(low.all_finite()) || !(high.all_finite()) {\n                    return Err(Error::NonFinite);\n                }\n                if !(low.all_lt(high)) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let scale = high - low;\n                if !(scale.all_finite()) {\n                    return Err(Error::NonFinite);\n                }\n\n                Ok(Self::new_bounded(low, high, scale))\n            }\n\n            fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,\n            {\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                #[cfg(debug_assertions)]\n                if !(low.all_finite()) || !(high.all_finite()) {\n                    return Err(Error::NonFinite);\n                }\n                if !low.all_le(high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let max_rand = <$ty>::splat(1.0 as $f_scalar - $f_scalar::EPSILON);\n                let scale = (high - low) / max_rand;\n                if !scale.all_finite() {\n                    return Err(Error::NonFinite);\n                }\n\n                Ok(Self::new_bounded(low, high, scale))\n            }\n\n            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {\n                // Generate a value in the range [1, 2)\n                let value1_2 = (rng.random::<$uty>() >> $uty::splat($bits_to_discard)).into_float_with_exponent(0);\n\n                // Get a value in the range [0, 1) to avoid overflow when multiplying by scale\n                let value0_1 = value1_2 - <$ty>::splat(1.0);\n\n                // We don't use `f64::mul_add`, because it is not available with\n                // `no_std`. Furthermore, it is slower for some targets (but\n                // faster for others). However, the order of multiplication and\n                // addition is important, because on some platforms (e.g. ARM)\n                // it will be optimized to a single (non-FMA) instruction.\n                value0_1 * self.scale + self.low\n            }\n\n            #[inline]\n            fn sample_single<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,\n            {\n                Self::sample_single_inclusive(low_b, high_b, rng)\n            }\n\n            #[inline]\n            fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,\n            {\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                #[cfg(debug_assertions)]\n                if !low.all_finite() || !high.all_finite() {\n                    return Err(Error::NonFinite);\n                }\n                if !low.all_le(high) {\n                    return Err(Error::EmptyRange);\n                }\n                let scale = high - low;\n                if !scale.all_finite() {\n                    return Err(Error::NonFinite);\n                }\n\n                // Generate a value in the range [1, 2)\n                let value1_2 =\n                    (rng.random::<$uty>() >> $uty::splat($bits_to_discard)).into_float_with_exponent(0);\n\n                // Get a value in the range [0, 1) to avoid overflow when multiplying by scale\n                let value0_1 = value1_2 - <$ty>::splat(1.0);\n\n                // Doing multiply before addition allows some architectures\n                // to use a single instruction.\n                Ok(value0_1 * scale + low)\n            }\n        }"],"distr::uniform::int::UniformInt":["Clone","Copy","Debug","Eq","PartialEq","impl UniformSampler for UniformInt<$ty> {\n            // We play free and fast with unsigned vs signed here\n            // (when $ty is signed), but that's fine, since the\n            // contract of this macro is for $ty and $uty to be\n            // \"bit-equal\", so casting between them is a no-op.\n\n            type X = $ty;\n\n            #[inline] // if the range is constant, this helps LLVM to do the\n                      // calculations at compile-time.\n            fn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,\n            {\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }\n\n            #[inline] // if the range is constant, this helps LLVM to do the\n                      // calculations at compile-time.\n            fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,\n            {\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }\n\n            /// Sample from distribution, Lemire's method, unbiased\n            #[inline]\n            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }\n\n            #[inline]\n            fn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,\n            {\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }\n\n            /// Sample single value, Canon's method, biased\n            ///\n            /// In the worst case, bias affects 1 in `2^n` samples where n is\n            /// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n            #[cfg(not(feature = \"unbiased\"))]\n            #[inline]\n            fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,\n            {\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }\n\n            /// Sample single value, Canon's method, unbiased\n            #[cfg(feature = \"unbiased\")]\n            #[inline]\n            fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<$ty> + Sized,\n                B2: SampleBorrow<$ty> + Sized,\n            {\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                let (mut result, mut lo) = rng.random::<$sample_ty>().wmul(range);\n\n                // In contrast to the biased sampler, we use a loop:\n                while lo > range.wrapping_neg() {\n                    let (new_hi, new_lo) = (rng.random::<$sample_ty>()).wmul(range);\n                    match lo.checked_add(new_hi) {\n                        Some(x) if x < $sample_ty::MAX => {\n                            // Anything less than MAX: last term is 0\n                            break;\n                        }\n                        None => {\n                            // Overflow: last term is 1\n                            result += 1;\n                            break;\n                        }\n                        _ => {\n                            // Unlikely case: must check next sample\n                            lo = new_lo;\n                            continue;\n                        }\n                    }\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }\n        }"],"distr::uniform::int::UniformUsize":["Clone","Copy","Debug","Eq","PartialEq","impl UniformSampler for UniformUsize {\n    type X = usize;\n\n    #[inline] // if the range is constant, this helps LLVM to do the\n              // calculations at compile-time.\n    fn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,\n    {\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low < high) {\n            return Err(Error::EmptyRange);\n        }\n\n        UniformSampler::new_inclusive(low, high - 1)\n    }\n\n    #[inline] // if the range is constant, this helps LLVM to do the\n              // calculations at compile-time.\n    fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,\n    {\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low <= high) {\n            return Err(Error::EmptyRange);\n        }\n\n        #[cfg(target_pointer_width = \"64\")]\n        let mode64 = high > (u32::MAX as usize);\n        #[cfg(target_pointer_width = \"32\")]\n        let mode64 = false;\n\n        let (range, thresh);\n        if cfg!(target_pointer_width = \"64\") && !mode64 {\n            let range32 = (high as u32).wrapping_sub(low as u32).wrapping_add(1);\n            range = range32 as usize;\n            thresh = if range32 > 0 {\n                (range32.wrapping_neg() % range32) as usize\n            } else {\n                0\n            };\n        } else {\n            range = high.wrapping_sub(low).wrapping_add(1);\n            thresh = if range > 0 {\n                range.wrapping_neg() % range\n            } else {\n                0\n            };\n        }\n\n        Ok(UniformUsize {\n            low,\n            range,\n            thresh,\n            #[cfg(target_pointer_width = \"64\")]\n            mode64,\n        })\n    }\n\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> usize {\n        #[cfg(target_pointer_width = \"32\")]\n        let mode32 = true;\n        #[cfg(target_pointer_width = \"64\")]\n        let mode32 = !self.mode64;\n\n        if mode32 {\n            let range = self.range as u32;\n            if range == 0 {\n                return rng.random::<u32>() as usize;\n            }\n\n            let thresh = self.thresh as u32;\n            let hi = loop {\n                let (hi, lo) = rng.random::<u32>().wmul(range);\n                if lo >= thresh {\n                    break hi;\n                }\n            };\n            self.low.wrapping_add(hi as usize)\n        } else {\n            let range = self.range as u64;\n            if range == 0 {\n                return rng.random::<u64>() as usize;\n            }\n\n            let thresh = self.thresh as u64;\n            let hi = loop {\n                let (hi, lo) = rng.random::<u64>().wmul(range);\n                if lo >= thresh {\n                    break hi;\n                }\n            };\n            self.low.wrapping_add(hi as usize)\n        }\n    }\n\n    #[inline]\n    fn sample_single<R: Rng + ?Sized, B1, B2>(\n        low_b: B1,\n        high_b: B2,\n        rng: &mut R,\n    ) -> Result<Self::X, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,\n    {\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low < high) {\n            return Err(Error::EmptyRange);\n        }\n\n        if cfg!(target_pointer_width = \"64\") && high > (u32::MAX as usize) {\n            return UniformInt::<u64>::sample_single(low as u64, high as u64, rng)\n                .map(|x| x as usize);\n        }\n\n        UniformInt::<u32>::sample_single(low as u32, high as u32, rng).map(|x| x as usize)\n    }\n\n    #[inline]\n    fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n        low_b: B1,\n        high_b: B2,\n        rng: &mut R,\n    ) -> Result<Self::X, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,\n    {\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low <= high) {\n            return Err(Error::EmptyRange);\n        }\n\n        if cfg!(target_pointer_width = \"64\") && high > (u32::MAX as usize) {\n            return UniformInt::<u64>::sample_single_inclusive(low as u64, high as u64, rng)\n                .map(|x| x as usize);\n        }\n\n        UniformInt::<u32>::sample_single_inclusive(low as u32, high as u32, rng).map(|x| x as usize)\n    }\n}"],"distr::uniform::other::UniformChar":["Clone","Copy","Debug","Eq","PartialEq","impl UniformSampler for UniformChar {\n    type X = char;\n\n    #[inline] // if the range is constant, this helps LLVM to do the\n              // calculations at compile-time.\n    fn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,\n    {\n        let low = char_to_comp_u32(*low_b.borrow());\n        let high = char_to_comp_u32(*high_b.borrow());\n        let sampler = UniformInt::<u32>::new(low, high);\n        sampler.map(|sampler| UniformChar { sampler })\n    }\n\n    #[inline] // if the range is constant, this helps LLVM to do the\n              // calculations at compile-time.\n    fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,\n    {\n        let low = char_to_comp_u32(*low_b.borrow());\n        let high = char_to_comp_u32(*high_b.borrow());\n        let sampler = UniformInt::<u32>::new_inclusive(low, high);\n        sampler.map(|sampler| UniformChar { sampler })\n    }\n\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {\n        let mut x = self.sampler.sample(rng);\n        if x >= CHAR_SURROGATE_START {\n            x += CHAR_SURROGATE_LEN;\n        }\n        // SAFETY: x must not be in surrogate range or greater than char::MAX.\n        // This relies on range constructors which accept char arguments.\n        // Validity of input char values is assumed.\n        unsafe { core::char::from_u32_unchecked(x) }\n    }\n}"],"distr::uniform::other::UniformDuration":["Clone","Copy","Debug","Eq","PartialEq","impl UniformSampler for UniformDuration {\n    type X = Duration;\n\n    #[inline]\n    fn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,\n    {\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low < high) {\n            return Err(Error::EmptyRange);\n        }\n        UniformDuration::new_inclusive(low, high - Duration::new(0, 1))\n    }\n\n    #[inline]\n    fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,\n    {\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low <= high) {\n            return Err(Error::EmptyRange);\n        }\n\n        let low_s = low.as_secs();\n        let low_n = low.subsec_nanos();\n        let mut high_s = high.as_secs();\n        let mut high_n = high.subsec_nanos();\n\n        if high_n < low_n {\n            high_s -= 1;\n            high_n += 1_000_000_000;\n        }\n\n        let mode = if low_s == high_s {\n            UniformDurationMode::Small {\n                secs: low_s,\n                nanos: Uniform::new_inclusive(low_n, high_n)?,\n            }\n        } else {\n            let max = high_s\n                .checked_mul(1_000_000_000)\n                .and_then(|n| n.checked_add(u64::from(high_n)));\n\n            if let Some(higher_bound) = max {\n                let lower_bound = low_s * 1_000_000_000 + u64::from(low_n);\n                UniformDurationMode::Medium {\n                    nanos: Uniform::new_inclusive(lower_bound, higher_bound)?,\n                }\n            } else {\n                // An offset is applied to simplify generation of nanoseconds\n                let max_nanos = high_n - low_n;\n                UniformDurationMode::Large {\n                    max_secs: high_s,\n                    max_nanos,\n                    secs: Uniform::new_inclusive(low_s, high_s)?,\n                }\n            }\n        };\n        Ok(UniformDuration {\n            mode,\n            offset: low_n,\n        })\n    }\n\n    #[inline]\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Duration {\n        match self.mode {\n            UniformDurationMode::Small { secs, nanos } => {\n                let n = nanos.sample(rng);\n                Duration::new(secs, n)\n            }\n            UniformDurationMode::Medium { nanos } => {\n                let nanos = nanos.sample(rng);\n                Duration::new(nanos / 1_000_000_000, (nanos % 1_000_000_000) as u32)\n            }\n            UniformDurationMode::Large {\n                max_secs,\n                max_nanos,\n                secs,\n            } => {\n                // constant folding means this is at least as fast as `Rng::sample(Range)`\n                let nano_range = Uniform::new(0, 1_000_000_000).unwrap();\n                loop {\n                    let s = secs.sample(rng);\n                    let n = nano_range.sample(rng);\n                    if !(s == max_secs && n > max_nanos) {\n                        let sum = n + self.offset;\n                        break Duration::new(s, sum);\n                    }\n                }\n            }\n        }\n    }\n}"],"distr::uniform::other::UniformDurationMode":["Clone","Copy","Debug","Eq","PartialEq"],"distr::weighted::Error":["Clone","Copy","Debug","Eq","PartialEq","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(match *self {\n            Error::InvalidInput => \"Weights sequence is empty/too long/unordered\",\n            Error::InvalidWeight => \"A weight is negative, too large or not a valid number\",\n            Error::InsufficientNonZero => \"Not enough weights > zero\",\n            Error::Overflow => \"Overflow when summing weights\",\n        })\n    }\n}","impl std::error::Error for Error {}"],"distr::weighted::weighted_index::WeightedIndex":["Clone","Debug","PartialEq","impl<X: SampleUniform + PartialOrd + Clone> WeightedIndex<X> {\n    /// Returns the weight at the given index, if it exists.\n    ///\n    /// If the index is out of bounds, this will return `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::distr::weighted::WeightedIndex;\n    ///\n    /// let weights = [0, 1, 2];\n    /// let dist = WeightedIndex::new(&weights).unwrap();\n    /// assert_eq!(dist.weight(0), Some(0));\n    /// assert_eq!(dist.weight(1), Some(1));\n    /// assert_eq!(dist.weight(2), Some(2));\n    /// assert_eq!(dist.weight(3), None);\n    /// ```\n    pub fn weight(&self, index: usize) -> Option<X>\n    where\n        X: for<'a> core::ops::SubAssign<&'a X>,\n    {\n        use core::cmp::Ordering::*;\n\n        let mut weight = match index.cmp(&self.cumulative_weights.len()) {\n            Less => self.cumulative_weights[index].clone(),\n            Equal => self.total_weight.clone(),\n            Greater => return None,\n        };\n\n        if index > 0 {\n            weight -= &self.cumulative_weights[index - 1];\n        }\n        Some(weight)\n    }\n\n    /// Returns a lazy-loading iterator containing the current weights of this distribution.\n    ///\n    /// If this distribution has not been updated since its creation, this will return the\n    /// same weights as were passed to `new`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::distr::weighted::WeightedIndex;\n    ///\n    /// let weights = [1, 2, 3];\n    /// let mut dist = WeightedIndex::new(&weights).unwrap();\n    /// assert_eq!(dist.weights().collect::<Vec<_>>(), vec![1, 2, 3]);\n    /// dist.update_weights(&[(0, &2)]).unwrap();\n    /// assert_eq!(dist.weights().collect::<Vec<_>>(), vec![2, 2, 3]);\n    /// ```\n    pub fn weights(&self) -> WeightedIndexIter<'_, X>\n    where\n        X: for<'a> core::ops::SubAssign<&'a X>,\n    {\n        WeightedIndexIter {\n            weighted_index: self,\n            index: 0,\n        }\n    }\n\n    /// Returns the sum of all weights in this distribution.\n    pub fn total_weight(&self) -> X {\n        self.total_weight.clone()\n    }\n}","impl<X: SampleUniform + PartialOrd> WeightedIndex<X> {\n    /// Creates a new a `WeightedIndex` [`Distribution`] using the values\n    /// in `weights`. The weights can use any type `X` for which an\n    /// implementation of [`Uniform<X>`] exists.\n    ///\n    /// Error cases:\n    /// -   [`Error::InvalidInput`] when the iterator `weights` is empty.\n    /// -   [`Error::InvalidWeight`] when a weight is not-a-number or negative.\n    /// -   [`Error::InsufficientNonZero`] when the sum of all weights is zero.\n    /// -   [`Error::Overflow`] when the sum of all weights overflows.\n    ///\n    /// [`Uniform<X>`]: crate::distr::uniform::Uniform\n    pub fn new<I>(weights: I) -> Result<WeightedIndex<X>, Error>\n    where\n        I: IntoIterator,\n        I::Item: SampleBorrow<X>,\n        X: Weight,\n    {\n        let mut iter = weights.into_iter();\n        let mut total_weight: X = iter.next().ok_or(Error::InvalidInput)?.borrow().clone();\n\n        let zero = X::ZERO;\n        if !(total_weight >= zero) {\n            return Err(Error::InvalidWeight);\n        }\n\n        let mut weights = Vec::<X>::with_capacity(iter.size_hint().0);\n        for w in iter {\n            // Note that `!(w >= x)` is not equivalent to `w < x` for partially\n            // ordered types due to NaNs which are equal to nothing.\n            if !(w.borrow() >= &zero) {\n                return Err(Error::InvalidWeight);\n            }\n            weights.push(total_weight.clone());\n\n            if let Err(()) = total_weight.checked_add_assign(w.borrow()) {\n                return Err(Error::Overflow);\n            }\n        }\n\n        if total_weight == zero {\n            return Err(Error::InsufficientNonZero);\n        }\n        let distr = X::Sampler::new(zero, total_weight.clone()).unwrap();\n\n        Ok(WeightedIndex {\n            cumulative_weights: weights,\n            total_weight,\n            weight_distribution: distr,\n        })\n    }\n\n    /// Update a subset of weights, without changing the number of weights.\n    ///\n    /// `new_weights` must be sorted by the index.\n    ///\n    /// Using this method instead of `new` might be more efficient if only a small number of\n    /// weights is modified. No allocations are performed, unless the weight type `X` uses\n    /// allocation internally.\n    ///\n    /// In case of error, `self` is not modified. Error cases:\n    /// -   [`Error::InvalidInput`] when `new_weights` are not ordered by\n    ///     index or an index is too large.\n    /// -   [`Error::InvalidWeight`] when a weight is not-a-number or negative.\n    /// -   [`Error::InsufficientNonZero`] when the sum of all weights is zero.\n    ///     Note that due to floating-point loss of precision, this case is not\n    ///     always correctly detected; usage of a fixed-point weight type may be\n    ///     preferred.\n    ///\n    /// Updates take `O(N)` time. If you need to frequently update weights, consider\n    /// [`rand_distr::weighted_tree`](https://docs.rs/rand_distr/*/rand_distr/weighted_tree/index.html)\n    /// as an alternative where an update is `O(log N)`.\n    pub fn update_weights(&mut self, new_weights: &[(usize, &X)]) -> Result<(), Error>\n    where\n        X: for<'a> core::ops::AddAssign<&'a X>\n            + for<'a> core::ops::SubAssign<&'a X>\n            + Clone\n            + Default,\n    {\n        if new_weights.is_empty() {\n            return Ok(());\n        }\n\n        let zero = <X as Default>::default();\n\n        let mut total_weight = self.total_weight.clone();\n\n        // Check for errors first, so we don't modify `self` in case something\n        // goes wrong.\n        let mut prev_i = None;\n        for &(i, w) in new_weights {\n            if let Some(old_i) = prev_i {\n                if old_i >= i {\n                    return Err(Error::InvalidInput);\n                }\n            }\n            if !(*w >= zero) {\n                return Err(Error::InvalidWeight);\n            }\n            if i > self.cumulative_weights.len() {\n                return Err(Error::InvalidInput);\n            }\n\n            let mut old_w = if i < self.cumulative_weights.len() {\n                self.cumulative_weights[i].clone()\n            } else {\n                self.total_weight.clone()\n            };\n            if i > 0 {\n                old_w -= &self.cumulative_weights[i - 1];\n            }\n\n            total_weight -= &old_w;\n            total_weight += w;\n            prev_i = Some(i);\n        }\n        if total_weight <= zero {\n            return Err(Error::InsufficientNonZero);\n        }\n\n        // Update the weights. Because we checked all the preconditions in the\n        // previous loop, this should never panic.\n        let mut iter = new_weights.iter();\n\n        let mut prev_weight = zero.clone();\n        let mut next_new_weight = iter.next();\n        let &(first_new_index, _) = next_new_weight.unwrap();\n        let mut cumulative_weight = if first_new_index > 0 {\n            self.cumulative_weights[first_new_index - 1].clone()\n        } else {\n            zero.clone()\n        };\n        for i in first_new_index..self.cumulative_weights.len() {\n            match next_new_weight {\n                Some(&(j, w)) if i == j => {\n                    cumulative_weight += w;\n                    next_new_weight = iter.next();\n                }\n                _ => {\n                    let mut tmp = self.cumulative_weights[i].clone();\n                    tmp -= &prev_weight; // We know this is positive.\n                    cumulative_weight += &tmp;\n                }\n            }\n            prev_weight = cumulative_weight.clone();\n            core::mem::swap(&mut prev_weight, &mut self.cumulative_weights[i]);\n        }\n\n        self.total_weight = total_weight;\n        self.weight_distribution = X::Sampler::new(zero, self.total_weight.clone()).unwrap();\n\n        Ok(())\n    }\n}","impl<X> Distribution<usize> for WeightedIndex<X>\nwhere\n    X: SampleUniform + PartialOrd,\n{\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> usize {\n        let chosen_weight = self.weight_distribution.sample(rng);\n        // Find the first item which has a weight *higher* than the chosen weight.\n        self.cumulative_weights\n            .partition_point(|w| w <= &chosen_weight)\n    }\n}"],"distr::weighted::weighted_index::WeightedIndexIter":["impl<X> Clone for WeightedIndexIter<'_, X>\nwhere\n    X: SampleUniform + PartialOrd,\n{\n    fn clone(&self) -> Self {\n        WeightedIndexIter {\n            weighted_index: self.weighted_index,\n            index: self.index,\n        }\n    }\n}","impl<X> Debug for WeightedIndexIter<'_, X>\nwhere\n    X: SampleUniform + PartialOrd + Debug,\n    X::Sampler: Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"WeightedIndexIter\")\n            .field(\"weighted_index\", &self.weighted_index)\n            .field(\"index\", &self.index)\n            .finish()\n    }\n}","impl<X> Iterator for WeightedIndexIter<'_, X>\nwhere\n    X: for<'b> core::ops::SubAssign<&'b X> + SampleUniform + PartialOrd + Clone,\n{\n    type Item = X;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.weighted_index.weight(self.index) {\n            None => None,\n            Some(weight) => {\n                self.index += 1;\n                Some(weight)\n            }\n        }\n    }\n}"],"rngs::mock::StepRng":["Clone","Debug","Eq","PartialEq","impl RngCore for StepRng {\n    #[inline]\n    fn next_u32(&mut self) -> u32 {\n        self.next_u64() as u32\n    }\n\n    #[inline]\n    fn next_u64(&mut self) -> u64 {\n        let res = self.v;\n        self.v = self.v.wrapping_add(self.a);\n        res\n    }\n\n    #[inline]\n    fn fill_bytes(&mut self, dst: &mut [u8]) {\n        impls::fill_bytes_via_next(self, dst)\n    }\n}","impl StepRng {\n    /// Create a `StepRng`, yielding an arithmetic sequence starting with\n    /// `initial` and incremented by `increment` each time.\n    pub fn new(initial: u64, increment: u64) -> Self {\n        StepRng {\n            v: initial,\n            a: increment,\n        }\n    }\n}"],"rngs::reseeding::ReseedingCore":["Debug","impl<R, Rsdr> BlockRngCore for ReseedingCore<R, Rsdr>\nwhere\n    R: BlockRngCore + SeedableRng,\n    Rsdr: TryRngCore,\n{\n    type Item = <R as BlockRngCore>::Item;\n    type Results = <R as BlockRngCore>::Results;\n\n    fn generate(&mut self, results: &mut Self::Results) {\n        if self.bytes_until_reseed <= 0 {\n            // We get better performance by not calling only `reseed` here\n            // and continuing with the rest of the function, but by directly\n            // returning from a non-inlined function.\n            return self.reseed_and_generate(results);\n        }\n        let num_bytes = size_of_val(results.as_ref());\n        self.bytes_until_reseed -= num_bytes as i64;\n        self.inner.generate(results);\n    }\n}","impl<R, Rsdr> Clone for ReseedingCore<R, Rsdr>\nwhere\n    R: BlockRngCore + SeedableRng + Clone,\n    Rsdr: TryRngCore + Clone,\n{\n    fn clone(&self) -> ReseedingCore<R, Rsdr> {\n        ReseedingCore {\n            inner: self.inner.clone(),\n            reseeder: self.reseeder.clone(),\n            threshold: self.threshold,\n            bytes_until_reseed: 0, // reseed clone on first use\n        }\n    }\n}","impl<R, Rsdr> CryptoBlockRng for ReseedingCore<R, Rsdr>\nwhere\n    R: BlockRngCore<Item = u32> + SeedableRng + CryptoBlockRng,\n    Rsdr: TryCryptoRng,\n{\n}","impl<R, Rsdr> ReseedingCore<R, Rsdr>\nwhere\n    R: BlockRngCore + SeedableRng,\n    Rsdr: TryRngCore,\n{\n    /// Create a new `ReseedingCore`.\n    ///\n    /// `threshold` is the maximum number of bytes produced by\n    /// [`BlockRngCore::generate`] before attempting reseeding.\n    fn new(threshold: u64, mut reseeder: Rsdr) -> Result<Self, Rsdr::Error> {\n        // Because generating more values than `i64::MAX` takes centuries on\n        // current hardware, we just clamp to that value.\n        // Also we set a threshold of 0, which indicates no limit, to that\n        // value.\n        let threshold = if threshold == 0 {\n            i64::MAX\n        } else if threshold <= i64::MAX as u64 {\n            threshold as i64\n        } else {\n            i64::MAX\n        };\n\n        let inner = R::try_from_rng(&mut reseeder)?;\n\n        Ok(ReseedingCore {\n            inner,\n            reseeder,\n            threshold,\n            bytes_until_reseed: threshold,\n        })\n    }\n\n    /// Reseed the internal PRNG.\n    fn reseed(&mut self) -> Result<(), Rsdr::Error> {\n        R::try_from_rng(&mut self.reseeder).map(|result| {\n            self.bytes_until_reseed = self.threshold;\n            self.inner = result\n        })\n    }\n\n    #[inline(never)]\n    fn reseed_and_generate(&mut self, results: &mut <Self as BlockRngCore>::Results) {\n        trace!(\"Reseeding RNG (periodic reseed)\");\n\n        let num_bytes = size_of_val(results.as_ref());\n\n        if let Err(e) = self.reseed() {\n            warn!(\"Reseeding RNG failed: {}\", e);\n            let _ = e;\n        }\n\n        self.bytes_until_reseed = self.threshold - num_bytes as i64;\n        self.inner.generate(results);\n    }\n}"],"rngs::reseeding::ReseedingRng":["Debug","impl<R, Rsdr> Clone for ReseedingRng<R, Rsdr>\nwhere\n    R: BlockRngCore + SeedableRng + Clone,\n    Rsdr: TryRngCore + Clone,\n{\n    fn clone(&self) -> ReseedingRng<R, Rsdr> {\n        // Recreating `BlockRng` seems easier than cloning it and resetting\n        // the index.\n        ReseedingRng(BlockRng::new(self.0.core.clone()))\n    }\n}","impl<R, Rsdr> CryptoRng for ReseedingRng<R, Rsdr>\nwhere\n    R: BlockRngCore<Item = u32> + SeedableRng + CryptoBlockRng,\n    Rsdr: TryCryptoRng,\n{\n}","impl<R, Rsdr> ReseedingRng<R, Rsdr>\nwhere\n    R: BlockRngCore + SeedableRng,\n    Rsdr: TryRngCore,\n{\n    /// Create a new `ReseedingRng` from an existing PRNG, combined with a RNG\n    /// to use as reseeder.\n    ///\n    /// `threshold` sets the number of generated bytes after which to reseed the\n    /// PRNG. Set it to zero to never reseed based on the number of generated\n    /// values.\n    pub fn new(threshold: u64, reseeder: Rsdr) -> Result<Self, Rsdr::Error> {\n        Ok(ReseedingRng(BlockRng::new(ReseedingCore::new(\n            threshold, reseeder,\n        )?)))\n    }\n\n    /// Immediately reseed the generator\n    ///\n    /// This discards any remaining random data in the cache.\n    pub fn reseed(&mut self) -> Result<(), Rsdr::Error> {\n        self.0.reset();\n        self.0.core.reseed()\n    }\n}","impl<R, Rsdr> RngCore for ReseedingRng<R, Rsdr>\nwhere\n    R: BlockRngCore<Item = u32> + SeedableRng,\n    Rsdr: TryRngCore,\n{\n    #[inline(always)]\n    fn next_u32(&mut self) -> u32 {\n        self.0.next_u32()\n    }\n\n    #[inline(always)]\n    fn next_u64(&mut self) -> u64 {\n        self.0.next_u64()\n    }\n\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        self.0.fill_bytes(dest)\n    }\n}"],"rngs::small::SmallRng":["Clone","Debug","Eq","PartialEq","impl RngCore for SmallRng {\n    #[inline(always)]\n    fn next_u32(&mut self) -> u32 {\n        self.0.next_u32()\n    }\n\n    #[inline(always)]\n    fn next_u64(&mut self) -> u64 {\n        self.0.next_u64()\n    }\n\n    #[inline(always)]\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        self.0.fill_bytes(dest)\n    }\n}","impl SeedableRng for SmallRng {\n    // Fix to 256 bits. Changing this is a breaking change!\n    type Seed = [u8; 32];\n\n    #[inline(always)]\n    fn from_seed(seed: Self::Seed) -> Self {\n        // This is for compatibility with 32-bit platforms where Rng::Seed has a different seed size\n        // With MSRV >= 1.77: let seed = *seed.first_chunk().unwrap()\n        const LEN: usize = core::mem::size_of::<<Rng as SeedableRng>::Seed>();\n        let seed = (&seed[..LEN]).try_into().unwrap();\n        SmallRng(Rng::from_seed(seed))\n    }\n\n    #[inline(always)]\n    fn seed_from_u64(state: u64) -> Self {\n        SmallRng(Rng::seed_from_u64(state))\n    }\n}"],"rngs::std::StdRng":["Clone","Debug","Eq","PartialEq","impl CryptoRng for StdRng {}","impl RngCore for StdRng {\n    #[inline(always)]\n    fn next_u32(&mut self) -> u32 {\n        self.0.next_u32()\n    }\n\n    #[inline(always)]\n    fn next_u64(&mut self) -> u64 {\n        self.0.next_u64()\n    }\n\n    #[inline(always)]\n    fn fill_bytes(&mut self, dst: &mut [u8]) {\n        self.0.fill_bytes(dst)\n    }\n}","impl SeedableRng for StdRng {\n    // Fix to 256 bits. Changing this is a breaking change!\n    type Seed = [u8; 32];\n\n    #[inline(always)]\n    fn from_seed(seed: Self::Seed) -> Self {\n        StdRng(Rng::from_seed(seed))\n    }\n}"],"rngs::thread::ThreadRng":["Clone","impl CryptoRng for ThreadRng {}","impl Default for ThreadRng {\n    fn default() -> ThreadRng {\n        rng()\n    }\n}","impl RngCore for ThreadRng {\n    #[inline(always)]\n    fn next_u32(&mut self) -> u32 {\n        // SAFETY: We must make sure to stop using `rng` before anyone else\n        // creates another mutable reference\n        let rng = unsafe { &mut *self.rng.get() };\n        rng.next_u32()\n    }\n\n    #[inline(always)]\n    fn next_u64(&mut self) -> u64 {\n        // SAFETY: We must make sure to stop using `rng` before anyone else\n        // creates another mutable reference\n        let rng = unsafe { &mut *self.rng.get() };\n        rng.next_u64()\n    }\n\n    #[inline(always)]\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        // SAFETY: We must make sure to stop using `rng` before anyone else\n        // creates another mutable reference\n        let rng = unsafe { &mut *self.rng.get() };\n        rng.fill_bytes(dest)\n    }\n}","impl ThreadRng {\n    /// Immediately reseed the generator\n    ///\n    /// This discards any remaining random data in the cache.\n    pub fn reseed(&mut self) -> Result<(), rand_core::OsError> {\n        // SAFETY: We must make sure to stop using `rng` before anyone else\n        // creates another mutable reference\n        let rng = unsafe { &mut *self.rng.get() };\n        rng.reseed()\n    }\n}","impl fmt::Debug for ThreadRng {\n    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n        write!(fmt, \"ThreadRng {{ .. }}\")\n    }\n}"],"rngs::xoshiro256plusplus::Xoshiro256PlusPlus":["Clone","Debug","Eq","PartialEq","impl RngCore for Xoshiro256PlusPlus {\n    #[inline]\n    fn next_u32(&mut self) -> u32 {\n        // The lowest bits have some linear dependencies, so we use the\n        // upper bits instead.\n        let val = self.next_u64();\n        (val >> 32) as u32\n    }\n\n    #[inline]\n    fn next_u64(&mut self) -> u64 {\n        let res = self.s[0]\n            .wrapping_add(self.s[3])\n            .rotate_left(23)\n            .wrapping_add(self.s[0]);\n\n        let t = self.s[1] << 17;\n\n        self.s[2] ^= self.s[0];\n        self.s[3] ^= self.s[1];\n        self.s[1] ^= self.s[2];\n        self.s[0] ^= self.s[3];\n\n        self.s[2] ^= t;\n\n        self.s[3] = self.s[3].rotate_left(45);\n\n        res\n    }\n\n    #[inline]\n    fn fill_bytes(&mut self, dst: &mut [u8]) {\n        fill_bytes_via_next(self, dst)\n    }\n}","impl SeedableRng for Xoshiro256PlusPlus {\n    type Seed = [u8; 32];\n\n    /// Create a new `Xoshiro256PlusPlus`.  If `seed` is entirely 0, it will be\n    /// mapped to a different seed.\n    #[inline]\n    fn from_seed(seed: [u8; 32]) -> Xoshiro256PlusPlus {\n        let mut state = [0; 4];\n        read_u64_into(&seed, &mut state);\n        // Check for zero on aligned integers for better code generation.\n        // Furtermore, seed_from_u64(0) will expand to a constant when optimized.\n        if state.iter().all(|&x| x == 0) {\n            return Self::seed_from_u64(0);\n        }\n        Xoshiro256PlusPlus { s: state }\n    }\n\n    /// Create a new `Xoshiro256PlusPlus` from a `u64` seed.\n    ///\n    /// This uses the SplitMix64 generator internally.\n    #[inline]\n    fn seed_from_u64(mut state: u64) -> Self {\n        const PHI: u64 = 0x9e3779b97f4a7c15;\n        let mut s = [0; 4];\n        for i in s.iter_mut() {\n            state = state.wrapping_add(PHI);\n            let mut z = state;\n            z = (z ^ (z >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);\n            z = (z ^ (z >> 27)).wrapping_mul(0x94d049bb133111eb);\n            z = z ^ (z >> 31);\n            *i = z;\n        }\n        // By using a non-zero PHI we are guaranteed to generate a non-zero state\n        // Thus preventing a recursion between from_seed and seed_from_u64.\n        debug_assert_ne!(s, [0; 4]);\n        Xoshiro256PlusPlus { s }\n    }\n}"],"seq::coin_flipper::CoinFlipper":["impl<R: RngCore> CoinFlipper<R> {\n    pub fn new(rng: R) -> Self {\n        Self {\n            rng,\n            chunk: 0,\n            chunk_remaining: 0,\n        }\n    }\n\n    #[inline]\n    /// Returns true with a probability of 1 / d\n    /// Uses an expected two bits of randomness\n    /// Panics if d == 0\n    pub fn random_ratio_one_over(&mut self, d: usize) -> bool {\n        debug_assert_ne!(d, 0);\n        // This uses the same logic as `random_ratio` but is optimized for the case that\n        // the starting numerator is one (which it always is for `Sequence::Choose()`)\n\n        // In this case (but not `random_ratio`), this way of calculating c is always accurate\n        let c = (usize::BITS - 1 - d.leading_zeros()).min(32);\n\n        if self.flip_c_heads(c) {\n            let numerator = 1 << c;\n            self.random_ratio(numerator, d)\n        } else {\n            false\n        }\n    }\n\n    #[inline]\n    /// Returns true with a probability of n / d\n    /// Uses an expected two bits of randomness\n    fn random_ratio(&mut self, mut n: usize, d: usize) -> bool {\n        // Explanation:\n        // We are trying to return true with a probability of n / d\n        // If n >= d, we can just return true\n        // Otherwise there are two possibilities 2n < d and 2n >= d\n        // In either case we flip a coin.\n        // If 2n < d\n        //  If it comes up tails, return false\n        //  If it comes up heads, double n and start again\n        //  This is fair because (0.5 * 0) + (0.5 * 2n / d) = n / d and 2n is less than d\n        // (if 2n was greater than d we would effectively round it down to 1\n        // by returning true)\n        // If 2n >= d\n        //  If it comes up tails, set n to 2n - d and start again\n        //  If it comes up heads, return true\n        //  This is fair because (0.5 * 1) + (0.5 * (2n - d) / d) = n / d\n        //  Note that if 2n = d and the coin comes up tails, n will be set to 0\n        //  before restarting which is equivalent to returning false.\n\n        // As a performance optimization we can flip multiple coins at once\n        // This is efficient because we can use the `lzcnt` intrinsic\n        // We can check up to 32 flips at once but we only receive one bit of information\n        // - all heads or at least one tail.\n\n        // Let c be the number of coins to flip. 1 <= c <= 32\n        // If 2n < d, n * 2^c < d\n        // If the result is all heads, then set n to n * 2^c\n        // If there was at least one tail, return false\n        // If 2n >= d, the order of results matters so we flip one coin at a time so c = 1\n        // Ideally, c will be as high as possible within these constraints\n\n        while n < d {\n            // Find a good value for c by counting leading zeros\n            // This will either give the highest possible c, or 1 less than that\n            let c = n\n                .leading_zeros()\n                .saturating_sub(d.leading_zeros() + 1)\n                .clamp(1, 32);\n\n            if self.flip_c_heads(c) {\n                // All heads\n                // Set n to n * 2^c\n                // If 2n >= d, the while loop will exit and we will return `true`\n                // If n * 2^c > `usize::MAX` we always return `true` anyway\n                n = n.saturating_mul(2_usize.pow(c));\n            } else {\n                // At least one tail\n                if c == 1 {\n                    // Calculate 2n - d.\n                    // We need to use wrapping as 2n might be greater than `usize::MAX`\n                    let next_n = n.wrapping_add(n).wrapping_sub(d);\n                    if next_n == 0 || next_n > n {\n                        // This will happen if 2n < d\n                        return false;\n                    }\n                    n = next_n;\n                } else {\n                    // c > 1 so 2n < d so we can return false\n                    return false;\n                }\n            }\n        }\n        true\n    }\n\n    /// If the next `c` bits of randomness all represent heads, consume them, return true\n    /// Otherwise return false and consume the number of heads plus one.\n    /// Generates new bits of randomness when necessary (in 32 bit chunks)\n    /// Has a 1 in 2 to the `c` chance of returning true\n    /// `c` must be less than or equal to 32\n    fn flip_c_heads(&mut self, mut c: u32) -> bool {\n        debug_assert!(c <= 32);\n        // Note that zeros on the left of the chunk represent heads.\n        // It needs to be this way round because zeros are filled in when left shifting\n        loop {\n            let zeros = self.chunk.leading_zeros();\n\n            if zeros < c {\n                // The happy path - we found a 1 and can return false\n                // Note that because a 1 bit was detected,\n                // We cannot have run out of random bits so we don't need to check\n\n                // First consume all of the bits read\n                // Using shl seems to give worse performance for size-hinted iterators\n                self.chunk = self.chunk.wrapping_shl(zeros + 1);\n\n                self.chunk_remaining = self.chunk_remaining.saturating_sub(zeros + 1);\n                return false;\n            } else {\n                // The number of zeros is larger than `c`\n                // There are two possibilities\n                if let Some(new_remaining) = self.chunk_remaining.checked_sub(c) {\n                    // Those zeroes were all part of our random chunk,\n                    // throw away `c` bits of randomness and return true\n                    self.chunk_remaining = new_remaining;\n                    self.chunk <<= c;\n                    return true;\n                } else {\n                    // Some of those zeroes were part of the random chunk\n                    // and some were part of the space behind it\n                    // We need to take into account only the zeroes that were random\n                    c -= self.chunk_remaining;\n\n                    // Generate a new chunk\n                    self.chunk = self.rng.next_u32();\n                    self.chunk_remaining = 32;\n                    // Go back to start of loop\n                }\n            }\n        }\n    }\n}"],"seq::increasing_uniform::IncreasingUniform":["impl<R: RngCore> IncreasingUniform<R> {\n    /// Create a dice roller.\n    /// The next item returned will be a random number in the range [0,n]\n    pub fn new(rng: R, n: u32) -> Self {\n        // If n = 0, the first number returned will always be 0\n        // so we don't need to generate a random number\n        let chunk_remaining = if n == 0 { 1 } else { 0 };\n        Self {\n            rng,\n            n,\n            chunk: 0,\n            chunk_remaining,\n        }\n    }\n\n    /// Returns a number in [0,n] and increments n by 1.\n    /// Generates new random bits as needed\n    /// Panics if `n >= u32::MAX`\n    #[inline]\n    pub fn next_index(&mut self) -> usize {\n        let next_n = self.n + 1;\n\n        // There's room for further optimisation here:\n        // random_range uses rejection sampling (or other method; see #1196) to avoid bias.\n        // When the initial sample is biased for range 0..bound\n        // it may still be viable to use for a smaller bound\n        // (especially if small biases are considered acceptable).\n\n        let next_chunk_remaining = self.chunk_remaining.checked_sub(1).unwrap_or_else(|| {\n            // If the chunk is empty, generate a new chunk\n            let (bound, remaining) = calculate_bound_u32(next_n);\n            // bound = (n + 1) * (n + 2) *..* (n + remaining)\n            self.chunk = self.rng.random_range(..bound);\n            // Chunk is a random number in\n            // [0, (n + 1) * (n + 2) *..* (n + remaining) )\n\n            remaining - 1\n        });\n\n        let result = if next_chunk_remaining == 0 {\n            // `chunk` is a random number in the range [0..n+1)\n            // Because `chunk_remaining` is about to be set to zero\n            // we do not need to clear the chunk here\n            self.chunk as usize\n        } else {\n            // `chunk` is a random number in a range that is a multiple of n+1\n            // so r will be a random number in [0..n+1)\n            let r = self.chunk % next_n;\n            self.chunk /= next_n;\n            r as usize\n        };\n\n        self.chunk_remaining = next_chunk_remaining;\n        self.n = next_n;\n        result\n    }\n}"],"seq::index_::IndexVec":["Clone","Debug","impl From<Vec<u32>> for IndexVec {\n    #[inline]\n    fn from(v: Vec<u32>) -> Self {\n        IndexVec::U32(v)\n    }\n}","impl From<Vec<u64>> for IndexVec {\n    #[inline]\n    fn from(v: Vec<u64>) -> Self {\n        IndexVec::U64(v)\n    }\n}","impl IndexVec {\n    /// Returns the number of indices\n    #[inline]\n    pub fn len(&self) -> usize {\n        match self {\n            IndexVec::U32(v) => v.len(),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => v.len(),\n        }\n    }\n\n    /// Returns `true` if the length is 0.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        match self {\n            IndexVec::U32(v) => v.is_empty(),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => v.is_empty(),\n        }\n    }\n\n    /// Return the value at the given `index`.\n    ///\n    /// (Note: we cannot implement [`std::ops::Index`] because of lifetime\n    /// restrictions.)\n    #[inline]\n    pub fn index(&self, index: usize) -> usize {\n        match self {\n            IndexVec::U32(v) => v[index] as usize,\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => v[index] as usize,\n        }\n    }\n\n    /// Return result as a `Vec<usize>`. Conversion may or may not be trivial.\n    #[inline]\n    pub fn into_vec(self) -> Vec<usize> {\n        match self {\n            IndexVec::U32(v) => v.into_iter().map(|i| i as usize).collect(),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => v.into_iter().map(|i| i as usize).collect(),\n        }\n    }\n\n    /// Iterate over the indices as a sequence of `usize` values\n    #[inline]\n    pub fn iter(&self) -> IndexVecIter<'_> {\n        match self {\n            IndexVec::U32(v) => IndexVecIter::U32(v.iter()),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => IndexVecIter::U64(v.iter()),\n        }\n    }\n}","impl IntoIterator for IndexVec {\n    type IntoIter = IndexVecIntoIter;\n    type Item = usize;\n\n    /// Convert into an iterator over the indices as a sequence of `usize` values\n    #[inline]\n    fn into_iter(self) -> IndexVecIntoIter {\n        match self {\n            IndexVec::U32(v) => IndexVecIntoIter::U32(v.into_iter()),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => IndexVecIntoIter::U64(v.into_iter()),\n        }\n    }\n}","impl PartialEq for IndexVec {\n    fn eq(&self, other: &IndexVec) -> bool {\n        use self::IndexVec::*;\n        match (self, other) {\n            (U32(v1), U32(v2)) => v1 == v2,\n            #[cfg(target_pointer_width = \"64\")]\n            (U64(v1), U64(v2)) => v1 == v2,\n            #[cfg(target_pointer_width = \"64\")]\n            (U32(v1), U64(v2)) => {\n                (v1.len() == v2.len()) && (v1.iter().zip(v2.iter()).all(|(x, y)| *x as u64 == *y))\n            }\n            #[cfg(target_pointer_width = \"64\")]\n            (U64(v1), U32(v2)) => {\n                (v1.len() == v2.len()) && (v1.iter().zip(v2.iter()).all(|(x, y)| *x == *y as u64))\n            }\n        }\n    }\n}"],"seq::index_::IndexVecIntoIter":["Clone","Debug","impl ExactSizeIterator for IndexVecIntoIter {}","impl Iterator for IndexVecIntoIter {\n    type Item = usize;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        use self::IndexVecIntoIter::*;\n        match self {\n            U32(v) => v.next().map(|i| i as usize),\n            #[cfg(target_pointer_width = \"64\")]\n            U64(v) => v.next().map(|i| i as usize),\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        use self::IndexVecIntoIter::*;\n        match self {\n            U32(v) => v.size_hint(),\n            #[cfg(target_pointer_width = \"64\")]\n            U64(v) => v.size_hint(),\n        }\n    }\n}"],"seq::index_::IndexVecIter":["Debug","impl ExactSizeIterator for IndexVecIter<'_> {}","impl Iterator for IndexVecIter<'_> {\n    type Item = usize;\n\n    #[inline]\n    fn next(&mut self) -> Option<usize> {\n        use self::IndexVecIter::*;\n        match self {\n            U32(iter) => iter.next().map(|i| *i as usize),\n            #[cfg(target_pointer_width = \"64\")]\n            U64(iter) => iter.next().map(|i| *i as usize),\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self {\n            IndexVecIter::U32(v) => v.size_hint(),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVecIter::U64(v) => v.size_hint(),\n        }\n    }\n}"],"seq::index_::sample_efraimidis_spirakis::Element":["impl<N> Eq for Element<N> {}","impl<N> Ord for Element<N> {\n        fn cmp(&self, other: &Self) -> Ordering {\n            // unwrap() should not panic since weights should not be NaN\n            // We reverse so that BinaryHeap::peek shows the smallest item\n            self.key.partial_cmp(&other.key).unwrap().reverse()\n        }\n    }","impl<N> PartialEq for Element<N> {\n        fn eq(&self, other: &Self) -> bool {\n            self.key == other.key\n        }\n    }","impl<N> PartialOrd for Element<N> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }\n    }"],"seq::slice::SliceChooseIter":["Debug","impl<'a, S: Index<usize, Output = T> + ?Sized + 'a, T: 'a> ExactSizeIterator\n    for SliceChooseIter<'a, S, T>\n{\n    fn len(&self) -> usize {\n        self.indices.len()\n    }\n}","impl<'a, S: Index<usize, Output = T> + ?Sized + 'a, T: 'a> Iterator for SliceChooseIter<'a, S, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        // TODO: investigate using SliceIndex::get_unchecked when stable\n        self.indices.next().map(|i| &self.slice[i])\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (self.indices.len(), Some(self.indices.len()))\n    }\n}"]},"single_path_import":{"distr::bernoulli::Bernoulli":"distr::Bernoulli","distr::bernoulli::BernoulliError":"distr::BernoulliError","distr::distribution::Distribution":"prelude::Distribution","distr::distribution::Iter":"distr::Iter","distr::distribution::Map":"distr::Map","distr::distribution::SampleString":"distr::SampleString","distr::float::IntoFloat":"distr::hidden_export::IntoFloat","distr::float::Open01":"distr::Open01","distr::float::OpenClosed01":"distr::OpenClosed01","distr::other::Alphabetic":"distr::Alphabetic","distr::other::Alphanumeric":"distr::Alphanumeric","distr::uniform::Uniform":"distr::Uniform","distr::uniform::float::UniformFloat":"distr::uniform::UniformFloat","distr::uniform::int::UniformInt":"distr::uniform::UniformInt","distr::uniform::int::UniformUsize":"distr::uniform::UniformUsize","distr::uniform::other::UniformChar":"distr::uniform::UniformChar","distr::uniform::other::UniformDuration":"distr::uniform::UniformDuration","distr::weighted::Error":"seq::Error","distr::weighted::weighted_index::WeightedIndex":"distr::weighted::WeightedIndex","rand_core":"rand_core","rand_core::CryptoRng":"prelude::CryptoRng","rand_core::OsRng":"rngs::OsRng","rand_core::RngCore":"prelude::RngCore","rand_core::SeedableRng":"prelude::SeedableRng","rand_core::TryCryptoRng":"TryCryptoRng","rand_core::TryRngCore":"TryRngCore","rng::Fill":"Fill","rng::Rng":"Rng","rngs::reseeding::ReseedingRng":"rngs::ReseedingRng","rngs::small::SmallRng":"rngs::SmallRng","rngs::std::StdRng":"rngs::StdRng","rngs::thread::ThreadRng":"rngs::ThreadRng","rngs::thread::rng":"rng","seq::iterator::IteratorRandom":"seq::IteratorRandom","seq::slice::IndexedMutRandom":"seq::IndexedMutRandom","seq::slice::IndexedRandom":"seq::IndexedRandom","seq::slice::SliceChooseIter":"seq::SliceChooseIter","seq::slice::SliceRandom":"seq::SliceRandom"},"srcs":{"<&Borrowed as distr::uniform::SampleBorrow<Borrowed>>::borrow":["#[inline(always)]\nfn borrow(&self) -> &Borrowed{\n        self\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<&D as distr::distribution::Distribution<T>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> T{\n        (*self).sample(rng)\n    }","Real(LocalPath(\"src/distr/distribution.rs\"))"],"<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::borrow":["#[inline(always)]\nfn borrow(&self) -> &Borrowed{\n        self\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<[T; N] as rng::Fill>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n        <[T] as Fill>::fill(self, rng)\n    }","Real(LocalPath(\"src/rng.rs\"))"],"<[T] as seq::slice::IndexedRandom>::len":["fn len(&self) -> usize{\n        self.len()\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"<[T] as seq::slice::SliceRandom>::partial_shuffle":["fn partial_shuffle<R>(&mut self, rng: &mut R, amount: usize) -> (&mut [T], &mut [T])\n    where\n        R: Rng + ?Sized,{\n        let m = self.len().saturating_sub(amount);\n\n        // The algorithm below is based on Durstenfeld's algorithm for the\n        // [FisherYates shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm)\n        // for an unbiased permutation.\n        // It ensures that the last `amount` elements of the slice\n        // are randomly selected from the whole slice.\n\n        // `IncreasingUniform::next_index()` is faster than `Rng::random_range`\n        // but only works for 32 bit integers\n        // So we must use the slow method if the slice is longer than that.\n        if self.len() < (u32::MAX as usize) {\n            let mut chooser = IncreasingUniform::new(rng, m as u32);\n            for i in m..self.len() {\n                let index = chooser.next_index();\n                self.swap(i, index);\n            }\n        } else {\n            for i in m..self.len() {\n                let index = rng.random_range(..i + 1);\n                self.swap(i, index);\n            }\n        }\n        let r = self.split_at_mut(m);\n        (r.1, r.0)\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"<[T] as seq::slice::SliceRandom>::shuffle":["fn shuffle<R>(&mut self, rng: &mut R)\n    where\n        R: Rng + ?Sized,{\n        if self.len() <= 1 {\n            // There is no need to shuffle an empty or single element slice\n            return;\n        }\n        self.partial_shuffle(rng, self.len());\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"<[bool] as rng::Fill>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                for elt in self.iter_mut() {\n                    *elt = rng.random();\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"<[char] as rng::Fill>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                for elt in self.iter_mut() {\n                    *elt = rng.random();\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"<[f32] as rng::Fill>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                for elt in self.iter_mut() {\n                    *elt = rng.random();\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"<[f64] as rng::Fill>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                for elt in self.iter_mut() {\n                    *elt = rng.random();\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"<[u8] as rng::Fill>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n        rng.fill_bytes(self)\n    }","Real(LocalPath(\"src/rng.rs\"))"],"<bool as distr::utils::BoolAsSIMD>::any":["#[inline(always)]\nfn any(self) -> bool{\n        self\n    }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<core::ops::Range<T> as distr::uniform::SampleRange<T>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n        !(self.start < self.end)\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::Range<T> as distr::uniform::SampleRange<T>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<T, Error>{\n        T::Sampler::sample_single(self.start, self.end, rng)\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeInclusive<T> as distr::uniform::SampleRange<T>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n        !(self.start() <= self.end())\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeInclusive<T> as distr::uniform::SampleRange<T>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<T, Error>{\n        T::Sampler::sample_single_inclusive(self.start(), self.end(), rng)\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<u128> as distr::uniform::SampleRange<u128>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                0 == self.end\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<u128> as distr::uniform::SampleRange<u128>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<u16> as distr::uniform::SampleRange<u16>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                0 == self.end\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<u16> as distr::uniform::SampleRange<u16>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<u32> as distr::uniform::SampleRange<u32>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                0 == self.end\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<u32> as distr::uniform::SampleRange<u32>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<u64> as distr::uniform::SampleRange<u64>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                0 == self.end\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<u64> as distr::uniform::SampleRange<u64>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<u8> as distr::uniform::SampleRange<u8>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                0 == self.end\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<u8> as distr::uniform::SampleRange<u8>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<usize> as distr::uniform::SampleRange<usize>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                0 == self.end\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeTo<usize> as distr::uniform::SampleRange<usize>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<u128> as distr::uniform::SampleRange<u128>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                false\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<u128> as distr::uniform::SampleRange<u128>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single_inclusive(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<u16> as distr::uniform::SampleRange<u16>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                false\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<u16> as distr::uniform::SampleRange<u16>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single_inclusive(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<u32> as distr::uniform::SampleRange<u32>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                false\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<u32> as distr::uniform::SampleRange<u32>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single_inclusive(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<u64> as distr::uniform::SampleRange<u64>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                false\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<u64> as distr::uniform::SampleRange<u64>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single_inclusive(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<u8> as distr::uniform::SampleRange<u8>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                false\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<u8> as distr::uniform::SampleRange<u8>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single_inclusive(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<usize> as distr::uniform::SampleRange<usize>>::is_empty":["#[inline]\nfn is_empty(&self) -> bool{\n                false\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<core::ops::RangeToInclusive<usize> as distr::uniform::SampleRange<usize>>::sample_single":["#[inline]\nfn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<$t, Error>{\n                <$t as SampleUniform>::Sampler::sample_single_inclusive(0, self.end, rng)\n            }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<distr::bernoulli::Bernoulli as distr::distribution::Distribution<bool>>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> bool{\n        // Make sure to always return true for p = 1.0.\n        if self.p_int == ALWAYS_TRUE {\n            return true;\n        }\n        let v: u64 = rng.random();\n        v < self.p_int\n    }","Real(LocalPath(\"src/distr/bernoulli.rs\"))"],"<distr::bernoulli::BernoulliError as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(match self {\n            BernoulliError::InvalidProbability => \"p is outside [0, 1] in Bernoulli distribution\",\n        })\n    }","Real(LocalPath(\"src/distr/bernoulli.rs\"))"],"<distr::distribution::Iter<D, R, T> as core::iter::Iterator>::next":["#[inline(always)]\nfn next(&mut self) -> Option<T>{\n        // Here, self.rng may be a reference, but we must take &mut anyway.\n        // Even if sample could take an R: Rng by value, we would need to do this\n        // since Rng is not copyable and we cannot enforce that this is \"reborrowable\".\n        Some(self.distr.sample(&mut self.rng))\n    }","Real(LocalPath(\"src/distr/distribution.rs\"))"],"<distr::distribution::Iter<D, R, T> as core::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (usize::MAX, None)\n    }","Real(LocalPath(\"src/distr/distribution.rs\"))"],"<distr::distribution::Map<D, F, T, S> as distr::distribution::Distribution<S>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> S{\n        (self.func)(self.distr.sample(rng))\n    }","Real(LocalPath(\"src/distr/distribution.rs\"))"],"<distr::float::Open01 as distr::distribution::Distribution<f32>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                // Transmute-based method; 23/52 random bits; (0, 1) interval.\n                // We use the most significant bits because for simple RNGs\n                // those are usually more random.\n                let float_size = mem::size_of::<$f_scalar>() as $u_scalar * 8;\n\n                let value: $uty = rng.random();\n                let fraction = value >> $uty::splat(float_size - $fraction_bits);\n                fraction.into_float_with_exponent(0) - $ty::splat(1.0 - $f_scalar::EPSILON / 2.0)\n            }","Real(LocalPath(\"src/distr/float.rs\"))"],"<distr::float::Open01 as distr::distribution::Distribution<f64>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                // Transmute-based method; 23/52 random bits; (0, 1) interval.\n                // We use the most significant bits because for simple RNGs\n                // those are usually more random.\n                let float_size = mem::size_of::<$f_scalar>() as $u_scalar * 8;\n\n                let value: $uty = rng.random();\n                let fraction = value >> $uty::splat(float_size - $fraction_bits);\n                fraction.into_float_with_exponent(0) - $ty::splat(1.0 - $f_scalar::EPSILON / 2.0)\n            }","Real(LocalPath(\"src/distr/float.rs\"))"],"<distr::float::OpenClosed01 as distr::distribution::Distribution<f32>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                // Multiply-based method; 24/53 random bits; (0, 1] interval.\n                // We use the most significant bits because for simple RNGs\n                // those are usually more random.\n                let float_size = mem::size_of::<$f_scalar>() as $u_scalar * 8;\n                let precision = $fraction_bits + 1;\n                let scale = 1.0 / ((1 as $u_scalar << precision) as $f_scalar);\n\n                let value: $uty = rng.random();\n                let value = value >> $uty::splat(float_size - precision);\n                // Add 1 to shift up; will not overflow because of right-shift:\n                $ty::splat(scale) * $ty::cast_from_int(value + $uty::splat(1))\n            }","Real(LocalPath(\"src/distr/float.rs\"))"],"<distr::float::OpenClosed01 as distr::distribution::Distribution<f64>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                // Multiply-based method; 24/53 random bits; (0, 1] interval.\n                // We use the most significant bits because for simple RNGs\n                // those are usually more random.\n                let float_size = mem::size_of::<$f_scalar>() as $u_scalar * 8;\n                let precision = $fraction_bits + 1;\n                let scale = 1.0 / ((1 as $u_scalar << precision) as $f_scalar);\n\n                let value: $uty = rng.random();\n                let value = value >> $uty::splat(float_size - precision);\n                // Add 1 to shift up; will not overflow because of right-shift:\n                $ty::splat(scale) * $ty::cast_from_int(value + $uty::splat(1))\n            }","Real(LocalPath(\"src/distr/float.rs\"))"],"<distr::other::Alphabetic as distr::distribution::Distribution<u8>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u8{\n        const RANGE: u8 = 26 + 26;\n\n        let offset = rng.random_range(0..RANGE) + b'A';\n\n        // Account for upper-cases\n        offset + (offset > b'Z') as u8 * (b'a' - b'Z' - 1)\n    }","Real(LocalPath(\"src/distr/other.rs\"))"],"<distr::other::Alphabetic as distr::distribution::SampleString>::append_string":["fn append_string<R: Rng + ?Sized>(&self, rng: &mut R, string: &mut String, len: usize){\n        // SAFETY: With this distribution we guarantee that we're working with valid ASCII\n        // characters.\n        // See [#1590](https://github.com/rust-random/rand/issues/1590).\n        unsafe {\n            let v = string.as_mut_vec();\n            v.reserve_exact(len);\n            v.extend(self.sample_iter(rng).take(len));\n        }\n    }","Real(LocalPath(\"src/distr/other.rs\"))"],"<distr::other::Alphanumeric as distr::distribution::Distribution<u8>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u8{\n        const RANGE: u32 = 26 + 26 + 10;\n        const GEN_ASCII_STR_CHARSET: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                abcdefghijklmnopqrstuvwxyz\\\n                0123456789\";\n        // We can pick from 62 characters. This is so close to a power of 2, 64,\n        // that we can do better than `Uniform`. Use a simple bitshift and\n        // rejection sampling. We do not use a bitmask, because for small RNGs\n        // the most significant bits are usually of higher quality.\n        loop {\n            let var = rng.next_u32() >> (32 - 6);\n            if var < RANGE {\n                return GEN_ASCII_STR_CHARSET[var as usize];\n            }\n        }\n    }","Real(LocalPath(\"src/distr/other.rs\"))"],"<distr::other::Alphanumeric as distr::distribution::SampleString>::append_string":["fn append_string<R: Rng + ?Sized>(&self, rng: &mut R, string: &mut String, len: usize){\n        // SAFETY: `self` only samples alphanumeric characters, which are valid UTF-8.\n        unsafe {\n            let v = string.as_mut_vec();\n            v.extend(\n                self.sample_iter(rng)\n                    .take(len)\n                    .inspect(|b| debug_assert!(b.is_ascii_alphanumeric())),\n            );\n        }\n    }","Real(LocalPath(\"src/distr/other.rs\"))"],"<distr::slice::Choose<'_, char> as distr::distribution::SampleString>::append_string":["fn append_string<R: crate::Rng + ?Sized>(&self, rng: &mut R, string: &mut String, len: usize){\n        // Get the max char length to minimize extra space.\n        // Limit this check to avoid searching for long slice.\n        let max_char_len = if self.slice.len() < 200 {\n            self.slice\n                .iter()\n                .try_fold(1, |max_len, char| {\n                    // When the current max_len is 4, the result max_char_len will be 4.\n                    Some(max_len.max(char.len_utf8())).filter(|len| *len < 4)\n                })\n                .unwrap_or(4)\n        } else {\n            4\n        };\n\n        // Split the extension of string to reuse the unused capacities.\n        // Skip the split for small length or only ascii slice.\n        let mut extend_len = if max_char_len == 1 || len < 100 {\n            len\n        } else {\n            len / 4\n        };\n        let mut remain_len = len;\n        while extend_len > 0 {\n            string.reserve(max_char_len * extend_len);\n            string.extend(self.sample_iter(&mut *rng).take(extend_len));\n            remain_len -= extend_len;\n            extend_len = extend_len.min(remain_len);\n        }\n    }","Real(LocalPath(\"src/distr/slice.rs\"))"],"<distr::slice::Choose<'a, T> as distr::distribution::Distribution<&'a T>>::sample":["fn sample<R: crate::Rng + ?Sized>(&self, rng: &mut R) -> &'a T{\n        let idx = self.range.sample(rng);\n\n        debug_assert!(\n            idx < self.slice.len(),\n            \"Uniform::new(0, {}) somehow returned {}\",\n            self.slice.len(),\n            idx\n        );\n\n        // Safety: at construction time, it was ensured that the slice was\n        // non-empty, and that the `Uniform` range produces values in range\n        // for the slice\n        unsafe { self.slice.get_unchecked(idx) }\n    }","Real(LocalPath(\"src/distr/slice.rs\"))"],"<distr::slice::Empty as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        write!(\n            f,\n            \"Tried to create a `rand::distr::slice::Choose` with an empty slice\"\n        )\n    }","Real(LocalPath(\"src/distr/slice.rs\"))"],"<distr::uniform::Error as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(match self {\n            Error::EmptyRange => \"low > high (or equal if exclusive) in uniform distribution\",\n            Error::NonFinite => \"Non-finite range in uniform distribution\",\n        })\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<distr::uniform::Uniform<X> as core::convert::TryFrom<core::ops::Range<X>>>::try_from":["fn try_from(r: Range<X>) -> Result<Uniform<X>, Error>{\n        Uniform::new(r.start, r.end)\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<distr::uniform::Uniform<X> as core::convert::TryFrom<core::ops::RangeInclusive<X>>>::try_from":["fn try_from(r: ::core::ops::RangeInclusive<X>) -> Result<Uniform<X>, Error>{\n        Uniform::new_inclusive(r.start(), r.end())\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<distr::uniform::Uniform<X> as distr::distribution::Distribution<X>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> X{\n        self.0.sample(rng)\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::new":["fn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                #[cfg(debug_assertions)]\n                if !(low.all_finite()) || !(high.all_finite()) {\n                    return Err(Error::NonFinite);\n                }\n                if !(low.all_lt(high)) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let scale = high - low;\n                if !(scale.all_finite()) {\n                    return Err(Error::NonFinite);\n                }\n\n                Ok(Self::new_bounded(low, high, scale))\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::new_inclusive":["fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                #[cfg(debug_assertions)]\n                if !(low.all_finite()) || !(high.all_finite()) {\n                    return Err(Error::NonFinite);\n                }\n                if !low.all_le(high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let max_rand = <$ty>::splat(1.0 as $f_scalar - $f_scalar::EPSILON);\n                let scale = (high - low) / max_rand;\n                if !scale.all_finite() {\n                    return Err(Error::NonFinite);\n                }\n\n                Ok(Self::new_bounded(low, high, scale))\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                // Generate a value in the range [1, 2)\n                let value1_2 = (rng.random::<$uty>() >> $uty::splat($bits_to_discard)).into_float_with_exponent(0);\n\n                // Get a value in the range [0, 1) to avoid overflow when multiplying by scale\n                let value0_1 = value1_2 - <$ty>::splat(1.0);\n\n                // We don't use `f64::mul_add`, because it is not available with\n                // `no_std`. Furthermore, it is slower for some targets (but\n                // faster for others). However, the order of multiplication and\n                // addition is important, because on some platforms (e.g. ARM)\n                // it will be optimized to a single (non-FMA) instruction.\n                value0_1 * self.scale + self.low\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                Self::sample_single_inclusive(low_b, high_b, rng)\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::sample_single_inclusive":["#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                #[cfg(debug_assertions)]\n                if !low.all_finite() || !high.all_finite() {\n                    return Err(Error::NonFinite);\n                }\n                if !low.all_le(high) {\n                    return Err(Error::EmptyRange);\n                }\n                let scale = high - low;\n                if !scale.all_finite() {\n                    return Err(Error::NonFinite);\n                }\n\n                // Generate a value in the range [1, 2)\n                let value1_2 =\n                    (rng.random::<$uty>() >> $uty::splat($bits_to_discard)).into_float_with_exponent(0);\n\n                // Get a value in the range [0, 1) to avoid overflow when multiplying by scale\n                let value0_1 = value1_2 - <$ty>::splat(1.0);\n\n                // Doing multiply before addition allows some architectures\n                // to use a single instruction.\n                Ok(value0_1 * scale + low)\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::new":["fn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                #[cfg(debug_assertions)]\n                if !(low.all_finite()) || !(high.all_finite()) {\n                    return Err(Error::NonFinite);\n                }\n                if !(low.all_lt(high)) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let scale = high - low;\n                if !(scale.all_finite()) {\n                    return Err(Error::NonFinite);\n                }\n\n                Ok(Self::new_bounded(low, high, scale))\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::new_inclusive":["fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                #[cfg(debug_assertions)]\n                if !(low.all_finite()) || !(high.all_finite()) {\n                    return Err(Error::NonFinite);\n                }\n                if !low.all_le(high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let max_rand = <$ty>::splat(1.0 as $f_scalar - $f_scalar::EPSILON);\n                let scale = (high - low) / max_rand;\n                if !scale.all_finite() {\n                    return Err(Error::NonFinite);\n                }\n\n                Ok(Self::new_bounded(low, high, scale))\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                // Generate a value in the range [1, 2)\n                let value1_2 = (rng.random::<$uty>() >> $uty::splat($bits_to_discard)).into_float_with_exponent(0);\n\n                // Get a value in the range [0, 1) to avoid overflow when multiplying by scale\n                let value0_1 = value1_2 - <$ty>::splat(1.0);\n\n                // We don't use `f64::mul_add`, because it is not available with\n                // `no_std`. Furthermore, it is slower for some targets (but\n                // faster for others). However, the order of multiplication and\n                // addition is important, because on some platforms (e.g. ARM)\n                // it will be optimized to a single (non-FMA) instruction.\n                value0_1 * self.scale + self.low\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                Self::sample_single_inclusive(low_b, high_b, rng)\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::sample_single_inclusive":["#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                #[cfg(debug_assertions)]\n                if !low.all_finite() || !high.all_finite() {\n                    return Err(Error::NonFinite);\n                }\n                if !low.all_le(high) {\n                    return Err(Error::EmptyRange);\n                }\n                let scale = high - low;\n                if !scale.all_finite() {\n                    return Err(Error::NonFinite);\n                }\n\n                // Generate a value in the range [1, 2)\n                let value1_2 =\n                    (rng.random::<$uty>() >> $uty::splat($bits_to_discard)).into_float_with_exponent(0);\n\n                // Get a value in the range [0, 1) to avoid overflow when multiplying by scale\n                let value0_1 = value1_2 - <$ty>::splat(1.0);\n\n                // Doing multiply before addition allows some architectures\n                // to use a single instruction.\n                Ok(value0_1 * scale + low)\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::sample":["/// Sample from distribution, Lemire's method, unbiased\n#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::sample_single_inclusive":["/// Sample single value, Canon's method, biased\n///\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n#[cfg(not(feature = \"unbiased\"))]\n#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::sample":["/// Sample from distribution, Lemire's method, unbiased\n#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::sample_single_inclusive":["/// Sample single value, Canon's method, biased\n///\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n#[cfg(not(feature = \"unbiased\"))]\n#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::sample":["/// Sample from distribution, Lemire's method, unbiased\n#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::sample_single_inclusive":["/// Sample single value, Canon's method, biased\n///\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n#[cfg(not(feature = \"unbiased\"))]\n#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::sample":["/// Sample from distribution, Lemire's method, unbiased\n#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::sample_single_inclusive":["/// Sample single value, Canon's method, biased\n///\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n#[cfg(not(feature = \"unbiased\"))]\n#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::sample":["/// Sample from distribution, Lemire's method, unbiased\n#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::sample_single_inclusive":["/// Sample single value, Canon's method, biased\n///\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n#[cfg(not(feature = \"unbiased\"))]\n#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::sample":["/// Sample from distribution, Lemire's method, unbiased\n#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::sample_single_inclusive":["/// Sample single value, Canon's method, biased\n///\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n#[cfg(not(feature = \"unbiased\"))]\n#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::sample":["/// Sample from distribution, Lemire's method, unbiased\n#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::sample_single_inclusive":["/// Sample single value, Canon's method, biased\n///\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n#[cfg(not(feature = \"unbiased\"))]\n#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::sample":["/// Sample from distribution, Lemire's method, unbiased\n#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::sample_single_inclusive":["/// Sample single value, Canon's method, biased\n///\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n#[cfg(not(feature = \"unbiased\"))]\n#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::sample":["/// Sample from distribution, Lemire's method, unbiased\n#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::sample_single_inclusive":["/// Sample single value, Canon's method, biased\n///\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n#[cfg(not(feature = \"unbiased\"))]\n#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                UniformSampler::new_inclusive(low, high - 1)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty;\n                let thresh = if range > 0 {\n                    let range = $sample_ty::from(range);\n                    (range.wrapping_neg() % range)\n                } else {\n                    0\n                };\n\n                Ok(UniformInt {\n                    low,\n                    range: range as $ty,           // type: $uty\n                    thresh: thresh as $uty as $ty, // type: $sample_ty\n                })\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::sample":["/// Sample from distribution, Lemire's method, unbiased\n#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n                let range = self.range as $uty as $sample_ty;\n                if range == 0 {\n                    return rng.random();\n                }\n\n                let thresh = self.thresh as $uty as $sample_ty;\n                let hi = loop {\n                    let (hi, lo) = rng.random::<$sample_ty>().wmul(range);\n                    if lo >= thresh {\n                        break hi;\n                    }\n                };\n                self.low.wrapping_add(hi as $ty)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low < high) {\n                    return Err(Error::EmptyRange);\n                }\n                Self::sample_single_inclusive(low, high - 1, rng)\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::sample_single_inclusive":["/// Sample single value, Canon's method, biased\n///\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8`), 48 (`i16`), 96 (`i32`), 64 (`i64`), 128 (`i128`).\n#[cfg(not(feature = \"unbiased\"))]\n#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n                low_b: B1,\n                high_b: B2,\n                rng: &mut R,\n            ) -> Result<Self::X, Error>\n            where\n                B1: SampleBorrow<Self::X> + Sized,\n                B2: SampleBorrow<Self::X> + Sized,{\n                let low = *low_b.borrow();\n                let high = *high_b.borrow();\n                if !(low <= high) {\n                    return Err(Error::EmptyRange);\n                }\n                let range = high.wrapping_sub(low).wrapping_add(1) as $uty as $sample_ty;\n                if range == 0 {\n                    // Range is MAX+1 (unrepresentable), so we need a special case\n                    return Ok(rng.random());\n                }\n\n                // generate a sample using a sensible integer type\n                let (mut result, lo_order) = rng.random::<$sample_ty>().wmul(range);\n\n                // if the sample is biased...\n                if lo_order > range.wrapping_neg() {\n                    // ...generate a new sample to reduce bias...\n                    let (new_hi_order, _) = (rng.random::<$sample_ty>()).wmul(range as $sample_ty);\n                    // ... incrementing result on overflow\n                    let is_overflow = lo_order.checked_add(new_hi_order as $sample_ty).is_none();\n                    result += is_overflow as $sample_ty;\n                }\n\n                Ok(low.wrapping_add(result as $ty))\n            }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,{\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low < high) {\n            return Err(Error::EmptyRange);\n        }\n\n        UniformSampler::new_inclusive(low, high - 1)\n    }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,{\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low <= high) {\n            return Err(Error::EmptyRange);\n        }\n\n        #[cfg(target_pointer_width = \"64\")]\n        let mode64 = high > (u32::MAX as usize);\n        #[cfg(target_pointer_width = \"32\")]\n        let mode64 = false;\n\n        let (range, thresh);\n        if cfg!(target_pointer_width = \"64\") && !mode64 {\n            let range32 = (high as u32).wrapping_sub(low as u32).wrapping_add(1);\n            range = range32 as usize;\n            thresh = if range32 > 0 {\n                (range32.wrapping_neg() % range32) as usize\n            } else {\n                0\n            };\n        } else {\n            range = high.wrapping_sub(low).wrapping_add(1);\n            thresh = if range > 0 {\n                range.wrapping_neg() % range\n            } else {\n                0\n            };\n        }\n\n        Ok(UniformUsize {\n            low,\n            range,\n            thresh,\n            #[cfg(target_pointer_width = \"64\")]\n            mode64,\n        })\n    }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> usize{\n        #[cfg(target_pointer_width = \"32\")]\n        let mode32 = true;\n        #[cfg(target_pointer_width = \"64\")]\n        let mode32 = !self.mode64;\n\n        if mode32 {\n            let range = self.range as u32;\n            if range == 0 {\n                return rng.random::<u32>() as usize;\n            }\n\n            let thresh = self.thresh as u32;\n            let hi = loop {\n                let (hi, lo) = rng.random::<u32>().wmul(range);\n                if lo >= thresh {\n                    break hi;\n                }\n            };\n            self.low.wrapping_add(hi as usize)\n        } else {\n            let range = self.range as u64;\n            if range == 0 {\n                return rng.random::<u64>() as usize;\n            }\n\n            let thresh = self.thresh as u64;\n            let hi = loop {\n                let (hi, lo) = rng.random::<u64>().wmul(range);\n                if lo >= thresh {\n                    break hi;\n                }\n            };\n            self.low.wrapping_add(hi as usize)\n        }\n    }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::sample_single":["#[inline]\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n        low_b: B1,\n        high_b: B2,\n        rng: &mut R,\n    ) -> Result<Self::X, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,{\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low < high) {\n            return Err(Error::EmptyRange);\n        }\n\n        if cfg!(target_pointer_width = \"64\") && high > (u32::MAX as usize) {\n            return UniformInt::<u64>::sample_single(low as u64, high as u64, rng)\n                .map(|x| x as usize);\n        }\n\n        UniformInt::<u32>::sample_single(low as u32, high as u32, rng).map(|x| x as usize)\n    }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::sample_single_inclusive":["#[inline]\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n        low_b: B1,\n        high_b: B2,\n        rng: &mut R,\n    ) -> Result<Self::X, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,{\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low <= high) {\n            return Err(Error::EmptyRange);\n        }\n\n        if cfg!(target_pointer_width = \"64\") && high > (u32::MAX as usize) {\n            return UniformInt::<u64>::sample_single_inclusive(low as u64, high as u64, rng)\n                .map(|x| x as usize);\n        }\n\n        UniformInt::<u32>::sample_single_inclusive(low as u32, high as u32, rng).map(|x| x as usize)\n    }","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"<distr::uniform::other::UniformChar as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,{\n        let low = char_to_comp_u32(*low_b.borrow());\n        let high = char_to_comp_u32(*high_b.borrow());\n        let sampler = UniformInt::<u32>::new(low, high);\n        sampler.map(|sampler| UniformChar { sampler })\n    }","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"<distr::uniform::other::UniformChar as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,{\n        let low = char_to_comp_u32(*low_b.borrow());\n        let high = char_to_comp_u32(*high_b.borrow());\n        let sampler = UniformInt::<u32>::new_inclusive(low, high);\n        sampler.map(|sampler| UniformChar { sampler })\n    }","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"<distr::uniform::other::UniformChar as distr::uniform::UniformSampler>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X{\n        let mut x = self.sampler.sample(rng);\n        if x >= CHAR_SURROGATE_START {\n            x += CHAR_SURROGATE_LEN;\n        }\n        // SAFETY: x must not be in surrogate range or greater than char::MAX.\n        // This relies on range constructors which accept char arguments.\n        // Validity of input char values is assumed.\n        unsafe { core::char::from_u32_unchecked(x) }\n    }","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"<distr::uniform::other::UniformDuration as distr::uniform::UniformSampler>::new":["#[inline]\nfn new<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,{\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low < high) {\n            return Err(Error::EmptyRange);\n        }\n        UniformDuration::new_inclusive(low, high - Duration::new(0, 1))\n    }","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"<distr::uniform::other::UniformDuration as distr::uniform::UniformSampler>::new_inclusive":["#[inline]\nfn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,{\n        let low = *low_b.borrow();\n        let high = *high_b.borrow();\n        if !(low <= high) {\n            return Err(Error::EmptyRange);\n        }\n\n        let low_s = low.as_secs();\n        let low_n = low.subsec_nanos();\n        let mut high_s = high.as_secs();\n        let mut high_n = high.subsec_nanos();\n\n        if high_n < low_n {\n            high_s -= 1;\n            high_n += 1_000_000_000;\n        }\n\n        let mode = if low_s == high_s {\n            UniformDurationMode::Small {\n                secs: low_s,\n                nanos: Uniform::new_inclusive(low_n, high_n)?,\n            }\n        } else {\n            let max = high_s\n                .checked_mul(1_000_000_000)\n                .and_then(|n| n.checked_add(u64::from(high_n)));\n\n            if let Some(higher_bound) = max {\n                let lower_bound = low_s * 1_000_000_000 + u64::from(low_n);\n                UniformDurationMode::Medium {\n                    nanos: Uniform::new_inclusive(lower_bound, higher_bound)?,\n                }\n            } else {\n                // An offset is applied to simplify generation of nanoseconds\n                let max_nanos = high_n - low_n;\n                UniformDurationMode::Large {\n                    max_secs: high_s,\n                    max_nanos,\n                    secs: Uniform::new_inclusive(low_s, high_s)?,\n                }\n            }\n        };\n        Ok(UniformDuration {\n            mode,\n            offset: low_n,\n        })\n    }","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"<distr::uniform::other::UniformDuration as distr::uniform::UniformSampler>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Duration{\n        match self.mode {\n            UniformDurationMode::Small { secs, nanos } => {\n                let n = nanos.sample(rng);\n                Duration::new(secs, n)\n            }\n            UniformDurationMode::Medium { nanos } => {\n                let nanos = nanos.sample(rng);\n                Duration::new(nanos / 1_000_000_000, (nanos % 1_000_000_000) as u32)\n            }\n            UniformDurationMode::Large {\n                max_secs,\n                max_nanos,\n                secs,\n            } => {\n                // constant folding means this is at least as fast as `Rng::sample(Range)`\n                let nano_range = Uniform::new(0, 1_000_000_000).unwrap();\n                loop {\n                    let s = secs.sample(rng);\n                    let n = nano_range.sample(rng);\n                    if !(s == max_secs && n > max_nanos) {\n                        let sum = n + self.offset;\n                        break Duration::new(s, sum);\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"<distr::weighted::Error as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_str(match *self {\n            Error::InvalidInput => \"Weights sequence is empty/too long/unordered\",\n            Error::InvalidWeight => \"A weight is negative, too large or not a valid number\",\n            Error::InsufficientNonZero => \"Not enough weights > zero\",\n            Error::Overflow => \"Overflow when summing weights\",\n        })\n    }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<distr::weighted::weighted_index::WeightedIndex<X> as distr::distribution::Distribution<usize>>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> usize{\n        let chosen_weight = self.weight_distribution.sample(rng);\n        // Find the first item which has a weight *higher* than the chosen weight.\n        self.cumulative_weights\n            .partition_point(|w| w <= &chosen_weight)\n    }","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"<distr::weighted::weighted_index::WeightedIndexIter<'_, X> as core::clone::Clone>::clone":["fn clone(&self) -> Self{\n        WeightedIndexIter {\n            weighted_index: self.weighted_index,\n            index: self.index,\n        }\n    }","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"<distr::weighted::weighted_index::WeightedIndexIter<'_, X> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"WeightedIndexIter\")\n            .field(\"weighted_index\", &self.weighted_index)\n            .field(\"index\", &self.index)\n            .finish()\n    }","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"<distr::weighted::weighted_index::WeightedIndexIter<'_, X> as core::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        match self.weighted_index.weight(self.index) {\n            None => None,\n            Some(weight) => {\n                self.index += 1;\n                Some(weight)\n            }\n        }\n    }","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"<f32 as distr::utils::FloatSIMDUtils>::all_finite":["#[inline(always)]\nfn all_finite(self) -> bool{\n                self.is_finite()\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f32 as distr::utils::FloatSIMDUtils>::all_le":["#[inline(always)]\nfn all_le(self, other: Self) -> bool{\n                self <= other\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f32 as distr::utils::FloatSIMDUtils>::all_lt":["#[inline(always)]\nfn all_lt(self, other: Self) -> bool{\n                self < other\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f32 as distr::utils::FloatSIMDUtils>::cast_from_int":["#[inline]\nfn cast_from_int(i: Self::UInt) -> Self{\n                i as $ty\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f32 as distr::utils::FloatSIMDUtils>::decrease_masked":["#[inline(always)]\nfn decrease_masked(self, mask: Self::Mask) -> Self{\n                debug_assert!(mask, \"At least one lane must be set\");\n                <$ty>::from_bits(self.to_bits() - 1)\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f32 as distr::utils::FloatSIMDUtils>::gt_mask":["#[inline(always)]\nfn gt_mask(self, other: Self) -> Self::Mask{\n                self > other\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f32 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                // Floats have an explicit representation for overflow\n                *self += *v;\n                Ok(())\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<f64 as distr::utils::FloatSIMDUtils>::all_finite":["#[inline(always)]\nfn all_finite(self) -> bool{\n                self.is_finite()\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f64 as distr::utils::FloatSIMDUtils>::all_le":["#[inline(always)]\nfn all_le(self, other: Self) -> bool{\n                self <= other\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f64 as distr::utils::FloatSIMDUtils>::all_lt":["#[inline(always)]\nfn all_lt(self, other: Self) -> bool{\n                self < other\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f64 as distr::utils::FloatSIMDUtils>::cast_from_int":["#[inline]\nfn cast_from_int(i: Self::UInt) -> Self{\n                i as $ty\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f64 as distr::utils::FloatSIMDUtils>::decrease_masked":["#[inline(always)]\nfn decrease_masked(self, mask: Self::Mask) -> Self{\n                debug_assert!(mask, \"At least one lane must be set\");\n                <$ty>::from_bits(self.to_bits() - 1)\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f64 as distr::utils::FloatSIMDUtils>::gt_mask":["#[inline(always)]\nfn gt_mask(self, other: Self) -> Self::Mask{\n                self > other\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<f64 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                // Floats have an explicit representation for overflow\n                *self += *v;\n                Ok(())\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<i128 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<i16 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<i32 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<i64 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<i8 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<isize as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<rngs::mock::StepRng as rand_core::RngCore>::fill_bytes":["#[inline]\nfn fill_bytes(&mut self, dst: &mut [u8]){\n        impls::fill_bytes_via_next(self, dst)\n    }","Real(LocalPath(\"src/rngs/mock.rs\"))"],"<rngs::mock::StepRng as rand_core::RngCore>::next_u32":["#[inline]\nfn next_u32(&mut self) -> u32{\n        self.next_u64() as u32\n    }","Real(LocalPath(\"src/rngs/mock.rs\"))"],"<rngs::mock::StepRng as rand_core::RngCore>::next_u64":["#[inline]\nfn next_u64(&mut self) -> u64{\n        let res = self.v;\n        self.v = self.v.wrapping_add(self.a);\n        res\n    }","Real(LocalPath(\"src/rngs/mock.rs\"))"],"<rngs::reseeding::ReseedingCore<R, Rsdr> as core::clone::Clone>::clone":["fn clone(&self) -> ReseedingCore<R, Rsdr>{\n        ReseedingCore {\n            inner: self.inner.clone(),\n            reseeder: self.reseeder.clone(),\n            threshold: self.threshold,\n            bytes_until_reseed: 0, // reseed clone on first use\n        }\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"<rngs::reseeding::ReseedingCore<R, Rsdr> as rand_core::block::BlockRngCore>::generate":["fn generate(&mut self, results: &mut Self::Results){\n        if self.bytes_until_reseed <= 0 {\n            // We get better performance by not calling only `reseed` here\n            // and continuing with the rest of the function, but by directly\n            // returning from a non-inlined function.\n            return self.reseed_and_generate(results);\n        }\n        let num_bytes = size_of_val(results.as_ref());\n        self.bytes_until_reseed -= num_bytes as i64;\n        self.inner.generate(results);\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as core::clone::Clone>::clone":["fn clone(&self) -> ReseedingRng<R, Rsdr>{\n        // Recreating `BlockRng` seems easier than cloning it and resetting\n        // the index.\n        ReseedingRng(BlockRng::new(self.0.core.clone()))\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as rand_core::RngCore>::fill_bytes":["fn fill_bytes(&mut self, dest: &mut [u8]){\n        self.0.fill_bytes(dest)\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as rand_core::RngCore>::next_u32":["#[inline(always)]\nfn next_u32(&mut self) -> u32{\n        self.0.next_u32()\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as rand_core::RngCore>::next_u64":["#[inline(always)]\nfn next_u64(&mut self) -> u64{\n        self.0.next_u64()\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"<rngs::small::SmallRng as rand_core::RngCore>::fill_bytes":["#[inline(always)]\nfn fill_bytes(&mut self, dest: &mut [u8]){\n        self.0.fill_bytes(dest)\n    }","Real(LocalPath(\"src/rngs/small.rs\"))"],"<rngs::small::SmallRng as rand_core::RngCore>::next_u32":["#[inline(always)]\nfn next_u32(&mut self) -> u32{\n        self.0.next_u32()\n    }","Real(LocalPath(\"src/rngs/small.rs\"))"],"<rngs::small::SmallRng as rand_core::RngCore>::next_u64":["#[inline(always)]\nfn next_u64(&mut self) -> u64{\n        self.0.next_u64()\n    }","Real(LocalPath(\"src/rngs/small.rs\"))"],"<rngs::small::SmallRng as rand_core::SeedableRng>::from_seed":["#[inline(always)]\nfn from_seed(seed: Self::Seed) -> Self{\n        // This is for compatibility with 32-bit platforms where Rng::Seed has a different seed size\n        // With MSRV >= 1.77: let seed = *seed.first_chunk().unwrap()\n        const LEN: usize = core::mem::size_of::<<Rng as SeedableRng>::Seed>();\n        let seed = (&seed[..LEN]).try_into().unwrap();\n        SmallRng(Rng::from_seed(seed))\n    }","Real(LocalPath(\"src/rngs/small.rs\"))"],"<rngs::small::SmallRng as rand_core::SeedableRng>::seed_from_u64":["#[inline(always)]\nfn seed_from_u64(state: u64) -> Self{\n        SmallRng(Rng::seed_from_u64(state))\n    }","Real(LocalPath(\"src/rngs/small.rs\"))"],"<rngs::std::StdRng as rand_core::RngCore>::fill_bytes":["#[inline(always)]\nfn fill_bytes(&mut self, dst: &mut [u8]){\n        self.0.fill_bytes(dst)\n    }","Real(LocalPath(\"src/rngs/std.rs\"))"],"<rngs::std::StdRng as rand_core::RngCore>::next_u32":["#[inline(always)]\nfn next_u32(&mut self) -> u32{\n        self.0.next_u32()\n    }","Real(LocalPath(\"src/rngs/std.rs\"))"],"<rngs::std::StdRng as rand_core::RngCore>::next_u64":["#[inline(always)]\nfn next_u64(&mut self) -> u64{\n        self.0.next_u64()\n    }","Real(LocalPath(\"src/rngs/std.rs\"))"],"<rngs::std::StdRng as rand_core::SeedableRng>::from_seed":["#[inline(always)]\nfn from_seed(seed: Self::Seed) -> Self{\n        StdRng(Rng::from_seed(seed))\n    }","Real(LocalPath(\"src/rngs/std.rs\"))"],"<rngs::thread::ThreadRng as core::default::Default>::default":["fn default() -> ThreadRng{\n        rng()\n    }","Real(LocalPath(\"src/rngs/thread.rs\"))"],"<rngs::thread::ThreadRng as core::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{\n        write!(fmt, \"ThreadRng {{ .. }}\")\n    }","Real(LocalPath(\"src/rngs/thread.rs\"))"],"<rngs::thread::ThreadRng as rand_core::RngCore>::fill_bytes":["#[inline(always)]\nfn fill_bytes(&mut self, dest: &mut [u8]){\n        // SAFETY: We must make sure to stop using `rng` before anyone else\n        // creates another mutable reference\n        let rng = unsafe { &mut *self.rng.get() };\n        rng.fill_bytes(dest)\n    }","Real(LocalPath(\"src/rngs/thread.rs\"))"],"<rngs::thread::ThreadRng as rand_core::RngCore>::next_u32":["#[inline(always)]\nfn next_u32(&mut self) -> u32{\n        // SAFETY: We must make sure to stop using `rng` before anyone else\n        // creates another mutable reference\n        let rng = unsafe { &mut *self.rng.get() };\n        rng.next_u32()\n    }","Real(LocalPath(\"src/rngs/thread.rs\"))"],"<rngs::thread::ThreadRng as rand_core::RngCore>::next_u64":["#[inline(always)]\nfn next_u64(&mut self) -> u64{\n        // SAFETY: We must make sure to stop using `rng` before anyone else\n        // creates another mutable reference\n        let rng = unsafe { &mut *self.rng.get() };\n        rng.next_u64()\n    }","Real(LocalPath(\"src/rngs/thread.rs\"))"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::fill_bytes":["#[inline]\nfn fill_bytes(&mut self, dst: &mut [u8]){\n        fill_bytes_via_next(self, dst)\n    }","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::next_u32":["#[inline]\nfn next_u32(&mut self) -> u32{\n        // The lowest bits have some linear dependencies, so we use the\n        // upper bits instead.\n        let val = self.next_u64();\n        (val >> 32) as u32\n    }","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::next_u64":["#[inline]\nfn next_u64(&mut self) -> u64{\n        let res = self.s[0]\n            .wrapping_add(self.s[3])\n            .rotate_left(23)\n            .wrapping_add(self.s[0]);\n\n        let t = self.s[1] << 17;\n\n        self.s[2] ^= self.s[0];\n        self.s[3] ^= self.s[1];\n        self.s[1] ^= self.s[2];\n        self.s[0] ^= self.s[3];\n\n        self.s[2] ^= t;\n\n        self.s[3] = self.s[3].rotate_left(45);\n\n        res\n    }","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::SeedableRng>::from_seed":["/// Create a new `Xoshiro256PlusPlus`.  If `seed` is entirely 0, it will be\n/// mapped to a different seed.\n#[inline]\nfn from_seed(seed: [u8; 32]) -> Xoshiro256PlusPlus{\n        let mut state = [0; 4];\n        read_u64_into(&seed, &mut state);\n        // Check for zero on aligned integers for better code generation.\n        // Furtermore, seed_from_u64(0) will expand to a constant when optimized.\n        if state.iter().all(|&x| x == 0) {\n            return Self::seed_from_u64(0);\n        }\n        Xoshiro256PlusPlus { s: state }\n    }","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::SeedableRng>::seed_from_u64":["/// Create a new `Xoshiro256PlusPlus` from a `u64` seed.\n///\n/// This uses the SplitMix64 generator internally.\n#[inline]\nfn seed_from_u64(mut state: u64) -> Self{\n        const PHI: u64 = 0x9e3779b97f4a7c15;\n        let mut s = [0; 4];\n        for i in s.iter_mut() {\n            state = state.wrapping_add(PHI);\n            let mut z = state;\n            z = (z ^ (z >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);\n            z = (z ^ (z >> 27)).wrapping_mul(0x94d049bb133111eb);\n            z = z ^ (z >> 31);\n            *i = z;\n        }\n        // By using a non-zero PHI we are guaranteed to generate a non-zero state\n        // Thus preventing a recursion between from_seed and seed_from_u64.\n        debug_assert_ne!(s, [0; 4]);\n        Xoshiro256PlusPlus { s }\n    }","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))"],"<seq::index_::IndexVec as core::cmp::PartialEq>::eq":["fn eq(&self, other: &IndexVec) -> bool{\n        use self::IndexVec::*;\n        match (self, other) {\n            (U32(v1), U32(v2)) => v1 == v2,\n            #[cfg(target_pointer_width = \"64\")]\n            (U64(v1), U64(v2)) => v1 == v2,\n            #[cfg(target_pointer_width = \"64\")]\n            (U32(v1), U64(v2)) => {\n                (v1.len() == v2.len()) && (v1.iter().zip(v2.iter()).all(|(x, y)| *x as u64 == *y))\n            }\n            #[cfg(target_pointer_width = \"64\")]\n            (U64(v1), U32(v2)) => {\n                (v1.len() == v2.len()) && (v1.iter().zip(v2.iter()).all(|(x, y)| *x == *y as u64))\n            }\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::index_::IndexVec as core::convert::From<alloc::vec::Vec<u32>>>::from":["#[inline]\nfn from(v: Vec<u32>) -> Self{\n        IndexVec::U32(v)\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::index_::IndexVec as core::convert::From<alloc::vec::Vec<u64>>>::from":["#[inline]\nfn from(v: Vec<u64>) -> Self{\n        IndexVec::U64(v)\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::index_::IndexVec as core::iter::IntoIterator>::into_iter":["/// Convert into an iterator over the indices as a sequence of `usize` values\n#[inline]\nfn into_iter(self) -> IndexVecIntoIter{\n        match self {\n            IndexVec::U32(v) => IndexVecIntoIter::U32(v.into_iter()),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => IndexVecIntoIter::U64(v.into_iter()),\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::index_::IndexVecIntoIter as core::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        use self::IndexVecIntoIter::*;\n        match self {\n            U32(v) => v.next().map(|i| i as usize),\n            #[cfg(target_pointer_width = \"64\")]\n            U64(v) => v.next().map(|i| i as usize),\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::index_::IndexVecIntoIter as core::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        use self::IndexVecIntoIter::*;\n        match self {\n            U32(v) => v.size_hint(),\n            #[cfg(target_pointer_width = \"64\")]\n            U64(v) => v.size_hint(),\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::index_::IndexVecIter<'_> as core::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<usize>{\n        use self::IndexVecIter::*;\n        match self {\n            U32(iter) => iter.next().map(|i| *i as usize),\n            #[cfg(target_pointer_width = \"64\")]\n            U64(iter) => iter.next().map(|i| *i as usize),\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::index_::IndexVecIter<'_> as core::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n        match self {\n            IndexVecIter::U32(v) => v.size_hint(),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVecIter::U64(v) => v.size_hint(),\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::index_::sample_efraimidis_spirakis::Element<N> as core::cmp::Ord>::cmp":["fn cmp(&self, other: &Self) -> Ordering{\n            // unwrap() should not panic since weights should not be NaN\n            // We reverse so that BinaryHeap::peek shows the smallest item\n            self.key.partial_cmp(&other.key).unwrap().reverse()\n        }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::index_::sample_efraimidis_spirakis::Element<N> as core::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n            self.key == other.key\n        }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::index_::sample_efraimidis_spirakis::Element<N> as core::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Self) -> Option<Ordering>{\n            Some(self.cmp(other))\n        }","Real(LocalPath(\"src/seq/index.rs\"))"],"<seq::slice::SliceChooseIter<'a, S, T> as core::iter::ExactSizeIterator>::len":["fn len(&self) -> usize{\n        self.indices.len()\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"<seq::slice::SliceChooseIter<'a, S, T> as core::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        // TODO: investigate using SliceIndex::get_unchecked when stable\n        self.indices.next().map(|i| &self.slice[i])\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"<seq::slice::SliceChooseIter<'a, S, T> as core::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (self.indices.len(), Some(self.indices.len()))\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"<u128 as distr::utils::WideningMultiply>::wmul":["#[inline(always)]\nfn wmul(self, b: $ty) -> Self::Output{\n                const LOWER_MASK: $ty = !0 >> $half;\n                let mut low = (self & LOWER_MASK).wrapping_mul(b & LOWER_MASK);\n                let mut t = low >> $half;\n                low &= LOWER_MASK;\n                t += (self >> $half).wrapping_mul(b & LOWER_MASK);\n                low += (t & LOWER_MASK) << $half;\n                let mut high = t >> $half;\n                t = low >> $half;\n                low &= LOWER_MASK;\n                t += (b >> $half).wrapping_mul(self & LOWER_MASK);\n                low += (t & LOWER_MASK) << $half;\n                high += t >> $half;\n                high += (self >> $half).wrapping_mul(b >> $half);\n\n                (high, low)\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<u128 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<u16 as distr::utils::WideningMultiply>::wmul":["#[inline(always)]\nfn wmul(self, x: $ty) -> Self::Output{\n                let tmp = (self as $wide) * (x as $wide);\n                ((tmp >> $shift) as $ty, tmp as $ty)\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<u16 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<u32 as distr::float::IntoFloat>::into_float_with_exponent":["#[inline(always)]\nfn into_float_with_exponent(self, exponent: i32) -> $ty{\n                // The exponent is encoded using an offset-binary representation\n                let exponent_bits: $u_scalar =\n                    (($exponent_bias + exponent) as $u_scalar) << $fraction_bits;\n                $ty::from_bits(self | $uty::splat(exponent_bits))\n            }","Real(LocalPath(\"src/distr/float.rs\"))"],"<u32 as distr::utils::WideningMultiply>::wmul":["#[inline(always)]\nfn wmul(self, x: $ty) -> Self::Output{\n                let tmp = (self as $wide) * (x as $wide);\n                ((tmp >> $shift) as $ty, tmp as $ty)\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<u32 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<u32 as seq::index_::UInt>::as_usize":["#[inline]\nfn as_usize(self) -> usize{\n        self as usize\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<u32 as seq::index_::UInt>::one":["#[inline]\nfn one() -> Self{\n        1\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<u32 as seq::index_::UInt>::zero":["#[inline]\nfn zero() -> Self{\n        0\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<u64 as distr::float::IntoFloat>::into_float_with_exponent":["#[inline(always)]\nfn into_float_with_exponent(self, exponent: i32) -> $ty{\n                // The exponent is encoded using an offset-binary representation\n                let exponent_bits: $u_scalar =\n                    (($exponent_bias + exponent) as $u_scalar) << $fraction_bits;\n                $ty::from_bits(self | $uty::splat(exponent_bits))\n            }","Real(LocalPath(\"src/distr/float.rs\"))"],"<u64 as distr::utils::WideningMultiply>::wmul":["#[inline(always)]\nfn wmul(self, x: $ty) -> Self::Output{\n                let tmp = (self as $wide) * (x as $wide);\n                ((tmp >> $shift) as $ty, tmp as $ty)\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<u64 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<u64 as seq::index_::UInt>::as_usize":["#[inline]\nfn as_usize(self) -> usize{\n        self as usize\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<u64 as seq::index_::UInt>::one":["#[inline]\nfn one() -> Self{\n        1\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<u64 as seq::index_::UInt>::zero":["#[inline]\nfn zero() -> Self{\n        0\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"<u8 as distr::utils::WideningMultiply>::wmul":["#[inline(always)]\nfn wmul(self, x: $ty) -> Self::Output{\n                let tmp = (self as $wide) * (x as $wide);\n                ((tmp >> $shift) as $ty, tmp as $ty)\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<u8 as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"<usize as distr::utils::WideningMultiply>::wmul":["#[inline(always)]\nfn wmul(self, x: usize) -> Self::Output{\n                let (high, low) = (self as $ty).wmul(x as $ty);\n                (high as usize, low as usize)\n            }","Real(LocalPath(\"src/distr/utils.rs\"))"],"<usize as distr::weighted::Weight>::checked_add_assign":["fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>{\n                match self.checked_add(*v) {\n                    Some(sum) => {\n                        *self = sum;\n                        Ok(())\n                    }\n                    None => Err(()),\n                }\n            }","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"distr::StandardUniform":["/// The Standard Uniform distribution\n///\n/// This [`Distribution`] is the *standard* parameterization of [`Uniform`]. Bounds\n/// are selected according to the output type.\n///\n/// Assuming the provided `Rng` is well-behaved, these implementations\n/// generate values with the following ranges and distributions:\n///\n/// * Integers (`i8`, `i32`, `u64`, etc.) are uniformly distributed\n///   over the whole range of the type (thus each possible value may be sampled\n///   with equal probability).\n/// * `char` is uniformly distributed over all Unicode scalar values, i.e. all\n///   code points in the range `0...0x10_FFFF`, except for the range\n///   `0xD800...0xDFFF` (the surrogate code points). This includes\n///   unassigned/reserved code points.\n///   For some uses, the [`Alphanumeric`] or [`Alphabetic`] distribution will be more\n///   appropriate.\n/// * `bool` samples `false` or `true`, each with probability 0.5.\n/// * Floating point types (`f32` and `f64`) are uniformly distributed in the\n///   half-open range `[0, 1)`. See also the [notes below](#floating-point-implementation).\n/// * Wrapping integers ([`Wrapping<T>`]), besides the type identical to their\n///   normal integer variants.\n/// * Non-zero integers ([`NonZeroU8`]), which are like their normal integer\n///   variants but cannot sample zero.\n///\n/// The `StandardUniform` distribution also supports generation of the following\n/// compound types where all component types are supported:\n///\n/// * Tuples (up to 12 elements): each element is sampled sequentially and\n///   independently (thus, assuming a well-behaved RNG, there is no correlation\n///   between elements).\n/// * Arrays `[T; n]` where `T` is supported. Each element is sampled\n///   sequentially and independently. Note that for small `T` this usually\n///   results in the RNG discarding random bits; see also [`Rng::fill`] which\n///   offers a more efficient approach to filling an array of integer types\n///   with random data.\n/// * SIMD types (requires [`simd_support`] feature) like x86's [`__m128i`]\n///   and `std::simd`'s [`u32x4`], [`f32x4`] and [`mask32x4`] types are\n///   effectively arrays of integer or floating-point types. Each lane is\n///   sampled independently, potentially with more efficient random-bit-usage\n///   (and a different resulting value) than would be achieved with sequential\n///   sampling (as with the array types above).\n///\n/// ## Custom implementations\n///\n/// The [`StandardUniform`] distribution may be implemented for user types as follows:\n///\n/// ```\n/// # #![allow(dead_code)]\n/// use rand::Rng;\n/// use rand::distr::{Distribution, StandardUniform};\n///\n/// struct MyF32 {\n///     x: f32,\n/// }\n///\n/// impl Distribution<MyF32> for StandardUniform {\n///     fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> MyF32 {\n///         MyF32 { x: rng.random() }\n///     }\n/// }\n/// ```\n///\n/// ## Example usage\n/// ```\n/// use rand::prelude::*;\n/// use rand::distr::StandardUniform;\n///\n/// let val: f32 = rand::rng().sample(StandardUniform);\n/// println!(\"f32 from [0, 1): {}\", val);\n/// ```\n///\n/// # Floating point implementation\n/// The floating point implementations for `StandardUniform` generate a random value in\n/// the half-open interval `[0, 1)`, i.e. including 0 but not 1.\n///\n/// All values that can be generated are of the form `n * /2`. For `f32`\n/// the 24 most significant random bits of a `u32` are used and for `f64` the\n/// 53 most significant bits of a `u64` are used. The conversion uses the\n/// multiplicative method: `(rng.gen::<$uty>() >> N) as $ty * (/2)`.\n///\n/// See also: [`Open01`] which samples from `(0, 1)`, [`OpenClosed01`] which\n/// samples from `(0, 1]` and `Rng::random_range(0..1)` which also samples from\n/// `[0, 1)`. Note that `Open01` uses transmute-based methods which yield 1 bit\n/// less precision but may perform faster on some architectures (on modern Intel\n/// CPUs all methods have approximately equal performance).\n///\n/// [`Uniform`]: uniform::Uniform\n/// [`Wrapping<T>`]: std::num::Wrapping\n/// [`NonZeroU8`]: std::num::NonZeroU8\n/// [`__m128i`]: https://doc.rust-lang.org/core/arch/x86/struct.__m128i.html\n/// [`u32x4`]: std::simd::u32x4\n/// [`f32x4`]: std::simd::f32x4\n/// [`mask32x4`]: std::simd::mask32x4\n/// [`simd_support`]: https://github.com/rust-random/rand#crate-features\npub struct StandardUniform;","Real(LocalPath(\"src/distr/mod.rs\"))"],"distr::bernoulli::Bernoulli":["/// The [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution) `Bernoulli(p)`.\n///\n/// This distribution describes a single boolean random variable, which is true\n/// with probability `p` and false with probability `1 - p`.\n/// It is a special case of the Binomial distribution with `n = 1`.\n///\n/// # Plot\n///\n/// The following plot shows the Bernoulli distribution with `p = 0.1`,\n/// `p = 0.5`, and `p = 0.9`.\n///\n/// ![Bernoulli distribution](https://raw.githubusercontent.com/rust-random/charts/main/charts/bernoulli.svg)\n///\n/// # Example\n///\n/// ```rust\n/// use rand::distr::{Bernoulli, Distribution};\n///\n/// let d = Bernoulli::new(0.3).unwrap();\n/// let v = d.sample(&mut rand::rng());\n/// println!(\"{} is from a Bernoulli distribution\", v);\n/// ```\n///\n/// # Precision\n///\n/// This `Bernoulli` distribution uses 64 bits from the RNG (a `u64`),\n/// so only probabilities that are multiples of 2<sup>-64</sup> can be\n/// represented.\npub struct Bernoulli {\n    /// Probability of success, relative to the maximal integer.\n    p_int: u64,\n}","Real(LocalPath(\"src/distr/bernoulli.rs\"))"],"distr::bernoulli::Bernoulli::from_ratio":["/// Construct a new `Bernoulli` with the probability of success of\n/// `numerator`-in-`denominator`. I.e. `new_ratio(2, 3)` will return\n/// a `Bernoulli` with a 2-in-3 chance, or about 67%, of returning `true`.\n///\n/// return `true`. If `numerator == 0` it will always return `false`.\n/// For `numerator > denominator` and `denominator == 0`, this returns an\n/// error. Otherwise, for `numerator == denominator`, samples are always\n/// true; for `numerator == 0` samples are always false.\n#[inline]\npub fn from_ratio(numerator: u32, denominator: u32) -> Result<Bernoulli, BernoulliError>{\n        if numerator > denominator || denominator == 0 {\n            return Err(BernoulliError::InvalidProbability);\n        }\n        if numerator == denominator {\n            return Ok(Bernoulli { p_int: ALWAYS_TRUE });\n        }\n        let p_int = ((f64::from(numerator) / f64::from(denominator)) * SCALE) as u64;\n        Ok(Bernoulli { p_int })\n    }","Real(LocalPath(\"src/distr/bernoulli.rs\"))"],"distr::bernoulli::Bernoulli::new":["/// Construct a new `Bernoulli` with the given probability of success `p`.\n///\n/// # Precision\n///\n/// For `p = 1.0`, the resulting distribution will always generate true.\n/// For `p = 0.0`, the resulting distribution will always generate false.\n///\n/// This method is accurate for any input `p` in the range `[0, 1]` which is\n/// a multiple of 2<sup>-64</sup>. (Note that not all multiples of\n/// 2<sup>-64</sup> in `[0, 1]` can be represented as a `f64`.)\n#[inline]\npub fn new(p: f64) -> Result<Bernoulli, BernoulliError>{\n        if !(0.0..1.0).contains(&p) {\n            if p == 1.0 {\n                return Ok(Bernoulli { p_int: ALWAYS_TRUE });\n            }\n            return Err(BernoulliError::InvalidProbability);\n        }\n        Ok(Bernoulli {\n            p_int: (p * SCALE) as u64,\n        })\n    }","Real(LocalPath(\"src/distr/bernoulli.rs\"))"],"distr::bernoulli::Bernoulli::p":["#[inline]\n/// Returns the probability (`p`) of the distribution.\n///\n/// This value may differ slightly from the input due to loss of precision.\npub fn p(&self) -> f64{\n        if self.p_int == ALWAYS_TRUE {\n            1.0\n        } else {\n            (self.p_int as f64) / SCALE\n        }\n    }","Real(LocalPath(\"src/distr/bernoulli.rs\"))"],"distr::bernoulli::BernoulliError":["/// Error type returned from [`Bernoulli::new`].\npub enum BernoulliError {\n    /// `p < 0` or `p > 1`.\n    InvalidProbability,\n}","Real(LocalPath(\"src/distr/bernoulli.rs\"))"],"distr::distribution::Distribution":["/// Types (distributions) that can be used to create a random instance of `T`.\n///\n/// It is possible to sample from a distribution through both the\n/// `Distribution` and [`Rng`] traits, via `distr.sample(&mut rng)` and\n/// `rng.sample(distr)`. They also both offer the [`sample_iter`] method, which\n/// produces an iterator that samples from the distribution.\n///\n/// All implementations are expected to be immutable; this has the significant\n/// advantage of not needing to consider thread safety, and for most\n/// distributions efficient state-less sampling algorithms are available.\n///\n/// Implementations are typically expected to be portable with reproducible\n/// results when used with a PRNG with fixed seed; see the\n/// [portability chapter](https://rust-random.github.io/book/portability.html)\n/// of The Rust Rand Book. In some cases this does not apply, e.g. the `usize`\n/// type requires different sampling on 32-bit and 64-bit machines.\n///\n/// [`sample_iter`]: Distribution::sample_iter\npub trait Distribution<T> {\n    /// Generate a random value of `T`, using `rng` as the source of randomness.\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> T;\n\n    /// Create an iterator that generates random values of `T`, using `rng` as\n    /// the source of randomness.\n    ///\n    /// Note that this function takes `self` by value. This works since\n    /// `Distribution<T>` is impl'd for `&D` where `D: Distribution<T>`,\n    /// however borrowing is not automatic hence `distr.sample_iter(...)` may\n    /// need to be replaced with `(&distr).sample_iter(...)` to borrow or\n    /// `(&*distr).sample_iter(...)` to reborrow an existing reference.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::distr::{Distribution, Alphanumeric, Uniform, StandardUniform};\n    ///\n    /// let mut rng = rand::rng();\n    ///\n    /// // Vec of 16 x f32:\n    /// let v: Vec<f32> = StandardUniform.sample_iter(&mut rng).take(16).collect();\n    ///\n    /// // String:\n    /// let s: String = Alphanumeric\n    ///     .sample_iter(&mut rng)\n    ///     .take(7)\n    ///     .map(char::from)\n    ///     .collect();\n    ///\n    /// // Dice-rolling:\n    /// let die_range = Uniform::new_inclusive(1, 6).unwrap();\n    /// let mut roll_die = die_range.sample_iter(&mut rng);\n    /// while roll_die.next().unwrap() != 6 {\n    ///     println!(\"Not a 6; rolling again!\");\n    /// }\n    /// ```\n    fn sample_iter<R>(self, rng: R) -> Iter<Self, R, T>\n    where\n        R: Rng,\n        Self: Sized,\n    {\n        Iter {\n            distr: self,\n            rng,\n            phantom: core::marker::PhantomData,\n        }\n    }\n\n    /// Map sampled values to type `S`\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::distr::{Distribution, Uniform};\n    ///\n    /// let die = Uniform::new_inclusive(1, 6).unwrap();\n    /// let even_number = die.map(|num| num % 2 == 0);\n    /// while !even_number.sample(&mut rand::rng()) {\n    ///     println!(\"Still odd; rolling again!\");\n    /// }\n    /// ```\n    fn map<F, S>(self, func: F) -> Map<Self, F, T, S>\n    where\n        F: Fn(T) -> S,\n        Self: Sized,\n    {\n        Map {\n            distr: self,\n            func,\n            phantom: core::marker::PhantomData,\n        }\n    }\n}","Real(LocalPath(\"src/distr/distribution.rs\"))"],"distr::distribution::Distribution::map":["/// Map sampled values to type `S`\n///\n/// # Example\n///\n/// ```\n/// use rand::distr::{Distribution, Uniform};\n///\n/// let die = Uniform::new_inclusive(1, 6).unwrap();\n/// let even_number = die.map(|num| num % 2 == 0);\n/// while !even_number.sample(&mut rand::rng()) {\n///     println!(\"Still odd; rolling again!\");\n/// }\n/// ```\nfn map<F, S>(self, func: F) -> Map<Self, F, T, S>\n    where\n        F: Fn(T) -> S,\n        Self: Sized,{\n        Map {\n            distr: self,\n            func,\n            phantom: core::marker::PhantomData,\n        }\n    }","Real(LocalPath(\"src/distr/distribution.rs\"))"],"distr::distribution::Distribution::sample_iter":["/// Create an iterator that generates random values of `T`, using `rng` as\n/// the source of randomness.\n///\n/// Note that this function takes `self` by value. This works since\n/// `Distribution<T>` is impl'd for `&D` where `D: Distribution<T>`,\n/// however borrowing is not automatic hence `distr.sample_iter(...)` may\n/// need to be replaced with `(&distr).sample_iter(...)` to borrow or\n/// `(&*distr).sample_iter(...)` to reborrow an existing reference.\n///\n/// # Example\n///\n/// ```\n/// use rand::distr::{Distribution, Alphanumeric, Uniform, StandardUniform};\n///\n/// let mut rng = rand::rng();\n///\n/// // Vec of 16 x f32:\n/// let v: Vec<f32> = StandardUniform.sample_iter(&mut rng).take(16).collect();\n///\n/// // String:\n/// let s: String = Alphanumeric\n///     .sample_iter(&mut rng)\n///     .take(7)\n///     .map(char::from)\n///     .collect();\n///\n/// // Dice-rolling:\n/// let die_range = Uniform::new_inclusive(1, 6).unwrap();\n/// let mut roll_die = die_range.sample_iter(&mut rng);\n/// while roll_die.next().unwrap() != 6 {\n///     println!(\"Not a 6; rolling again!\");\n/// }\n/// ```\nfn sample_iter<R>(self, rng: R) -> Iter<Self, R, T>\n    where\n        R: Rng,\n        Self: Sized,{\n        Iter {\n            distr: self,\n            rng,\n            phantom: core::marker::PhantomData,\n        }\n    }","Real(LocalPath(\"src/distr/distribution.rs\"))"],"distr::distribution::Iter":["/// An iterator over a [`Distribution`]\n///\n/// This iterator yields random values of type `T` with distribution `D`\n/// from a random generator of type `R`.\n///\n/// Construct this `struct` using [`Distribution::sample_iter`] or\n/// [`Rng::sample_iter`]. It is also used by [`Rng::random_iter`] and\n/// [`crate::random_iter`].\npub struct Iter<D, R, T> {\n    distr: D,\n    rng: R,\n    phantom: core::marker::PhantomData<T>,\n}","Real(LocalPath(\"src/distr/distribution.rs\"))"],"distr::distribution::Map":["/// A [`Distribution`] which maps sampled values to type `S`\n///\n/// This `struct` is created by the [`Distribution::map`] method.\n/// See its documentation for more.\npub struct Map<D, F, T, S> {\n    distr: D,\n    func: F,\n    phantom: core::marker::PhantomData<fn(T) -> S>,\n}","Real(LocalPath(\"src/distr/distribution.rs\"))"],"distr::distribution::SampleString":["/// Sample or extend a [`String`]\n///\n/// Helper methods to extend a [`String`] or sample a new [`String`].\n#[cfg(feature = \"alloc\")]\npub trait SampleString {\n    /// Append `len` random chars to `string`\n    ///\n    /// Note: implementations may leave `string` with excess capacity. If this\n    /// is undesirable, consider calling [`String::shrink_to_fit`] after this\n    /// method.\n    fn append_string<R: Rng + ?Sized>(&self, rng: &mut R, string: &mut String, len: usize);\n\n    /// Generate a [`String`] of `len` random chars\n    ///\n    /// Note: implementations may leave the string with excess capacity. If this\n    /// is undesirable, consider calling [`String::shrink_to_fit`] after this\n    /// method.\n    #[inline]\n    fn sample_string<R: Rng + ?Sized>(&self, rng: &mut R, len: usize) -> String {\n        let mut s = String::new();\n        self.append_string(rng, &mut s, len);\n        s\n    }\n}","Real(LocalPath(\"src/distr/distribution.rs\"))"],"distr::distribution::SampleString::sample_string":["/// Generate a [`String`] of `len` random chars\n///\n/// Note: implementations may leave the string with excess capacity. If this\n/// is undesirable, consider calling [`String::shrink_to_fit`] after this\n/// method.\n#[inline]\nfn sample_string<R: Rng + ?Sized>(&self, rng: &mut R, len: usize) -> String{\n        let mut s = String::new();\n        self.append_string(rng, &mut s, len);\n        s\n    }","Real(LocalPath(\"src/distr/distribution.rs\"))"],"distr::float::<impl distr::distribution::Distribution<f32> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                // Multiply-based method; 24/53 random bits; [0, 1) interval.\n                // We use the most significant bits because for simple RNGs\n                // those are usually more random.\n                let float_size = mem::size_of::<$f_scalar>() as $u_scalar * 8;\n                let precision = $fraction_bits + 1;\n                let scale = 1.0 / ((1 as $u_scalar << precision) as $f_scalar);\n\n                let value: $uty = rng.random();\n                let value = value >> $uty::splat(float_size - precision);\n                $ty::splat(scale) * $ty::cast_from_int(value)\n            }","Real(LocalPath(\"src/distr/float.rs\"))"],"distr::float::<impl distr::distribution::Distribution<f64> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                // Multiply-based method; 24/53 random bits; [0, 1) interval.\n                // We use the most significant bits because for simple RNGs\n                // those are usually more random.\n                let float_size = mem::size_of::<$f_scalar>() as $u_scalar * 8;\n                let precision = $fraction_bits + 1;\n                let scale = 1.0 / ((1 as $u_scalar << precision) as $f_scalar);\n\n                let value: $uty = rng.random();\n                let value = value >> $uty::splat(float_size - precision);\n                $ty::splat(scale) * $ty::cast_from_int(value)\n            }","Real(LocalPath(\"src/distr/float.rs\"))"],"distr::float::IntoFloat":["#[doc(hidden)]\npub trait IntoFloat {\n    type F;\n\n    /// Helper method to combine the fraction and a constant exponent into a\n    /// float.\n    ///\n    /// Only the least significant bits of `self` may be set, 23 for `f32` and\n    /// 52 for `f64`.\n    /// The resulting value will fall in a range that depends on the exponent.\n    /// As an example the range with exponent 0 will be\n    /// [2<sup>0</sup>..2<sup>1</sup>), which is [1..2).\n    fn into_float_with_exponent(self, exponent: i32) -> Self::F;\n}","Real(LocalPath(\"src/distr/float.rs\"))"],"distr::float::Open01":["/// A distribution to sample floating point numbers uniformly in the open\n/// interval `(0, 1)`, i.e. not including either endpoint.\n///\n/// All values that can be generated are of the form `n *  + /2`. For `f32`\n/// the 23 most significant random bits of an `u32` are used, for `f64` 52 from\n/// an `u64`. The conversion uses a transmute-based method.\n///\n/// See also: [`StandardUniform`] which samples from `[0, 1)`, [`OpenClosed01`]\n/// which samples from `(0, 1]` and [`Uniform`] which samples from arbitrary\n/// ranges.\n///\n/// # Example\n/// ```\n/// use rand::Rng;\n/// use rand::distr::Open01;\n///\n/// let val: f32 = rand::rng().sample(Open01);\n/// println!(\"f32 from (0, 1): {}\", val);\n/// ```\n///\n/// [`StandardUniform`]: crate::distr::StandardUniform\n/// [`OpenClosed01`]: crate::distr::OpenClosed01\n/// [`Uniform`]: crate::distr::uniform::Uniform\npub struct Open01;","Real(LocalPath(\"src/distr/float.rs\"))"],"distr::float::OpenClosed01":["/// A distribution to sample floating point numbers uniformly in the half-open\n/// interval `(0, 1]`, i.e. including 1 but not 0.\n///\n/// All values that can be generated are of the form `n * /2`. For `f32`\n/// the 24 most significant random bits of a `u32` are used and for `f64` the\n/// 53 most significant bits of a `u64` are used. The conversion uses the\n/// multiplicative method.\n///\n/// See also: [`StandardUniform`] which samples from `[0, 1)`, [`Open01`]\n/// which samples from `(0, 1)` and [`Uniform`] which samples from arbitrary\n/// ranges.\n///\n/// # Example\n/// ```\n/// use rand::Rng;\n/// use rand::distr::OpenClosed01;\n///\n/// let val: f32 = rand::rng().sample(OpenClosed01);\n/// println!(\"f32 from (0, 1): {}\", val);\n/// ```\n///\n/// [`StandardUniform`]: crate::distr::StandardUniform\n/// [`Open01`]: crate::distr::Open01\n/// [`Uniform`]: crate::distr::uniform::Uniform\npub struct OpenClosed01;","Real(LocalPath(\"src/distr/float.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::arch::x86_64::__m128i> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> __m128i{\n        // NOTE: It's tempting to use the u128 impl here, but confusingly this\n        // results in different code (return via rdx, r10 instead of rax, rdx\n        // with u128 impl) and is much slower (+130 time). This version calls\n        // impls::fill_bytes_via_next but performs well.\n\n        let mut buf = [0_u8; core::mem::size_of::<__m128i>()];\n        rng.fill_bytes(&mut buf);\n        // x86 is little endian so no need for conversion\n\n        // SAFETY: All byte sequences of `buf` represent values of the output type.\n        unsafe { core::mem::transmute(buf) }\n    }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::arch::x86_64::__m256i> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> __m256i{\n        let mut buf = [0_u8; core::mem::size_of::<__m256i>()];\n        rng.fill_bytes(&mut buf);\n        // x86 is little endian so no need for conversion\n\n        // SAFETY: All byte sequences of `buf` represent values of the output type.\n        unsafe { core::mem::transmute(buf) }\n    }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i128>> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i16>> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i32>> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i64>> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i8>> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u128>> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u16>> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u32>> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u64>> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u8>> for distr::StandardUniform>::sample":["fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                loop {\n                    if let Some(nz) = $new(rng.random()) {\n                        break nz;\n                    }\n                }\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<i128> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                rng.random::<$uty>() as $ty\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<i16> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                rng.random::<$uty>() as $ty\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<i32> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                rng.random::<$uty>() as $ty\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<i64> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                rng.random::<$uty>() as $ty\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<i8> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> $ty{\n                rng.random::<$uty>() as $ty\n            }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<u128> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u128{\n        // Use LE; we explicitly generate one value before the next.\n        let x = u128::from(rng.next_u64());\n        let y = u128::from(rng.next_u64());\n        (y << 64) | x\n    }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<u16> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u16{\n        rng.next_u32() as u16\n    }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<u32> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u32{\n        rng.next_u32()\n    }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<u64> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u64{\n        rng.next_u64()\n    }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::integer::<impl distr::distribution::Distribution<u8> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u8{\n        rng.next_u32() as u8\n    }","Real(LocalPath(\"src/distr/integer.rs\"))"],"distr::other::<impl distr::distribution::Distribution<()> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B, C)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I, J)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I, J, K)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I, J, K, L)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<(A,)> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> ( $($tyvar,)* ){\n                let out = ($(\n                    // use the $tyvar's to get the appropriate number of\n                    // repeats (they're not actually needed)\n                    rng.random::<$tyvar>()\n                ,)*);\n\n                // Suppress the unused variable warning for empty tuple\n                let _rng = rng;\n\n                out\n            }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<[T; N]> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> [T; N]{\n        array::from_fn(|_| rng.random())\n    }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<bool> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> bool{\n        // We can compare against an arbitrary bit of an u32 to get a bool.\n        // Because the least significant bits of a lower quality RNG can have\n        // simple patterns, we compare against the most significant bit. This is\n        // easiest done using a sign test.\n        (rng.next_u32() as i32) < 0\n    }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<char> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> char{\n        // A valid `char` is either in the interval `[0, 0xD800)` or\n        // `(0xDFFF, 0x11_0000)`. All `char`s must therefore be in\n        // `[0, 0x11_0000)` but not in the \"gap\" `[0xD800, 0xDFFF]` which is\n        // reserved for surrogates. This is the size of that gap.\n        const GAP_SIZE: u32 = 0xDFFF - 0xD800 + 1;\n\n        // Uniform::new(0, 0x11_0000 - GAP_SIZE) can also be used, but it\n        // seemed slower.\n        let range = Uniform::new(GAP_SIZE, 0x11_0000).unwrap();\n\n        let mut n = range.sample(rng);\n        if n <= 0xDFFF {\n            n -= GAP_SIZE;\n        }\n        // SAFETY: We ensure above that `n` represents a `char`.\n        unsafe { char::from_u32_unchecked(n) }\n    }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::Distribution<core::num::Wrapping<T>> for distr::StandardUniform>::sample":["#[inline]\nfn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Wrapping<T>{\n        Wrapping(rng.random())\n    }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::<impl distr::distribution::SampleString for distr::StandardUniform>::append_string":["fn append_string<R: Rng + ?Sized>(&self, rng: &mut R, s: &mut String, len: usize){\n        // A char is encoded with at most four bytes, thus this reservation is\n        // guaranteed to be sufficient. We do not shrink_to_fit afterwards so\n        // that repeated usage on the same `String` buffer does not reallocate.\n        s.reserve(4 * len);\n        s.extend(Distribution::<char>::sample_iter(self, rng).take(len));\n    }","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::Alphabetic":["/// Sample a [`u8`], uniformly distributed over letters:\n/// a-z and A-Z.\n///\n/// # Example\n///\n/// You're able to generate random Alphabetic characters via mapping or via the\n/// [`SampleString::sample_string`] method like so:\n///\n/// ```\n/// use rand::Rng;\n/// use rand::distr::{Alphabetic, SampleString};\n///\n/// // Manual mapping\n/// let mut rng = rand::rng();\n/// let chars: String = (0..7).map(|_| rng.sample(Alphabetic) as char).collect();\n/// println!(\"Random chars: {}\", chars);\n///\n/// // Using [`SampleString::sample_string`]\n/// let string = Alphabetic.sample_string(&mut rand::rng(), 16);\n/// println!(\"Random string: {}\", string);\n/// ```\n///\n/// # Passwords\n///\n/// Refer to [`Alphanumeric#Passwords`].\npub struct Alphabetic;","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::other::Alphanumeric":["/// Sample a `u8`, uniformly distributed over ASCII letters and numbers:\n/// a-z, A-Z and 0-9.\n///\n/// # Example\n///\n/// ```\n/// use rand::Rng;\n/// use rand::distr::Alphanumeric;\n///\n/// let mut rng = rand::rng();\n/// let chars: String = (0..7).map(|_| rng.sample(Alphanumeric) as char).collect();\n/// println!(\"Random chars: {}\", chars);\n/// ```\n///\n/// The [`SampleString`] trait provides an easier method of generating\n/// a random [`String`], and offers more efficient allocation:\n/// ```\n/// use rand::distr::{Alphanumeric, SampleString};\n/// let string = Alphanumeric.sample_string(&mut rand::rng(), 16);\n/// println!(\"Random string: {}\", string);\n/// ```\n///\n/// # Passwords\n///\n/// Users sometimes ask whether it is safe to use a string of random characters\n/// as a password. In principle, all RNGs in Rand implementing `CryptoRng` are\n/// suitable as a source of randomness for generating passwords (if they are\n/// properly seeded), but it is more conservative to only use randomness\n/// directly from the operating system via the `getrandom` crate, or the\n/// corresponding bindings of a crypto library.\n///\n/// When generating passwords or keys, it is important to consider the threat\n/// model and in some cases the memorability of the password. This is out of\n/// scope of the Rand project, and therefore we defer to the following\n/// references:\n///\n/// - [Wikipedia article on Password Strength](https://en.wikipedia.org/wiki/Password_strength)\n/// - [Diceware for generating memorable passwords](https://en.wikipedia.org/wiki/Diceware)\npub struct Alphanumeric;","Real(LocalPath(\"src/distr/other.rs\"))"],"distr::slice::Choose":["/// A distribution to uniformly sample elements of a slice\n///\n/// Like [`IndexedRandom::choose`], this uniformly samples elements of a slice\n/// without modification of the slice (so called \"sampling with replacement\").\n/// This distribution object may be a little faster for repeated sampling (but\n/// slower for small numbers of samples).\n///\n/// ## Examples\n///\n/// Since this is a distribution, [`Rng::sample_iter`] and\n/// [`Distribution::sample_iter`] may be used, for example:\n/// ```\n/// use rand::distr::{Distribution, slice::Choose};\n///\n/// let vowels = ['a', 'e', 'i', 'o', 'u'];\n/// let vowels_dist = Choose::new(&vowels).unwrap();\n///\n/// // build a string of 10 vowels\n/// let vowel_string: String = vowels_dist\n///     .sample_iter(&mut rand::rng())\n///     .take(10)\n///     .collect();\n///\n/// println!(\"{}\", vowel_string);\n/// assert_eq!(vowel_string.len(), 10);\n/// assert!(vowel_string.chars().all(|c| vowels.contains(&c)));\n/// ```\n///\n/// For a single sample, [`IndexedRandom::choose`] may be preferred:\n/// ```\n/// use rand::seq::IndexedRandom;\n///\n/// let vowels = ['a', 'e', 'i', 'o', 'u'];\n/// let mut rng = rand::rng();\n///\n/// println!(\"{}\", vowels.choose(&mut rng).unwrap());\n/// ```\n///\n/// [`IndexedRandom::choose`]: crate::seq::IndexedRandom::choose\n/// [`Rng::sample_iter`]: crate::Rng::sample_iter\npub struct Choose<'a, T> {\n    slice: &'a [T],\n    range: UniformUsize,\n    num_choices: NonZeroUsize,\n}","Real(LocalPath(\"src/distr/slice.rs\"))"],"distr::slice::Choose::<'a, T>::new":["/// Create a new `Choose` instance which samples uniformly from the slice.\n///\n/// Returns error [`Empty`] if the slice is empty.\npub fn new(slice: &'a [T]) -> Result<Self, Empty>{\n        let num_choices = NonZeroUsize::new(slice.len()).ok_or(Empty)?;\n\n        Ok(Self {\n            slice,\n            range: UniformUsize::new(0, num_choices.get()).unwrap(),\n            num_choices,\n        })\n    }","Real(LocalPath(\"src/distr/slice.rs\"))"],"distr::slice::Choose::<'a, T>::num_choices":["/// Returns the count of choices in this distribution\npub fn num_choices(&self) -> NonZeroUsize{\n        self.num_choices\n    }","Real(LocalPath(\"src/distr/slice.rs\"))"],"distr::slice::Empty":["/// Error: empty slice\n///\n/// This error is returned when [`Choose::new`] is given an empty slice.\npub struct Empty;","Real(LocalPath(\"src/distr/slice.rs\"))"],"distr::uniform::Error":["/// Error type returned from [`Uniform::new`] and `new_inclusive`.\npub enum Error {\n    /// `low > high`, or equal in case of exclusive range.\n    EmptyRange,\n    /// Input or range `high - low` is non-finite. Not relevant to integer types.\n    NonFinite,\n}","Real(LocalPath(\"src/distr/uniform.rs\"))"],"distr::uniform::SampleBorrow":["/// Helper trait similar to [`Borrow`] but implemented\n/// only for [`SampleUniform`] and references to [`SampleUniform`]\n/// in order to resolve ambiguity issues.\n///\n/// [`Borrow`]: std::borrow::Borrow\npub trait SampleBorrow<Borrowed> {\n    /// Immutably borrows from an owned value. See [`Borrow::borrow`]\n    ///\n    /// [`Borrow::borrow`]: std::borrow::Borrow::borrow\n    fn borrow(&self) -> &Borrowed;\n}","Real(LocalPath(\"src/distr/uniform.rs\"))"],"distr::uniform::SampleRange":["/// Range that supports generating a single sample efficiently.\n///\n/// Any type implementing this trait can be used to specify the sampled range\n/// for `Rng::random_range`.\npub trait SampleRange<T> {\n    /// Generate a sample from the given range.\n    fn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> Result<T, Error>;\n\n    /// Check whether the range is empty.\n    fn is_empty(&self) -> bool;\n}","Real(LocalPath(\"src/distr/uniform.rs\"))"],"distr::uniform::SampleUniform":["/// Helper trait for creating objects using the correct implementation of\n/// [`UniformSampler`] for the sampling type.\n///\n/// See the [module documentation] on how to implement [`Uniform`] range\n/// sampling for a custom type.\n///\n/// [module documentation]: crate::distr::uniform\npub trait SampleUniform: Sized {\n    /// The `UniformSampler` implementation supporting type `X`.\n    type Sampler: UniformSampler<X = Self>;\n}","Real(LocalPath(\"src/distr/uniform.rs\"))"],"distr::uniform::Uniform":["/// Sample values uniformly between two bounds.\n///\n/// # Construction\n///\n/// [`Uniform::new`] and [`Uniform::new_inclusive`] construct a uniform\n/// distribution sampling from the given `low` and `high` limits. `Uniform` may\n/// also be constructed via [`TryFrom`] as in `Uniform::try_from(1..=6).unwrap()`.\n///\n/// Constructors may do extra work up front to allow faster sampling of multiple\n/// values. Where only a single sample is required it is suggested to use\n/// [`Rng::random_range`] or one of the `sample_single` methods instead.\n///\n/// When sampling from a constant range, many calculations can happen at\n/// compile-time and all methods should be fast; for floating-point ranges and\n/// the full range of integer types, this should have comparable performance to\n/// the [`StandardUniform`](super::StandardUniform) distribution.\n///\n/// # Provided implementations\n///\n/// - `char` ([`UniformChar`]): samples a range over the implementation for `u32`\n/// - `f32`, `f64` ([`UniformFloat`]): samples approximately uniformly within a\n///   range; bias may be present in the least-significant bit of the significand\n///   and the limits of the input range may be sampled even when an open\n///   (exclusive) range is used\n/// - Integer types ([`UniformInt`]) may show a small bias relative to the\n///   expected uniform distribution of output. In the worst case, bias affects\n///   1 in `2^n` samples where n is 56 (`i8` and `u8`), 48 (`i16` and `u16`), 96\n///   (`i32` and `u32`), 64 (`i64` and `u64`), 128 (`i128` and `u128`).\n///   The `unbiased` feature flag fixes this bias.\n/// - `usize` ([`UniformUsize`]) is handled specially, using the `u32`\n///   implementation where possible to enable portable results across 32-bit and\n///   64-bit CPU architectures.\n/// - `Duration` ([`UniformDuration`]): samples a range over the implementation\n///   for `u32` or `u64`\n/// - SIMD types (requires [`simd_support`] feature) like x86's [`__m128i`]\n///   and `std::simd`'s [`u32x4`], [`f32x4`] and [`mask32x4`] types are\n///   effectively arrays of integer or floating-point types. Each lane is\n///   sampled independently from its own range, potentially with more efficient\n///   random-bit-usage than would be achieved with sequential sampling.\n///\n/// # Example\n///\n/// ```\n/// use rand::distr::{Distribution, Uniform};\n///\n/// let between = Uniform::try_from(10..10000).unwrap();\n/// let mut rng = rand::rng();\n/// let mut sum = 0;\n/// for _ in 0..1000 {\n///     sum += between.sample(&mut rng);\n/// }\n/// println!(\"{}\", sum);\n/// ```\n///\n/// For a single sample, [`Rng::random_range`] may be preferred:\n///\n/// ```\n/// use rand::Rng;\n///\n/// let mut rng = rand::rng();\n/// println!(\"{}\", rng.random_range(0..10));\n/// ```\n///\n/// [`new`]: Uniform::new\n/// [`new_inclusive`]: Uniform::new_inclusive\n/// [`Rng::random_range`]: Rng::random_range\n/// [`__m128i`]: https://doc.rust-lang.org/core/arch/x86/struct.__m128i.html\n/// [`u32x4`]: std::simd::u32x4\n/// [`f32x4`]: std::simd::f32x4\n/// [`mask32x4`]: std::simd::mask32x4\n/// [`simd_support`]: https://github.com/rust-random/rand#crate-features\npub struct Uniform<X: SampleUniform>(X::Sampler);","Real(LocalPath(\"src/distr/uniform.rs\"))"],"distr::uniform::Uniform::<X>::new":["/// Create a new `Uniform` instance, which samples uniformly from the half\n/// open range `[low, high)` (excluding `high`).\n///\n/// For discrete types (e.g. integers), samples will always be strictly less\n/// than `high`. For (approximations of) continuous types (e.g. `f32`, `f64`),\n/// samples may equal `high` due to loss of precision but may not be\n/// greater than `high`.\n///\n/// Fails if `low >= high`, or if `low`, `high` or the range `high - low` is\n/// non-finite. In release mode, only the range is checked.\npub fn new<B1, B2>(low: B1, high: B2) -> Result<Uniform<X>, Error>\n    where\n        B1: SampleBorrow<X> + Sized,\n        B2: SampleBorrow<X> + Sized,{\n        X::Sampler::new(low, high).map(Uniform)\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"distr::uniform::Uniform::<X>::new_inclusive":["/// Create a new `Uniform` instance, which samples uniformly from the closed\n/// range `[low, high]` (inclusive).\n///\n/// Fails if `low > high`, or if `low`, `high` or the range `high - low` is\n/// non-finite. In release mode, only the range is checked.\npub fn new_inclusive<B1, B2>(low: B1, high: B2) -> Result<Uniform<X>, Error>\n    where\n        B1: SampleBorrow<X> + Sized,\n        B2: SampleBorrow<X> + Sized,{\n        X::Sampler::new_inclusive(low, high).map(Uniform)\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"distr::uniform::UniformSampler":["/// Helper trait handling actual uniform sampling.\n///\n/// See the [module documentation] on how to implement [`Uniform`] range\n/// sampling for a custom type.\n///\n/// Implementation of [`sample_single`] is optional, and is only useful when\n/// the implementation can be faster than `Self::new(low, high).sample(rng)`.\n///\n/// [module documentation]: crate::distr::uniform\n/// [`sample_single`]: UniformSampler::sample_single\npub trait UniformSampler: Sized {\n    /// The type sampled by this implementation.\n    type X;\n\n    /// Construct self, with inclusive lower bound and exclusive upper bound `[low, high)`.\n    ///\n    /// For discrete types (e.g. integers), samples will always be strictly less\n    /// than `high`. For (approximations of) continuous types (e.g. `f32`, `f64`),\n    /// samples may equal `high` due to loss of precision but may not be\n    /// greater than `high`.\n    ///\n    /// Usually users should not call this directly but prefer to use\n    /// [`Uniform::new`].\n    fn new<B1, B2>(low: B1, high: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized;\n\n    /// Construct self, with inclusive bounds `[low, high]`.\n    ///\n    /// Usually users should not call this directly but prefer to use\n    /// [`Uniform::new_inclusive`].\n    fn new_inclusive<B1, B2>(low: B1, high: B2) -> Result<Self, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized;\n\n    /// Sample a value.\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X;\n\n    /// Sample a single value uniformly from a range with inclusive lower bound\n    /// and exclusive upper bound `[low, high)`.\n    ///\n    /// For discrete types (e.g. integers), samples will always be strictly less\n    /// than `high`. For (approximations of) continuous types (e.g. `f32`, `f64`),\n    /// samples may equal `high` due to loss of precision but may not be\n    /// greater than `high`.\n    ///\n    /// By default this is implemented using\n    /// `UniformSampler::new(low, high).sample(rng)`. However, for some types\n    /// more optimal implementations for single usage may be provided via this\n    /// method (which is the case for integers and floats).\n    /// Results may not be identical.\n    ///\n    /// Note that to use this method in a generic context, the type needs to be\n    /// retrieved via `SampleUniform::Sampler` as follows:\n    /// ```\n    /// use rand::distr::uniform::{SampleUniform, UniformSampler};\n    /// # #[allow(unused)]\n    /// fn sample_from_range<T: SampleUniform>(lb: T, ub: T) -> T {\n    ///     let mut rng = rand::rng();\n    ///     <T as SampleUniform>::Sampler::sample_single(lb, ub, &mut rng).unwrap()\n    /// }\n    /// ```\n    fn sample_single<R: Rng + ?Sized, B1, B2>(\n        low: B1,\n        high: B2,\n        rng: &mut R,\n    ) -> Result<Self::X, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,\n    {\n        let uniform: Self = UniformSampler::new(low, high)?;\n        Ok(uniform.sample(rng))\n    }\n\n    /// Sample a single value uniformly from a range with inclusive lower bound\n    /// and inclusive upper bound `[low, high]`.\n    ///\n    /// By default this is implemented using\n    /// `UniformSampler::new_inclusive(low, high).sample(rng)`. However, for\n    /// some types more optimal implementations for single usage may be provided\n    /// via this method.\n    /// Results may not be identical.\n    fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n        low: B1,\n        high: B2,\n        rng: &mut R,\n    ) -> Result<Self::X, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,\n    {\n        let uniform: Self = UniformSampler::new_inclusive(low, high)?;\n        Ok(uniform.sample(rng))\n    }\n}","Real(LocalPath(\"src/distr/uniform.rs\"))"],"distr::uniform::UniformSampler::sample_single":["/// Sample a single value uniformly from a range with inclusive lower bound\n/// and exclusive upper bound `[low, high)`.\n///\n/// For discrete types (e.g. integers), samples will always be strictly less\n/// than `high`. For (approximations of) continuous types (e.g. `f32`, `f64`),\n/// samples may equal `high` due to loss of precision but may not be\n/// greater than `high`.\n///\n/// By default this is implemented using\n/// `UniformSampler::new(low, high).sample(rng)`. However, for some types\n/// more optimal implementations for single usage may be provided via this\n/// method (which is the case for integers and floats).\n/// Results may not be identical.\n///\n/// Note that to use this method in a generic context, the type needs to be\n/// retrieved via `SampleUniform::Sampler` as follows:\n/// ```\n/// use rand::distr::uniform::{SampleUniform, UniformSampler};\n/// # #[allow(unused)]\n/// fn sample_from_range<T: SampleUniform>(lb: T, ub: T) -> T {\n///     let mut rng = rand::rng();\n///     <T as SampleUniform>::Sampler::sample_single(lb, ub, &mut rng).unwrap()\n/// }\n/// ```\nfn sample_single<R: Rng + ?Sized, B1, B2>(\n        low: B1,\n        high: B2,\n        rng: &mut R,\n    ) -> Result<Self::X, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,{\n        let uniform: Self = UniformSampler::new(low, high)?;\n        Ok(uniform.sample(rng))\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"distr::uniform::UniformSampler::sample_single_inclusive":["/// Sample a single value uniformly from a range with inclusive lower bound\n/// and inclusive upper bound `[low, high]`.\n///\n/// By default this is implemented using\n/// `UniformSampler::new_inclusive(low, high).sample(rng)`. However, for\n/// some types more optimal implementations for single usage may be provided\n/// via this method.\n/// Results may not be identical.\nfn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(\n        low: B1,\n        high: B2,\n        rng: &mut R,\n    ) -> Result<Self::X, Error>\n    where\n        B1: SampleBorrow<Self::X> + Sized,\n        B2: SampleBorrow<Self::X> + Sized,{\n        let uniform: Self = UniformSampler::new_inclusive(low, high)?;\n        Ok(uniform.sample(rng))\n    }","Real(LocalPath(\"src/distr/uniform.rs\"))"],"distr::uniform::float::UniformFloat":["/// The back-end implementing [`UniformSampler`] for floating-point types.\n///\n/// Unless you are implementing [`UniformSampler`] for your own type, this type\n/// should not be used directly, use [`Uniform`] instead.\n///\n/// # Implementation notes\n///\n/// `UniformFloat` implementations convert RNG output to a float in the range\n/// `[1, 2)` via transmutation, map this to `[0, 1)`, then scale and translate\n/// to the desired range. Values produced this way have what equals 23 bits of\n/// random digits for an `f32` and 52 for an `f64`.\n///\n/// # Bias and range errors\n///\n/// Bias may be expected within the least-significant bit of the significand.\n/// It is not guaranteed that exclusive limits of a range are respected; i.e.\n/// when sampling the range `[a, b)` it is not guaranteed that `b` is never\n/// sampled.\n///\n/// [`new`]: UniformSampler::new\n/// [`new_inclusive`]: UniformSampler::new_inclusive\n/// [`StandardUniform`]: crate::distr::StandardUniform\n/// [`Uniform`]: super::Uniform\npub struct UniformFloat<X> {\n    low: X,\n    scale: X,\n}","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"distr::uniform::float::UniformFloat::<f32>::new_bounded":["/// Construct, reducing `scale` as required to ensure that rounding\n/// can never yield values greater than `high`.\n///\n/// Note: though it may be tempting to use a variant of this method\n/// to ensure that samples from `[low, high)` are always strictly\n/// less than `high`, this approach may be very slow where\n/// `scale.abs()` is much smaller than `high.abs()`\n/// (example: `low=0.99999999997819644, high=1.`).\nfn new_bounded(low: $ty, high: $ty, mut scale: $ty) -> Self{\n                let max_rand = <$ty>::splat(1.0 as $f_scalar - $f_scalar::EPSILON);\n\n                loop {\n                    let mask = (scale * max_rand + low).gt_mask(high);\n                    if !mask.any() {\n                        break;\n                    }\n                    scale = scale.decrease_masked(mask);\n                }\n\n                debug_assert!(<$ty>::splat(0.0).all_le(scale));\n\n                UniformFloat { low, scale }\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"distr::uniform::float::UniformFloat::<f64>::new_bounded":["/// Construct, reducing `scale` as required to ensure that rounding\n/// can never yield values greater than `high`.\n///\n/// Note: though it may be tempting to use a variant of this method\n/// to ensure that samples from `[low, high)` are always strictly\n/// less than `high`, this approach may be very slow where\n/// `scale.abs()` is much smaller than `high.abs()`\n/// (example: `low=0.99999999997819644, high=1.`).\nfn new_bounded(low: $ty, high: $ty, mut scale: $ty) -> Self{\n                let max_rand = <$ty>::splat(1.0 as $f_scalar - $f_scalar::EPSILON);\n\n                loop {\n                    let mask = (scale * max_rand + low).gt_mask(high);\n                    if !mask.any() {\n                        break;\n                    }\n                    scale = scale.decrease_masked(mask);\n                }\n\n                debug_assert!(<$ty>::splat(0.0).all_le(scale));\n\n                UniformFloat { low, scale }\n            }","Real(LocalPath(\"src/distr/uniform_float.rs\"))"],"distr::uniform::int::UniformInt":["/// The back-end implementing [`UniformSampler`] for integer types.\n///\n/// Unless you are implementing [`UniformSampler`] for your own type, this type\n/// should not be used directly, use [`Uniform`] instead.\n///\n/// # Implementation notes\n///\n/// For simplicity, we use the same generic struct `UniformInt<X>` for all\n/// integer types `X`. This gives us only one field type, `X`; to store unsigned\n/// values of this size, we take use the fact that these conversions are no-ops.\n///\n/// For a closed range, the number of possible numbers we should generate is\n/// `range = (high - low + 1)`. To avoid bias, we must ensure that the size of\n/// our sample space, `zone`, is a multiple of `range`; other values must be\n/// rejected (by replacing with a new random sample).\n///\n/// As a special case, we use `range = 0` to represent the full range of the\n/// result type (i.e. for `new_inclusive($ty::MIN, $ty::MAX)`).\n///\n/// The optimum `zone` is the largest product of `range` which fits in our\n/// (unsigned) target type. We calculate this by calculating how many numbers we\n/// must reject: `reject = (MAX + 1) % range = (MAX - range + 1) % range`. Any (large)\n/// product of `range` will suffice, thus in `sample_single` we multiply by a\n/// power of 2 via bit-shifting (faster but may cause more rejections).\n///\n/// The smallest integer PRNGs generate is `u32`. For 8- and 16-bit outputs we\n/// use `u32` for our `zone` and samples (because it's not slower and because\n/// it reduces the chance of having to reject a sample). In this case we cannot\n/// store `zone` in the target type since it is too large, however we know\n/// `ints_to_reject < range <= $uty::MAX`.\n///\n/// An alternative to using a modulus is widening multiply: After a widening\n/// multiply by `range`, the result is in the high word. Then comparing the low\n/// word against `zone` makes sure our distribution is uniform.\n///\n/// # Bias\n///\n/// Unless the `unbiased` feature flag is used, outputs may have a small bias.\n/// In the worst case, bias affects 1 in `2^n` samples where n is\n/// 56 (`i8` and `u8`), 48 (`i16` and `u16`), 96 (`i32` and `u32`), 64 (`i64`\n/// and `u64`), 128 (`i128` and `u128`).\n///\n/// [`Uniform`]: super::Uniform\npub struct UniformInt<X> {\n    pub(super) low: X,\n    pub(super) range: X,\n    thresh: X, // effectively 2.pow(max(64, uty_bits)) % range\n}","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"distr::uniform::int::UniformUsize":["/// The back-end implementing [`UniformSampler`] for `usize`.\n///\n/// # Implementation notes\n///\n/// Sampling a `usize` value is usually used in relation to the length of an\n/// array or other memory structure, thus it is reasonable to assume that the\n/// vast majority of use-cases will have a maximum size under [`u32::MAX`].\n/// In part to optimise for this use-case, but mostly to ensure that results\n/// are portable across 32-bit and 64-bit architectures (as far as is possible),\n/// this implementation will use 32-bit sampling when possible.\n#[cfg(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))]\npub struct UniformUsize {\n    low: usize,\n    range: usize,\n    thresh: usize,\n    #[cfg(target_pointer_width = \"64\")]\n    mode64: bool,\n}","Real(LocalPath(\"src/distr/uniform_int.rs\"))"],"distr::uniform::other::<impl distr::distribution::SampleString for distr::uniform::Uniform<char>>::append_string":["fn append_string<R: Rng + ?Sized>(\n        &self,\n        rng: &mut R,\n        string: &mut alloc::string::String,\n        len: usize,\n    ){\n        // Getting the hi value to assume the required length to reserve in string.\n        let mut hi = self.0.sampler.low + self.0.sampler.range - 1;\n        if hi >= CHAR_SURROGATE_START {\n            hi += CHAR_SURROGATE_LEN;\n        }\n        // Get the utf8 length of hi to minimize extra space.\n        let max_char_len = char::from_u32(hi).map(char::len_utf8).unwrap_or(4);\n        string.reserve(max_char_len * len);\n        string.extend(self.sample_iter(rng).take(len))\n    }","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"distr::uniform::other::UniformChar":["/// The back-end implementing [`UniformSampler`] for `char`.\n///\n/// Unless you are implementing [`UniformSampler`] for your own type, this type\n/// should not be used directly, use [`Uniform`] instead.\n///\n/// This differs from integer range sampling since the range `0xD800..=0xDFFF`\n/// are used for surrogate pairs in UCS and UTF-16, and consequently are not\n/// valid Unicode code points. We must therefore avoid sampling values in this\n/// range.\npub struct UniformChar {\n    sampler: UniformInt<u32>,\n}","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"distr::uniform::other::UniformDuration":["/// The back-end implementing [`UniformSampler`] for `Duration`.\n///\n/// Unless you are implementing [`UniformSampler`] for your own types, this type\n/// should not be used directly, use [`Uniform`] instead.\npub struct UniformDuration {\n    mode: UniformDurationMode,\n    offset: u32,\n}","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"distr::uniform::other::UniformDurationMode":["enum UniformDurationMode {\n    Small {\n        secs: u64,\n        nanos: Uniform<u32>,\n    },\n    Medium {\n        nanos: Uniform<u64>,\n    },\n    Large {\n        max_secs: u64,\n        max_nanos: u32,\n        secs: Uniform<u64>,\n    },\n}","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"distr::uniform::other::char_to_comp_u32":["/// Convert `char` to compressed `u32`\nfn char_to_comp_u32(c: char) -> u32{\n    match c as u32 {\n        c if c >= CHAR_SURROGATE_START => c - CHAR_SURROGATE_LEN,\n        c => c,\n    }\n}","Real(LocalPath(\"src/distr/uniform_other.rs\"))"],"distr::utils::BoolAsSIMD":["pub(crate) trait BoolAsSIMD: Sized {\n    fn any(self) -> bool;\n}","Real(LocalPath(\"src/distr/utils.rs\"))"],"distr::utils::FloatAsSIMD":["/// Implement functions on f32/f64 to give them APIs similar to SIMD types\npub(crate) trait FloatAsSIMD: Sized {\n    #[cfg(test)]\n    const LEN: usize = 1;\n\n    #[inline(always)]\n    fn splat(scalar: Self) -> Self {\n        scalar\n    }\n}","Real(LocalPath(\"src/distr/utils.rs\"))"],"distr::utils::FloatAsSIMD::splat":["#[inline(always)]\nfn splat(scalar: Self) -> Self{\n        scalar\n    }","Real(LocalPath(\"src/distr/utils.rs\"))"],"distr::utils::FloatSIMDUtils":["/// Helper trait when dealing with scalar and SIMD floating point types.\npub(crate) trait FloatSIMDUtils {\n    // `PartialOrd` for vectors compares lexicographically. We want to compare all\n    // the individual SIMD lanes instead, and get the combined result over all\n    // lanes. This is possible using something like `a.lt(b).all()`, but we\n    // implement it as a trait so we can write the same code for `f32` and `f64`.\n    // Only the comparison functions we need are implemented.\n    fn all_lt(self, other: Self) -> bool;\n    fn all_le(self, other: Self) -> bool;\n    fn all_finite(self) -> bool;\n\n    type Mask;\n    fn gt_mask(self, other: Self) -> Self::Mask;\n\n    // Decrease all lanes where the mask is `true` to the next lower value\n    // representable by the floating-point type. At least one of the lanes\n    // must be set.\n    fn decrease_masked(self, mask: Self::Mask) -> Self;\n\n    // Convert from int value. Conversion is done while retaining the numerical\n    // value, not by retaining the binary representation.\n    type UInt;\n    fn cast_from_int(i: Self::UInt) -> Self;\n}","Real(LocalPath(\"src/distr/utils.rs\"))"],"distr::utils::IntAsSIMD":["pub(crate) trait IntAsSIMD: Sized {\n    #[inline(always)]\n    fn splat(scalar: Self) -> Self {\n        scalar\n    }\n}","Real(LocalPath(\"src/distr/utils.rs\"))"],"distr::utils::IntAsSIMD::splat":["#[inline(always)]\nfn splat(scalar: Self) -> Self{\n        scalar\n    }","Real(LocalPath(\"src/distr/utils.rs\"))"],"distr::utils::WideningMultiply":["pub(crate) trait WideningMultiply<RHS = Self> {\n    type Output;\n\n    fn wmul(self, x: RHS) -> Self::Output;\n}","Real(LocalPath(\"src/distr/utils.rs\"))"],"distr::weighted::Error":["/// Invalid weight errors\n///\n/// This type represents errors from [`WeightedIndex::new`],\n/// [`WeightedIndex::update_weights`] and other weighted distributions.\n#[non_exhaustive]\npub enum Error {\n    /// The input weight sequence is empty, too long, or wrongly ordered\n    InvalidInput,\n\n    /// A weight is negative, too large for the distribution, or not a valid number\n    InvalidWeight,\n\n    /// Not enough non-zero weights are available to sample values\n    ///\n    /// When attempting to sample a single value this implies that all weights\n    /// are zero. When attempting to sample `amount` values this implies that\n    /// less than `amount` weights are greater than zero.\n    InsufficientNonZero,\n\n    /// Overflow when calculating the sum of weights\n    Overflow,\n}","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"distr::weighted::Weight":["/// Bounds on a weight\n///\n/// See usage in [`WeightedIndex`].\npub trait Weight: Clone {\n    /// Representation of 0\n    const ZERO: Self;\n\n    /// Checked addition\n    ///\n    /// -   `Result::Ok`: On success, `v` is added to `self`\n    /// -   `Result::Err`: Returns an error when `Self` cannot represent the\n    ///     result of `self + v` (i.e. overflow). The value of `self` should be\n    ///     discarded.\n    #[allow(clippy::result_unit_err)]\n    fn checked_add_assign(&mut self, v: &Self) -> Result<(), ()>;\n}","Real(LocalPath(\"src/distr/weighted/mod.rs\"))"],"distr::weighted::weighted_index::WeightedIndex":["/// A distribution using weighted sampling of discrete items.\n///\n/// Sampling a `WeightedIndex` distribution returns the index of a randomly\n/// selected element from the iterator used when the `WeightedIndex` was\n/// created. The chance of a given element being picked is proportional to the\n/// weight of the element. The weights can use any type `X` for which an\n/// implementation of [`Uniform<X>`] exists. The implementation guarantees that\n/// elements with zero weight are never picked, even when the weights are\n/// floating point numbers.\n///\n/// # Performance\n///\n/// Time complexity of sampling from `WeightedIndex` is `O(log N)` where\n/// `N` is the number of weights.\n/// See also [`rand_distr::weighted`] for alternative implementations supporting\n/// potentially-faster sampling or a more easily modifiable tree structure.\n///\n/// A `WeightedIndex<X>` contains a `Vec<X>` and a [`Uniform<X>`] and so its\n/// size is the sum of the size of those objects, possibly plus some alignment.\n///\n/// Creating a `WeightedIndex<X>` will allocate enough space to hold `N - 1`\n/// weights of type `X`, where `N` is the number of weights. However, since\n/// `Vec` doesn't guarantee a particular growth strategy, additional memory\n/// might be allocated but not used. Since the `WeightedIndex` object also\n/// contains an instance of `X::Sampler`, this might cause additional allocations,\n/// though for primitive types, [`Uniform<X>`] doesn't allocate any memory.\n///\n/// Sampling from `WeightedIndex` will result in a single call to\n/// `Uniform<X>::sample` (method of the [`Distribution`] trait), which typically\n/// will request a single value from the underlying [`RngCore`], though the\n/// exact number depends on the implementation of `Uniform<X>::sample`.\n///\n/// # Example\n///\n/// ```\n/// use rand::prelude::*;\n/// use rand::distr::weighted::WeightedIndex;\n///\n/// let choices = ['a', 'b', 'c'];\n/// let weights = [2,   1,   1];\n/// let dist = WeightedIndex::new(&weights).unwrap();\n/// let mut rng = rand::rng();\n/// for _ in 0..100 {\n///     // 50% chance to print 'a', 25% chance to print 'b', 25% chance to print 'c'\n///     println!(\"{}\", choices[dist.sample(&mut rng)]);\n/// }\n///\n/// let items = [('a', 0.0), ('b', 3.0), ('c', 7.0)];\n/// let dist2 = WeightedIndex::new(items.iter().map(|item| item.1)).unwrap();\n/// for _ in 0..100 {\n///     // 0% chance to print 'a', 30% chance to print 'b', 70% chance to print 'c'\n///     println!(\"{}\", items[dist2.sample(&mut rng)].0);\n/// }\n/// ```\n///\n/// [`Uniform<X>`]: crate::distr::Uniform\n/// [`RngCore`]: crate::RngCore\n/// [`rand_distr::weighted`]: https://docs.rs/rand_distr/latest/rand_distr/weighted/index.html\npub struct WeightedIndex<X: SampleUniform + PartialOrd> {\n    cumulative_weights: Vec<X>,\n    total_weight: X,\n    weight_distribution: X::Sampler,\n}","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"distr::weighted::weighted_index::WeightedIndex::<X>::new":["/// Creates a new a `WeightedIndex` [`Distribution`] using the values\n/// in `weights`. The weights can use any type `X` for which an\n/// implementation of [`Uniform<X>`] exists.\n///\n/// Error cases:\n/// -   [`Error::InvalidInput`] when the iterator `weights` is empty.\n/// -   [`Error::InvalidWeight`] when a weight is not-a-number or negative.\n/// -   [`Error::InsufficientNonZero`] when the sum of all weights is zero.\n/// -   [`Error::Overflow`] when the sum of all weights overflows.\n///\n/// [`Uniform<X>`]: crate::distr::uniform::Uniform\npub fn new<I>(weights: I) -> Result<WeightedIndex<X>, Error>\n    where\n        I: IntoIterator,\n        I::Item: SampleBorrow<X>,\n        X: Weight,{\n        let mut iter = weights.into_iter();\n        let mut total_weight: X = iter.next().ok_or(Error::InvalidInput)?.borrow().clone();\n\n        let zero = X::ZERO;\n        if !(total_weight >= zero) {\n            return Err(Error::InvalidWeight);\n        }\n\n        let mut weights = Vec::<X>::with_capacity(iter.size_hint().0);\n        for w in iter {\n            // Note that `!(w >= x)` is not equivalent to `w < x` for partially\n            // ordered types due to NaNs which are equal to nothing.\n            if !(w.borrow() >= &zero) {\n                return Err(Error::InvalidWeight);\n            }\n            weights.push(total_weight.clone());\n\n            if let Err(()) = total_weight.checked_add_assign(w.borrow()) {\n                return Err(Error::Overflow);\n            }\n        }\n\n        if total_weight == zero {\n            return Err(Error::InsufficientNonZero);\n        }\n        let distr = X::Sampler::new(zero, total_weight.clone()).unwrap();\n\n        Ok(WeightedIndex {\n            cumulative_weights: weights,\n            total_weight,\n            weight_distribution: distr,\n        })\n    }","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"distr::weighted::weighted_index::WeightedIndex::<X>::total_weight":["/// Returns the sum of all weights in this distribution.\npub fn total_weight(&self) -> X{\n        self.total_weight.clone()\n    }","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"distr::weighted::weighted_index::WeightedIndex::<X>::update_weights":["/// Update a subset of weights, without changing the number of weights.\n///\n/// `new_weights` must be sorted by the index.\n///\n/// Using this method instead of `new` might be more efficient if only a small number of\n/// weights is modified. No allocations are performed, unless the weight type `X` uses\n/// allocation internally.\n///\n/// In case of error, `self` is not modified. Error cases:\n/// -   [`Error::InvalidInput`] when `new_weights` are not ordered by\n///     index or an index is too large.\n/// -   [`Error::InvalidWeight`] when a weight is not-a-number or negative.\n/// -   [`Error::InsufficientNonZero`] when the sum of all weights is zero.\n///     Note that due to floating-point loss of precision, this case is not\n///     always correctly detected; usage of a fixed-point weight type may be\n///     preferred.\n///\n/// Updates take `O(N)` time. If you need to frequently update weights, consider\n/// [`rand_distr::weighted_tree`](https://docs.rs/rand_distr/*/rand_distr/weighted_tree/index.html)\n/// as an alternative where an update is `O(log N)`.\npub fn update_weights(&mut self, new_weights: &[(usize, &X)]) -> Result<(), Error>\n    where\n        X: for<'a> core::ops::AddAssign<&'a X>\n            + for<'a> core::ops::SubAssign<&'a X>\n            + Clone\n            + Default,{\n        if new_weights.is_empty() {\n            return Ok(());\n        }\n\n        let zero = <X as Default>::default();\n\n        let mut total_weight = self.total_weight.clone();\n\n        // Check for errors first, so we don't modify `self` in case something\n        // goes wrong.\n        let mut prev_i = None;\n        for &(i, w) in new_weights {\n            if let Some(old_i) = prev_i {\n                if old_i >= i {\n                    return Err(Error::InvalidInput);\n                }\n            }\n            if !(*w >= zero) {\n                return Err(Error::InvalidWeight);\n            }\n            if i > self.cumulative_weights.len() {\n                return Err(Error::InvalidInput);\n            }\n\n            let mut old_w = if i < self.cumulative_weights.len() {\n                self.cumulative_weights[i].clone()\n            } else {\n                self.total_weight.clone()\n            };\n            if i > 0 {\n                old_w -= &self.cumulative_weights[i - 1];\n            }\n\n            total_weight -= &old_w;\n            total_weight += w;\n            prev_i = Some(i);\n        }\n        if total_weight <= zero {\n            return Err(Error::InsufficientNonZero);\n        }\n\n        // Update the weights. Because we checked all the preconditions in the\n        // previous loop, this should never panic.\n        let mut iter = new_weights.iter();\n\n        let mut prev_weight = zero.clone();\n        let mut next_new_weight = iter.next();\n        let &(first_new_index, _) = next_new_weight.unwrap();\n        let mut cumulative_weight = if first_new_index > 0 {\n            self.cumulative_weights[first_new_index - 1].clone()\n        } else {\n            zero.clone()\n        };\n        for i in first_new_index..self.cumulative_weights.len() {\n            match next_new_weight {\n                Some(&(j, w)) if i == j => {\n                    cumulative_weight += w;\n                    next_new_weight = iter.next();\n                }\n                _ => {\n                    let mut tmp = self.cumulative_weights[i].clone();\n                    tmp -= &prev_weight; // We know this is positive.\n                    cumulative_weight += &tmp;\n                }\n            }\n            prev_weight = cumulative_weight.clone();\n            core::mem::swap(&mut prev_weight, &mut self.cumulative_weights[i]);\n        }\n\n        self.total_weight = total_weight;\n        self.weight_distribution = X::Sampler::new(zero, self.total_weight.clone()).unwrap();\n\n        Ok(())\n    }","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"distr::weighted::weighted_index::WeightedIndex::<X>::weight":["/// Returns the weight at the given index, if it exists.\n///\n/// If the index is out of bounds, this will return `None`.\n///\n/// # Example\n///\n/// ```\n/// use rand::distr::weighted::WeightedIndex;\n///\n/// let weights = [0, 1, 2];\n/// let dist = WeightedIndex::new(&weights).unwrap();\n/// assert_eq!(dist.weight(0), Some(0));\n/// assert_eq!(dist.weight(1), Some(1));\n/// assert_eq!(dist.weight(2), Some(2));\n/// assert_eq!(dist.weight(3), None);\n/// ```\npub fn weight(&self, index: usize) -> Option<X>\n    where\n        X: for<'a> core::ops::SubAssign<&'a X>,{\n        use core::cmp::Ordering::*;\n\n        let mut weight = match index.cmp(&self.cumulative_weights.len()) {\n            Less => self.cumulative_weights[index].clone(),\n            Equal => self.total_weight.clone(),\n            Greater => return None,\n        };\n\n        if index > 0 {\n            weight -= &self.cumulative_weights[index - 1];\n        }\n        Some(weight)\n    }","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"distr::weighted::weighted_index::WeightedIndex::<X>::weights":["/// Returns a lazy-loading iterator containing the current weights of this distribution.\n///\n/// If this distribution has not been updated since its creation, this will return the\n/// same weights as were passed to `new`.\n///\n/// # Example\n///\n/// ```\n/// use rand::distr::weighted::WeightedIndex;\n///\n/// let weights = [1, 2, 3];\n/// let mut dist = WeightedIndex::new(&weights).unwrap();\n/// assert_eq!(dist.weights().collect::<Vec<_>>(), vec![1, 2, 3]);\n/// dist.update_weights(&[(0, &2)]).unwrap();\n/// assert_eq!(dist.weights().collect::<Vec<_>>(), vec![2, 2, 3]);\n/// ```\npub fn weights(&self) -> WeightedIndexIter<'_, X>\n    where\n        X: for<'a> core::ops::SubAssign<&'a X>,{\n        WeightedIndexIter {\n            weighted_index: self,\n            index: 0,\n        }\n    }","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"distr::weighted::weighted_index::WeightedIndexIter":["/// A lazy-loading iterator over the weights of a `WeightedIndex` distribution.\n/// This is returned by [`WeightedIndex::weights`].\npub struct WeightedIndexIter<'a, X: SampleUniform + PartialOrd> {\n    weighted_index: &'a WeightedIndex<X>,\n    index: usize,\n}","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))"],"fill":["/// Fill any type implementing [`Fill`] with random data\n///\n/// This function is shorthand for\n/// <code>[rng()].[fill](Rng::fill)(<var>dest</var>)</code>.\n///\n/// # Example\n///\n/// ```\n/// let mut arr = [0i8; 20];\n/// rand::fill(&mut arr[..]);\n/// ```\n///\n/// Note that you can instead use [`random()`] to generate an array of random\n/// data, though this is slower for small elements (smaller than the RNG word\n/// size).\n#[cfg(feature = \"thread_rng\")]\n#[inline]\n#[track_caller]\npub fn fill<T: Fill + ?Sized>(dest: &mut T){\n    dest.fill(&mut rng())\n}","Real(LocalPath(\"src/lib.rs\"))"],"random":["/// Generate a random value using the thread-local random number generator.\n///\n/// This function is shorthand for <code>[rng()].[random()](Rng::random)</code>:\n///\n/// -   See [`ThreadRng`] for documentation of the generator and security\n/// -   See [`StandardUniform`] for documentation of supported types and distributions\n///\n/// # Examples\n///\n/// ```\n/// let x = rand::random::<u8>();\n/// println!(\"{}\", x);\n///\n/// let y = rand::random::<f64>();\n/// println!(\"{}\", y);\n///\n/// if rand::random() { // generates a boolean\n///     println!(\"Better lucky than good!\");\n/// }\n/// ```\n///\n/// If you're calling `random()` repeatedly, consider using a local `rng`\n/// handle to save an initialization-check on each usage:\n///\n/// ```\n/// use rand::Rng; // provides the `random` method\n///\n/// let mut rng = rand::rng(); // a local handle to the generator\n///\n/// let mut v = vec![1, 2, 3];\n///\n/// for x in v.iter_mut() {\n///     *x = rng.random();\n/// }\n/// ```\n///\n/// [`StandardUniform`]: distr::StandardUniform\n/// [`ThreadRng`]: rngs::ThreadRng\n#[cfg(feature = \"thread_rng\")]\n#[inline]\npub fn random<T>() -> T\nwhere\n    StandardUniform: Distribution<T>,{\n    rng().random()\n}","Real(LocalPath(\"src/lib.rs\"))"],"random_bool":["/// Return a bool with a probability `p` of being true.\n///\n/// This function is shorthand for\n/// <code>[rng()].[random_bool](Rng::random_bool)(<var>p</var>)</code>.\n///\n/// # Example\n///\n/// ```\n/// println!(\"{}\", rand::random_bool(1.0 / 3.0));\n/// ```\n///\n/// # Panics\n///\n/// If `p < 0` or `p > 1`.\n#[cfg(feature = \"thread_rng\")]\n#[inline]\n#[track_caller]\npub fn random_bool(p: f64) -> bool{\n    rng().random_bool(p)\n}","Real(LocalPath(\"src/lib.rs\"))"],"random_iter":["/// Return an iterator over [`random()`] variates\n///\n/// This function is shorthand for\n/// <code>[rng()].[random_iter](Rng::random_iter)()</code>.\n///\n/// # Example\n///\n/// ```\n/// let v: Vec<i32> = rand::random_iter().take(5).collect();\n/// println!(\"{v:?}\");\n/// ```\n#[cfg(feature = \"thread_rng\")]\n#[inline]\npub fn random_iter<T>() -> distr::Iter<StandardUniform, rngs::ThreadRng, T>\nwhere\n    StandardUniform: Distribution<T>,{\n    rng().random_iter()\n}","Real(LocalPath(\"src/lib.rs\"))"],"random_range":["/// Generate a random value in the given range using the thread-local random number generator.\n///\n/// This function is shorthand for\n/// <code>[rng()].[random_range](Rng::random_range)(<var>range</var>)</code>.\n///\n/// # Example\n///\n/// ```\n/// let y: f32 = rand::random_range(0.0..=1e9);\n/// println!(\"{}\", y);\n///\n/// let words: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n/// println!(\"{}\", words[rand::random_range(..words.len())]);\n/// ```\n/// Note that the first example can also be achieved (without `collect`'ing\n/// to a `Vec`) using [`seq::IteratorRandom::choose`].\n#[cfg(feature = \"thread_rng\")]\n#[inline]\npub fn random_range<T, R>(range: R) -> T\nwhere\n    T: distr::uniform::SampleUniform,\n    R: distr::uniform::SampleRange<T>,{\n    rng().random_range(range)\n}","Real(LocalPath(\"src/lib.rs\"))"],"random_ratio":["/// Return a bool with a probability of `numerator/denominator` of being\n/// true.\n///\n/// That is, `random_ratio(2, 3)` has chance of 2 in 3, or about 67%, of\n/// returning true. If `numerator == denominator`, then the returned value\n/// is guaranteed to be `true`. If `numerator == 0`, then the returned\n/// value is guaranteed to be `false`.\n///\n/// See also the [`Bernoulli`] distribution, which may be faster if\n/// sampling from the same `numerator` and `denominator` repeatedly.\n///\n/// This function is shorthand for\n/// <code>[rng()].[random_ratio](Rng::random_ratio)(<var>numerator</var>, <var>denominator</var>)</code>.\n///\n/// # Panics\n///\n/// If `denominator == 0` or `numerator > denominator`.\n///\n/// # Example\n///\n/// ```\n/// println!(\"{}\", rand::random_ratio(2, 3));\n/// ```\n///\n/// [`Bernoulli`]: distr::Bernoulli\n#[cfg(feature = \"thread_rng\")]\n#[inline]\n#[track_caller]\npub fn random_ratio(numerator: u32, denominator: u32) -> bool{\n    rng().random_ratio(numerator, denominator)\n}","Real(LocalPath(\"src/lib.rs\"))"],"rng::Fill":["/// Types which may be filled with random data\n///\n/// This trait allows arrays to be efficiently filled with random data.\n///\n/// Implementations are expected to be portable across machines unless\n/// clearly documented otherwise (see the\n/// [Chapter on Portability](https://rust-random.github.io/book/portability.html)).\npub trait Fill {\n    /// Fill self with random data\n    fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R);\n}","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng":["/// User-level interface for RNGs\n///\n/// [`RngCore`] is the `dyn`-safe implementation-level interface for Random\n/// (Number) Generators. This trait, `Rng`, provides a user-level interface on\n/// RNGs. It is implemented automatically for any `R: RngCore`.\n///\n/// This trait must usually be brought into scope via `use rand::Rng;` or\n/// `use rand::prelude::*;`.\n///\n/// # Generic usage\n///\n/// The basic pattern is `fn foo<R: Rng + ?Sized>(rng: &mut R)`. Some\n/// things are worth noting here:\n///\n/// - Since `Rng: RngCore` and every `RngCore` implements `Rng`, it makes no\n///   difference whether we use `R: Rng` or `R: RngCore`.\n/// - The `+ ?Sized` un-bounding allows functions to be called directly on\n///   type-erased references; i.e. `foo(r)` where `r: &mut dyn RngCore`. Without\n///   this it would be necessary to write `foo(&mut r)`.\n///\n/// An alternative pattern is possible: `fn foo<R: Rng>(rng: R)`. This has some\n/// trade-offs. It allows the argument to be consumed directly without a `&mut`\n/// (which is how `from_rng(rand::rng())` works); also it still works directly\n/// on references (including type-erased references). Unfortunately within the\n/// function `foo` it is not known whether `rng` is a reference type or not,\n/// hence many uses of `rng` require an extra reference, either explicitly\n/// (`distr.sample(&mut rng)`) or implicitly (`rng.random()`); one may hope the\n/// optimiser can remove redundant references later.\n///\n/// Example:\n///\n/// ```\n/// use rand::Rng;\n///\n/// fn foo<R: Rng + ?Sized>(rng: &mut R) -> f32 {\n///     rng.random()\n/// }\n///\n/// # let v = foo(&mut rand::rng());\n/// ```\npub trait Rng: RngCore {\n    /// Return a random value via the [`StandardUniform`] distribution.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::Rng;\n    ///\n    /// let mut rng = rand::rng();\n    /// let x: u32 = rng.random();\n    /// println!(\"{}\", x);\n    /// println!(\"{:?}\", rng.random::<(f64, bool)>());\n    /// ```\n    ///\n    /// # Arrays and tuples\n    ///\n    /// The `rng.random()` method is able to generate arrays\n    /// and tuples (up to 12 elements), so long as all element types can be\n    /// generated.\n    ///\n    /// For arrays of integers, especially for those with small element types\n    /// (< 64 bit), it will likely be faster to instead use [`Rng::fill`],\n    /// though note that generated values will differ.\n    ///\n    /// ```\n    /// use rand::Rng;\n    ///\n    /// let mut rng = rand::rng();\n    /// let tuple: (u8, i32, char) = rng.random(); // arbitrary tuple support\n    ///\n    /// let arr1: [f32; 32] = rng.random();        // array construction\n    /// let mut arr2 = [0u8; 128];\n    /// rng.fill(&mut arr2);                    // array fill\n    /// ```\n    ///\n    /// [`StandardUniform`]: distr::StandardUniform\n    #[inline]\n    fn random<T>(&mut self) -> T\n    where\n        StandardUniform: Distribution<T>,\n    {\n        StandardUniform.sample(self)\n    }\n\n    /// Return an iterator over [`random`](Self::random) variates\n    ///\n    /// This is a just a wrapper over [`Rng::sample_iter`] using\n    /// [`distr::StandardUniform`].\n    ///\n    /// Note: this method consumes its argument. Use\n    /// `(&mut rng).random_iter()` to avoid consuming the RNG.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::{rngs::SmallRng, Rng, SeedableRng};\n    ///\n    /// let rng = SmallRng::seed_from_u64(0);\n    /// let v: Vec<i32> = rng.random_iter().take(5).collect();\n    /// assert_eq!(v.len(), 5);\n    /// ```\n    #[inline]\n    fn random_iter<T>(self) -> distr::Iter<StandardUniform, Self, T>\n    where\n        Self: Sized,\n        StandardUniform: Distribution<T>,\n    {\n        StandardUniform.sample_iter(self)\n    }\n\n    /// Generate a random value in the given range.\n    ///\n    /// This function is optimised for the case that only a single sample is\n    /// made from the given range. See also the [`Uniform`] distribution\n    /// type which may be faster if sampling from the same range repeatedly.\n    ///\n    /// All types support `low..high_exclusive` and `low..=high` range syntax.\n    /// Unsigned integer types also support `..high_exclusive` and `..=high` syntax.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the range is empty, or if `high - low` overflows for floats.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::Rng;\n    ///\n    /// let mut rng = rand::rng();\n    ///\n    /// // Exclusive range\n    /// let n: u32 = rng.random_range(..10);\n    /// println!(\"{}\", n);\n    /// let m: f64 = rng.random_range(-40.0..1.3e5);\n    /// println!(\"{}\", m);\n    ///\n    /// // Inclusive range\n    /// let n: u32 = rng.random_range(..=10);\n    /// println!(\"{}\", n);\n    /// ```\n    ///\n    /// [`Uniform`]: distr::uniform::Uniform\n    #[track_caller]\n    fn random_range<T, R>(&mut self, range: R) -> T\n    where\n        T: SampleUniform,\n        R: SampleRange<T>,\n    {\n        assert!(!range.is_empty(), \"cannot sample empty range\");\n        range.sample_single(self).unwrap()\n    }\n\n    /// Return a bool with a probability `p` of being true.\n    ///\n    /// See also the [`Bernoulli`] distribution, which may be faster if\n    /// sampling from the same probability repeatedly.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::Rng;\n    ///\n    /// let mut rng = rand::rng();\n    /// println!(\"{}\", rng.random_bool(1.0 / 3.0));\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// If `p < 0` or `p > 1`.\n    ///\n    /// [`Bernoulli`]: distr::Bernoulli\n    #[inline]\n    #[track_caller]\n    fn random_bool(&mut self, p: f64) -> bool {\n        match distr::Bernoulli::new(p) {\n            Ok(d) => self.sample(d),\n            Err(_) => panic!(\"p={:?} is outside range [0.0, 1.0]\", p),\n        }\n    }\n\n    /// Return a bool with a probability of `numerator/denominator` of being\n    /// true.\n    ///\n    /// That is, `random_ratio(2, 3)` has chance of 2 in 3, or about 67%, of\n    /// returning true. If `numerator == denominator`, then the returned value\n    /// is guaranteed to be `true`. If `numerator == 0`, then the returned\n    /// value is guaranteed to be `false`.\n    ///\n    /// See also the [`Bernoulli`] distribution, which may be faster if\n    /// sampling from the same `numerator` and `denominator` repeatedly.\n    ///\n    /// # Panics\n    ///\n    /// If `denominator == 0` or `numerator > denominator`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::Rng;\n    ///\n    /// let mut rng = rand::rng();\n    /// println!(\"{}\", rng.random_ratio(2, 3));\n    /// ```\n    ///\n    /// [`Bernoulli`]: distr::Bernoulli\n    #[inline]\n    #[track_caller]\n    fn random_ratio(&mut self, numerator: u32, denominator: u32) -> bool {\n        match distr::Bernoulli::from_ratio(numerator, denominator) {\n            Ok(d) => self.sample(d),\n            Err(_) => panic!(\n                \"p={}/{} is outside range [0.0, 1.0]\",\n                numerator, denominator\n            ),\n        }\n    }\n\n    /// Sample a new value, using the given distribution.\n    ///\n    /// ### Example\n    ///\n    /// ```\n    /// use rand::Rng;\n    /// use rand::distr::Uniform;\n    ///\n    /// let mut rng = rand::rng();\n    /// let x = rng.sample(Uniform::new(10u32, 15).unwrap());\n    /// // Type annotation requires two types, the type and distribution; the\n    /// // distribution can be inferred.\n    /// let y = rng.sample::<u16, _>(Uniform::new(10, 15).unwrap());\n    /// ```\n    fn sample<T, D: Distribution<T>>(&mut self, distr: D) -> T {\n        distr.sample(self)\n    }\n\n    /// Create an iterator that generates values using the given distribution.\n    ///\n    /// Note: this method consumes its arguments. Use\n    /// `(&mut rng).sample_iter(..)` to avoid consuming the RNG.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::Rng;\n    /// use rand::distr::{Alphanumeric, Uniform, StandardUniform};\n    ///\n    /// let mut rng = rand::rng();\n    ///\n    /// // Vec of 16 x f32:\n    /// let v: Vec<f32> = (&mut rng).sample_iter(StandardUniform).take(16).collect();\n    ///\n    /// // String:\n    /// let s: String = (&mut rng).sample_iter(Alphanumeric)\n    ///     .take(7)\n    ///     .map(char::from)\n    ///     .collect();\n    ///\n    /// // Combined values\n    /// println!(\"{:?}\", (&mut rng).sample_iter(StandardUniform).take(5)\n    ///                              .collect::<Vec<(f64, bool)>>());\n    ///\n    /// // Dice-rolling:\n    /// let die_range = Uniform::new_inclusive(1, 6).unwrap();\n    /// let mut roll_die = (&mut rng).sample_iter(die_range);\n    /// while roll_die.next().unwrap() != 6 {\n    ///     println!(\"Not a 6; rolling again!\");\n    /// }\n    /// ```\n    fn sample_iter<T, D>(self, distr: D) -> distr::Iter<D, Self, T>\n    where\n        D: Distribution<T>,\n        Self: Sized,\n    {\n        distr.sample_iter(self)\n    }\n\n    /// Fill any type implementing [`Fill`] with random data\n    ///\n    /// This method is implemented for types which may be safely reinterpreted\n    /// as an (aligned) `[u8]` slice then filled with random data. It is often\n    /// faster than using [`Rng::random`] but not value-equivalent.\n    ///\n    /// The distribution is expected to be uniform with portable results, but\n    /// this cannot be guaranteed for third-party implementations.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::Rng;\n    ///\n    /// let mut arr = [0i8; 20];\n    /// rand::rng().fill(&mut arr[..]);\n    /// ```\n    ///\n    /// [`fill_bytes`]: RngCore::fill_bytes\n    #[track_caller]\n    fn fill<T: Fill + ?Sized>(&mut self, dest: &mut T) {\n        dest.fill(self)\n    }\n\n    /// Alias for [`Rng::random`].\n    #[inline]\n    #[deprecated(\n        since = \"0.9.0\",\n        note = \"Renamed to `random` to avoid conflict with the new `gen` keyword in Rust 2024.\"\n    )]\n    fn r#gen<T>(&mut self) -> T\n    where\n        StandardUniform: Distribution<T>,\n    {\n        self.random()\n    }\n\n    /// Alias for [`Rng::random_range`].\n    #[inline]\n    #[deprecated(since = \"0.9.0\", note = \"Renamed to `random_range`\")]\n    fn gen_range<T, R>(&mut self, range: R) -> T\n    where\n        T: SampleUniform,\n        R: SampleRange<T>,\n    {\n        self.random_range(range)\n    }\n\n    /// Alias for [`Rng::random_bool`].\n    #[inline]\n    #[deprecated(since = \"0.9.0\", note = \"Renamed to `random_bool`\")]\n    fn gen_bool(&mut self, p: f64) -> bool {\n        self.random_bool(p)\n    }\n\n    /// Alias for [`Rng::random_ratio`].\n    #[inline]\n    #[deprecated(since = \"0.9.0\", note = \"Renamed to `random_ratio`\")]\n    fn gen_ratio(&mut self, numerator: u32, denominator: u32) -> bool {\n        self.random_ratio(numerator, denominator)\n    }\n}","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::fill":["/// Fill any type implementing [`Fill`] with random data\n///\n/// This method is implemented for types which may be safely reinterpreted\n/// as an (aligned) `[u8]` slice then filled with random data. It is often\n/// faster than using [`Rng::random`] but not value-equivalent.\n///\n/// The distribution is expected to be uniform with portable results, but\n/// this cannot be guaranteed for third-party implementations.\n///\n/// # Example\n///\n/// ```\n/// use rand::Rng;\n///\n/// let mut arr = [0i8; 20];\n/// rand::rng().fill(&mut arr[..]);\n/// ```\n///\n/// [`fill_bytes`]: RngCore::fill_bytes\n#[track_caller]\nfn fill<T: Fill + ?Sized>(&mut self, dest: &mut T){\n        dest.fill(self)\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::gen":["/// Alias for [`Rng::random`].\n#[inline]\n#[deprecated(\n        since = \"0.9.0\",\n        note = \"Renamed to `random` to avoid conflict with the new `gen` keyword in Rust 2024.\"\n    )]\nfn r#gen<T>(&mut self) -> T\n    where\n        StandardUniform: Distribution<T>,{\n        self.random()\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::gen_bool":["/// Alias for [`Rng::random_bool`].\n#[inline]\n#[deprecated(since = \"0.9.0\", note = \"Renamed to `random_bool`\")]\nfn gen_bool(&mut self, p: f64) -> bool{\n        self.random_bool(p)\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::gen_range":["/// Alias for [`Rng::random_range`].\n#[inline]\n#[deprecated(since = \"0.9.0\", note = \"Renamed to `random_range`\")]\nfn gen_range<T, R>(&mut self, range: R) -> T\n    where\n        T: SampleUniform,\n        R: SampleRange<T>,{\n        self.random_range(range)\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::gen_ratio":["/// Alias for [`Rng::random_ratio`].\n#[inline]\n#[deprecated(since = \"0.9.0\", note = \"Renamed to `random_ratio`\")]\nfn gen_ratio(&mut self, numerator: u32, denominator: u32) -> bool{\n        self.random_ratio(numerator, denominator)\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::random":["/// Return a random value via the [`StandardUniform`] distribution.\n///\n/// # Example\n///\n/// ```\n/// use rand::Rng;\n///\n/// let mut rng = rand::rng();\n/// let x: u32 = rng.random();\n/// println!(\"{}\", x);\n/// println!(\"{:?}\", rng.random::<(f64, bool)>());\n/// ```\n///\n/// # Arrays and tuples\n///\n/// The `rng.random()` method is able to generate arrays\n/// and tuples (up to 12 elements), so long as all element types can be\n/// generated.\n///\n/// For arrays of integers, especially for those with small element types\n/// (< 64 bit), it will likely be faster to instead use [`Rng::fill`],\n/// though note that generated values will differ.\n///\n/// ```\n/// use rand::Rng;\n///\n/// let mut rng = rand::rng();\n/// let tuple: (u8, i32, char) = rng.random(); // arbitrary tuple support\n///\n/// let arr1: [f32; 32] = rng.random();        // array construction\n/// let mut arr2 = [0u8; 128];\n/// rng.fill(&mut arr2);                    // array fill\n/// ```\n///\n/// [`StandardUniform`]: distr::StandardUniform\n#[inline]\nfn random<T>(&mut self) -> T\n    where\n        StandardUniform: Distribution<T>,{\n        StandardUniform.sample(self)\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::random_bool":["/// Return a bool with a probability `p` of being true.\n///\n/// See also the [`Bernoulli`] distribution, which may be faster if\n/// sampling from the same probability repeatedly.\n///\n/// # Example\n///\n/// ```\n/// use rand::Rng;\n///\n/// let mut rng = rand::rng();\n/// println!(\"{}\", rng.random_bool(1.0 / 3.0));\n/// ```\n///\n/// # Panics\n///\n/// If `p < 0` or `p > 1`.\n///\n/// [`Bernoulli`]: distr::Bernoulli\n#[inline]\n#[track_caller]\nfn random_bool(&mut self, p: f64) -> bool{\n        match distr::Bernoulli::new(p) {\n            Ok(d) => self.sample(d),\n            Err(_) => panic!(\"p={:?} is outside range [0.0, 1.0]\", p),\n        }\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::random_iter":["/// Return an iterator over [`random`](Self::random) variates\n///\n/// This is a just a wrapper over [`Rng::sample_iter`] using\n/// [`distr::StandardUniform`].\n///\n/// Note: this method consumes its argument. Use\n/// `(&mut rng).random_iter()` to avoid consuming the RNG.\n///\n/// # Example\n///\n/// ```\n/// use rand::{rngs::SmallRng, Rng, SeedableRng};\n///\n/// let rng = SmallRng::seed_from_u64(0);\n/// let v: Vec<i32> = rng.random_iter().take(5).collect();\n/// assert_eq!(v.len(), 5);\n/// ```\n#[inline]\nfn random_iter<T>(self) -> distr::Iter<StandardUniform, Self, T>\n    where\n        Self: Sized,\n        StandardUniform: Distribution<T>,{\n        StandardUniform.sample_iter(self)\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::random_range":["/// Generate a random value in the given range.\n///\n/// This function is optimised for the case that only a single sample is\n/// made from the given range. See also the [`Uniform`] distribution\n/// type which may be faster if sampling from the same range repeatedly.\n///\n/// All types support `low..high_exclusive` and `low..=high` range syntax.\n/// Unsigned integer types also support `..high_exclusive` and `..=high` syntax.\n///\n/// # Panics\n///\n/// Panics if the range is empty, or if `high - low` overflows for floats.\n///\n/// # Example\n///\n/// ```\n/// use rand::Rng;\n///\n/// let mut rng = rand::rng();\n///\n/// // Exclusive range\n/// let n: u32 = rng.random_range(..10);\n/// println!(\"{}\", n);\n/// let m: f64 = rng.random_range(-40.0..1.3e5);\n/// println!(\"{}\", m);\n///\n/// // Inclusive range\n/// let n: u32 = rng.random_range(..=10);\n/// println!(\"{}\", n);\n/// ```\n///\n/// [`Uniform`]: distr::uniform::Uniform\n#[track_caller]\nfn random_range<T, R>(&mut self, range: R) -> T\n    where\n        T: SampleUniform,\n        R: SampleRange<T>,{\n        assert!(!range.is_empty(), \"cannot sample empty range\");\n        range.sample_single(self).unwrap()\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::random_ratio":["/// Return a bool with a probability of `numerator/denominator` of being\n/// true.\n///\n/// That is, `random_ratio(2, 3)` has chance of 2 in 3, or about 67%, of\n/// returning true. If `numerator == denominator`, then the returned value\n/// is guaranteed to be `true`. If `numerator == 0`, then the returned\n/// value is guaranteed to be `false`.\n///\n/// See also the [`Bernoulli`] distribution, which may be faster if\n/// sampling from the same `numerator` and `denominator` repeatedly.\n///\n/// # Panics\n///\n/// If `denominator == 0` or `numerator > denominator`.\n///\n/// # Example\n///\n/// ```\n/// use rand::Rng;\n///\n/// let mut rng = rand::rng();\n/// println!(\"{}\", rng.random_ratio(2, 3));\n/// ```\n///\n/// [`Bernoulli`]: distr::Bernoulli\n#[inline]\n#[track_caller]\nfn random_ratio(&mut self, numerator: u32, denominator: u32) -> bool{\n        match distr::Bernoulli::from_ratio(numerator, denominator) {\n            Ok(d) => self.sample(d),\n            Err(_) => panic!(\n                \"p={}/{} is outside range [0.0, 1.0]\",\n                numerator, denominator\n            ),\n        }\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::sample":["/// Sample a new value, using the given distribution.\n///\n/// ### Example\n///\n/// ```\n/// use rand::Rng;\n/// use rand::distr::Uniform;\n///\n/// let mut rng = rand::rng();\n/// let x = rng.sample(Uniform::new(10u32, 15).unwrap());\n/// // Type annotation requires two types, the type and distribution; the\n/// // distribution can be inferred.\n/// let y = rng.sample::<u16, _>(Uniform::new(10, 15).unwrap());\n/// ```\nfn sample<T, D: Distribution<T>>(&mut self, distr: D) -> T{\n        distr.sample(self)\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::Rng::sample_iter":["/// Create an iterator that generates values using the given distribution.\n///\n/// Note: this method consumes its arguments. Use\n/// `(&mut rng).sample_iter(..)` to avoid consuming the RNG.\n///\n/// # Example\n///\n/// ```\n/// use rand::Rng;\n/// use rand::distr::{Alphanumeric, Uniform, StandardUniform};\n///\n/// let mut rng = rand::rng();\n///\n/// // Vec of 16 x f32:\n/// let v: Vec<f32> = (&mut rng).sample_iter(StandardUniform).take(16).collect();\n///\n/// // String:\n/// let s: String = (&mut rng).sample_iter(Alphanumeric)\n///     .take(7)\n///     .map(char::from)\n///     .collect();\n///\n/// // Combined values\n/// println!(\"{:?}\", (&mut rng).sample_iter(StandardUniform).take(5)\n///                              .collect::<Vec<(f64, bool)>>());\n///\n/// // Dice-rolling:\n/// let die_range = Uniform::new_inclusive(1, 6).unwrap();\n/// let mut roll_die = (&mut rng).sample_iter(die_range);\n/// while roll_die.next().unwrap() != 6 {\n///     println!(\"Not a 6; rolling again!\");\n/// }\n/// ```\nfn sample_iter<T, D>(self, distr: D) -> distr::Iter<D, Self, T>\n    where\n        D: Distribution<T>,\n        Self: Sized,{\n        distr.sample_iter(self)\n    }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i128>]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = self.len() * mem::size_of::<$t>();\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = Wrapping(x.0.to_le());\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i16>]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = self.len() * mem::size_of::<$t>();\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = Wrapping(x.0.to_le());\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i32>]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = self.len() * mem::size_of::<$t>();\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = Wrapping(x.0.to_le());\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i64>]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = self.len() * mem::size_of::<$t>();\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = Wrapping(x.0.to_le());\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i8>]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = self.len() * mem::size_of::<$t>();\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = Wrapping(x.0.to_le());\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u128>]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = self.len() * mem::size_of::<$t>();\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = Wrapping(x.0.to_le());\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u16>]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = self.len() * mem::size_of::<$t>();\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = Wrapping(x.0.to_le());\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u32>]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = self.len() * mem::size_of::<$t>();\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = Wrapping(x.0.to_le());\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u64>]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = self.len() * mem::size_of::<$t>();\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = Wrapping(x.0.to_le());\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [i128]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = mem::size_of_val(self);\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = x.to_le();\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [i16]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = mem::size_of_val(self);\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = x.to_le();\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [i32]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = mem::size_of_val(self);\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = x.to_le();\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [i64]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = mem::size_of_val(self);\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = x.to_le();\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [i8]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = mem::size_of_val(self);\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = x.to_le();\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [u128]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = mem::size_of_val(self);\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = x.to_le();\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [u16]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = mem::size_of_val(self);\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = x.to_le();\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [u32]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = mem::size_of_val(self);\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = x.to_le();\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::_::<impl rng::Fill for [u64]>::fill":["fn fill<R: Rng + ?Sized>(&mut self, rng: &mut R){\n                if self.len() > 0 {\n                    let size = mem::size_of_val(self);\n                    rng.fill_bytes(\n                        // SAFETY: `self` non-null and valid for reads and writes within its `size`\n                        // bytes. `self` meets the alignment requirements of `&mut [u8]`.\n                        // The contents of `self` are initialized. Both `[u8]` and `[$t]` are valid\n                        // for all bit-patterns of their contents (note that the SAFETY requirement\n                        // on callers of this macro). `self` is not borrowed.\n                        unsafe {\n                            slice::from_raw_parts_mut(self.as_mut_ptr()\n                                as *mut u8,\n                                size\n                            )\n                        }\n                    );\n                    for x in self {\n                        *x = x.to_le();\n                    }\n                }\n            }","Real(LocalPath(\"src/rng.rs\"))"],"rng::__unsafe":["/// Call target for unsafe macros\nconst unsafe fn __unsafe(){}","Real(LocalPath(\"src/rng.rs\"))"],"rngs::mock::StepRng":["/// A mock generator yielding very predictable output\n///\n/// This generates an arithmetic sequence (i.e. adds a constant each step)\n/// over a `u64` number, using wrapping arithmetic. If the increment is 0\n/// the generator yields a constant.\n///\n/// Other integer types (64-bit and smaller) are produced via cast from `u64`.\n///\n/// Other types are produced via their implementation of [`Rng`](crate::Rng) or\n/// [`Distribution`](crate::distr::Distribution).\n/// Output values may not be intuitive and may change in future releases but\n/// are considered\n/// [portable](https://rust-random.github.io/book/portability.html).\n/// (`bool` output is true when bit `1u64 << 31` is set.)\n///\n/// # Example\n///\n/// ```\n/// # #![allow(deprecated)]\n/// use rand::Rng;\n/// use rand::rngs::mock::StepRng;\n///\n/// let mut my_rng = StepRng::new(2, 1);\n/// let sample: [u64; 3] = my_rng.random();\n/// assert_eq!(sample, [2, 3, 4]);\n/// ```\n#[deprecated(since = \"0.9.2\", note = \"Deprecated without replacement\")]\npub struct StepRng {\n    v: u64,\n    a: u64,\n}","Real(LocalPath(\"src/rngs/mock.rs\"))"],"rngs::mock::StepRng::new":["/// Create a `StepRng`, yielding an arithmetic sequence starting with\n/// `initial` and incremented by `increment` each time.\npub fn new(initial: u64, increment: u64) -> Self{\n        StepRng {\n            v: initial,\n            a: increment,\n        }\n    }","Real(LocalPath(\"src/rngs/mock.rs\"))"],"rngs::reseeding::ReseedingCore":["struct ReseedingCore<R, Rsdr> {\n    inner: R,\n    reseeder: Rsdr,\n    threshold: i64,\n    bytes_until_reseed: i64,\n}","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"rngs::reseeding::ReseedingCore::<R, Rsdr>::new":["/// Create a new `ReseedingCore`.\n///\n/// `threshold` is the maximum number of bytes produced by\n/// [`BlockRngCore::generate`] before attempting reseeding.\nfn new(threshold: u64, mut reseeder: Rsdr) -> Result<Self, Rsdr::Error>{\n        // Because generating more values than `i64::MAX` takes centuries on\n        // current hardware, we just clamp to that value.\n        // Also we set a threshold of 0, which indicates no limit, to that\n        // value.\n        let threshold = if threshold == 0 {\n            i64::MAX\n        } else if threshold <= i64::MAX as u64 {\n            threshold as i64\n        } else {\n            i64::MAX\n        };\n\n        let inner = R::try_from_rng(&mut reseeder)?;\n\n        Ok(ReseedingCore {\n            inner,\n            reseeder,\n            threshold,\n            bytes_until_reseed: threshold,\n        })\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"rngs::reseeding::ReseedingCore::<R, Rsdr>::reseed":["/// Reseed the internal PRNG.\nfn reseed(&mut self) -> Result<(), Rsdr::Error>{\n        R::try_from_rng(&mut self.reseeder).map(|result| {\n            self.bytes_until_reseed = self.threshold;\n            self.inner = result\n        })\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"rngs::reseeding::ReseedingCore::<R, Rsdr>::reseed_and_generate":["#[inline(never)]\nfn reseed_and_generate(&mut self, results: &mut <Self as BlockRngCore>::Results){\n        trace!(\"Reseeding RNG (periodic reseed)\");\n\n        let num_bytes = size_of_val(results.as_ref());\n\n        if let Err(e) = self.reseed() {\n            warn!(\"Reseeding RNG failed: {}\", e);\n            let _ = e;\n        }\n\n        self.bytes_until_reseed = self.threshold - num_bytes as i64;\n        self.inner.generate(results);\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"rngs::reseeding::ReseedingRng":["/// A wrapper around any PRNG that implements [`BlockRngCore`], that adds the\n/// ability to reseed it.\n///\n/// `ReseedingRng` reseeds the underlying PRNG in the following cases:\n///\n/// - On a manual call to [`reseed()`].\n/// - After `clone()`, the clone will be reseeded on first use.\n/// - After the PRNG has generated a configurable number of random bytes.\n///\n/// # When should reseeding after a fixed number of generated bytes be used?\n///\n/// Reseeding after a fixed number of generated bytes is never strictly\n/// *necessary*. Cryptographic PRNGs don't have a limited number of bytes they\n/// can output, or at least not a limit reachable in any practical way. There is\n/// no such thing as 'running out of entropy'.\n///\n/// Occasionally reseeding can be seen as some form of 'security in depth'. Even\n/// if in the future a cryptographic weakness is found in the CSPRNG being used,\n/// or a flaw in the implementation, occasionally reseeding should make\n/// exploiting it much more difficult or even impossible.\n///\n/// Use [`ReseedingRng::new`] with a `threshold` of `0` to disable reseeding\n/// after a fixed number of generated bytes.\n///\n/// # Error handling\n///\n/// Although unlikely, reseeding the wrapped PRNG can fail. `ReseedingRng` will\n/// never panic but try to handle the error intelligently through some\n/// combination of retrying and delaying reseeding until later.\n/// If handling the source error fails `ReseedingRng` will continue generating\n/// data from the wrapped PRNG without reseeding.\n///\n/// Manually calling [`reseed()`] will not have this retry or delay logic, but\n/// reports the error.\n///\n/// # Example\n///\n/// ```\n/// use rand::prelude::*;\n/// use rand_chacha::ChaCha20Core; // Internal part of ChaChaRng that\n///                              // implements BlockRngCore\n/// use rand::rngs::OsRng;\n/// use rand::rngs::ReseedingRng;\n///\n/// let mut reseeding_rng = ReseedingRng::<ChaCha20Core, _>::new(0, OsRng).unwrap();\n///\n/// println!(\"{}\", reseeding_rng.random::<u64>());\n///\n/// let mut cloned_rng = reseeding_rng.clone();\n/// assert!(reseeding_rng.random::<u64>() != cloned_rng.random::<u64>());\n/// ```\n///\n/// [`BlockRngCore`]: rand_core::block::BlockRngCore\n/// [`ReseedingRng::new`]: ReseedingRng::new\n/// [`reseed()`]: ReseedingRng::reseed\npub struct ReseedingRng<R, Rsdr>(BlockRng<ReseedingCore<R, Rsdr>>)\nwhere\n    R: BlockRngCore + SeedableRng,\n    Rsdr: TryRngCore;","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"rngs::reseeding::ReseedingRng::<R, Rsdr>::new":["/// Create a new `ReseedingRng` from an existing PRNG, combined with a RNG\n/// to use as reseeder.\n///\n/// `threshold` sets the number of generated bytes after which to reseed the\n/// PRNG. Set it to zero to never reseed based on the number of generated\n/// values.\npub fn new(threshold: u64, reseeder: Rsdr) -> Result<Self, Rsdr::Error>{\n        Ok(ReseedingRng(BlockRng::new(ReseedingCore::new(\n            threshold, reseeder,\n        )?)))\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"rngs::reseeding::ReseedingRng::<R, Rsdr>::reseed":["/// Immediately reseed the generator\n///\n/// This discards any remaining random data in the cache.\npub fn reseed(&mut self) -> Result<(), Rsdr::Error>{\n        self.0.reset();\n        self.0.core.reseed()\n    }","Real(LocalPath(\"src/rngs/reseeding.rs\"))"],"rngs::small::SmallRng":["/// A small-state, fast, non-crypto, non-portable PRNG\n///\n/// This is the \"standard small\" RNG, a generator with the following properties:\n///\n/// - Non-[portable]: any future library version may replace the algorithm\n///   and results may be platform-dependent.\n///   (For a small portable generator, use the [rand_pcg] or [rand_xoshiro] crate.)\n/// - Non-cryptographic: output is easy to predict (insecure)\n/// - [Quality]: statistically good quality\n/// - Fast: the RNG is fast for both bulk generation and single values, with\n///   consistent cost of method calls\n/// - Fast initialization\n/// - Small state: little memory usage (current state size is 16-32 bytes\n///   depending on platform)\n///\n/// The current algorithm is\n/// `Xoshiro256PlusPlus` on 64-bit platforms and `Xoshiro128PlusPlus` on 32-bit\n/// platforms. Both are also implemented by the [rand_xoshiro] crate.\n///\n/// ## Seeding (construction)\n///\n/// This generator implements the [`SeedableRng`] trait. All methods are\n/// suitable for seeding, but note that, even with a fixed seed, output is not\n/// [portable]. Some suggestions:\n///\n/// 1.  To automatically seed with a unique seed, use [`SeedableRng::from_rng`]:\n///     ```\n///     use rand::SeedableRng;\n///     use rand::rngs::SmallRng;\n///     let rng = SmallRng::from_rng(&mut rand::rng());\n///     # let _: SmallRng = rng;\n///     ```\n///     or [`SeedableRng::from_os_rng`]:\n///     ```\n///     # use rand::SeedableRng;\n///     # use rand::rngs::SmallRng;\n///     let rng = SmallRng::from_os_rng();\n///     # let _: SmallRng = rng;\n///     ```\n/// 2.  To use a deterministic integral seed, use `seed_from_u64`. This uses a\n///     hash function internally to yield a (typically) good seed from any\n///     input.\n///     ```\n///     # use rand::{SeedableRng, rngs::SmallRng};\n///     let rng = SmallRng::seed_from_u64(1);\n///     # let _: SmallRng = rng;\n///     ```\n/// 3.  To seed deterministically from text or other input, use [`rand_seeder`].\n///\n/// See also [Seeding RNGs] in the book.\n///\n/// ## Generation\n///\n/// The generators implements [`RngCore`] and thus also [`Rng`][crate::Rng].\n/// See also the [Random Values] chapter in the book.\n///\n/// [portable]: https://rust-random.github.io/book/crate-reprod.html\n/// [Seeding RNGs]: https://rust-random.github.io/book/guide-seeding.html\n/// [Random Values]: https://rust-random.github.io/book/guide-values.html\n/// [Quality]: https://rust-random.github.io/book/guide-rngs.html#quality\n/// [`StdRng`]: crate::rngs::StdRng\n/// [rand_pcg]: https://crates.io/crates/rand_pcg\n/// [rand_xoshiro]: https://crates.io/crates/rand_xoshiro\n/// [`rand_chacha::ChaCha8Rng`]: https://docs.rs/rand_chacha/latest/rand_chacha/struct.ChaCha8Rng.html\n/// [`rand_seeder`]: https://docs.rs/rand_seeder/latest/rand_seeder/\npub struct SmallRng(Rng);","Real(LocalPath(\"src/rngs/small.rs\"))"],"rngs::std::StdRng":["/// A strong, fast (amortized), non-portable RNG\n///\n/// This is the \"standard\" RNG, a generator with the following properties:\n///\n/// - Non-[portable]: any future library version may replace the algorithm\n///   and results may be platform-dependent.\n///   (For a portable version, use the [rand_chacha] crate directly.)\n/// - [CSPRNG]: statistically good quality of randomness and [unpredictable]\n/// - Fast ([amortized](https://en.wikipedia.org/wiki/Amortized_analysis)):\n///   the RNG is fast for bulk generation, but the cost of method calls is not\n///   consistent due to usage of an output buffer.\n///\n/// The current algorithm used is the ChaCha block cipher with 12 rounds. Please\n/// see this relevant [rand issue] for the discussion. This may change as new\n/// evidence of cipher security and performance becomes available.\n///\n/// ## Seeding (construction)\n///\n/// This generator implements the [`SeedableRng`] trait. Any method may be used,\n/// but note that `seed_from_u64` is not suitable for usage where security is\n/// important. Also note that, even with a fixed seed, output is not [portable].\n///\n/// Using a fresh seed **direct from the OS** is the most secure option:\n/// ```\n/// # use rand::{SeedableRng, rngs::StdRng};\n/// let rng = StdRng::from_os_rng();\n/// # let _: StdRng = rng;\n/// ```\n///\n/// Seeding via [`rand::rng()`](crate::rng()) may be faster:\n/// ```\n/// # use rand::{SeedableRng, rngs::StdRng};\n/// let rng = StdRng::from_rng(&mut rand::rng());\n/// # let _: StdRng = rng;\n/// ```\n///\n/// Any [`SeedableRng`] method may be used, but note that `seed_from_u64` is not\n/// suitable where security is required. See also [Seeding RNGs] in the book.\n///\n/// ## Generation\n///\n/// The generators implements [`RngCore`] and thus also [`Rng`][crate::Rng].\n/// See also the [Random Values] chapter in the book.\n///\n/// [portable]: https://rust-random.github.io/book/crate-reprod.html\n/// [Seeding RNGs]: https://rust-random.github.io/book/guide-seeding.html\n/// [unpredictable]: https://rust-random.github.io/book/guide-rngs.html#security\n/// [Random Values]: https://rust-random.github.io/book/guide-values.html\n/// [CSPRNG]: https://rust-random.github.io/book/guide-gen.html#cryptographically-secure-pseudo-random-number-generator\n/// [rand_chacha]: https://crates.io/crates/rand_chacha\n/// [rand issue]: https://github.com/rust-random/rand/issues/932\npub struct StdRng(Rng);","Real(LocalPath(\"src/rngs/std.rs\"))"],"rngs::thread::THREAD_RNG_KEY::__init":["#[inline]\nfn __init() -> $t{\n            $init\n        }","Real(Remapped { local_path: Some(\"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/native/mod.rs\"), virtual_name: \"/rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/sys/thread_local/native/mod.rs\" })"],"rngs::thread::ThreadRng":["/// A reference to the thread-local generator\n///\n/// This type is a reference to a lazily-initialized thread-local generator.\n/// An instance can be obtained via [`rand::rng()`][crate::rng()] or via\n/// [`ThreadRng::default()`].\n/// The handle cannot be passed between threads (is not `Send` or `Sync`).\n///\n/// # Security\n///\n/// Security must be considered relative to a threat model and validation\n/// requirements. The Rand project can provide no guarantee of fitness for\n/// purpose. The design criteria for `ThreadRng` are as follows:\n///\n/// - Automatic seeding via [`OsRng`] and periodically thereafter (see\n///   ([`ReseedingRng`] documentation). Limitation: there is no automatic\n///   reseeding on process fork (see [below](#fork)).\n/// - A rigorusly analyzed, unpredictable (cryptographic) pseudo-random generator\n///   (see [the book on security](https://rust-random.github.io/book/guide-rngs.html#security)).\n///   The currently selected algorithm is ChaCha (12-rounds).\n///   See also [`StdRng`] documentation.\n/// - Not to leak internal state through [`Debug`] or serialization\n///   implementations.\n/// - No further protections exist to in-memory state. In particular, the\n///   implementation is not required to zero memory on exit (of the process or\n///   thread). (This may change in the future.)\n/// - Be fast enough for general-purpose usage. Note in particular that\n///   `ThreadRng` is designed to be a \"fast, reasonably secure generator\"\n///   (where \"reasonably secure\" implies the above criteria).\n///\n/// We leave it to the user to determine whether this generator meets their\n/// security requirements. For an alternative, see [`OsRng`].\n///\n/// # Fork\n///\n/// `ThreadRng` is not automatically reseeded on fork. It is recommended to\n/// explicitly call [`ThreadRng::reseed`] immediately after a fork, for example:\n/// ```ignore\n/// fn do_fork() {\n///     let pid = unsafe { libc::fork() };\n///     if pid == 0 {\n///         // Reseed ThreadRng in child processes:\n///         rand::rng().reseed();\n///     }\n/// }\n/// ```\n///\n/// Methods on `ThreadRng` are not reentrant-safe and thus should not be called\n/// from an interrupt (e.g. a fork handler) unless it can be guaranteed that no\n/// other method on the same `ThreadRng` is currently executing.\n///\n/// [`ReseedingRng`]: crate::rngs::ReseedingRng\n/// [`StdRng`]: crate::rngs::StdRng\npub struct ThreadRng {\n    // Rc is explicitly !Send and !Sync\n    rng: Rc<UnsafeCell<ReseedingRng<Core, OsRng>>>,\n}","Real(LocalPath(\"src/rngs/thread.rs\"))"],"rngs::thread::ThreadRng::reseed":["/// Immediately reseed the generator\n///\n/// This discards any remaining random data in the cache.\npub fn reseed(&mut self) -> Result<(), rand_core::OsError>{\n        // SAFETY: We must make sure to stop using `rng` before anyone else\n        // creates another mutable reference\n        let rng = unsafe { &mut *self.rng.get() };\n        rng.reseed()\n    }","Real(LocalPath(\"src/rngs/thread.rs\"))"],"rngs::thread::rng":["/// Access a fast, pre-initialized generator\n///\n/// This is a handle to the local [`ThreadRng`].\n///\n/// See also [`crate::rngs`] for alternatives.\n///\n/// # Example\n///\n/// ```\n/// use rand::prelude::*;\n///\n/// # fn main() {\n///\n/// let mut numbers = [1, 2, 3, 4, 5];\n/// numbers.shuffle(&mut rand::rng());\n/// println!(\"Numbers: {numbers:?}\");\n///\n/// // Using a local binding avoids an initialization-check on each usage:\n/// let mut rng = rand::rng();\n///\n/// println!(\"True or false: {}\", rng.random::<bool>());\n/// println!(\"A simulated die roll: {}\", rng.random_range(1..=6));\n/// # }\n/// ```\n///\n/// # Security\n///\n/// Refer to [`ThreadRng#Security`].\npub fn rng() -> ThreadRng{\n    let rng = THREAD_RNG_KEY.with(|t| t.clone());\n    ThreadRng { rng }\n}","Real(LocalPath(\"src/rngs/thread.rs\"))"],"rngs::xoshiro256plusplus::Xoshiro256PlusPlus":["/// A xoshiro256++ random number generator.\n///\n/// The xoshiro256++ algorithm is not suitable for cryptographic purposes, but\n/// is very fast and has excellent statistical properties.\n///\n/// The algorithm used here is translated from [the `xoshiro256plusplus.c`\n/// reference source code](http://xoshiro.di.unimi.it/xoshiro256plusplus.c) by\n/// David Blackman and Sebastiano Vigna.\npub struct Xoshiro256PlusPlus {\n    s: [u64; 4],\n}","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))"],"seq::coin_flipper::CoinFlipper":["pub(crate) struct CoinFlipper<R: RngCore> {\n    pub rng: R,\n    chunk: u32, // TODO(opt): this should depend on RNG word size\n    chunk_remaining: u32,\n}","Real(LocalPath(\"src/seq/coin_flipper.rs\"))"],"seq::coin_flipper::CoinFlipper::<R>::flip_c_heads":["/// If the next `c` bits of randomness all represent heads, consume them, return true\n/// Otherwise return false and consume the number of heads plus one.\n/// Generates new bits of randomness when necessary (in 32 bit chunks)\n/// Has a 1 in 2 to the `c` chance of returning true\n/// `c` must be less than or equal to 32\nfn flip_c_heads(&mut self, mut c: u32) -> bool{\n        debug_assert!(c <= 32);\n        // Note that zeros on the left of the chunk represent heads.\n        // It needs to be this way round because zeros are filled in when left shifting\n        loop {\n            let zeros = self.chunk.leading_zeros();\n\n            if zeros < c {\n                // The happy path - we found a 1 and can return false\n                // Note that because a 1 bit was detected,\n                // We cannot have run out of random bits so we don't need to check\n\n                // First consume all of the bits read\n                // Using shl seems to give worse performance for size-hinted iterators\n                self.chunk = self.chunk.wrapping_shl(zeros + 1);\n\n                self.chunk_remaining = self.chunk_remaining.saturating_sub(zeros + 1);\n                return false;\n            } else {\n                // The number of zeros is larger than `c`\n                // There are two possibilities\n                if let Some(new_remaining) = self.chunk_remaining.checked_sub(c) {\n                    // Those zeroes were all part of our random chunk,\n                    // throw away `c` bits of randomness and return true\n                    self.chunk_remaining = new_remaining;\n                    self.chunk <<= c;\n                    return true;\n                } else {\n                    // Some of those zeroes were part of the random chunk\n                    // and some were part of the space behind it\n                    // We need to take into account only the zeroes that were random\n                    c -= self.chunk_remaining;\n\n                    // Generate a new chunk\n                    self.chunk = self.rng.next_u32();\n                    self.chunk_remaining = 32;\n                    // Go back to start of loop\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/seq/coin_flipper.rs\"))"],"seq::coin_flipper::CoinFlipper::<R>::new":["pub fn new(rng: R) -> Self{\n        Self {\n            rng,\n            chunk: 0,\n            chunk_remaining: 0,\n        }\n    }","Real(LocalPath(\"src/seq/coin_flipper.rs\"))"],"seq::coin_flipper::CoinFlipper::<R>::random_ratio":["#[inline]\n/// Returns true with a probability of n / d\n/// Uses an expected two bits of randomness\nfn random_ratio(&mut self, mut n: usize, d: usize) -> bool{\n        // Explanation:\n        // We are trying to return true with a probability of n / d\n        // If n >= d, we can just return true\n        // Otherwise there are two possibilities 2n < d and 2n >= d\n        // In either case we flip a coin.\n        // If 2n < d\n        //  If it comes up tails, return false\n        //  If it comes up heads, double n and start again\n        //  This is fair because (0.5 * 0) + (0.5 * 2n / d) = n / d and 2n is less than d\n        // (if 2n was greater than d we would effectively round it down to 1\n        // by returning true)\n        // If 2n >= d\n        //  If it comes up tails, set n to 2n - d and start again\n        //  If it comes up heads, return true\n        //  This is fair because (0.5 * 1) + (0.5 * (2n - d) / d) = n / d\n        //  Note that if 2n = d and the coin comes up tails, n will be set to 0\n        //  before restarting which is equivalent to returning false.\n\n        // As a performance optimization we can flip multiple coins at once\n        // This is efficient because we can use the `lzcnt` intrinsic\n        // We can check up to 32 flips at once but we only receive one bit of information\n        // - all heads or at least one tail.\n\n        // Let c be the number of coins to flip. 1 <= c <= 32\n        // If 2n < d, n * 2^c < d\n        // If the result is all heads, then set n to n * 2^c\n        // If there was at least one tail, return false\n        // If 2n >= d, the order of results matters so we flip one coin at a time so c = 1\n        // Ideally, c will be as high as possible within these constraints\n\n        while n < d {\n            // Find a good value for c by counting leading zeros\n            // This will either give the highest possible c, or 1 less than that\n            let c = n\n                .leading_zeros()\n                .saturating_sub(d.leading_zeros() + 1)\n                .clamp(1, 32);\n\n            if self.flip_c_heads(c) {\n                // All heads\n                // Set n to n * 2^c\n                // If 2n >= d, the while loop will exit and we will return `true`\n                // If n * 2^c > `usize::MAX` we always return `true` anyway\n                n = n.saturating_mul(2_usize.pow(c));\n            } else {\n                // At least one tail\n                if c == 1 {\n                    // Calculate 2n - d.\n                    // We need to use wrapping as 2n might be greater than `usize::MAX`\n                    let next_n = n.wrapping_add(n).wrapping_sub(d);\n                    if next_n == 0 || next_n > n {\n                        // This will happen if 2n < d\n                        return false;\n                    }\n                    n = next_n;\n                } else {\n                    // c > 1 so 2n < d so we can return false\n                    return false;\n                }\n            }\n        }\n        true\n    }","Real(LocalPath(\"src/seq/coin_flipper.rs\"))"],"seq::coin_flipper::CoinFlipper::<R>::random_ratio_one_over":["#[inline]\n/// Returns true with a probability of 1 / d\n/// Uses an expected two bits of randomness\n/// Panics if d == 0\npub fn random_ratio_one_over(&mut self, d: usize) -> bool{\n        debug_assert_ne!(d, 0);\n        // This uses the same logic as `random_ratio` but is optimized for the case that\n        // the starting numerator is one (which it always is for `Sequence::Choose()`)\n\n        // In this case (but not `random_ratio`), this way of calculating c is always accurate\n        let c = (usize::BITS - 1 - d.leading_zeros()).min(32);\n\n        if self.flip_c_heads(c) {\n            let numerator = 1 << c;\n            self.random_ratio(numerator, d)\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"src/seq/coin_flipper.rs\"))"],"seq::increasing_uniform::IncreasingUniform":["/// Similar to a Uniform distribution,\n/// but after returning a number in the range [0,n], n is increased by 1.\npub(crate) struct IncreasingUniform<R: RngCore> {\n    pub rng: R,\n    n: u32,\n    // Chunk is a random number in [0, (n + 1) * (n + 2) *..* (n + chunk_remaining) )\n    chunk: u32,\n    chunk_remaining: u8,\n}","Real(LocalPath(\"src/seq/increasing_uniform.rs\"))"],"seq::increasing_uniform::IncreasingUniform::<R>::new":["/// Create a dice roller.\n/// The next item returned will be a random number in the range [0,n]\npub fn new(rng: R, n: u32) -> Self{\n        // If n = 0, the first number returned will always be 0\n        // so we don't need to generate a random number\n        let chunk_remaining = if n == 0 { 1 } else { 0 };\n        Self {\n            rng,\n            n,\n            chunk: 0,\n            chunk_remaining,\n        }\n    }","Real(LocalPath(\"src/seq/increasing_uniform.rs\"))"],"seq::increasing_uniform::IncreasingUniform::<R>::next_index":["/// Returns a number in [0,n] and increments n by 1.\n/// Generates new random bits as needed\n/// Panics if `n >= u32::MAX`\n#[inline]\npub fn next_index(&mut self) -> usize{\n        let next_n = self.n + 1;\n\n        // There's room for further optimisation here:\n        // random_range uses rejection sampling (or other method; see #1196) to avoid bias.\n        // When the initial sample is biased for range 0..bound\n        // it may still be viable to use for a smaller bound\n        // (especially if small biases are considered acceptable).\n\n        let next_chunk_remaining = self.chunk_remaining.checked_sub(1).unwrap_or_else(|| {\n            // If the chunk is empty, generate a new chunk\n            let (bound, remaining) = calculate_bound_u32(next_n);\n            // bound = (n + 1) * (n + 2) *..* (n + remaining)\n            self.chunk = self.rng.random_range(..bound);\n            // Chunk is a random number in\n            // [0, (n + 1) * (n + 2) *..* (n + remaining) )\n\n            remaining - 1\n        });\n\n        let result = if next_chunk_remaining == 0 {\n            // `chunk` is a random number in the range [0..n+1)\n            // Because `chunk_remaining` is about to be set to zero\n            // we do not need to clear the chunk here\n            self.chunk as usize\n        } else {\n            // `chunk` is a random number in a range that is a multiple of n+1\n            // so r will be a random number in [0..n+1)\n            let r = self.chunk % next_n;\n            self.chunk /= next_n;\n            r as usize\n        };\n\n        self.chunk_remaining = next_chunk_remaining;\n        self.n = next_n;\n        result\n    }","Real(LocalPath(\"src/seq/increasing_uniform.rs\"))"],"seq::increasing_uniform::calculate_bound_u32":["#[inline]\n/// Calculates `bound`, `count` such that bound (m)*(m+1)*..*(m + remaining - 1)\nfn calculate_bound_u32(m: u32) -> (u32, u8){\n    debug_assert!(m > 0);\n    #[inline]\n    const fn inner(m: u32) -> (u32, u8) {\n        let mut product = m;\n        let mut current = m + 1;\n\n        loop {\n            if let Some(p) = u32::checked_mul(product, current) {\n                product = p;\n                current += 1;\n            } else {\n                // Count has a maximum value of 13 for when min is 1 or 2\n                let count = (current - m) as u8;\n                return (product, count);\n            }\n        }\n    }\n\n    const RESULT2: (u32, u8) = inner(2);\n    if m == 2 {\n        // Making this value a constant instead of recalculating it\n        // gives a significant (~50%) performance boost for small shuffles\n        return RESULT2;\n    }\n\n    inner(m)\n}","Real(LocalPath(\"src/seq/increasing_uniform.rs\"))"],"seq::increasing_uniform::calculate_bound_u32::inner":["#[inline]\nconst fn inner(m: u32) -> (u32, u8){\n        let mut product = m;\n        let mut current = m + 1;\n\n        loop {\n            if let Some(p) = u32::checked_mul(product, current) {\n                product = p;\n                current += 1;\n            } else {\n                // Count has a maximum value of 13 for when min is 1 or 2\n                let count = (current - m) as u8;\n                return (product, count);\n            }\n        }\n    }","Real(LocalPath(\"src/seq/increasing_uniform.rs\"))"],"seq::index::sample_array":["/// Randomly sample exactly `N` distinct indices from `0..len`, and\n/// return them in random order (fully shuffled).\n///\n/// This is implemented via Floyd's algorithm. Time complexity is `O(N^2)`\n/// and memory complexity is `O(N)`.\n///\n/// Returns `None` if (and only if) `N > len`.\npub fn sample_array<R, const N: usize>(rng: &mut R, len: usize) -> Option<[usize; N]>\n    where\n        R: Rng + ?Sized,{\n        if N > len {\n            return None;\n        }\n\n        // Floyd's algorithm\n        let mut indices = [0; N];\n        for (i, j) in (len - N..len).enumerate() {\n            let t = rng.random_range(..j + 1);\n            if let Some(pos) = indices[0..i].iter().position(|&x| x == t) {\n                indices[pos] = j;\n            }\n            indices[i] = t;\n        }\n        Some(indices)\n    }","Real(LocalPath(\"src/seq/mod.rs\"))"],"seq::index_::IndexVec":["/// A vector of indices.\n///\n/// Multiple internal representations are possible.\npub enum IndexVec {\n    #[doc(hidden)]\n    U32(Vec<u32>),\n    #[cfg(target_pointer_width = \"64\")]\n    #[doc(hidden)]\n    U64(Vec<u64>),\n}","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::IndexVec::index":["/// Return the value at the given `index`.\n///\n/// (Note: we cannot implement [`std::ops::Index`] because of lifetime\n/// restrictions.)\n#[inline]\npub fn index(&self, index: usize) -> usize{\n        match self {\n            IndexVec::U32(v) => v[index] as usize,\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => v[index] as usize,\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::IndexVec::into_vec":["/// Return result as a `Vec<usize>`. Conversion may or may not be trivial.\n#[inline]\npub fn into_vec(self) -> Vec<usize>{\n        match self {\n            IndexVec::U32(v) => v.into_iter().map(|i| i as usize).collect(),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => v.into_iter().map(|i| i as usize).collect(),\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::IndexVec::is_empty":["/// Returns `true` if the length is 0.\n#[inline]\npub fn is_empty(&self) -> bool{\n        match self {\n            IndexVec::U32(v) => v.is_empty(),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => v.is_empty(),\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::IndexVec::iter":["/// Iterate over the indices as a sequence of `usize` values\n#[inline]\npub fn iter(&self) -> IndexVecIter<'_>{\n        match self {\n            IndexVec::U32(v) => IndexVecIter::U32(v.iter()),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => IndexVecIter::U64(v.iter()),\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::IndexVec::len":["/// Returns the number of indices\n#[inline]\npub fn len(&self) -> usize{\n        match self {\n            IndexVec::U32(v) => v.len(),\n            #[cfg(target_pointer_width = \"64\")]\n            IndexVec::U64(v) => v.len(),\n        }\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::IndexVecIntoIter":["/// Return type of `IndexVec::into_iter`.\npub enum IndexVecIntoIter {\n    #[doc(hidden)]\n    U32(vec::IntoIter<u32>),\n    #[cfg(target_pointer_width = \"64\")]\n    #[doc(hidden)]\n    U64(vec::IntoIter<u64>),\n}","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::IndexVecIter":["/// Return type of `IndexVec::iter`.\npub enum IndexVecIter<'a> {\n    #[doc(hidden)]\n    U32(slice::Iter<'a, u32>),\n    #[cfg(target_pointer_width = \"64\")]\n    #[doc(hidden)]\n    U64(slice::Iter<'a, u64>),\n}","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::UInt":["trait UInt: Copy + PartialOrd + Ord + PartialEq + Eq + SampleUniform + Hash + AddAssign {\n    fn zero() -> Self;\n    #[cfg_attr(feature = \"alloc\", allow(dead_code))]\n    fn one() -> Self;\n    fn as_usize(self) -> usize;\n}","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::sample":["/// Randomly sample exactly `amount` distinct indices from `0..length`, and\n/// return them in random order (fully shuffled).\n///\n/// This method is used internally by the slice sampling methods, but it can\n/// sometimes be useful to have the indices themselves so this is provided as\n/// an alternative.\n///\n/// The implementation used is not specified; we automatically select the\n/// fastest available algorithm for the `length` and `amount` parameters\n/// (based on detailed profiling on an Intel Haswell CPU). Roughly speaking,\n/// complexity is `O(amount)`, except that when `amount` is small, performance\n/// is closer to `O(amount^2)`, and when `length` is close to `amount` then\n/// `O(length)`.\n///\n/// Note that performance is significantly better over `u32` indices than over\n/// `u64` indices. Because of this we hide the underlying type behind an\n/// abstraction, `IndexVec`.\n///\n/// If an allocation-free `no_std` function is required, it is suggested\n/// to adapt the internal `sample_floyd` implementation.\n///\n/// Panics if `amount > length`.\n#[track_caller]\npub fn sample<R>(rng: &mut R, length: usize, amount: usize) -> IndexVec\nwhere\n    R: Rng + ?Sized,{\n    if amount > length {\n        panic!(\"`amount` of samples must be less than or equal to `length`\");\n    }\n    if length > (u32::MAX as usize) {\n        #[cfg(target_pointer_width = \"32\")]\n        unreachable!();\n\n        // We never want to use inplace here, but could use floyd's alg\n        // Lazy version: always use the cache alg.\n        #[cfg(target_pointer_width = \"64\")]\n        return sample_rejection(rng, length as u64, amount as u64);\n    }\n    let amount = amount as u32;\n    let length = length as u32;\n\n    // Choice of algorithm here depends on both length and amount. See:\n    // https://github.com/rust-random/rand/pull/479\n    // We do some calculations with f32. Accuracy is not very important.\n\n    if amount < 163 {\n        const C: [[f32; 2]; 2] = [[1.6, 8.0 / 45.0], [10.0, 70.0 / 9.0]];\n        let j = usize::from(length >= 500_000);\n        let amount_fp = amount as f32;\n        let m4 = C[0][j] * amount_fp;\n        // Short-cut: when amount < 12, floyd's is always faster\n        if amount > 11 && (length as f32) < (C[1][j] + m4) * amount_fp {\n            sample_inplace(rng, length, amount)\n        } else {\n            sample_floyd(rng, length, amount)\n        }\n    } else {\n        const C: [f32; 2] = [270.0, 330.0 / 9.0];\n        let j = usize::from(length >= 500_000);\n        if (length as f32) < C[j] * (amount as f32) {\n            sample_inplace(rng, length, amount)\n        } else {\n            sample_rejection(rng, length, amount)\n        }\n    }\n}","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::sample_efraimidis_spirakis":["/// Randomly sample `amount` distinct indices from `0..length`\n///\n/// The result may contain less than `amount` indices if insufficient non-zero\n/// weights are available. Results are returned in an arbitrary order (there is\n/// no guarantee of shuffling or ordering).\n///\n/// Function `weight` is called once for each index to provide weights.\n///\n/// This implementation is based on the algorithm A-ExpJ as found in\n/// [Efraimidis and Spirakis, 2005](https://doi.org/10.1016/j.ipl.2005.11.003).\n/// It uses `O(length + amount)` space and `O(length)` time.\n///\n/// Error cases:\n/// -   [`WeightError::InvalidWeight`] when a weight is not-a-number or negative.\n#[cfg(feature = \"std\")]\nfn sample_efraimidis_spirakis<R, F, X, N>(\n    rng: &mut R,\n    length: N,\n    weight: F,\n    amount: N,\n) -> Result<IndexVec, WeightError>\nwhere\n    R: Rng + ?Sized,\n    F: Fn(usize) -> X,\n    X: Into<f64>,\n    N: UInt,\n    IndexVec: From<Vec<N>>,{\n    use std::{cmp::Ordering, collections::BinaryHeap};\n\n    if amount == N::zero() {\n        return Ok(IndexVec::U32(Vec::new()));\n    }\n\n    struct Element<N> {\n        index: N,\n        key: f64,\n    }\n\n    impl<N> PartialOrd for Element<N> {\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }\n    }\n\n    impl<N> Ord for Element<N> {\n        fn cmp(&self, other: &Self) -> Ordering {\n            // unwrap() should not panic since weights should not be NaN\n            // We reverse so that BinaryHeap::peek shows the smallest item\n            self.key.partial_cmp(&other.key).unwrap().reverse()\n        }\n    }\n\n    impl<N> PartialEq for Element<N> {\n        fn eq(&self, other: &Self) -> bool {\n            self.key == other.key\n        }\n    }\n\n    impl<N> Eq for Element<N> {}\n\n    let mut candidates = BinaryHeap::with_capacity(amount.as_usize());\n    let mut index = N::zero();\n    while index < length && candidates.len() < amount.as_usize() {\n        let weight = weight(index.as_usize()).into();\n        if weight > 0.0 {\n            // We use the log of the key used in A-ExpJ to improve precision\n            // for small weights:\n            let key = rng.random::<f64>().ln() / weight;\n            candidates.push(Element { index, key });\n        } else if !(weight >= 0.0) {\n            return Err(WeightError::InvalidWeight);\n        }\n\n        index += N::one();\n    }\n\n    if index < length {\n        let mut x = rng.random::<f64>().ln() / candidates.peek().unwrap().key;\n        while index < length {\n            let weight = weight(index.as_usize()).into();\n            if weight > 0.0 {\n                x -= weight;\n                if x <= 0.0 {\n                    let min_candidate = candidates.pop().unwrap();\n                    let t = (min_candidate.key * weight).exp();\n                    let key = rng.random_range(t..1.0).ln() / weight;\n                    candidates.push(Element { index, key });\n\n                    x = rng.random::<f64>().ln() / candidates.peek().unwrap().key;\n                }\n            } else if !(weight >= 0.0) {\n                return Err(WeightError::InvalidWeight);\n            }\n\n            index += N::one();\n        }\n    }\n\n    Ok(IndexVec::from(\n        candidates.iter().map(|elt| elt.index).collect(),\n    ))\n}","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::sample_efraimidis_spirakis::Element":["struct Element<N> {\n        index: N,\n        key: f64,\n    }","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::sample_floyd":["/// Randomly sample exactly `amount` indices from `0..length`, using Floyd's\n/// combination algorithm.\n///\n/// The output values are fully shuffled. (Overhead is under 50%.)\n///\n/// This implementation uses `O(amount)` memory and `O(amount^2)` time.\nfn sample_floyd<R>(rng: &mut R, length: u32, amount: u32) -> IndexVec\nwhere\n    R: Rng + ?Sized,{\n    // Note that the values returned by `rng.random_range()` can be\n    // inferred from the returned vector by working backwards from\n    // the last entry. This bijection proves the algorithm fair.\n    debug_assert!(amount <= length);\n    let mut indices = Vec::with_capacity(amount as usize);\n    for j in length - amount..length {\n        let t = rng.random_range(..=j);\n        if let Some(pos) = indices.iter().position(|&x| x == t) {\n            indices[pos] = j;\n        }\n        indices.push(t);\n    }\n    IndexVec::from(indices)\n}","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::sample_inplace":["/// Randomly sample exactly `amount` indices from `0..length`, using an inplace\n/// partial Fisher-Yates method.\n/// Sample an amount of indices using an inplace partial fisher yates method.\n///\n/// This allocates the entire `length` of indices and randomizes only the first `amount`.\n/// It then truncates to `amount` and returns.\n///\n/// This method is not appropriate for large `length` and potentially uses a lot\n/// of memory; because of this we only implement for `u32` index (which improves\n/// performance in all cases).\n///\n/// Set-up is `O(length)` time and memory and shuffling is `O(amount)` time.\nfn sample_inplace<R>(rng: &mut R, length: u32, amount: u32) -> IndexVec\nwhere\n    R: Rng + ?Sized,{\n    debug_assert!(amount <= length);\n    let mut indices: Vec<u32> = Vec::with_capacity(length as usize);\n    indices.extend(0..length);\n    for i in 0..amount {\n        let j: u32 = rng.random_range(i..length);\n        indices.swap(i as usize, j as usize);\n    }\n    indices.truncate(amount as usize);\n    debug_assert_eq!(indices.len(), amount as usize);\n    IndexVec::from(indices)\n}","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::sample_rejection":["/// Randomly sample exactly `amount` indices from `0..length`, using rejection\n/// sampling.\n///\n/// Since `amount <<< length` there is a low chance of a random sample in\n/// `0..length` being a duplicate. We test for duplicates and resample where\n/// necessary. The algorithm is `O(amount)` time and memory.\n///\n/// This function  is generic over X primarily so that results are value-stable\n/// over 32-bit and 64-bit platforms.\nfn sample_rejection<X: UInt, R>(rng: &mut R, length: X, amount: X) -> IndexVec\nwhere\n    R: Rng + ?Sized,\n    IndexVec: From<Vec<X>>,{\n    debug_assert!(amount < length);\n    #[cfg(feature = \"std\")]\n    let mut cache = HashSet::with_capacity(amount.as_usize());\n    #[cfg(not(feature = \"std\"))]\n    let mut cache = BTreeSet::new();\n    let distr = Uniform::new(X::zero(), length).unwrap();\n    let mut indices = Vec::with_capacity(amount.as_usize());\n    for _ in 0..amount.as_usize() {\n        let mut pos = distr.sample(rng);\n        while !cache.insert(pos) {\n            pos = distr.sample(rng);\n        }\n        indices.push(pos);\n    }\n\n    debug_assert_eq!(indices.len(), amount.as_usize());\n    IndexVec::from(indices)\n}","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::index_::sample_weighted":["/// Randomly sample `amount` distinct indices from `0..length`\n///\n/// The result may contain less than `amount` indices if insufficient non-zero\n/// weights are available. Results are returned in an arbitrary order (there is\n/// no guarantee of shuffling or ordering).\n///\n/// Function `weight` is called once for each index to provide weights.\n///\n/// This method is used internally by the slice sampling methods, but it can\n/// sometimes be useful to have the indices themselves so this is provided as\n/// an alternative.\n///\n/// Error cases:\n/// -   [`WeightError::InvalidWeight`] when a weight is not-a-number or negative.\n///\n/// This implementation uses `O(length + amount)` space and `O(length)` time.\n#[cfg(feature = \"std\")]\npub fn sample_weighted<R, F, X>(\n    rng: &mut R,\n    length: usize,\n    weight: F,\n    amount: usize,\n) -> Result<IndexVec, WeightError>\nwhere\n    R: Rng + ?Sized,\n    F: Fn(usize) -> X,\n    X: Into<f64>,{\n    if length > (u32::MAX as usize) {\n        #[cfg(target_pointer_width = \"32\")]\n        unreachable!();\n\n        #[cfg(target_pointer_width = \"64\")]\n        {\n            let amount = amount as u64;\n            let length = length as u64;\n            sample_efraimidis_spirakis(rng, length, weight, amount)\n        }\n    } else {\n        assert!(amount <= u32::MAX as usize);\n        let amount = amount as u32;\n        let length = length as u32;\n        sample_efraimidis_spirakis(rng, length, weight, amount)\n    }\n}","Real(LocalPath(\"src/seq/index.rs\"))"],"seq::iterator::IteratorRandom":["/// Extension trait on iterators, providing random sampling methods.\n///\n/// This trait is implemented on all iterators `I` where `I: Iterator + Sized`\n/// and provides methods for\n/// choosing one or more elements. You must `use` this trait:\n///\n/// ```\n/// use rand::seq::IteratorRandom;\n///\n/// let faces = \"\";\n/// println!(\"I am {}!\", faces.chars().choose(&mut rand::rng()).unwrap());\n/// ```\n/// Example output (non-deterministic):\n/// ```none\n/// I am !\n/// ```\npub trait IteratorRandom: Iterator + Sized {\n    /// Uniformly sample one element\n    ///\n    /// Assuming that the [`Iterator::size_hint`] is correct, this method\n    /// returns one uniformly-sampled random element of the slice, or `None`\n    /// only if the slice is empty. Incorrect bounds on the `size_hint` may\n    /// cause this method to incorrectly return `None` if fewer elements than\n    /// the advertised `lower` bound are present and may prevent sampling of\n    /// elements beyond an advertised `upper` bound (i.e. incorrect `size_hint`\n    /// is memory-safe, but may result in unexpected `None` result and\n    /// non-uniform distribution).\n    ///\n    /// With an accurate [`Iterator::size_hint`] and where [`Iterator::nth`] is\n    /// a constant-time operation, this method can offer `O(1)` performance.\n    /// Where no size hint is\n    /// available, complexity is `O(n)` where `n` is the iterator length.\n    /// Partial hints (where `lower > 0`) also improve performance.\n    ///\n    /// Note further that [`Iterator::size_hint`] may affect the number of RNG\n    /// samples used as well as the result (while remaining uniform sampling).\n    /// Consider instead using [`IteratorRandom::choose_stable`] to avoid\n    /// [`Iterator`] combinators which only change size hints from affecting the\n    /// results.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::seq::IteratorRandom;\n    ///\n    /// let words = \"Mary had a little lamb\".split(' ');\n    /// println!(\"{}\", words.choose(&mut rand::rng()).unwrap());\n    /// ```\n    fn choose<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let (mut lower, mut upper) = self.size_hint();\n        let mut result = None;\n\n        // Handling for this condition outside the loop allows the optimizer to eliminate the loop\n        // when the Iterator is an ExactSizeIterator. This has a large performance impact on e.g.\n        // seq_iter_choose_from_1000.\n        if upper == Some(lower) {\n            return match lower {\n                0 => None,\n                1 => self.next(),\n                _ => self.nth(rng.random_range(..lower)),\n            };\n        }\n\n        let mut coin_flipper = CoinFlipper::new(rng);\n        let mut consumed = 0;\n\n        // Continue until the iterator is exhausted\n        loop {\n            if lower > 1 {\n                let ix = coin_flipper.rng.random_range(..lower + consumed);\n                let skip = if ix < lower {\n                    result = self.nth(ix);\n                    lower - (ix + 1)\n                } else {\n                    lower\n                };\n                if upper == Some(lower) {\n                    return result;\n                }\n                consumed += lower;\n                if skip > 0 {\n                    self.nth(skip - 1);\n                }\n            } else {\n                let elem = self.next();\n                if elem.is_none() {\n                    return result;\n                }\n                consumed += 1;\n                if coin_flipper.random_ratio_one_over(consumed) {\n                    result = elem;\n                }\n            }\n\n            let hint = self.size_hint();\n            lower = hint.0;\n            upper = hint.1;\n        }\n    }\n\n    /// Uniformly sample one element (stable)\n    ///\n    /// This method is very similar to [`choose`] except that the result\n    /// only depends on the length of the iterator and the values produced by\n    /// `rng`. Notably for any iterator of a given length this will make the\n    /// same requests to `rng` and if the same sequence of values are produced\n    /// the same index will be selected from `self`. This may be useful if you\n    /// need consistent results no matter what type of iterator you are working\n    /// with. If you do not need this stability prefer [`choose`].\n    ///\n    /// Note that this method still uses [`Iterator::size_hint`] to skip\n    /// constructing elements where possible, however the selection and `rng`\n    /// calls are the same in the face of this optimization. If you want to\n    /// force every element to be created regardless call `.inspect(|e| ())`.\n    ///\n    /// [`choose`]: IteratorRandom::choose\n    //\n    // Clippy is wrong here: we need to iterate over all entries with the RNG to\n    // ensure that choosing is *stable*.\n    #[allow(clippy::double_ended_iterator_last)]\n    fn choose_stable<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut consumed = 0;\n        let mut result = None;\n        let mut coin_flipper = CoinFlipper::new(rng);\n\n        loop {\n            // Currently the only way to skip elements is `nth()`. So we need to\n            // store what index to access next here.\n            // This should be replaced by `advance_by()` once it is stable:\n            // https://github.com/rust-lang/rust/issues/77404\n            let mut next = 0;\n\n            let (lower, _) = self.size_hint();\n            if lower >= 2 {\n                let highest_selected = (0..lower)\n                    .filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1))\n                    .last();\n\n                consumed += lower;\n                next = lower;\n\n                if let Some(ix) = highest_selected {\n                    result = self.nth(ix);\n                    next -= ix + 1;\n                    debug_assert!(result.is_some(), \"iterator shorter than size_hint().0\");\n                }\n            }\n\n            let elem = self.nth(next);\n            if elem.is_none() {\n                return result;\n            }\n\n            if coin_flipper.random_ratio_one_over(consumed + 1) {\n                result = elem;\n            }\n            consumed += 1;\n        }\n    }\n\n    /// Uniformly sample `amount` distinct elements into a buffer\n    ///\n    /// Collects values at random from the iterator into a supplied buffer\n    /// until that buffer is filled.\n    ///\n    /// Although the elements are selected randomly, the order of elements in\n    /// the buffer is neither stable nor fully random. If random ordering is\n    /// desired, shuffle the result.\n    ///\n    /// Returns the number of elements added to the buffer. This equals the length\n    /// of the buffer unless the iterator contains insufficient elements, in which\n    /// case this equals the number of elements available.\n    ///\n    /// Complexity is `O(n)` where `n` is the length of the iterator.\n    /// For slices, prefer [`IndexedRandom::choose_multiple`].\n    fn choose_multiple_fill<R>(mut self, rng: &mut R, buf: &mut [Self::Item]) -> usize\n    where\n        R: Rng + ?Sized,\n    {\n        let amount = buf.len();\n        let mut len = 0;\n        while len < amount {\n            if let Some(elem) = self.next() {\n                buf[len] = elem;\n                len += 1;\n            } else {\n                // Iterator exhausted; stop early\n                return len;\n            }\n        }\n\n        // Continue, since the iterator was not exhausted\n        for (i, elem) in self.enumerate() {\n            let k = rng.random_range(..i + 1 + amount);\n            if let Some(slot) = buf.get_mut(k) {\n                *slot = elem;\n            }\n        }\n        len\n    }\n\n    /// Uniformly sample `amount` distinct elements into a [`Vec`]\n    ///\n    /// This is equivalent to `choose_multiple_fill` except for the result type.\n    ///\n    /// Although the elements are selected randomly, the order of elements in\n    /// the buffer is neither stable nor fully random. If random ordering is\n    /// desired, shuffle the result.\n    ///\n    /// The length of the returned vector equals `amount` unless the iterator\n    /// contains insufficient elements, in which case it equals the number of\n    /// elements available.\n    ///\n    /// Complexity is `O(n)` where `n` is the length of the iterator.\n    /// For slices, prefer [`IndexedRandom::choose_multiple`].\n    #[cfg(feature = \"alloc\")]\n    fn choose_multiple<R>(mut self, rng: &mut R, amount: usize) -> Vec<Self::Item>\n    where\n        R: Rng + ?Sized,\n    {\n        let mut reservoir = Vec::with_capacity(amount);\n        reservoir.extend(self.by_ref().take(amount));\n\n        // Continue unless the iterator was exhausted\n        //\n        // note: this prevents iterators that \"restart\" from causing problems.\n        // If the iterator stops once, then so do we.\n        if reservoir.len() == amount {\n            for (i, elem) in self.enumerate() {\n                let k = rng.random_range(..i + 1 + amount);\n                if let Some(slot) = reservoir.get_mut(k) {\n                    *slot = elem;\n                }\n            }\n        } else {\n            // Don't hang onto extra memory. There is a corner case where\n            // `amount` was much less than `self.len()`.\n            reservoir.shrink_to_fit();\n        }\n        reservoir\n    }\n}","Real(LocalPath(\"src/seq/iterator.rs\"))"],"seq::iterator::IteratorRandom::choose":["/// Uniformly sample one element\n///\n/// Assuming that the [`Iterator::size_hint`] is correct, this method\n/// returns one uniformly-sampled random element of the slice, or `None`\n/// only if the slice is empty. Incorrect bounds on the `size_hint` may\n/// cause this method to incorrectly return `None` if fewer elements than\n/// the advertised `lower` bound are present and may prevent sampling of\n/// elements beyond an advertised `upper` bound (i.e. incorrect `size_hint`\n/// is memory-safe, but may result in unexpected `None` result and\n/// non-uniform distribution).\n///\n/// With an accurate [`Iterator::size_hint`] and where [`Iterator::nth`] is\n/// a constant-time operation, this method can offer `O(1)` performance.\n/// Where no size hint is\n/// available, complexity is `O(n)` where `n` is the iterator length.\n/// Partial hints (where `lower > 0`) also improve performance.\n///\n/// Note further that [`Iterator::size_hint`] may affect the number of RNG\n/// samples used as well as the result (while remaining uniform sampling).\n/// Consider instead using [`IteratorRandom::choose_stable`] to avoid\n/// [`Iterator`] combinators which only change size hints from affecting the\n/// results.\n///\n/// # Example\n///\n/// ```\n/// use rand::seq::IteratorRandom;\n///\n/// let words = \"Mary had a little lamb\".split(' ');\n/// println!(\"{}\", words.choose(&mut rand::rng()).unwrap());\n/// ```\nfn choose<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,{\n        let (mut lower, mut upper) = self.size_hint();\n        let mut result = None;\n\n        // Handling for this condition outside the loop allows the optimizer to eliminate the loop\n        // when the Iterator is an ExactSizeIterator. This has a large performance impact on e.g.\n        // seq_iter_choose_from_1000.\n        if upper == Some(lower) {\n            return match lower {\n                0 => None,\n                1 => self.next(),\n                _ => self.nth(rng.random_range(..lower)),\n            };\n        }\n\n        let mut coin_flipper = CoinFlipper::new(rng);\n        let mut consumed = 0;\n\n        // Continue until the iterator is exhausted\n        loop {\n            if lower > 1 {\n                let ix = coin_flipper.rng.random_range(..lower + consumed);\n                let skip = if ix < lower {\n                    result = self.nth(ix);\n                    lower - (ix + 1)\n                } else {\n                    lower\n                };\n                if upper == Some(lower) {\n                    return result;\n                }\n                consumed += lower;\n                if skip > 0 {\n                    self.nth(skip - 1);\n                }\n            } else {\n                let elem = self.next();\n                if elem.is_none() {\n                    return result;\n                }\n                consumed += 1;\n                if coin_flipper.random_ratio_one_over(consumed) {\n                    result = elem;\n                }\n            }\n\n            let hint = self.size_hint();\n            lower = hint.0;\n            upper = hint.1;\n        }\n    }","Real(LocalPath(\"src/seq/iterator.rs\"))"],"seq::iterator::IteratorRandom::choose_multiple":["/// Uniformly sample `amount` distinct elements into a [`Vec`]\n///\n/// This is equivalent to `choose_multiple_fill` except for the result type.\n///\n/// Although the elements are selected randomly, the order of elements in\n/// the buffer is neither stable nor fully random. If random ordering is\n/// desired, shuffle the result.\n///\n/// The length of the returned vector equals `amount` unless the iterator\n/// contains insufficient elements, in which case it equals the number of\n/// elements available.\n///\n/// Complexity is `O(n)` where `n` is the length of the iterator.\n/// For slices, prefer [`IndexedRandom::choose_multiple`].\n#[cfg(feature = \"alloc\")]\nfn choose_multiple<R>(mut self, rng: &mut R, amount: usize) -> Vec<Self::Item>\n    where\n        R: Rng + ?Sized,{\n        let mut reservoir = Vec::with_capacity(amount);\n        reservoir.extend(self.by_ref().take(amount));\n\n        // Continue unless the iterator was exhausted\n        //\n        // note: this prevents iterators that \"restart\" from causing problems.\n        // If the iterator stops once, then so do we.\n        if reservoir.len() == amount {\n            for (i, elem) in self.enumerate() {\n                let k = rng.random_range(..i + 1 + amount);\n                if let Some(slot) = reservoir.get_mut(k) {\n                    *slot = elem;\n                }\n            }\n        } else {\n            // Don't hang onto extra memory. There is a corner case where\n            // `amount` was much less than `self.len()`.\n            reservoir.shrink_to_fit();\n        }\n        reservoir\n    }","Real(LocalPath(\"src/seq/iterator.rs\"))"],"seq::iterator::IteratorRandom::choose_multiple_fill":["/// Uniformly sample `amount` distinct elements into a buffer\n///\n/// Collects values at random from the iterator into a supplied buffer\n/// until that buffer is filled.\n///\n/// Although the elements are selected randomly, the order of elements in\n/// the buffer is neither stable nor fully random. If random ordering is\n/// desired, shuffle the result.\n///\n/// Returns the number of elements added to the buffer. This equals the length\n/// of the buffer unless the iterator contains insufficient elements, in which\n/// case this equals the number of elements available.\n///\n/// Complexity is `O(n)` where `n` is the length of the iterator.\n/// For slices, prefer [`IndexedRandom::choose_multiple`].\nfn choose_multiple_fill<R>(mut self, rng: &mut R, buf: &mut [Self::Item]) -> usize\n    where\n        R: Rng + ?Sized,{\n        let amount = buf.len();\n        let mut len = 0;\n        while len < amount {\n            if let Some(elem) = self.next() {\n                buf[len] = elem;\n                len += 1;\n            } else {\n                // Iterator exhausted; stop early\n                return len;\n            }\n        }\n\n        // Continue, since the iterator was not exhausted\n        for (i, elem) in self.enumerate() {\n            let k = rng.random_range(..i + 1 + amount);\n            if let Some(slot) = buf.get_mut(k) {\n                *slot = elem;\n            }\n        }\n        len\n    }","Real(LocalPath(\"src/seq/iterator.rs\"))"],"seq::iterator::IteratorRandom::choose_stable":["/// Uniformly sample one element (stable)\n///\n/// This method is very similar to [`choose`] except that the result\n/// only depends on the length of the iterator and the values produced by\n/// `rng`. Notably for any iterator of a given length this will make the\n/// same requests to `rng` and if the same sequence of values are produced\n/// the same index will be selected from `self`. This may be useful if you\n/// need consistent results no matter what type of iterator you are working\n/// with. If you do not need this stability prefer [`choose`].\n///\n/// Note that this method still uses [`Iterator::size_hint`] to skip\n/// constructing elements where possible, however the selection and `rng`\n/// calls are the same in the face of this optimization. If you want to\n/// force every element to be created regardless call `.inspect(|e| ())`.\n///\n/// [`choose`]: IteratorRandom::choose\n#[allow(clippy::double_ended_iterator_last)]\nfn choose_stable<R>(mut self, rng: &mut R) -> Option<Self::Item>\n    where\n        R: Rng + ?Sized,{\n        let mut consumed = 0;\n        let mut result = None;\n        let mut coin_flipper = CoinFlipper::new(rng);\n\n        loop {\n            // Currently the only way to skip elements is `nth()`. So we need to\n            // store what index to access next here.\n            // This should be replaced by `advance_by()` once it is stable:\n            // https://github.com/rust-lang/rust/issues/77404\n            let mut next = 0;\n\n            let (lower, _) = self.size_hint();\n            if lower >= 2 {\n                let highest_selected = (0..lower)\n                    .filter(|ix| coin_flipper.random_ratio_one_over(consumed + ix + 1))\n                    .last();\n\n                consumed += lower;\n                next = lower;\n\n                if let Some(ix) = highest_selected {\n                    result = self.nth(ix);\n                    next -= ix + 1;\n                    debug_assert!(result.is_some(), \"iterator shorter than size_hint().0\");\n                }\n            }\n\n            let elem = self.nth(next);\n            if elem.is_none() {\n                return result;\n            }\n\n            if coin_flipper.random_ratio_one_over(consumed + 1) {\n                result = elem;\n            }\n            consumed += 1;\n        }\n    }","Real(LocalPath(\"src/seq/iterator.rs\"))"],"seq::slice::IndexedMutRandom":["/// Extension trait on indexable lists, providing random sampling methods.\n///\n/// This trait is implemented automatically for every type implementing\n/// [`IndexedRandom`] and [`std::ops::IndexMut<usize>`].\npub trait IndexedMutRandom: IndexedRandom + IndexMut<usize> {\n    /// Uniformly sample one element (mut)\n    ///\n    /// Returns a mutable reference to one uniformly-sampled random element of\n    /// the slice, or `None` if the slice is empty.\n    ///\n    /// For slices, complexity is `O(1)`.\n    fn choose_mut<R>(&mut self, rng: &mut R) -> Option<&mut Self::Output>\n    where\n        R: Rng + ?Sized,\n    {\n        if self.is_empty() {\n            None\n        } else {\n            let len = self.len();\n            Some(&mut self[rng.random_range(..len)])\n        }\n    }\n\n    /// Biased sampling for one element (mut)\n    ///\n    /// Returns a mutable reference to one element of the slice, sampled according\n    /// to the provided weights. Returns `None` only if the slice is empty.\n    ///\n    /// The specified function `weight` maps each item `x` to a relative\n    /// likelihood `weight(x)`. The probability of each item being selected is\n    /// therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.\n    ///\n    /// For slices of length `n`, complexity is `O(n)`.\n    /// For more information about the underlying algorithm,\n    /// see the [`WeightedIndex`] distribution.\n    ///\n    /// See also [`choose_weighted`].\n    ///\n    /// [`choose_mut`]: IndexedMutRandom::choose_mut\n    /// [`choose_weighted`]: IndexedRandom::choose_weighted\n    /// [`WeightedIndex`]: crate::distr::weighted::WeightedIndex\n    #[cfg(feature = \"alloc\")]\n    fn choose_weighted_mut<R, F, B, X>(\n        &mut self,\n        rng: &mut R,\n        weight: F,\n    ) -> Result<&mut Self::Output, WeightError>\n    where\n        R: Rng + ?Sized,\n        F: Fn(&Self::Output) -> B,\n        B: SampleBorrow<X>,\n        X: SampleUniform + Weight + PartialOrd<X>,\n    {\n        use crate::distr::{weighted::WeightedIndex, Distribution};\n        let distr = WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?;\n        let index = distr.sample(rng);\n        Ok(&mut self[index])\n    }\n}","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::IndexedMutRandom::choose_mut":["/// Uniformly sample one element (mut)\n///\n/// Returns a mutable reference to one uniformly-sampled random element of\n/// the slice, or `None` if the slice is empty.\n///\n/// For slices, complexity is `O(1)`.\nfn choose_mut<R>(&mut self, rng: &mut R) -> Option<&mut Self::Output>\n    where\n        R: Rng + ?Sized,{\n        if self.is_empty() {\n            None\n        } else {\n            let len = self.len();\n            Some(&mut self[rng.random_range(..len)])\n        }\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::IndexedMutRandom::choose_weighted_mut":["/// Biased sampling for one element (mut)\n///\n/// Returns a mutable reference to one element of the slice, sampled according\n/// to the provided weights. Returns `None` only if the slice is empty.\n///\n/// The specified function `weight` maps each item `x` to a relative\n/// likelihood `weight(x)`. The probability of each item being selected is\n/// therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.\n///\n/// For slices of length `n`, complexity is `O(n)`.\n/// For more information about the underlying algorithm,\n/// see the [`WeightedIndex`] distribution.\n///\n/// See also [`choose_weighted`].\n///\n/// [`choose_mut`]: IndexedMutRandom::choose_mut\n/// [`choose_weighted`]: IndexedRandom::choose_weighted\n/// [`WeightedIndex`]: crate::distr::weighted::WeightedIndex\n#[cfg(feature = \"alloc\")]\nfn choose_weighted_mut<R, F, B, X>(\n        &mut self,\n        rng: &mut R,\n        weight: F,\n    ) -> Result<&mut Self::Output, WeightError>\n    where\n        R: Rng + ?Sized,\n        F: Fn(&Self::Output) -> B,\n        B: SampleBorrow<X>,\n        X: SampleUniform + Weight + PartialOrd<X>,{\n        use crate::distr::{weighted::WeightedIndex, Distribution};\n        let distr = WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?;\n        let index = distr.sample(rng);\n        Ok(&mut self[index])\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::IndexedRandom":["/// Extension trait on indexable lists, providing random sampling methods.\n///\n/// This trait is implemented on `[T]` slice types. Other types supporting\n/// [`std::ops::Index<usize>`] may implement this (only [`Self::len`] must be\n/// specified).\npub trait IndexedRandom: Index<usize> {\n    /// The length\n    fn len(&self) -> usize;\n\n    /// True when the length is zero\n    #[inline]\n    fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Uniformly sample one element\n    ///\n    /// Returns a reference to one uniformly-sampled random element of\n    /// the slice, or `None` if the slice is empty.\n    ///\n    /// For slices, complexity is `O(1)`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::seq::IndexedRandom;\n    ///\n    /// let choices = [1, 2, 4, 8, 16, 32];\n    /// let mut rng = rand::rng();\n    /// println!(\"{:?}\", choices.choose(&mut rng));\n    /// assert_eq!(choices[..0].choose(&mut rng), None);\n    /// ```\n    fn choose<R>(&self, rng: &mut R) -> Option<&Self::Output>\n    where\n        R: Rng + ?Sized,\n    {\n        if self.is_empty() {\n            None\n        } else {\n            Some(&self[rng.random_range(..self.len())])\n        }\n    }\n\n    /// Uniformly sample `amount` distinct elements from self\n    ///\n    /// Chooses `amount` elements from the slice at random, without repetition,\n    /// and in random order. The returned iterator is appropriate both for\n    /// collection into a `Vec` and filling an existing buffer (see example).\n    ///\n    /// In case this API is not sufficiently flexible, use [`index::sample`].\n    ///\n    /// For slices, complexity is the same as [`index::sample`].\n    ///\n    /// # Example\n    /// ```\n    /// use rand::seq::IndexedRandom;\n    ///\n    /// let mut rng = &mut rand::rng();\n    /// let sample = \"Hello, audience!\".as_bytes();\n    ///\n    /// // collect the results into a vector:\n    /// let v: Vec<u8> = sample.choose_multiple(&mut rng, 3).cloned().collect();\n    ///\n    /// // store in a buffer:\n    /// let mut buf = [0u8; 5];\n    /// for (b, slot) in sample.choose_multiple(&mut rng, buf.len()).zip(buf.iter_mut()) {\n    ///     *slot = *b;\n    /// }\n    /// ```\n    #[cfg(feature = \"alloc\")]\n    fn choose_multiple<R>(&self, rng: &mut R, amount: usize) -> SliceChooseIter<Self, Self::Output>\n    where\n        Self::Output: Sized,\n        R: Rng + ?Sized,\n    {\n        let amount = core::cmp::min(amount, self.len());\n        SliceChooseIter {\n            slice: self,\n            _phantom: Default::default(),\n            indices: index::sample(rng, self.len(), amount).into_iter(),\n        }\n    }\n\n    /// Uniformly sample a fixed-size array of distinct elements from self\n    ///\n    /// Chooses `N` elements from the slice at random, without repetition,\n    /// and in random order.\n    ///\n    /// For slices, complexity is the same as [`index::sample_array`].\n    ///\n    /// # Example\n    /// ```\n    /// use rand::seq::IndexedRandom;\n    ///\n    /// let mut rng = &mut rand::rng();\n    /// let sample = \"Hello, audience!\".as_bytes();\n    ///\n    /// let a: [u8; 3] = sample.choose_multiple_array(&mut rng).unwrap();\n    /// ```\n    fn choose_multiple_array<R, const N: usize>(&self, rng: &mut R) -> Option<[Self::Output; N]>\n    where\n        Self::Output: Clone + Sized,\n        R: Rng + ?Sized,\n    {\n        let indices = index::sample_array(rng, self.len())?;\n        Some(indices.map(|index| self[index].clone()))\n    }\n\n    /// Biased sampling for one element\n    ///\n    /// Returns a reference to one element of the slice, sampled according\n    /// to the provided weights. Returns `None` only if the slice is empty.\n    ///\n    /// The specified function `weight` maps each item `x` to a relative\n    /// likelihood `weight(x)`. The probability of each item being selected is\n    /// therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.\n    ///\n    /// For slices of length `n`, complexity is `O(n)`.\n    /// For more information about the underlying algorithm,\n    /// see the [`WeightedIndex`] distribution.\n    ///\n    /// See also [`choose_weighted_mut`].\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::prelude::*;\n    ///\n    /// let choices = [('a', 2), ('b', 1), ('c', 1), ('d', 0)];\n    /// let mut rng = rand::rng();\n    /// // 50% chance to print 'a', 25% chance to print 'b', 25% chance to print 'c',\n    /// // and 'd' will never be printed\n    /// println!(\"{:?}\", choices.choose_weighted(&mut rng, |item| item.1).unwrap().0);\n    /// ```\n    /// [`choose`]: IndexedRandom::choose\n    /// [`choose_weighted_mut`]: IndexedMutRandom::choose_weighted_mut\n    /// [`WeightedIndex`]: crate::distr::weighted::WeightedIndex\n    #[cfg(feature = \"alloc\")]\n    fn choose_weighted<R, F, B, X>(\n        &self,\n        rng: &mut R,\n        weight: F,\n    ) -> Result<&Self::Output, WeightError>\n    where\n        R: Rng + ?Sized,\n        F: Fn(&Self::Output) -> B,\n        B: SampleBorrow<X>,\n        X: SampleUniform + Weight + PartialOrd<X>,\n    {\n        use crate::distr::{weighted::WeightedIndex, Distribution};\n        let distr = WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?;\n        Ok(&self[distr.sample(rng)])\n    }\n\n    /// Biased sampling of `amount` distinct elements\n    ///\n    /// Similar to [`choose_multiple`], but where the likelihood of each\n    /// element's inclusion in the output may be specified. Zero-weighted\n    /// elements are never returned; the result may therefore contain fewer\n    /// elements than `amount` even when `self.len() >= amount`. The elements\n    /// are returned in an arbitrary, unspecified order.\n    ///\n    /// The specified function `weight` maps each item `x` to a relative\n    /// likelihood `weight(x)`. The probability of each item being selected is\n    /// therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.\n    ///\n    /// This implementation uses `O(length + amount)` space and `O(length)` time.\n    /// See [`index::sample_weighted`] for details.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::prelude::*;\n    ///\n    /// let choices = [('a', 2), ('b', 1), ('c', 1)];\n    /// let mut rng = rand::rng();\n    /// // First Draw * Second Draw = total odds\n    /// // -----------------------\n    /// // (50% * 50%) + (25% * 67%) = 41.7% chance that the output is `['a', 'b']` in some order.\n    /// // (50% * 50%) + (25% * 67%) = 41.7% chance that the output is `['a', 'c']` in some order.\n    /// // (25% * 33%) + (25% * 33%) = 16.6% chance that the output is `['b', 'c']` in some order.\n    /// println!(\"{:?}\", choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).unwrap().collect::<Vec<_>>());\n    /// ```\n    /// [`choose_multiple`]: IndexedRandom::choose_multiple\n    // Note: this is feature-gated on std due to usage of f64::powf.\n    // If necessary, we may use alloc+libm as an alternative (see PR #1089).\n    #[cfg(feature = \"std\")]\n    fn choose_multiple_weighted<R, F, X>(\n        &self,\n        rng: &mut R,\n        amount: usize,\n        weight: F,\n    ) -> Result<SliceChooseIter<Self, Self::Output>, WeightError>\n    where\n        Self::Output: Sized,\n        R: Rng + ?Sized,\n        F: Fn(&Self::Output) -> X,\n        X: Into<f64>,\n    {\n        let amount = core::cmp::min(amount, self.len());\n        Ok(SliceChooseIter {\n            slice: self,\n            _phantom: Default::default(),\n            indices: index::sample_weighted(\n                rng,\n                self.len(),\n                |idx| weight(&self[idx]).into(),\n                amount,\n            )?\n            .into_iter(),\n        })\n    }\n}","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::IndexedRandom::choose":["/// Uniformly sample one element\n///\n/// Returns a reference to one uniformly-sampled random element of\n/// the slice, or `None` if the slice is empty.\n///\n/// For slices, complexity is `O(1)`.\n///\n/// # Example\n///\n/// ```\n/// use rand::seq::IndexedRandom;\n///\n/// let choices = [1, 2, 4, 8, 16, 32];\n/// let mut rng = rand::rng();\n/// println!(\"{:?}\", choices.choose(&mut rng));\n/// assert_eq!(choices[..0].choose(&mut rng), None);\n/// ```\nfn choose<R>(&self, rng: &mut R) -> Option<&Self::Output>\n    where\n        R: Rng + ?Sized,{\n        if self.is_empty() {\n            None\n        } else {\n            Some(&self[rng.random_range(..self.len())])\n        }\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::IndexedRandom::choose_multiple":["/// Uniformly sample `amount` distinct elements from self\n///\n/// Chooses `amount` elements from the slice at random, without repetition,\n/// and in random order. The returned iterator is appropriate both for\n/// collection into a `Vec` and filling an existing buffer (see example).\n///\n/// In case this API is not sufficiently flexible, use [`index::sample`].\n///\n/// For slices, complexity is the same as [`index::sample`].\n///\n/// # Example\n/// ```\n/// use rand::seq::IndexedRandom;\n///\n/// let mut rng = &mut rand::rng();\n/// let sample = \"Hello, audience!\".as_bytes();\n///\n/// // collect the results into a vector:\n/// let v: Vec<u8> = sample.choose_multiple(&mut rng, 3).cloned().collect();\n///\n/// // store in a buffer:\n/// let mut buf = [0u8; 5];\n/// for (b, slot) in sample.choose_multiple(&mut rng, buf.len()).zip(buf.iter_mut()) {\n///     *slot = *b;\n/// }\n/// ```\n#[cfg(feature = \"alloc\")]\nfn choose_multiple<R>(&self, rng: &mut R, amount: usize) -> SliceChooseIter<Self, Self::Output>\n    where\n        Self::Output: Sized,\n        R: Rng + ?Sized,{\n        let amount = core::cmp::min(amount, self.len());\n        SliceChooseIter {\n            slice: self,\n            _phantom: Default::default(),\n            indices: index::sample(rng, self.len(), amount).into_iter(),\n        }\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::IndexedRandom::choose_multiple_array":["/// Uniformly sample a fixed-size array of distinct elements from self\n///\n/// Chooses `N` elements from the slice at random, without repetition,\n/// and in random order.\n///\n/// For slices, complexity is the same as [`index::sample_array`].\n///\n/// # Example\n/// ```\n/// use rand::seq::IndexedRandom;\n///\n/// let mut rng = &mut rand::rng();\n/// let sample = \"Hello, audience!\".as_bytes();\n///\n/// let a: [u8; 3] = sample.choose_multiple_array(&mut rng).unwrap();\n/// ```\nfn choose_multiple_array<R, const N: usize>(&self, rng: &mut R) -> Option<[Self::Output; N]>\n    where\n        Self::Output: Clone + Sized,\n        R: Rng + ?Sized,{\n        let indices = index::sample_array(rng, self.len())?;\n        Some(indices.map(|index| self[index].clone()))\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::IndexedRandom::choose_multiple_weighted":["/// Biased sampling of `amount` distinct elements\n///\n/// Similar to [`choose_multiple`], but where the likelihood of each\n/// element's inclusion in the output may be specified. Zero-weighted\n/// elements are never returned; the result may therefore contain fewer\n/// elements than `amount` even when `self.len() >= amount`. The elements\n/// are returned in an arbitrary, unspecified order.\n///\n/// The specified function `weight` maps each item `x` to a relative\n/// likelihood `weight(x)`. The probability of each item being selected is\n/// therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.\n///\n/// This implementation uses `O(length + amount)` space and `O(length)` time.\n/// See [`index::sample_weighted`] for details.\n///\n/// # Example\n///\n/// ```\n/// use rand::prelude::*;\n///\n/// let choices = [('a', 2), ('b', 1), ('c', 1)];\n/// let mut rng = rand::rng();\n/// // First Draw * Second Draw = total odds\n/// // -----------------------\n/// // (50% * 50%) + (25% * 67%) = 41.7% chance that the output is `['a', 'b']` in some order.\n/// // (50% * 50%) + (25% * 67%) = 41.7% chance that the output is `['a', 'c']` in some order.\n/// // (25% * 33%) + (25% * 33%) = 16.6% chance that the output is `['b', 'c']` in some order.\n/// println!(\"{:?}\", choices.choose_multiple_weighted(&mut rng, 2, |item| item.1).unwrap().collect::<Vec<_>>());\n/// ```\n/// [`choose_multiple`]: IndexedRandom::choose_multiple\n#[cfg(feature = \"std\")]\nfn choose_multiple_weighted<R, F, X>(\n        &self,\n        rng: &mut R,\n        amount: usize,\n        weight: F,\n    ) -> Result<SliceChooseIter<Self, Self::Output>, WeightError>\n    where\n        Self::Output: Sized,\n        R: Rng + ?Sized,\n        F: Fn(&Self::Output) -> X,\n        X: Into<f64>,{\n        let amount = core::cmp::min(amount, self.len());\n        Ok(SliceChooseIter {\n            slice: self,\n            _phantom: Default::default(),\n            indices: index::sample_weighted(\n                rng,\n                self.len(),\n                |idx| weight(&self[idx]).into(),\n                amount,\n            )?\n            .into_iter(),\n        })\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::IndexedRandom::choose_weighted":["/// Biased sampling for one element\n///\n/// Returns a reference to one element of the slice, sampled according\n/// to the provided weights. Returns `None` only if the slice is empty.\n///\n/// The specified function `weight` maps each item `x` to a relative\n/// likelihood `weight(x)`. The probability of each item being selected is\n/// therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.\n///\n/// For slices of length `n`, complexity is `O(n)`.\n/// For more information about the underlying algorithm,\n/// see the [`WeightedIndex`] distribution.\n///\n/// See also [`choose_weighted_mut`].\n///\n/// # Example\n///\n/// ```\n/// use rand::prelude::*;\n///\n/// let choices = [('a', 2), ('b', 1), ('c', 1), ('d', 0)];\n/// let mut rng = rand::rng();\n/// // 50% chance to print 'a', 25% chance to print 'b', 25% chance to print 'c',\n/// // and 'd' will never be printed\n/// println!(\"{:?}\", choices.choose_weighted(&mut rng, |item| item.1).unwrap().0);\n/// ```\n/// [`choose`]: IndexedRandom::choose\n/// [`choose_weighted_mut`]: IndexedMutRandom::choose_weighted_mut\n/// [`WeightedIndex`]: crate::distr::weighted::WeightedIndex\n#[cfg(feature = \"alloc\")]\nfn choose_weighted<R, F, B, X>(\n        &self,\n        rng: &mut R,\n        weight: F,\n    ) -> Result<&Self::Output, WeightError>\n    where\n        R: Rng + ?Sized,\n        F: Fn(&Self::Output) -> B,\n        B: SampleBorrow<X>,\n        X: SampleUniform + Weight + PartialOrd<X>,{\n        use crate::distr::{weighted::WeightedIndex, Distribution};\n        let distr = WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?;\n        Ok(&self[distr.sample(rng)])\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::IndexedRandom::is_empty":["/// True when the length is zero\n#[inline]\nfn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::SliceChooseIter":["/// An iterator over multiple slice elements.\n///\n/// This struct is created by\n/// [`IndexedRandom::choose_multiple`](trait.IndexedRandom.html#tymethod.choose_multiple).\n#[cfg(feature = \"alloc\")]\npub struct SliceChooseIter<'a, S: ?Sized + 'a, T: 'a> {\n    slice: &'a S,\n    _phantom: core::marker::PhantomData<T>,\n    indices: index::IndexVecIntoIter,\n}","Real(LocalPath(\"src/seq/slice.rs\"))"],"seq::slice::SliceRandom":["/// Extension trait on slices, providing shuffling methods.\n///\n/// This trait is implemented on all `[T]` slice types, providing several\n/// methods for choosing and shuffling elements. You must `use` this trait:\n///\n/// ```\n/// use rand::seq::SliceRandom;\n///\n/// let mut rng = rand::rng();\n/// let mut bytes = \"Hello, random!\".to_string().into_bytes();\n/// bytes.shuffle(&mut rng);\n/// let str = String::from_utf8(bytes).unwrap();\n/// println!(\"{}\", str);\n/// ```\n/// Example output (non-deterministic):\n/// ```none\n/// l,nmroHado !le\n/// ```\npub trait SliceRandom: IndexedMutRandom {\n    /// Shuffle a mutable slice in place.\n    ///\n    /// For slices of length `n`, complexity is `O(n)`.\n    /// The resulting permutation is picked uniformly from the set of all possible permutations.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::seq::SliceRandom;\n    ///\n    /// let mut rng = rand::rng();\n    /// let mut y = [1, 2, 3, 4, 5];\n    /// println!(\"Unshuffled: {:?}\", y);\n    /// y.shuffle(&mut rng);\n    /// println!(\"Shuffled:   {:?}\", y);\n    /// ```\n    fn shuffle<R>(&mut self, rng: &mut R)\n    where\n        R: Rng + ?Sized;\n\n    /// Shuffle a slice in place, but exit early.\n    ///\n    /// Returns two mutable slices from the source slice. The first contains\n    /// `amount` elements randomly permuted. The second has the remaining\n    /// elements that are not fully shuffled.\n    ///\n    /// This is an efficient method to select `amount` elements at random from\n    /// the slice, provided the slice may be mutated.\n    ///\n    /// If you only need to choose elements randomly and `amount > self.len()/2`\n    /// then you may improve performance by taking\n    /// `amount = self.len() - amount` and using only the second slice.\n    ///\n    /// If `amount` is greater than the number of elements in the slice, this\n    /// will perform a full shuffle.\n    ///\n    /// For slices, complexity is `O(m)` where `m = amount`.\n    fn partial_shuffle<R>(\n        &mut self,\n        rng: &mut R,\n        amount: usize,\n    ) -> (&mut [Self::Output], &mut [Self::Output])\n    where\n        Self::Output: Sized,\n        R: Rng + ?Sized;\n}","Real(LocalPath(\"src/seq/slice.rs\"))"],"thread_rng":["/// Access the thread-local generator\n///\n/// Use [`rand::rng()`](rng()) instead.\n#[cfg(feature = \"thread_rng\")]\n#[deprecated(since = \"0.9.0\", note = \"Renamed to `rng`\")]\n#[inline]\npub fn thread_rng() -> crate::rngs::ThreadRng{\n    rng()\n}","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"(&'^0.Named(DefId(0:2214 ~ rand[6311]::seq::slice::SliceRandom::partial_shuffle::'_), \"'_\") mut [Alias(Projection, AliasTy { args: [Self/#0, usize], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })], &'^0.Named(DefId(0:2214 ~ rand[6311]::seq::slice::SliceRandom::partial_shuffle::'_), \"'_\") mut [Alias(Projection, AliasTy { args: [Self/#0, usize], def_id: DefId(1:40133 ~ core[a245]::ops::index::Index::Output) })])":["partial_shuffle"],"(&'^0.Named(DefId(0:2219 ~ rand[6311]::seq::slice::{impl#2}::partial_shuffle::'_), \"'_\") mut [T/#0], &'^0.Named(DefId(0:2219 ~ rand[6311]::seq::slice::{impl#2}::partial_shuffle::'_), \"'_\") mut [T/#0])":["partial_shuffle"],"(A/#0, B/#1)":["sample"],"(A/#0, B/#1, C/#2)":["sample"],"(A/#0, B/#1, C/#2, D/#3)":["sample"],"(A/#0, B/#1, C/#2, D/#3, E/#4)":["sample"],"(A/#0, B/#1, C/#2, D/#3, E/#4, F/#5)":["sample"],"(A/#0, B/#1, C/#2, D/#3, E/#4, F/#5, G/#6)":["sample"],"(A/#0, B/#1, C/#2, D/#3, E/#4, F/#5, G/#6, H/#7)":["sample"],"(A/#0, B/#1, C/#2, D/#3, E/#4, F/#5, G/#6, H/#7, I/#8)":["sample"],"(A/#0, B/#1, C/#2, D/#3, E/#4, F/#5, G/#6, H/#7, I/#8, J/#9)":["sample"],"(A/#0, B/#1, C/#2, D/#3, E/#4, F/#5, G/#6, H/#7, I/#8, J/#9, K/#10)":["sample"],"(A/#0, B/#1, C/#2, D/#3, E/#4, F/#5, G/#6, H/#7, I/#8, J/#9, K/#10, L/#11)":["sample"],"(A/#0,)":["sample"],"(u32, u8)":["calculate_bound_u32","inner"],"(usize, core::option::Option<usize>)":["size_hint"],"Alias(Projection, AliasTy { args: [Self/#0, RHS/#1], def_id: DefId(0:186 ~ rand[6311]::distr::utils::WideningMultiply::Output) })":["wmul"],"Alias(Projection, AliasTy { args: [Self/#0], def_id: DefId(0:195 ~ rand[6311]::distr::utils::FloatSIMDUtils::Mask) })":["gt_mask"],"Alias(Projection, AliasTy { args: [Self/#0], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [Self/#0], def_id: DefId(0:87 ~ rand[6311]::distr::float::IntoFloat::F) })":["into_float_with_exponent"],"Alias(Projection, AliasTy { args: [distr::uniform::float::UniformFloat<f32>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::float::UniformFloat<f64>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::int::UniformInt<i128>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::int::UniformInt<i16>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::int::UniformInt<i32>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::int::UniformInt<i64>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::int::UniformInt<i8>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::int::UniformInt<u128>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::int::UniformInt<u16>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::int::UniformInt<u32>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::int::UniformInt<u64>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::int::UniformInt<u8>], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [distr::uniform::other::UniformChar], def_id: DefId(0:365 ~ rand[6311]::distr::uniform::UniformSampler::X) })":["sample"],"Alias(Projection, AliasTy { args: [f32], def_id: DefId(0:195 ~ rand[6311]::distr::utils::FloatSIMDUtils::Mask) })":["gt_mask"],"Alias(Projection, AliasTy { args: [f64], def_id: DefId(0:195 ~ rand[6311]::distr::utils::FloatSIMDUtils::Mask) })":["gt_mask"],"Alias(Projection, AliasTy { args: [u128, u128], def_id: DefId(0:186 ~ rand[6311]::distr::utils::WideningMultiply::Output) })":["wmul"],"Alias(Projection, AliasTy { args: [u16, u16], def_id: DefId(0:186 ~ rand[6311]::distr::utils::WideningMultiply::Output) })":["wmul"],"Alias(Projection, AliasTy { args: [u32, u32], def_id: DefId(0:186 ~ rand[6311]::distr::utils::WideningMultiply::Output) })":["wmul"],"Alias(Projection, AliasTy { args: [u64, u64], def_id: DefId(0:186 ~ rand[6311]::distr::utils::WideningMultiply::Output) })":["wmul"],"Alias(Projection, AliasTy { args: [u8, u8], def_id: DefId(0:186 ~ rand[6311]::distr::utils::WideningMultiply::Output) })":["wmul"],"Alias(Projection, AliasTy { args: [usize, usize], def_id: DefId(0:186 ~ rand[6311]::distr::utils::WideningMultiply::Output) })":["wmul"],"[T/#0; N/#1]":["sample"],"alloc::rc::Rc":["__init"],"alloc::string::String":["sample_string"],"alloc::vec::Vec":["choose_multiple","into_vec"],"bool":["all_finite","all_le","all_lt","any","eq","flip_c_heads","gen_bool","gen_ratio","is_empty","random_bool","random_ratio","random_ratio_one_over","sample"],"char":["sample"],"core::arch::x86_64::__m128i":["sample"],"core::arch::x86_64::__m256i":["sample"],"core::cmp::Ordering":["cmp"],"core::num::NonZero":["num_choices","sample"],"core::num::Wrapping":["sample"],"core::option::Option":["choose","choose_multiple_array","choose_mut","choose_stable","next","partial_cmp","sample_array","weight"],"core::result::Result":["checked_add_assign","choose_multiple_weighted","choose_weighted","choose_weighted_mut","fmt","from_ratio","new","new_inclusive","reseed","sample_efraimidis_spirakis","sample_single","sample_single_inclusive","sample_weighted","try_from","update_weights"],"core::time::Duration":["sample"],"distr::StandardUniform":["clone","default"],"distr::bernoulli::Bernoulli":["clone"],"distr::bernoulli::BernoulliError":["clone"],"distr::distribution::Iter":["random_iter","sample_iter"],"distr::distribution::Map":["map"],"distr::float::Open01":["clone","default"],"distr::float::OpenClosed01":["clone","default"],"distr::other::Alphabetic":["clone","default"],"distr::other::Alphanumeric":["clone","default"],"distr::slice::Choose":["clone"],"distr::slice::Empty":["clone"],"distr::uniform::Error":["clone"],"distr::uniform::Uniform":["clone"],"distr::uniform::float::UniformFloat":["clone","new_bounded"],"distr::uniform::int::UniformInt":["clone"],"distr::uniform::int::UniformUsize":["clone"],"distr::uniform::other::UniformChar":["clone"],"distr::uniform::other::UniformDuration":["clone"],"distr::uniform::other::UniformDurationMode":["clone"],"distr::weighted::Error":["clone"],"distr::weighted::weighted_index::WeightedIndex":["clone"],"distr::weighted::weighted_index::WeightedIndexIter":["clone","weights"],"f32":["cast_from_int","into_float_with_exponent","sample"],"f64":["cast_from_int","into_float_with_exponent","p","sample"],"i128":["sample"],"i16":["sample"],"i32":["sample"],"i64":["sample"],"i8":["sample"],"rngs::mock::StepRng":["clone","new"],"rngs::reseeding::ReseedingCore":["clone"],"rngs::reseeding::ReseedingRng":["clone"],"rngs::small::SmallRng":["clone","from_seed","seed_from_u64"],"rngs::std::StdRng":["clone","from_seed"],"rngs::thread::ThreadRng":["clone","default","rng","thread_rng"],"rngs::xoshiro256plusplus::Xoshiro256PlusPlus":["clone","from_seed","seed_from_u64"],"seq::coin_flipper::CoinFlipper":["new"],"seq::increasing_uniform::IncreasingUniform":["new"],"seq::index_::IndexVec":["clone","from","sample","sample_floyd","sample_inplace","sample_rejection"],"seq::index_::IndexVecIntoIter":["clone","into_iter"],"seq::index_::IndexVecIter":["iter"],"seq::slice::SliceChooseIter":["choose_multiple"],"u128":["sample"],"u16":["sample"],"u32":["char_to_comp_u32","next_u32","one","sample","zero"],"u64":["next_u64","one","sample","zero"],"u8":["sample"],"usize":["as_usize","choose_multiple_fill","len","next_index","sample"]},"struct_to_trait":{"<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed":["distr::uniform::SampleBorrow"],"<I as seq::iterator::IteratorRandom>::I":["seq::iterator::IteratorRandom"],"<IR as seq::slice::IndexedMutRandom>::IR":["seq::slice::IndexedMutRandom"],"<R as rng::Rng>::R":["rng::Rng"],"core::ops::Range":["distr::uniform::SampleRange"],"core::ops::RangeInclusive":["distr::uniform::SampleRange"],"core::ops::RangeTo":["distr::uniform::SampleRange"],"core::ops::RangeToInclusive":["distr::uniform::SampleRange"],"core::time::Duration":["distr::uniform::SampleUniform"],"distr::StandardUniform":["core::clone::Clone","core::default::Default","core::fmt::Debug","core::marker::Copy","distr::distribution::Distribution","distr::distribution::SampleString"],"distr::bernoulli::Bernoulli":["core::clone::Clone","core::cmp::PartialEq","core::fmt::Debug","core::marker::Copy","core::marker::StructuralPartialEq","distr::distribution::Distribution"],"distr::bernoulli::BernoulliError":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::error::Error","core::fmt::Debug","core::fmt::Display","core::marker::Copy","core::marker::StructuralPartialEq"],"distr::distribution::Iter":["core::fmt::Debug","core::iter::FusedIterator","core::iter::Iterator"],"distr::distribution::Map":["core::fmt::Debug","distr::distribution::Distribution"],"distr::float::Open01":["core::clone::Clone","core::default::Default","core::fmt::Debug","core::marker::Copy","distr::distribution::Distribution"],"distr::float::OpenClosed01":["core::clone::Clone","core::default::Default","core::fmt::Debug","core::marker::Copy","distr::distribution::Distribution"],"distr::other::Alphabetic":["core::clone::Clone","core::default::Default","core::fmt::Debug","core::marker::Copy","distr::distribution::Distribution","distr::distribution::SampleString"],"distr::other::Alphanumeric":["core::clone::Clone","core::default::Default","core::fmt::Debug","core::marker::Copy","distr::distribution::Distribution","distr::distribution::SampleString"],"distr::slice::Choose":["core::clone::Clone","core::fmt::Debug","core::marker::Copy","distr::distribution::Distribution","distr::distribution::SampleString"],"distr::slice::Empty":["core::clone::Clone","core::error::Error","core::fmt::Debug","core::fmt::Display","core::marker::Copy"],"distr::uniform::Error":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::error::Error","core::fmt::Debug","core::fmt::Display","core::marker::Copy","core::marker::StructuralPartialEq"],"distr::uniform::Uniform":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::convert::TryFrom","core::fmt::Debug","core::marker::Copy","core::marker::StructuralPartialEq","distr::distribution::Distribution","distr::distribution::SampleString"],"distr::uniform::float::UniformFloat":["core::clone::Clone","core::cmp::PartialEq","core::fmt::Debug","core::marker::Copy","core::marker::StructuralPartialEq","distr::uniform::UniformSampler"],"distr::uniform::int::UniformInt":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::Copy","core::marker::StructuralPartialEq","distr::uniform::UniformSampler"],"distr::uniform::int::UniformUsize":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::Copy","core::marker::StructuralPartialEq","distr::uniform::UniformSampler"],"distr::uniform::other::UniformChar":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::Copy","core::marker::StructuralPartialEq","distr::uniform::UniformSampler"],"distr::uniform::other::UniformDuration":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::Copy","core::marker::StructuralPartialEq","distr::uniform::UniformSampler"],"distr::uniform::other::UniformDurationMode":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::Copy","core::marker::StructuralPartialEq"],"distr::weighted::Error":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::error::Error","core::fmt::Debug","core::fmt::Display","core::marker::Copy","core::marker::StructuralPartialEq"],"distr::weighted::weighted_index::WeightedIndex":["core::clone::Clone","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralPartialEq","distr::distribution::Distribution"],"distr::weighted::weighted_index::WeightedIndexIter":["core::clone::Clone","core::fmt::Debug","core::iter::Iterator"],"rngs::mock::StepRng":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralPartialEq","rand_core::RngCore"],"rngs::reseeding::ReseedingCore":["core::clone::Clone","core::fmt::Debug","rand_core::block::BlockRngCore","rand_core::block::CryptoBlockRng"],"rngs::reseeding::ReseedingRng":["core::clone::Clone","core::fmt::Debug","rand_core::CryptoRng","rand_core::RngCore"],"rngs::small::SmallRng":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralPartialEq","rand_core::RngCore","rand_core::SeedableRng"],"rngs::std::StdRng":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralPartialEq","rand_core::CryptoRng","rand_core::RngCore","rand_core::SeedableRng"],"rngs::thread::ThreadRng":["core::clone::Clone","core::default::Default","core::fmt::Debug","rand_core::CryptoRng","rand_core::RngCore"],"rngs::xoshiro256plusplus::Xoshiro256PlusPlus":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralPartialEq","rand_core::RngCore","rand_core::SeedableRng"],"seq::index_::IndexVec":["core::clone::Clone","core::cmp::PartialEq","core::convert::From","core::fmt::Debug","core::iter::IntoIterator"],"seq::index_::IndexVecIntoIter":["core::clone::Clone","core::fmt::Debug","core::iter::ExactSizeIterator","core::iter::Iterator"],"seq::index_::IndexVecIter":["core::fmt::Debug","core::iter::ExactSizeIterator","core::iter::Iterator"],"seq::index_::sample_efraimidis_spirakis::Element":["core::cmp::Eq","core::cmp::Ord","core::cmp::PartialEq","core::cmp::PartialOrd"],"seq::slice::SliceChooseIter":["core::fmt::Debug","core::iter::ExactSizeIterator","core::iter::Iterator"]},"targets":{"<&Borrowed as distr::uniform::SampleBorrow<Borrowed>>::borrow":["borrow","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleBorrow"],"<&D as distr::distribution::Distribution<T>>::sample":["sample","Real(LocalPath(\"src/distr/distribution.rs\"))","distr::distribution::Distribution"],"<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::borrow":["borrow","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleBorrow"],"<[T; N] as rng::Fill>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"<[T] as seq::slice::IndexedRandom>::len":["len","Real(LocalPath(\"src/seq/slice.rs\"))","seq::slice::IndexedRandom"],"<[T] as seq::slice::SliceRandom>::partial_shuffle":["partial_shuffle","Real(LocalPath(\"src/seq/slice.rs\"))","seq::slice::SliceRandom"],"<[T] as seq::slice::SliceRandom>::shuffle":["shuffle","Real(LocalPath(\"src/seq/slice.rs\"))","seq::slice::SliceRandom"],"<[bool] as rng::Fill>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"<[char] as rng::Fill>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"<[f32] as rng::Fill>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"<[f64] as rng::Fill>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"<[u8] as rng::Fill>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"<bool as distr::utils::BoolAsSIMD>::any":["any","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::BoolAsSIMD"],"<core::ops::Range<T> as distr::uniform::SampleRange<T>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::Range<T> as distr::uniform::SampleRange<T>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeInclusive<T> as distr::uniform::SampleRange<T>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeInclusive<T> as distr::uniform::SampleRange<T>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<u128> as distr::uniform::SampleRange<u128>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<u128> as distr::uniform::SampleRange<u128>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<u16> as distr::uniform::SampleRange<u16>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<u16> as distr::uniform::SampleRange<u16>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<u32> as distr::uniform::SampleRange<u32>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<u32> as distr::uniform::SampleRange<u32>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<u64> as distr::uniform::SampleRange<u64>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<u64> as distr::uniform::SampleRange<u64>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<u8> as distr::uniform::SampleRange<u8>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<u8> as distr::uniform::SampleRange<u8>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<usize> as distr::uniform::SampleRange<usize>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeTo<usize> as distr::uniform::SampleRange<usize>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<u128> as distr::uniform::SampleRange<u128>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<u128> as distr::uniform::SampleRange<u128>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<u16> as distr::uniform::SampleRange<u16>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<u16> as distr::uniform::SampleRange<u16>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<u32> as distr::uniform::SampleRange<u32>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<u32> as distr::uniform::SampleRange<u32>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<u64> as distr::uniform::SampleRange<u64>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<u64> as distr::uniform::SampleRange<u64>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<u8> as distr::uniform::SampleRange<u8>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<u8> as distr::uniform::SampleRange<u8>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<usize> as distr::uniform::SampleRange<usize>>::is_empty":["is_empty","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<core::ops::RangeToInclusive<usize> as distr::uniform::SampleRange<usize>>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::uniform::SampleRange"],"<distr::bernoulli::Bernoulli as distr::distribution::Distribution<bool>>::sample":["sample","Real(LocalPath(\"src/distr/bernoulli.rs\"))","distr::distribution::Distribution"],"<distr::bernoulli::BernoulliError as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/distr/bernoulli.rs\"))","core::fmt::Display"],"<distr::distribution::Iter<D, R, T> as core::iter::Iterator>::next":["next","Real(LocalPath(\"src/distr/distribution.rs\"))","core::iter::Iterator"],"<distr::distribution::Iter<D, R, T> as core::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/distr/distribution.rs\"))","core::iter::Iterator"],"<distr::distribution::Map<D, F, T, S> as distr::distribution::Distribution<S>>::sample":["sample","Real(LocalPath(\"src/distr/distribution.rs\"))","distr::distribution::Distribution"],"<distr::float::Open01 as distr::distribution::Distribution<f32>>::sample":["sample","Real(LocalPath(\"src/distr/float.rs\"))","distr::distribution::Distribution"],"<distr::float::Open01 as distr::distribution::Distribution<f64>>::sample":["sample","Real(LocalPath(\"src/distr/float.rs\"))","distr::distribution::Distribution"],"<distr::float::OpenClosed01 as distr::distribution::Distribution<f32>>::sample":["sample","Real(LocalPath(\"src/distr/float.rs\"))","distr::distribution::Distribution"],"<distr::float::OpenClosed01 as distr::distribution::Distribution<f64>>::sample":["sample","Real(LocalPath(\"src/distr/float.rs\"))","distr::distribution::Distribution"],"<distr::other::Alphabetic as distr::distribution::Distribution<u8>>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"<distr::other::Alphabetic as distr::distribution::SampleString>::append_string":["append_string","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::SampleString"],"<distr::other::Alphanumeric as distr::distribution::Distribution<u8>>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"<distr::other::Alphanumeric as distr::distribution::SampleString>::append_string":["append_string","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::SampleString"],"<distr::slice::Choose<'_, char> as distr::distribution::SampleString>::append_string":["append_string","Real(LocalPath(\"src/distr/slice.rs\"))","distr::distribution::SampleString"],"<distr::slice::Choose<'a, T> as distr::distribution::Distribution<&'a T>>::sample":["sample","Real(LocalPath(\"src/distr/slice.rs\"))","distr::distribution::Distribution"],"<distr::slice::Empty as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/distr/slice.rs\"))","core::fmt::Display"],"<distr::uniform::Error as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/distr/uniform.rs\"))","core::fmt::Display"],"<distr::uniform::Uniform<X> as core::convert::TryFrom<core::ops::Range<X>>>::try_from":["try_from","Real(LocalPath(\"src/distr/uniform.rs\"))","core::convert::TryFrom"],"<distr::uniform::Uniform<X> as core::convert::TryFrom<core::ops::RangeInclusive<X>>>::try_from":["try_from","Real(LocalPath(\"src/distr/uniform.rs\"))","core::convert::TryFrom"],"<distr::uniform::Uniform<X> as distr::distribution::Distribution<X>>::sample":["sample","Real(LocalPath(\"src/distr/uniform.rs\"))","distr::distribution::Distribution"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_float.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_float.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_float.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_float.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::float::UniformFloat<f32> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_float.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_float.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_float.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_float.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_float.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::float::UniformFloat<f64> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_float.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i128> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i16> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i32> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i64> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<i8> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u128> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u16> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u32> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u64> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformInt<u8> as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::int::UniformUsize as distr::uniform::UniformSampler>::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform_int.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::other::UniformChar as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_other.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::other::UniformChar as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_other.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::other::UniformChar as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_other.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::other::UniformDuration as distr::uniform::UniformSampler>::new":["new","Real(LocalPath(\"src/distr/uniform_other.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::other::UniformDuration as distr::uniform::UniformSampler>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform_other.rs\"))","distr::uniform::UniformSampler"],"<distr::uniform::other::UniformDuration as distr::uniform::UniformSampler>::sample":["sample","Real(LocalPath(\"src/distr/uniform_other.rs\"))","distr::uniform::UniformSampler"],"<distr::weighted::Error as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","core::fmt::Display"],"<distr::weighted::weighted_index::WeightedIndex<X> as distr::distribution::Distribution<usize>>::sample":["sample","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))","distr::distribution::Distribution"],"<distr::weighted::weighted_index::WeightedIndexIter<'_, X> as core::clone::Clone>::clone":["clone","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))","core::clone::Clone"],"<distr::weighted::weighted_index::WeightedIndexIter<'_, X> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))","core::fmt::Debug"],"<distr::weighted::weighted_index::WeightedIndexIter<'_, X> as core::iter::Iterator>::next":["next","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))","core::iter::Iterator"],"<f32 as distr::utils::FloatSIMDUtils>::all_finite":["all_finite","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f32 as distr::utils::FloatSIMDUtils>::all_le":["all_le","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f32 as distr::utils::FloatSIMDUtils>::all_lt":["all_lt","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f32 as distr::utils::FloatSIMDUtils>::cast_from_int":["cast_from_int","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f32 as distr::utils::FloatSIMDUtils>::decrease_masked":["decrease_masked","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f32 as distr::utils::FloatSIMDUtils>::gt_mask":["gt_mask","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f32 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<f64 as distr::utils::FloatSIMDUtils>::all_finite":["all_finite","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f64 as distr::utils::FloatSIMDUtils>::all_le":["all_le","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f64 as distr::utils::FloatSIMDUtils>::all_lt":["all_lt","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f64 as distr::utils::FloatSIMDUtils>::cast_from_int":["cast_from_int","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f64 as distr::utils::FloatSIMDUtils>::decrease_masked":["decrease_masked","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f64 as distr::utils::FloatSIMDUtils>::gt_mask":["gt_mask","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::FloatSIMDUtils"],"<f64 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<i128 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<i16 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<i32 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<i64 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<i8 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<isize as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<rngs::mock::StepRng as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"src/rngs/mock.rs\"))","rand_core::RngCore"],"<rngs::mock::StepRng as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"src/rngs/mock.rs\"))","rand_core::RngCore"],"<rngs::mock::StepRng as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"src/rngs/mock.rs\"))","rand_core::RngCore"],"<rngs::reseeding::ReseedingCore<R, Rsdr> as core::clone::Clone>::clone":["clone","Real(LocalPath(\"src/rngs/reseeding.rs\"))","core::clone::Clone"],"<rngs::reseeding::ReseedingCore<R, Rsdr> as rand_core::block::BlockRngCore>::generate":["generate","Real(LocalPath(\"src/rngs/reseeding.rs\"))","rand_core::block::BlockRngCore"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as core::clone::Clone>::clone":["clone","Real(LocalPath(\"src/rngs/reseeding.rs\"))","core::clone::Clone"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"src/rngs/reseeding.rs\"))","rand_core::RngCore"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"src/rngs/reseeding.rs\"))","rand_core::RngCore"],"<rngs::reseeding::ReseedingRng<R, Rsdr> as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"src/rngs/reseeding.rs\"))","rand_core::RngCore"],"<rngs::small::SmallRng as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"src/rngs/small.rs\"))","rand_core::RngCore"],"<rngs::small::SmallRng as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"src/rngs/small.rs\"))","rand_core::RngCore"],"<rngs::small::SmallRng as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"src/rngs/small.rs\"))","rand_core::RngCore"],"<rngs::small::SmallRng as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"src/rngs/small.rs\"))","rand_core::SeedableRng"],"<rngs::small::SmallRng as rand_core::SeedableRng>::seed_from_u64":["seed_from_u64","Real(LocalPath(\"src/rngs/small.rs\"))","rand_core::SeedableRng"],"<rngs::std::StdRng as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"src/rngs/std.rs\"))","rand_core::RngCore"],"<rngs::std::StdRng as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"src/rngs/std.rs\"))","rand_core::RngCore"],"<rngs::std::StdRng as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"src/rngs/std.rs\"))","rand_core::RngCore"],"<rngs::std::StdRng as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"src/rngs/std.rs\"))","rand_core::SeedableRng"],"<rngs::thread::ThreadRng as core::default::Default>::default":["default","Real(LocalPath(\"src/rngs/thread.rs\"))","core::default::Default"],"<rngs::thread::ThreadRng as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/rngs/thread.rs\"))","core::fmt::Debug"],"<rngs::thread::ThreadRng as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"src/rngs/thread.rs\"))","rand_core::RngCore"],"<rngs::thread::ThreadRng as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"src/rngs/thread.rs\"))","rand_core::RngCore"],"<rngs::thread::ThreadRng as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"src/rngs/thread.rs\"))","rand_core::RngCore"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))","rand_core::RngCore"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))","rand_core::RngCore"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))","rand_core::RngCore"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))","rand_core::SeedableRng"],"<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::SeedableRng>::seed_from_u64":["seed_from_u64","Real(LocalPath(\"src/rngs/xoshiro256plusplus.rs\"))","rand_core::SeedableRng"],"<seq::index_::IndexVec as core::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/seq/index.rs\"))","core::cmp::PartialEq"],"<seq::index_::IndexVec as core::convert::From<alloc::vec::Vec<u32>>>::from":["from","Real(LocalPath(\"src/seq/index.rs\"))","core::convert::From"],"<seq::index_::IndexVec as core::convert::From<alloc::vec::Vec<u64>>>::from":["from","Real(LocalPath(\"src/seq/index.rs\"))","core::convert::From"],"<seq::index_::IndexVec as core::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/seq/index.rs\"))","core::iter::IntoIterator"],"<seq::index_::IndexVecIntoIter as core::iter::Iterator>::next":["next","Real(LocalPath(\"src/seq/index.rs\"))","core::iter::Iterator"],"<seq::index_::IndexVecIntoIter as core::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/seq/index.rs\"))","core::iter::Iterator"],"<seq::index_::IndexVecIter<'_> as core::iter::Iterator>::next":["next","Real(LocalPath(\"src/seq/index.rs\"))","core::iter::Iterator"],"<seq::index_::IndexVecIter<'_> as core::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/seq/index.rs\"))","core::iter::Iterator"],"<seq::index_::sample_efraimidis_spirakis::Element<N> as core::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/seq/index.rs\"))","core::cmp::Ord"],"<seq::index_::sample_efraimidis_spirakis::Element<N> as core::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/seq/index.rs\"))","core::cmp::PartialEq"],"<seq::index_::sample_efraimidis_spirakis::Element<N> as core::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/seq/index.rs\"))","core::cmp::PartialOrd"],"<seq::slice::SliceChooseIter<'a, S, T> as core::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/seq/slice.rs\"))","core::iter::ExactSizeIterator"],"<seq::slice::SliceChooseIter<'a, S, T> as core::iter::Iterator>::next":["next","Real(LocalPath(\"src/seq/slice.rs\"))","core::iter::Iterator"],"<seq::slice::SliceChooseIter<'a, S, T> as core::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/seq/slice.rs\"))","core::iter::Iterator"],"<u128 as distr::utils::WideningMultiply>::wmul":["wmul","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::WideningMultiply"],"<u128 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<u16 as distr::utils::WideningMultiply>::wmul":["wmul","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::WideningMultiply"],"<u16 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<u32 as distr::float::IntoFloat>::into_float_with_exponent":["into_float_with_exponent","Real(LocalPath(\"src/distr/float.rs\"))","distr::float::IntoFloat"],"<u32 as distr::utils::WideningMultiply>::wmul":["wmul","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::WideningMultiply"],"<u32 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<u32 as seq::index_::UInt>::as_usize":["as_usize","Real(LocalPath(\"src/seq/index.rs\"))","seq::index_::UInt"],"<u32 as seq::index_::UInt>::one":["one","Real(LocalPath(\"src/seq/index.rs\"))","seq::index_::UInt"],"<u32 as seq::index_::UInt>::zero":["zero","Real(LocalPath(\"src/seq/index.rs\"))","seq::index_::UInt"],"<u64 as distr::float::IntoFloat>::into_float_with_exponent":["into_float_with_exponent","Real(LocalPath(\"src/distr/float.rs\"))","distr::float::IntoFloat"],"<u64 as distr::utils::WideningMultiply>::wmul":["wmul","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::WideningMultiply"],"<u64 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<u64 as seq::index_::UInt>::as_usize":["as_usize","Real(LocalPath(\"src/seq/index.rs\"))","seq::index_::UInt"],"<u64 as seq::index_::UInt>::one":["one","Real(LocalPath(\"src/seq/index.rs\"))","seq::index_::UInt"],"<u64 as seq::index_::UInt>::zero":["zero","Real(LocalPath(\"src/seq/index.rs\"))","seq::index_::UInt"],"<u8 as distr::utils::WideningMultiply>::wmul":["wmul","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::WideningMultiply"],"<u8 as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"<usize as distr::utils::WideningMultiply>::wmul":["wmul","Real(LocalPath(\"src/distr/utils.rs\"))","distr::utils::WideningMultiply"],"<usize as distr::weighted::Weight>::checked_add_assign":["checked_add_assign","Real(LocalPath(\"src/distr/weighted/mod.rs\"))","distr::weighted::Weight"],"distr::bernoulli::Bernoulli::from_ratio":["from_ratio","Real(LocalPath(\"src/distr/bernoulli.rs\"))",""],"distr::bernoulli::Bernoulli::new":["new","Real(LocalPath(\"src/distr/bernoulli.rs\"))",""],"distr::bernoulli::Bernoulli::p":["p","Real(LocalPath(\"src/distr/bernoulli.rs\"))",""],"distr::distribution::Distribution::map":["map","Real(LocalPath(\"src/distr/distribution.rs\"))",""],"distr::distribution::Distribution::sample_iter":["sample_iter","Real(LocalPath(\"src/distr/distribution.rs\"))",""],"distr::distribution::SampleString::sample_string":["sample_string","Real(LocalPath(\"src/distr/distribution.rs\"))",""],"distr::float::<impl distr::distribution::Distribution<f32> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/float.rs\"))","distr::distribution::Distribution"],"distr::float::<impl distr::distribution::Distribution<f64> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/float.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::arch::x86_64::__m128i> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::arch::x86_64::__m256i> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i128>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i16>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i32>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i64>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<i8>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u128>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u16>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u32>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u64>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<core::num::NonZero<u8>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<i128> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<i16> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<i32> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<i64> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<i8> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<u128> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<u16> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<u32> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<u64> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::integer::<impl distr::distribution::Distribution<u8> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/integer.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<()> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B, C)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I, J)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I, J, K)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A, B, C, D, E, F, G, H, I, J, K, L)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<(A,)> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<[T; N]> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<bool> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<char> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::Distribution<core::num::Wrapping<T>> for distr::StandardUniform>::sample":["sample","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::Distribution"],"distr::other::<impl distr::distribution::SampleString for distr::StandardUniform>::append_string":["append_string","Real(LocalPath(\"src/distr/other.rs\"))","distr::distribution::SampleString"],"distr::slice::Choose::<'a, T>::new":["new","Real(LocalPath(\"src/distr/slice.rs\"))",""],"distr::slice::Choose::<'a, T>::num_choices":["num_choices","Real(LocalPath(\"src/distr/slice.rs\"))",""],"distr::uniform::Uniform::<X>::new":["new","Real(LocalPath(\"src/distr/uniform.rs\"))",""],"distr::uniform::Uniform::<X>::new_inclusive":["new_inclusive","Real(LocalPath(\"src/distr/uniform.rs\"))",""],"distr::uniform::UniformSampler::sample_single":["sample_single","Real(LocalPath(\"src/distr/uniform.rs\"))",""],"distr::uniform::UniformSampler::sample_single_inclusive":["sample_single_inclusive","Real(LocalPath(\"src/distr/uniform.rs\"))",""],"distr::uniform::float::UniformFloat::<f32>::new_bounded":["new_bounded","Real(LocalPath(\"src/distr/uniform_float.rs\"))",""],"distr::uniform::float::UniformFloat::<f64>::new_bounded":["new_bounded","Real(LocalPath(\"src/distr/uniform_float.rs\"))",""],"distr::uniform::other::<impl distr::distribution::SampleString for distr::uniform::Uniform<char>>::append_string":["append_string","Real(LocalPath(\"src/distr/uniform_other.rs\"))","distr::distribution::SampleString"],"distr::uniform::other::char_to_comp_u32":["char_to_comp_u32","Real(LocalPath(\"src/distr/uniform_other.rs\"))",""],"distr::utils::FloatAsSIMD::splat":["splat","Real(LocalPath(\"src/distr/utils.rs\"))",""],"distr::utils::IntAsSIMD::splat":["splat","Real(LocalPath(\"src/distr/utils.rs\"))",""],"distr::weighted::weighted_index::WeightedIndex::<X>::new":["new","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))",""],"distr::weighted::weighted_index::WeightedIndex::<X>::total_weight":["total_weight","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))",""],"distr::weighted::weighted_index::WeightedIndex::<X>::update_weights":["update_weights","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))",""],"distr::weighted::weighted_index::WeightedIndex::<X>::weight":["weight","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))",""],"distr::weighted::weighted_index::WeightedIndex::<X>::weights":["weights","Real(LocalPath(\"src/distr/weighted/weighted_index.rs\"))",""],"fill":["fill","Real(LocalPath(\"src/lib.rs\"))",""],"random":["random","Real(LocalPath(\"src/lib.rs\"))",""],"random_bool":["random_bool","Real(LocalPath(\"src/lib.rs\"))",""],"random_iter":["random_iter","Real(LocalPath(\"src/lib.rs\"))",""],"random_range":["random_range","Real(LocalPath(\"src/lib.rs\"))",""],"random_ratio":["random_ratio","Real(LocalPath(\"src/lib.rs\"))",""],"rng::Rng::fill":["fill","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::gen":["gen","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::gen_bool":["gen_bool","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::gen_range":["gen_range","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::gen_ratio":["gen_ratio","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::random":["random","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::random_bool":["random_bool","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::random_iter":["random_iter","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::random_range":["random_range","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::random_ratio":["random_ratio","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::sample":["sample","Real(LocalPath(\"src/rng.rs\"))",""],"rng::Rng::sample_iter":["sample_iter","Real(LocalPath(\"src/rng.rs\"))",""],"rng::_::<impl rng::Fill for [core::num::Wrapping<i128>]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i16>]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i32>]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i64>]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [core::num::Wrapping<i8>]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u128>]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u16>]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u32>]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [core::num::Wrapping<u64>]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [i128]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [i16]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [i32]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [i64]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [i8]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [u128]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [u16]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [u32]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::_::<impl rng::Fill for [u64]>::fill":["fill","Real(LocalPath(\"src/rng.rs\"))","rng::Fill"],"rng::__unsafe":["__unsafe","Real(LocalPath(\"src/rng.rs\"))",""],"rngs::mock::StepRng::new":["new","Real(LocalPath(\"src/rngs/mock.rs\"))",""],"rngs::reseeding::ReseedingCore::<R, Rsdr>::new":["new","Real(LocalPath(\"src/rngs/reseeding.rs\"))",""],"rngs::reseeding::ReseedingCore::<R, Rsdr>::reseed":["reseed","Real(LocalPath(\"src/rngs/reseeding.rs\"))",""],"rngs::reseeding::ReseedingCore::<R, Rsdr>::reseed_and_generate":["reseed_and_generate","Real(LocalPath(\"src/rngs/reseeding.rs\"))",""],"rngs::reseeding::ReseedingRng::<R, Rsdr>::new":["new","Real(LocalPath(\"src/rngs/reseeding.rs\"))",""],"rngs::reseeding::ReseedingRng::<R, Rsdr>::reseed":["reseed","Real(LocalPath(\"src/rngs/reseeding.rs\"))",""],"rngs::thread::THREAD_RNG_KEY::__init":["__init","Real(Remapped { local_path: Some(\"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/native/mod.rs\"), virtual_name: \"/rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/sys/thread_local/native/mod.rs\" })",""],"rngs::thread::ThreadRng::reseed":["reseed","Real(LocalPath(\"src/rngs/thread.rs\"))",""],"rngs::thread::rng":["rng","Real(LocalPath(\"src/rngs/thread.rs\"))",""],"seq::coin_flipper::CoinFlipper::<R>::flip_c_heads":["flip_c_heads","Real(LocalPath(\"src/seq/coin_flipper.rs\"))",""],"seq::coin_flipper::CoinFlipper::<R>::new":["new","Real(LocalPath(\"src/seq/coin_flipper.rs\"))",""],"seq::coin_flipper::CoinFlipper::<R>::random_ratio":["random_ratio","Real(LocalPath(\"src/seq/coin_flipper.rs\"))",""],"seq::coin_flipper::CoinFlipper::<R>::random_ratio_one_over":["random_ratio_one_over","Real(LocalPath(\"src/seq/coin_flipper.rs\"))",""],"seq::increasing_uniform::IncreasingUniform::<R>::new":["new","Real(LocalPath(\"src/seq/increasing_uniform.rs\"))",""],"seq::increasing_uniform::IncreasingUniform::<R>::next_index":["next_index","Real(LocalPath(\"src/seq/increasing_uniform.rs\"))",""],"seq::increasing_uniform::calculate_bound_u32":["calculate_bound_u32","Real(LocalPath(\"src/seq/increasing_uniform.rs\"))",""],"seq::increasing_uniform::calculate_bound_u32::inner":["inner","Real(LocalPath(\"src/seq/increasing_uniform.rs\"))",""],"seq::index::sample_array":["sample_array","Real(LocalPath(\"src/seq/mod.rs\"))",""],"seq::index_::IndexVec::index":["index","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::index_::IndexVec::into_vec":["into_vec","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::index_::IndexVec::is_empty":["is_empty","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::index_::IndexVec::iter":["iter","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::index_::IndexVec::len":["len","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::index_::sample":["sample","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::index_::sample_efraimidis_spirakis":["sample_efraimidis_spirakis","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::index_::sample_floyd":["sample_floyd","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::index_::sample_inplace":["sample_inplace","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::index_::sample_rejection":["sample_rejection","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::index_::sample_weighted":["sample_weighted","Real(LocalPath(\"src/seq/index.rs\"))",""],"seq::iterator::IteratorRandom::choose":["choose","Real(LocalPath(\"src/seq/iterator.rs\"))",""],"seq::iterator::IteratorRandom::choose_multiple":["choose_multiple","Real(LocalPath(\"src/seq/iterator.rs\"))",""],"seq::iterator::IteratorRandom::choose_multiple_fill":["choose_multiple_fill","Real(LocalPath(\"src/seq/iterator.rs\"))",""],"seq::iterator::IteratorRandom::choose_stable":["choose_stable","Real(LocalPath(\"src/seq/iterator.rs\"))",""],"seq::slice::IndexedMutRandom::choose_mut":["choose_mut","Real(LocalPath(\"src/seq/slice.rs\"))",""],"seq::slice::IndexedMutRandom::choose_weighted_mut":["choose_weighted_mut","Real(LocalPath(\"src/seq/slice.rs\"))",""],"seq::slice::IndexedRandom::choose":["choose","Real(LocalPath(\"src/seq/slice.rs\"))",""],"seq::slice::IndexedRandom::choose_multiple":["choose_multiple","Real(LocalPath(\"src/seq/slice.rs\"))",""],"seq::slice::IndexedRandom::choose_multiple_array":["choose_multiple_array","Real(LocalPath(\"src/seq/slice.rs\"))",""],"seq::slice::IndexedRandom::choose_multiple_weighted":["choose_multiple_weighted","Real(LocalPath(\"src/seq/slice.rs\"))",""],"seq::slice::IndexedRandom::choose_weighted":["choose_weighted","Real(LocalPath(\"src/seq/slice.rs\"))",""],"seq::slice::IndexedRandom::is_empty":["is_empty","Real(LocalPath(\"src/seq/slice.rs\"))",""],"thread_rng":["thread_rng","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["distr::StandardUniform","distr::bernoulli::Bernoulli","distr::bernoulli::BernoulliError","distr::float::Open01","distr::float::OpenClosed01","distr::other::Alphabetic","distr::other::Alphanumeric","distr::slice::Choose","distr::slice::Empty","distr::uniform::Error","distr::uniform::Uniform","distr::uniform::float::UniformFloat","distr::uniform::int::UniformInt","distr::uniform::int::UniformUsize","distr::uniform::other::UniformChar","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode","distr::weighted::Error","distr::weighted::weighted_index::WeightedIndex","distr::weighted::weighted_index::WeightedIndexIter","rngs::mock::StepRng","rngs::reseeding::ReseedingCore","rngs::reseeding::ReseedingRng","rngs::small::SmallRng","rngs::std::StdRng","rngs::thread::ThreadRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus","seq::index_::IndexVec","seq::index_::IndexVecIntoIter"],"core::cmp::Eq":["distr::bernoulli::BernoulliError","distr::uniform::Error","distr::uniform::Uniform","distr::uniform::int::UniformInt","distr::uniform::int::UniformUsize","distr::uniform::other::UniformChar","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode","distr::weighted::Error","rngs::mock::StepRng","rngs::small::SmallRng","rngs::std::StdRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus","seq::index_::sample_efraimidis_spirakis::Element"],"core::cmp::Ord":["seq::index_::sample_efraimidis_spirakis::Element"],"core::cmp::PartialEq":["distr::bernoulli::Bernoulli","distr::bernoulli::BernoulliError","distr::uniform::Error","distr::uniform::Uniform","distr::uniform::float::UniformFloat","distr::uniform::int::UniformInt","distr::uniform::int::UniformUsize","distr::uniform::other::UniformChar","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode","distr::weighted::Error","distr::weighted::weighted_index::WeightedIndex","rngs::mock::StepRng","rngs::small::SmallRng","rngs::std::StdRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus","seq::index_::IndexVec","seq::index_::sample_efraimidis_spirakis::Element"],"core::cmp::PartialOrd":["seq::index_::sample_efraimidis_spirakis::Element"],"core::convert::From":["seq::index_::IndexVec"],"core::convert::TryFrom":["distr::uniform::Uniform"],"core::default::Default":["distr::StandardUniform","distr::float::Open01","distr::float::OpenClosed01","distr::other::Alphabetic","distr::other::Alphanumeric","rngs::thread::ThreadRng"],"core::error::Error":["distr::bernoulli::BernoulliError","distr::slice::Empty","distr::uniform::Error","distr::weighted::Error"],"core::fmt::Debug":["distr::StandardUniform","distr::bernoulli::Bernoulli","distr::bernoulli::BernoulliError","distr::distribution::Iter","distr::distribution::Map","distr::float::Open01","distr::float::OpenClosed01","distr::other::Alphabetic","distr::other::Alphanumeric","distr::slice::Choose","distr::slice::Empty","distr::uniform::Error","distr::uniform::Uniform","distr::uniform::float::UniformFloat","distr::uniform::int::UniformInt","distr::uniform::int::UniformUsize","distr::uniform::other::UniformChar","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode","distr::weighted::Error","distr::weighted::weighted_index::WeightedIndex","distr::weighted::weighted_index::WeightedIndexIter","rngs::mock::StepRng","rngs::reseeding::ReseedingCore","rngs::reseeding::ReseedingRng","rngs::small::SmallRng","rngs::std::StdRng","rngs::thread::ThreadRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus","seq::index_::IndexVec","seq::index_::IndexVecIntoIter","seq::index_::IndexVecIter","seq::slice::SliceChooseIter"],"core::fmt::Display":["distr::bernoulli::BernoulliError","distr::slice::Empty","distr::uniform::Error","distr::weighted::Error"],"core::iter::ExactSizeIterator":["seq::index_::IndexVecIntoIter","seq::index_::IndexVecIter","seq::slice::SliceChooseIter"],"core::iter::FusedIterator":["distr::distribution::Iter"],"core::iter::IntoIterator":["seq::index_::IndexVec"],"core::iter::Iterator":["distr::distribution::Iter","distr::weighted::weighted_index::WeightedIndexIter","seq::index_::IndexVecIntoIter","seq::index_::IndexVecIter","seq::slice::SliceChooseIter"],"core::marker::Copy":["distr::StandardUniform","distr::bernoulli::Bernoulli","distr::bernoulli::BernoulliError","distr::float::Open01","distr::float::OpenClosed01","distr::other::Alphabetic","distr::other::Alphanumeric","distr::slice::Choose","distr::slice::Empty","distr::uniform::Error","distr::uniform::Uniform","distr::uniform::float::UniformFloat","distr::uniform::int::UniformInt","distr::uniform::int::UniformUsize","distr::uniform::other::UniformChar","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode","distr::weighted::Error"],"core::marker::StructuralPartialEq":["distr::bernoulli::Bernoulli","distr::bernoulli::BernoulliError","distr::uniform::Error","distr::uniform::Uniform","distr::uniform::float::UniformFloat","distr::uniform::int::UniformInt","distr::uniform::int::UniformUsize","distr::uniform::other::UniformChar","distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode","distr::weighted::Error","distr::weighted::weighted_index::WeightedIndex","rngs::mock::StepRng","rngs::small::SmallRng","rngs::std::StdRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"distr::distribution::Distribution":["distr::StandardUniform","distr::bernoulli::Bernoulli","distr::distribution::Map","distr::float::Open01","distr::float::OpenClosed01","distr::other::Alphabetic","distr::other::Alphanumeric","distr::slice::Choose","distr::uniform::Uniform","distr::weighted::weighted_index::WeightedIndex"],"distr::distribution::SampleString":["distr::StandardUniform","distr::other::Alphabetic","distr::other::Alphanumeric","distr::slice::Choose","distr::uniform::Uniform"],"distr::uniform::SampleBorrow":["<Borrowed as distr::uniform::SampleBorrow<Borrowed>>::Borrowed"],"distr::uniform::SampleRange":["core::ops::Range","core::ops::RangeInclusive","core::ops::RangeTo","core::ops::RangeToInclusive"],"distr::uniform::SampleUniform":["core::time::Duration"],"distr::uniform::UniformSampler":["distr::uniform::float::UniformFloat","distr::uniform::int::UniformInt","distr::uniform::int::UniformUsize","distr::uniform::other::UniformChar","distr::uniform::other::UniformDuration"],"rand_core::CryptoRng":["rngs::reseeding::ReseedingRng","rngs::std::StdRng","rngs::thread::ThreadRng"],"rand_core::RngCore":["rngs::mock::StepRng","rngs::reseeding::ReseedingRng","rngs::small::SmallRng","rngs::std::StdRng","rngs::thread::ThreadRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"rand_core::SeedableRng":["rngs::small::SmallRng","rngs::std::StdRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus"],"rand_core::block::BlockRngCore":["rngs::reseeding::ReseedingCore"],"rand_core::block::CryptoBlockRng":["rngs::reseeding::ReseedingCore"],"rng::Rng":["<R as rng::Rng>::R"],"seq::iterator::IteratorRandom":["<I as seq::iterator::IteratorRandom>::I"],"seq::slice::IndexedMutRandom":["<IR as seq::slice::IndexedMutRandom>::IR"]},"type_to_def_path":{"distr::StandardUniform":"distr::StandardUniform","distr::bernoulli::Bernoulli":"distr::bernoulli::Bernoulli","distr::bernoulli::BernoulliError":"distr::bernoulli::BernoulliError","distr::distribution::Iter<D, R, T>":"distr::distribution::Iter","distr::distribution::Map<D, F, T, S>":"distr::distribution::Map","distr::float::Open01":"distr::float::Open01","distr::float::OpenClosed01":"distr::float::OpenClosed01","distr::other::Alphabetic":"distr::other::Alphabetic","distr::other::Alphanumeric":"distr::other::Alphanumeric","distr::slice::Choose<'a, T>":"distr::slice::Choose","distr::slice::Empty":"distr::slice::Empty","distr::uniform::Error":"distr::uniform::Error","distr::uniform::Uniform<X>":"distr::uniform::Uniform","distr::uniform::float::UniformFloat<X>":"distr::uniform::float::UniformFloat","distr::uniform::int::UniformInt<X>":"distr::uniform::int::UniformInt","distr::uniform::int::UniformUsize":"distr::uniform::int::UniformUsize","distr::uniform::other::UniformChar":"distr::uniform::other::UniformChar","distr::uniform::other::UniformDuration":"distr::uniform::other::UniformDuration","distr::uniform::other::UniformDurationMode":"distr::uniform::other::UniformDurationMode","distr::weighted::Error":"distr::weighted::Error","distr::weighted::weighted_index::WeightedIndex<X>":"distr::weighted::weighted_index::WeightedIndex","distr::weighted::weighted_index::WeightedIndexIter<'a, X>":"distr::weighted::weighted_index::WeightedIndexIter","rngs::mock::StepRng":"rngs::mock::StepRng","rngs::reseeding::ReseedingCore<R, Rsdr>":"rngs::reseeding::ReseedingCore","rngs::reseeding::ReseedingRng<R, Rsdr>":"rngs::reseeding::ReseedingRng","rngs::small::SmallRng":"rngs::small::SmallRng","rngs::std::StdRng":"rngs::std::StdRng","rngs::thread::ThreadRng":"rngs::thread::ThreadRng","rngs::xoshiro256plusplus::Xoshiro256PlusPlus":"rngs::xoshiro256plusplus::Xoshiro256PlusPlus","seq::coin_flipper::CoinFlipper<R>":"seq::coin_flipper::CoinFlipper","seq::increasing_uniform::IncreasingUniform<R>":"seq::increasing_uniform::IncreasingUniform","seq::index_::IndexVec":"seq::index_::IndexVec","seq::index_::IndexVecIntoIter":"seq::index_::IndexVecIntoIter","seq::index_::IndexVecIter<'a>":"seq::index_::IndexVecIter","seq::index_::sample_efraimidis_spirakis::Element<N>":"seq::index_::sample_efraimidis_spirakis::Element","seq::slice::SliceChooseIter<'a, S, T>":"seq::slice::SliceChooseIter"}}