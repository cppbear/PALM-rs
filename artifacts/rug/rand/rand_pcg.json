{"dependencies":{"<pcg128::Lcg128Xsl64 as core::clone::Clone>::clone":["pcg128::Lcg128Xsl64"],"<pcg128::Lcg128Xsl64 as core::cmp::Eq>::assert_receiver_is_total_eq":["pcg128::Lcg128Xsl64"],"<pcg128::Lcg128Xsl64 as core::cmp::PartialEq>::eq":["pcg128::Lcg128Xsl64"],"<pcg128::Lcg128Xsl64 as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","pcg128::Lcg128Xsl64"],"<pcg128::Lcg128Xsl64 as rand_core::RngCore>::fill_bytes":["pcg128::Lcg128Xsl64"],"<pcg128::Lcg128Xsl64 as rand_core::RngCore>::next_u32":["pcg128::Lcg128Xsl64"],"<pcg128::Lcg128Xsl64 as rand_core::RngCore>::next_u64":["pcg128::Lcg128Xsl64"],"<pcg128::Lcg128Xsl64 as rand_core::SeedableRng>::from_seed":["pcg128::Lcg128Xsl64"],"<pcg128::Mcg128Xsl64 as core::clone::Clone>::clone":["pcg128::Mcg128Xsl64"],"<pcg128::Mcg128Xsl64 as core::cmp::Eq>::assert_receiver_is_total_eq":["pcg128::Mcg128Xsl64"],"<pcg128::Mcg128Xsl64 as core::cmp::PartialEq>::eq":["pcg128::Mcg128Xsl64"],"<pcg128::Mcg128Xsl64 as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","pcg128::Mcg128Xsl64"],"<pcg128::Mcg128Xsl64 as rand_core::RngCore>::fill_bytes":["pcg128::Mcg128Xsl64"],"<pcg128::Mcg128Xsl64 as rand_core::RngCore>::next_u32":["pcg128::Mcg128Xsl64"],"<pcg128::Mcg128Xsl64 as rand_core::RngCore>::next_u64":["pcg128::Mcg128Xsl64"],"<pcg128::Mcg128Xsl64 as rand_core::SeedableRng>::from_seed":["pcg128::Mcg128Xsl64"],"<pcg128cm::Lcg128CmDxsm64 as core::clone::Clone>::clone":["pcg128cm::Lcg128CmDxsm64"],"<pcg128cm::Lcg128CmDxsm64 as core::cmp::Eq>::assert_receiver_is_total_eq":["pcg128cm::Lcg128CmDxsm64"],"<pcg128cm::Lcg128CmDxsm64 as core::cmp::PartialEq>::eq":["pcg128cm::Lcg128CmDxsm64"],"<pcg128cm::Lcg128CmDxsm64 as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","pcg128cm::Lcg128CmDxsm64"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::RngCore>::fill_bytes":["pcg128cm::Lcg128CmDxsm64"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::RngCore>::next_u32":["pcg128cm::Lcg128CmDxsm64"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::RngCore>::next_u64":["pcg128cm::Lcg128CmDxsm64"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::SeedableRng>::from_seed":["pcg128cm::Lcg128CmDxsm64"],"<pcg64::Lcg64Xsh32 as core::clone::Clone>::clone":["pcg64::Lcg64Xsh32"],"<pcg64::Lcg64Xsh32 as core::cmp::Eq>::assert_receiver_is_total_eq":["pcg64::Lcg64Xsh32"],"<pcg64::Lcg64Xsh32 as core::cmp::PartialEq>::eq":["pcg64::Lcg64Xsh32"],"<pcg64::Lcg64Xsh32 as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","pcg64::Lcg64Xsh32"],"<pcg64::Lcg64Xsh32 as rand_core::RngCore>::fill_bytes":["pcg64::Lcg64Xsh32"],"<pcg64::Lcg64Xsh32 as rand_core::RngCore>::next_u32":["pcg64::Lcg64Xsh32"],"<pcg64::Lcg64Xsh32 as rand_core::RngCore>::next_u64":["pcg64::Lcg64Xsh32"],"<pcg64::Lcg64Xsh32 as rand_core::SeedableRng>::from_seed":["pcg64::Lcg64Xsh32"],"pcg128::Lcg128Xsl64":["pcg128::Lcg128Xsl64"],"pcg128::Lcg128Xsl64::advance":["pcg128::Lcg128Xsl64"],"pcg128::Lcg128Xsl64::from_state_incr":["pcg128::Lcg128Xsl64"],"pcg128::Lcg128Xsl64::new":["pcg128::Lcg128Xsl64"],"pcg128::Lcg128Xsl64::step":["pcg128::Lcg128Xsl64"],"pcg128::Mcg128Xsl64":["pcg128::Mcg128Xsl64"],"pcg128::Mcg128Xsl64::advance":["pcg128::Mcg128Xsl64"],"pcg128::Mcg128Xsl64::new":["pcg128::Mcg128Xsl64"],"pcg128::output_xsl_rr":[],"pcg128cm::Lcg128CmDxsm64":["pcg128cm::Lcg128CmDxsm64"],"pcg128cm::Lcg128CmDxsm64::advance":["pcg128cm::Lcg128CmDxsm64"],"pcg128cm::Lcg128CmDxsm64::from_state_incr":["pcg128cm::Lcg128CmDxsm64"],"pcg128cm::Lcg128CmDxsm64::new":["pcg128cm::Lcg128CmDxsm64"],"pcg128cm::Lcg128CmDxsm64::step":["pcg128cm::Lcg128CmDxsm64"],"pcg128cm::output_dxsm":[],"pcg64::Lcg64Xsh32":["pcg64::Lcg64Xsh32"],"pcg64::Lcg64Xsh32::advance":["pcg64::Lcg64Xsh32"],"pcg64::Lcg64Xsh32::from_state_incr":["pcg64::Lcg64Xsh32"],"pcg64::Lcg64Xsh32::new":["pcg64::Lcg64Xsh32"],"pcg64::Lcg64Xsh32::step":["pcg64::Lcg64Xsh32"]},"glob_path_import":{},"self_to_fn":{"pcg128::Lcg128Xsl64":["Clone","Eq","PartialEq","impl Lcg128Xsl64 {\n    /// Multi-step advance functions (jump-ahead, jump-back)\n    ///\n    /// The method used here is based on Brown, \"Random Number Generation\n    /// with Arbitrary Stride,\", Transactions of the American Nuclear\n    /// Society (Nov. 1994).  The algorithm is very similar to fast\n    /// exponentiation.\n    ///\n    /// Even though delta is an unsigned integer, we can pass a\n    /// signed integer to go backwards, it just goes \"the long way round\".\n    ///\n    /// Using this function is equivalent to calling `next_64()` `delta`\n    /// number of times.\n    #[inline]\n    pub fn advance(&mut self, delta: u128) {\n        let mut acc_mult: u128 = 1;\n        let mut acc_plus: u128 = 0;\n        let mut cur_mult = MULTIPLIER;\n        let mut cur_plus = self.increment;\n        let mut mdelta = delta;\n\n        while mdelta > 0 {\n            if (mdelta & 1) != 0 {\n                acc_mult = acc_mult.wrapping_mul(cur_mult);\n                acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);\n            }\n            cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);\n            cur_mult = cur_mult.wrapping_mul(cur_mult);\n            mdelta /= 2;\n        }\n        self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);\n    }\n\n    /// Construct an instance compatible with PCG seed and stream.\n    ///\n    /// Note that the highest bit of the `stream` parameter is discarded\n    /// to simplify upholding internal invariants.\n    ///\n    /// Note that two generators with different stream parameters may be closely\n    /// correlated.\n    ///\n    /// PCG specifies the following default values for both parameters:\n    ///\n    /// - `state = 0xcafef00dd15ea5e5`\n    /// - `stream = 0xa02bdbf7bb3c0a7ac28fa16a64abf96`\n    pub fn new(state: u128, stream: u128) -> Self {\n        // The increment must be odd, hence we discard one bit:\n        let increment = (stream << 1) | 1;\n        Lcg128Xsl64::from_state_incr(state, increment)\n    }\n\n    #[inline]\n    fn from_state_incr(state: u128, increment: u128) -> Self {\n        let mut pcg = Lcg128Xsl64 { state, increment };\n        // Move away from initial value:\n        pcg.state = pcg.state.wrapping_add(pcg.increment);\n        pcg.step();\n        pcg\n    }\n\n    #[inline]\n    fn step(&mut self) {\n        // prepare the LCG for the next round\n        self.state = self\n            .state\n            .wrapping_mul(MULTIPLIER)\n            .wrapping_add(self.increment);\n    }\n}","impl RngCore for Lcg128Xsl64 {\n    #[inline]\n    fn next_u32(&mut self) -> u32 {\n        self.next_u64() as u32\n    }\n\n    #[inline]\n    fn next_u64(&mut self) -> u64 {\n        self.step();\n        output_xsl_rr(self.state)\n    }\n\n    #[inline]\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        impls::fill_bytes_via_next(self, dest)\n    }\n}","impl SeedableRng for Lcg128Xsl64 {\n    type Seed = [u8; 32];\n\n    /// We use a single 255-bit seed to initialise the state and select a stream.\n    /// One `seed` bit (lowest bit of `seed[8]`) is ignored.\n    fn from_seed(seed: Self::Seed) -> Self {\n        let mut seed_u64 = [0u64; 4];\n        le::read_u64_into(&seed, &mut seed_u64);\n        let state = u128::from(seed_u64[0]) | (u128::from(seed_u64[1]) << 64);\n        let incr = u128::from(seed_u64[2]) | (u128::from(seed_u64[3]) << 64);\n\n        // The increment must be odd, hence we discard one bit:\n        Lcg128Xsl64::from_state_incr(state, incr | 1)\n    }\n}","impl fmt::Debug for Lcg128Xsl64 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Lcg128Xsl64 {{}}\")\n    }\n}"],"pcg128::Mcg128Xsl64":["Clone","Eq","PartialEq","impl Mcg128Xsl64 {\n    /// Multi-step advance functions (jump-ahead, jump-back)\n    ///\n    /// The method used here is based on Brown, \"Random Number Generation\n    /// with Arbitrary Stride,\", Transactions of the American Nuclear\n    /// Society (Nov. 1994).  The algorithm is very similar to fast\n    /// exponentiation.\n    ///\n    /// Even though delta is an unsigned integer, we can pass a\n    /// signed integer to go backwards, it just goes \"the long way round\".\n    ///\n    /// Using this function is equivalent to calling `next_64()` `delta`\n    /// number of times.\n    #[inline]\n    pub fn advance(&mut self, delta: u128) {\n        let mut acc_mult: u128 = 1;\n        let mut acc_plus: u128 = 0;\n        let mut cur_mult = MULTIPLIER;\n        let mut cur_plus: u128 = 0;\n        let mut mdelta = delta;\n\n        while mdelta > 0 {\n            if (mdelta & 1) != 0 {\n                acc_mult = acc_mult.wrapping_mul(cur_mult);\n                acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);\n            }\n            cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);\n            cur_mult = cur_mult.wrapping_mul(cur_mult);\n            mdelta /= 2;\n        }\n        self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);\n    }\n\n    /// Construct an instance compatible with PCG seed.\n    ///\n    /// Note that PCG specifies a default value for the parameter:\n    ///\n    /// - `state = 0xcafef00dd15ea5e5`\n    pub fn new(state: u128) -> Self {\n        // Force low bit to 1, as in C version (C++ uses `state | 3` instead).\n        Mcg128Xsl64 { state: state | 1 }\n    }\n}","impl RngCore for Mcg128Xsl64 {\n    #[inline]\n    fn next_u32(&mut self) -> u32 {\n        self.next_u64() as u32\n    }\n\n    #[inline]\n    fn next_u64(&mut self) -> u64 {\n        self.state = self.state.wrapping_mul(MULTIPLIER);\n        output_xsl_rr(self.state)\n    }\n\n    #[inline]\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        impls::fill_bytes_via_next(self, dest)\n    }\n}","impl SeedableRng for Mcg128Xsl64 {\n    type Seed = [u8; 16];\n\n    fn from_seed(seed: Self::Seed) -> Self {\n        // Read as if a little-endian u128 value:\n        let mut seed_u64 = [0u64; 2];\n        le::read_u64_into(&seed, &mut seed_u64);\n        let state = u128::from(seed_u64[0]) | (u128::from(seed_u64[1]) << 64);\n        Mcg128Xsl64::new(state)\n    }\n}","impl fmt::Debug for Mcg128Xsl64 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Mcg128Xsl64 {{}}\")\n    }\n}"],"pcg128cm::Lcg128CmDxsm64":["Clone","Eq","PartialEq","impl Lcg128CmDxsm64 {\n    /// Multi-step advance functions (jump-ahead, jump-back)\n    ///\n    /// The method used here is based on Brown, \"Random Number Generation\n    /// with Arbitrary Stride,\", Transactions of the American Nuclear\n    /// Society (Nov. 1994).  The algorithm is very similar to fast\n    /// exponentiation.\n    ///\n    /// Even though delta is an unsigned integer, we can pass a\n    /// signed integer to go backwards, it just goes \"the long way round\".\n    ///\n    /// Using this function is equivalent to calling `next_64()` `delta`\n    /// number of times.\n    #[inline]\n    pub fn advance(&mut self, delta: u128) {\n        let mut acc_mult: u128 = 1;\n        let mut acc_plus: u128 = 0;\n        let mut cur_mult = MULTIPLIER as u128;\n        let mut cur_plus = self.increment;\n        let mut mdelta = delta;\n\n        while mdelta > 0 {\n            if (mdelta & 1) != 0 {\n                acc_mult = acc_mult.wrapping_mul(cur_mult);\n                acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);\n            }\n            cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);\n            cur_mult = cur_mult.wrapping_mul(cur_mult);\n            mdelta /= 2;\n        }\n        self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);\n    }\n\n    /// Construct an instance compatible with PCG seed and stream.\n    ///\n    /// Note that the highest bit of the `stream` parameter is discarded\n    /// to simplify upholding internal invariants.\n    ///\n    /// Note that while two generators with different stream parameter may be\n    /// closely correlated, this is [mitigated][upgrading-pcg64] by the DXSM output function.\n    ///\n    /// PCG specifies the following default values for both parameters:\n    ///\n    /// - `state = 0xcafef00dd15ea5e5`\n    /// - `stream = 0xa02bdbf7bb3c0a7ac28fa16a64abf96`\n    ///\n    /// [upgrading-pcg64]: https://numpy.org/doc/stable/reference/random/upgrading-pcg64.html\n    pub fn new(state: u128, stream: u128) -> Self {\n        // The increment must be odd, hence we discard one bit:\n        let increment = (stream << 1) | 1;\n        Self::from_state_incr(state, increment)\n    }\n\n    #[inline]\n    fn from_state_incr(state: u128, increment: u128) -> Self {\n        let mut pcg = Self { state, increment };\n        // Move away from initial value:\n        pcg.state = pcg.state.wrapping_add(pcg.increment);\n        pcg.step();\n        pcg\n    }\n\n    #[inline(always)]\n    fn step(&mut self) {\n        // prepare the LCG for the next round\n        self.state = self\n            .state\n            .wrapping_mul(MULTIPLIER as u128)\n            .wrapping_add(self.increment);\n    }\n}","impl RngCore for Lcg128CmDxsm64 {\n    #[inline]\n    fn next_u32(&mut self) -> u32 {\n        self.next_u64() as u32\n    }\n\n    #[inline]\n    fn next_u64(&mut self) -> u64 {\n        let res = output_dxsm(self.state);\n        self.step();\n        res\n    }\n\n    #[inline]\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        impls::fill_bytes_via_next(self, dest)\n    }\n}","impl SeedableRng for Lcg128CmDxsm64 {\n    type Seed = [u8; 32];\n\n    /// We use a single 255-bit seed to initialise the state and select a stream.\n    /// One `seed` bit (lowest bit of `seed[8]`) is ignored.\n    fn from_seed(seed: Self::Seed) -> Self {\n        let mut seed_u64 = [0u64; 4];\n        le::read_u64_into(&seed, &mut seed_u64);\n        let state = u128::from(seed_u64[0]) | (u128::from(seed_u64[1]) << 64);\n        let incr = u128::from(seed_u64[2]) | (u128::from(seed_u64[3]) << 64);\n\n        // The increment must be odd, hence we discard one bit:\n        Self::from_state_incr(state, incr | 1)\n    }\n}","impl fmt::Debug for Lcg128CmDxsm64 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Lcg128CmDxsm64 {{}}\")\n    }\n}"],"pcg64::Lcg64Xsh32":["Clone","Eq","PartialEq","impl Lcg64Xsh32 {\n    /// Multi-step advance functions (jump-ahead, jump-back)\n    ///\n    /// The method used here is based on Brown, \"Random Number Generation\n    /// with Arbitrary Stride,\", Transactions of the American Nuclear\n    /// Society (Nov. 1994).  The algorithm is very similar to fast\n    /// exponentiation.\n    ///\n    /// Even though delta is an unsigned integer, we can pass a\n    /// signed integer to go backwards, it just goes \"the long way round\".\n    ///\n    /// Using this function is equivalent to calling `next_32()` `delta`\n    /// number of times.\n    #[inline]\n    pub fn advance(&mut self, delta: u64) {\n        let mut acc_mult: u64 = 1;\n        let mut acc_plus: u64 = 0;\n        let mut cur_mult = MULTIPLIER;\n        let mut cur_plus = self.increment;\n        let mut mdelta = delta;\n\n        while mdelta > 0 {\n            if (mdelta & 1) != 0 {\n                acc_mult = acc_mult.wrapping_mul(cur_mult);\n                acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);\n            }\n            cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);\n            cur_mult = cur_mult.wrapping_mul(cur_mult);\n            mdelta /= 2;\n        }\n        self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);\n    }\n\n    /// Construct an instance compatible with PCG seed and stream.\n    ///\n    /// Note that the highest bit of the `stream` parameter is discarded\n    /// to simplify upholding internal invariants.\n    ///\n    /// Note that two generators with different stream parameters may be closely\n    /// correlated.\n    ///\n    /// PCG specifies the following default values for both parameters:\n    ///\n    /// - `state = 0xcafef00dd15ea5e5`\n    /// - `stream = 0xa02bdbf7bb3c0a7`\n    // Note: stream is 1442695040888963407u64 >> 1\n    pub fn new(state: u64, stream: u64) -> Self {\n        // The increment must be odd, hence we discard one bit:\n        let increment = (stream << 1) | 1;\n        Lcg64Xsh32::from_state_incr(state, increment)\n    }\n\n    #[inline]\n    fn from_state_incr(state: u64, increment: u64) -> Self {\n        let mut pcg = Lcg64Xsh32 { state, increment };\n        // Move away from initial value:\n        pcg.state = pcg.state.wrapping_add(pcg.increment);\n        pcg.step();\n        pcg\n    }\n\n    #[inline]\n    fn step(&mut self) {\n        // prepare the LCG for the next round\n        self.state = self\n            .state\n            .wrapping_mul(MULTIPLIER)\n            .wrapping_add(self.increment);\n    }\n}","impl RngCore for Lcg64Xsh32 {\n    #[inline]\n    fn next_u32(&mut self) -> u32 {\n        let state = self.state;\n        self.step();\n\n        // Output function XSH RR: xorshift high (bits), followed by a random rotate\n        // Constants are for 64-bit state, 32-bit output\n        const ROTATE: u32 = 59; // 64 - 5\n        const XSHIFT: u32 = 18; // (5 + 32) / 2\n        const SPARE: u32 = 27; // 64 - 32 - 5\n\n        let rot = (state >> ROTATE) as u32;\n        let xsh = (((state >> XSHIFT) ^ state) >> SPARE) as u32;\n        xsh.rotate_right(rot)\n    }\n\n    #[inline]\n    fn next_u64(&mut self) -> u64 {\n        impls::next_u64_via_u32(self)\n    }\n\n    #[inline]\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        impls::fill_bytes_via_next(self, dest)\n    }\n}","impl SeedableRng for Lcg64Xsh32 {\n    type Seed = [u8; 16];\n\n    /// We use a single 127-bit seed to initialise the state and select a stream.\n    /// One `seed` bit (lowest bit of `seed[8]`) is ignored.\n    fn from_seed(seed: Self::Seed) -> Self {\n        let mut seed_u64 = [0u64; 2];\n        le::read_u64_into(&seed, &mut seed_u64);\n\n        // The increment must be odd, hence we discard one bit:\n        Lcg64Xsh32::from_state_incr(seed_u64[0], seed_u64[1] | 1)\n    }\n}","impl fmt::Debug for Lcg64Xsh32 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Lcg64Xsh32 {{}}\")\n    }\n}"]},"single_path_import":{"pcg128::Lcg128Xsl64":"Lcg128Xsl64","pcg128::Mcg128Xsl64":"Mcg128Xsl64","pcg128::Pcg64":"Pcg64","pcg128::Pcg64Mcg":"Pcg64Mcg","pcg128cm::Lcg128CmDxsm64":"Lcg128CmDxsm64","pcg128cm::Pcg64Dxsm":"Pcg64Dxsm","pcg64::Lcg64Xsh32":"Lcg64Xsh32","pcg64::Pcg32":"Pcg32","rand_core":"rand_core"},"srcs":{"<pcg128::Lcg128Xsl64 as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"Lcg128Xsl64 {{}}\")\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"<pcg128::Lcg128Xsl64 as rand_core::RngCore>::fill_bytes":["#[inline]\nfn fill_bytes(&mut self, dest: &mut [u8]){\n        impls::fill_bytes_via_next(self, dest)\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"<pcg128::Lcg128Xsl64 as rand_core::RngCore>::next_u32":["#[inline]\nfn next_u32(&mut self) -> u32{\n        self.next_u64() as u32\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"<pcg128::Lcg128Xsl64 as rand_core::RngCore>::next_u64":["#[inline]\nfn next_u64(&mut self) -> u64{\n        self.step();\n        output_xsl_rr(self.state)\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"<pcg128::Lcg128Xsl64 as rand_core::SeedableRng>::from_seed":["/// We use a single 255-bit seed to initialise the state and select a stream.\n/// One `seed` bit (lowest bit of `seed[8]`) is ignored.\nfn from_seed(seed: Self::Seed) -> Self{\n        let mut seed_u64 = [0u64; 4];\n        le::read_u64_into(&seed, &mut seed_u64);\n        let state = u128::from(seed_u64[0]) | (u128::from(seed_u64[1]) << 64);\n        let incr = u128::from(seed_u64[2]) | (u128::from(seed_u64[3]) << 64);\n\n        // The increment must be odd, hence we discard one bit:\n        Lcg128Xsl64::from_state_incr(state, incr | 1)\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"<pcg128::Mcg128Xsl64 as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"Mcg128Xsl64 {{}}\")\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"<pcg128::Mcg128Xsl64 as rand_core::RngCore>::fill_bytes":["#[inline]\nfn fill_bytes(&mut self, dest: &mut [u8]){\n        impls::fill_bytes_via_next(self, dest)\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"<pcg128::Mcg128Xsl64 as rand_core::RngCore>::next_u32":["#[inline]\nfn next_u32(&mut self) -> u32{\n        self.next_u64() as u32\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"<pcg128::Mcg128Xsl64 as rand_core::RngCore>::next_u64":["#[inline]\nfn next_u64(&mut self) -> u64{\n        self.state = self.state.wrapping_mul(MULTIPLIER);\n        output_xsl_rr(self.state)\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"<pcg128::Mcg128Xsl64 as rand_core::SeedableRng>::from_seed":["fn from_seed(seed: Self::Seed) -> Self{\n        // Read as if a little-endian u128 value:\n        let mut seed_u64 = [0u64; 2];\n        le::read_u64_into(&seed, &mut seed_u64);\n        let state = u128::from(seed_u64[0]) | (u128::from(seed_u64[1]) << 64);\n        Mcg128Xsl64::new(state)\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"<pcg128cm::Lcg128CmDxsm64 as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"Lcg128CmDxsm64 {{}}\")\n    }","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::RngCore>::fill_bytes":["#[inline]\nfn fill_bytes(&mut self, dest: &mut [u8]){\n        impls::fill_bytes_via_next(self, dest)\n    }","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::RngCore>::next_u32":["#[inline]\nfn next_u32(&mut self) -> u32{\n        self.next_u64() as u32\n    }","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::RngCore>::next_u64":["#[inline]\nfn next_u64(&mut self) -> u64{\n        let res = output_dxsm(self.state);\n        self.step();\n        res\n    }","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::SeedableRng>::from_seed":["/// We use a single 255-bit seed to initialise the state and select a stream.\n/// One `seed` bit (lowest bit of `seed[8]`) is ignored.\nfn from_seed(seed: Self::Seed) -> Self{\n        let mut seed_u64 = [0u64; 4];\n        le::read_u64_into(&seed, &mut seed_u64);\n        let state = u128::from(seed_u64[0]) | (u128::from(seed_u64[1]) << 64);\n        let incr = u128::from(seed_u64[2]) | (u128::from(seed_u64[3]) << 64);\n\n        // The increment must be odd, hence we discard one bit:\n        Self::from_state_incr(state, incr | 1)\n    }","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"<pcg64::Lcg64Xsh32 as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"Lcg64Xsh32 {{}}\")\n    }","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))"],"<pcg64::Lcg64Xsh32 as rand_core::RngCore>::fill_bytes":["#[inline]\nfn fill_bytes(&mut self, dest: &mut [u8]){\n        impls::fill_bytes_via_next(self, dest)\n    }","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))"],"<pcg64::Lcg64Xsh32 as rand_core::RngCore>::next_u32":["#[inline]\nfn next_u32(&mut self) -> u32{\n        let state = self.state;\n        self.step();\n\n        // Output function XSH RR: xorshift high (bits), followed by a random rotate\n        // Constants are for 64-bit state, 32-bit output\n        const ROTATE: u32 = 59; // 64 - 5\n        const XSHIFT: u32 = 18; // (5 + 32) / 2\n        const SPARE: u32 = 27; // 64 - 32 - 5\n\n        let rot = (state >> ROTATE) as u32;\n        let xsh = (((state >> XSHIFT) ^ state) >> SPARE) as u32;\n        xsh.rotate_right(rot)\n    }","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))"],"<pcg64::Lcg64Xsh32 as rand_core::RngCore>::next_u64":["#[inline]\nfn next_u64(&mut self) -> u64{\n        impls::next_u64_via_u32(self)\n    }","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))"],"<pcg64::Lcg64Xsh32 as rand_core::SeedableRng>::from_seed":["/// We use a single 127-bit seed to initialise the state and select a stream.\n/// One `seed` bit (lowest bit of `seed[8]`) is ignored.\nfn from_seed(seed: Self::Seed) -> Self{\n        let mut seed_u64 = [0u64; 2];\n        le::read_u64_into(&seed, &mut seed_u64);\n\n        // The increment must be odd, hence we discard one bit:\n        Lcg64Xsh32::from_state_incr(seed_u64[0], seed_u64[1] | 1)\n    }","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))"],"pcg128::Lcg128Xsl64":["/// A PCG random number generator (XSL RR 128/64 (LCG) variant).\n///\n/// Permuted Congruential Generator with 128-bit state, internal Linear\n/// Congruential Generator, and 64-bit output via \"xorshift low (bits),\n/// random rotation\" output function.\n///\n/// This is a 128-bit LCG with explicitly chosen stream with the PCG-XSL-RR\n/// output function. This combination is the standard `pcg64`.\n///\n/// Despite the name, this implementation uses 32 bytes (256 bit) space\n/// comprising 128 bits of state and 128 bits stream selector. These are both\n/// set by `SeedableRng`, using a 256-bit seed.\n///\n/// Note that two generators with different stream parameters may be closely\n/// correlated.\npub struct Lcg128Xsl64 {\n    state: u128,\n    increment: u128,\n}","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"pcg128::Lcg128Xsl64::advance":["/// Multi-step advance functions (jump-ahead, jump-back)\n///\n/// The method used here is based on Brown, \"Random Number Generation\n/// with Arbitrary Stride,\", Transactions of the American Nuclear\n/// Society (Nov. 1994).  The algorithm is very similar to fast\n/// exponentiation.\n///\n/// Even though delta is an unsigned integer, we can pass a\n/// signed integer to go backwards, it just goes \"the long way round\".\n///\n/// Using this function is equivalent to calling `next_64()` `delta`\n/// number of times.\n#[inline]\npub fn advance(&mut self, delta: u128){\n        let mut acc_mult: u128 = 1;\n        let mut acc_plus: u128 = 0;\n        let mut cur_mult = MULTIPLIER;\n        let mut cur_plus = self.increment;\n        let mut mdelta = delta;\n\n        while mdelta > 0 {\n            if (mdelta & 1) != 0 {\n                acc_mult = acc_mult.wrapping_mul(cur_mult);\n                acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);\n            }\n            cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);\n            cur_mult = cur_mult.wrapping_mul(cur_mult);\n            mdelta /= 2;\n        }\n        self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"pcg128::Lcg128Xsl64::from_state_incr":["#[inline]\nfn from_state_incr(state: u128, increment: u128) -> Self{\n        let mut pcg = Lcg128Xsl64 { state, increment };\n        // Move away from initial value:\n        pcg.state = pcg.state.wrapping_add(pcg.increment);\n        pcg.step();\n        pcg\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"pcg128::Lcg128Xsl64::new":["/// Construct an instance compatible with PCG seed and stream.\n///\n/// Note that the highest bit of the `stream` parameter is discarded\n/// to simplify upholding internal invariants.\n///\n/// Note that two generators with different stream parameters may be closely\n/// correlated.\n///\n/// PCG specifies the following default values for both parameters:\n///\n/// - `state = 0xcafef00dd15ea5e5`\n/// - `stream = 0xa02bdbf7bb3c0a7ac28fa16a64abf96`\npub fn new(state: u128, stream: u128) -> Self{\n        // The increment must be odd, hence we discard one bit:\n        let increment = (stream << 1) | 1;\n        Lcg128Xsl64::from_state_incr(state, increment)\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"pcg128::Lcg128Xsl64::step":["#[inline]\nfn step(&mut self){\n        // prepare the LCG for the next round\n        self.state = self\n            .state\n            .wrapping_mul(MULTIPLIER)\n            .wrapping_add(self.increment);\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"pcg128::Mcg128Xsl64":["/// A PCG random number generator (XSL 128/64 (MCG) variant).\n///\n/// Permuted Congruential Generator with 128-bit state, internal Multiplicative\n/// Congruential Generator, and 64-bit output via \"xorshift low (bits),\n/// random rotation\" output function.\n///\n/// This is a 128-bit MCG with the PCG-XSL-RR output function, also known as\n/// `pcg64_fast`.\n/// Note that compared to the standard `pcg64` (128-bit LCG with PCG-XSL-RR\n/// output function), this RNG is faster, also has a long cycle, and still has\n/// good performance on statistical tests.\npub struct Mcg128Xsl64 {\n    state: u128,\n}","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"pcg128::Mcg128Xsl64::advance":["/// Multi-step advance functions (jump-ahead, jump-back)\n///\n/// The method used here is based on Brown, \"Random Number Generation\n/// with Arbitrary Stride,\", Transactions of the American Nuclear\n/// Society (Nov. 1994).  The algorithm is very similar to fast\n/// exponentiation.\n///\n/// Even though delta is an unsigned integer, we can pass a\n/// signed integer to go backwards, it just goes \"the long way round\".\n///\n/// Using this function is equivalent to calling `next_64()` `delta`\n/// number of times.\n#[inline]\npub fn advance(&mut self, delta: u128){\n        let mut acc_mult: u128 = 1;\n        let mut acc_plus: u128 = 0;\n        let mut cur_mult = MULTIPLIER;\n        let mut cur_plus: u128 = 0;\n        let mut mdelta = delta;\n\n        while mdelta > 0 {\n            if (mdelta & 1) != 0 {\n                acc_mult = acc_mult.wrapping_mul(cur_mult);\n                acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);\n            }\n            cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);\n            cur_mult = cur_mult.wrapping_mul(cur_mult);\n            mdelta /= 2;\n        }\n        self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"pcg128::Mcg128Xsl64::new":["/// Construct an instance compatible with PCG seed.\n///\n/// Note that PCG specifies a default value for the parameter:\n///\n/// - `state = 0xcafef00dd15ea5e5`\npub fn new(state: u128) -> Self{\n        // Force low bit to 1, as in C version (C++ uses `state | 3` instead).\n        Mcg128Xsl64 { state: state | 1 }\n    }","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"pcg128::output_xsl_rr":["#[inline(always)]\nfn output_xsl_rr(state: u128) -> u64{\n    // Output function XSL RR (\"xorshift low (bits), random rotation\")\n    // Constants are for 128-bit state, 64-bit output\n    const XSHIFT: u32 = 64; // (128 - 64 + 64) / 2\n    const ROTATE: u32 = 122; // 128 - 6\n\n    let rot = (state >> ROTATE) as u32;\n    let xsl = ((state >> XSHIFT) as u64) ^ (state as u64);\n    xsl.rotate_right(rot)\n}","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))"],"pcg128cm::Lcg128CmDxsm64":["/// A PCG random number generator (CM DXSM 128/64 (LCG) variant).\n///\n/// Permuted Congruential Generator with 128-bit state, internal Linear\n/// Congruential Generator, and 64-bit output via \"double xorshift multiply\"\n/// output function.\n///\n/// This is a 128-bit LCG with explicitly chosen stream with the PCG-DXSM\n/// output function. This corresponds to `pcg_engines::cm_setseq_dxsm_128_64`\n/// from pcg_cpp and `PCG64DXSM` from NumPy.\n///\n/// Despite the name, this implementation uses 32 bytes (256 bit) space\n/// comprising 128 bits of state and 128 bits stream selector. These are both\n/// set by `SeedableRng`, using a 256-bit seed.\n///\n/// Note that while two generators with different stream parameter may be\n/// closely correlated, this is [mitigated][upgrading-pcg64] by the DXSM output function.\n///\n/// [upgrading-pcg64]: https://numpy.org/doc/stable/reference/random/upgrading-pcg64.html\npub struct Lcg128CmDxsm64 {\n    state: u128,\n    increment: u128,\n}","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"pcg128cm::Lcg128CmDxsm64::advance":["/// Multi-step advance functions (jump-ahead, jump-back)\n///\n/// The method used here is based on Brown, \"Random Number Generation\n/// with Arbitrary Stride,\", Transactions of the American Nuclear\n/// Society (Nov. 1994).  The algorithm is very similar to fast\n/// exponentiation.\n///\n/// Even though delta is an unsigned integer, we can pass a\n/// signed integer to go backwards, it just goes \"the long way round\".\n///\n/// Using this function is equivalent to calling `next_64()` `delta`\n/// number of times.\n#[inline]\npub fn advance(&mut self, delta: u128){\n        let mut acc_mult: u128 = 1;\n        let mut acc_plus: u128 = 0;\n        let mut cur_mult = MULTIPLIER as u128;\n        let mut cur_plus = self.increment;\n        let mut mdelta = delta;\n\n        while mdelta > 0 {\n            if (mdelta & 1) != 0 {\n                acc_mult = acc_mult.wrapping_mul(cur_mult);\n                acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);\n            }\n            cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);\n            cur_mult = cur_mult.wrapping_mul(cur_mult);\n            mdelta /= 2;\n        }\n        self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);\n    }","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"pcg128cm::Lcg128CmDxsm64::from_state_incr":["#[inline]\nfn from_state_incr(state: u128, increment: u128) -> Self{\n        let mut pcg = Self { state, increment };\n        // Move away from initial value:\n        pcg.state = pcg.state.wrapping_add(pcg.increment);\n        pcg.step();\n        pcg\n    }","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"pcg128cm::Lcg128CmDxsm64::new":["/// Construct an instance compatible with PCG seed and stream.\n///\n/// Note that the highest bit of the `stream` parameter is discarded\n/// to simplify upholding internal invariants.\n///\n/// Note that while two generators with different stream parameter may be\n/// closely correlated, this is [mitigated][upgrading-pcg64] by the DXSM output function.\n///\n/// PCG specifies the following default values for both parameters:\n///\n/// - `state = 0xcafef00dd15ea5e5`\n/// - `stream = 0xa02bdbf7bb3c0a7ac28fa16a64abf96`\n///\n/// [upgrading-pcg64]: https://numpy.org/doc/stable/reference/random/upgrading-pcg64.html\npub fn new(state: u128, stream: u128) -> Self{\n        // The increment must be odd, hence we discard one bit:\n        let increment = (stream << 1) | 1;\n        Self::from_state_incr(state, increment)\n    }","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"pcg128cm::Lcg128CmDxsm64::step":["#[inline(always)]\nfn step(&mut self){\n        // prepare the LCG for the next round\n        self.state = self\n            .state\n            .wrapping_mul(MULTIPLIER as u128)\n            .wrapping_add(self.increment);\n    }","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"pcg128cm::output_dxsm":["#[inline(always)]\nfn output_dxsm(state: u128) -> u64{\n    // See https://github.com/imneme/pcg-cpp/blob/ffd522e7188bef30a00c74dc7eb9de5faff90092/include/pcg_random.hpp#L1016\n    // for a short discussion of the construction and its original implementation.\n    let mut hi = (state >> 64) as u64;\n    let mut lo = state as u64;\n\n    lo |= 1;\n    hi ^= hi >> 32;\n    hi = hi.wrapping_mul(MULTIPLIER);\n    hi ^= hi >> 48;\n    hi = hi.wrapping_mul(lo);\n\n    hi\n}","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))"],"pcg64::Lcg64Xsh32":["/// A PCG random number generator (XSH RR 64/32 (LCG) variant).\n///\n/// Permuted Congruential Generator with 64-bit state, internal Linear\n/// Congruential Generator, and 32-bit output via \"xorshift high (bits),\n/// random rotation\" output function.\n///\n/// This is a 64-bit LCG with explicitly chosen stream with the PCG-XSH-RR\n/// output function. This combination is the standard `pcg32`.\n///\n/// Despite the name, this implementation uses 16 bytes (128 bit) space\n/// comprising 64 bits of state and 64 bits stream selector. These are both set\n/// by `SeedableRng`, using a 128-bit seed.\n///\n/// Note that two generators with different stream parameter may be closely\n/// correlated.\npub struct Lcg64Xsh32 {\n    state: u64,\n    increment: u64,\n}","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))"],"pcg64::Lcg64Xsh32::advance":["/// Multi-step advance functions (jump-ahead, jump-back)\n///\n/// The method used here is based on Brown, \"Random Number Generation\n/// with Arbitrary Stride,\", Transactions of the American Nuclear\n/// Society (Nov. 1994).  The algorithm is very similar to fast\n/// exponentiation.\n///\n/// Even though delta is an unsigned integer, we can pass a\n/// signed integer to go backwards, it just goes \"the long way round\".\n///\n/// Using this function is equivalent to calling `next_32()` `delta`\n/// number of times.\n#[inline]\npub fn advance(&mut self, delta: u64){\n        let mut acc_mult: u64 = 1;\n        let mut acc_plus: u64 = 0;\n        let mut cur_mult = MULTIPLIER;\n        let mut cur_plus = self.increment;\n        let mut mdelta = delta;\n\n        while mdelta > 0 {\n            if (mdelta & 1) != 0 {\n                acc_mult = acc_mult.wrapping_mul(cur_mult);\n                acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);\n            }\n            cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);\n            cur_mult = cur_mult.wrapping_mul(cur_mult);\n            mdelta /= 2;\n        }\n        self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);\n    }","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))"],"pcg64::Lcg64Xsh32::from_state_incr":["#[inline]\nfn from_state_incr(state: u64, increment: u64) -> Self{\n        let mut pcg = Lcg64Xsh32 { state, increment };\n        // Move away from initial value:\n        pcg.state = pcg.state.wrapping_add(pcg.increment);\n        pcg.step();\n        pcg\n    }","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))"],"pcg64::Lcg64Xsh32::new":["/// Construct an instance compatible with PCG seed and stream.\n///\n/// Note that the highest bit of the `stream` parameter is discarded\n/// to simplify upholding internal invariants.\n///\n/// Note that two generators with different stream parameters may be closely\n/// correlated.\n///\n/// PCG specifies the following default values for both parameters:\n///\n/// - `state = 0xcafef00dd15ea5e5`\n/// - `stream = 0xa02bdbf7bb3c0a7`\npub fn new(state: u64, stream: u64) -> Self{\n        // The increment must be odd, hence we discard one bit:\n        let increment = (stream << 1) | 1;\n        Lcg64Xsh32::from_state_incr(state, increment)\n    }","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))"],"pcg64::Lcg64Xsh32::step":["#[inline]\nfn step(&mut self){\n        // prepare the LCG for the next round\n        self.state = self\n            .state\n            .wrapping_mul(MULTIPLIER)\n            .wrapping_add(self.increment);\n    }","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))"]},"struct_constructor":{"bool":["eq"],"core::result::Result":["fmt"],"pcg128::Lcg128Xsl64":["clone","from_seed","from_state_incr","new"],"pcg128::Mcg128Xsl64":["clone","from_seed","new"],"pcg128cm::Lcg128CmDxsm64":["clone","from_seed","from_state_incr","new"],"pcg64::Lcg64Xsh32":["clone","from_seed","from_state_incr","new"],"u32":["next_u32"],"u64":["next_u64","output_dxsm","output_xsl_rr"]},"struct_to_trait":{"pcg128::Lcg128Xsl64":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralPartialEq","rand_core::RngCore","rand_core::SeedableRng"],"pcg128::Mcg128Xsl64":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralPartialEq","rand_core::RngCore","rand_core::SeedableRng"],"pcg128cm::Lcg128CmDxsm64":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralPartialEq","rand_core::RngCore","rand_core::SeedableRng"],"pcg64::Lcg64Xsh32":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralPartialEq","rand_core::RngCore","rand_core::SeedableRng"]},"targets":{"<pcg128::Lcg128Xsl64 as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))","core::fmt::Debug"],"<pcg128::Lcg128Xsl64 as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))","rand_core::RngCore"],"<pcg128::Lcg128Xsl64 as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))","rand_core::RngCore"],"<pcg128::Lcg128Xsl64 as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))","rand_core::RngCore"],"<pcg128::Lcg128Xsl64 as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))","rand_core::SeedableRng"],"<pcg128::Mcg128Xsl64 as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))","core::fmt::Debug"],"<pcg128::Mcg128Xsl64 as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))","rand_core::RngCore"],"<pcg128::Mcg128Xsl64 as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))","rand_core::RngCore"],"<pcg128::Mcg128Xsl64 as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))","rand_core::RngCore"],"<pcg128::Mcg128Xsl64 as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))","rand_core::SeedableRng"],"<pcg128cm::Lcg128CmDxsm64 as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))","core::fmt::Debug"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))","rand_core::RngCore"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))","rand_core::RngCore"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))","rand_core::RngCore"],"<pcg128cm::Lcg128CmDxsm64 as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))","rand_core::SeedableRng"],"<pcg64::Lcg64Xsh32 as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))","core::fmt::Debug"],"<pcg64::Lcg64Xsh32 as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))","rand_core::RngCore"],"<pcg64::Lcg64Xsh32 as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))","rand_core::RngCore"],"<pcg64::Lcg64Xsh32 as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))","rand_core::RngCore"],"<pcg64::Lcg64Xsh32 as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))","rand_core::SeedableRng"],"pcg128::Lcg128Xsl64::advance":["advance","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))",""],"pcg128::Lcg128Xsl64::from_state_incr":["from_state_incr","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))",""],"pcg128::Lcg128Xsl64::new":["new","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))",""],"pcg128::Lcg128Xsl64::step":["step","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))",""],"pcg128::Mcg128Xsl64::advance":["advance","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))",""],"pcg128::Mcg128Xsl64::new":["new","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))",""],"pcg128::output_xsl_rr":["output_xsl_rr","Real(LocalPath(\"rand_pcg/src/pcg128.rs\"))",""],"pcg128cm::Lcg128CmDxsm64::advance":["advance","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))",""],"pcg128cm::Lcg128CmDxsm64::from_state_incr":["from_state_incr","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))",""],"pcg128cm::Lcg128CmDxsm64::new":["new","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))",""],"pcg128cm::Lcg128CmDxsm64::step":["step","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))",""],"pcg128cm::output_dxsm":["output_dxsm","Real(LocalPath(\"rand_pcg/src/pcg128cm.rs\"))",""],"pcg64::Lcg64Xsh32::advance":["advance","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))",""],"pcg64::Lcg64Xsh32::from_state_incr":["from_state_incr","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))",""],"pcg64::Lcg64Xsh32::new":["new","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))",""],"pcg64::Lcg64Xsh32::step":["step","Real(LocalPath(\"rand_pcg/src/pcg64.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["pcg128::Lcg128Xsl64","pcg128::Mcg128Xsl64","pcg128cm::Lcg128CmDxsm64","pcg64::Lcg64Xsh32"],"core::cmp::Eq":["pcg128::Lcg128Xsl64","pcg128::Mcg128Xsl64","pcg128cm::Lcg128CmDxsm64","pcg64::Lcg64Xsh32"],"core::cmp::PartialEq":["pcg128::Lcg128Xsl64","pcg128::Mcg128Xsl64","pcg128cm::Lcg128CmDxsm64","pcg64::Lcg64Xsh32"],"core::fmt::Debug":["pcg128::Lcg128Xsl64","pcg128::Mcg128Xsl64","pcg128cm::Lcg128CmDxsm64","pcg64::Lcg64Xsh32"],"core::marker::StructuralPartialEq":["pcg128::Lcg128Xsl64","pcg128::Mcg128Xsl64","pcg128cm::Lcg128CmDxsm64","pcg64::Lcg64Xsh32"],"rand_core::RngCore":["pcg128::Lcg128Xsl64","pcg128::Mcg128Xsl64","pcg128cm::Lcg128CmDxsm64","pcg64::Lcg64Xsh32"],"rand_core::SeedableRng":["pcg128::Lcg128Xsl64","pcg128::Mcg128Xsl64","pcg128cm::Lcg128CmDxsm64","pcg64::Lcg64Xsh32"]},"type_to_def_path":{"pcg128::Lcg128Xsl64":"pcg128::Lcg128Xsl64","pcg128::Mcg128Xsl64":"pcg128::Mcg128Xsl64","pcg128cm::Lcg128CmDxsm64":"pcg128cm::Lcg128CmDxsm64","pcg64::Lcg64Xsh32":"pcg64::Lcg64Xsh32"}}