{"dependencies":{"<chacha::Array64<T> as std::clone::Clone>::clone":["chacha::Array64","std::marker::Sized"],"<chacha::Array64<T> as std::convert::AsMut<[T]>>::as_mut":["chacha::Array64","std::marker::Sized"],"<chacha::Array64<T> as std::convert::AsRef<[T]>>::as_ref":["chacha::Array64","std::marker::Sized"],"<chacha::Array64<T> as std::default::Default>::default":["chacha::Array64","std::marker::Sized"],"<chacha::Array64<T> as std::fmt::Debug>::fmt":["chacha::Array64","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<chacha::ChaCha12Core as rand_core::SeedableRng>::from_seed":["chacha::ChaCha12Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha12Core as rand_core::block::BlockRngCore>::generate":["chacha::ChaCha12Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha12Core as std::clone::Clone>::clone":["chacha::ChaCha12Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha12Core as std::cmp::Eq>::assert_receiver_is_total_eq":["chacha::ChaCha12Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha12Core as std::cmp::PartialEq>::eq":["chacha::ChaCha12Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha12Core as std::fmt::Debug>::fmt":["chacha::ChaCha12Core","guts::ChaCha","ppv_lite86::vec128_storage","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<chacha::ChaCha12Rng as rand_core::RngCore>::fill_bytes":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha12Rng as rand_core::RngCore>::next_u32":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha12Rng as rand_core::RngCore>::next_u64":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha12Rng as rand_core::SeedableRng>::from_seed":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha12Rng as std::clone::Clone>::clone":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha12Rng as std::cmp::PartialEq>::eq":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha12Rng as std::convert::From<chacha::ChaCha12Core>>::from":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha12Rng as std::fmt::Debug>::fmt":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<chacha::ChaCha20Core as rand_core::SeedableRng>::from_seed":["chacha::ChaCha20Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha20Core as rand_core::block::BlockRngCore>::generate":["chacha::ChaCha20Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha20Core as std::clone::Clone>::clone":["chacha::ChaCha20Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha20Core as std::cmp::Eq>::assert_receiver_is_total_eq":["chacha::ChaCha20Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha20Core as std::cmp::PartialEq>::eq":["chacha::ChaCha20Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha20Core as std::fmt::Debug>::fmt":["chacha::ChaCha20Core","guts::ChaCha","ppv_lite86::vec128_storage","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<chacha::ChaCha20Rng as rand_core::RngCore>::fill_bytes":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha20Rng as rand_core::RngCore>::next_u32":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha20Rng as rand_core::RngCore>::next_u64":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha20Rng as rand_core::SeedableRng>::from_seed":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha20Rng as std::clone::Clone>::clone":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha20Rng as std::cmp::PartialEq>::eq":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha20Rng as std::convert::From<chacha::ChaCha20Core>>::from":["chacha::ChaCha12Core","chacha::ChaCha20Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha20Rng as std::fmt::Debug>::fmt":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<chacha::ChaCha8Core as rand_core::SeedableRng>::from_seed":["chacha::ChaCha8Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha8Core as rand_core::block::BlockRngCore>::generate":["chacha::ChaCha8Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha8Core as std::clone::Clone>::clone":["chacha::ChaCha8Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha8Core as std::cmp::Eq>::assert_receiver_is_total_eq":["chacha::ChaCha8Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha8Core as std::cmp::PartialEq>::eq":["chacha::ChaCha8Core","guts::ChaCha","ppv_lite86::vec128_storage"],"<chacha::ChaCha8Core as std::fmt::Debug>::fmt":["chacha::ChaCha8Core","guts::ChaCha","ppv_lite86::vec128_storage","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<chacha::ChaCha8Rng as rand_core::RngCore>::fill_bytes":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha8Rng as rand_core::RngCore>::next_u32":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha8Rng as rand_core::RngCore>::next_u64":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha8Rng as rand_core::SeedableRng>::from_seed":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha8Rng as std::clone::Clone>::clone":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha8Rng as std::cmp::PartialEq>::eq":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha8Rng as std::convert::From<chacha::ChaCha8Core>>::from":["chacha::ChaCha12Core","chacha::ChaCha8Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::ChaCha8Rng as std::fmt::Debug>::fmt":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<chacha::abstract12::ChaCha12Rng as std::cmp::Eq>::assert_receiver_is_total_eq":["chacha::abstract12::ChaCha12Rng"],"<chacha::abstract12::ChaCha12Rng as std::cmp::PartialEq>::eq":["chacha::abstract12::ChaCha12Rng"],"<chacha::abstract12::ChaCha12Rng as std::convert::From<&chacha::ChaCha12Rng>>::from":["chacha::ChaCha12Core","chacha::ChaCha12Rng","chacha::abstract12::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::abstract12::ChaCha12Rng as std::fmt::Debug>::fmt":["chacha::abstract12::ChaCha12Rng","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<chacha::abstract20::ChaCha20Rng as std::cmp::Eq>::assert_receiver_is_total_eq":["chacha::abstract20::ChaCha20Rng"],"<chacha::abstract20::ChaCha20Rng as std::cmp::PartialEq>::eq":["chacha::abstract20::ChaCha20Rng"],"<chacha::abstract20::ChaCha20Rng as std::convert::From<&chacha::ChaCha20Rng>>::from":["chacha::ChaCha12Core","chacha::ChaCha20Rng","chacha::abstract20::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::abstract20::ChaCha20Rng as std::fmt::Debug>::fmt":["chacha::abstract20::ChaCha20Rng","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<chacha::abstract8::ChaCha8Rng as std::cmp::Eq>::assert_receiver_is_total_eq":["chacha::abstract8::ChaCha8Rng"],"<chacha::abstract8::ChaCha8Rng as std::cmp::PartialEq>::eq":["chacha::abstract8::ChaCha8Rng"],"<chacha::abstract8::ChaCha8Rng as std::convert::From<&chacha::ChaCha8Rng>>::from":["chacha::ChaCha12Core","chacha::ChaCha8Rng","chacha::abstract8::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"<chacha::abstract8::ChaCha8Rng as std::fmt::Debug>::fmt":["chacha::abstract8::ChaCha8Rng","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<guts::ChaCha as std::clone::Clone>::clone":["guts::ChaCha","ppv_lite86::vec128_storage"],"<guts::ChaCha as std::cmp::Eq>::assert_receiver_is_total_eq":["guts::ChaCha","ppv_lite86::vec128_storage"],"<guts::ChaCha as std::cmp::PartialEq>::eq":["guts::ChaCha","ppv_lite86::vec128_storage"],"<guts::State<V> as std::clone::Clone>::clone":["guts::State","std::marker::Sized"],"chacha::Array64":["chacha::Array64","std::marker::Sized"],"chacha::ChaCha12Core":["chacha::ChaCha12Core","guts::ChaCha","ppv_lite86::vec128_storage"],"chacha::ChaCha12Rng":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha12Rng::get_seed":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha12Rng::get_stream":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha12Rng::get_word_pos":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha12Rng::set_stream":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha12Rng::set_word_pos":["chacha::ChaCha12Core","chacha::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha20Core":["chacha::ChaCha20Core","guts::ChaCha","ppv_lite86::vec128_storage"],"chacha::ChaCha20Rng":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha20Rng::get_seed":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha20Rng::get_stream":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha20Rng::get_word_pos":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha20Rng::set_stream":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha20Rng::set_word_pos":["chacha::ChaCha12Core","chacha::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha8Core":["chacha::ChaCha8Core","guts::ChaCha","ppv_lite86::vec128_storage"],"chacha::ChaCha8Rng":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha8Rng::get_seed":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha8Rng::get_stream":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha8Rng::get_word_pos":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha8Rng::set_stream":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::ChaCha8Rng::set_word_pos":["chacha::ChaCha12Core","chacha::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::abstract12::<impl std::convert::From<&chacha::abstract12::ChaCha12Rng> for chacha::ChaCha12Rng>::from":["chacha::ChaCha12Core","chacha::ChaCha12Rng","chacha::abstract12::ChaCha12Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::abstract12::ChaCha12Rng":["chacha::abstract12::ChaCha12Rng"],"chacha::abstract20::<impl std::convert::From<&chacha::abstract20::ChaCha20Rng> for chacha::ChaCha20Rng>::from":["chacha::ChaCha12Core","chacha::ChaCha20Rng","chacha::abstract20::ChaCha20Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::abstract20::ChaCha20Rng":["chacha::abstract20::ChaCha20Rng"],"chacha::abstract8::<impl std::convert::From<&chacha::abstract8::ChaCha8Rng> for chacha::ChaCha8Rng>::from":["chacha::ChaCha12Core","chacha::ChaCha8Rng","chacha::abstract8::ChaCha8Rng","guts::ChaCha","ppv_lite86::vec128_storage","rand_core::block::BlockRng","rand_core::block::BlockRngCore","std::marker::Sized"],"chacha::abstract8::ChaCha8Rng":["chacha::abstract8::ChaCha8Rng"],"guts::ChaCha":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::ChaCha::get_block_pos":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::ChaCha::get_nonce":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::ChaCha::get_seed":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::ChaCha::new":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::ChaCha::refill4":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::ChaCha::set_block_pos":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::ChaCha::set_nonce":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::State":["guts::State","std::marker::Sized"],"guts::add_pos":["ppv_lite86::Machine","std::marker::Sized"],"guts::d0123":["ppv_lite86::Machine","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::diagonalize":["guts::State","ppv_lite86::LaneWords4","std::marker::Sized"],"guts::get_seed":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::get_seed::fn_impl":["guts::ChaCha","ppv_lite86::Machine","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::get_seed::impl_avx":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::get_seed::impl_sse2":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::get_stream_param":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::get_stream_param::fn_impl":["guts::ChaCha","ppv_lite86::Machine","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::get_stream_param::impl_avx":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::get_stream_param::impl_sse2":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::init_chacha":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::init_chacha::fn_impl":["guts::ChaCha","ppv_lite86::Machine","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::init_chacha::impl_avx":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::init_chacha::impl_sse2":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::init_chacha_x":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::init_chacha_x::fn_impl":["guts::ChaCha","ppv_lite86::Machine","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::init_chacha_x::impl_avx":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::init_chacha_x::impl_sse2":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::read_u32le":[],"guts::refill_narrow_rounds":["guts::ChaCha","guts::State","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::refill_narrow_rounds::fn_impl":["guts::ChaCha","guts::State","ppv_lite86::Machine","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::refill_narrow_rounds::impl_avx":["guts::ChaCha","guts::State","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::refill_narrow_rounds::impl_avx2":["guts::ChaCha","guts::State","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::refill_narrow_rounds::impl_sse2":["guts::ChaCha","guts::State","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::refill_narrow_rounds::impl_sse41":["guts::ChaCha","guts::State","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::refill_narrow_rounds::impl_ssse3":["guts::ChaCha","guts::State","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::refill_wide":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::refill_wide::fn_impl":["guts::ChaCha","ppv_lite86::Machine","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::refill_wide::impl_avx":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::refill_wide::impl_avx2":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::refill_wide::impl_sse2":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::refill_wide::impl_sse41":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::refill_wide::impl_ssse3":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::refill_wide_impl":["guts::ChaCha","ppv_lite86::Machine","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::round":["guts::State","ppv_lite86::ArithOps","ppv_lite86::BitOps32","std::marker::Sized"],"guts::set_stream_param":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::set_stream_param::fn_impl":["guts::ChaCha","ppv_lite86::Machine","ppv_lite86::vec128_storage","std::marker::Sized"],"guts::set_stream_param::impl_avx":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::set_stream_param::impl_sse2":["guts::ChaCha","ppv_lite86::vec128_storage"],"guts::undiagonalize":["guts::State","ppv_lite86::LaneWords4","std::marker::Sized"]},"glob_path_import":{},"self_to_fn":{"chacha::Array64":["impl<T> AsMut<[T]> for Array64<T> {\n    fn as_mut(&mut self) -> &mut [T] {\n        &mut self.0\n    }\n}","impl<T> AsRef<[T]> for Array64<T> {\n    fn as_ref(&self) -> &[T] {\n        &self.0\n    }\n}","impl<T> Clone for Array64<T>\nwhere\n    T: Copy + Default,\n{\n    fn clone(&self) -> Self {\n        let mut new = Self::default();\n        new.0.copy_from_slice(&self.0);\n        new\n    }\n}","impl<T> Default for Array64<T>\nwhere\n    T: Default,\n{\n    #[rustfmt::skip]\n    fn default() -> Self {\n        Self([\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n        ])\n    }\n}","impl<T> fmt::Debug for Array64<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Array64 {{}}\")\n    }\n}"],"chacha::ChaCha12Core":["Clone","Eq","PartialEq","impl BlockRngCore for $ChaChaXCore {\n            type Item = u32;\n            type Results = Array64<u32>;\n\n            #[inline]\n            fn generate(&mut self, r: &mut Self::Results) {\n                self.state.refill4($rounds, &mut r.0);\n            }\n        }","impl CryptoBlockRng for $ChaChaXCore {}","impl SeedableRng for $ChaChaXCore {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }\n        }","impl fmt::Debug for $ChaChaXCore {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                write!(f, \"ChaChaXCore {{}}\")\n            }\n        }"],"chacha::ChaCha12Rng":["Clone","Debug","impl $ChaChaXRng {\n            // The buffer is a 4-block window, i.e. it is always at a block-aligned position in the\n            // stream but if the stream has been sought it may not be self-aligned.\n\n            /// Get the offset from the start of the stream, in 32-bit words.\n            ///\n            /// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n            /// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n            /// not supported, hence the result can simply be multiplied by 4 to get a\n            /// byte-offset.\n            #[inline]\n            pub fn get_word_pos(&self) -> u128 {\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }\n\n            /// Set the offset from the start of the stream, in 32-bit words.\n            ///\n            /// As with `get_word_pos`, we use a 68-bit number. Since the generator\n            /// simply cycles at the end of its period (1 ZiB), we ignore the upper\n            /// 60 bits.\n            #[inline]\n            pub fn set_word_pos(&mut self, word_offset: u128) {\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }\n\n            /// Set the stream number.\n            ///\n            /// This is initialized to zero; 2<sup>64</sup> unique streams of output\n            /// are available per seed/key.\n            ///\n            /// Note that in order to reproduce ChaCha output with a specific 64-bit\n            /// nonce, one can convert that nonce to a `u64` in little-endian fashion\n            /// and pass to this function. In theory a 96-bit nonce can be used by\n            /// passing the last 64-bits to this function and using the first 32-bits as\n            /// the most significant half of the 64-bit counter (which may be set\n            /// indirectly via `set_word_pos`), but this is not directly supported.\n            #[inline]\n            pub fn set_stream(&mut self, stream: u64) {\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }\n\n            /// Get the stream number.\n            #[inline]\n            pub fn get_stream(&self) -> u64 {\n                self.rng.core.state.get_nonce()\n            }\n\n            /// Get the seed.\n            #[inline]\n            pub fn get_seed(&self) -> [u8; 32] {\n                self.rng.core.state.get_seed()\n            }\n        }","impl CryptoRng for $ChaChaXRng {}","impl Eq for $ChaChaXRng {}","impl From<$ChaChaXCore> for $ChaChaXRng {\n            fn from(core: $ChaChaXCore) -> Self {\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }","impl From<&$ChaChaXRng> for super::$ChaChaXRng {\n                // Construct one of the possible concrete RNGs realizing an abstract state.\n                fn from(a: &$ChaChaXRng) -> Self {\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }\n            }","impl PartialEq<$ChaChaXRng> for $ChaChaXRng {\n            fn eq(&self, rhs: &$ChaChaXRng) -> bool {\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }\n        }","impl RngCore for $ChaChaXRng {\n            #[inline]\n            fn next_u32(&mut self) -> u32 {\n                self.rng.next_u32()\n            }\n\n            #[inline]\n            fn next_u64(&mut self) -> u64 {\n                self.rng.next_u64()\n            }\n\n            #[inline]\n            fn fill_bytes(&mut self, bytes: &mut [u8]) {\n                self.rng.fill_bytes(bytes)\n            }\n        }","impl SeedableRng for $ChaChaXRng {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }"],"chacha::ChaCha20Core":["Clone","Eq","PartialEq","impl BlockRngCore for $ChaChaXCore {\n            type Item = u32;\n            type Results = Array64<u32>;\n\n            #[inline]\n            fn generate(&mut self, r: &mut Self::Results) {\n                self.state.refill4($rounds, &mut r.0);\n            }\n        }","impl CryptoBlockRng for $ChaChaXCore {}","impl SeedableRng for $ChaChaXCore {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }\n        }","impl fmt::Debug for $ChaChaXCore {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                write!(f, \"ChaChaXCore {{}}\")\n            }\n        }"],"chacha::ChaCha20Rng":["Clone","Debug","impl $ChaChaXRng {\n            // The buffer is a 4-block window, i.e. it is always at a block-aligned position in the\n            // stream but if the stream has been sought it may not be self-aligned.\n\n            /// Get the offset from the start of the stream, in 32-bit words.\n            ///\n            /// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n            /// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n            /// not supported, hence the result can simply be multiplied by 4 to get a\n            /// byte-offset.\n            #[inline]\n            pub fn get_word_pos(&self) -> u128 {\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }\n\n            /// Set the offset from the start of the stream, in 32-bit words.\n            ///\n            /// As with `get_word_pos`, we use a 68-bit number. Since the generator\n            /// simply cycles at the end of its period (1 ZiB), we ignore the upper\n            /// 60 bits.\n            #[inline]\n            pub fn set_word_pos(&mut self, word_offset: u128) {\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }\n\n            /// Set the stream number.\n            ///\n            /// This is initialized to zero; 2<sup>64</sup> unique streams of output\n            /// are available per seed/key.\n            ///\n            /// Note that in order to reproduce ChaCha output with a specific 64-bit\n            /// nonce, one can convert that nonce to a `u64` in little-endian fashion\n            /// and pass to this function. In theory a 96-bit nonce can be used by\n            /// passing the last 64-bits to this function and using the first 32-bits as\n            /// the most significant half of the 64-bit counter (which may be set\n            /// indirectly via `set_word_pos`), but this is not directly supported.\n            #[inline]\n            pub fn set_stream(&mut self, stream: u64) {\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }\n\n            /// Get the stream number.\n            #[inline]\n            pub fn get_stream(&self) -> u64 {\n                self.rng.core.state.get_nonce()\n            }\n\n            /// Get the seed.\n            #[inline]\n            pub fn get_seed(&self) -> [u8; 32] {\n                self.rng.core.state.get_seed()\n            }\n        }","impl CryptoRng for $ChaChaXRng {}","impl Eq for $ChaChaXRng {}","impl From<$ChaChaXCore> for $ChaChaXRng {\n            fn from(core: $ChaChaXCore) -> Self {\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }","impl From<&$ChaChaXRng> for super::$ChaChaXRng {\n                // Construct one of the possible concrete RNGs realizing an abstract state.\n                fn from(a: &$ChaChaXRng) -> Self {\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }\n            }","impl PartialEq<$ChaChaXRng> for $ChaChaXRng {\n            fn eq(&self, rhs: &$ChaChaXRng) -> bool {\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }\n        }","impl RngCore for $ChaChaXRng {\n            #[inline]\n            fn next_u32(&mut self) -> u32 {\n                self.rng.next_u32()\n            }\n\n            #[inline]\n            fn next_u64(&mut self) -> u64 {\n                self.rng.next_u64()\n            }\n\n            #[inline]\n            fn fill_bytes(&mut self, bytes: &mut [u8]) {\n                self.rng.fill_bytes(bytes)\n            }\n        }","impl SeedableRng for $ChaChaXRng {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }"],"chacha::ChaCha8Core":["Clone","Eq","PartialEq","impl BlockRngCore for $ChaChaXCore {\n            type Item = u32;\n            type Results = Array64<u32>;\n\n            #[inline]\n            fn generate(&mut self, r: &mut Self::Results) {\n                self.state.refill4($rounds, &mut r.0);\n            }\n        }","impl CryptoBlockRng for $ChaChaXCore {}","impl SeedableRng for $ChaChaXCore {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }\n        }","impl fmt::Debug for $ChaChaXCore {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                write!(f, \"ChaChaXCore {{}}\")\n            }\n        }"],"chacha::ChaCha8Rng":["Clone","Debug","impl $ChaChaXRng {\n            // The buffer is a 4-block window, i.e. it is always at a block-aligned position in the\n            // stream but if the stream has been sought it may not be self-aligned.\n\n            /// Get the offset from the start of the stream, in 32-bit words.\n            ///\n            /// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n            /// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n            /// not supported, hence the result can simply be multiplied by 4 to get a\n            /// byte-offset.\n            #[inline]\n            pub fn get_word_pos(&self) -> u128 {\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }\n\n            /// Set the offset from the start of the stream, in 32-bit words.\n            ///\n            /// As with `get_word_pos`, we use a 68-bit number. Since the generator\n            /// simply cycles at the end of its period (1 ZiB), we ignore the upper\n            /// 60 bits.\n            #[inline]\n            pub fn set_word_pos(&mut self, word_offset: u128) {\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }\n\n            /// Set the stream number.\n            ///\n            /// This is initialized to zero; 2<sup>64</sup> unique streams of output\n            /// are available per seed/key.\n            ///\n            /// Note that in order to reproduce ChaCha output with a specific 64-bit\n            /// nonce, one can convert that nonce to a `u64` in little-endian fashion\n            /// and pass to this function. In theory a 96-bit nonce can be used by\n            /// passing the last 64-bits to this function and using the first 32-bits as\n            /// the most significant half of the 64-bit counter (which may be set\n            /// indirectly via `set_word_pos`), but this is not directly supported.\n            #[inline]\n            pub fn set_stream(&mut self, stream: u64) {\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }\n\n            /// Get the stream number.\n            #[inline]\n            pub fn get_stream(&self) -> u64 {\n                self.rng.core.state.get_nonce()\n            }\n\n            /// Get the seed.\n            #[inline]\n            pub fn get_seed(&self) -> [u8; 32] {\n                self.rng.core.state.get_seed()\n            }\n        }","impl CryptoRng for $ChaChaXRng {}","impl Eq for $ChaChaXRng {}","impl From<$ChaChaXCore> for $ChaChaXRng {\n            fn from(core: $ChaChaXCore) -> Self {\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }","impl From<&$ChaChaXRng> for super::$ChaChaXRng {\n                // Construct one of the possible concrete RNGs realizing an abstract state.\n                fn from(a: &$ChaChaXRng) -> Self {\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }\n            }","impl PartialEq<$ChaChaXRng> for $ChaChaXRng {\n            fn eq(&self, rhs: &$ChaChaXRng) -> bool {\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }\n        }","impl RngCore for $ChaChaXRng {\n            #[inline]\n            fn next_u32(&mut self) -> u32 {\n                self.rng.next_u32()\n            }\n\n            #[inline]\n            fn next_u64(&mut self) -> u64 {\n                self.rng.next_u64()\n            }\n\n            #[inline]\n            fn fill_bytes(&mut self, bytes: &mut [u8]) {\n                self.rng.fill_bytes(bytes)\n            }\n        }","impl SeedableRng for $ChaChaXRng {\n            type Seed = [u8; 32];\n\n            #[inline]\n            fn from_seed(seed: Self::Seed) -> Self {\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }\n        }"],"chacha::abstract12::ChaCha12Rng":["Debug","Eq","PartialEq","impl From<&super::$ChaChaXRng> for $ChaChaXRng {\n                // Forget all information about the input except what is necessary to determine the\n                // outputs of any sequence of pub API calls.\n                fn from(r: &super::$ChaChaXRng) -> Self {\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }\n            }"],"chacha::abstract20::ChaCha20Rng":["Debug","Eq","PartialEq","impl From<&super::$ChaChaXRng> for $ChaChaXRng {\n                // Forget all information about the input except what is necessary to determine the\n                // outputs of any sequence of pub API calls.\n                fn from(r: &super::$ChaChaXRng) -> Self {\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }\n            }"],"chacha::abstract8::ChaCha8Rng":["Debug","Eq","PartialEq","impl From<&super::$ChaChaXRng> for $ChaChaXRng {\n                // Forget all information about the input except what is necessary to determine the\n                // outputs of any sequence of pub API calls.\n                fn from(r: &super::$ChaChaXRng) -> Self {\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }\n            }"],"guts::ChaCha":["Clone","Eq","PartialEq","impl ChaCha {\n    #[inline(always)]\n    pub fn new(key: &[u8; 32], nonce: &[u8]) -> Self {\n        init_chacha(key, nonce)\n    }\n\n    /// Produce 4 blocks of output, advancing the state\n    #[inline(always)]\n    pub fn refill4(&mut self, drounds: u32, out: &mut [u32; BUFSZ]) {\n        refill_wide(self, drounds, out)\n    }\n\n    #[inline(always)]\n    pub fn set_block_pos(&mut self, value: u64) {\n        set_stream_param(self, STREAM_PARAM_BLOCK, value)\n    }\n\n    #[inline(always)]\n    pub fn get_block_pos(&self) -> u64 {\n        get_stream_param(self, STREAM_PARAM_BLOCK)\n    }\n\n    #[inline(always)]\n    pub fn set_nonce(&mut self, value: u64) {\n        set_stream_param(self, STREAM_PARAM_NONCE, value)\n    }\n\n    #[inline(always)]\n    pub fn get_nonce(&self) -> u64 {\n        get_stream_param(self, STREAM_PARAM_NONCE)\n    }\n\n    #[inline(always)]\n    pub fn get_seed(&self) -> [u8; 32] {\n        get_seed(self)\n    }\n}"],"guts::State":["Clone"]},"single_path_import":{"chacha::ChaCha12Core":"ChaCha12Core","chacha::ChaCha12Rng":"ChaCha12Rng","chacha::ChaCha20Core":"ChaCha20Core","chacha::ChaCha20Rng":"ChaCha20Rng","chacha::ChaCha8Core":"ChaCha8Core","chacha::ChaCha8Rng":"ChaCha8Rng","ppv_lite86::Machine":"guts::Machine","rand_core":"rand_core"},"srcs":{"<chacha::Array64<T> as std::clone::Clone>::clone":["fn clone(&self) -> Self{\n        let mut new = Self::default();\n        new.0.copy_from_slice(&self.0);\n        new\n    }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::Array64<T> as std::convert::AsMut<[T]>>::as_mut":["fn as_mut(&mut self) -> &mut [T]{\n        &mut self.0\n    }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::Array64<T> as std::convert::AsRef<[T]>>::as_ref":["fn as_ref(&self) -> &[T]{\n        &self.0\n    }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::Array64<T> as std::default::Default>::default":["#[rustfmt::skip]\nfn default() -> Self{\n        Self([\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),\n        ])\n    }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::Array64<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"Array64 {{}}\")\n    }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha12Core as rand_core::SeedableRng>::from_seed":["#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha12Core as rand_core::block::BlockRngCore>::generate":["#[inline]\nfn generate(&mut self, r: &mut Self::Results){\n                self.state.refill4($rounds, &mut r.0);\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha12Core as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n                write!(f, \"ChaChaXCore {{}}\")\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha12Rng as rand_core::RngCore>::fill_bytes":["#[inline]\nfn fill_bytes(&mut self, bytes: &mut [u8]){\n                self.rng.fill_bytes(bytes)\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha12Rng as rand_core::RngCore>::next_u32":["#[inline]\nfn next_u32(&mut self) -> u32{\n                self.rng.next_u32()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha12Rng as rand_core::RngCore>::next_u64":["#[inline]\nfn next_u64(&mut self) -> u64{\n                self.rng.next_u64()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha12Rng as rand_core::SeedableRng>::from_seed":["#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha12Rng as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &$ChaChaXRng) -> bool{\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha12Rng as std::convert::From<chacha::ChaCha12Core>>::from":["fn from(core: $ChaChaXCore) -> Self{\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha20Core as rand_core::SeedableRng>::from_seed":["#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha20Core as rand_core::block::BlockRngCore>::generate":["#[inline]\nfn generate(&mut self, r: &mut Self::Results){\n                self.state.refill4($rounds, &mut r.0);\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha20Core as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n                write!(f, \"ChaChaXCore {{}}\")\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha20Rng as rand_core::RngCore>::fill_bytes":["#[inline]\nfn fill_bytes(&mut self, bytes: &mut [u8]){\n                self.rng.fill_bytes(bytes)\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha20Rng as rand_core::RngCore>::next_u32":["#[inline]\nfn next_u32(&mut self) -> u32{\n                self.rng.next_u32()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha20Rng as rand_core::RngCore>::next_u64":["#[inline]\nfn next_u64(&mut self) -> u64{\n                self.rng.next_u64()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha20Rng as rand_core::SeedableRng>::from_seed":["#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha20Rng as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &$ChaChaXRng) -> bool{\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha20Rng as std::convert::From<chacha::ChaCha20Core>>::from":["fn from(core: $ChaChaXCore) -> Self{\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha8Core as rand_core::SeedableRng>::from_seed":["#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                $ChaChaXCore {\n                    state: ChaCha::new(&seed, &[0u8; 8]),\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha8Core as rand_core::block::BlockRngCore>::generate":["#[inline]\nfn generate(&mut self, r: &mut Self::Results){\n                self.state.refill4($rounds, &mut r.0);\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha8Core as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n                write!(f, \"ChaChaXCore {{}}\")\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha8Rng as rand_core::RngCore>::fill_bytes":["#[inline]\nfn fill_bytes(&mut self, bytes: &mut [u8]){\n                self.rng.fill_bytes(bytes)\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha8Rng as rand_core::RngCore>::next_u32":["#[inline]\nfn next_u32(&mut self) -> u32{\n                self.rng.next_u32()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha8Rng as rand_core::RngCore>::next_u64":["#[inline]\nfn next_u64(&mut self) -> u64{\n                self.rng.next_u64()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha8Rng as rand_core::SeedableRng>::from_seed":["#[inline]\nfn from_seed(seed: Self::Seed) -> Self{\n                let core = $ChaChaXCore::from_seed(seed);\n                Self {\n                    rng: BlockRng::new(core),\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha8Rng as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &$ChaChaXRng) -> bool{\n                let a: $abst::$ChaChaXRng = self.into();\n                let b: $abst::$ChaChaXRng = rhs.into();\n                a == b\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::ChaCha8Rng as std::convert::From<chacha::ChaCha8Core>>::from":["fn from(core: $ChaChaXCore) -> Self{\n                $ChaChaXRng {\n                    rng: BlockRng::new(core),\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::abstract12::ChaCha12Rng as std::convert::From<&chacha::ChaCha12Rng>>::from":["fn from(r: &super::$ChaChaXRng) -> Self{\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::abstract20::ChaCha20Rng as std::convert::From<&chacha::ChaCha20Rng>>::from":["fn from(r: &super::$ChaChaXRng) -> Self{\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"<chacha::abstract8::ChaCha8Rng as std::convert::From<&chacha::ChaCha8Rng>>::from":["fn from(r: &super::$ChaChaXRng) -> Self{\n                    Self {\n                        seed: r.get_seed(),\n                        stream: r.get_stream(),\n                        word_pos: r.get_word_pos(),\n                    }\n                }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::Array64":["#[repr(transparent)]\npub struct Array64<T>([T; 64]);","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha12Core":["#[doc=$doc]\npub struct $ChaChaXCore {\n            state: ChaCha,\n        }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha12Rng":["/// A cryptographically secure random number generator that uses the ChaCha algorithm.\n///\n/// ChaCha is a stream cipher designed by Daniel J. Bernstein[^1], that we use as an RNG. It is\n/// an improved variant of the Salsa20 cipher family, which was selected as one of the \"stream\n/// ciphers suitable for widespread adoption\" by eSTREAM[^2].\n///\n/// ChaCha uses add-rotate-xor (ARX) operations as its basis. These are safe against timing\n/// attacks, although that is mostly a concern for ciphers and not for RNGs. We provide a SIMD\n/// implementation to support high throughput on a variety of common hardware platforms.\n///\n/// With the ChaCha algorithm it is possible to choose the number of rounds the core algorithm\n/// should run. The number of rounds is a tradeoff between performance and security, where 8\n/// rounds is the minimum potentially secure configuration, and 20 rounds is widely used as a\n/// conservative choice.\n///\n/// We use a 64-bit counter and 64-bit stream identifier as in Bernstein's implementation[^1]\n/// except that we use a stream identifier in place of a nonce. A 64-bit counter over 64-byte\n/// (16 word) blocks allows 1 ZiB of output before cycling, and the stream identifier allows\n/// 2<sup>64</sup> unique streams of output per seed. Both counter and stream are initialized\n/// to zero but may be set via the `set_word_pos` and `set_stream` methods.\n///\n/// The word layout is:\n///\n/// ```text\n/// constant  constant  constant  constant\n/// seed      seed      seed      seed\n/// seed      seed      seed      seed\n/// counter   counter   stream_id stream_id\n/// ```\n///\n/// This implementation uses an output buffer of sixteen `u32` words, and uses\n/// [`BlockRng`] to implement the [`RngCore`] methods.\n///\n/// [^1]: D. J. Bernstein, [*ChaCha, a variant of Salsa20*](\n///       https://cr.yp.to/chacha.html)\n///\n/// [^2]: [eSTREAM: the ECRYPT Stream Cipher Project](\n///       http://www.ecrypt.eu.org/stream/)\npub struct $ChaChaXRng {\n            rng: BlockRng<$ChaChaXCore>,\n        }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha12Rng::get_seed":["/// Get the seed.\n#[inline]\npub fn get_seed(&self) -> [u8; 32]{\n                self.rng.core.state.get_seed()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha12Rng::get_stream":["/// Get the stream number.\n#[inline]\npub fn get_stream(&self) -> u64{\n                self.rng.core.state.get_nonce()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha12Rng::get_word_pos":["/// Get the offset from the start of the stream, in 32-bit words.\n///\n/// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n/// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n/// not supported, hence the result can simply be multiplied by 4 to get a\n/// byte-offset.\n#[inline]\npub fn get_word_pos(&self) -> u128{\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha12Rng::set_stream":["/// Set the stream number.\n///\n/// This is initialized to zero; 2<sup>64</sup> unique streams of output\n/// are available per seed/key.\n///\n/// Note that in order to reproduce ChaCha output with a specific 64-bit\n/// nonce, one can convert that nonce to a `u64` in little-endian fashion\n/// and pass to this function. In theory a 96-bit nonce can be used by\n/// passing the last 64-bits to this function and using the first 32-bits as\n/// the most significant half of the 64-bit counter (which may be set\n/// indirectly via `set_word_pos`), but this is not directly supported.\n#[inline]\npub fn set_stream(&mut self, stream: u64){\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha12Rng::set_word_pos":["/// Set the offset from the start of the stream, in 32-bit words.\n///\n/// As with `get_word_pos`, we use a 68-bit number. Since the generator\n/// simply cycles at the end of its period (1 ZiB), we ignore the upper\n/// 60 bits.\n#[inline]\npub fn set_word_pos(&mut self, word_offset: u128){\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha20Core":["#[doc=$doc]\npub struct $ChaChaXCore {\n            state: ChaCha,\n        }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha20Rng":["/// A cryptographically secure random number generator that uses the ChaCha algorithm.\n///\n/// ChaCha is a stream cipher designed by Daniel J. Bernstein[^1], that we use as an RNG. It is\n/// an improved variant of the Salsa20 cipher family, which was selected as one of the \"stream\n/// ciphers suitable for widespread adoption\" by eSTREAM[^2].\n///\n/// ChaCha uses add-rotate-xor (ARX) operations as its basis. These are safe against timing\n/// attacks, although that is mostly a concern for ciphers and not for RNGs. We provide a SIMD\n/// implementation to support high throughput on a variety of common hardware platforms.\n///\n/// With the ChaCha algorithm it is possible to choose the number of rounds the core algorithm\n/// should run. The number of rounds is a tradeoff between performance and security, where 8\n/// rounds is the minimum potentially secure configuration, and 20 rounds is widely used as a\n/// conservative choice.\n///\n/// We use a 64-bit counter and 64-bit stream identifier as in Bernstein's implementation[^1]\n/// except that we use a stream identifier in place of a nonce. A 64-bit counter over 64-byte\n/// (16 word) blocks allows 1 ZiB of output before cycling, and the stream identifier allows\n/// 2<sup>64</sup> unique streams of output per seed. Both counter and stream are initialized\n/// to zero but may be set via the `set_word_pos` and `set_stream` methods.\n///\n/// The word layout is:\n///\n/// ```text\n/// constant  constant  constant  constant\n/// seed      seed      seed      seed\n/// seed      seed      seed      seed\n/// counter   counter   stream_id stream_id\n/// ```\n///\n/// This implementation uses an output buffer of sixteen `u32` words, and uses\n/// [`BlockRng`] to implement the [`RngCore`] methods.\n///\n/// [^1]: D. J. Bernstein, [*ChaCha, a variant of Salsa20*](\n///       https://cr.yp.to/chacha.html)\n///\n/// [^2]: [eSTREAM: the ECRYPT Stream Cipher Project](\n///       http://www.ecrypt.eu.org/stream/)\npub struct $ChaChaXRng {\n            rng: BlockRng<$ChaChaXCore>,\n        }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha20Rng::get_seed":["/// Get the seed.\n#[inline]\npub fn get_seed(&self) -> [u8; 32]{\n                self.rng.core.state.get_seed()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha20Rng::get_stream":["/// Get the stream number.\n#[inline]\npub fn get_stream(&self) -> u64{\n                self.rng.core.state.get_nonce()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha20Rng::get_word_pos":["/// Get the offset from the start of the stream, in 32-bit words.\n///\n/// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n/// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n/// not supported, hence the result can simply be multiplied by 4 to get a\n/// byte-offset.\n#[inline]\npub fn get_word_pos(&self) -> u128{\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha20Rng::set_stream":["/// Set the stream number.\n///\n/// This is initialized to zero; 2<sup>64</sup> unique streams of output\n/// are available per seed/key.\n///\n/// Note that in order to reproduce ChaCha output with a specific 64-bit\n/// nonce, one can convert that nonce to a `u64` in little-endian fashion\n/// and pass to this function. In theory a 96-bit nonce can be used by\n/// passing the last 64-bits to this function and using the first 32-bits as\n/// the most significant half of the 64-bit counter (which may be set\n/// indirectly via `set_word_pos`), but this is not directly supported.\n#[inline]\npub fn set_stream(&mut self, stream: u64){\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha20Rng::set_word_pos":["/// Set the offset from the start of the stream, in 32-bit words.\n///\n/// As with `get_word_pos`, we use a 68-bit number. Since the generator\n/// simply cycles at the end of its period (1 ZiB), we ignore the upper\n/// 60 bits.\n#[inline]\npub fn set_word_pos(&mut self, word_offset: u128){\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha8Core":["#[doc=$doc]\npub struct $ChaChaXCore {\n            state: ChaCha,\n        }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha8Rng":["/// A cryptographically secure random number generator that uses the ChaCha algorithm.\n///\n/// ChaCha is a stream cipher designed by Daniel J. Bernstein[^1], that we use as an RNG. It is\n/// an improved variant of the Salsa20 cipher family, which was selected as one of the \"stream\n/// ciphers suitable for widespread adoption\" by eSTREAM[^2].\n///\n/// ChaCha uses add-rotate-xor (ARX) operations as its basis. These are safe against timing\n/// attacks, although that is mostly a concern for ciphers and not for RNGs. We provide a SIMD\n/// implementation to support high throughput on a variety of common hardware platforms.\n///\n/// With the ChaCha algorithm it is possible to choose the number of rounds the core algorithm\n/// should run. The number of rounds is a tradeoff between performance and security, where 8\n/// rounds is the minimum potentially secure configuration, and 20 rounds is widely used as a\n/// conservative choice.\n///\n/// We use a 64-bit counter and 64-bit stream identifier as in Bernstein's implementation[^1]\n/// except that we use a stream identifier in place of a nonce. A 64-bit counter over 64-byte\n/// (16 word) blocks allows 1 ZiB of output before cycling, and the stream identifier allows\n/// 2<sup>64</sup> unique streams of output per seed. Both counter and stream are initialized\n/// to zero but may be set via the `set_word_pos` and `set_stream` methods.\n///\n/// The word layout is:\n///\n/// ```text\n/// constant  constant  constant  constant\n/// seed      seed      seed      seed\n/// seed      seed      seed      seed\n/// counter   counter   stream_id stream_id\n/// ```\n///\n/// This implementation uses an output buffer of sixteen `u32` words, and uses\n/// [`BlockRng`] to implement the [`RngCore`] methods.\n///\n/// [^1]: D. J. Bernstein, [*ChaCha, a variant of Salsa20*](\n///       https://cr.yp.to/chacha.html)\n///\n/// [^2]: [eSTREAM: the ECRYPT Stream Cipher Project](\n///       http://www.ecrypt.eu.org/stream/)\npub struct $ChaChaXRng {\n            rng: BlockRng<$ChaChaXCore>,\n        }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha8Rng::get_seed":["/// Get the seed.\n#[inline]\npub fn get_seed(&self) -> [u8; 32]{\n                self.rng.core.state.get_seed()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha8Rng::get_stream":["/// Get the stream number.\n#[inline]\npub fn get_stream(&self) -> u64{\n                self.rng.core.state.get_nonce()\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha8Rng::get_word_pos":["/// Get the offset from the start of the stream, in 32-bit words.\n///\n/// Since the generated blocks are 16 words (2<sup>4</sup>) long and the\n/// counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\n/// not supported, hence the result can simply be multiplied by 4 to get a\n/// byte-offset.\n#[inline]\npub fn get_word_pos(&self) -> u128{\n                let buf_start_block = {\n                    let buf_end_block = self.rng.core.state.get_block_pos();\n                    u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into())\n                };\n                let (buf_offset_blocks, block_offset_words) = {\n                    let buf_offset_words = self.rng.index() as u64;\n                    let blocks_part = buf_offset_words / u64::from(BLOCK_WORDS);\n                    let words_part = buf_offset_words % u64::from(BLOCK_WORDS);\n                    (blocks_part, words_part)\n                };\n                let pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks);\n                let pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n                pos_block_words + u128::from(block_offset_words)\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha8Rng::set_stream":["/// Set the stream number.\n///\n/// This is initialized to zero; 2<sup>64</sup> unique streams of output\n/// are available per seed/key.\n///\n/// Note that in order to reproduce ChaCha output with a specific 64-bit\n/// nonce, one can convert that nonce to a `u64` in little-endian fashion\n/// and pass to this function. In theory a 96-bit nonce can be used by\n/// passing the last 64-bits to this function and using the first 32-bits as\n/// the most significant half of the 64-bit counter (which may be set\n/// indirectly via `set_word_pos`), but this is not directly supported.\n#[inline]\npub fn set_stream(&mut self, stream: u64){\n                self.rng.core.state.set_nonce(stream);\n                if self.rng.index() != 64 {\n                    let wp = self.get_word_pos();\n                    self.set_word_pos(wp);\n                }\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::ChaCha8Rng::set_word_pos":["/// Set the offset from the start of the stream, in 32-bit words.\n///\n/// As with `get_word_pos`, we use a 68-bit number. Since the generator\n/// simply cycles at the end of its period (1 ZiB), we ignore the upper\n/// 60 bits.\n#[inline]\npub fn set_word_pos(&mut self, word_offset: u128){\n                let block = (word_offset / u128::from(BLOCK_WORDS)) as u64;\n                self.rng.core.state.set_block_pos(block);\n                self.rng\n                    .generate_and_set((word_offset % u128::from(BLOCK_WORDS)) as usize);\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::abstract12::<impl std::convert::From<&chacha::abstract12::ChaCha12Rng> for chacha::ChaCha12Rng>::from":["fn from(a: &$ChaChaXRng) -> Self{\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::abstract12::ChaCha12Rng":["pub(crate) struct $ChaChaXRng {\n                seed: [u8; 32],\n                stream: u64,\n                word_pos: u128,\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::abstract20::<impl std::convert::From<&chacha::abstract20::ChaCha20Rng> for chacha::ChaCha20Rng>::from":["fn from(a: &$ChaChaXRng) -> Self{\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::abstract20::ChaCha20Rng":["pub(crate) struct $ChaChaXRng {\n                seed: [u8; 32],\n                stream: u64,\n                word_pos: u128,\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::abstract8::<impl std::convert::From<&chacha::abstract8::ChaCha8Rng> for chacha::ChaCha8Rng>::from":["fn from(a: &$ChaChaXRng) -> Self{\n                    use rand_core::SeedableRng;\n                    let mut r = Self::from_seed(a.seed);\n                    r.set_stream(a.stream);\n                    r.set_word_pos(a.word_pos);\n                    r\n                }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"chacha::abstract8::ChaCha8Rng":["pub(crate) struct $ChaChaXRng {\n                seed: [u8; 32],\n                stream: u64,\n                word_pos: u128,\n            }","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))"],"guts::ChaCha":["pub struct ChaCha {\n    pub(crate) b: vec128_storage,\n    pub(crate) c: vec128_storage,\n    pub(crate) d: vec128_storage,\n}","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::ChaCha::get_block_pos":["#[inline(always)]\npub fn get_block_pos(&self) -> u64{\n        get_stream_param(self, STREAM_PARAM_BLOCK)\n    }","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::ChaCha::get_nonce":["#[inline(always)]\npub fn get_nonce(&self) -> u64{\n        get_stream_param(self, STREAM_PARAM_NONCE)\n    }","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::ChaCha::get_seed":["#[inline(always)]\npub fn get_seed(&self) -> [u8; 32]{\n        get_seed(self)\n    }","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::ChaCha::new":["#[inline(always)]\npub fn new(key: &[u8; 32], nonce: &[u8]) -> Self{\n        init_chacha(key, nonce)\n    }","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::ChaCha::refill4":["/// Produce 4 blocks of output, advancing the state\n#[inline(always)]\npub fn refill4(&mut self, drounds: u32, out: &mut [u32; BUFSZ]){\n        refill_wide(self, drounds, out)\n    }","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::ChaCha::set_block_pos":["#[inline(always)]\npub fn set_block_pos(&mut self, value: u64){\n        set_stream_param(self, STREAM_PARAM_BLOCK, value)\n    }","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::ChaCha::set_nonce":["#[inline(always)]\npub fn set_nonce(&mut self, value: u64){\n        set_stream_param(self, STREAM_PARAM_NONCE, value)\n    }","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::State":["pub struct State<V> {\n    pub(crate) a: V,\n    pub(crate) b: V,\n    pub(crate) c: V,\n    pub(crate) d: V,\n}","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::add_pos":["#[inline(always)]\n#[cfg(target_endian = \"little\")]\nfn add_pos<Mach: Machine>(m: Mach, d: Mach::u32x4, i: u64) -> Mach::u32x4{\n    let d0: Mach::u64x2 = m.unpack(d.into());\n    let incr = m.vec([i, 0]);\n    m.unpack((d0 + incr).into())\n}","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::d0123":["#[inline(always)]\n#[cfg(target_endian = \"little\")]\nfn d0123<Mach: Machine>(m: Mach, d: vec128_storage) -> Mach::u32x4x4{\n    let d0: Mach::u64x2 = m.unpack(d);\n    let incr =\n        Mach::u64x2x4::from_lanes([m.vec([0, 0]), m.vec([1, 0]), m.vec([2, 0]), m.vec([3, 0])]);\n    m.unpack((Mach::u64x2x4::from_lanes([d0, d0, d0, d0]) + incr).into())\n}","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::diagonalize":["#[inline(always)]\npub(crate) fn diagonalize<V: LaneWords4>(mut x: State<V>) -> State<V>{\n    x.b = x.b.shuffle_lane_words3012();\n    x.c = x.c.shuffle_lane_words2301();\n    x.d = x.d.shuffle_lane_words1230();\n    x\n}","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::get_seed":["#[cfg(feature = \"std\")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = \"avx\")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }\n            #[target_feature(enable = \"sse2\")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!(\"avx\") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!(\"sse2\") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::get_seed::fn_impl":["#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let b: Mach::u32x4 = m.unpack(state.b);\n        let c: Mach::u32x4 = m.unpack(state.c);\n        let mut key = [0u8; 32];\n        b.write_le(&mut key[..16]);\n        c.write_le(&mut key[16..]);\n        key\n    }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::get_seed::impl_avx":["#[target_feature(enable = \"avx\")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::get_seed::impl_sse2":["#[target_feature(enable = \"sse2\")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::get_stream_param":["#[cfg(feature = \"std\")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = \"avx\")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }\n            #[target_feature(enable = \"sse2\")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!(\"avx\") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!(\"sse2\") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::get_stream_param::fn_impl":["#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let d: Mach::u32x4 = m.unpack(state.d);\n        ((d.extract((param << 1) | 1) as u64) << 32) | d.extract(param << 1) as u64\n    }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::get_stream_param::impl_avx":["#[target_feature(enable = \"avx\")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::get_stream_param::impl_sse2":["#[target_feature(enable = \"sse2\")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::init_chacha":["#[cfg(feature = \"std\")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = \"avx\")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }\n            #[target_feature(enable = \"sse2\")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!(\"avx\") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!(\"sse2\") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::init_chacha::fn_impl":["#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let ctr_nonce = [\n            0,\n            if nonce.len() == 12 {\n                read_u32le(&nonce[0..4])\n            } else {\n                0\n            },\n            read_u32le(&nonce[nonce.len() - 8..nonce.len() - 4]),\n            read_u32le(&nonce[nonce.len() - 4..]),\n        ];\n        let key0: Mach::u32x4 = m.read_le(&key[..16]);\n        let key1: Mach::u32x4 = m.read_le(&key[16..]);\n        ChaCha {\n            b: key0.into(),\n            c: key1.into(),\n            d: ctr_nonce.into(),\n        }\n    }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::init_chacha::impl_avx":["#[target_feature(enable = \"avx\")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::init_chacha::impl_sse2":["#[target_feature(enable = \"sse2\")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::init_chacha_x":["#[cfg(feature = \"std\")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = \"avx\")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }\n            #[target_feature(enable = \"sse2\")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!(\"avx\") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!(\"sse2\") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::init_chacha_x::fn_impl":["#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let key0: Mach::u32x4 = m.read_le(&key[..16]);\n        let key1: Mach::u32x4 = m.read_le(&key[16..]);\n        let nonce0: Mach::u32x4 = m.read_le(&nonce[..16]);\n        let mut state = ChaCha {\n            b: key0.into(),\n            c: key1.into(),\n            d: nonce0.into(),\n        };\n        let x = refill_narrow_rounds(&mut state, rounds);\n        let ctr_nonce1 = [0, 0, read_u32le(&nonce[16..20]), read_u32le(&nonce[20..24])];\n        state.b = x.a;\n        state.c = x.d;\n        state.d = ctr_nonce1.into();\n        state\n    }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::init_chacha_x::impl_avx":["#[target_feature(enable = \"avx\")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::init_chacha_x::impl_sse2":["#[target_feature(enable = \"sse2\")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::read_u32le":["fn read_u32le(xs: &[u8]) -> u32{\n    assert_eq!(xs.len(), 4);\n    u32::from(xs[0]) | (u32::from(xs[1]) << 8) | (u32::from(xs[2]) << 16) | (u32::from(xs[3]) << 24)\n}","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::refill_narrow_rounds":["#[cfg(feature = \"std\")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = \"avx2\")]\n            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {\n                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }\n            #[target_feature(enable = \"avx\")]\n            #[target_feature(enable = \"sse4.1\")]\n            #[target_feature(enable = \"ssse3\")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }\n            #[target_feature(enable = \"sse4.1\")]\n            #[target_feature(enable = \"ssse3\")]\n            unsafe fn impl_sse41($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)\n            }\n            #[target_feature(enable = \"ssse3\")]\n            unsafe fn impl_ssse3($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)\n            }\n            #[target_feature(enable = \"sse2\")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!(\"avx2\") {\n                    impl_avx2($($arg),*)\n                } else if is_x86_feature_detected!(\"avx\") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!(\"sse4.1\") {\n                    impl_sse41($($arg),*)\n                } else if is_x86_feature_detected!(\"ssse3\") {\n                    impl_ssse3($($arg),*)\n                } else if is_x86_feature_detected!(\"sse2\") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_narrow_rounds::fn_impl":["#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let k: Mach::u32x4 = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);\n        let mut x = State {\n            a: k,\n            b: m.unpack(state.b),\n            c: m.unpack(state.c),\n            d: m.unpack(state.d),\n        };\n        for _ in 0..drounds {\n            x = round(x);\n            x = undiagonalize(round(diagonalize(x)));\n        }\n        State {\n            a: x.a.into(),\n            b: x.b.into(),\n            c: x.c.into(),\n            d: x.d.into(),\n        }\n    }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_narrow_rounds::impl_avx":["#[target_feature(enable = \"avx\")]\n#[target_feature(enable = \"sse4.1\")]\n#[target_feature(enable = \"ssse3\")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_narrow_rounds::impl_avx2":["#[target_feature(enable = \"avx2\")]\nunsafe fn impl_avx2($($arg: $argty),*) -> $ret{\n                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_narrow_rounds::impl_sse2":["#[target_feature(enable = \"sse2\")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_narrow_rounds::impl_sse41":["#[target_feature(enable = \"sse4.1\")]\n#[target_feature(enable = \"ssse3\")]\nunsafe fn impl_sse41($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_narrow_rounds::impl_ssse3":["#[target_feature(enable = \"ssse3\")]\nunsafe fn impl_ssse3($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_wide":["#[cfg(feature = \"std\")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = \"avx2\")]\n            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {\n                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }\n            #[target_feature(enable = \"avx\")]\n            #[target_feature(enable = \"sse4.1\")]\n            #[target_feature(enable = \"ssse3\")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }\n            #[target_feature(enable = \"sse4.1\")]\n            #[target_feature(enable = \"ssse3\")]\n            unsafe fn impl_sse41($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)\n            }\n            #[target_feature(enable = \"ssse3\")]\n            unsafe fn impl_ssse3($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)\n            }\n            #[target_feature(enable = \"sse2\")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!(\"avx2\") {\n                    impl_avx2($($arg),*)\n                } else if is_x86_feature_detected!(\"avx\") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!(\"sse4.1\") {\n                    impl_sse41($($arg),*)\n                } else if is_x86_feature_detected!(\"ssse3\") {\n                    impl_ssse3($($arg),*)\n                } else if is_x86_feature_detected!(\"sse2\") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_wide::fn_impl":["#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        refill_wide_impl(m, state, drounds, out);\n    }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_wide::impl_avx":["#[target_feature(enable = \"avx\")]\n#[target_feature(enable = \"sse4.1\")]\n#[target_feature(enable = \"ssse3\")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_wide::impl_avx2":["#[target_feature(enable = \"avx2\")]\nunsafe fn impl_avx2($($arg: $argty),*) -> $ret{\n                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);\n                _mm256_zeroupper();\n                ret\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_wide::impl_sse2":["#[target_feature(enable = \"sse2\")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_wide::impl_sse41":["#[target_feature(enable = \"sse4.1\")]\n#[target_feature(enable = \"ssse3\")]\nunsafe fn impl_sse41($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_wide::impl_ssse3":["#[target_feature(enable = \"ssse3\")]\nunsafe fn impl_ssse3($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::refill_wide_impl":["#[allow(clippy::many_single_char_names)]\n#[inline(always)]\nfn refill_wide_impl<Mach: Machine>(\n    m: Mach,\n    state: &mut ChaCha,\n    drounds: u32,\n    out: &mut [u32; BUFSZ],\n){\n    let k = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);\n    let b = m.unpack(state.b);\n    let c = m.unpack(state.c);\n    let mut x = State {\n        a: Mach::u32x4x4::from_lanes([k, k, k, k]),\n        b: Mach::u32x4x4::from_lanes([b, b, b, b]),\n        c: Mach::u32x4x4::from_lanes([c, c, c, c]),\n        d: d0123(m, state.d),\n    };\n    for _ in 0..drounds {\n        x = round(x);\n        x = undiagonalize(round(diagonalize(x)));\n    }\n    let kk = Mach::u32x4x4::from_lanes([k, k, k, k]);\n    let sb = m.unpack(state.b);\n    let sb = Mach::u32x4x4::from_lanes([sb, sb, sb, sb]);\n    let sc = m.unpack(state.c);\n    let sc = Mach::u32x4x4::from_lanes([sc, sc, sc, sc]);\n    let sd = d0123(m, state.d);\n    let results = Mach::u32x4x4::transpose4(x.a + kk, x.b + sb, x.c + sc, x.d + sd);\n    out[0..16].copy_from_slice(&results.0.to_scalars());\n    out[16..32].copy_from_slice(&results.1.to_scalars());\n    out[32..48].copy_from_slice(&results.2.to_scalars());\n    out[48..64].copy_from_slice(&results.3.to_scalars());\n    state.d = add_pos(m, sd.to_lanes()[0], 4).into();\n}","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::round":["#[inline(always)]\npub(crate) fn round<V: ArithOps + BitOps32>(mut x: State<V>) -> State<V>{\n    x.a += x.b;\n    x.d = (x.d ^ x.a).rotate_each_word_right16();\n    x.c += x.d;\n    x.b = (x.b ^ x.c).rotate_each_word_right20();\n    x.a += x.b;\n    x.d = (x.d ^ x.a).rotate_each_word_right24();\n    x.c += x.d;\n    x.b = (x.b ^ x.c).rotate_each_word_right25();\n    x\n}","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"],"guts::set_stream_param":["#[cfg(feature = \"std\")]\nfn $name($($arg: $argty),*) -> $ret{\n            #[inline(always)]\n            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body\n            use std::arch::x86_64::*;\n            #[target_feature(enable = \"avx\")]\n            unsafe fn impl_avx($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }\n            #[target_feature(enable = \"sse2\")]\n            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }\n            unsafe {\n                if is_x86_feature_detected!(\"avx\") {\n                    impl_avx($($arg),*)\n                } else if is_x86_feature_detected!(\"sse2\") {\n                    impl_sse2($($arg),*)\n                } else {\n                    unimplemented!()\n                }\n            }\n        }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::set_stream_param::fn_impl":["#[inline(always)]\nfn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret{\n        let d: Mach::u32x4 = m.unpack(state.d);\n        state.d = d\n            .insert((value >> 32) as u32, (param << 1) | 1)\n            .insert(value as u32, param << 1)\n            .into();\n    }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::set_stream_param::impl_avx":["#[target_feature(enable = \"avx\")]\nunsafe fn impl_avx($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::set_stream_param::impl_sse2":["#[target_feature(enable = \"sse2\")]\nunsafe fn impl_sse2($($arg: $argty),*) -> $ret{\n                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))"],"guts::undiagonalize":["#[inline(always)]\npub(crate) fn undiagonalize<V: LaneWords4>(mut x: State<V>) -> State<V>{\n    x.b = x.b.shuffle_lane_words1230();\n    x.c = x.c.shuffle_lane_words2301();\n    x.d = x.d.shuffle_lane_words3012();\n    x\n}","Real(LocalPath(\"rand_chacha/src/guts.rs\"))"]},"struct_constructor":{"&'^0.Named(DefId(0:379 ~ rand_chacha[133f]::chacha::{impl#1}::as_ref::'_), \"'_\") [T/#0]":["as_ref"],"&'^0.Named(DefId(0:380 ~ rand_chacha[133f]::chacha::{impl#2}::as_mut::'_), \"'_\") mut [T/#0]":["as_mut"],"Alias(Projection, AliasTy { args: [Mach/#0], def_id: DefId(21:282 ~ ppv_lite86[e7d0]::types::Machine::u32x4x4) })":["d0123"],"[u8; 32_usize]":["fn_impl","get_seed","impl_avx","impl_sse2"],"bool":["eq"],"chacha::Array64":["clone","default"],"chacha::ChaCha12Core":["clone","from_seed"],"chacha::ChaCha12Rng":["clone","from","from_seed"],"chacha::ChaCha20Core":["clone","from_seed"],"chacha::ChaCha20Rng":["clone","from","from_seed"],"chacha::ChaCha8Core":["clone","from_seed"],"chacha::ChaCha8Rng":["clone","from","from_seed"],"chacha::abstract12::ChaCha12Rng":["from"],"chacha::abstract20::ChaCha20Rng":["from"],"chacha::abstract8::ChaCha8Rng":["from"],"guts::ChaCha":["clone","fn_impl","impl_avx","impl_sse2","init_chacha","init_chacha_x","new"],"guts::State":["clone","fn_impl","impl_avx","impl_avx2","impl_sse2","impl_sse41","impl_ssse3","refill_narrow_rounds"],"u128":["get_word_pos"],"u32":["next_u32","read_u32le"],"u64":["fn_impl","get_block_pos","get_nonce","get_stream","get_stream_param","impl_avx","impl_sse2","next_u64"]},"struct_to_trait":{"chacha::Array64":["std::clone::Clone","std::convert::AsMut","std::convert::AsRef","std::default::Default","std::fmt::Debug"],"chacha::ChaCha12Core":["rand_core::SeedableRng","rand_core::block::BlockRngCore","rand_core::block::CryptoBlockRng","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"chacha::ChaCha12Rng":["rand_core::CryptoRng","rand_core::RngCore","rand_core::SeedableRng","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug"],"chacha::ChaCha20Core":["rand_core::SeedableRng","rand_core::block::BlockRngCore","rand_core::block::CryptoBlockRng","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"chacha::ChaCha20Rng":["rand_core::CryptoRng","rand_core::RngCore","rand_core::SeedableRng","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug"],"chacha::ChaCha8Core":["rand_core::SeedableRng","rand_core::block::BlockRngCore","rand_core::block::CryptoBlockRng","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralPartialEq"],"chacha::ChaCha8Rng":["rand_core::CryptoRng","rand_core::RngCore","rand_core::SeedableRng","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug"],"chacha::abstract12::ChaCha12Rng":["std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::marker::StructuralPartialEq"],"chacha::abstract20::ChaCha20Rng":["std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::marker::StructuralPartialEq"],"chacha::abstract8::ChaCha8Rng":["std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::marker::StructuralPartialEq"],"guts::ChaCha":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::StructuralPartialEq"],"guts::State":["std::clone::Clone"]},"targets":{"<chacha::Array64<T> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::clone::Clone"],"<chacha::Array64<T> as std::convert::AsMut<[T]>>::as_mut":["as_mut","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::AsMut"],"<chacha::Array64<T> as std::convert::AsRef<[T]>>::as_ref":["as_ref","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::AsRef"],"<chacha::Array64<T> as std::default::Default>::default":["default","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::default::Default"],"<chacha::Array64<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::fmt::Debug"],"<chacha::ChaCha12Core as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::SeedableRng"],"<chacha::ChaCha12Core as rand_core::block::BlockRngCore>::generate":["generate","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::block::BlockRngCore"],"<chacha::ChaCha12Core as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::fmt::Debug"],"<chacha::ChaCha12Rng as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::RngCore"],"<chacha::ChaCha12Rng as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::RngCore"],"<chacha::ChaCha12Rng as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::RngCore"],"<chacha::ChaCha12Rng as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::SeedableRng"],"<chacha::ChaCha12Rng as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::cmp::PartialEq"],"<chacha::ChaCha12Rng as std::convert::From<chacha::ChaCha12Core>>::from":["from","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::From"],"<chacha::ChaCha20Core as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::SeedableRng"],"<chacha::ChaCha20Core as rand_core::block::BlockRngCore>::generate":["generate","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::block::BlockRngCore"],"<chacha::ChaCha20Core as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::fmt::Debug"],"<chacha::ChaCha20Rng as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::RngCore"],"<chacha::ChaCha20Rng as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::RngCore"],"<chacha::ChaCha20Rng as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::RngCore"],"<chacha::ChaCha20Rng as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::SeedableRng"],"<chacha::ChaCha20Rng as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::cmp::PartialEq"],"<chacha::ChaCha20Rng as std::convert::From<chacha::ChaCha20Core>>::from":["from","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::From"],"<chacha::ChaCha8Core as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::SeedableRng"],"<chacha::ChaCha8Core as rand_core::block::BlockRngCore>::generate":["generate","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::block::BlockRngCore"],"<chacha::ChaCha8Core as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::fmt::Debug"],"<chacha::ChaCha8Rng as rand_core::RngCore>::fill_bytes":["fill_bytes","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::RngCore"],"<chacha::ChaCha8Rng as rand_core::RngCore>::next_u32":["next_u32","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::RngCore"],"<chacha::ChaCha8Rng as rand_core::RngCore>::next_u64":["next_u64","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::RngCore"],"<chacha::ChaCha8Rng as rand_core::SeedableRng>::from_seed":["from_seed","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","rand_core::SeedableRng"],"<chacha::ChaCha8Rng as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::cmp::PartialEq"],"<chacha::ChaCha8Rng as std::convert::From<chacha::ChaCha8Core>>::from":["from","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::From"],"<chacha::abstract12::ChaCha12Rng as std::convert::From<&chacha::ChaCha12Rng>>::from":["from","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::From"],"<chacha::abstract20::ChaCha20Rng as std::convert::From<&chacha::ChaCha20Rng>>::from":["from","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::From"],"<chacha::abstract8::ChaCha8Rng as std::convert::From<&chacha::ChaCha8Rng>>::from":["from","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::From"],"chacha::ChaCha12Rng::get_seed":["get_seed","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha12Rng::get_stream":["get_stream","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha12Rng::get_word_pos":["get_word_pos","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha12Rng::set_stream":["set_stream","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha12Rng::set_word_pos":["set_word_pos","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha20Rng::get_seed":["get_seed","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha20Rng::get_stream":["get_stream","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha20Rng::get_word_pos":["get_word_pos","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha20Rng::set_stream":["set_stream","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha20Rng::set_word_pos":["set_word_pos","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha8Rng::get_seed":["get_seed","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha8Rng::get_stream":["get_stream","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha8Rng::get_word_pos":["get_word_pos","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha8Rng::set_stream":["set_stream","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::ChaCha8Rng::set_word_pos":["set_word_pos","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))",""],"chacha::abstract12::<impl std::convert::From<&chacha::abstract12::ChaCha12Rng> for chacha::ChaCha12Rng>::from":["from","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::From"],"chacha::abstract20::<impl std::convert::From<&chacha::abstract20::ChaCha20Rng> for chacha::ChaCha20Rng>::from":["from","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::From"],"chacha::abstract8::<impl std::convert::From<&chacha::abstract8::ChaCha8Rng> for chacha::ChaCha8Rng>::from":["from","Real(LocalPath(\"rand_chacha/src/chacha.rs\"))","std::convert::From"],"guts::ChaCha::get_block_pos":["get_block_pos","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::ChaCha::get_nonce":["get_nonce","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::ChaCha::get_seed":["get_seed","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::ChaCha::new":["new","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::ChaCha::refill4":["refill4","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::ChaCha::set_block_pos":["set_block_pos","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::ChaCha::set_nonce":["set_nonce","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::add_pos":["add_pos","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::d0123":["d0123","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::diagonalize":["diagonalize","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::get_seed":["get_seed","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::get_seed::fn_impl":["fn_impl","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::get_seed::impl_avx":["impl_avx","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::get_seed::impl_sse2":["impl_sse2","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::get_stream_param":["get_stream_param","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::get_stream_param::fn_impl":["fn_impl","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::get_stream_param::impl_avx":["impl_avx","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::get_stream_param::impl_sse2":["impl_sse2","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::init_chacha":["init_chacha","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::init_chacha::fn_impl":["fn_impl","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::init_chacha::impl_avx":["impl_avx","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::init_chacha::impl_sse2":["impl_sse2","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::init_chacha_x":["init_chacha_x","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::init_chacha_x::fn_impl":["fn_impl","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::init_chacha_x::impl_avx":["impl_avx","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::init_chacha_x::impl_sse2":["impl_sse2","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::read_u32le":["read_u32le","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::refill_narrow_rounds":["refill_narrow_rounds","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_narrow_rounds::fn_impl":["fn_impl","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_narrow_rounds::impl_avx":["impl_avx","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_narrow_rounds::impl_avx2":["impl_avx2","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_narrow_rounds::impl_sse2":["impl_sse2","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_narrow_rounds::impl_sse41":["impl_sse41","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_narrow_rounds::impl_ssse3":["impl_ssse3","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_wide":["refill_wide","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_wide::fn_impl":["fn_impl","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_wide::impl_avx":["impl_avx","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_wide::impl_avx2":["impl_avx2","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_wide::impl_sse2":["impl_sse2","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_wide::impl_sse41":["impl_sse41","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_wide::impl_ssse3":["impl_ssse3","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::refill_wide_impl":["refill_wide_impl","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::round":["round","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""],"guts::set_stream_param":["set_stream_param","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::set_stream_param::fn_impl":["fn_impl","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::set_stream_param::impl_avx":["impl_avx","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::set_stream_param::impl_sse2":["impl_sse2","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ppv-lite86-0.2.21/src/x86_64/mod.rs\"))",""],"guts::undiagonalize":["undiagonalize","Real(LocalPath(\"rand_chacha/src/guts.rs\"))",""]},"trait_to_struct":{"rand_core::CryptoRng":["chacha::ChaCha12Rng","chacha::ChaCha20Rng","chacha::ChaCha8Rng"],"rand_core::RngCore":["chacha::ChaCha12Rng","chacha::ChaCha20Rng","chacha::ChaCha8Rng"],"rand_core::SeedableRng":["chacha::ChaCha12Core","chacha::ChaCha12Rng","chacha::ChaCha20Core","chacha::ChaCha20Rng","chacha::ChaCha8Core","chacha::ChaCha8Rng"],"rand_core::block::BlockRngCore":["chacha::ChaCha12Core","chacha::ChaCha20Core","chacha::ChaCha8Core"],"rand_core::block::CryptoBlockRng":["chacha::ChaCha12Core","chacha::ChaCha20Core","chacha::ChaCha8Core"],"std::clone::Clone":["chacha::Array64","chacha::ChaCha12Core","chacha::ChaCha12Rng","chacha::ChaCha20Core","chacha::ChaCha20Rng","chacha::ChaCha8Core","chacha::ChaCha8Rng","guts::ChaCha","guts::State"],"std::cmp::Eq":["chacha::ChaCha12Core","chacha::ChaCha12Rng","chacha::ChaCha20Core","chacha::ChaCha20Rng","chacha::ChaCha8Core","chacha::ChaCha8Rng","chacha::abstract12::ChaCha12Rng","chacha::abstract20::ChaCha20Rng","chacha::abstract8::ChaCha8Rng","guts::ChaCha"],"std::cmp::PartialEq":["chacha::ChaCha12Core","chacha::ChaCha12Rng","chacha::ChaCha20Core","chacha::ChaCha20Rng","chacha::ChaCha8Core","chacha::ChaCha8Rng","chacha::abstract12::ChaCha12Rng","chacha::abstract20::ChaCha20Rng","chacha::abstract8::ChaCha8Rng","guts::ChaCha"],"std::convert::AsMut":["chacha::Array64"],"std::convert::AsRef":["chacha::Array64"],"std::convert::From":["chacha::ChaCha12Rng","chacha::ChaCha20Rng","chacha::ChaCha8Rng","chacha::abstract12::ChaCha12Rng","chacha::abstract20::ChaCha20Rng","chacha::abstract8::ChaCha8Rng"],"std::default::Default":["chacha::Array64"],"std::fmt::Debug":["chacha::Array64","chacha::ChaCha12Core","chacha::ChaCha12Rng","chacha::ChaCha20Core","chacha::ChaCha20Rng","chacha::ChaCha8Core","chacha::ChaCha8Rng","chacha::abstract12::ChaCha12Rng","chacha::abstract20::ChaCha20Rng","chacha::abstract8::ChaCha8Rng"],"std::marker::StructuralPartialEq":["chacha::ChaCha12Core","chacha::ChaCha20Core","chacha::ChaCha8Core","chacha::abstract12::ChaCha12Rng","chacha::abstract20::ChaCha20Rng","chacha::abstract8::ChaCha8Rng","guts::ChaCha"]},"type_to_def_path":{"chacha::Array64<T>":"chacha::Array64","chacha::ChaCha12Core":"chacha::ChaCha12Core","chacha::ChaCha12Rng":"chacha::ChaCha12Rng","chacha::ChaCha20Core":"chacha::ChaCha20Core","chacha::ChaCha20Rng":"chacha::ChaCha20Rng","chacha::ChaCha8Core":"chacha::ChaCha8Core","chacha::ChaCha8Rng":"chacha::ChaCha8Rng","chacha::abstract12::ChaCha12Rng":"chacha::abstract12::ChaCha12Rng","chacha::abstract20::ChaCha20Rng":"chacha::abstract20::ChaCha20Rng","chacha::abstract8::ChaCha8Rng":"chacha::abstract8::ChaCha8Rng","guts::ChaCha":"guts::ChaCha","guts::State<V>":"guts::State"}}