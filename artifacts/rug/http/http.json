{
    "dependencies": {
        "<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_append": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<&'a std::string::String as header::map::as_header_name::Sealed>::as_str": [
            "std::string::String"
        ],
        "<&'a std::string::String as header::map::as_header_name::Sealed>::find": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::string::String",
            "std::vec::Vec"
        ],
        "<&'a std::string::String as header::map::as_header_name::Sealed>::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String",
            "std::vec::Vec"
        ],
        "<&'a str as header::map::as_header_name::Sealed>::as_str": [],
        "<&'a str as header::map::as_header_name::Sealed>::find": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<&'a str as header::map::as_header_name::Sealed>::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": [
            "header::map::Danger",
            "header::map::GetAll",
            "header::map::HeaderMap",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::ValueIterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<&'static str as header::map::into_header_name::Sealed>::try_append": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<&'static str as header::map::into_header_name::Sealed>::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<&'static str as header::map::into_header_name::Sealed>::try_insert": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<T as extensions::AnyClone>::as_any": [],
        "<T as extensions::AnyClone>::as_any_mut": [],
        "<T as extensions::AnyClone>::clone_box": [
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<T as extensions::AnyClone>::into_any": [
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<byte_str::ByteStr as std::clone::Clone>::clone": [
            "byte_str::ByteStr",
            "bytes::Bytes"
        ],
        "<byte_str::ByteStr as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "byte_str::ByteStr",
            "bytes::Bytes"
        ],
        "<byte_str::ByteStr as std::cmp::Ord>::cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::cmp::Ordering"
        ],
        "<byte_str::ByteStr as std::cmp::PartialEq>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes"
        ],
        "<byte_str::ByteStr as std::cmp::PartialOrd>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<byte_str::ByteStr as std::convert::From<&'a str>>::from": [
            "byte_str::ByteStr",
            "bytes::Bytes"
        ],
        "<byte_str::ByteStr as std::convert::From<std::string::String>>::from": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::string::String"
        ],
        "<byte_str::ByteStr as std::fmt::Debug>::fmt": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<byte_str::ByteStr as std::hash::Hash>::hash": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::IdHasher",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<byte_str::ByteStr as std::ops::Deref>::deref": [
            "byte_str::ByteStr",
            "bytes::Bytes"
        ],
        "<error::Error as std::convert::From<header::map::MaxSizeReached>>::from": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<error::Error as std::convert::From<method::InvalidMethod>>::from": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<error::Error as std::convert::From<status::InvalidStatusCode>>::from": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<error::Error as std::convert::From<std::convert::Infallible>>::from": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "std::convert::Infallible",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<error::Error as std::convert::From<uri::InvalidUri>>::from": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<error::Error as std::convert::From<uri::InvalidUriParts>>::from": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<error::Error as std::error::Error>::source": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "std::marker::Sized",
            "std::option::Option",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<error::Error as std::fmt::Debug>::fmt": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<error::Error as std::fmt::Display>::fmt": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<extensions::Extensions as std::clone::Clone>::clone": [
            "extensions::Extensions",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<extensions::Extensions as std::default::Default>::default": [
            "extensions::Extensions",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<extensions::Extensions as std::fmt::Debug>::fmt": [
            "extensions::Extensions",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "<extensions::IdHasher as std::default::Default>::default": [
            "extensions::IdHasher"
        ],
        "<extensions::IdHasher as std::hash::Hasher>::finish": [
            "extensions::IdHasher"
        ],
        "<extensions::IdHasher as std::hash::Hasher>::write": [
            "extensions::IdHasher"
        ],
        "<extensions::IdHasher as std::hash::Hasher>::write_u64": [
            "extensions::IdHasher"
        ],
        "<header::map::Bucket<T> as std::clone::Clone>::clone": [
            "header::map::Bucket",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::map::Bucket<T> as std::fmt::Debug>::fmt": [
            "header::map::Bucket",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "<header::map::Cursor as std::clone::Clone>::clone": [
            "header::map::Cursor"
        ],
        "<header::map::Cursor as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "header::map::Cursor"
        ],
        "<header::map::Cursor as std::cmp::PartialEq>::eq": [
            "header::map::Cursor"
        ],
        "<header::map::Cursor as std::fmt::Debug>::fmt": [
            "header::map::Cursor",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::map::Danger as std::clone::Clone>::clone": [
            "header::map::Danger",
            "std::hash::RandomState"
        ],
        "<header::map::Drain<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::fmt::Formatter",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::Drain<'a, T> as std::iter::Iterator>::next": [
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint": [
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::Drain<'a, T> as std::ops::Drop>::drop": [
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::Entry<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::Entry",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::ExtraValue<T> as std::clone::Clone>::clone": [
            "header::map::ExtraValue",
            "header::map::Link",
            "std::marker::Sized"
        ],
        "<header::map::ExtraValue<T> as std::fmt::Debug>::fmt": [
            "header::map::ExtraValue",
            "header::map::Link",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq": [
            "header::map::Danger",
            "header::map::GetAll",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::GetAll<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::GetAll",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": [
            "header::map::Danger",
            "header::map::GetAll",
            "header::map::HeaderMap",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::HashValue as std::clone::Clone>::clone": [
            "header::map::HashValue"
        ],
        "<header::map::HashValue as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "header::map::HashValue"
        ],
        "<header::map::HashValue as std::cmp::PartialEq>::eq": [
            "header::map::HashValue"
        ],
        "<header::map::HashValue as std::fmt::Debug>::fmt": [
            "header::map::HashValue",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::map::HeaderMap<T> as std::clone::Clone>::clone": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "<header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V, S>>>::try_from": [
            "std::collections::HashMap",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::map::HeaderMap<T> as std::default::Default>::default": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "<header::map::HeaderMap<T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend": [
            "header::map::Danger",
            "header::map::GetAll",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::iter::IntoIterator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend": [
            "header::map::Danger",
            "header::map::GetAll",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::iter::IntoIterator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter": [
            "header::map::Danger",
            "header::map::GetAll",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::iter::IntoIterator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IntoIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::IntoIter",
            "std::vec::Vec"
        ],
        "<header::map::HeaderMap<T> as std::ops::Index<K>>::index": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "<header::map::IntoIter<T> as std::fmt::Debug>::fmt": [
            "header::map::IntoIter",
            "std::alloc::Allocator",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::IntoIter",
            "std::vec::Vec"
        ],
        "<header::map::IntoIter<T> as std::iter::Iterator>::next": [
            "header::map::IntoIter",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::IntoIter",
            "std::vec::Vec"
        ],
        "<header::map::IntoIter<T> as std::iter::Iterator>::size_hint": [
            "header::map::IntoIter",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::IntoIter",
            "std::vec::Vec"
        ],
        "<header::map::IntoIter<T> as std::ops::Drop>::drop": [
            "header::map::IntoIter",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::IntoIter",
            "std::vec::Vec"
        ],
        "<header::map::Iter<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::Iter<'a, T> as std::iter::Iterator>::next": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::IterMut<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::IterMut<'a, T> as std::iter::Iterator>::next": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::Keys<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Keys",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "std::slice::Iter"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::count": [
            "header::map::Keys",
            "std::marker::Sized",
            "std::slice::Iter"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::last": [
            "header::map::Keys",
            "std::marker::Sized",
            "std::option::Option",
            "std::slice::Iter"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::next": [
            "header::map::Keys",
            "std::marker::Sized",
            "std::option::Option",
            "std::slice::Iter"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::nth": [
            "header::map::Keys",
            "std::marker::Sized",
            "std::option::Option",
            "std::slice::Iter"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint": [
            "header::map::Keys",
            "std::marker::Sized",
            "std::option::Option",
            "std::slice::Iter"
        ],
        "<header::map::Link as std::clone::Clone>::clone": [
            "header::map::Link"
        ],
        "<header::map::Link as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "header::map::Link"
        ],
        "<header::map::Link as std::cmp::PartialEq>::eq": [
            "header::map::Link"
        ],
        "<header::map::Link as std::fmt::Debug>::fmt": [
            "header::map::Link",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::map::Links as std::clone::Clone>::clone": [
            "header::map::Links"
        ],
        "<header::map::Links as std::fmt::Debug>::fmt": [
            "header::map::Links",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::map::MaxSizeReached as std::fmt::Debug>::fmt": [
            "header::map::MaxSizeReached",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::map::MaxSizeReached as std::fmt::Display>::fmt": [
            "header::map::MaxSizeReached",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::map::OccupiedEntry<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::ValueIterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::Pos as std::clone::Clone>::clone": [
            "header::map::HashValue",
            "header::map::Pos"
        ],
        "<header::map::RawLinks<T> as std::clone::Clone>::clone": [
            "header::map::Bucket",
            "header::map::HashValue",
            "header::map::RawLinks",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::map::RawLinks<T> as std::fmt::Debug>::fmt": [
            "header::map::Bucket",
            "header::map::HashValue",
            "header::map::RawLinks",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "<header::map::RawLinks<T> as std::ops::Index<usize>>::index": [
            "header::map::Bucket",
            "header::map::HashValue",
            "header::map::RawLinks",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut": [
            "header::map::Bucket",
            "header::map::HashValue",
            "header::map::RawLinks",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::map::VacantEntry<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::ValueDrain<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::ValueDrain",
            "std::fmt::Formatter",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next": [
            "header::map::ValueDrain",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint": [
            "header::map::ValueDrain",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop": [
            "header::map::ValueDrain",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::map::ValueIter<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::ValueIter<'a, T> as std::iter::Iterator>::next": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::ValueIterMut<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::Values<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "header::map::Values",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::Values<'a, T> as std::iter::Iterator>::next": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "header::map::Values",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::Values<'a, T> as std::iter::Iterator>::size_hint": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "header::map::Values",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::ValuesMut<'a, T> as std::fmt::Debug>::fmt": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "header::map::ValuesMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "header::map::ValuesMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "header::map::ValuesMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::map::as_header_name::TryEntryError as std::convert::From<header::map::MaxSizeReached>>::from": [
            "header::map::MaxSizeReached",
            "header::map::as_header_name::TryEntryError",
            "header::name::InvalidHeaderName"
        ],
        "<header::map::as_header_name::TryEntryError as std::convert::From<header::name::InvalidHeaderName>>::from": [
            "header::map::MaxSizeReached",
            "header::map::as_header_name::TryEntryError",
            "header::name::InvalidHeaderName"
        ],
        "<header::name::Custom as std::clone::Clone>::clone": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::name::Custom"
        ],
        "<header::name::Custom as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::name::Custom"
        ],
        "<header::name::Custom as std::cmp::PartialEq>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::name::Custom"
        ],
        "<header::name::Custom as std::fmt::Debug>::fmt": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::name::Custom",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::Custom as std::hash::Hash>::hash": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::IdHasher",
            "header::name::Custom",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from": [
            "header::name::HdrName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HdrName<'a> as std::fmt::Debug>::fmt": [
            "header::name::HdrName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::HdrName<'a> as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "header::name::HdrName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as header::map::as_header_name::Sealed>::find": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::name::HeaderName as header::map::into_header_name::Sealed>::try_append": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::name::HeaderName as std::borrow::Borrow<str>>::borrow": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::clone::Clone>::clone": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq": [
            "header::name::HdrName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<str>>::eq": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq>::eq": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::convert::AsRef<str>>::as_ref": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::convert::From<header::name::Custom>>::from": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::name::Custom",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from": [
            "header::name::HdrName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<&'a std::string::String>>::try_from": [
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<&'a str>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<std::string::String>>::try_from": [
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::name::HeaderName as std::fmt::Debug>::fmt": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::HeaderName as std::fmt::Display>::fmt": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::HeaderName as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<header::name::HeaderName as std::str::FromStr>::from_str": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::InvalidHeaderName as std::fmt::Debug>::fmt": [
            "header::name::InvalidHeaderName",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::InvalidHeaderName as std::fmt::Display>::fmt": [
            "header::name::InvalidHeaderName",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::MaybeLower<'a> as std::clone::Clone>::clone": [
            "header::name::MaybeLower"
        ],
        "<header::name::MaybeLower<'a> as std::fmt::Debug>::fmt": [
            "header::name::MaybeLower",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::MaybeLower<'a> as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "header::name::MaybeLower",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<header::name::Repr<T> as std::clone::Clone>::clone": [
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::Repr<T> as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::Repr<T> as std::cmp::PartialEq>::eq": [
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "<header::name::Repr<T> as std::fmt::Debug>::fmt": [
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::Repr<T> as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<header::name::StandardHeader as std::clone::Clone>::clone": [
            "header::name::StandardHeader"
        ],
        "<header::name::StandardHeader as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "header::name::StandardHeader"
        ],
        "<header::name::StandardHeader as std::cmp::PartialEq>::eq": [
            "header::name::StandardHeader"
        ],
        "<header::name::StandardHeader as std::fmt::Debug>::fmt": [
            "header::name::StandardHeader",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::name::StandardHeader as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "header::name::StandardHeader",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<header::value::HeaderValue as std::clone::Clone>::clone": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::cmp::Ord>::cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::cmp::Ordering"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::string::String"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq>::eq": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::option::Option",
            "std::string::String"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from": [
            "bytes::Bytes",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "header::value::HeaderValue",
            "std::marker::Sized"
        ],
        "<header::value::HeaderValue as std::convert::From<i16>>::from": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::convert::From<i32>>::from": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::convert::From<i64>>::from": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::convert::From<isize>>::from": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::convert::From<u16>>::from": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::convert::From<u32>>::from": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::convert::From<u64>>::from": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::convert::From<usize>>::from": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<&'a std::string::String>>::try_from": [
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<&'a str>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<std::string::String>>::try_from": [
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<header::value::HeaderValue as std::fmt::Debug>::fmt": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::value::HeaderValue as std::hash::Hash>::hash": [
            "bytes::Bytes",
            "extensions::IdHasher",
            "header::value::HeaderValue",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<header::value::HeaderValue as std::str::FromStr>::from_str": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt": [
            "header::value::InvalidHeaderValue",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::value::InvalidHeaderValue as std::fmt::Display>::fmt": [
            "header::value::InvalidHeaderValue",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::value::ToStrError as std::fmt::Debug>::fmt": [
            "header::value::ToStrError",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<header::value::ToStrError as std::fmt::Display>::fmt": [
            "header::value::ToStrError",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<method::Inner as std::clone::Clone>::clone": [
            "method::Inner",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Inner as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "method::Inner",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Inner as std::cmp::PartialEq>::eq": [
            "method::Inner",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Inner as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "method::Inner",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<method::InvalidMethod as std::fmt::Debug>::fmt": [
            "method::InvalidMethod",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<method::InvalidMethod as std::fmt::Display>::fmt": [
            "method::InvalidMethod",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<method::Method as std::clone::Clone>::clone": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Method as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Method as std::cmp::PartialEq<&'a str>>::eq": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Method as std::cmp::PartialEq<str>>::eq": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Method as std::cmp::PartialEq>::eq": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Method as std::convert::AsRef<str>>::as_ref": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Method as std::convert::From<&'a method::Method>>::from": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Method as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<method::Method as std::convert::TryFrom<&'a str>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<method::Method as std::default::Default>::default": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::Method as std::fmt::Debug>::fmt": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<method::Method as std::fmt::Display>::fmt": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<method::Method as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<method::Method as std::str::FromStr>::from_str": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<method::extension::AllocatedExtension as std::clone::Clone>::clone": [
            "method::extension::AllocatedExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::extension::AllocatedExtension as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "method::extension::AllocatedExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::extension::AllocatedExtension as std::cmp::PartialEq>::eq": [
            "method::extension::AllocatedExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "<method::extension::AllocatedExtension as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "method::extension::AllocatedExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<method::extension::InlineExtension as std::clone::Clone>::clone": [
            "method::extension::InlineExtension"
        ],
        "<method::extension::InlineExtension as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "method::extension::InlineExtension"
        ],
        "<method::extension::InlineExtension as std::cmp::PartialEq>::eq": [
            "method::extension::InlineExtension"
        ],
        "<method::extension::InlineExtension as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "method::extension::InlineExtension",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<request::Builder as std::default::Default>::default": [
            "request::Builder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<request::Builder as std::fmt::Debug>::fmt": [
            "request::Builder",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<request::Parts as std::clone::Clone>::clone": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "<request::Parts as std::fmt::Debug>::fmt": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "<request::Request<T> as std::clone::Clone>::clone": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "<request::Request<T> as std::default::Default>::default": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "<request::Request<T> as std::fmt::Debug>::fmt": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "<response::Builder as std::default::Default>::default": [
            "response::Builder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<response::Builder as std::fmt::Debug>::fmt": [
            "response::Builder",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<response::Parts as std::clone::Clone>::clone": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "<response::Parts as std::fmt::Debug>::fmt": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "<response::Response<T> as std::clone::Clone>::clone": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "<response::Response<T> as std::default::Default>::default": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "<response::Response<T> as std::fmt::Debug>::fmt": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::fmt::Formatter",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "<status::InvalidStatusCode as std::fmt::Debug>::fmt": [
            "status::InvalidStatusCode",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<status::InvalidStatusCode as std::fmt::Display>::fmt": [
            "status::InvalidStatusCode",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<status::StatusCode as std::clone::Clone>::clone": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "<status::StatusCode as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "<status::StatusCode as std::cmp::Ord>::cmp": [
            "status::StatusCode",
            "std::cmp::Ordering",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "<status::StatusCode as std::cmp::PartialEq<u16>>::eq": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "<status::StatusCode as std::cmp::PartialEq>::eq": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "<status::StatusCode as std::cmp::PartialOrd>::partial_cmp": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option"
        ],
        "<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "<status::StatusCode as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<status::StatusCode as std::convert::TryFrom<&'a str>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<status::StatusCode as std::convert::TryFrom<u16>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<status::StatusCode as std::default::Default>::default": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "<status::StatusCode as std::fmt::Debug>::fmt": [
            "status::StatusCode",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::result::Result"
        ],
        "<status::StatusCode as std::fmt::Display>::fmt": [
            "status::StatusCode",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::result::Result"
        ],
        "<status::StatusCode as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "status::StatusCode",
            "std::hash::Hasher",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "<status::StatusCode as std::str::FromStr>::from_str": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<std::string::String as header::map::as_header_name::Sealed>::as_str": [
            "std::string::String"
        ],
        "<std::string::String as header::map::as_header_name::Sealed>::find": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::string::String",
            "std::vec::Vec"
        ],
        "<std::string::String as header::map::as_header_name::Sealed>::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String",
            "std::vec::Vec"
        ],
        "<uri::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "uri::ErrorKind"
        ],
        "<uri::ErrorKind as std::cmp::PartialEq>::eq": [
            "uri::ErrorKind"
        ],
        "<uri::ErrorKind as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::ErrorKind"
        ],
        "<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from": [
            "uri::ErrorKind",
            "uri::InvalidUri"
        ],
        "<uri::InvalidUri as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::ErrorKind",
            "uri::InvalidUri"
        ],
        "<uri::InvalidUri as std::fmt::Display>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::ErrorKind",
            "uri::InvalidUri"
        ],
        "<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from": [
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<uri::InvalidUriParts as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<uri::InvalidUriParts as std::fmt::Display>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "<uri::Parts as std::convert::From<uri::Uri>>::from": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::Parts",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Parts as std::default::Default>::default": [
            "std::marker::Sized",
            "std::option::Option",
            "uri::Parts"
        ],
        "<uri::Parts as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "uri::Parts"
        ],
        "<uri::Uri as std::clone::Clone>::clone": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::cmp::PartialEq<&'a str>>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::cmp::PartialEq<str>>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::cmp::PartialEq>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::convert::From<uri::authority::Authority>>::from": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::convert::From<uri::path::PathAndQuery>>::from": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a std::string::String>>::try_from": [
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a str>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a uri::Uri>>::try_from": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::result::Result",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::convert::TryFrom<std::string::String>>::try_from": [
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String"
        ],
        "<uri::Uri as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<uri::Uri as std::convert::TryFrom<uri::Parts>>::try_from": [
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "uri::Parts"
        ],
        "<uri::Uri as std::default::Default>::default": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::fmt::Debug>::fmt": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::fmt::Display>::fmt": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::hash::Hash>::hash": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::IdHasher",
            "std::hash::Hasher",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::Uri as std::str::FromStr>::from_str": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::authority::Authority as std::clone::Clone>::clone": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::string::String",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq<str>>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "std::string::String",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::convert::AsRef<str>>::as_ref": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<&'a str>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<std::string::String>>::try_from": [
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<uri::authority::Authority as std::fmt::Debug>::fmt": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::fmt::Display>::fmt": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::hash::Hash>::hash": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::IdHasher",
            "std::hash::Hasher",
            "std::marker::Sized",
            "uri::authority::Authority"
        ],
        "<uri::authority::Authority as std::str::FromStr>::from_str": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::builder::Builder as std::convert::From<uri::Uri>>::from": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::result::Result",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::builder::Builder",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::builder::Builder as std::default::Default>::default": [
            "std::marker::Sized",
            "std::result::Result",
            "uri::builder::Builder"
        ],
        "<uri::builder::Builder as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::builder::Builder"
        ],
        "<uri::path::PathAndQuery as std::clone::Clone>::clone": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::string::String",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "std::string::String",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<&'a str>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<&std::string::String>>::try_from": [
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<std::string::String>>::try_from": [
            "std::marker::Sized",
            "std::result::Result",
            "std::string::String"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<uri::path::PathAndQuery as std::fmt::Debug>::fmt": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::fmt::Display>::fmt": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::hash::Hash>::hash": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::IdHasher",
            "std::hash::Hasher",
            "std::marker::Sized",
            "uri::path::PathAndQuery"
        ],
        "<uri::path::PathAndQuery as std::str::FromStr>::from_str": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq": [
            "std::marker::Sized",
            "uri::port::Port"
        ],
        "<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq": [
            "std::marker::Sized",
            "uri::port::Port"
        ],
        "<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref": [
            "std::marker::Sized",
            "uri::port::Port"
        ],
        "<uri::port::Port<T> as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::port::Port"
        ],
        "<uri::port::Port<T> as std::fmt::Display>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::port::Port"
        ],
        "<uri::scheme::Protocol as std::clone::Clone>::clone": [
            "uri::scheme::Protocol"
        ],
        "<uri::scheme::Protocol as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::scheme::Protocol"
        ],
        "<uri::scheme::Scheme as std::clone::Clone>::clone": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::scheme::Scheme as std::cmp::PartialEq>::eq": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::scheme::Scheme as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::scheme::Scheme as std::convert::TryFrom<&'a str>>::try_from": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::scheme::Scheme as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::scheme::Scheme as std::fmt::Display>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::scheme::Scheme as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "std::hash::Hasher",
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "<uri::scheme::Scheme as std::str::FromStr>::from_str": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<uri::scheme::Scheme2<T> as std::clone::Clone>::clone": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme2"
        ],
        "<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme2"
        ],
        "<uri::scheme::Scheme2<T> as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme2"
        ],
        "<version::Http as std::clone::Clone>::clone": [
            "version::Http"
        ],
        "<version::Http as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "version::Http"
        ],
        "<version::Http as std::cmp::Ord>::cmp": [
            "std::cmp::Ordering",
            "version::Http"
        ],
        "<version::Http as std::cmp::PartialEq>::eq": [
            "version::Http"
        ],
        "<version::Http as std::cmp::PartialOrd>::partial_cmp": [
            "std::marker::Sized",
            "std::option::Option",
            "version::Http"
        ],
        "<version::Http as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "std::hash::Hasher",
            "std::marker::Sized",
            "version::Http"
        ],
        "<version::Version as std::clone::Clone>::clone": [
            "version::Http",
            "version::Version"
        ],
        "<version::Version as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "version::Http",
            "version::Version"
        ],
        "<version::Version as std::cmp::Ord>::cmp": [
            "std::cmp::Ordering",
            "version::Http",
            "version::Version"
        ],
        "<version::Version as std::cmp::PartialEq>::eq": [
            "version::Http",
            "version::Version"
        ],
        "<version::Version as std::cmp::PartialOrd>::partial_cmp": [
            "std::marker::Sized",
            "std::option::Option",
            "version::Http",
            "version::Version"
        ],
        "<version::Version as std::default::Default>::default": [
            "version::Http",
            "version::Version"
        ],
        "<version::Version as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "version::Http",
            "version::Version"
        ],
        "<version::Version as std::hash::Hash>::hash": [
            "extensions::IdHasher",
            "std::hash::Hasher",
            "std::marker::Sized",
            "version::Http",
            "version::Version"
        ],
        "byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from": [
            "byte_str::ByteStr",
            "bytes::Bytes"
        ],
        "byte_str::ByteStr": [
            "byte_str::ByteStr",
            "bytes::Bytes"
        ],
        "byte_str::ByteStr::from_static": [
            "byte_str::ByteStr",
            "bytes::Bytes"
        ],
        "byte_str::ByteStr::from_utf8": [
            "bytes::Bytes",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "byte_str::ByteStr::from_utf8_unchecked": [
            "byte_str::ByteStr",
            "bytes::Bytes"
        ],
        "byte_str::ByteStr::new": [
            "byte_str::ByteStr",
            "bytes::Bytes"
        ],
        "error::Error": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "error::Error::get_ref": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "error::Error::is": [
            "error::Error",
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "std::error::Error",
            "std::marker::Sized",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "error::ErrorKind": [
            "error::ErrorKind",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "extensions::<impl std::clone::Clone for std::boxed::Box<(dyn extensions::AnyClone + std::marker::Send + std::marker::Sync + 'static)>>::clone": [
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "extensions::AnyClone::as_any": [],
        "extensions::AnyClone::as_any_mut": [],
        "extensions::AnyClone::clone_box": [
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "extensions::AnyClone::into_any": [
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "extensions::Extensions": [
            "extensions::Extensions",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "extensions::Extensions::clear": [
            "extensions::Extensions",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "extensions::Extensions::extend": [
            "extensions::Extensions",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "extensions::Extensions::get": [
            "extensions::Extensions",
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::marker::PhantomData",
            "std::marker::Send",
            "std::marker::Sized",
            "std::marker::Sync",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "extensions::Extensions::get_mut": [
            "extensions::Extensions",
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::marker::PhantomData",
            "std::marker::Send",
            "std::marker::Sized",
            "std::marker::Sync",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "extensions::Extensions::get_or_insert": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::clone::Clone",
            "std::marker::PhantomData",
            "std::marker::Send",
            "std::marker::Sized",
            "std::marker::Sync",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "extensions::Extensions::get_or_insert_default": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::clone::Clone",
            "std::default::Default",
            "std::marker::PhantomData",
            "std::marker::Send",
            "std::marker::Sized",
            "std::marker::Sync",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "extensions::Extensions::get_or_insert_with": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::clone::Clone",
            "std::marker::PhantomData",
            "std::marker::Send",
            "std::marker::Sized",
            "std::marker::Sync",
            "std::ops::FnOnce",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "extensions::Extensions::insert": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::clone::Clone",
            "std::marker::PhantomData",
            "std::marker::Send",
            "std::marker::Sized",
            "std::marker::Sync",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "extensions::Extensions::is_empty": [
            "extensions::Extensions",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "extensions::Extensions::len": [
            "extensions::Extensions",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "extensions::Extensions::new": [
            "extensions::Extensions",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "extensions::Extensions::remove": [
            "extensions::Extensions",
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::marker::PhantomData",
            "std::marker::Send",
            "std::marker::Sized",
            "std::marker::Sync",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "extensions::IdHasher": [
            "extensions::IdHasher"
        ],
        "header::map::Bucket": [
            "header::map::Bucket",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "header::map::Cursor": [
            "header::map::Cursor"
        ],
        "header::map::Danger": [
            "header::map::Danger",
            "std::hash::RandomState"
        ],
        "header::map::Danger::is_red": [
            "header::map::Danger",
            "std::hash::RandomState"
        ],
        "header::map::Danger::is_yellow": [
            "header::map::Danger",
            "std::hash::RandomState"
        ],
        "header::map::Danger::set_green": [
            "header::map::Danger",
            "std::hash::RandomState"
        ],
        "header::map::Danger::set_red": [
            "header::map::Danger",
            "std::hash::RandomState"
        ],
        "header::map::Danger::set_yellow": [
            "header::map::Danger",
            "std::hash::RandomState"
        ],
        "header::map::Drain": [
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::Entry": [
            "header::map::Danger",
            "header::map::Entry",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::Entry::<'a, T>::key": [
            "header::map::Danger",
            "header::map::Entry",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::Entry::<'a, T>::or_insert": [
            "header::map::Danger",
            "header::map::Entry",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::Entry::<'a, T>::or_insert_with": [
            "header::map::Danger",
            "header::map::Entry",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::ops::FnOnce",
            "std::vec::Vec"
        ],
        "header::map::Entry::<'a, T>::or_try_insert": [
            "header::map::Danger",
            "header::map::Entry",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::Entry::<'a, T>::or_try_insert_with": [
            "header::map::Danger",
            "header::map::Entry",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::ops::FnOnce",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::ExtraValue": [
            "header::map::ExtraValue",
            "header::map::Link",
            "std::marker::Sized"
        ],
        "header::map::GetAll": [
            "header::map::Danger",
            "header::map::GetAll",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::GetAll::<'a, T>::iter": [
            "header::map::Danger",
            "header::map::GetAll",
            "header::map::HeaderMap",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HashValue": [
            "header::map::HashValue"
        ],
        "header::map::HeaderMap": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::append": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::into_header_name::IntoHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::capacity": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::clear": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::contains_key": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::as_header_name::AsHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::drain": [
            "header::map::Bucket",
            "header::map::Danger",
            "header::map::Drain",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::entry": [
            "header::map::Danger",
            "header::map::Entry",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::VacantEntry",
            "header::map::into_header_name::IntoHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::find": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::cmp::PartialEq",
            "std::convert::Into",
            "std::hash::Hash",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::get": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::as_header_name::AsHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::get2": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::as_header_name::AsHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::get_all": [
            "header::map::Danger",
            "header::map::GetAll",
            "header::map::HeaderMap",
            "header::map::as_header_name::AsHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::get_mut": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::as_header_name::AsHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::insert": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::into_header_name::IntoHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::insert_occupied": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::insert_occupied_mult": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueDrain",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::is_empty": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::iter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::iter_mut": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::keys": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Keys",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::slice::Iter",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::keys_len": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::len": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::raw_links": [
            "header::map::Bucket",
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::RawLinks",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::rebuild": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::reinsert_entry_in_order": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::Pos",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::remove": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::as_header_name::AsHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::remove_all_extra_values": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::remove_extra_value": [
            "header::map::Danger",
            "header::map::ExtraValue",
            "header::map::HeaderMap",
            "header::map::Link",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::remove_found": [
            "header::map::Bucket",
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::reserve": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_append": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::into_header_name::IntoHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_append2": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::cmp::PartialEq",
            "std::convert::Into",
            "std::hash::Hash",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::as_header_name::AsHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_entry2": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::cmp::PartialEq",
            "std::convert::Into",
            "std::hash::Hash",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_grow": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_insert": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::into_header_name::IntoHeaderName",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_insert2": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::cmp::PartialEq",
            "std::convert::Into",
            "std::hash::Hash",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_insert_entry": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_insert_phase_two": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_reserve": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_reserve_one": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::try_with_capacity": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "header::map::HeaderMap::<T>::value_iter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::value_iter_mut": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::values": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "header::map::Values",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::values_mut": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "header::map::ValuesMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::<T>::with_capacity": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::HeaderMap::new": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::IntoIter": [
            "header::map::IntoIter",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::IntoIter",
            "std::vec::Vec"
        ],
        "header::map::Iter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::IterMut": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::IterMut::<'a, T>::next_unsafe": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::Keys": [
            "header::map::Keys",
            "std::marker::Sized",
            "std::slice::Iter"
        ],
        "header::map::Link": [
            "header::map::Link"
        ],
        "header::map::Links": [
            "header::map::Links"
        ],
        "header::map::MaxSizeReached": [
            "header::map::MaxSizeReached"
        ],
        "header::map::MaxSizeReached::new": [
            "header::map::MaxSizeReached"
        ],
        "header::map::OccupiedEntry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::append": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::get": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::get_mut": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::insert": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::insert_mult": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::ValueDrain",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::into_mut": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::iter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::iter_mut": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::ValueIterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::key": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::remove": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::remove_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::OccupiedEntry::<'a, T>::remove_entry_mult": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::ValueDrain",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::Pos": [
            "header::map::HashValue",
            "header::map::Pos"
        ],
        "header::map::Pos::is_none": [
            "header::map::HashValue",
            "header::map::Pos"
        ],
        "header::map::Pos::is_some": [
            "header::map::HashValue",
            "header::map::Pos"
        ],
        "header::map::Pos::new": [
            "header::map::HashValue",
            "header::map::Pos"
        ],
        "header::map::Pos::none": [
            "header::map::HashValue",
            "header::map::Pos"
        ],
        "header::map::Pos::resolve": [
            "header::map::HashValue",
            "header::map::Pos",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "header::map::RawLinks": [
            "header::map::Bucket",
            "header::map::HashValue",
            "header::map::RawLinks",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "header::map::VacantEntry": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::VacantEntry::<'a, T>::insert": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::VacantEntry::<'a, T>::insert_entry": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::VacantEntry::<'a, T>::into_key": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::VacantEntry::<'a, T>::key": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "header::map::VacantEntry::<'a, T>::try_insert": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::VacantEntry::<'a, T>::try_insert_entry": [
            "header::map::Danger",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::VacantEntry",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::ValueDrain": [
            "header::map::ValueDrain",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "header::map::ValueIter": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIter",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::ValueIterMut": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::ValueIterMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::Values": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::Iter",
            "header::map::Values",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::ValuesMut": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "header::map::IterMut",
            "header::map::ValuesMut",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::PhantomData",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::append_value": [
            "header::map::Bucket",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::as_header_name::Sealed::as_str": [],
        "header::map::as_header_name::Sealed::find": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::as_header_name::Sealed::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::as_header_name::TryEntryError": [
            "header::map::MaxSizeReached",
            "header::map::as_header_name::TryEntryError",
            "header::name::InvalidHeaderName"
        ],
        "header::map::desired_pos": [
            "header::map::HashValue"
        ],
        "header::map::do_insert_phase_two": [
            "header::map::HashValue",
            "header::map::Pos"
        ],
        "header::map::drain_all_extra_values": [
            "header::map::Bucket",
            "header::map::HashValue",
            "header::map::RawLinks",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::hash_elem_using": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::map::Danger",
            "header::map::HashValue",
            "std::hash::Hash",
            "std::hash::RandomState"
        ],
        "header::map::into_header_name::Sealed::try_append": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::into_header_name::Sealed::try_entry": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::into_header_name::Sealed::try_insert": [
            "header::map::Danger",
            "header::map::HeaderMap",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "header::map::probe_distance": [
            "header::map::HashValue"
        ],
        "header::map::remove_extra_value": [
            "header::map::Bucket",
            "header::map::ExtraValue",
            "header::map::HashValue",
            "header::map::Link",
            "header::map::RawLinks",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "header::map::to_raw_capacity": [],
        "header::map::usable_capacity": [],
        "header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::name::Custom"
        ],
        "header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from": [
            "bytes::Bytes",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "header::name::Custom": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::name::Custom"
        ],
        "header::name::HdrName": [
            "header::name::HdrName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "header::name::HdrName::<'a>::custom": [
            "header::name::HdrName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "header::name::HdrName::<'a>::from_bytes": [
            "std::marker::Sized",
            "std::ops::FnOnce",
            "std::result::Result"
        ],
        "header::name::HdrName::<'a>::from_static": [
            "std::marker::Sized",
            "std::ops::FnOnce"
        ],
        "header::name::HeaderName": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "header::name::HeaderName::as_str": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "header::name::HeaderName::from_bytes": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "header::name::HeaderName::from_lowercase": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "header::name::HeaderName::from_static": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "header::name::HeaderName::into_bytes": [
            "bytes::Bytes",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "header::name::InvalidHeaderName": [
            "header::name::InvalidHeaderName"
        ],
        "header::name::InvalidHeaderName::new": [
            "header::name::InvalidHeaderName"
        ],
        "header::name::MaybeLower": [
            "header::name::MaybeLower"
        ],
        "header::name::Repr": [
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::marker::Sized"
        ],
        "header::name::StandardHeader": [
            "header::name::StandardHeader"
        ],
        "header::name::StandardHeader::as_str": [
            "header::name::StandardHeader"
        ],
        "header::name::StandardHeader::from_bytes": [
            "std::marker::Sized",
            "std::option::Option"
        ],
        "header::name::eq_ignore_ascii_case": [],
        "header::name::parse_hdr": [
            "std::marker::Sized",
            "std::mem::MaybeUninit",
            "std::result::Result"
        ],
        "header::name::slice_assume_init": [
            "std::marker::Sized",
            "std::mem::MaybeUninit"
        ],
        "header::name::uninit_u8_array": [
            "std::marker::Sized",
            "std::mem::MaybeUninit"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::string::String"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::option::Option",
            "std::string::String"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "header::value::HeaderValue": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "header::value::HeaderValue::as_bytes": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "header::value::HeaderValue::from_bytes": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "header::value::HeaderValue::from_maybe_shared": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::convert::AsRef",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "header::value::HeaderValue::from_maybe_shared_unchecked": [
            "bytes::Bytes",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "header::value::HeaderValue",
            "std::convert::AsRef",
            "std::marker::Sized"
        ],
        "header::value::HeaderValue::from_name": [
            "bytes::Bytes",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "header::value::HeaderValue",
            "std::marker::Sized"
        ],
        "header::value::HeaderValue::from_shared": [
            "bytes::Bytes",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "header::value::HeaderValue::from_static": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "header::value::HeaderValue::from_str": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "header::value::HeaderValue::is_empty": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "header::value::HeaderValue::is_sensitive": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "header::value::HeaderValue::len": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "header::value::HeaderValue::set_sensitive": [
            "bytes::Bytes",
            "header::value::HeaderValue"
        ],
        "header::value::HeaderValue::to_str": [
            "bytes::Bytes",
            "header::value::HeaderValue",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "header::value::HeaderValue::try_from_generic": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::convert::AsRef",
            "std::marker::Sized",
            "std::ops::FnOnce",
            "std::result::Result"
        ],
        "header::value::InvalidHeaderValue": [
            "header::value::InvalidHeaderValue"
        ],
        "header::value::ToStrError": [
            "header::value::ToStrError"
        ],
        "header::value::is_valid": [],
        "header::value::is_visible_ascii": [],
        "method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "method::<impl std::cmp::PartialEq<method::Method> for str>::eq": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "method::Inner": [
            "method::Inner",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "method::InvalidMethod": [
            "method::InvalidMethod"
        ],
        "method::InvalidMethod::new": [
            "method::InvalidMethod"
        ],
        "method::Method": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "method::Method::as_str": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "method::Method::extension_inline": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "method::Method::from_bytes": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "method::Method::is_idempotent": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "method::Method::is_safe": [
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "method::extension::AllocatedExtension": [
            "method::extension::AllocatedExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "method::extension::AllocatedExtension::as_str": [
            "method::extension::AllocatedExtension",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::marker::Sized"
        ],
        "method::extension::AllocatedExtension::new": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "method::extension::InlineExtension": [
            "method::extension::InlineExtension"
        ],
        "method::extension::InlineExtension::as_str": [
            "method::extension::InlineExtension"
        ],
        "method::extension::InlineExtension::new": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "method::extension::write_checked": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Builder": [
            "request::Builder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Builder::and_then": [
            "request::Builder",
            "std::marker::Sized",
            "std::ops::FnOnce",
            "std::result::Result"
        ],
        "request::Builder::body": [
            "request::Builder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Builder::extension": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "request::Builder",
            "std::alloc::Allocator",
            "std::any::Any",
            "std::clone::Clone",
            "std::marker::PhantomData",
            "std::marker::Send",
            "std::marker::Sized",
            "std::marker::Sync",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "request::Builder::extensions_mut": [
            "request::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "request::Builder::extensions_ref": [
            "request::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "request::Builder::header": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Builder::headers_mut": [
            "request::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "request::Builder::headers_ref": [
            "request::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "request::Builder::method": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Builder::method_ref": [
            "request::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "request::Builder::new": [
            "request::Builder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Builder::uri": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Builder::uri_ref": [
            "request::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "request::Builder::version": [
            "request::Builder",
            "std::marker::Sized",
            "std::result::Result",
            "version::Http",
            "version::Version"
        ],
        "request::Builder::version_ref": [
            "request::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "request::Parts": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Parts::new": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<()>::builder": [
            "request::Builder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Request::<()>::connect": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Request::<()>::delete": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Request::<()>::get": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Request::<()>::head": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Request::<()>::options": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Request::<()>::patch": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Request::<()>::post": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Request::<()>::put": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Request::<()>::trace": [
            "request::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "request::Request::<T>::body": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::body_mut": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::extensions": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::extensions_mut": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::from_parts": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::headers": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::headers_mut": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::into_body": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::into_parts": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::map": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::ops::FnOnce",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::method": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::method_mut": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::new": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::uri": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::uri_mut": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::version": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "request::Request::<T>::version_mut": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "response::Builder": [
            "response::Builder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "response::Builder::and_then": [
            "response::Builder",
            "std::marker::Sized",
            "std::ops::FnOnce",
            "std::result::Result"
        ],
        "response::Builder::body": [
            "response::Builder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "response::Builder::extension": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "header::map::Bucket",
            "header::map::Drain",
            "header::map::HashValue",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "response::Builder",
            "std::alloc::Allocator",
            "std::any::Any",
            "std::clone::Clone",
            "std::marker::PhantomData",
            "std::marker::Send",
            "std::marker::Sized",
            "std::marker::Sync",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "response::Builder::extensions_mut": [
            "response::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "response::Builder::extensions_ref": [
            "response::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "response::Builder::header": [
            "response::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "response::Builder::headers_mut": [
            "response::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "response::Builder::headers_ref": [
            "response::Builder",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "response::Builder::new": [
            "response::Builder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "response::Builder::status": [
            "response::Builder",
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "response::Builder::version": [
            "response::Builder",
            "std::marker::Sized",
            "std::result::Result",
            "version::Http",
            "version::Version"
        ],
        "response::Parts": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Parts::new": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<()>::builder": [
            "response::Builder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "response::Response::<T>::body": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::body_mut": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::extensions": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::extensions_mut": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::from_parts": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::headers": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::headers_mut": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::into_body": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::into_parts": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::map": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::ops::FnOnce",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::new": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::status": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::status_mut": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::version": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "response::Response::<T>::version_mut": [
            "extensions::Extensions",
            "header::map::Danger",
            "header::map::HeaderMap",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::alloc::Allocator",
            "std::boxed::Box",
            "std::hash::RandomState",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option",
            "std::vec::Vec",
            "version::Http",
            "version::Version"
        ],
        "status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "status::<impl std::convert::From<status::StatusCode> for u16>::from": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "status::InvalidStatusCode": [
            "status::InvalidStatusCode"
        ],
        "status::InvalidStatusCode::new": [
            "status::InvalidStatusCode"
        ],
        "status::StatusCode": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "status::StatusCode::as_str": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "status::StatusCode::as_u16": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "status::StatusCode::canonical_reason": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive",
            "std::option::Option"
        ],
        "status::StatusCode::from_bytes": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "status::StatusCode::from_u16": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "status::StatusCode::is_client_error": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "status::StatusCode::is_informational": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "status::StatusCode::is_redirection": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "status::StatusCode::is_server_error": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "status::StatusCode::is_success": [
            "status::StatusCode",
            "std::marker::Sized",
            "std::num::NonZero",
            "std::num::ZeroablePrimitive"
        ],
        "status::canonical_reason": [
            "std::marker::Sized",
            "std::option::Option"
        ],
        "uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::ErrorKind": [
            "uri::ErrorKind"
        ],
        "uri::InvalidUri": [
            "uri::ErrorKind",
            "uri::InvalidUri"
        ],
        "uri::InvalidUri::s": [
            "uri::ErrorKind",
            "uri::InvalidUri"
        ],
        "uri::InvalidUriParts": [
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "uri::Parts": [
            "std::marker::Sized",
            "std::option::Option",
            "uri::Parts"
        ],
        "uri::Uri": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::authority": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::builder": [
            "std::marker::Sized",
            "std::result::Result",
            "uri::builder::Builder"
        ],
        "uri::Uri::from_maybe_shared": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::convert::AsRef",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::Uri::from_parts": [
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "uri::Parts"
        ],
        "uri::Uri::from_shared": [
            "bytes::Bytes",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::Uri::from_static": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::has_path": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::host": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::into_parts": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::Parts",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::path": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::path_and_query": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::port": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::port_u16": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::query": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::scheme": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::Uri::scheme_str": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::string::String",
            "uri::authority::Authority"
        ],
        "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::authority::Authority"
        ],
        "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "std::string::String",
            "uri::authority::Authority"
        ],
        "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::authority::Authority"
        ],
        "uri::authority::Authority": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "uri::authority::Authority::as_str": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "uri::authority::Authority::empty": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "uri::authority::Authority::from_maybe_shared": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::convert::AsRef",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::authority::Authority::from_shared": [
            "bytes::Bytes",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::authority::Authority::from_static": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "uri::authority::Authority::host": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::authority::Authority"
        ],
        "uri::authority::Authority::parse": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::authority::Authority::parse_non_empty": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::authority::Authority::port": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::authority::Authority"
        ],
        "uri::authority::Authority::port_u16": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::authority::Authority"
        ],
        "uri::authority::create_authority": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::convert::AsRef",
            "std::marker::Sized",
            "std::ops::FnOnce",
            "std::result::Result"
        ],
        "uri::authority::host": [],
        "uri::builder::Builder": [
            "std::marker::Sized",
            "std::result::Result",
            "uri::builder::Builder"
        ],
        "uri::builder::Builder::authority": [
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result",
            "uri::builder::Builder"
        ],
        "uri::builder::Builder::build": [
            "std::marker::Sized",
            "std::result::Result",
            "uri::builder::Builder"
        ],
        "uri::builder::Builder::map": [
            "std::marker::Sized",
            "std::ops::FnOnce",
            "std::result::Result",
            "uri::builder::Builder"
        ],
        "uri::builder::Builder::new": [
            "std::marker::Sized",
            "std::result::Result",
            "uri::builder::Builder"
        ],
        "uri::builder::Builder::path_and_query": [
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result",
            "uri::builder::Builder"
        ],
        "uri::builder::Builder::scheme": [
            "std::convert::Into",
            "std::convert::TryInto",
            "std::marker::Sized",
            "std::result::Result",
            "uri::builder::Builder"
        ],
        "uri::parse_full": [
            "bytes::Bytes",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::string::String",
            "uri::path::PathAndQuery"
        ],
        "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::path::PathAndQuery"
        ],
        "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "std::string::String",
            "uri::path::PathAndQuery"
        ],
        "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::path::PathAndQuery"
        ],
        "uri::path::PathAndQuery": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "uri::path::PathAndQuery::as_str": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "uri::path::PathAndQuery::empty": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "uri::path::PathAndQuery::from_maybe_shared": [
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "std::convert::AsRef",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::path::PathAndQuery::from_shared": [
            "bytes::Bytes",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::path::PathAndQuery::from_static": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "uri::path::PathAndQuery::path": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "uri::path::PathAndQuery::query": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "std::marker::Sized",
            "std::option::Option",
            "uri::path::PathAndQuery"
        ],
        "uri::path::PathAndQuery::slash": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "uri::path::PathAndQuery::star": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "uri::path::PathAndQuery"
        ],
        "uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq": [
            "std::marker::Sized",
            "uri::port::Port"
        ],
        "uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from": [
            "std::marker::Sized",
            "uri::port::Port"
        ],
        "uri::port::Port": [
            "std::marker::Sized",
            "uri::port::Port"
        ],
        "uri::port::Port::<T>::as_str": [
            "std::marker::Sized",
            "uri::port::Port"
        ],
        "uri::port::Port::<T>::as_u16": [
            "std::marker::Sized",
            "uri::port::Port"
        ],
        "uri::port::Port::<T>::from_str": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::scheme::Protocol": [
            "uri::scheme::Protocol"
        ],
        "uri::scheme::Protocol::len": [
            "uri::scheme::Protocol"
        ],
        "uri::scheme::Scheme": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::scheme::Scheme2": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme2"
        ],
        "uri::scheme::Scheme2::<T>::is_none": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme2"
        ],
        "uri::scheme::Scheme2::<usize>::parse": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::scheme::Scheme2::<usize>::parse_exact": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "uri::scheme::Scheme::as_str": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "uri::scheme::Scheme::empty": [
            "std::marker::Sized",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "version::Http": [
            "version::Http"
        ],
        "version::Version": [
            "version::Http",
            "version::Version"
        ]
    },
    "glob_path_import": {},
    "self_to_fn": {
        "<T as extensions::AnyClone>::T": [
            "impl<T: Clone + Send + Sync + 'static> AnyClone for T {\n    fn clone_box(&self) -> Box<dyn AnyClone + Send + Sync> {\n        Box::new(self.clone())\n    }\n\n    fn as_any(&self) -> &dyn Any {\n        self\n    }\n\n    fn as_any_mut(&mut self) -> &mut dyn Any {\n        self\n    }\n\n    fn into_any(self: Box<Self>) -> Box<dyn Any> {\n        self\n    }\n}"
        ],
        "byte_str::ByteStr": [
            "Clone",
            "Debug",
            "Eq",
            "Hash",
            "Ord",
            "PartialEq",
            "PartialOrd",
            "impl ByteStr {\n    #[inline]\n    pub fn new() -> ByteStr {\n        ByteStr {\n            // Invariant: the empty slice is trivially valid UTF-8.\n            bytes: Bytes::new(),\n        }\n    }\n\n    #[inline]\n    pub const fn from_static(val: &'static str) -> ByteStr {\n        ByteStr {\n            // Invariant: val is a str so contains valid UTF-8.\n            bytes: Bytes::from_static(val.as_bytes()),\n        }\n    }\n\n    #[inline]\n    /// ## Panics\n    /// In a debug build this will panic if `bytes` is not valid UTF-8.\n    ///\n    /// ## Safety\n    /// `bytes` must contain valid UTF-8. In a release build it is undefined\n    /// behavior to call this with `bytes` that is not valid UTF-8.\n    pub unsafe fn from_utf8_unchecked(bytes: Bytes) -> ByteStr {\n        if cfg!(debug_assertions) {\n            match str::from_utf8(&bytes) {\n                Ok(_) => (),\n                Err(err) => panic!(\n                    \"ByteStr::from_utf8_unchecked() with invalid bytes; error = {}, bytes = {:?}\",\n                    err, bytes\n                ),\n            }\n        }\n        // Invariant: assumed by the safety requirements of this function.\n        ByteStr { bytes }\n    }\n\n    pub(crate) fn from_utf8(bytes: Bytes) -> Result<ByteStr, std::str::Utf8Error> {\n        str::from_utf8(&bytes)?;\n        // Invariant: just checked is utf8\n        Ok(ByteStr { bytes })\n    }\n}",
            "impl From<String> for ByteStr {\n    #[inline]\n    fn from(src: String) -> ByteStr {\n        ByteStr {\n            // Invariant: src is a String so contains valid UTF-8.\n            bytes: Bytes::from(src),\n        }\n    }\n}",
            "impl ops::Deref for ByteStr {\n    type Target = str;\n\n    #[inline]\n    fn deref(&self) -> &str {\n        let b: &[u8] = self.bytes.as_ref();\n        // Safety: the invariant of `bytes` is that it contains valid UTF-8.\n        unsafe { str::from_utf8_unchecked(b) }\n    }\n}",
            "impl<'a> From<&'a str> for ByteStr {\n    #[inline]\n    fn from(src: &'a str) -> ByteStr {\n        ByteStr {\n            // Invariant: src is a str so contains valid UTF-8.\n            bytes: Bytes::copy_from_slice(src.as_bytes()),\n        }\n    }\n}"
        ],
        "bytes::Bytes": [
            "impl From<ByteStr> for Bytes {\n    fn from(src: ByteStr) -> Self {\n        src.bytes\n    }\n}",
            "impl From<Custom> for Bytes {\n    #[inline]\n    fn from(Custom(inner): Custom) -> Bytes {\n        Bytes::from(inner)\n    }\n}",
            "impl<T> From<Repr<T>> for Bytes\nwhere\n    T: Into<Bytes>,\n{\n    fn from(repr: Repr<T>) -> Bytes {\n        match repr {\n            Repr::Standard(header) => Bytes::from_static(header.as_str().as_bytes()),\n            Repr::Custom(header) => header.into(),\n        }\n    }\n}"
        ],
        "error::Error": [
            "impl Error {\n    /// Return true if the underlying error has the same type as T.\n    pub fn is<T: error::Error + 'static>(&self) -> bool {\n        self.get_ref().is::<T>()\n    }\n\n    /// Return a reference to the lower level, inner error.\n    pub fn get_ref(&self) -> &(dyn error::Error + 'static) {\n        use self::ErrorKind::*;\n\n        match self.inner {\n            StatusCode(ref e) => e,\n            Method(ref e) => e,\n            Uri(ref e) => e,\n            UriParts(ref e) => e,\n            HeaderName(ref e) => e,\n            HeaderValue(ref e) => e,\n            MaxSizeReached(ref e) => e,\n        }\n    }\n}",
            "impl From<MaxSizeReached> for Error {\n    fn from(err: MaxSizeReached) -> Error {\n        Error {\n            inner: ErrorKind::MaxSizeReached(err),\n        }\n    }\n}",
            "impl From<header::InvalidHeaderName> for Error {\n    fn from(err: header::InvalidHeaderName) -> Error {\n        Error {\n            inner: ErrorKind::HeaderName(err),\n        }\n    }\n}",
            "impl From<header::InvalidHeaderValue> for Error {\n    fn from(err: header::InvalidHeaderValue) -> Error {\n        Error {\n            inner: ErrorKind::HeaderValue(err),\n        }\n    }\n}",
            "impl From<method::InvalidMethod> for Error {\n    fn from(err: method::InvalidMethod) -> Error {\n        Error {\n            inner: ErrorKind::Method(err),\n        }\n    }\n}",
            "impl From<status::InvalidStatusCode> for Error {\n    fn from(err: status::InvalidStatusCode) -> Error {\n        Error {\n            inner: ErrorKind::StatusCode(err),\n        }\n    }\n}",
            "impl From<std::convert::Infallible> for Error {\n    fn from(err: std::convert::Infallible) -> Error {\n        match err {}\n    }\n}",
            "impl From<uri::InvalidUri> for Error {\n    fn from(err: uri::InvalidUri) -> Error {\n        Error {\n            inner: ErrorKind::Uri(err),\n        }\n    }\n}",
            "impl From<uri::InvalidUriParts> for Error {\n    fn from(err: uri::InvalidUriParts) -> Error {\n        Error {\n            inner: ErrorKind::UriParts(err),\n        }\n    }\n}",
            "impl error::Error for Error {\n    // Return any available cause from the inner error. Note the inner error is\n    // not itself the cause.\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        self.get_ref().source()\n    }\n}",
            "impl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"http::Error\")\n            // Skip the noise of the ErrorKind enum\n            .field(&self.get_ref())\n            .finish()\n    }\n}",
            "impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.get_ref(), f)\n    }\n}"
        ],
        "extensions::Extensions": [
            "Clone",
            "Default",
            "impl Extensions {\n    /// Create an empty `Extensions`.\n    #[inline]\n    pub fn new() -> Extensions {\n        Extensions { map: None }\n    }\n\n    /// Insert a type into this `Extensions`.\n    ///\n    /// If a extension of this type already existed, it will\n    /// be returned and replaced with the new one.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// assert!(ext.insert(5i32).is_none());\n    /// assert!(ext.insert(4u8).is_none());\n    /// assert_eq!(ext.insert(9i32), Some(5i32));\n    /// ```\n    pub fn insert<T: Clone + Send + Sync + 'static>(&mut self, val: T) -> Option<T> {\n        self.map\n            .get_or_insert_with(Box::default)\n            .insert(TypeId::of::<T>(), Box::new(val))\n            .and_then(|boxed| boxed.into_any().downcast().ok().map(|boxed| *boxed))\n    }\n\n    /// Get a reference to a type previously inserted on this `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// assert!(ext.get::<i32>().is_none());\n    /// ext.insert(5i32);\n    ///\n    /// assert_eq!(ext.get::<i32>(), Some(&5i32));\n    /// ```\n    pub fn get<T: Send + Sync + 'static>(&self) -> Option<&T> {\n        self.map\n            .as_ref()\n            .and_then(|map| map.get(&TypeId::of::<T>()))\n            .and_then(|boxed| (**boxed).as_any().downcast_ref())\n    }\n\n    /// Get a mutable reference to a type previously inserted on this `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// ext.insert(String::from(\"Hello\"));\n    /// ext.get_mut::<String>().unwrap().push_str(\" World\");\n    ///\n    /// assert_eq!(ext.get::<String>().unwrap(), \"Hello World\");\n    /// ```\n    pub fn get_mut<T: Send + Sync + 'static>(&mut self) -> Option<&mut T> {\n        self.map\n            .as_mut()\n            .and_then(|map| map.get_mut(&TypeId::of::<T>()))\n            .and_then(|boxed| (**boxed).as_any_mut().downcast_mut())\n    }\n\n    /// Get a mutable reference to a type, inserting `value` if not already present on this\n    /// `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// *ext.get_or_insert(1i32) += 2;\n    ///\n    /// assert_eq!(*ext.get::<i32>().unwrap(), 3);\n    /// ```\n    pub fn get_or_insert<T: Clone + Send + Sync + 'static>(&mut self, value: T) -> &mut T {\n        self.get_or_insert_with(|| value)\n    }\n\n    /// Get a mutable reference to a type, inserting the value created by `f` if not already present\n    /// on this `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// *ext.get_or_insert_with(|| 1i32) += 2;\n    ///\n    /// assert_eq!(*ext.get::<i32>().unwrap(), 3);\n    /// ```\n    pub fn get_or_insert_with<T: Clone + Send + Sync + 'static, F: FnOnce() -> T>(\n        &mut self,\n        f: F,\n    ) -> &mut T {\n        let out = self\n            .map\n            .get_or_insert_with(Box::default)\n            .entry(TypeId::of::<T>())\n            .or_insert_with(|| Box::new(f()));\n        (**out).as_any_mut().downcast_mut().unwrap()\n    }\n\n    /// Get a mutable reference to a type, inserting the type's default value if not already present\n    /// on this `Extensions`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// *ext.get_or_insert_default::<i32>() += 2;\n    ///\n    /// assert_eq!(*ext.get::<i32>().unwrap(), 2);\n    /// ```\n    pub fn get_or_insert_default<T: Default + Clone + Send + Sync + 'static>(&mut self) -> &mut T {\n        self.get_or_insert_with(T::default)\n    }\n\n    /// Remove a type from this `Extensions`.\n    ///\n    /// If a extension of this type existed, it will be returned.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// ext.insert(5i32);\n    /// assert_eq!(ext.remove::<i32>(), Some(5i32));\n    /// assert!(ext.get::<i32>().is_none());\n    /// ```\n    pub fn remove<T: Send + Sync + 'static>(&mut self) -> Option<T> {\n        self.map\n            .as_mut()\n            .and_then(|map| map.remove(&TypeId::of::<T>()))\n            .and_then(|boxed| boxed.into_any().downcast().ok().map(|boxed| *boxed))\n    }\n\n    /// Clear the `Extensions` of all inserted extensions.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// ext.insert(5i32);\n    /// ext.clear();\n    ///\n    /// assert!(ext.get::<i32>().is_none());\n    /// ```\n    #[inline]\n    pub fn clear(&mut self) {\n        if let Some(ref mut map) = self.map {\n            map.clear();\n        }\n    }\n\n    /// Check whether the extension set is empty or not.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// assert!(ext.is_empty());\n    /// ext.insert(5i32);\n    /// assert!(!ext.is_empty());\n    /// ```\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.map.as_ref().map_or(true, |map| map.is_empty())\n    }\n\n    /// Get the number of extensions available.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext = Extensions::new();\n    /// assert_eq!(ext.len(), 0);\n    /// ext.insert(5i32);\n    /// assert_eq!(ext.len(), 1);\n    /// ```\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.map.as_ref().map_or(0, |map| map.len())\n    }\n\n    /// Extends `self` with another `Extensions`.\n    ///\n    /// If an instance of a specific type exists in both, the one in `self` is overwritten with the\n    /// one from `other`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Extensions;\n    /// let mut ext_a = Extensions::new();\n    /// ext_a.insert(8u8);\n    /// ext_a.insert(16u16);\n    ///\n    /// let mut ext_b = Extensions::new();\n    /// ext_b.insert(4u8);\n    /// ext_b.insert(\"hello\");\n    ///\n    /// ext_a.extend(ext_b);\n    /// assert_eq!(ext_a.len(), 3);\n    /// assert_eq!(ext_a.get::<u8>(), Some(&4u8));\n    /// assert_eq!(ext_a.get::<u16>(), Some(&16u16));\n    /// assert_eq!(ext_a.get::<&'static str>().copied(), Some(\"hello\"));\n    /// ```\n    pub fn extend(&mut self, other: Self) {\n        if let Some(other) = other.map {\n            if let Some(map) = &mut self.map {\n                map.extend(*other);\n            } else {\n                self.map = Some(other);\n            }\n        }\n    }\n}",
            "impl fmt::Debug for Extensions {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Extensions\").finish()\n    }\n}"
        ],
        "extensions::IdHasher": [
            "Default",
            "impl Hasher for IdHasher {\n    fn write(&mut self, _: &[u8]) {\n        unreachable!(\"TypeId calls write_u64\");\n    }\n\n    #[inline]\n    fn write_u64(&mut self, id: u64) {\n        self.0 = id;\n    }\n\n    #[inline]\n    fn finish(&self) -> u64 {\n        self.0\n    }\n}"
        ],
        "header::map::Bucket": [
            "Clone",
            "Debug"
        ],
        "header::map::Cursor": [
            "Clone",
            "Copy",
            "Debug",
            "Eq",
            "PartialEq"
        ],
        "header::map::Danger": [
            "Clone",
            "impl Danger {\n    fn is_red(&self) -> bool {\n        matches!(*self, Danger::Red(_))\n    }\n\n    fn set_red(&mut self) {\n        debug_assert!(self.is_yellow());\n        *self = Danger::Red(RandomState::new());\n    }\n\n    fn is_yellow(&self) -> bool {\n        matches!(*self, Danger::Yellow)\n    }\n\n    fn set_yellow(&mut self) {\n        if let Danger::Green = *self {\n            *self = Danger::Yellow;\n        }\n    }\n\n    fn set_green(&mut self) {\n        debug_assert!(self.is_yellow());\n        *self = Danger::Green;\n    }\n}"
        ],
        "header::map::Drain": [
            "Debug",
            "impl<'a, T> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        for _ in self {}\n    }\n}",
            "impl<'a, T> FusedIterator for Drain<'a, T> {}",
            "impl<'a, T> Iterator for Drain<'a, T> {\n    type Item = (Option<HeaderName>, T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(next) = self.next {\n            // Remove the extra value\n\n            let raw_links = RawLinks(self.entries);\n            let extra = unsafe { remove_extra_value(raw_links, &mut *self.extra_values, next) };\n\n            match extra.next {\n                Link::Extra(idx) => self.next = Some(idx),\n                Link::Entry(_) => self.next = None,\n            }\n\n            return Some((None, extra.value));\n        }\n\n        let idx = self.idx;\n\n        if idx == self.len {\n            return None;\n        }\n\n        self.idx += 1;\n\n        unsafe {\n            let entry = &(*self.entries)[idx];\n\n            // Read the header name\n            let key = ptr::read(&entry.key as *const _);\n            let value = ptr::read(&entry.value as *const _);\n            self.next = entry.links.map(|l| l.next);\n\n            Some((Some(key), value))\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        // At least this many names... It's unknown if the user wants\n        // to count the extra_values on top.\n        //\n        // For instance, extending a new `HeaderMap` wouldn't need to\n        // reserve the upper-bound in `entries`, only the lower-bound.\n        let lower = self.len - self.idx;\n        let upper = unsafe { (*self.extra_values).len() } + lower;\n        (lower, Some(upper))\n    }\n}",
            "unsafe impl<'a, T: Send> Send for Drain<'a, T> {}",
            "unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}"
        ],
        "header::map::Entry": [
            "Debug",
            "impl<'a, T> Entry<'a, T> {\n    /// Ensures a value is in the entry by inserting the default if empty.\n    ///\n    /// Returns a mutable reference to the **first** value in the entry.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if capacity exceeds max `HeaderMap` capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map: HeaderMap<u32> = HeaderMap::default();\n    ///\n    /// let headers = &[\n    ///     \"content-length\",\n    ///     \"x-hello\",\n    ///     \"Content-Length\",\n    ///     \"x-world\",\n    /// ];\n    ///\n    /// for &header in headers {\n    ///     let counter = map.entry(header)\n    ///         .or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(map[\"content-length\"], 2);\n    /// assert_eq!(map[\"x-hello\"], 1);\n    /// ```\n    pub fn or_insert(self, default: T) -> &'a mut T {\n        self.or_try_insert(default)\n            .expect(\"size overflows MAX_SIZE\")\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty.\n    ///\n    /// Returns a mutable reference to the **first** value in the entry.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if `HeaderMap` exceeds max capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map: HeaderMap<u32> = HeaderMap::default();\n    ///\n    /// let headers = &[\n    ///     \"content-length\",\n    ///     \"x-hello\",\n    ///     \"Content-Length\",\n    ///     \"x-world\",\n    /// ];\n    ///\n    /// for &header in headers {\n    ///     let counter = map.entry(header)\n    ///         .or_try_insert(0)\n    ///         .unwrap();\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(map[\"content-length\"], 2);\n    /// assert_eq!(map[\"x-hello\"], 1);\n    /// ```\n    pub fn or_try_insert(self, default: T) -> Result<&'a mut T, MaxSizeReached> {\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => Ok(e.into_mut()),\n            Vacant(e) => e.try_insert(default),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default\n    /// function if empty.\n    ///\n    /// The default function is not called if the entry exists in the map.\n    /// Returns a mutable reference to the **first** value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage.\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// let res = map.entry(\"x-hello\")\n    ///     .or_insert_with(|| \"world\".parse().unwrap());\n    ///\n    /// assert_eq!(res, \"world\");\n    /// ```\n    ///\n    /// The default function is not called if the entry exists in the map.\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.try_insert(HOST, \"world\".parse().unwrap()).unwrap();\n    ///\n    /// let res = map.try_entry(\"host\")\n    ///     .unwrap()\n    ///     .or_try_insert_with(|| unreachable!())\n    ///     .unwrap();\n    ///\n    ///\n    /// assert_eq!(res, \"world\");\n    /// ```\n    pub fn or_insert_with<F: FnOnce() -> T>(self, default: F) -> &'a mut T {\n        self.or_try_insert_with(default)\n            .expect(\"size overflows MAX_SIZE\")\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default\n    /// function if empty.\n    ///\n    /// The default function is not called if the entry exists in the map.\n    /// Returns a mutable reference to the **first** value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage.\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// let res = map.entry(\"x-hello\")\n    ///     .or_insert_with(|| \"world\".parse().unwrap());\n    ///\n    /// assert_eq!(res, \"world\");\n    /// ```\n    ///\n    /// The default function is not called if the entry exists in the map.\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.try_insert(HOST, \"world\".parse().unwrap()).unwrap();\n    ///\n    /// let res = map.try_entry(\"host\")\n    ///     .unwrap()\n    ///     .or_try_insert_with(|| unreachable!())\n    ///     .unwrap();\n    ///\n    ///\n    /// assert_eq!(res, \"world\");\n    /// ```\n    pub fn or_try_insert_with<F: FnOnce() -> T>(\n        self,\n        default: F,\n    ) -> Result<&'a mut T, MaxSizeReached> {\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => Ok(e.into_mut()),\n            Vacant(e) => e.try_insert(default()),\n        }\n    }\n\n    /// Returns a reference to the entry's key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(map.entry(\"x-hello\").key(), \"x-hello\");\n    /// ```\n    pub fn key(&self) -> &HeaderName {\n        use self::Entry::*;\n\n        match *self {\n            Vacant(ref e) => e.key(),\n            Occupied(ref e) => e.key(),\n        }\n    }\n}"
        ],
        "header::map::ExtraValue": [
            "Clone",
            "Debug"
        ],
        "header::map::GetAll": [
            "Debug",
            "impl<'a, T: 'a> GetAll<'a, T> {\n    /// Returns an iterator visiting all values associated with the entry.\n    ///\n    /// Values are iterated in insertion order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    /// map.append(HOST, \"hello.earth\".parse().unwrap());\n    ///\n    /// let values = map.get_all(\"host\");\n    /// let mut iter = values.iter();\n    /// assert_eq!(&\"hello.world\", iter.next().unwrap());\n    /// assert_eq!(&\"hello.earth\", iter.next().unwrap());\n    /// assert!(iter.next().is_none());\n    /// ```\n    pub fn iter(&self) -> ValueIter<'a, T> {\n        // This creates a new GetAll struct so that the lifetime\n        // isn't bound to &self.\n        GetAll {\n            map: self.map,\n            index: self.index,\n        }\n        .into_iter()\n    }\n}",
            "impl<'a, T: PartialEq> PartialEq for GetAll<'a, T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.iter().eq(other.iter())\n    }\n}",
            "impl<'a, T> IntoIterator for GetAll<'a, T> {\n    type Item = &'a T;\n    type IntoIter = ValueIter<'a, T>;\n\n    fn into_iter(self) -> ValueIter<'a, T> {\n        self.map.value_iter(self.index)\n    }\n}"
        ],
        "header::map::HashValue": [
            "Clone",
            "Copy",
            "Debug",
            "Eq",
            "PartialEq"
        ],
        "header::map::HeaderMap": [
            "Clone",
            "impl HeaderMap {\n    /// Create an empty `HeaderMap`.\n    ///\n    /// The map will be created without any capacity. This function will not\n    /// allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let map = HeaderMap::new();\n    ///\n    /// assert!(map.is_empty());\n    /// assert_eq!(0, map.capacity());\n    /// ```\n    pub fn new() -> Self {\n        HeaderMap::try_with_capacity(0).unwrap()\n    }\n}",
            "impl<'a, K, V, S, T> TryFrom<&'a HashMap<K, V, S>> for HeaderMap<T>\nwhere\n    K: Eq + Hash,\n    HeaderName: TryFrom<&'a K>,\n    <HeaderName as TryFrom<&'a K>>::Error: Into<crate::Error>,\n    T: TryFrom<&'a V>,\n    T::Error: Into<crate::Error>,\n{\n    type Error = Error;\n\n    fn try_from(c: &'a HashMap<K, V, S>) -> Result<Self, Self::Error> {\n        c.iter()\n            .map(|(k, v)| -> crate::Result<(HeaderName, T)> {\n                let name = TryFrom::try_from(k).map_err(Into::into)?;\n                let value = TryFrom::try_from(v).map_err(Into::into)?;\n                Ok((name, value))\n            })\n            .collect()\n    }\n}",
            "impl<K, T> ops::Index<K> for HeaderMap<T>\nwhere\n    K: AsHeaderName,\n{\n    type Output = T;\n\n    /// # Panics\n    /// Using the index operator will cause a panic if the header you're querying isn't set.\n    #[inline]\n    fn index(&self, index: K) -> &T {\n        match self.get2(&index) {\n            Some(val) => val,\n            None => panic!(\"no entry found for key {:?}\", index.as_str()),\n        }\n    }\n}",
            "impl<T: Eq> Eq for HeaderMap<T> {}",
            "impl<T: PartialEq> PartialEq for HeaderMap<T> {\n    fn eq(&self, other: &HeaderMap<T>) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.keys()\n            .all(|key| self.get_all(key) == other.get_all(key))\n    }\n}",
            "impl<T: fmt::Debug> fmt::Debug for HeaderMap<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_map().entries(self.iter()).finish()\n    }\n}",
            "impl<T> Default for HeaderMap<T> {\n    fn default() -> Self {\n        HeaderMap::try_with_capacity(0).expect(\"zero capacity should never fail\")\n    }\n}",
            "impl<T> Extend<(HeaderName, T)> for HeaderMap<T> {\n    fn extend<I: IntoIterator<Item = (HeaderName, T)>>(&mut self, iter: I) {\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let iter = iter.into_iter();\n\n        let reserve = if self.is_empty() {\n            iter.size_hint().0\n        } else {\n            (iter.size_hint().0 + 1) / 2\n        };\n\n        self.reserve(reserve);\n\n        for (k, v) in iter {\n            self.append(k, v);\n        }\n    }\n}",
            "impl<T> Extend<(Option<HeaderName>, T)> for HeaderMap<T> {\n    /// Extend a `HeaderMap` with the contents of another `HeaderMap`.\n    ///\n    /// This function expects the yielded items to follow the same structure as\n    /// `IntoIter`.\n    ///\n    /// # Panics\n    ///\n    /// This panics if the first yielded item does not have a `HeaderName`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// let mut extra = HeaderMap::new();\n    ///\n    /// extra.insert(HOST, \"foo.bar\".parse().unwrap());\n    /// extra.insert(COOKIE, \"hello\".parse().unwrap());\n    /// extra.append(COOKIE, \"world\".parse().unwrap());\n    ///\n    /// map.extend(extra);\n    ///\n    /// assert_eq!(map[\"host\"], \"foo.bar\");\n    /// assert_eq!(map[\"accept\"], \"text/plain\");\n    /// assert_eq!(map[\"cookie\"], \"hello\");\n    ///\n    /// let v = map.get_all(\"host\");\n    /// assert_eq!(1, v.iter().count());\n    ///\n    /// let v = map.get_all(\"cookie\");\n    /// assert_eq!(2, v.iter().count());\n    /// ```\n    fn extend<I: IntoIterator<Item = (Option<HeaderName>, T)>>(&mut self, iter: I) {\n        let mut iter = iter.into_iter();\n\n        // The structure of this is a bit weird, but it is mostly to make the\n        // borrow checker happy.\n        let (mut key, mut val) = match iter.next() {\n            Some((Some(key), val)) => (key, val),\n            Some((None, _)) => panic!(\"expected a header name, but got None\"),\n            None => return,\n        };\n\n        'outer: loop {\n            let mut entry = match self.try_entry2(key).expect(\"size overflows MAX_SIZE\") {\n                Entry::Occupied(mut e) => {\n                    // Replace all previous values while maintaining a handle to\n                    // the entry.\n                    e.insert(val);\n                    e\n                }\n                Entry::Vacant(e) => e.insert_entry(val),\n            };\n\n            // As long as `HeaderName` is none, keep inserting the value into\n            // the current entry\n            loop {\n                match iter.next() {\n                    Some((Some(k), v)) => {\n                        key = k;\n                        val = v;\n                        continue 'outer;\n                    }\n                    Some((None, v)) => {\n                        entry.append(v);\n                    }\n                    None => {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}",
            "impl<T> FromIterator<(HeaderName, T)> for HeaderMap<T> {\n    fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (HeaderName, T)>,\n    {\n        let mut map = HeaderMap::default();\n        map.extend(iter);\n        map\n    }\n}",
            "impl<T> HeaderMap<T> {\n    /// Create an empty `HeaderMap` with the specified capacity.\n    ///\n    /// The returned map will allocate internal storage in order to hold about\n    /// `capacity` elements without reallocating. However, this is a \"best\n    /// effort\" as there are usage patterns that could cause additional\n    /// allocations before `capacity` headers are stored in the map.\n    ///\n    /// More capacity than requested may be allocated.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if capacity exceeds max `HeaderMap` capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let map: HeaderMap<u32> = HeaderMap::with_capacity(10);\n    ///\n    /// assert!(map.is_empty());\n    /// assert_eq!(12, map.capacity());\n    /// ```\n    pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n        Self::try_with_capacity(capacity).expect(\"size overflows MAX_SIZE\")\n    }\n\n    /// Create an empty `HeaderMap` with the specified capacity.\n    ///\n    /// The returned map will allocate internal storage in order to hold about\n    /// `capacity` elements without reallocating. However, this is a \"best\n    /// effort\" as there are usage patterns that could cause additional\n    /// allocations before `capacity` headers are stored in the map.\n    ///\n    /// More capacity than requested may be allocated.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if `HeaderMap` exceeds max capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let map: HeaderMap<u32> = HeaderMap::try_with_capacity(10).unwrap();\n    ///\n    /// assert!(map.is_empty());\n    /// assert_eq!(12, map.capacity());\n    /// ```\n    pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n        if capacity == 0 {\n            Ok(HeaderMap {\n                mask: 0,\n                indices: Box::new([]), // as a ZST, this doesn't actually allocate anything\n                entries: Vec::new(),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            })\n        } else {\n            let raw_cap = match to_raw_capacity(capacity).checked_next_power_of_two() {\n                Some(c) => c,\n                None => return Err(MaxSizeReached { _priv: () }),\n            };\n            if raw_cap > MAX_SIZE {\n                return Err(MaxSizeReached { _priv: () });\n            }\n            debug_assert!(raw_cap > 0);\n\n            Ok(HeaderMap {\n                mask: (raw_cap - 1) as Size,\n                indices: vec![Pos::none(); raw_cap].into_boxed_slice(),\n                entries: Vec::with_capacity(usable_capacity(raw_cap)),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            })\n        }\n    }\n\n    /// Returns the number of headers stored in the map.\n    ///\n    /// This number represents the total number of **values** stored in the map.\n    /// This number can be greater than or equal to the number of **keys**\n    /// stored given that a single key may have more than one associated value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{ACCEPT, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(0, map.len());\n    ///\n    /// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n    /// map.insert(HOST, \"localhost\".parse().unwrap());\n    ///\n    /// assert_eq!(2, map.len());\n    ///\n    /// map.append(ACCEPT, \"text/html\".parse().unwrap());\n    ///\n    /// assert_eq!(3, map.len());\n    /// ```\n    pub fn len(&self) -> usize {\n        self.entries.len() + self.extra_values.len()\n    }\n\n    /// Returns the number of keys stored in the map.\n    ///\n    /// This number will be less than or equal to `len()` as each key may have\n    /// more than one associated value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{ACCEPT, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(0, map.keys_len());\n    ///\n    /// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n    /// map.insert(HOST, \"localhost\".parse().unwrap());\n    ///\n    /// assert_eq!(2, map.keys_len());\n    ///\n    /// map.insert(ACCEPT, \"text/html\".parse().unwrap());\n    ///\n    /// assert_eq!(2, map.keys_len());\n    /// ```\n    pub fn keys_len(&self) -> usize {\n        self.entries.len()\n    }\n\n    /// Returns true if the map contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert!(map.is_empty());\n    ///\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// assert!(!map.is_empty());\n    /// ```\n    pub fn is_empty(&self) -> bool {\n        self.entries.len() == 0\n    }\n\n    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n    /// for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// map.clear();\n    /// assert!(map.is_empty());\n    /// assert!(map.capacity() > 0);\n    /// ```\n    pub fn clear(&mut self) {\n        self.entries.clear();\n        self.extra_values.clear();\n        self.danger = Danger::Green;\n\n        for e in self.indices.iter_mut() {\n            *e = Pos::none();\n        }\n    }\n\n    /// Returns the number of headers the map can hold without reallocating.\n    ///\n    /// This number is an approximation as certain usage patterns could cause\n    /// additional allocations before the returned capacity is filled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(0, map.capacity());\n    ///\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    /// assert_eq!(6, map.capacity());\n    /// ```\n    pub fn capacity(&self) -> usize {\n        usable_capacity(self.indices.len())\n    }\n\n    /// Reserves capacity for at least `additional` more headers to be inserted\n    /// into the `HeaderMap`.\n    ///\n    /// The header map may reserve more space to avoid frequent reallocations.\n    /// Like with `with_capacity`, this will be a \"best effort\" to avoid\n    /// allocations until `additional` more headers are inserted. Certain usage\n    /// patterns could cause additional allocations before the number is\n    /// reached.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new allocation size overflows `HeaderMap` `MAX_SIZE`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.reserve(10);\n    /// # map.insert(HOST, \"bar\".parse().unwrap());\n    /// ```\n    pub fn reserve(&mut self, additional: usize) {\n        self.try_reserve(additional)\n            .expect(\"size overflows MAX_SIZE\")\n    }\n\n    /// Reserves capacity for at least `additional` more headers to be inserted\n    /// into the `HeaderMap`.\n    ///\n    /// The header map may reserve more space to avoid frequent reallocations.\n    /// Like with `with_capacity`, this will be a \"best effort\" to avoid\n    /// allocations until `additional` more headers are inserted. Certain usage\n    /// patterns could cause additional allocations before the number is\n    /// reached.\n    ///\n    /// # Errors\n    ///\n    /// This method differs from `reserve` by returning an error instead of\n    /// panicking if the value is too large.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.try_reserve(10).unwrap();\n    /// # map.try_insert(HOST, \"bar\".parse().unwrap()).unwrap();\n    /// ```\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), MaxSizeReached> {\n        // TODO: This can't overflow if done properly... since the max # of\n        // elements is u16::MAX.\n        let cap = self\n            .entries\n            .len()\n            .checked_add(additional)\n            .ok_or_else(MaxSizeReached::new)?;\n\n        let raw_cap = to_raw_capacity(cap);\n\n        if raw_cap > self.indices.len() {\n            let raw_cap = raw_cap\n                .checked_next_power_of_two()\n                .ok_or_else(MaxSizeReached::new)?;\n            if raw_cap > MAX_SIZE {\n                return Err(MaxSizeReached::new());\n            }\n\n            if self.entries.is_empty() {\n                self.mask = raw_cap as Size - 1;\n                self.indices = vec![Pos::none(); raw_cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(raw_cap));\n            } else {\n                self.try_grow(raw_cap)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Returns a reference to the value associated with the key.\n    ///\n    /// If there are multiple values associated with the key, then the first one\n    /// is returned. Use `get_all` to get all values associated with a given\n    /// key. Returns `None` if there are no values associated with the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.get(\"host\").is_none());\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// assert_eq!(map.get(HOST).unwrap(), &\"hello\");\n    /// assert_eq!(map.get(\"host\").unwrap(), &\"hello\");\n    ///\n    /// map.append(HOST, \"world\".parse().unwrap());\n    /// assert_eq!(map.get(\"host\").unwrap(), &\"hello\");\n    /// ```\n    pub fn get<K>(&self, key: K) -> Option<&T>\n    where\n        K: AsHeaderName,\n    {\n        self.get2(&key)\n    }\n\n    fn get2<K>(&self, key: &K) -> Option<&T>\n    where\n        K: AsHeaderName,\n    {\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &self.entries[found];\n                Some(&entry.value)\n            }\n            None => None,\n        }\n    }\n\n    /// Returns a mutable reference to the value associated with the key.\n    ///\n    /// If there are multiple values associated with the key, then the first one\n    /// is returned. Use `entry` to get all values associated with a given\n    /// key. Returns `None` if there are no values associated with the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, \"hello\".to_string());\n    /// map.get_mut(\"host\").unwrap().push_str(\"-world\");\n    ///\n    /// assert_eq!(map.get(HOST).unwrap(), &\"hello-world\");\n    /// ```\n    pub fn get_mut<K>(&mut self, key: K) -> Option<&mut T>\n    where\n        K: AsHeaderName,\n    {\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &mut self.entries[found];\n                Some(&mut entry.value)\n            }\n            None => None,\n        }\n    }\n\n    /// Returns a view of all values associated with a key.\n    ///\n    /// The returned view does not incur any allocations and allows iterating\n    /// the values associated with the key.  See [`GetAll`] for more details.\n    /// Returns `None` if there are no values associated with the key.\n    ///\n    /// [`GetAll`]: struct.GetAll.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// map.append(HOST, \"goodbye\".parse().unwrap());\n    ///\n    /// let view = map.get_all(\"host\");\n    ///\n    /// let mut iter = view.iter();\n    /// assert_eq!(&\"hello\", iter.next().unwrap());\n    /// assert_eq!(&\"goodbye\", iter.next().unwrap());\n    /// assert!(iter.next().is_none());\n    /// ```\n    pub fn get_all<K>(&self, key: K) -> GetAll<'_, T>\n    where\n        K: AsHeaderName,\n    {\n        GetAll {\n            map: self,\n            index: key.find(self).map(|(_, i)| i),\n        }\n    }\n\n    /// Returns true if the map contains a value for the specified key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(!map.contains_key(HOST));\n    ///\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    /// assert!(map.contains_key(\"host\"));\n    /// ```\n    pub fn contains_key<K>(&self, key: K) -> bool\n    where\n        K: AsHeaderName,\n    {\n        key.find(self).is_some()\n    }\n\n    /// An iterator visiting all key-value pairs.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version. Each key will be yielded once per associated\n    /// value. So, if a key has 3 associated values, it will be yielded 3 times.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// map.append(HOST, \"goodbye\".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n    ///\n    /// for (key, value) in map.iter() {\n    ///     println!(\"{:?}: {:?}\", key, value);\n    /// }\n    /// ```\n    pub fn iter(&self) -> Iter<'_, T> {\n        Iter {\n            map: self,\n            entry: 0,\n            cursor: self.entries.first().map(|_| Cursor::Head),\n        }\n    }\n\n    /// An iterator visiting all key-value pairs, with mutable value references.\n    ///\n    /// The iterator order is arbitrary, but consistent across platforms for the\n    /// same crate version. Each key will be yielded once per associated value,\n    /// so if a key has 3 associated values, it will be yielded 3 times.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::default();\n    ///\n    /// map.insert(HOST, \"hello\".to_string());\n    /// map.append(HOST, \"goodbye\".to_string());\n    /// map.insert(CONTENT_LENGTH, \"123\".to_string());\n    ///\n    /// for (key, value) in map.iter_mut() {\n    ///     value.push_str(\"-boop\");\n    /// }\n    /// ```\n    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n        IterMut {\n            map: self as *mut _,\n            entry: 0,\n            cursor: self.entries.first().map(|_| Cursor::Head),\n            lt: PhantomData,\n        }\n    }\n\n    /// An iterator visiting all keys.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version. Each key will be yielded only once even if it\n    /// has multiple associated values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// map.append(HOST, \"goodbye\".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n    ///\n    /// for key in map.keys() {\n    ///     println!(\"{:?}\", key);\n    /// }\n    /// ```\n    pub fn keys(&self) -> Keys<'_, T> {\n        Keys {\n            inner: self.entries.iter(),\n        }\n    }\n\n    /// An iterator visiting all values.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// map.append(HOST, \"goodbye\".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n    ///\n    /// for value in map.values() {\n    ///     println!(\"{:?}\", value);\n    /// }\n    /// ```\n    pub fn values(&self) -> Values<'_, T> {\n        Values { inner: self.iter() }\n    }\n\n    /// An iterator visiting all values mutably.\n    ///\n    /// The iteration order is arbitrary, but consistent across platforms for\n    /// the same crate version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::default();\n    ///\n    /// map.insert(HOST, \"hello\".to_string());\n    /// map.append(HOST, \"goodbye\".to_string());\n    /// map.insert(CONTENT_LENGTH, \"123\".to_string());\n    ///\n    /// for value in map.values_mut() {\n    ///     value.push_str(\"-boop\");\n    /// }\n    /// ```\n    pub fn values_mut(&mut self) -> ValuesMut<'_, T> {\n        ValuesMut {\n            inner: self.iter_mut(),\n        }\n    }\n\n    /// Clears the map, returning all entries as an iterator.\n    ///\n    /// The internal memory is kept for reuse.\n    ///\n    /// For each yielded item that has `None` provided for the `HeaderName`,\n    /// then the associated header name is the same as that of the previously\n    /// yielded item. The first yielded item will have `HeaderName` set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::{CONTENT_LENGTH, HOST};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.insert(HOST, \"hello\".parse().unwrap());\n    /// map.append(HOST, \"goodbye\".parse().unwrap());\n    /// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n    ///\n    /// let mut drain = map.drain();\n    ///\n    ///\n    /// assert_eq!(drain.next(), Some((Some(HOST), \"hello\".parse().unwrap())));\n    /// assert_eq!(drain.next(), Some((None, \"goodbye\".parse().unwrap())));\n    ///\n    /// assert_eq!(drain.next(), Some((Some(CONTENT_LENGTH), \"123\".parse().unwrap())));\n    ///\n    /// assert_eq!(drain.next(), None);\n    /// ```\n    pub fn drain(&mut self) -> Drain<'_, T> {\n        for i in self.indices.iter_mut() {\n            *i = Pos::none();\n        }\n\n        // Memory safety\n        //\n        // When the Drain is first created, it shortens the length of\n        // the source vector to make sure no uninitialized or moved-from\n        // elements are accessible at all if the Drain's destructor never\n        // gets to run.\n\n        let entries = &mut self.entries[..] as *mut _;\n        let extra_values = &mut self.extra_values as *mut _;\n        let len = self.entries.len();\n        unsafe {\n            self.entries.set_len(0);\n        }\n\n        Drain {\n            idx: 0,\n            len,\n            entries,\n            extra_values,\n            next: None,\n            lt: PhantomData,\n        }\n    }\n\n    fn value_iter(&self, idx: Option<usize>) -> ValueIter<'_, T> {\n        use self::Cursor::*;\n\n        if let Some(idx) = idx {\n            let back = {\n                let entry = &self.entries[idx];\n\n                entry.links.map(|l| Values(l.tail)).unwrap_or(Head)\n            };\n\n            ValueIter {\n                map: self,\n                index: idx,\n                front: Some(Head),\n                back: Some(back),\n            }\n        } else {\n            ValueIter {\n                map: self,\n                index: usize::MAX,\n                front: None,\n                back: None,\n            }\n        }\n    }\n\n    fn value_iter_mut(&mut self, idx: usize) -> ValueIterMut<'_, T> {\n        use self::Cursor::*;\n\n        let back = {\n            let entry = &self.entries[idx];\n\n            entry.links.map(|l| Values(l.tail)).unwrap_or(Head)\n        };\n\n        ValueIterMut {\n            map: self as *mut _,\n            index: idx,\n            front: Some(Head),\n            back: Some(back),\n            lt: PhantomData,\n        }\n    }\n\n    /// Gets the given key's corresponding entry in the map for in-place\n    /// manipulation.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if capacity exceeds max `HeaderMap` capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map: HeaderMap<u32> = HeaderMap::default();\n    ///\n    /// let headers = &[\n    ///     \"content-length\",\n    ///     \"x-hello\",\n    ///     \"Content-Length\",\n    ///     \"x-world\",\n    /// ];\n    ///\n    /// for &header in headers {\n    ///     let counter = map.entry(header).or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(map[\"content-length\"], 2);\n    /// assert_eq!(map[\"x-hello\"], 1);\n    /// ```\n    pub fn entry<K>(&mut self, key: K) -> Entry<'_, T>\n    where\n        K: IntoHeaderName,\n    {\n        key.try_entry(self).expect(\"size overflows MAX_SIZE\")\n    }\n\n    /// Gets the given key's corresponding entry in the map for in-place\n    /// manipulation.\n    ///\n    /// # Errors\n    ///\n    /// This method differs from `entry` by allowing types that may not be\n    /// valid `HeaderName`s to passed as the key (such as `String`). If they\n    /// do not parse as a valid `HeaderName`, this returns an\n    /// `InvalidHeaderName` error.\n    ///\n    /// If reserving space goes over the maximum, this will also return an\n    /// error. However, to prevent breaking changes to the return type, the\n    /// error will still say `InvalidHeaderName`, unlike other `try_*` methods\n    /// which return a `MaxSizeReached` error.\n    pub fn try_entry<K>(&mut self, key: K) -> Result<Entry<'_, T>, InvalidHeaderName>\n    where\n        K: AsHeaderName,\n    {\n        key.try_entry(self).map_err(|err| match err {\n            as_header_name::TryEntryError::InvalidHeaderName(e) => e,\n            as_header_name::TryEntryError::MaxSizeReached(_e) => {\n                // Unfortunately, we cannot change the return type of this\n                // method, so the max size reached error needs to be converted\n                // into an InvalidHeaderName. Yay.\n                InvalidHeaderName::new()\n            }\n        })\n    }\n\n    fn try_entry2<K>(&mut self, key: K) -> Result<Entry<'_, T>, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,\n    {\n        // Ensure that there is space in the map\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash,\n                key: key.into(),\n                probe,\n                danger,\n            }),\n            Entry::Occupied(OccupiedEntry {\n                map: self,\n                index: pos,\n                probe,\n            }),\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash,\n                key: key.into(),\n                probe,\n                danger,\n            })\n        ))\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not previously have this key present, then `None` is\n    /// returned.\n    ///\n    /// If the map did have this key present, the new value is associated with\n    /// the key and all previous values are removed. **Note** that only a single\n    /// one of the previous values is returned. If there are multiple values\n    /// that have been previously associated with the key, then the first one is\n    /// returned. See `insert_mult` on `OccupiedEntry` for an API that returns\n    /// all values.\n    ///\n    /// The key is not updated, though; this matters for types that can be `==`\n    /// without being identical.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if capacity exceeds max `HeaderMap` capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.insert(HOST, \"world\".parse().unwrap()).is_none());\n    /// assert!(!map.is_empty());\n    ///\n    /// let mut prev = map.insert(HOST, \"earth\".parse().unwrap()).unwrap();\n    /// assert_eq!(\"world\", prev);\n    /// ```\n    pub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n    where\n        K: IntoHeaderName,\n    {\n        self.try_insert(key, val).expect(\"size overflows MAX_SIZE\")\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not previously have this key present, then `None` is\n    /// returned.\n    ///\n    /// If the map did have this key present, the new value is associated with\n    /// the key and all previous values are removed. **Note** that only a single\n    /// one of the previous values is returned. If there are multiple values\n    /// that have been previously associated with the key, then the first one is\n    /// returned. See `insert_mult` on `OccupiedEntry` for an API that returns\n    /// all values.\n    ///\n    /// The key is not updated, though; this matters for types that can be `==`\n    /// without being identical.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if `HeaderMap` exceeds max capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.try_insert(HOST, \"world\".parse().unwrap()).unwrap().is_none());\n    /// assert!(!map.is_empty());\n    ///\n    /// let mut prev = map.try_insert(HOST, \"earth\".parse().unwrap()).unwrap().unwrap();\n    /// assert_eq!(\"world\", prev);\n    /// ```\n    pub fn try_insert<K>(&mut self, key: K, val: T) -> Result<Option<T>, MaxSizeReached>\n    where\n        K: IntoHeaderName,\n    {\n        key.try_insert(self, val)\n    }\n\n    #[inline]\n    fn try_insert2<K>(&mut self, key: K, value: T) -> Result<Option<T>, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,\n    {\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            // Vacant\n            {\n                let _ = danger; // Make lint happy\n                let index = self.entries.len();\n                self.try_insert_entry(hash, key.into(), value)?;\n                self.indices[probe] = Pos::new(index, hash);\n                None\n            },\n            // Occupied\n            Some(self.insert_occupied(pos, value)),\n            // Robinhood\n            {\n                self.try_insert_phase_two(key.into(), value, hash, probe, danger)?;\n                None\n            }\n        ))\n    }\n\n    /// Set an occupied bucket to the given value\n    #[inline]\n    fn insert_occupied(&mut self, index: usize, value: T) -> T {\n        if let Some(links) = self.entries[index].links {\n            self.remove_all_extra_values(links.next);\n        }\n\n        let entry = &mut self.entries[index];\n        mem::replace(&mut entry.value, value)\n    }\n\n    fn insert_occupied_mult(&mut self, index: usize, value: T) -> ValueDrain<'_, T> {\n        let old;\n        let links;\n\n        {\n            let entry = &mut self.entries[index];\n\n            old = mem::replace(&mut entry.value, value);\n            links = entry.links.take();\n        }\n\n        let raw_links = self.raw_links();\n        let extra_values = &mut self.extra_values;\n\n        let next =\n            links.map(|l| drain_all_extra_values(raw_links, extra_values, l.next).into_iter());\n\n        ValueDrain {\n            first: Some(old),\n            next,\n            lt: PhantomData,\n        }\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not previously have this key present, then `false` is\n    /// returned.\n    ///\n    /// If the map did have this key present, the new value is pushed to the end\n    /// of the list of values currently associated with the key. The key is not\n    /// updated, though; this matters for types that can be `==` without being\n    /// identical.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if capacity exceeds max `HeaderMap` capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.insert(HOST, \"world\".parse().unwrap()).is_none());\n    /// assert!(!map.is_empty());\n    ///\n    /// map.append(HOST, \"earth\".parse().unwrap());\n    ///\n    /// let values = map.get_all(\"host\");\n    /// let mut i = values.iter();\n    /// assert_eq!(\"world\", *i.next().unwrap());\n    /// assert_eq!(\"earth\", *i.next().unwrap());\n    /// ```\n    pub fn append<K>(&mut self, key: K, value: T) -> bool\n    where\n        K: IntoHeaderName,\n    {\n        self.try_append(key, value)\n            .expect(\"size overflows MAX_SIZE\")\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not previously have this key present, then `false` is\n    /// returned.\n    ///\n    /// If the map did have this key present, the new value is pushed to the end\n    /// of the list of values currently associated with the key. The key is not\n    /// updated, though; this matters for types that can be `==` without being\n    /// identical.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if `HeaderMap` exceeds max capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// assert!(map.try_insert(HOST, \"world\".parse().unwrap()).unwrap().is_none());\n    /// assert!(!map.is_empty());\n    ///\n    /// map.try_append(HOST, \"earth\".parse().unwrap()).unwrap();\n    ///\n    /// let values = map.get_all(\"host\");\n    /// let mut i = values.iter();\n    /// assert_eq!(\"world\", *i.next().unwrap());\n    /// assert_eq!(\"earth\", *i.next().unwrap());\n    /// ```\n    pub fn try_append<K>(&mut self, key: K, value: T) -> Result<bool, MaxSizeReached>\n    where\n        K: IntoHeaderName,\n    {\n        key.try_append(self, value)\n    }\n\n    #[inline]\n    fn try_append2<K>(&mut self, key: K, value: T) -> Result<bool, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,\n    {\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            // Vacant\n            {\n                let _ = danger;\n                let index = self.entries.len();\n                self.try_insert_entry(hash, key.into(), value)?;\n                self.indices[probe] = Pos::new(index, hash);\n                false\n            },\n            // Occupied\n            {\n                append_value(pos, &mut self.entries[pos], &mut self.extra_values, value);\n                true\n            },\n            // Robinhood\n            {\n                self.try_insert_phase_two(key.into(), value, hash, probe, danger)?;\n\n                false\n            }\n        ))\n    }\n\n    #[inline]\n    fn find<K>(&self, key: &K) -> Option<(usize, usize)>\n    where\n        K: Hash + Into<HeaderName> + ?Sized,\n        HeaderName: PartialEq<K>,\n    {\n        if self.entries.is_empty() {\n            return None;\n        }\n\n        let hash = hash_elem_using(&self.danger, key);\n        let mask = self.mask;\n        let mut probe = desired_pos(mask, hash);\n        let mut dist = 0;\n\n        probe_loop!(probe < self.indices.len(), {\n            if let Some((i, entry_hash)) = self.indices[probe].resolve() {\n                if dist > probe_distance(mask, entry_hash, probe) {\n                    // give up when probe distance is too long\n                    return None;\n                } else if entry_hash == hash && self.entries[i].key == *key {\n                    return Some((probe, i));\n                }\n            } else {\n                return None;\n            }\n\n            dist += 1;\n        });\n    }\n\n    /// phase 2 is post-insert where we forward-shift `Pos` in the indices.\n    #[inline]\n    fn try_insert_phase_two(\n        &mut self,\n        key: HeaderName,\n        value: T,\n        hash: HashValue,\n        probe: usize,\n        danger: bool,\n    ) -> Result<usize, MaxSizeReached> {\n        // Push the value and get the index\n        let index = self.entries.len();\n        self.try_insert_entry(hash, key, value)?;\n\n        let num_displaced = do_insert_phase_two(&mut self.indices, probe, Pos::new(index, hash));\n\n        if danger || num_displaced >= DISPLACEMENT_THRESHOLD {\n            // Increase danger level\n            self.danger.set_yellow();\n        }\n\n        Ok(index)\n    }\n\n    /// Removes a key from the map, returning the value associated with the key.\n    ///\n    /// Returns `None` if the map does not contain the key. If there are\n    /// multiple values associated with the key, then the first one is returned.\n    /// See `remove_entry_mult` on `OccupiedEntry` for an API that yields all\n    /// values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// # use http::header::HOST;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// let prev = map.remove(HOST).unwrap();\n    /// assert_eq!(\"hello.world\", prev);\n    ///\n    /// assert!(map.remove(HOST).is_none());\n    /// ```\n    pub fn remove<K>(&mut self, key: K) -> Option<T>\n    where\n        K: AsHeaderName,\n    {\n        match key.find(self) {\n            Some((probe, idx)) => {\n                if let Some(links) = self.entries[idx].links {\n                    self.remove_all_extra_values(links.next);\n                }\n\n                let entry = self.remove_found(probe, idx);\n\n                Some(entry.value)\n            }\n            None => None,\n        }\n    }\n\n    /// Remove an entry from the map.\n    ///\n    /// Warning: To avoid inconsistent state, extra values _must_ be removed\n    /// for the `found` index (via `remove_all_extra_values` or similar)\n    /// _before_ this method is called.\n    #[inline]\n    fn remove_found(&mut self, probe: usize, found: usize) -> Bucket<T> {\n        // index `probe` and entry `found` is to be removed\n        // use swap_remove, but then we need to update the index that points\n        // to the other entry that has to move\n        self.indices[probe] = Pos::none();\n        let entry = self.entries.swap_remove(found);\n\n        // correct index that points to the entry that had to swap places\n        if let Some(entry) = self.entries.get(found) {\n            // was not last element\n            // examine new element in `found` and find it in indices\n            let mut probe = desired_pos(self.mask, entry.hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((i, _)) = self.indices[probe].resolve() {\n                    if i >= self.entries.len() {\n                        // found it\n                        self.indices[probe] = Pos::new(found, entry.hash);\n                        break;\n                    }\n                }\n            });\n\n            // Update links\n            if let Some(links) = entry.links {\n                self.extra_values[links.next].prev = Link::Entry(found);\n                self.extra_values[links.tail].next = Link::Entry(found);\n            }\n        }\n\n        // backward shift deletion in self.indices\n        // after probe, shift all non-ideally placed indices backward\n        if !self.entries.is_empty() {\n            let mut last_probe = probe;\n            let mut probe = probe + 1;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    if probe_distance(self.mask, entry_hash, probe) > 0 {\n                        self.indices[last_probe] = self.indices[probe];\n                        self.indices[probe] = Pos::none();\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n\n                last_probe = probe;\n            });\n        }\n\n        entry\n    }\n\n    /// Removes the `ExtraValue` at the given index.\n    #[inline]\n    fn remove_extra_value(&mut self, idx: usize) -> ExtraValue<T> {\n        let raw_links = self.raw_links();\n        remove_extra_value(raw_links, &mut self.extra_values, idx)\n    }\n\n    fn remove_all_extra_values(&mut self, mut head: usize) {\n        loop {\n            let extra = self.remove_extra_value(head);\n\n            if let Link::Extra(idx) = extra.next {\n                head = idx;\n            } else {\n                break;\n            }\n        }\n    }\n\n    #[inline]\n    fn try_insert_entry(\n        &mut self,\n        hash: HashValue,\n        key: HeaderName,\n        value: T,\n    ) -> Result<(), MaxSizeReached> {\n        if self.entries.len() >= MAX_SIZE {\n            return Err(MaxSizeReached::new());\n        }\n\n        self.entries.push(Bucket {\n            hash,\n            key,\n            value,\n            links: None,\n        });\n\n        Ok(())\n    }\n\n    fn rebuild(&mut self) {\n        // Loop over all entries and re-insert them into the map\n        'outer: for (index, entry) in self.entries.iter_mut().enumerate() {\n            let hash = hash_elem_using(&self.danger, &entry.key);\n            let mut probe = desired_pos(self.mask, hash);\n            let mut dist = 0;\n\n            // Update the entry's hash code\n            entry.hash = hash;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    // if existing element probed less than us, swap\n                    let their_dist = probe_distance(self.mask, entry_hash, probe);\n\n                    if their_dist < dist {\n                        // Robinhood\n                        break;\n                    }\n                } else {\n                    // Vacant slot\n                    self.indices[probe] = Pos::new(index, hash);\n                    continue 'outer;\n                }\n\n                dist += 1;\n            });\n\n            do_insert_phase_two(&mut self.indices, probe, Pos::new(index, hash));\n        }\n    }\n\n    fn reinsert_entry_in_order(&mut self, pos: Pos) {\n        if let Some((_, entry_hash)) = pos.resolve() {\n            // Find first empty bucket and insert there\n            let mut probe = desired_pos(self.mask, entry_hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if self.indices[probe].resolve().is_none() {\n                    // empty bucket, insert here\n                    self.indices[probe] = pos;\n                    return;\n                }\n            });\n        }\n    }\n\n    fn try_reserve_one(&mut self) -> Result<(), MaxSizeReached> {\n        let len = self.entries.len();\n\n        if self.danger.is_yellow() {\n            let load_factor = self.entries.len() as f32 / self.indices.len() as f32;\n\n            if load_factor >= LOAD_FACTOR_THRESHOLD {\n                // Transition back to green danger level\n                self.danger.set_green();\n\n                // Double the capacity\n                let new_cap = self.indices.len() * 2;\n\n                // Grow the capacity\n                self.try_grow(new_cap)?;\n            } else {\n                self.danger.set_red();\n\n                // Rebuild hash table\n                for index in self.indices.iter_mut() {\n                    *index = Pos::none();\n                }\n\n                self.rebuild();\n            }\n        } else if len == self.capacity() {\n            if len == 0 {\n                let new_raw_cap = 8;\n                self.mask = 8 - 1;\n                self.indices = vec![Pos::none(); new_raw_cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(new_raw_cap));\n            } else {\n                let raw_cap = self.indices.len();\n                self.try_grow(raw_cap << 1)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    #[inline]\n    fn try_grow(&mut self, new_raw_cap: usize) -> Result<(), MaxSizeReached> {\n        if new_raw_cap > MAX_SIZE {\n            return Err(MaxSizeReached::new());\n        }\n\n        // find first ideally placed element -- start of cluster\n        let mut first_ideal = 0;\n\n        for (i, pos) in self.indices.iter().enumerate() {\n            if let Some((_, entry_hash)) = pos.resolve() {\n                if 0 == probe_distance(self.mask, entry_hash, i) {\n                    first_ideal = i;\n                    break;\n                }\n            }\n        }\n\n        // visit the entries in an order where we can simply reinsert them\n        // into self.indices without any bucket stealing.\n        let old_indices = mem::replace(\n            &mut self.indices,\n            vec![Pos::none(); new_raw_cap].into_boxed_slice(),\n        );\n        self.mask = new_raw_cap.wrapping_sub(1) as Size;\n\n        for &pos in &old_indices[first_ideal..] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        for &pos in &old_indices[..first_ideal] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        // Reserve additional entry slots\n        let more = self.capacity() - self.entries.len();\n        self.entries.reserve_exact(more);\n        Ok(())\n    }\n\n    #[inline]\n    fn raw_links(&mut self) -> RawLinks<T> {\n        RawLinks(&mut self.entries[..] as *mut _)\n    }\n}",
            "impl<T> IntoIterator for HeaderMap<T> {\n    type Item = (Option<HeaderName>, T);\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, one that moves keys and values\n    /// out of the map in arbitrary order. The map cannot be used after calling\n    /// this.\n    ///\n    /// For each yielded item that has `None` provided for the `HeaderName`,\n    /// then the associated header name is the same as that of the previously\n    /// yielded item. The first yielded item will have `HeaderName` set.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage.\n    ///\n    /// ```\n    /// # use http::header;\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    /// map.insert(header::CONTENT_LENGTH, \"123\".parse().unwrap());\n    /// map.insert(header::CONTENT_TYPE, \"json\".parse().unwrap());\n    ///\n    /// let mut iter = map.into_iter();\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), \"123\".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), \"json\".parse().unwrap())));\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// Multiple values per key.\n    ///\n    /// ```\n    /// # use http::header;\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// map.append(header::CONTENT_LENGTH, \"123\".parse().unwrap());\n    /// map.append(header::CONTENT_LENGTH, \"456\".parse().unwrap());\n    ///\n    /// map.append(header::CONTENT_TYPE, \"json\".parse().unwrap());\n    /// map.append(header::CONTENT_TYPE, \"html\".parse().unwrap());\n    /// map.append(header::CONTENT_TYPE, \"xml\".parse().unwrap());\n    ///\n    /// let mut iter = map.into_iter();\n    ///\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), \"123\".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((None, \"456\".parse().unwrap())));\n    ///\n    /// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), \"json\".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((None, \"html\".parse().unwrap())));\n    /// assert_eq!(iter.next(), Some((None, \"xml\".parse().unwrap())));\n    /// assert!(iter.next().is_none());\n    /// ```\n    fn into_iter(self) -> IntoIter<T> {\n        IntoIter {\n            next: None,\n            entries: self.entries.into_iter(),\n            extra_values: self.extra_values,\n        }\n    }\n}"
        ],
        "header::map::IntoIter": [
            "Debug",
            "impl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        // Ensure the iterator is consumed\n        for _ in self.by_ref() {}\n\n        // All the values have already been yielded out.\n        unsafe {\n            self.extra_values.set_len(0);\n        }\n    }\n}",
            "impl<T> FusedIterator for IntoIter<T> {}",
            "impl<T> Iterator for IntoIter<T> {\n    type Item = (Option<HeaderName>, T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if let Some(next) = self.next {\n            self.next = match self.extra_values[next].next {\n                Link::Entry(_) => None,\n                Link::Extra(v) => Some(v),\n            };\n\n            let value = unsafe { ptr::read(&self.extra_values[next].value) };\n\n            return Some((None, value));\n        }\n\n        if let Some(bucket) = self.entries.next() {\n            self.next = bucket.links.map(|l| l.next);\n            let name = Some(bucket.key);\n            let value = bucket.value;\n\n            return Some((name, value));\n        }\n\n        None\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, _) = self.entries.size_hint();\n        // There could be more than just the entries upper, as there\n        // could be items in the `extra_values`. We could guess, saying\n        // `upper + extra_values.len()`, but that could overestimate by a lot.\n        (lower, None)\n    }\n}"
        ],
        "header::map::Iter": [
            "Debug",
            "impl<'a, T> FusedIterator for Iter<'a, T> {}",
            "impl<'a, T> Iterator for Iter<'a, T> {\n    type Item = (&'a HeaderName, &'a T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        if self.cursor.is_none() {\n            if (self.entry + 1) >= self.map.entries.len() {\n                return None;\n            }\n\n            self.entry += 1;\n            self.cursor = Some(Cursor::Head);\n        }\n\n        let entry = &self.map.entries[self.entry];\n\n        match self.cursor.unwrap() {\n            Head => {\n                self.cursor = entry.links.map(|l| Values(l.next));\n                Some((&entry.key, &entry.value))\n            }\n            Values(idx) => {\n                let extra = &self.map.extra_values[idx];\n\n                match extra.next {\n                    Link::Entry(_) => self.cursor = None,\n                    Link::Extra(i) => self.cursor = Some(Values(i)),\n                }\n\n                Some((&entry.key, &extra.value))\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let map = self.map;\n        debug_assert!(map.entries.len() >= self.entry);\n\n        let lower = map.entries.len() - self.entry;\n        // We could pessimistically guess at the upper bound, saying\n        // that its lower + map.extra_values.len(). That could be\n        // way over though, such as if we're near the end, and have\n        // already gone through several extra values...\n        (lower, None)\n    }\n}",
            "unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}",
            "unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}"
        ],
        "header::map::IterMut": [
            "Debug",
            "impl<'a, T> FusedIterator for IterMut<'a, T> {}",
            "impl<'a, T> IterMut<'a, T> {\n    fn next_unsafe(&mut self) -> Option<(&'a HeaderName, *mut T)> {\n        use self::Cursor::*;\n\n        if self.cursor.is_none() {\n            if (self.entry + 1) >= unsafe { &*self.map }.entries.len() {\n                return None;\n            }\n\n            self.entry += 1;\n            self.cursor = Some(Cursor::Head);\n        }\n\n        let entry = unsafe { &mut (*self.map).entries[self.entry] };\n\n        match self.cursor.unwrap() {\n            Head => {\n                self.cursor = entry.links.map(|l| Values(l.next));\n                Some((&entry.key, &mut entry.value as *mut _))\n            }\n            Values(idx) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                match extra.next {\n                    Link::Entry(_) => self.cursor = None,\n                    Link::Extra(i) => self.cursor = Some(Values(i)),\n                }\n\n                Some((&entry.key, &mut extra.value as *mut _))\n            }\n        }\n    }\n}",
            "impl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = (&'a HeaderName, &'a mut T);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next_unsafe()\n            .map(|(key, ptr)| (key, unsafe { &mut *ptr }))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let map = unsafe { &*self.map };\n        debug_assert!(map.entries.len() >= self.entry);\n\n        let lower = map.entries.len() - self.entry;\n        // We could pessimistically guess at the upper bound, saying\n        // that its lower + map.extra_values.len(). That could be\n        // way over though, such as if we're near the end, and have\n        // already gone through several extra values...\n        (lower, None)\n    }\n}",
            "unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}",
            "unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}"
        ],
        "header::map::Keys": [
            "Debug",
            "impl<'a, T> ExactSizeIterator for Keys<'a, T> {}",
            "impl<'a, T> FusedIterator for Keys<'a, T> {}",
            "impl<'a, T> Iterator for Keys<'a, T> {\n    type Item = &'a HeaderName;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|b| &b.key)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        self.inner.nth(n).map(|b| &b.key)\n    }\n\n    fn count(self) -> usize {\n        self.inner.count()\n    }\n\n    fn last(self) -> Option<Self::Item> {\n        self.inner.last().map(|b| &b.key)\n    }\n}"
        ],
        "header::map::Link": [
            "Clone",
            "Copy",
            "Debug",
            "Eq",
            "PartialEq"
        ],
        "header::map::Links": [
            "Clone",
            "Copy",
            "Debug"
        ],
        "header::map::MaxSizeReached": [
            "impl MaxSizeReached {\n    fn new() -> Self {\n        MaxSizeReached { _priv: () }\n    }\n}",
            "impl fmt::Debug for MaxSizeReached {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"MaxSizeReached\")\n            // skip _priv noise\n            .finish()\n    }\n}",
            "impl fmt::Display for MaxSizeReached {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"max size reached\")\n    }\n}",
            "impl std::error::Error for MaxSizeReached {}"
        ],
        "header::map::OccupiedEntry": [
            "Debug",
            "impl<'a, T> IntoIterator for OccupiedEntry<'a, T> {\n    type Item = &'a mut T;\n    type IntoIter = ValueIterMut<'a, T>;\n\n    fn into_iter(self) -> ValueIterMut<'a, T> {\n        self.map.value_iter_mut(self.index)\n    }\n}",
            "impl<'a, T> OccupiedEntry<'a, T> {\n    /// Returns a reference to the entry's key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry(\"host\") {\n    ///     assert_eq!(\"host\", e.key());\n    /// }\n    /// ```\n    pub fn key(&self) -> &HeaderName {\n        &self.map.entries[self.index].key\n    }\n\n    /// Get a reference to the first value in the entry.\n    ///\n    /// Values are stored in insertion order.\n    ///\n    /// # Panics\n    ///\n    /// `get` panics if there are no values associated with the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n    ///     assert_eq!(e.get(), &\"hello.world\");\n    ///\n    ///     e.append(\"hello.earth\".parse().unwrap());\n    ///\n    ///     assert_eq!(e.get(), &\"hello.world\");\n    /// }\n    /// ```\n    pub fn get(&self) -> &T {\n        &self.map.entries[self.index].value\n    }\n\n    /// Get a mutable reference to the first value in the entry.\n    ///\n    /// Values are stored in insertion order.\n    ///\n    /// # Panics\n    ///\n    /// `get_mut` panics if there are no values associated with the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, \"hello.world\".to_string());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n    ///     e.get_mut().push_str(\"-2\");\n    ///     assert_eq!(e.get(), &\"hello.world-2\");\n    /// }\n    /// ```\n    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.map.entries[self.index].value\n    }\n\n    /// Converts the `OccupiedEntry` into a mutable reference to the **first**\n    /// value.\n    ///\n    /// The lifetime of the returned reference is bound to the original map.\n    ///\n    /// # Panics\n    ///\n    /// `into_mut` panics if there are no values associated with the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, \"hello.world\".to_string());\n    /// map.append(HOST, \"hello.earth\".to_string());\n    ///\n    /// if let Entry::Occupied(e) = map.entry(\"host\") {\n    ///     e.into_mut().push_str(\"-2\");\n    /// }\n    ///\n    /// assert_eq!(\"hello.world-2\", map[\"host\"]);\n    /// ```\n    pub fn into_mut(self) -> &'a mut T {\n        &mut self.map.entries[self.index].value\n    }\n\n    /// Sets the value of the entry.\n    ///\n    /// All previous values associated with the entry are removed and the first\n    /// one is returned. See `insert_mult` for an API that returns all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"hello.world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n    ///     let mut prev = e.insert(\"earth\".parse().unwrap());\n    ///     assert_eq!(\"hello.world\", prev);\n    /// }\n    ///\n    /// assert_eq!(\"earth\", map[\"host\"]);\n    /// ```\n    pub fn insert(&mut self, value: T) -> T {\n        self.map.insert_occupied(self.index, value)\n    }\n\n    /// Sets the value of the entry.\n    ///\n    /// This function does the same as `insert` except it returns an iterator\n    /// that yields all values previously associated with the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    /// map.append(HOST, \"world2\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n    ///     let mut prev = e.insert_mult(\"earth\".parse().unwrap());\n    ///     assert_eq!(\"world\", prev.next().unwrap());\n    ///     assert_eq!(\"world2\", prev.next().unwrap());\n    ///     assert!(prev.next().is_none());\n    /// }\n    ///\n    /// assert_eq!(\"earth\", map[\"host\"]);\n    /// ```\n    pub fn insert_mult(&mut self, value: T) -> ValueDrain<'_, T> {\n        self.map.insert_occupied_mult(self.index, value)\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The new value is appended to the end of the entry's value list. All\n    /// previous values associated with the entry are retained.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n    ///     e.append(\"earth\".parse().unwrap());\n    /// }\n    ///\n    /// let values = map.get_all(\"host\");\n    /// let mut i = values.iter();\n    /// assert_eq!(\"world\", *i.next().unwrap());\n    /// assert_eq!(\"earth\", *i.next().unwrap());\n    /// ```\n    pub fn append(&mut self, value: T) {\n        let idx = self.index;\n        let entry = &mut self.map.entries[idx];\n        append_value(idx, entry, &mut self.map.extra_values, value);\n    }\n\n    /// Remove the entry from the map.\n    ///\n    /// All values associated with the entry are removed and the first one is\n    /// returned. See `remove_entry_mult` for an API that returns all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry(\"host\") {\n    ///     let mut prev = e.remove();\n    ///     assert_eq!(\"world\", prev);\n    /// }\n    ///\n    /// assert!(!map.contains_key(\"host\"));\n    /// ```\n    pub fn remove(self) -> T {\n        self.remove_entry().1\n    }\n\n    /// Remove the entry from the map.\n    ///\n    /// The key and all values associated with the entry are removed and the\n    /// first one is returned. See `remove_entry_mult` for an API that returns\n    /// all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry(\"host\") {\n    ///     let (key, mut prev) = e.remove_entry();\n    ///     assert_eq!(\"host\", key.as_str());\n    ///     assert_eq!(\"world\", prev);\n    /// }\n    ///\n    /// assert!(!map.contains_key(\"host\"));\n    /// ```\n    pub fn remove_entry(self) -> (HeaderName, T) {\n        if let Some(links) = self.map.entries[self.index].links {\n            self.map.remove_all_extra_values(links.next);\n        }\n\n        let entry = self.map.remove_found(self.probe, self.index);\n\n        (entry.key, entry.value)\n    }\n\n    /// Remove the entry from the map.\n    ///\n    /// The key and all values associated with the entry are removed and\n    /// returned.\n    pub fn remove_entry_mult(self) -> (HeaderName, ValueDrain<'a, T>) {\n        let raw_links = self.map.raw_links();\n        let extra_values = &mut self.map.extra_values;\n\n        let next = self.map.entries[self.index]\n            .links\n            .map(|l| drain_all_extra_values(raw_links, extra_values, l.next).into_iter());\n\n        let entry = self.map.remove_found(self.probe, self.index);\n\n        let drain = ValueDrain {\n            first: Some(entry.value),\n            next,\n            lt: PhantomData,\n        };\n        (entry.key, drain)\n    }\n\n    /// Returns an iterator visiting all values associated with the entry.\n    ///\n    /// Values are iterated in insertion order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::new();\n    /// map.insert(HOST, \"world\".parse().unwrap());\n    /// map.append(HOST, \"earth\".parse().unwrap());\n    ///\n    /// if let Entry::Occupied(e) = map.entry(\"host\") {\n    ///     let mut iter = e.iter();\n    ///     assert_eq!(&\"world\", iter.next().unwrap());\n    ///     assert_eq!(&\"earth\", iter.next().unwrap());\n    ///     assert!(iter.next().is_none());\n    /// }\n    /// ```\n    pub fn iter(&self) -> ValueIter<'_, T> {\n        self.map.value_iter(Some(self.index))\n    }\n\n    /// Returns an iterator mutably visiting all values associated with the\n    /// entry.\n    ///\n    /// Values are iterated in insertion order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry, HOST};\n    /// let mut map = HeaderMap::default();\n    /// map.insert(HOST, \"world\".to_string());\n    /// map.append(HOST, \"earth\".to_string());\n    ///\n    /// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n    ///     for e in e.iter_mut() {\n    ///         e.push_str(\"-boop\");\n    ///     }\n    /// }\n    ///\n    /// let mut values = map.get_all(\"host\");\n    /// let mut i = values.iter();\n    /// assert_eq!(&\"world-boop\", i.next().unwrap());\n    /// assert_eq!(&\"earth-boop\", i.next().unwrap());\n    /// ```\n    pub fn iter_mut(&mut self) -> ValueIterMut<'_, T> {\n        self.map.value_iter_mut(self.index)\n    }\n}"
        ],
        "header::map::Pos": [
            "Clone",
            "Copy",
            "impl Pos {\n    #[inline]\n    fn new(index: usize, hash: HashValue) -> Self {\n        debug_assert!(index < MAX_SIZE);\n        Pos {\n            index: index as Size,\n            hash,\n        }\n    }\n\n    #[inline]\n    fn none() -> Self {\n        Pos {\n            index: !0,\n            hash: HashValue(0),\n        }\n    }\n\n    #[inline]\n    fn is_some(&self) -> bool {\n        !self.is_none()\n    }\n\n    #[inline]\n    fn is_none(&self) -> bool {\n        self.index == !0\n    }\n\n    #[inline]\n    fn resolve(&self) -> Option<(usize, HashValue)> {\n        if self.is_some() {\n            Some((self.index as usize, self.hash))\n        } else {\n            None\n        }\n    }\n}"
        ],
        "header::map::RawLinks": [
            "Debug",
            "impl<T> Clone for RawLinks<T> {\n    fn clone(&self) -> RawLinks<T> {\n        *self\n    }\n}",
            "impl<T> Copy for RawLinks<T> {}",
            "impl<T> ops::Index<usize> for RawLinks<T> {\n    type Output = Option<Links>;\n\n    fn index(&self, idx: usize) -> &Self::Output {\n        unsafe { &(*self.0)[idx].links }\n    }\n}",
            "impl<T> ops::IndexMut<usize> for RawLinks<T> {\n    fn index_mut(&mut self, idx: usize) -> &mut Self::Output {\n        unsafe { &mut (*self.0)[idx].links }\n    }\n}"
        ],
        "header::map::VacantEntry": [
            "Debug",
            "impl<'a, T> VacantEntry<'a, T> {\n    /// Returns a reference to the entry's key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::HeaderMap;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// assert_eq!(map.entry(\"x-hello\").key().as_str(), \"x-hello\");\n    /// ```\n    pub fn key(&self) -> &HeaderName {\n        &self.key\n    }\n\n    /// Take ownership of the key\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry(\"x-hello\") {\n    ///     assert_eq!(v.into_key().as_str(), \"x-hello\");\n    /// }\n    /// ```\n    pub fn into_key(self) -> HeaderName {\n        self.key\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The value will be associated with this entry's key. A mutable reference\n    /// to the inserted value will be returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry(\"x-hello\") {\n    ///     v.insert(\"world\".parse().unwrap());\n    /// }\n    ///\n    /// assert_eq!(map[\"x-hello\"], \"world\");\n    /// ```\n    pub fn insert(self, value: T) -> &'a mut T {\n        self.try_insert(value).expect(\"size overflows MAX_SIZE\")\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The value will be associated with this entry's key. A mutable reference\n    /// to the inserted value will be returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderMap, Entry};\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry(\"x-hello\") {\n    ///     v.insert(\"world\".parse().unwrap());\n    /// }\n    ///\n    /// assert_eq!(map[\"x-hello\"], \"world\");\n    /// ```\n    pub fn try_insert(self, value: T) -> Result<&'a mut T, MaxSizeReached> {\n        // Ensure that there is space in the map\n        let index =\n            self.map\n                .try_insert_phase_two(self.key, value, self.hash, self.probe, self.danger)?;\n\n        Ok(&mut self.map.entries[index].value)\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The value will be associated with this entry's key. The new\n    /// `OccupiedEntry` is returned, allowing for further manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.try_entry(\"x-hello\").unwrap() {\n    ///     let mut e = v.try_insert_entry(\"world\".parse().unwrap()).unwrap();\n    ///     e.insert(\"world2\".parse().unwrap());\n    /// }\n    ///\n    /// assert_eq!(map[\"x-hello\"], \"world2\");\n    /// ```\n    pub fn insert_entry(self, value: T) -> OccupiedEntry<'a, T> {\n        self.try_insert_entry(value)\n            .expect(\"size overflows MAX_SIZE\")\n    }\n\n    /// Insert the value into the entry.\n    ///\n    /// The value will be associated with this entry's key. The new\n    /// `OccupiedEntry` is returned, allowing for further manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// let mut map = HeaderMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.try_entry(\"x-hello\").unwrap() {\n    ///     let mut e = v.try_insert_entry(\"world\".parse().unwrap()).unwrap();\n    ///     e.insert(\"world2\".parse().unwrap());\n    /// }\n    ///\n    /// assert_eq!(map[\"x-hello\"], \"world2\");\n    /// ```\n    pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n        // Ensure that there is space in the map\n        let index =\n            self.map\n                .try_insert_phase_two(self.key, value, self.hash, self.probe, self.danger)?;\n\n        Ok(OccupiedEntry {\n            map: self.map,\n            index,\n            probe: self.probe,\n        })\n    }\n}"
        ],
        "header::map::ValueDrain": [
            "Debug",
            "impl<'a, T> Drop for ValueDrain<'a, T> {\n    fn drop(&mut self) {\n        for _ in self.by_ref() {}\n    }\n}",
            "impl<'a, T> FusedIterator for ValueDrain<'a, T> {}",
            "impl<'a, T> Iterator for ValueDrain<'a, T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        if self.first.is_some() {\n            self.first.take()\n        } else if let Some(ref mut extras) = self.next {\n            extras.next()\n        } else {\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match (&self.first, &self.next) {\n            // Exactly 1\n            (&Some(_), &None) => (1, Some(1)),\n            // 1 + extras\n            (&Some(_), Some(extras)) => {\n                let (l, u) = extras.size_hint();\n                (l + 1, u.map(|u| u + 1))\n            }\n            // Extras only\n            (&None, Some(extras)) => extras.size_hint(),\n            // No more\n            (&None, &None) => (0, Some(0)),\n        }\n    }\n}",
            "unsafe impl<'a, T: Send> Send for ValueDrain<'a, T> {}",
            "unsafe impl<'a, T: Sync> Sync for ValueDrain<'a, T> {}"
        ],
        "header::map::ValueIter": [
            "Debug",
            "impl<'a, T: 'a> DoubleEndedIterator for ValueIter<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&self.map.entries[self.index].value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }\n}",
            "impl<'a, T: 'a> Iterator for ValueIter<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        match self.front {\n            Some(Head) => {\n                let entry = &self.map.entries[self.index];\n\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match (self.front, self.back) {\n            // Exactly 1 value...\n            (Some(Cursor::Head), Some(Cursor::Head)) => (1, Some(1)),\n            // At least 1...\n            (Some(_), _) => (1, None),\n            // No more values...\n            (None, _) => (0, Some(0)),\n        }\n    }\n}",
            "impl<'a, T> FusedIterator for ValueIter<'a, T> {}"
        ],
        "header::map::ValueIterMut": [
            "Debug",
            "impl<'a, T: 'a> DoubleEndedIterator for ValueIterMut<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }\n}",
            "impl<'a, T: 'a> Iterator for ValueIterMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.front {\n            Some(Head) => {\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }\n}",
            "impl<'a, T> FusedIterator for ValueIterMut<'a, T> {}",
            "unsafe impl<'a, T: Send> Send for ValueIterMut<'a, T> {}",
            "unsafe impl<'a, T: Sync> Sync for ValueIterMut<'a, T> {}"
        ],
        "header::map::Values": [
            "Debug",
            "impl<'a, T> FusedIterator for Values<'a, T> {}",
            "impl<'a, T> Iterator for Values<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|(_, v)| v)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}"
        ],
        "header::map::ValuesMut": [
            "Debug",
            "impl<'a, T> FusedIterator for ValuesMut<'a, T> {}",
            "impl<'a, T> Iterator for ValuesMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next().map(|(_, v)| v)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.inner.size_hint()\n    }\n}"
        ],
        "header::map::as_header_name::TryEntryError": [
            "impl From<InvalidHeaderName> for TryEntryError {\n        fn from(e: InvalidHeaderName) -> TryEntryError {\n            TryEntryError::InvalidHeaderName(e)\n        }\n    }",
            "impl From<MaxSizeReached> for TryEntryError {\n        fn from(e: MaxSizeReached) -> TryEntryError {\n            TryEntryError::MaxSizeReached(e)\n        }\n    }"
        ],
        "header::name::Custom": [
            "Clone",
            "Debug",
            "Eq",
            "PartialEq",
            "impl Hash for Custom {\n    #[inline]\n    fn hash<H: Hasher>(&self, hasher: &mut H) {\n        hasher.write(self.0.as_bytes())\n    }\n}"
        ],
        "header::name::HdrName": [
            "Debug",
            "Hash",
            "impl<'a> From<StandardHeader> for HdrName<'a> {\n    fn from(hdr: StandardHeader) -> HdrName<'a> {\n        HdrName {\n            inner: Repr::Standard(hdr),\n        }\n    }\n}",
            "impl<'a> HdrName<'a> {\n    // Precondition: if lower then buf is valid UTF-8\n    fn custom(buf: &'a [u8], lower: bool) -> HdrName<'a> {\n        HdrName {\n            // Invariant (on MaybeLower): follows from the precondition\n            inner: Repr::Custom(MaybeLower { buf, lower }),\n        }\n    }\n\n    pub fn from_bytes<F, U>(hdr: &[u8], f: F) -> Result<U, InvalidHeaderName>\n    where\n        F: FnOnce(HdrName<'_>) -> U,\n    {\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n        let hdr = parse_hdr(hdr, &mut buf, &HEADER_CHARS)?;\n        Ok(f(hdr))\n    }\n\n    pub fn from_static<F, U>(hdr: &'static str, f: F) -> U\n    where\n        F: FnOnce(HdrName<'_>) -> U,\n    {\n        let mut buf = uninit_u8_array();\n        let hdr =\n            // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n            parse_hdr(hdr.as_bytes(), &mut buf, &HEADER_CHARS).expect(\"static str is invalid name\");\n        f(hdr)\n    }\n}"
        ],
        "header::name::HeaderName": [
            "Clone",
            "Eq",
            "Hash",
            "PartialEq",
            "impl AsHeaderName for HeaderName {}",
            "impl AsRef<[u8]> for HeaderName {\n    fn as_ref(&self) -> &[u8] {\n        self.as_str().as_bytes()\n    }\n}",
            "impl AsRef<str> for HeaderName {\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}",
            "impl Borrow<str> for HeaderName {\n    fn borrow(&self) -> &str {\n        self.as_str()\n    }\n}",
            "impl From<Custom> for HeaderName {\n    fn from(src: Custom) -> HeaderName {\n        HeaderName {\n            inner: Repr::Custom(src),\n        }\n    }\n}",
            "impl From<StandardHeader> for HeaderName {\n    fn from(src: StandardHeader) -> HeaderName {\n        HeaderName {\n            inner: Repr::Standard(src),\n        }\n    }\n}",
            "impl FromStr for HeaderName {\n    type Err = InvalidHeaderName;\n\n    fn from_str(s: &str) -> Result<HeaderName, InvalidHeaderName> {\n        HeaderName::from_bytes(s.as_bytes()).map_err(|_| InvalidHeaderName { _priv: () })\n    }\n}",
            "impl HeaderName {\n    /// Converts a slice of bytes to an HTTP header name.\n    ///\n    /// This function normalizes the input.\n    pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n        match parse_hdr(src, &mut buf, &HEADER_CHARS)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                use bytes::BufMut;\n                let mut dst = BytesMut::with_capacity(buf.len());\n\n                for b in buf.iter() {\n                    // HEADER_CHARS maps all bytes to valid single-byte UTF-8\n                    let b = HEADER_CHARS[*b as usize];\n\n                    if b == 0 {\n                        return Err(InvalidHeaderName::new());\n                    }\n\n                    dst.put_u8(b);\n                }\n\n                // Safety: the loop above maps all bytes in buf to valid single byte\n                // UTF-8 before copying them into dst. This means that dst (and hence\n                // dst.freeze()) is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                Ok(Custom(val).into())\n            }\n        }\n    }\n\n    /// Converts a slice of bytes to an HTTP header name.\n    ///\n    /// This function expects the input to only contain lowercase characters.\n    /// This is useful when decoding HTTP/2.0 or HTTP/3.0 headers. Both\n    /// require that all headers be represented in lower case.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    ///\n    /// // Parsing a lower case header\n    /// let hdr = HeaderName::from_lowercase(b\"content-length\").unwrap();\n    /// assert_eq!(CONTENT_LENGTH, hdr);\n    ///\n    /// // Parsing a header that contains uppercase characters\n    /// assert!(HeaderName::from_lowercase(b\"Content-Length\").is_err());\n    /// ```\n    pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS_H2 is a valid table for parse_hdr()\n        match parse_hdr(src, &mut buf, &HEADER_CHARS_H2)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                for &b in buf.iter() {\n                    // HEADER_CHARS_H2 maps all bytes that are not valid single-byte\n                    // UTF-8 to 0 so this check returns an error for invalid UTF-8.\n                    if HEADER_CHARS_H2[b as usize] == 0 {\n                        return Err(InvalidHeaderName::new());\n                    }\n                }\n\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the loop above checks that each byte of buf (either\n                // version) is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n        }\n    }\n\n    /// Converts a static string to a HTTP header name.\n    ///\n    /// This function requires the static string to only contain lowercase\n    /// characters, numerals and symbols, as per the HTTP/2.0 specification\n    /// and header names internal representation within this library.\n    ///\n    /// # Panics\n    ///\n    /// This function panics when the static string is a invalid header.\n    ///\n    /// Until [Allow panicking in constants](https://github.com/rust-lang/rfcs/pull/2345)\n    /// makes its way into stable, the panic message at compile-time is\n    /// going to look cryptic, but should at least point at your header value:\n    ///\n    /// ```text\n    /// error: any use of this value will cause an error\n    ///     --> http/src/header/name.rs:1241:13\n    ///      |\n    /// 1241 |             ([] as [u8; 0])[0]; // Invalid header name\n    ///      |             ^^^^^^^^^^^^^^^^^^\n    ///      |             |\n    ///      |             index out of bounds: the length is 0 but the index is 0\n    ///      |             inside `http::HeaderName::from_static` at http/src/header/name.rs:1241:13\n    ///      |             inside `INVALID_NAME` at src/main.rs:3:34\n    ///      |\n    ///     ::: src/main.rs:3:1\n    ///      |\n    /// 3    | const INVALID_NAME: HeaderName = HeaderName::from_static(\"Capitalized\");\n    ///      | ------------------------------------------------------------------------\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::*;\n    /// // Parsing a standard header\n    /// let hdr = HeaderName::from_static(\"content-length\");\n    /// assert_eq!(CONTENT_LENGTH, hdr);\n    ///\n    /// // Parsing a custom header\n    /// let CUSTOM_HEADER: &'static str = \"custom-header\";\n    ///\n    /// let a = HeaderName::from_lowercase(b\"custom-header\").unwrap();\n    /// let b = HeaderName::from_static(CUSTOM_HEADER);\n    /// assert_eq!(a, b);\n    /// ```\n    ///\n    /// ```should_panic\n    /// # use http::header::*;\n    /// #\n    /// // Parsing a header that contains invalid symbols(s):\n    /// HeaderName::from_static(\"content{}{}length\"); // This line panics!\n    ///\n    /// // Parsing a header that contains invalid uppercase characters.\n    /// let a = HeaderName::from_static(\"foobar\");\n    /// let b = HeaderName::from_static(\"FOOBAR\"); // This line panics!\n    /// ```\n    #[allow(unconditional_panic)] // required for the panic circumvention\n    pub const fn from_static(src: &'static str) -> HeaderName {\n        let name_bytes = src.as_bytes();\n        if let Some(standard) = StandardHeader::from_bytes(name_bytes) {\n            return HeaderName {\n                inner: Repr::Standard(standard),\n            };\n        }\n\n        if name_bytes.is_empty() || name_bytes.len() > super::MAX_HEADER_NAME_LEN || {\n            let mut i = 0;\n            loop {\n                if i >= name_bytes.len() {\n                    break false;\n                } else if HEADER_CHARS_H2[name_bytes[i] as usize] == 0 {\n                    break true;\n                }\n                i += 1;\n            }\n        } {\n            // TODO: When msrv is bumped to larger than 1.57, this should be\n            // replaced with `panic!` macro.\n            // https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html#panic-in-const-contexts\n            //\n            // See the panics section of this method's document for details.\n            #[allow(clippy::no_effect, clippy::out_of_bounds_indexing)]\n            ([] as [u8; 0])[0]; // Invalid header name\n        }\n\n        HeaderName {\n            inner: Repr::Custom(Custom(ByteStr::from_static(src))),\n        }\n    }\n\n    /// Returns a `str` representation of the header.\n    ///\n    /// The returned string will always be lower case.\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        match self.inner {\n            Repr::Standard(v) => v.as_str(),\n            Repr::Custom(ref v) => &v.0,\n        }\n    }\n\n    pub(super) fn into_bytes(self) -> Bytes {\n        self.inner.into()\n    }\n}",
            "impl IntoHeaderName for HeaderName {}",
            "impl PartialEq<str> for HeaderName {\n    /// Performs a case-insensitive comparison of the string against the header\n    /// name\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use http::header::CONTENT_LENGTH;\n    ///\n    /// assert_eq!(CONTENT_LENGTH, \"content-length\");\n    /// assert_eq!(CONTENT_LENGTH, \"Content-Length\");\n    /// assert_ne!(CONTENT_LENGTH, \"content length\");\n    /// ```\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        eq_ignore_ascii_case(self.as_ref(), other.as_bytes())\n    }\n}",
            "impl Sealed for HeaderName {\n        #[inline]\n        fn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError> {\n            Ok(map.try_entry2(self)?)\n        }\n\n        #[inline]\n        fn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)> {\n            map.find(self)\n        }\n\n        fn as_str(&self) -> &str {\n            <HeaderName>::as_str(self)\n        }\n    }",
            "impl Sealed for HeaderName {\n        #[inline]\n        fn try_insert<T>(\n            self,\n            map: &mut HeaderMap<T>,\n            val: T,\n        ) -> Result<Option<T>, MaxSizeReached> {\n            map.try_insert2(self, val)\n        }\n\n        #[inline]\n        fn try_append<T>(self, map: &mut HeaderMap<T>, val: T) -> Result<bool, MaxSizeReached> {\n            map.try_append2(self, val)\n        }\n\n        #[inline]\n        fn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, MaxSizeReached> {\n            map.try_entry2(self)\n        }\n    }",
            "impl TryFrom<String> for HeaderName {\n    type Error = InvalidHeaderName;\n\n    #[inline]\n    fn try_from(s: String) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}",
            "impl TryFrom<Vec<u8>> for HeaderName {\n    type Error = InvalidHeaderName;\n\n    #[inline]\n    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {\n        Self::from_bytes(&vec)\n    }\n}",
            "impl fmt::Debug for HeaderName {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.as_str(), fmt)\n    }\n}",
            "impl fmt::Display for HeaderName {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.as_str(), fmt)\n    }\n}",
            "impl<'a> From<&'a HeaderName> for HeaderName {\n    fn from(src: &'a HeaderName) -> HeaderName {\n        src.clone()\n    }\n}",
            "impl<'a> From<HdrName<'a>> for HeaderName {\n    fn from(src: HdrName<'a>) -> HeaderName {\n        match src.inner {\n            Repr::Standard(s) => HeaderName {\n                inner: Repr::Standard(s),\n            },\n            Repr::Custom(maybe_lower) => {\n                if maybe_lower.lower {\n                    let buf = Bytes::copy_from_slice(maybe_lower.buf);\n                    // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                    let byte_str = unsafe { ByteStr::from_utf8_unchecked(buf) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(byte_str)),\n                    }\n                } else {\n                    use bytes::BufMut;\n                    let mut dst = BytesMut::with_capacity(maybe_lower.buf.len());\n\n                    for b in maybe_lower.buf.iter() {\n                        // HEADER_CHARS maps each byte to a valid single-byte UTF-8\n                        // codepoint.\n                        dst.put_u8(HEADER_CHARS[*b as usize]);\n                    }\n\n                    // Safety: the loop above maps each byte of maybe_lower.buf to a\n                    // valid single-byte UTF-8 codepoint before copying it into dst.\n                    // dst (and hence dst.freeze()) is thus valid UTF-8.\n                    let buf = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(buf)),\n                    }\n                }\n            }\n        }\n    }\n}",
            "impl<'a> PartialEq<&'a HeaderName> for HeaderName {\n    #[inline]\n    fn eq(&self, other: &&'a HeaderName) -> bool {\n        *self == **other\n    }\n}",
            "impl<'a> PartialEq<&'a str> for HeaderName {\n    /// Performs a case-insensitive comparison of the string against the header\n    /// name\n    #[inline]\n    fn eq(&self, other: &&'a str) -> bool {\n        *self == **other\n    }\n}",
            "impl<'a> PartialEq<HdrName<'a>> for HeaderName {\n    #[inline]\n    fn eq(&self, other: &HdrName<'a>) -> bool {\n        match self.inner {\n            Repr::Standard(a) => match other.inner {\n                Repr::Standard(b) => a == b,\n                _ => false,\n            },\n            Repr::Custom(Custom(ref a)) => match other.inner {\n                Repr::Custom(ref b) => {\n                    if b.lower {\n                        a.as_bytes() == b.buf\n                    } else {\n                        eq_ignore_ascii_case(a.as_bytes(), b.buf)\n                    }\n                }\n                _ => false,\n            },\n        }\n    }\n}",
            "impl<'a> TryFrom<&'a String> for HeaderName {\n    type Error = InvalidHeaderName;\n    #[inline]\n    fn try_from(s: &'a String) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}",
            "impl<'a> TryFrom<&'a [u8]> for HeaderName {\n    type Error = InvalidHeaderName;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        Self::from_bytes(s)\n    }\n}",
            "impl<'a> TryFrom<&'a str> for HeaderName {\n    type Error = InvalidHeaderName;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}"
        ],
        "header::name::InvalidHeaderName": [
            "impl Error for InvalidHeaderName {}",
            "impl InvalidHeaderName {\n    pub(super) fn new() -> InvalidHeaderName {\n        InvalidHeaderName { _priv: () }\n    }\n}",
            "impl fmt::Debug for InvalidHeaderName {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"InvalidHeaderName\")\n            // skip _priv noise\n            .finish()\n    }\n}",
            "impl fmt::Display for InvalidHeaderName {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"invalid HTTP header name\")\n    }\n}"
        ],
        "header::name::MaybeLower": [
            "Clone",
            "Debug",
            "impl<'a> Hash for MaybeLower<'a> {\n    #[inline]\n    fn hash<H: Hasher>(&self, hasher: &mut H) {\n        if self.lower {\n            hasher.write(self.buf);\n        } else {\n            for &b in self.buf {\n                hasher.write(&[HEADER_CHARS[b as usize]]);\n            }\n        }\n    }\n}"
        ],
        "header::name::Repr": [
            "Clone",
            "Debug",
            "Eq",
            "Hash",
            "PartialEq"
        ],
        "header::name::StandardHeader": [
            "Clone",
            "Copy",
            "Debug",
            "Eq",
            "Hash",
            "PartialEq",
            "impl StandardHeader {\n            #[inline]\n            fn as_str(&self) -> &'static str {\n                match *self {\n                    // Safety: test_parse_standard_headers ensures these &[u8]s are &str-safe.\n                    $(\n                    StandardHeader::$konst => unsafe { std::str::from_utf8_unchecked( $name_bytes ) },\n                    )+\n                }\n            }\n\n            const fn from_bytes(name_bytes: &[u8]) -> Option<StandardHeader> {\n                match name_bytes {\n                    $(\n                        $name_bytes => Some(StandardHeader::$konst),\n                    )+\n                    _ => None,\n                }\n            }\n        }"
        ],
        "header::value::HeaderValue": [
            "Clone",
            "impl AsRef<[u8]> for HeaderValue {\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n        self.inner.as_ref()\n    }\n}",
            "impl Eq for HeaderValue {}",
            "impl From<$t> for HeaderValue {\n            fn from(num: $t) -> HeaderValue {\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }\n        }",
            "impl From<HeaderName> for HeaderValue {\n    #[inline]\n    fn from(h: HeaderName) -> HeaderValue {\n        HeaderValue {\n            inner: h.into_bytes(),\n            is_sensitive: false,\n        }\n    }\n}",
            "impl FromStr for HeaderValue {\n    type Err = InvalidHeaderValue;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<HeaderValue, Self::Err> {\n        HeaderValue::from_str(s)\n    }\n}",
            "impl Hash for HeaderValue {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.inner.hash(state);\n    }\n}",
            "impl HeaderValue {\n    /// Convert a static string to a `HeaderValue`.\n    ///\n    /// This function will not perform any copying, however the string is\n    /// checked to ensure that no invalid characters are present. Only visible\n    /// ASCII characters (32-127) are permitted.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument contains invalid header value\n    /// characters.\n    ///\n    /// Until [Allow panicking in constants](https://github.com/rust-lang/rfcs/pull/2345)\n    /// makes its way into stable, the panic message at compile-time is\n    /// going to look cryptic, but should at least point at your header value:\n    ///\n    /// ```text\n    /// error: any use of this value will cause an error\n    ///   --> http/src/header/value.rs:67:17\n    ///    |\n    /// 67 |                 ([] as [u8; 0])[0]; // Invalid header value\n    ///    |                 ^^^^^^^^^^^^^^^^^^\n    ///    |                 |\n    ///    |                 index out of bounds: the length is 0 but the index is 0\n    ///    |                 inside `HeaderValue::from_static` at http/src/header/value.rs:67:17\n    ///    |                 inside `INVALID_HEADER` at src/main.rs:73:33\n    ///    |\n    ///   ::: src/main.rs:73:1\n    ///    |\n    /// 73 | const INVALID_HEADER: HeaderValue = HeaderValue::from_static(\"some value\");\n    ///    | ----------------------------------------------------------------------------\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static(\"hello\");\n    /// assert_eq!(val, \"hello\");\n    /// ```\n    #[inline]\n    #[allow(unconditional_panic)] // required for the panic circumvention\n    pub const fn from_static(src: &'static str) -> HeaderValue {\n        let bytes = src.as_bytes();\n        let mut i = 0;\n        while i < bytes.len() {\n            if !is_visible_ascii(bytes[i]) {\n                // TODO: When msrv is bumped to larger than 1.57, this should be\n                // replaced with `panic!` macro.\n                // https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html#panic-in-const-contexts\n                //\n                // See the panics section of this method's document for details.\n                #[allow(clippy::no_effect, clippy::out_of_bounds_indexing)]\n                ([] as [u8; 0])[0]; // Invalid header value\n            }\n            i += 1;\n        }\n\n        HeaderValue {\n            inner: Bytes::from_static(bytes),\n            is_sensitive: false,\n        }\n    }\n\n    /// Attempt to convert a string to a `HeaderValue`.\n    ///\n    /// If the argument contains invalid header value characters, an error is\n    /// returned. Only visible ASCII characters (32-127) are permitted. Use\n    /// `from_bytes` to create a `HeaderValue` that includes opaque octets\n    /// (128-255).\n    ///\n    /// This function is intended to be replaced in the future by a `TryFrom`\n    /// implementation once the trait is stabilized in std.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_str(\"hello\").unwrap();\n    /// assert_eq!(val, \"hello\");\n    /// ```\n    ///\n    /// An invalid value\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_str(\"\\n\");\n    /// assert!(val.is_err());\n    /// ```\n    #[inline]\n    #[allow(clippy::should_implement_trait)]\n    pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n        HeaderValue::try_from_generic(src, |s| Bytes::copy_from_slice(s.as_bytes()))\n    }\n\n    /// Converts a HeaderName into a HeaderValue\n    ///\n    /// Since every valid HeaderName is a valid HeaderValue this is done infallibly.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::{HeaderValue, HeaderName};\n    /// # use http::header::ACCEPT;\n    /// let val = HeaderValue::from_name(ACCEPT);\n    /// assert_eq!(val, HeaderValue::from_bytes(b\"accept\").unwrap());\n    /// ```\n    #[inline]\n    pub fn from_name(name: HeaderName) -> HeaderValue {\n        name.into()\n    }\n\n    /// Attempt to convert a byte slice to a `HeaderValue`.\n    ///\n    /// If the argument contains invalid header value bytes, an error is\n    /// returned. Only byte values between 32 and 255 (inclusive) are permitted,\n    /// excluding byte 127 (DEL).\n    ///\n    /// This function is intended to be replaced in the future by a `TryFrom`\n    /// implementation once the trait is stabilized in std.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_bytes(b\"hello\\xfa\").unwrap();\n    /// assert_eq!(val, &b\"hello\\xfa\"[..]);\n    /// ```\n    ///\n    /// An invalid value\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_bytes(b\"\\n\");\n    /// assert!(val.is_err());\n    /// ```\n    #[inline]\n    pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n        HeaderValue::try_from_generic(src, Bytes::copy_from_slice)\n    }\n\n    /// Attempt to convert a `Bytes` buffer to a `HeaderValue`.\n    ///\n    /// This will try to prevent a copy if the type passed is the type used\n    /// internally, and will copy the data if it is not.\n    pub fn from_maybe_shared<T>(src: T) -> Result<HeaderValue, InvalidHeaderValue>\n    where\n        T: AsRef<[u8]> + 'static,\n    {\n        if_downcast_into!(T, Bytes, src, {\n            return HeaderValue::from_shared(src);\n        });\n\n        HeaderValue::from_bytes(src.as_ref())\n    }\n\n    /// Convert a `Bytes` directly into a `HeaderValue` without validating.\n    ///\n    /// This function does NOT validate that illegal bytes are not contained\n    /// within the buffer.\n    ///\n    /// ## Panics\n    /// In a debug build this will panic if `src` is not valid UTF-8.\n    ///\n    /// ## Safety\n    /// `src` must contain valid UTF-8. In a release build it is undefined\n    /// behaviour to call this with `src` that is not valid UTF-8.\n    pub unsafe fn from_maybe_shared_unchecked<T>(src: T) -> HeaderValue\n    where\n        T: AsRef<[u8]> + 'static,\n    {\n        if cfg!(debug_assertions) {\n            match HeaderValue::from_maybe_shared(src) {\n                Ok(val) => val,\n                Err(_err) => {\n                    panic!(\"HeaderValue::from_maybe_shared_unchecked() with invalid bytes\");\n                }\n            }\n        } else {\n            if_downcast_into!(T, Bytes, src, {\n                return HeaderValue {\n                    inner: src,\n                    is_sensitive: false,\n                };\n            });\n\n            let src = Bytes::copy_from_slice(src.as_ref());\n            HeaderValue {\n                inner: src,\n                is_sensitive: false,\n            }\n        }\n    }\n\n    fn from_shared(src: Bytes) -> Result<HeaderValue, InvalidHeaderValue> {\n        HeaderValue::try_from_generic(src, std::convert::identity)\n    }\n\n    fn try_from_generic<T: AsRef<[u8]>, F: FnOnce(T) -> Bytes>(\n        src: T,\n        into: F,\n    ) -> Result<HeaderValue, InvalidHeaderValue> {\n        for &b in src.as_ref() {\n            if !is_valid(b) {\n                return Err(InvalidHeaderValue { _priv: () });\n            }\n        }\n        Ok(HeaderValue {\n            inner: into(src),\n            is_sensitive: false,\n        })\n    }\n\n    /// Yields a `&str` slice if the `HeaderValue` only contains visible ASCII\n    /// chars.\n    ///\n    /// This function will perform a scan of the header value, checking all the\n    /// characters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static(\"hello\");\n    /// assert_eq!(val.to_str().unwrap(), \"hello\");\n    /// ```\n    pub fn to_str(&self) -> Result<&str, ToStrError> {\n        let bytes = self.as_ref();\n\n        for &b in bytes {\n            if !is_visible_ascii(b) {\n                return Err(ToStrError { _priv: () });\n            }\n        }\n\n        unsafe { Ok(str::from_utf8_unchecked(bytes)) }\n    }\n\n    /// Returns the length of `self`.\n    ///\n    /// This length is in bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static(\"hello\");\n    /// assert_eq!(val.len(), 5);\n    /// ```\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.as_ref().len()\n    }\n\n    /// Returns true if the `HeaderValue` has a length of zero bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static(\"\");\n    /// assert!(val.is_empty());\n    ///\n    /// let val = HeaderValue::from_static(\"hello\");\n    /// assert!(!val.is_empty());\n    /// ```\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Converts a `HeaderValue` to a byte slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let val = HeaderValue::from_static(\"hello\");\n    /// assert_eq!(val.as_bytes(), b\"hello\");\n    /// ```\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8] {\n        self.as_ref()\n    }\n\n    /// Mark that the header value represents sensitive information.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let mut val = HeaderValue::from_static(\"my secret\");\n    ///\n    /// val.set_sensitive(true);\n    /// assert!(val.is_sensitive());\n    ///\n    /// val.set_sensitive(false);\n    /// assert!(!val.is_sensitive());\n    /// ```\n    #[inline]\n    pub fn set_sensitive(&mut self, val: bool) {\n        self.is_sensitive = val;\n    }\n\n    /// Returns `true` if the value represents sensitive data.\n    ///\n    /// Sensitive data could represent passwords or other data that should not\n    /// be stored on disk or in memory. By marking header values as sensitive,\n    /// components using this crate can be instructed to treat them with special\n    /// care for security reasons. For example, caches can avoid storing\n    /// sensitive values, and HPACK encoders used by HTTP/2.0 implementations\n    /// can choose not to compress them.\n    ///\n    /// Additionally, sensitive values will be masked by the `Debug`\n    /// implementation of `HeaderValue`.\n    ///\n    /// Note that sensitivity is not factored into equality or ordering.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::header::HeaderValue;\n    /// let mut val = HeaderValue::from_static(\"my secret\");\n    ///\n    /// val.set_sensitive(true);\n    /// assert!(val.is_sensitive());\n    ///\n    /// val.set_sensitive(false);\n    /// assert!(!val.is_sensitive());\n    /// ```\n    #[inline]\n    pub fn is_sensitive(&self) -> bool {\n        self.is_sensitive\n    }\n}",
            "impl Ord for HeaderValue {\n    #[inline]\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n        self.inner.cmp(&other.inner)\n    }\n}",
            "impl PartialEq for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &HeaderValue) -> bool {\n        self.inner == other.inner\n    }\n}",
            "impl PartialEq<String> for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n        *self == other[..]\n    }\n}",
            "impl PartialEq<[u8]> for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &[u8]) -> bool {\n        self.inner == other\n    }\n}",
            "impl PartialEq<str> for HeaderValue {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        self.inner == other.as_bytes()\n    }\n}",
            "impl PartialOrd for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}",
            "impl PartialOrd<String> for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {\n        self.inner.partial_cmp(other.as_bytes())\n    }\n}",
            "impl PartialOrd<[u8]> for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &[u8]) -> Option<cmp::Ordering> {\n        (*self.inner).partial_cmp(other)\n    }\n}",
            "impl PartialOrd<str> for HeaderValue {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        (*self.inner).partial_cmp(other.as_bytes())\n    }\n}",
            "impl TryFrom<String> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(t: String) -> Result<Self, Self::Error> {\n        HeaderValue::from_shared(t.into())\n    }\n}",
            "impl TryFrom<Vec<u8>> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {\n        HeaderValue::from_shared(vec.into())\n    }\n}",
            "impl fmt::Debug for HeaderValue {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.is_sensitive {\n            f.write_str(\"Sensitive\")\n        } else {\n            f.write_str(\"\\\"\")?;\n            let mut from = 0;\n            let bytes = self.as_bytes();\n            for (i, &b) in bytes.iter().enumerate() {\n                if !is_visible_ascii(b) || b == b'\"' {\n                    if from != i {\n                        f.write_str(unsafe { str::from_utf8_unchecked(&bytes[from..i]) })?;\n                    }\n                    if b == b'\"' {\n                        f.write_str(\"\\\\\\\"\")?;\n                    } else {\n                        write!(f, \"\\\\x{:x}\", b)?;\n                    }\n                    from = i + 1;\n                }\n            }\n\n            f.write_str(unsafe { str::from_utf8_unchecked(&bytes[from..]) })?;\n            f.write_str(\"\\\"\")\n        }\n    }\n}",
            "impl<'a, T: ?Sized> PartialEq<&'a T> for HeaderValue\nwhere\n    HeaderValue: PartialEq<T>,\n{\n    #[inline]\n    fn eq(&self, other: &&'a T) -> bool {\n        *self == **other\n    }\n}",
            "impl<'a, T: ?Sized> PartialOrd<&'a T> for HeaderValue\nwhere\n    HeaderValue: PartialOrd<T>,\n{\n    #[inline]\n    fn partial_cmp(&self, other: &&'a T) -> Option<cmp::Ordering> {\n        self.partial_cmp(*other)\n    }\n}",
            "impl<'a> From<&'a HeaderValue> for HeaderValue {\n    #[inline]\n    fn from(t: &'a HeaderValue) -> Self {\n        t.clone()\n    }\n}",
            "impl<'a> TryFrom<&'a String> for HeaderValue {\n    type Error = InvalidHeaderValue;\n    #[inline]\n    fn try_from(s: &'a String) -> Result<Self, Self::Error> {\n        Self::from_bytes(s.as_bytes())\n    }\n}",
            "impl<'a> TryFrom<&'a [u8]> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        HeaderValue::from_bytes(t)\n    }\n}",
            "impl<'a> TryFrom<&'a str> for HeaderValue {\n    type Error = InvalidHeaderValue;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}"
        ],
        "header::value::InvalidHeaderValue": [
            "impl Error for InvalidHeaderValue {}",
            "impl fmt::Debug for InvalidHeaderValue {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"InvalidHeaderValue\")\n            // skip _priv noise\n            .finish()\n    }\n}",
            "impl fmt::Display for InvalidHeaderValue {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"failed to parse header value\")\n    }\n}"
        ],
        "header::value::ToStrError": [
            "Debug",
            "impl Error for ToStrError {}",
            "impl fmt::Display for ToStrError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"failed to convert header to a str\")\n    }\n}"
        ],
        "method::Inner": [
            "Clone",
            "Eq",
            "Hash",
            "PartialEq"
        ],
        "method::InvalidMethod": [
            "impl Error for InvalidMethod {}",
            "impl InvalidMethod {\n    fn new() -> InvalidMethod {\n        InvalidMethod { _priv: () }\n    }\n}",
            "impl fmt::Debug for InvalidMethod {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"InvalidMethod\")\n            // skip _priv noise\n            .finish()\n    }\n}",
            "impl fmt::Display for InvalidMethod {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"invalid HTTP method\")\n    }\n}"
        ],
        "method::Method": [
            "Clone",
            "Eq",
            "Hash",
            "PartialEq",
            "impl AsRef<str> for Method {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}",
            "impl Default for Method {\n    #[inline]\n    fn default() -> Method {\n        Method::GET\n    }\n}",
            "impl FromStr for Method {\n    type Err = InvalidMethod;\n\n    #[inline]\n    fn from_str(t: &str) -> Result<Self, Self::Err> {\n        TryFrom::try_from(t)\n    }\n}",
            "impl Method {\n    /// GET\n    pub const GET: Method = Method(Get);\n\n    /// POST\n    pub const POST: Method = Method(Post);\n\n    /// PUT\n    pub const PUT: Method = Method(Put);\n\n    /// DELETE\n    pub const DELETE: Method = Method(Delete);\n\n    /// HEAD\n    pub const HEAD: Method = Method(Head);\n\n    /// OPTIONS\n    pub const OPTIONS: Method = Method(Options);\n\n    /// CONNECT\n    pub const CONNECT: Method = Method(Connect);\n\n    /// PATCH\n    pub const PATCH: Method = Method(Patch);\n\n    /// TRACE\n    pub const TRACE: Method = Method(Trace);\n\n    /// Converts a slice of bytes to an HTTP method.\n    pub fn from_bytes(src: &[u8]) -> Result<Method, InvalidMethod> {\n        match src.len() {\n            0 => Err(InvalidMethod::new()),\n            3 => match src {\n                b\"GET\" => Ok(Method(Get)),\n                b\"PUT\" => Ok(Method(Put)),\n                _ => Method::extension_inline(src),\n            },\n            4 => match src {\n                b\"POST\" => Ok(Method(Post)),\n                b\"HEAD\" => Ok(Method(Head)),\n                _ => Method::extension_inline(src),\n            },\n            5 => match src {\n                b\"PATCH\" => Ok(Method(Patch)),\n                b\"TRACE\" => Ok(Method(Trace)),\n                _ => Method::extension_inline(src),\n            },\n            6 => match src {\n                b\"DELETE\" => Ok(Method(Delete)),\n                _ => Method::extension_inline(src),\n            },\n            7 => match src {\n                b\"OPTIONS\" => Ok(Method(Options)),\n                b\"CONNECT\" => Ok(Method(Connect)),\n                _ => Method::extension_inline(src),\n            },\n            _ => {\n                if src.len() <= InlineExtension::MAX {\n                    Method::extension_inline(src)\n                } else {\n                    let allocated = AllocatedExtension::new(src)?;\n\n                    Ok(Method(ExtensionAllocated(allocated)))\n                }\n            }\n        }\n    }\n\n    fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod> {\n        let inline = InlineExtension::new(src)?;\n\n        Ok(Method(ExtensionInline(inline)))\n    }\n\n    /// Whether a method is considered \"safe\", meaning the request is\n    /// essentially read-only.\n    ///\n    /// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.1)\n    /// for more words.\n    pub fn is_safe(&self) -> bool {\n        matches!(self.0, Get | Head | Options | Trace)\n    }\n\n    /// Whether a method is considered \"idempotent\", meaning the request has\n    /// the same result if executed multiple times.\n    ///\n    /// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.2) for\n    /// more words.\n    pub fn is_idempotent(&self) -> bool {\n        match self.0 {\n            Put | Delete => true,\n            _ => self.is_safe(),\n        }\n    }\n\n    /// Return a &str representation of the HTTP method\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        match self.0 {\n            Options => \"OPTIONS\",\n            Get => \"GET\",\n            Post => \"POST\",\n            Put => \"PUT\",\n            Delete => \"DELETE\",\n            Head => \"HEAD\",\n            Trace => \"TRACE\",\n            Connect => \"CONNECT\",\n            Patch => \"PATCH\",\n            ExtensionInline(ref inline) => inline.as_str(),\n            ExtensionAllocated(ref allocated) => allocated.as_str(),\n        }\n    }\n}",
            "impl PartialEq<str> for Method {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        self.as_ref() == other\n    }\n}",
            "impl fmt::Debug for Method {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_ref())\n    }\n}",
            "impl fmt::Display for Method {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.write_str(self.as_ref())\n    }\n}",
            "impl<'a> From<&'a Method> for Method {\n    #[inline]\n    fn from(t: &'a Method) -> Self {\n        t.clone()\n    }\n}",
            "impl<'a> PartialEq<&'a Method> for Method {\n    #[inline]\n    fn eq(&self, other: &&'a Method) -> bool {\n        self == *other\n    }\n}",
            "impl<'a> PartialEq<&'a str> for Method {\n    #[inline]\n    fn eq(&self, other: &&'a str) -> bool {\n        self.as_ref() == *other\n    }\n}",
            "impl<'a> TryFrom<&'a [u8]> for Method {\n    type Error = InvalidMethod;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        Method::from_bytes(t)\n    }\n}",
            "impl<'a> TryFrom<&'a str> for Method {\n    type Error = InvalidMethod;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        TryFrom::try_from(t.as_bytes())\n    }\n}"
        ],
        "method::extension::AllocatedExtension": [
            "Clone",
            "Eq",
            "Hash",
            "PartialEq",
            "impl AllocatedExtension {\n        pub fn new(src: &[u8]) -> Result<AllocatedExtension, InvalidMethod> {\n            let mut data: Vec<u8> = vec![0; src.len()];\n\n            write_checked(src, &mut data)?;\n\n            // Invariant: data is exactly src.len() long and write_checked\n            // ensures that the first src.len() bytes of data are valid UTF-8.\n            Ok(AllocatedExtension(data.into_boxed_slice()))\n        }\n\n        pub fn as_str(&self) -> &str {\n            // Safety: the invariant of AllocatedExtension ensures that self.0\n            // contains valid UTF-8.\n            unsafe { str::from_utf8_unchecked(&self.0) }\n        }\n    }"
        ],
        "method::extension::InlineExtension": [
            "Clone",
            "Eq",
            "Hash",
            "PartialEq",
            "impl InlineExtension {\n        // Method::from_bytes() assumes this is at least 7\n        pub const MAX: usize = 15;\n\n        pub fn new(src: &[u8]) -> Result<InlineExtension, InvalidMethod> {\n            let mut data: [u8; InlineExtension::MAX] = Default::default();\n\n            write_checked(src, &mut data)?;\n\n            // Invariant: write_checked ensures that the first src.len() bytes\n            // of data are valid UTF-8.\n            Ok(InlineExtension(data, src.len() as u8))\n        }\n\n        pub fn as_str(&self) -> &str {\n            let InlineExtension(ref data, len) = self;\n            // Safety: the invariant of InlineExtension ensures that the first\n            // len bytes of data contain valid UTF-8.\n            unsafe { str::from_utf8_unchecked(&data[..*len as usize]) }\n        }\n    }"
        ],
        "request::Builder": [
            "Debug",
            "impl Builder {\n    /// Creates a new default instance of `Builder` to construct a `Request`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = request::Builder::new()\n    ///     .method(\"POST\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn new() -> Builder {\n        Builder::default()\n    }\n\n    /// Set the HTTP method for this request.\n    ///\n    /// By default this is `GET`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .method(\"POST\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn method<T>(self, method: T) -> Builder\n    where\n        T: TryInto<Method>,\n        <T as TryInto<Method>>::Error: Into<crate::Error>,\n    {\n        self.and_then(move |mut head| {\n            let method = method.try_into().map_err(Into::into)?;\n            head.method = method;\n            Ok(head)\n        })\n    }\n\n    /// Get the HTTP Method for this request.\n    ///\n    /// By default this is `GET`. If builder has error, returns None.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let mut req = Request::builder();\n    /// assert_eq!(req.method_ref(),Some(&Method::GET));\n    ///\n    /// req = req.method(\"POST\");\n    /// assert_eq!(req.method_ref(),Some(&Method::POST));\n    /// ```\n    pub fn method_ref(&self) -> Option<&Method> {\n        self.inner.as_ref().ok().map(|h| &h.method)\n    }\n\n    /// Set the URI for this request.\n    ///\n    /// By default this is `/`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .uri(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn uri<T>(self, uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        self.and_then(move |mut head| {\n            head.uri = uri.try_into().map_err(Into::into)?;\n            Ok(head)\n        })\n    }\n\n    /// Get the URI for this request\n    ///\n    /// By default this is `/`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let mut req = Request::builder();\n    /// assert_eq!(req.uri_ref().unwrap(), \"/\" );\n    ///\n    /// req = req.uri(\"https://www.rust-lang.org/\");\n    /// assert_eq!(req.uri_ref().unwrap(), \"https://www.rust-lang.org/\" );\n    /// ```\n    pub fn uri_ref(&self) -> Option<&Uri> {\n        self.inner.as_ref().ok().map(|h| &h.uri)\n    }\n\n    /// Set the HTTP version for this request.\n    ///\n    /// By default this is HTTP/1.1\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .version(Version::HTTP_2)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn version(self, version: Version) -> Builder {\n        self.and_then(move |mut head| {\n            head.version = version;\n            Ok(head)\n        })\n    }\n\n    /// Get the HTTP version for this request\n    ///\n    /// By default this is HTTP/1.1.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let mut req = Request::builder();\n    /// assert_eq!(req.version_ref().unwrap(), &Version::HTTP_11 );\n    ///\n    /// req = req.version(Version::HTTP_2);\n    /// assert_eq!(req.version_ref().unwrap(), &Version::HTTP_2 );\n    /// ```\n    pub fn version_ref(&self) -> Option<&Version> {\n        self.inner.as_ref().ok().map(|h| &h.version)\n    }\n\n    /// Appends a header to this request builder.\n    ///\n    /// This function will append the provided key/value as a header to the\n    /// internal `HeaderMap` being constructed. Essentially this is equivalent\n    /// to calling `HeaderMap::append`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    ///\n    /// let req = Request::builder()\n    ///     .header(\"Accept\", \"text/html\")\n    ///     .header(\"X-Custom-Foo\", \"bar\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn header<K, V>(self, key: K, value: V) -> Builder\n    where\n        K: TryInto<HeaderName>,\n        <K as TryInto<HeaderName>>::Error: Into<crate::Error>,\n        V: TryInto<HeaderValue>,\n        <V as TryInto<HeaderValue>>::Error: Into<crate::Error>,\n    {\n        self.and_then(move |mut head| {\n            let name = key.try_into().map_err(Into::into)?;\n            let value = value.try_into().map_err(Into::into)?;\n            head.headers.try_append(name, value)?;\n            Ok(head)\n        })\n    }\n\n    /// Get header on this request builder.\n    /// when builder has error returns None\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Request;\n    /// let req = Request::builder()\n    ///     .header(\"Accept\", \"text/html\")\n    ///     .header(\"X-Custom-Foo\", \"bar\");\n    /// let headers = req.headers_ref().unwrap();\n    /// assert_eq!( headers[\"Accept\"], \"text/html\" );\n    /// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n    /// ```\n    pub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>> {\n        self.inner.as_ref().ok().map(|h| &h.headers)\n    }\n\n    /// Get headers on this request builder.\n    ///\n    /// When builder has error returns None.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::{header::HeaderValue, Request};\n    /// let mut req = Request::builder();\n    /// {\n    ///   let headers = req.headers_mut().unwrap();\n    ///   headers.insert(\"Accept\", HeaderValue::from_static(\"text/html\"));\n    ///   headers.insert(\"X-Custom-Foo\", HeaderValue::from_static(\"bar\"));\n    /// }\n    /// let headers = req.headers_ref().unwrap();\n    /// assert_eq!( headers[\"Accept\"], \"text/html\" );\n    /// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n    /// ```\n    pub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>> {\n        self.inner.as_mut().ok().map(|h| &mut h.headers)\n    }\n\n    /// Adds an extension to this builder\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let req = Request::builder()\n    ///     .extension(\"My Extension\")\n    ///     .body(())\n    ///     .unwrap();\n    ///\n    /// assert_eq!(req.extensions().get::<&'static str>(),\n    ///            Some(&\"My Extension\"));\n    /// ```\n    pub fn extension<T>(self, extension: T) -> Builder\n    where\n        T: Clone + Any + Send + Sync + 'static,\n    {\n        self.and_then(move |mut head| {\n            head.extensions.insert(extension);\n            Ok(head)\n        })\n    }\n\n    /// Get a reference to the extensions for this request builder.\n    ///\n    /// If the builder has an error, this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Request;\n    /// let req = Request::builder().extension(\"My Extension\").extension(5u32);\n    /// let extensions = req.extensions_ref().unwrap();\n    /// assert_eq!(extensions.get::<&'static str>(), Some(&\"My Extension\"));\n    /// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    /// ```\n    pub fn extensions_ref(&self) -> Option<&Extensions> {\n        self.inner.as_ref().ok().map(|h| &h.extensions)\n    }\n\n    /// Get a mutable reference to the extensions for this request builder.\n    ///\n    /// If the builder has an error, this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Request;\n    /// let mut req = Request::builder().extension(\"My Extension\");\n    /// let mut extensions = req.extensions_mut().unwrap();\n    /// assert_eq!(extensions.get::<&'static str>(), Some(&\"My Extension\"));\n    /// extensions.insert(5u32);\n    /// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    /// ```\n    pub fn extensions_mut(&mut self) -> Option<&mut Extensions> {\n        self.inner.as_mut().ok().map(|h| &mut h.extensions)\n    }\n\n    /// \"Consumes\" this builder, using the provided `body` to return a\n    /// constructed `Request`.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if any previously configured argument\n    /// failed to parse or get converted to the internal representation. For\n    /// example if an invalid `head` was specified via `header(\"Foo\",\n    /// \"Bar\\r\\n\")` the error will be returned when this function is called\n    /// rather than when `header` was called.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::builder()\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn body<T>(self, body: T) -> Result<Request<T>> {\n        self.inner.map(move |head| Request { head, body })\n    }\n\n    // private\n\n    fn and_then<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts>,\n    {\n        Builder {\n            inner: self.inner.and_then(func),\n        }\n    }\n}",
            "impl Default for Builder {\n    #[inline]\n    fn default() -> Builder {\n        Builder {\n            inner: Ok(Parts::new()),\n        }\n    }\n}"
        ],
        "request::Parts": [
            "Clone",
            "impl Parts {\n    /// Creates a new default instance of `Parts`\n    fn new() -> Parts {\n        Parts {\n            method: Method::default(),\n            uri: Uri::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }\n}",
            "impl fmt::Debug for Parts {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Parts\")\n            .field(\"method\", &self.method)\n            .field(\"uri\", &self.uri)\n            .field(\"version\", &self.version)\n            .field(\"headers\", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }\n}"
        ],
        "request::Request": [
            "Clone",
            "impl Request<()> {\n    /// Creates a new builder-style object to manufacture a `Request`\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::builder()\n    ///     .method(\"GET\")\n    ///     .uri(\"https://www.rust-lang.org/\")\n    ///     .header(\"X-Custom-Foo\", \"Bar\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn builder() -> Builder {\n        Builder::new()\n    }\n\n    /// Creates a new `Builder` initialized with a GET method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::get(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn get<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::GET).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a PUT method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::put(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn put<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::PUT).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a POST method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::post(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn post<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::POST).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a DELETE method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::delete(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn delete<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::DELETE).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with an OPTIONS method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::options(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// # assert_eq!(*request.method(), Method::OPTIONS);\n    /// ```\n    pub fn options<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::OPTIONS).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a HEAD method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::head(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn head<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::HEAD).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a CONNECT method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::connect(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn connect<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::CONNECT).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a PATCH method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::patch(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn patch<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::PATCH).uri(uri)\n    }\n\n    /// Creates a new `Builder` initialized with a TRACE method and the given URI.\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Request`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let request = Request::trace(\"https://www.rust-lang.org/\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn trace<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,\n    {\n        Builder::new().method(Method::TRACE).uri(uri)\n    }\n}",
            "impl<T: Default> Default for Request<T> {\n    fn default() -> Request<T> {\n        Request::new(T::default())\n    }\n}",
            "impl<T: fmt::Debug> fmt::Debug for Request<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Request\")\n            .field(\"method\", self.method())\n            .field(\"uri\", self.uri())\n            .field(\"version\", &self.version())\n            .field(\"headers\", self.headers())\n            // omits Extensions because not useful\n            .field(\"body\", self.body())\n            .finish()\n    }\n}",
            "impl<T> Request<T> {\n    /// Creates a new blank `Request` with the body\n    ///\n    /// The component parts of this request will be set to their default, e.g.\n    /// the GET method, no headers, etc.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::new(\"hello world\");\n    ///\n    /// assert_eq!(*request.method(), Method::GET);\n    /// assert_eq!(*request.body(), \"hello world\");\n    /// ```\n    #[inline]\n    pub fn new(body: T) -> Request<T> {\n        Request {\n            head: Parts::new(),\n            body,\n        }\n    }\n\n    /// Creates a new `Request` with the given components parts and body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::new(\"hello world\");\n    /// let (mut parts, body) = request.into_parts();\n    /// parts.method = Method::POST;\n    ///\n    /// let request = Request::from_parts(parts, body);\n    /// ```\n    #[inline]\n    pub fn from_parts(parts: Parts, body: T) -> Request<T> {\n        Request { head: parts, body }\n    }\n\n    /// Returns a reference to the associated HTTP method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert_eq!(*request.method(), Method::GET);\n    /// ```\n    #[inline]\n    pub fn method(&self) -> &Method {\n        &self.head.method\n    }\n\n    /// Returns a mutable reference to the associated HTTP method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<()> = Request::default();\n    /// *request.method_mut() = Method::PUT;\n    /// assert_eq!(*request.method(), Method::PUT);\n    /// ```\n    #[inline]\n    pub fn method_mut(&mut self) -> &mut Method {\n        &mut self.head.method\n    }\n\n    /// Returns a reference to the associated URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert_eq!(*request.uri(), *\"/\");\n    /// ```\n    #[inline]\n    pub fn uri(&self) -> &Uri {\n        &self.head.uri\n    }\n\n    /// Returns a mutable reference to the associated URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<()> = Request::default();\n    /// *request.uri_mut() = \"/hello\".parse().unwrap();\n    /// assert_eq!(*request.uri(), *\"/hello\");\n    /// ```\n    #[inline]\n    pub fn uri_mut(&mut self) -> &mut Uri {\n        &mut self.head.uri\n    }\n\n    /// Returns the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert_eq!(request.version(), Version::HTTP_11);\n    /// ```\n    #[inline]\n    pub fn version(&self) -> Version {\n        self.head.version\n    }\n\n    /// Returns a mutable reference to the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<()> = Request::default();\n    /// *request.version_mut() = Version::HTTP_2;\n    /// assert_eq!(request.version(), Version::HTTP_2);\n    /// ```\n    #[inline]\n    pub fn version_mut(&mut self) -> &mut Version {\n        &mut self.head.version\n    }\n\n    /// Returns a reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert!(request.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers(&self) -> &HeaderMap<HeaderValue> {\n        &self.head.headers\n    }\n\n    /// Returns a mutable reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut request: Request<()> = Request::default();\n    /// request.headers_mut().insert(HOST, HeaderValue::from_static(\"world\"));\n    /// assert!(!request.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue> {\n        &mut self.head.headers\n    }\n\n    /// Returns a reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<()> = Request::default();\n    /// assert!(request.extensions().get::<i32>().is_none());\n    /// ```\n    #[inline]\n    pub fn extensions(&self) -> &Extensions {\n        &self.head.extensions\n    }\n\n    /// Returns a mutable reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut request: Request<()> = Request::default();\n    /// request.extensions_mut().insert(\"hello\");\n    /// assert_eq!(request.extensions().get(), Some(&\"hello\"));\n    /// ```\n    #[inline]\n    pub fn extensions_mut(&mut self) -> &mut Extensions {\n        &mut self.head.extensions\n    }\n\n    /// Returns a reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request: Request<String> = Request::default();\n    /// assert!(request.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body(&self) -> &T {\n        &self.body\n    }\n\n    /// Returns a mutable reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut request: Request<String> = Request::default();\n    /// request.body_mut().push_str(\"hello world\");\n    /// assert!(!request.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body_mut(&mut self) -> &mut T {\n        &mut self.body\n    }\n\n    /// Consumes the request, returning just the body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::Request;\n    /// let request = Request::new(10);\n    /// let body = request.into_body();\n    /// assert_eq!(body, 10);\n    /// ```\n    #[inline]\n    pub fn into_body(self) -> T {\n        self.body\n    }\n\n    /// Consumes the request returning the head and body parts.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::new(());\n    /// let (parts, body) = request.into_parts();\n    /// assert_eq!(parts.method, Method::GET);\n    /// ```\n    #[inline]\n    pub fn into_parts(self) -> (Parts, T) {\n        (self.head, self.body)\n    }\n\n    /// Consumes the request returning a new request with body mapped to the\n    /// return type of the passed in function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let request = Request::builder().body(\"some string\").unwrap();\n    /// let mapped_request: Request<&[u8]> = request.map(|b| {\n    ///   assert_eq!(b, \"some string\");\n    ///   b.as_bytes()\n    /// });\n    /// assert_eq!(mapped_request.body(), &\"some string\".as_bytes());\n    /// ```\n    #[inline]\n    pub fn map<F, U>(self, f: F) -> Request<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        Request {\n            body: f(self.body),\n            head: self.head,\n        }\n    }\n}"
        ],
        "response::Builder": [
            "Debug",
            "impl Builder {\n    /// Creates a new default instance of `Builder` to construct either a\n    /// `Head` or a `Response`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = response::Builder::new()\n    ///     .status(200)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn new() -> Builder {\n        Builder::default()\n    }\n\n    /// Set the HTTP status for this response.\n    ///\n    /// By default this is `200`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .status(200)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn status<T>(self, status: T) -> Builder\n    where\n        T: TryInto<StatusCode>,\n        <T as TryInto<StatusCode>>::Error: Into<crate::Error>,\n    {\n        self.and_then(move |mut head| {\n            head.status = status.try_into().map_err(Into::into)?;\n            Ok(head)\n        })\n    }\n\n    /// Set the HTTP version for this response.\n    ///\n    /// By default this is HTTP/1.1\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .version(Version::HTTP_2)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn version(self, version: Version) -> Builder {\n        self.and_then(move |mut head| {\n            head.version = version;\n            Ok(head)\n        })\n    }\n\n    /// Appends a header to this response builder.\n    ///\n    /// This function will append the provided key/value as a header to the\n    /// internal `HeaderMap` being constructed. Essentially this is equivalent\n    /// to calling `HeaderMap::append`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    ///\n    /// let response = Response::builder()\n    ///     .header(\"Content-Type\", \"text/html\")\n    ///     .header(\"X-Custom-Foo\", \"bar\")\n    ///     .header(\"content-length\", 0)\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn header<K, V>(self, key: K, value: V) -> Builder\n    where\n        K: TryInto<HeaderName>,\n        <K as TryInto<HeaderName>>::Error: Into<crate::Error>,\n        V: TryInto<HeaderValue>,\n        <V as TryInto<HeaderValue>>::Error: Into<crate::Error>,\n    {\n        self.and_then(move |mut head| {\n            let name = key.try_into().map_err(Into::into)?;\n            let value = value.try_into().map_err(Into::into)?;\n            head.headers.try_append(name, value)?;\n            Ok(head)\n        })\n    }\n\n    /// Get header on this response builder.\n    ///\n    /// When builder has error returns None.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Response;\n    /// # use http::header::HeaderValue;\n    /// let res = Response::builder()\n    ///     .header(\"Accept\", \"text/html\")\n    ///     .header(\"X-Custom-Foo\", \"bar\");\n    /// let headers = res.headers_ref().unwrap();\n    /// assert_eq!( headers[\"Accept\"], \"text/html\" );\n    /// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n    /// ```\n    pub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>> {\n        self.inner.as_ref().ok().map(|h| &h.headers)\n    }\n\n    /// Get header on this response builder.\n    /// when builder has error returns None\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::HeaderValue;\n    /// # use http::response::Builder;\n    /// let mut res = Response::builder();\n    /// {\n    ///   let headers = res.headers_mut().unwrap();\n    ///   headers.insert(\"Accept\", HeaderValue::from_static(\"text/html\"));\n    ///   headers.insert(\"X-Custom-Foo\", HeaderValue::from_static(\"bar\"));\n    /// }\n    /// let headers = res.headers_ref().unwrap();\n    /// assert_eq!( headers[\"Accept\"], \"text/html\" );\n    /// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n    /// ```\n    pub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>> {\n        self.inner.as_mut().ok().map(|h| &mut h.headers)\n    }\n\n    /// Adds an extension to this builder\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .extension(\"My Extension\")\n    ///     .body(())\n    ///     .unwrap();\n    ///\n    /// assert_eq!(response.extensions().get::<&'static str>(),\n    ///            Some(&\"My Extension\"));\n    /// ```\n    pub fn extension<T>(self, extension: T) -> Builder\n    where\n        T: Clone + Any + Send + Sync + 'static,\n    {\n        self.and_then(move |mut head| {\n            head.extensions.insert(extension);\n            Ok(head)\n        })\n    }\n\n    /// Get a reference to the extensions for this response builder.\n    ///\n    /// If the builder has an error, this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Response;\n    /// let res = Response::builder().extension(\"My Extension\").extension(5u32);\n    /// let extensions = res.extensions_ref().unwrap();\n    /// assert_eq!(extensions.get::<&'static str>(), Some(&\"My Extension\"));\n    /// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    /// ```\n    pub fn extensions_ref(&self) -> Option<&Extensions> {\n        self.inner.as_ref().ok().map(|h| &h.extensions)\n    }\n\n    /// Get a mutable reference to the extensions for this response builder.\n    ///\n    /// If the builder has an error, this returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Response;\n    /// let mut res = Response::builder().extension(\"My Extension\");\n    /// let mut extensions = res.extensions_mut().unwrap();\n    /// assert_eq!(extensions.get::<&'static str>(), Some(&\"My Extension\"));\n    /// extensions.insert(5u32);\n    /// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n    /// ```\n    pub fn extensions_mut(&mut self) -> Option<&mut Extensions> {\n        self.inner.as_mut().ok().map(|h| &mut h.extensions)\n    }\n\n    /// \"Consumes\" this builder, using the provided `body` to return a\n    /// constructed `Response`.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if any previously configured argument\n    /// failed to parse or get converted to the internal representation. For\n    /// example if an invalid `head` was specified via `header(\"Foo\",\n    /// \"Bar\\r\\n\")` the error will be returned when this function is called\n    /// rather than when `header` was called.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let response = Response::builder()\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    pub fn body<T>(self, body: T) -> Result<Response<T>> {\n        self.inner.map(move |head| Response { head, body })\n    }\n\n    // private\n\n    fn and_then<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts>,\n    {\n        Builder {\n            inner: self.inner.and_then(func),\n        }\n    }\n}",
            "impl Default for Builder {\n    #[inline]\n    fn default() -> Builder {\n        Builder {\n            inner: Ok(Parts::new()),\n        }\n    }\n}"
        ],
        "response::Parts": [
            "Clone",
            "impl Parts {\n    /// Creates a new default instance of `Parts`\n    fn new() -> Parts {\n        Parts {\n            status: StatusCode::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }\n}",
            "impl fmt::Debug for Parts {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Parts\")\n            .field(\"status\", &self.status)\n            .field(\"version\", &self.version)\n            .field(\"headers\", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }\n}"
        ],
        "response::Response": [
            "Clone",
            "impl Response<()> {\n    /// Creates a new builder-style object to manufacture a `Response`\n    ///\n    /// This method returns an instance of `Builder` which can be used to\n    /// create a `Response`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::builder()\n    ///     .status(200)\n    ///     .header(\"X-Custom-Foo\", \"Bar\")\n    ///     .body(())\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn builder() -> Builder {\n        Builder::new()\n    }\n}",
            "impl<T: Default> Default for Response<T> {\n    #[inline]\n    fn default() -> Response<T> {\n        Response::new(T::default())\n    }\n}",
            "impl<T: fmt::Debug> fmt::Debug for Response<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Response\")\n            .field(\"status\", &self.status())\n            .field(\"version\", &self.version())\n            .field(\"headers\", self.headers())\n            // omits Extensions because not useful\n            .field(\"body\", self.body())\n            .finish()\n    }\n}",
            "impl<T> Response<T> {\n    /// Creates a new blank `Response` with the body\n    ///\n    /// The component parts of this response will be set to their default, e.g.\n    /// the ok status, no headers, etc.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::new(\"hello world\");\n    ///\n    /// assert_eq!(response.status(), StatusCode::OK);\n    /// assert_eq!(*response.body(), \"hello world\");\n    /// ```\n    #[inline]\n    pub fn new(body: T) -> Response<T> {\n        Response {\n            head: Parts::new(),\n            body,\n        }\n    }\n\n    /// Creates a new `Response` with the given head and body\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::new(\"hello world\");\n    /// let (mut parts, body) = response.into_parts();\n    ///\n    /// parts.status = StatusCode::BAD_REQUEST;\n    /// let response = Response::from_parts(parts, body);\n    ///\n    /// assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n    /// assert_eq!(*response.body(), \"hello world\");\n    /// ```\n    #[inline]\n    pub fn from_parts(parts: Parts, body: T) -> Response<T> {\n        Response { head: parts, body }\n    }\n\n    /// Returns the `StatusCode`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert_eq!(response.status(), StatusCode::OK);\n    /// ```\n    #[inline]\n    pub fn status(&self) -> StatusCode {\n        self.head.status\n    }\n\n    /// Returns a mutable reference to the associated `StatusCode`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut response: Response<()> = Response::default();\n    /// *response.status_mut() = StatusCode::CREATED;\n    /// assert_eq!(response.status(), StatusCode::CREATED);\n    /// ```\n    #[inline]\n    pub fn status_mut(&mut self) -> &mut StatusCode {\n        &mut self.head.status\n    }\n\n    /// Returns a reference to the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert_eq!(response.version(), Version::HTTP_11);\n    /// ```\n    #[inline]\n    pub fn version(&self) -> Version {\n        self.head.version\n    }\n\n    /// Returns a mutable reference to the associated version.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut response: Response<()> = Response::default();\n    /// *response.version_mut() = Version::HTTP_2;\n    /// assert_eq!(response.version(), Version::HTTP_2);\n    /// ```\n    #[inline]\n    pub fn version_mut(&mut self) -> &mut Version {\n        &mut self.head.version\n    }\n\n    /// Returns a reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert!(response.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers(&self) -> &HeaderMap<HeaderValue> {\n        &self.head.headers\n    }\n\n    /// Returns a mutable reference to the associated header field map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut response: Response<()> = Response::default();\n    /// response.headers_mut().insert(HOST, HeaderValue::from_static(\"world\"));\n    /// assert!(!response.headers().is_empty());\n    /// ```\n    #[inline]\n    pub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue> {\n        &mut self.head.headers\n    }\n\n    /// Returns a reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// assert!(response.extensions().get::<i32>().is_none());\n    /// ```\n    #[inline]\n    pub fn extensions(&self) -> &Extensions {\n        &self.head.extensions\n    }\n\n    /// Returns a mutable reference to the associated extensions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// # use http::header::*;\n    /// let mut response: Response<()> = Response::default();\n    /// response.extensions_mut().insert(\"hello\");\n    /// assert_eq!(response.extensions().get(), Some(&\"hello\"));\n    /// ```\n    #[inline]\n    pub fn extensions_mut(&mut self) -> &mut Extensions {\n        &mut self.head.extensions\n    }\n\n    /// Returns a reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<String> = Response::default();\n    /// assert!(response.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body(&self) -> &T {\n        &self.body\n    }\n\n    /// Returns a mutable reference to the associated HTTP body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let mut response: Response<String> = Response::default();\n    /// response.body_mut().push_str(\"hello world\");\n    /// assert!(!response.body().is_empty());\n    /// ```\n    #[inline]\n    pub fn body_mut(&mut self) -> &mut T {\n        &mut self.body\n    }\n\n    /// Consumes the response, returning just the body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::Response;\n    /// let response = Response::new(10);\n    /// let body = response.into_body();\n    /// assert_eq!(body, 10);\n    /// ```\n    #[inline]\n    pub fn into_body(self) -> T {\n        self.body\n    }\n\n    /// Consumes the response returning the head and body parts.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response: Response<()> = Response::default();\n    /// let (parts, body) = response.into_parts();\n    /// assert_eq!(parts.status, StatusCode::OK);\n    /// ```\n    #[inline]\n    pub fn into_parts(self) -> (Parts, T) {\n        (self.head, self.body)\n    }\n\n    /// Consumes the response returning a new response with body mapped to the\n    /// return type of the passed in function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    /// let response = Response::builder().body(\"some string\").unwrap();\n    /// let mapped_response: Response<&[u8]> = response.map(|b| {\n    ///   assert_eq!(b, \"some string\");\n    ///   b.as_bytes()\n    /// });\n    /// assert_eq!(mapped_response.body(), &\"some string\".as_bytes());\n    /// ```\n    #[inline]\n    pub fn map<F, U>(self, f: F) -> Response<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        Response {\n            body: f(self.body),\n            head: self.head,\n        }\n    }\n}"
        ],
        "status::InvalidStatusCode": [
            "impl Error for InvalidStatusCode {}",
            "impl InvalidStatusCode {\n    fn new() -> InvalidStatusCode {\n        InvalidStatusCode { _priv: () }\n    }\n}",
            "impl fmt::Debug for InvalidStatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(\"InvalidStatusCode\")\n            // skip _priv noise\n            .finish()\n    }\n}",
            "impl fmt::Display for InvalidStatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"invalid status code\")\n    }\n}"
        ],
        "status::StatusCode": [
            "Clone",
            "Copy",
            "Eq",
            "Hash",
            "Ord",
            "PartialEq",
            "PartialOrd",
            "impl Default for StatusCode {\n    #[inline]\n    fn default() -> StatusCode {\n        StatusCode::OK\n    }\n}",
            "impl FromStr for StatusCode {\n    type Err = InvalidStatusCode;\n\n    fn from_str(s: &str) -> Result<StatusCode, InvalidStatusCode> {\n        StatusCode::from_bytes(s.as_ref())\n    }\n}",
            "impl PartialEq<u16> for StatusCode {\n    #[inline]\n    fn eq(&self, other: &u16) -> bool {\n        self.as_u16() == *other\n    }\n}",
            "impl StatusCode {\n        $(\n            $(#[$docs])*\n            pub const $konst: StatusCode = StatusCode(unsafe { NonZeroU16::new_unchecked($num) });\n        )+\n\n        }",
            "impl StatusCode {\n    /// Converts a u16 to a status code.\n    ///\n    /// The function validates the correctness of the supplied u16. It must be\n    /// greater or equal to 100 and less than 1000.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use http::StatusCode;\n    ///\n    /// let ok = StatusCode::from_u16(200).unwrap();\n    /// assert_eq!(ok, StatusCode::OK);\n    ///\n    /// let err = StatusCode::from_u16(99);\n    /// assert!(err.is_err());\n    /// ```\n    #[inline]\n    pub fn from_u16(src: u16) -> Result<StatusCode, InvalidStatusCode> {\n        if !(100..1000).contains(&src) {\n            return Err(InvalidStatusCode::new());\n        }\n\n        NonZeroU16::new(src)\n            .map(StatusCode)\n            .ok_or_else(InvalidStatusCode::new)\n    }\n\n    /// Converts a `&[u8]` to a status code.\n    pub fn from_bytes(src: &[u8]) -> Result<StatusCode, InvalidStatusCode> {\n        if src.len() != 3 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let a = src[0].wrapping_sub(b'0') as u16;\n        let b = src[1].wrapping_sub(b'0') as u16;\n        let c = src[2].wrapping_sub(b'0') as u16;\n\n        if a == 0 || a > 9 || b > 9 || c > 9 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let status = (a * 100) + (b * 10) + c;\n        NonZeroU16::new(status)\n            .map(StatusCode)\n            .ok_or_else(InvalidStatusCode::new)\n    }\n\n    /// Returns the `u16` corresponding to this `StatusCode`.\n    ///\n    /// # Note\n    ///\n    /// This is the same as the `From<StatusCode>` implementation, but\n    /// included as an inherent method because that implementation doesn't\n    /// appear in rustdocs, as well as a way to force the type instead of\n    /// relying on inference.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let status = http::StatusCode::OK;\n    /// assert_eq!(status.as_u16(), 200);\n    /// ```\n    #[inline]\n    pub const fn as_u16(&self) -> u16 {\n        self.0.get()\n    }\n\n    /// Returns a &str representation of the `StatusCode`\n    ///\n    /// The return value only includes a numerical representation of the\n    /// status code. The canonical reason is not included.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let status = http::StatusCode::OK;\n    /// assert_eq!(status.as_str(), \"200\");\n    /// ```\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        let offset = (self.0.get() - 100) as usize;\n        let offset = offset * 3;\n\n        // Invariant: self has checked range [100, 999] and CODE_DIGITS is\n        // ASCII-only, of length 900 * 3 = 2700 bytes\n\n        #[cfg(debug_assertions)]\n        {\n            &CODE_DIGITS[offset..offset + 3]\n        }\n\n        #[cfg(not(debug_assertions))]\n        unsafe {\n            CODE_DIGITS.get_unchecked(offset..offset + 3)\n        }\n    }\n\n    /// Get the standardised `reason-phrase` for this status code.\n    ///\n    /// This is mostly here for servers writing responses, but could potentially have application\n    /// at other times.\n    ///\n    /// The reason phrase is defined as being exclusively for human readers. You should avoid\n    /// deriving any meaning from it at all costs.\n    ///\n    /// Bear in mind also that in HTTP/2.0 and HTTP/3.0 the reason phrase is abolished from\n    /// transmission, and so this canonical reason phrase really is the only reason phrase youll\n    /// find.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// let status = http::StatusCode::OK;\n    /// assert_eq!(status.canonical_reason(), Some(\"OK\"));\n    /// ```\n    pub fn canonical_reason(&self) -> Option<&'static str> {\n        canonical_reason(self.0.get())\n    }\n\n    /// Check if status is within 100-199.\n    #[inline]\n    pub fn is_informational(&self) -> bool {\n        (100..200).contains(&self.0.get())\n    }\n\n    /// Check if status is within 200-299.\n    #[inline]\n    pub fn is_success(&self) -> bool {\n        (200..300).contains(&self.0.get())\n    }\n\n    /// Check if status is within 300-399.\n    #[inline]\n    pub fn is_redirection(&self) -> bool {\n        (300..400).contains(&self.0.get())\n    }\n\n    /// Check if status is within 400-499.\n    #[inline]\n    pub fn is_client_error(&self) -> bool {\n        (400..500).contains(&self.0.get())\n    }\n\n    /// Check if status is within 500-599.\n    #[inline]\n    pub fn is_server_error(&self) -> bool {\n        (500..600).contains(&self.0.get())\n    }\n}",
            "impl TryFrom<u16> for StatusCode {\n    type Error = InvalidStatusCode;\n\n    #[inline]\n    fn try_from(t: u16) -> Result<Self, Self::Error> {\n        StatusCode::from_u16(t)\n    }\n}",
            "impl fmt::Debug for StatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&self.0, f)\n    }\n}",
            "impl fmt::Display for StatusCode {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"{} {}\",\n            u16::from(*self),\n            self.canonical_reason().unwrap_or(\"<unknown status code>\")\n        )\n    }\n}",
            "impl<'a> From<&'a StatusCode> for StatusCode {\n    #[inline]\n    fn from(t: &'a StatusCode) -> Self {\n        t.to_owned()\n    }\n}",
            "impl<'a> TryFrom<&'a [u8]> for StatusCode {\n    type Error = InvalidStatusCode;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        StatusCode::from_bytes(t)\n    }\n}",
            "impl<'a> TryFrom<&'a str> for StatusCode {\n    type Error = InvalidStatusCode;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}"
        ],
        "std::boxed::Box": [
            "impl Clone for Box<dyn AnyClone + Send + Sync> {\n    fn clone(&self) -> Self {\n        (**self).clone_box()\n    }\n}"
        ],
        "std::string::String": [
            "impl AsHeaderName for String {}",
            "impl PartialEq<Authority> for String {\n    fn eq(&self, other: &Authority) -> bool {\n        self.as_str().eq_ignore_ascii_case(other.as_str())\n    }\n}",
            "impl PartialEq<HeaderValue> for String {\n    #[inline]\n    fn eq(&self, other: &HeaderValue) -> bool {\n        *other == *self\n    }\n}",
            "impl PartialEq<PathAndQuery> for String {\n    #[inline]\n    fn eq(&self, other: &PathAndQuery) -> bool {\n        self.as_str() == other.as_str()\n    }\n}",
            "impl PartialOrd<Authority> for String {\n    fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering> {\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}",
            "impl PartialOrd<HeaderValue> for String {\n    #[inline]\n    fn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering> {\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }\n}",
            "impl PartialOrd<PathAndQuery> for String {\n    #[inline]\n    fn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other.as_str())\n    }\n}",
            "impl Sealed for String {\n        #[inline]\n        fn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError> {\n            self.as_str().try_entry(map)\n        }\n\n        #[inline]\n        fn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)> {\n            Sealed::find(&self.as_str(), map)\n        }\n\n        fn as_str(&self) -> &str {\n            self\n        }\n    }"
        ],
        "uri::ErrorKind": [
            "Debug",
            "Eq",
            "PartialEq"
        ],
        "uri::InvalidUri": [
            "Debug",
            "impl Error for InvalidUri {}",
            "impl From<ErrorKind> for InvalidUri {\n    fn from(src: ErrorKind) -> InvalidUri {\n        InvalidUri(src)\n    }\n}",
            "impl InvalidUri {\n    fn s(&self) -> &str {\n        match self.0 {\n            ErrorKind::InvalidUriChar => \"invalid uri character\",\n            ErrorKind::InvalidScheme => \"invalid scheme\",\n            ErrorKind::InvalidAuthority => \"invalid authority\",\n            ErrorKind::InvalidPort => \"invalid port\",\n            ErrorKind::InvalidFormat => \"invalid format\",\n            ErrorKind::SchemeMissing => \"scheme missing\",\n            ErrorKind::AuthorityMissing => \"authority missing\",\n            ErrorKind::PathAndQueryMissing => \"path missing\",\n            ErrorKind::TooLong => \"uri too long\",\n            ErrorKind::Empty => \"empty string\",\n            ErrorKind::SchemeTooLong => \"scheme too long\",\n        }\n    }\n}",
            "impl fmt::Display for InvalidUri {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.s().fmt(f)\n    }\n}"
        ],
        "uri::InvalidUriParts": [
            "Debug",
            "impl Error for InvalidUriParts {}",
            "impl From<ErrorKind> for InvalidUriParts {\n    fn from(src: ErrorKind) -> InvalidUriParts {\n        InvalidUriParts(src.into())\n    }\n}",
            "impl fmt::Display for InvalidUriParts {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}"
        ],
        "uri::Parts": [
            "Debug",
            "Default",
            "impl From<Uri> for Parts {\n    fn from(src: Uri) -> Self {\n        let path_and_query = if src.has_path() {\n            Some(src.path_and_query)\n        } else {\n            None\n        };\n\n        let scheme = match src.scheme.inner {\n            Scheme2::None => None,\n            _ => Some(src.scheme),\n        };\n\n        let authority = if src.authority.data.is_empty() {\n            None\n        } else {\n            Some(src.authority)\n        };\n\n        Parts {\n            scheme,\n            authority,\n            path_and_query,\n            _priv: (),\n        }\n    }\n}"
        ],
        "uri::Uri": [
            "Clone",
            "impl Default for Uri {\n    #[inline]\n    fn default() -> Uri {\n        Uri {\n            scheme: Scheme::empty(),\n            authority: Authority::empty(),\n            path_and_query: PathAndQuery::slash(),\n        }\n    }\n}",
            "impl Eq for Uri {}",
            "impl From<Authority> for Uri {\n    fn from(authority: Authority) -> Self {\n        Self {\n            scheme: Scheme::empty(),\n            authority,\n            path_and_query: PathAndQuery::empty(),\n        }\n    }\n}",
            "impl From<PathAndQuery> for Uri {\n    fn from(path_and_query: PathAndQuery) -> Self {\n        Self {\n            scheme: Scheme::empty(),\n            authority: Authority::empty(),\n            path_and_query,\n        }\n    }\n}",
            "impl FromStr for Uri {\n    type Err = InvalidUri;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<Uri, InvalidUri> {\n        Uri::try_from(s.as_bytes())\n    }\n}",
            "impl Hash for Uri {\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        if !self.scheme.inner.is_none() {\n            self.scheme.hash(state);\n            state.write_u8(0xff);\n        }\n\n        if let Some(auth) = self.authority() {\n            auth.hash(state);\n        }\n\n        Hash::hash_slice(self.path().as_bytes(), state);\n\n        if let Some(query) = self.query() {\n            b'?'.hash(state);\n            Hash::hash_slice(query.as_bytes(), state);\n        }\n    }\n}",
            "impl PartialEq for Uri {\n    fn eq(&self, other: &Uri) -> bool {\n        if self.scheme() != other.scheme() {\n            return false;\n        }\n\n        if self.authority() != other.authority() {\n            return false;\n        }\n\n        if self.path() != other.path() {\n            return false;\n        }\n\n        if self.query() != other.query() {\n            return false;\n        }\n\n        true\n    }\n}",
            "impl PartialEq<str> for Uri {\n    fn eq(&self, other: &str) -> bool {\n        let mut other = other.as_bytes();\n        let mut absolute = false;\n\n        if let Some(scheme) = self.scheme() {\n            let scheme = scheme.as_str().as_bytes();\n            absolute = true;\n\n            if other.len() < scheme.len() + 3 {\n                return false;\n            }\n\n            if !scheme.eq_ignore_ascii_case(&other[..scheme.len()]) {\n                return false;\n            }\n\n            other = &other[scheme.len()..];\n\n            if &other[..3] != b\"://\" {\n                return false;\n            }\n\n            other = &other[3..];\n        }\n\n        if let Some(auth) = self.authority() {\n            let len = auth.data.len();\n            absolute = true;\n\n            if other.len() < len {\n                return false;\n            }\n\n            if !auth.data.as_bytes().eq_ignore_ascii_case(&other[..len]) {\n                return false;\n            }\n\n            other = &other[len..];\n        }\n\n        let path = self.path();\n\n        if other.len() < path.len() || path.as_bytes() != &other[..path.len()] {\n            if absolute && path == \"/\" {\n                // PathAndQuery can be omitted, fall through\n            } else {\n                return false;\n            }\n        } else {\n            other = &other[path.len()..];\n        }\n\n        if let Some(query) = self.query() {\n            if other.is_empty() {\n                return query.is_empty();\n            }\n\n            if other[0] != b'?' {\n                return false;\n            }\n\n            other = &other[1..];\n\n            if other.len() < query.len() {\n                return false;\n            }\n\n            if query.as_bytes() != &other[..query.len()] {\n                return false;\n            }\n\n            other = &other[query.len()..];\n        }\n\n        other.is_empty() || other[0] == b'#'\n    }\n}",
            "impl TryFrom<Parts> for Uri {\n    type Error = InvalidUriParts;\n\n    #[inline]\n    fn try_from(src: Parts) -> Result<Self, Self::Error> {\n        Uri::from_parts(src)\n    }\n}",
            "impl TryFrom<String> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: String) -> Result<Self, Self::Error> {\n        Uri::from_shared(Bytes::from(t))\n    }\n}",
            "impl TryFrom<Vec<u8>> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {\n        Uri::from_shared(Bytes::from(vec))\n    }\n}",
            "impl Uri {\n    /// Creates a new builder-style object to manufacture a `Uri`.\n    ///\n    /// This method returns an instance of `Builder` which can be usd to\n    /// create a `Uri`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use http::Uri;\n    ///\n    /// let uri = Uri::builder()\n    ///     .scheme(\"https\")\n    ///     .authority(\"hyper.rs\")\n    ///     .path_and_query(\"/\")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn builder() -> Builder {\n        Builder::new()\n    }\n\n    /// Attempt to convert a `Parts` into a `Uri`.\n    ///\n    /// # Examples\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let mut parts = Parts::default();\n    /// parts.path_and_query = Some(\"/foo\".parse().unwrap());\n    ///\n    /// let uri = Uri::from_parts(parts).unwrap();\n    ///\n    /// assert_eq!(uri.path(), \"/foo\");\n    ///\n    /// assert!(uri.scheme().is_none());\n    /// assert!(uri.authority().is_none());\n    /// ```\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let mut parts = Parts::default();\n    /// parts.scheme = Some(\"http\".parse().unwrap());\n    /// parts.authority = Some(\"foo.com\".parse().unwrap());\n    /// parts.path_and_query = Some(\"/foo\".parse().unwrap());\n    ///\n    /// let uri = Uri::from_parts(parts).unwrap();\n    ///\n    /// assert_eq!(uri.scheme().unwrap().as_str(), \"http\");\n    /// assert_eq!(uri.authority().unwrap(), \"foo.com\");\n    /// assert_eq!(uri.path(), \"/foo\");\n    /// ```\n    pub fn from_parts(src: Parts) -> Result<Uri, InvalidUriParts> {\n        if src.scheme.is_some() {\n            if src.authority.is_none() {\n                return Err(ErrorKind::AuthorityMissing.into());\n            }\n\n            if src.path_and_query.is_none() {\n                return Err(ErrorKind::PathAndQueryMissing.into());\n            }\n        } else if src.authority.is_some() && src.path_and_query.is_some() {\n            return Err(ErrorKind::SchemeMissing.into());\n        }\n\n        let scheme = match src.scheme {\n            Some(scheme) => scheme,\n            None => Scheme {\n                inner: Scheme2::None,\n            },\n        };\n\n        let authority = match src.authority {\n            Some(authority) => authority,\n            None => Authority::empty(),\n        };\n\n        let path_and_query = match src.path_and_query {\n            Some(path_and_query) => path_and_query,\n            None => PathAndQuery::empty(),\n        };\n\n        Ok(Uri {\n            scheme,\n            authority,\n            path_and_query,\n        })\n    }\n\n    /// Attempt to convert a `Bytes` buffer to a `Uri`.\n    ///\n    /// This will try to prevent a copy if the type passed is the type used\n    /// internally, and will copy the data if it is not.\n    pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + 'static,\n    {\n        if_downcast_into!(T, Bytes, src, {\n            return Uri::from_shared(src);\n        });\n\n        Uri::try_from(src.as_ref())\n    }\n\n    // Not public while `bytes` is unstable.\n    fn from_shared(s: Bytes) -> Result<Uri, InvalidUri> {\n        use self::ErrorKind::*;\n\n        if s.len() > MAX_LEN {\n            return Err(TooLong.into());\n        }\n\n        match s.len() {\n            0 => {\n                return Err(Empty.into());\n            }\n            1 => match s[0] {\n                b'/' => {\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority: Authority::empty(),\n                        path_and_query: PathAndQuery::slash(),\n                    });\n                }\n                b'*' => {\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority: Authority::empty(),\n                        path_and_query: PathAndQuery::star(),\n                    });\n                }\n                _ => {\n                    let authority = Authority::from_shared(s)?;\n\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority,\n                        path_and_query: PathAndQuery::empty(),\n                    });\n                }\n            },\n            _ => {}\n        }\n\n        if s[0] == b'/' {\n            return Ok(Uri {\n                scheme: Scheme::empty(),\n                authority: Authority::empty(),\n                path_and_query: PathAndQuery::from_shared(s)?,\n            });\n        }\n\n        parse_full(s)\n    }\n\n    /// Convert a `Uri` from a static string.\n    ///\n    /// This function will not perform any copying, however the string is\n    /// checked to ensure that it is valid.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument is an invalid URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::Uri;\n    /// let uri = Uri::from_static(\"http://example.com/foo\");\n    ///\n    /// assert_eq!(uri.host().unwrap(), \"example.com\");\n    /// assert_eq!(uri.path(), \"/foo\");\n    /// ```\n    pub fn from_static(src: &'static str) -> Self {\n        let s = Bytes::from_static(src.as_bytes());\n        match Uri::from_shared(s) {\n            Ok(uri) => uri,\n            Err(e) => panic!(\"static str is not valid URI: {}\", e),\n        }\n    }\n\n    /// Convert a `Uri` into `Parts`.\n    ///\n    /// # Note\n    ///\n    /// This is just an inherent method providing the same functionality as\n    /// `let parts: Parts = uri.into()`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let uri: Uri = \"/foo\".parse().unwrap();\n    ///\n    /// let parts = uri.into_parts();\n    ///\n    /// assert_eq!(parts.path_and_query.unwrap(), \"/foo\");\n    ///\n    /// assert!(parts.scheme.is_none());\n    /// assert!(parts.authority.is_none());\n    /// ```\n    #[inline]\n    pub fn into_parts(self) -> Parts {\n        self.into()\n    }\n\n    /// Returns the path & query components of the Uri\n    #[inline]\n    pub fn path_and_query(&self) -> Option<&PathAndQuery> {\n        if !self.scheme.inner.is_none() || self.authority.data.is_empty() {\n            Some(&self.path_and_query)\n        } else {\n            None\n        }\n    }\n\n    /// Get the path of this `Uri`.\n    ///\n    /// Both relative and absolute URIs contain a path component, though it\n    /// might be the empty string. The path component is **case sensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                        |--------|\n    ///                                             |\n    ///                                           path\n    /// ```\n    ///\n    /// If the URI is `*` then the path component is equal to `*`.\n    ///\n    /// # Examples\n    ///\n    /// A relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    ///\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.path(), \"/hello/world\");\n    /// ```\n    ///\n    /// An absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.path(), \"/hello/world\");\n    /// ```\n    #[inline]\n    pub fn path(&self) -> &str {\n        if self.has_path() {\n            self.path_and_query.path()\n        } else {\n            \"\"\n        }\n    }\n\n    /// Get the scheme of this `Uri`.\n    ///\n    /// The URI scheme refers to a specification for assigning identifiers\n    /// within that scheme. Only absolute URIs contain a scheme component, but\n    /// not all absolute URIs will contain a scheme component.  Although scheme\n    /// names are case-insensitive, the canonical form is lowercase.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    /// |-|\n    ///  |\n    /// scheme\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// use http::uri::{Scheme, Uri};\n    ///\n    /// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.scheme(), Some(&Scheme::HTTP));\n    /// ```\n    ///\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.scheme().is_none());\n    /// ```\n    #[inline]\n    pub fn scheme(&self) -> Option<&Scheme> {\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(&self.scheme)\n        }\n    }\n\n    /// Get the scheme of this `Uri` as a `&str`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.scheme_str(), Some(\"http\"));\n    /// ```\n    #[inline]\n    pub fn scheme_str(&self) -> Option<&str> {\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(self.scheme.as_str())\n        }\n    }\n\n    /// Get the authority of this `Uri`.\n    ///\n    /// The authority is a hierarchical element for naming authority such that\n    /// the remainder of the URI is delegated to that authority. For HTTP, the\n    /// authority consists of the host and port. The host portion of the\n    /// authority is **case-insensitive**.\n    ///\n    /// The authority also includes a `username:password` component, however\n    /// the use of this is deprecated and should be avoided.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///       |-------------------------------|\n    ///                     |\n    ///                 authority\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.authority().map(|a| a.as_str()), Some(\"example.org:80\"));\n    /// ```\n    ///\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.authority().is_none());\n    /// ```\n    #[inline]\n    pub fn authority(&self) -> Option<&Authority> {\n        if self.authority.data.is_empty() {\n            None\n        } else {\n            Some(&self.authority)\n        }\n    }\n\n    /// Get the host of this `Uri`.\n    ///\n    /// The host subcomponent of authority is identified by an IP literal\n    /// encapsulated within square brackets, an IPv4 address in dotted- decimal\n    /// form, or a registered name.  The host subcomponent is **case-insensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                         |---------|\n    ///                              |\n    ///                             host\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.host(), Some(\"example.org\"));\n    /// ```\n    ///\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.host().is_none());\n    /// ```\n    #[inline]\n    pub fn host(&self) -> Option<&str> {\n        self.authority().map(|a| a.host())\n    }\n\n    /// Get the port part of this `Uri`.\n    ///\n    /// The port subcomponent of authority is designated by an optional port\n    /// number following the host and delimited from it by a single colon (\":\")\n    /// character. It can be turned into a decimal port number with the `as_u16`\n    /// method or as a `str` with the `as_str` method.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                     |-|\n    ///                                      |\n    ///                                     port\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI with port\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n    ///\n    /// let port = uri.port().unwrap();\n    /// assert_eq!(port.as_u16(), 80);\n    /// ```\n    ///\n    /// Absolute URI without port\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.port().is_none());\n    /// ```\n    ///\n    /// Relative URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.port().is_none());\n    /// ```\n    pub fn port(&self) -> Option<Port<&str>> {\n        self.authority().and_then(|a| a.port())\n    }\n\n    /// Get the port of this `Uri` as a `u16`.\n    ///\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::{Uri, uri::Port};\n    /// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.port_u16(), Some(80));\n    /// ```\n    pub fn port_u16(&self) -> Option<u16> {\n        self.port().map(|p| p.as_u16())\n    }\n\n    /// Get the query string of this `Uri`, starting after the `?`.\n    ///\n    /// The query component contains non-hierarchical data that, along with data\n    /// in the path component, serves to identify a resource within the scope of\n    /// the URI's scheme and naming authority (if any). The query component is\n    /// indicated by the first question mark (\"?\") character and terminated by a\n    /// number sign (\"#\") character or by the end of the URI.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                                   |-------------------|\n    ///                                                             |\n    ///                                                           query\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Absolute URI\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"http://example.org/hello/world?key=value\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.query(), Some(\"key=value\"));\n    /// ```\n    ///\n    /// Relative URI with a query string component\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n    ///\n    /// assert_eq!(uri.query(), Some(\"key=value&foo=bar\"));\n    /// ```\n    ///\n    /// Relative URI without a query string component\n    ///\n    /// ```\n    /// # use http::Uri;\n    /// let uri: Uri = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(uri.query().is_none());\n    /// ```\n    #[inline]\n    pub fn query(&self) -> Option<&str> {\n        self.path_and_query.query()\n    }\n\n    fn has_path(&self) -> bool {\n        !self.path_and_query.data.is_empty() || !self.scheme.inner.is_none()\n    }\n}",
            "impl fmt::Debug for Uri {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}",
            "impl fmt::Display for Uri {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(scheme) = self.scheme() {\n            write!(f, \"{}://\", scheme)?;\n        }\n\n        if let Some(authority) = self.authority() {\n            write!(f, \"{}\", authority)?;\n        }\n\n        write!(f, \"{}\", self.path())?;\n\n        if let Some(query) = self.query() {\n            write!(f, \"?{}\", query)?;\n        }\n\n        Ok(())\n    }\n}",
            "impl<'a> PartialEq<&'a str> for Uri {\n    fn eq(&self, other: &&'a str) -> bool {\n        self == *other\n    }\n}",
            "impl<'a> TryFrom<&'a String> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: &'a String) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}",
            "impl<'a> TryFrom<&'a Uri> for Uri {\n    type Error = crate::Error;\n\n    #[inline]\n    fn try_from(src: &'a Uri) -> Result<Self, Self::Error> {\n        Ok(src.clone())\n    }\n}",
            "impl<'a> TryFrom<&'a [u8]> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: &'a [u8]) -> Result<Self, Self::Error> {\n        Uri::from_shared(Bytes::copy_from_slice(t))\n    }\n}",
            "impl<'a> TryFrom<&'a str> for Uri {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: &'a str) -> Result<Self, Self::Error> {\n        t.parse()\n    }\n}"
        ],
        "uri::authority::Authority": [
            "Clone",
            "impl AsRef<str> for Authority {\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}",
            "impl Authority {\n    pub(super) fn empty() -> Self {\n        Authority {\n            data: ByteStr::new(),\n        }\n    }\n\n    // Not public while `bytes` is unstable.\n    pub(super) fn from_shared(s: Bytes) -> Result<Self, InvalidUri> {\n        // Precondition on create_authority: trivially satisfied by the\n        // identity closure\n        create_authority(s, |s| s)\n    }\n\n    /// Attempt to convert an `Authority` from a static string.\n    ///\n    /// This function will not perform any copying, and the string will be\n    /// checked if it is empty or contains an invalid character.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument contains invalid characters or\n    /// is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority = Authority::from_static(\"example.com\");\n    /// assert_eq!(authority.host(), \"example.com\");\n    /// ```\n    pub fn from_static(src: &'static str) -> Self {\n        Authority::from_shared(Bytes::from_static(src.as_bytes()))\n            .expect(\"static str is not valid authority\")\n    }\n\n    /// Attempt to convert a `Bytes` buffer to a `Authority`.\n    ///\n    /// This will try to prevent a copy if the type passed is the type used\n    /// internally, and will copy the data if it is not.\n    pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + 'static,\n    {\n        if_downcast_into!(T, Bytes, src, {\n            return Authority::from_shared(src);\n        });\n\n        Authority::try_from(src.as_ref())\n    }\n\n    // Note: this may return an *empty* Authority. You might want `parse_non_empty`.\n    // Postcondition: for all Ok() returns, s[..ret.unwrap()] is valid UTF-8 where\n    // ret is the return value.\n    pub(super) fn parse(s: &[u8]) -> Result<usize, InvalidUri> {\n        let mut colon_cnt = 0u32;\n        let mut start_bracket = false;\n        let mut end_bracket = false;\n        let mut has_percent = false;\n        let mut end = s.len();\n        let mut at_sign_pos = None;\n        const MAX_COLONS: u32 = 8; // e.g., [FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:80\n\n        // Among other things, this loop checks that every byte in s up to the\n        // first '/', '?', or '#' is a valid URI character (or in some contexts,\n        // a '%'). This means that each such byte is a valid single-byte UTF-8\n        // code point.\n        for (i, &b) in s.iter().enumerate() {\n            match URI_CHARS[b as usize] {\n                b'/' | b'?' | b'#' => {\n                    end = i;\n                    break;\n                }\n                b':' => {\n                    if colon_cnt >= MAX_COLONS {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    colon_cnt += 1;\n                }\n                b'[' => {\n                    if has_percent || start_bracket {\n                        // Something other than the userinfo has a `%`, so reject it.\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    start_bracket = true;\n                }\n                b']' => {\n                    if (!start_bracket) || end_bracket {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    end_bracket = true;\n\n                    // Those were part of an IPv6 hostname, so forget them...\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                b'@' => {\n                    at_sign_pos = Some(i);\n\n                    // Those weren't a port colon, but part of the\n                    // userinfo, so it needs to be forgotten.\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                0 if b == b'%' => {\n                    // Per https://tools.ietf.org/html/rfc3986#section-3.2.1 and\n                    // https://url.spec.whatwg.org/#authority-state\n                    // the userinfo can have a percent-encoded username and password,\n                    // so record that a `%` was found. If this turns out to be\n                    // part of the userinfo, this flag will be cleared.\n                    // Also per https://tools.ietf.org/html/rfc6874, percent-encoding can\n                    // be used to indicate a zone identifier.\n                    // If the flag hasn't been cleared at the end, that means this\n                    // was part of the hostname (and not part of an IPv6 address), and\n                    // will fail with an error.\n                    has_percent = true;\n                }\n                0 => {\n                    return Err(ErrorKind::InvalidUriChar.into());\n                }\n                _ => {}\n            }\n        }\n\n        if start_bracket ^ end_bracket {\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if colon_cnt > 1 {\n            // Things like 'localhost:8080:3030' are rejected.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if end > 0 && at_sign_pos == Some(end - 1) {\n            // If there's nothing after an `@`, this is bonkers.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if has_percent {\n            // Something after the userinfo has a `%`, so reject it.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        Ok(end)\n    }\n\n    // Parse bytes as an Authority, not allowing an empty string.\n    //\n    // This should be used by functions that allow a user to parse\n    // an `Authority` by itself.\n    //\n    // Postcondition: for all Ok() returns, s[..ret.unwrap()] is valid UTF-8 where\n    // ret is the return value.\n    fn parse_non_empty(s: &[u8]) -> Result<usize, InvalidUri> {\n        if s.is_empty() {\n            return Err(ErrorKind::Empty.into());\n        }\n        Authority::parse(s)\n    }\n\n    /// Get the host of this `Authority`.\n    ///\n    /// The host subcomponent of authority is identified by an IP literal\n    /// encapsulated within square brackets, an IPv4 address in dotted- decimal\n    /// form, or a registered name.  The host subcomponent is **case-insensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                         |---------|\n    ///                              |\n    ///                             host\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let authority: Authority = \"example.org:80\".parse().unwrap();\n    ///\n    /// assert_eq!(authority.host(), \"example.org\");\n    /// ```\n    #[inline]\n    pub fn host(&self) -> &str {\n        host(self.as_str())\n    }\n\n    /// Get the port part of this `Authority`.\n    ///\n    /// The port subcomponent of authority is designated by an optional port\n    /// number following the host and delimited from it by a single colon (\":\")\n    /// character. It can be turned into a decimal port number with the `as_u16`\n    /// method or as a `str` with the `as_str` method.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                     |-|\n    ///                                      |\n    ///                                     port\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// Authority with port\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = \"example.org:80\".parse().unwrap();\n    ///\n    /// let port = authority.port().unwrap();\n    /// assert_eq!(port.as_u16(), 80);\n    /// assert_eq!(port.as_str(), \"80\");\n    /// ```\n    ///\n    /// Authority without port\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = \"example.org\".parse().unwrap();\n    ///\n    /// assert!(authority.port().is_none());\n    /// ```\n    pub fn port(&self) -> Option<Port<&str>> {\n        let bytes = self.as_str();\n        bytes\n            .rfind(':')\n            .and_then(|i| Port::from_str(&bytes[i + 1..]).ok())\n    }\n\n    /// Get the port of this `Authority` as a `u16`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = \"example.org:80\".parse().unwrap();\n    ///\n    /// assert_eq!(authority.port_u16(), Some(80));\n    /// ```\n    pub fn port_u16(&self) -> Option<u16> {\n        self.port().map(|p| p.as_u16())\n    }\n\n    /// Return a str representation of the authority\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        &self.data[..]\n    }\n}",
            "impl Eq for Authority {}",
            "impl FromStr for Authority {\n    type Err = InvalidUri;\n\n    fn from_str(s: &str) -> Result<Self, InvalidUri> {\n        TryFrom::try_from(s)\n    }\n}",
            "impl Hash for Authority {\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.data.len().hash(state);\n        for &b in self.data.as_bytes() {\n            state.write_u8(b.to_ascii_lowercase());\n        }\n    }\n}",
            "impl PartialEq for Authority {\n    fn eq(&self, other: &Authority) -> bool {\n        self.data.eq_ignore_ascii_case(&other.data)\n    }\n}",
            "impl PartialEq<String> for Authority {\n    fn eq(&self, other: &String) -> bool {\n        self.data.eq_ignore_ascii_case(other.as_str())\n    }\n}",
            "impl PartialEq<str> for Authority {\n    fn eq(&self, other: &str) -> bool {\n        self.data.eq_ignore_ascii_case(other)\n    }\n}",
            "impl PartialOrd for Authority {\n    fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}",
            "impl PartialOrd<String> for Authority {\n    fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}",
            "impl PartialOrd<str> for Authority {\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}",
            "impl TryFrom<String> for Authority {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(t: String) -> Result<Self, Self::Error> {\n        Authority::from_shared(t.into())\n    }\n}",
            "impl TryFrom<Vec<u8>> for Authority {\n    type Error = InvalidUri;\n\n    #[inline]\n    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {\n        Authority::from_shared(vec.into())\n    }\n}",
            "impl fmt::Debug for Authority {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}",
            "impl fmt::Display for Authority {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}",
            "impl<'a> PartialEq<&'a str> for Authority {\n    fn eq(&self, other: &&'a str) -> bool {\n        self.data.eq_ignore_ascii_case(other)\n    }\n}",
            "impl<'a> PartialOrd<&'a str> for Authority {\n    fn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering> {\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }\n}",
            "impl<'a> TryFrom<&'a [u8]> for Authority {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        // parse first, and only turn into Bytes if valid\n\n        // Preconditon on create_authority: copy_from_slice() copies all of\n        // bytes from the [u8] parameter into a new Bytes\n        create_authority(s, Bytes::copy_from_slice)\n    }\n}",
            "impl<'a> TryFrom<&'a str> for Authority {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        TryFrom::try_from(s.as_bytes())\n    }\n}"
        ],
        "uri::builder::Builder": [
            "Debug",
            "impl Builder {\n    /// Creates a new default instance of `Builder` to construct a `Uri`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = uri::Builder::new()\n    ///     .scheme(\"https\")\n    ///     .authority(\"hyper.rs\")\n    ///     .path_and_query(\"/\")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    #[inline]\n    pub fn new() -> Builder {\n        Builder::default()\n    }\n\n    /// Set the `Scheme` for this URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let mut builder = uri::Builder::new();\n    /// builder.scheme(\"https\");\n    /// ```\n    pub fn scheme<T>(self, scheme: T) -> Self\n    where\n        T: TryInto<Scheme>,\n        <T as TryInto<Scheme>>::Error: Into<crate::Error>,\n    {\n        self.map(move |mut parts| {\n            let scheme = scheme.try_into().map_err(Into::into)?;\n            parts.scheme = Some(scheme);\n            Ok(parts)\n        })\n    }\n\n    /// Set the `Authority` for this URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = uri::Builder::new()\n    ///     .authority(\"tokio.rs\")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn authority<T>(self, auth: T) -> Self\n    where\n        T: TryInto<Authority>,\n        <T as TryInto<Authority>>::Error: Into<crate::Error>,\n    {\n        self.map(move |mut parts| {\n            let auth = auth.try_into().map_err(Into::into)?;\n            parts.authority = Some(auth);\n            Ok(parts)\n        })\n    }\n\n    /// Set the `PathAndQuery` for this URI.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = uri::Builder::new()\n    ///     .path_and_query(\"/hello?foo=bar\")\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn path_and_query<T>(self, p_and_q: T) -> Self\n    where\n        T: TryInto<PathAndQuery>,\n        <T as TryInto<PathAndQuery>>::Error: Into<crate::Error>,\n    {\n        self.map(move |mut parts| {\n            let p_and_q = p_and_q.try_into().map_err(Into::into)?;\n            parts.path_and_query = Some(p_and_q);\n            Ok(parts)\n        })\n    }\n\n    /// Consumes this builder, and tries to construct a valid `Uri` from\n    /// the configured pieces.\n    ///\n    /// # Errors\n    ///\n    /// This function may return an error if any previously configured argument\n    /// failed to parse or get converted to the internal representation. For\n    /// example if an invalid `scheme` was specified via `scheme(\"!@#%/^\")`\n    /// the error will be returned when this function is called rather than\n    /// when `scheme` was called.\n    ///\n    /// Additionally, the various forms of URI require certain combinations of\n    /// parts to be set to be valid. If the parts don't fit into any of the\n    /// valid forms of URI, a new error is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::*;\n    ///\n    /// let uri = Uri::builder()\n    ///     .build()\n    ///     .unwrap();\n    /// ```\n    pub fn build(self) -> Result<Uri, crate::Error> {\n        let parts = self.parts?;\n        Uri::from_parts(parts).map_err(Into::into)\n    }\n\n    // private\n\n    fn map<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts, crate::Error>,\n    {\n        Builder {\n            parts: self.parts.and_then(func),\n        }\n    }\n}",
            "impl Default for Builder {\n    #[inline]\n    fn default() -> Builder {\n        Builder {\n            parts: Ok(Parts::default()),\n        }\n    }\n}",
            "impl From<Uri> for Builder {\n    fn from(uri: Uri) -> Self {\n        Self {\n            parts: Ok(uri.into_parts()),\n        }\n    }\n}"
        ],
        "uri::path::PathAndQuery": [
            "Clone",
            "impl Eq for PathAndQuery {}",
            "impl FromStr for PathAndQuery {\n    type Err = InvalidUri;\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, InvalidUri> {\n        TryFrom::try_from(s)\n    }\n}",
            "impl PartialEq for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &PathAndQuery) -> bool {\n        self.data == other.data\n    }\n}",
            "impl PartialEq<String> for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n        self.as_str() == other.as_str()\n    }\n}",
            "impl PartialEq<str> for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n        self.as_str() == other\n    }\n}",
            "impl PartialOrd for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other.as_str())\n    }\n}",
            "impl PartialOrd<String> for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other.as_str())\n    }\n}",
            "impl PartialOrd<str> for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(other)\n    }\n}",
            "impl PathAndQuery {\n    // Not public while `bytes` is unstable.\n    pub(super) fn from_shared(mut src: Bytes) -> Result<Self, InvalidUri> {\n        let mut query = NONE;\n        let mut fragment = None;\n\n        let mut is_maybe_not_utf8 = false;\n\n        // block for iterator borrow\n        {\n            let mut iter = src.as_ref().iter().enumerate();\n\n            // path ...\n            for (i, &b) in &mut iter {\n                // See https://url.spec.whatwg.org/#path-state\n                match b {\n                    b'?' => {\n                        debug_assert_eq!(query, NONE);\n                        query = i as u16;\n                        break;\n                    }\n                    b'#' => {\n                        fragment = Some(i);\n                        break;\n                    }\n\n                    // This is the range of bytes that don't need to be\n                    // percent-encoded in the path. If it should have been\n                    // percent-encoded, then error.\n                    #[rustfmt::skip]\n                    0x21 |\n                    0x24..=0x3B |\n                    0x3D |\n                    0x40..=0x5F |\n                    0x61..=0x7A |\n                    0x7C |\n                    0x7E => {}\n\n                    // potentially utf8, might not, should check\n                    0x7F..=0xFF => {\n                        is_maybe_not_utf8 = true;\n                    }\n\n                    // These are code points that are supposed to be\n                    // percent-encoded in the path but there are clients\n                    // out there sending them as is and httparse accepts\n                    // to parse those requests, so they are allowed here\n                    // for parity.\n                    //\n                    // For reference, those are code points that are used\n                    // to send requests with JSON directly embedded in\n                    // the URI path. Yes, those things happen for real.\n                    #[rustfmt::skip]\n                    b'\"' |\n                    b'{' | b'}' => {}\n\n                    _ => return Err(ErrorKind::InvalidUriChar.into()),\n                }\n            }\n\n            // query ...\n            if query != NONE {\n                for (i, &b) in iter {\n                    match b {\n                        // While queries *should* be percent-encoded, most\n                        // bytes are actually allowed...\n                        // See https://url.spec.whatwg.org/#query-state\n                        //\n                        // Allowed: 0x21 / 0x24 - 0x3B / 0x3D / 0x3F - 0x7E\n                        #[rustfmt::skip]\n                        0x21 |\n                        0x24..=0x3B |\n                        0x3D |\n                        0x3F..=0x7E => {}\n\n                        0x7F..=0xFF => {\n                            is_maybe_not_utf8 = true;\n                        }\n\n                        b'#' => {\n                            fragment = Some(i);\n                            break;\n                        }\n\n                        _ => return Err(ErrorKind::InvalidUriChar.into()),\n                    }\n                }\n            }\n        }\n\n        if let Some(i) = fragment {\n            src.truncate(i);\n        }\n\n        let data = if is_maybe_not_utf8 {\n            ByteStr::from_utf8(src).map_err(|_| ErrorKind::InvalidUriChar)?\n        } else {\n            unsafe { ByteStr::from_utf8_unchecked(src) }\n        };\n\n        Ok(PathAndQuery { data, query })\n    }\n\n    /// Convert a `PathAndQuery` from a static string.\n    ///\n    /// This function will not perform any copying, however the string is\n    /// checked to ensure that it is valid.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if the argument is an invalid path and query.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let v = PathAndQuery::from_static(\"/hello?world\");\n    ///\n    /// assert_eq!(v.path(), \"/hello\");\n    /// assert_eq!(v.query(), Some(\"world\"));\n    /// ```\n    #[inline]\n    pub fn from_static(src: &'static str) -> Self {\n        let src = Bytes::from_static(src.as_bytes());\n\n        PathAndQuery::from_shared(src).unwrap()\n    }\n\n    /// Attempt to convert a `Bytes` buffer to a `PathAndQuery`.\n    ///\n    /// This will try to prevent a copy if the type passed is the type used\n    /// internally, and will copy the data if it is not.\n    pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + 'static,\n    {\n        if_downcast_into!(T, Bytes, src, {\n            return PathAndQuery::from_shared(src);\n        });\n\n        PathAndQuery::try_from(src.as_ref())\n    }\n\n    pub(super) fn empty() -> Self {\n        PathAndQuery {\n            data: ByteStr::new(),\n            query: NONE,\n        }\n    }\n\n    pub(super) fn slash() -> Self {\n        PathAndQuery {\n            data: ByteStr::from_static(\"/\"),\n            query: NONE,\n        }\n    }\n\n    pub(super) fn star() -> Self {\n        PathAndQuery {\n            data: ByteStr::from_static(\"*\"),\n            query: NONE,\n        }\n    }\n\n    /// Returns the path component\n    ///\n    /// The path component is **case sensitive**.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                        |--------|\n    ///                                             |\n    ///                                           path\n    /// ```\n    ///\n    /// If the URI is `*` then the path component is equal to `*`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    ///\n    /// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.path(), \"/hello/world\");\n    /// ```\n    #[inline]\n    pub fn path(&self) -> &str {\n        let ret = if self.query == NONE {\n            &self.data[..]\n        } else {\n            &self.data[..self.query as usize]\n        };\n\n        if ret.is_empty() {\n            return \"/\";\n        }\n\n        ret\n    }\n\n    /// Returns the query string component\n    ///\n    /// The query component contains non-hierarchical data that, along with data\n    /// in the path component, serves to identify a resource within the scope of\n    /// the URI's scheme and naming authority (if any). The query component is\n    /// indicated by the first question mark (\"?\") character and terminated by a\n    /// number sign (\"#\") character or by the end of the URI.\n    ///\n    /// ```notrust\n    /// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n    ///                                                   |-------------------|\n    ///                                                             |\n    ///                                                           query\n    /// ```\n    ///\n    /// # Examples\n    ///\n    /// With a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.query(), Some(\"key=value&foo=bar\"));\n    /// ```\n    ///\n    /// Without a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert!(path_and_query.query().is_none());\n    /// ```\n    #[inline]\n    pub fn query(&self) -> Option<&str> {\n        if self.query == NONE {\n            None\n        } else {\n            let i = self.query + 1;\n            Some(&self.data[i as usize..])\n        }\n    }\n\n    /// Returns the path and query as a string component.\n    ///\n    /// # Examples\n    ///\n    /// With a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.as_str(), \"/hello/world?key=value&foo=bar\");\n    /// ```\n    ///\n    /// Without a query string component\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n    ///\n    /// assert_eq!(path_and_query.as_str(), \"/hello/world\");\n    /// ```\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        let ret = &self.data[..];\n        if ret.is_empty() {\n            return \"/\";\n        }\n        ret\n    }\n}",
            "impl TryFrom<&String> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &String) -> Result<Self, Self::Error> {\n        TryFrom::try_from(s.as_bytes())\n    }\n}",
            "impl TryFrom<String> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: String) -> Result<Self, Self::Error> {\n        PathAndQuery::from_shared(s.into())\n    }\n}",
            "impl TryFrom<Vec<u8>> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(vec: Vec<u8>) -> Result<Self, Self::Error> {\n        PathAndQuery::from_shared(vec.into())\n    }\n}",
            "impl fmt::Debug for PathAndQuery {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}",
            "impl fmt::Display for PathAndQuery {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if !self.data.is_empty() {\n            match self.data.as_bytes()[0] {\n                b'/' | b'*' => write!(fmt, \"{}\", &self.data[..]),\n                _ => write!(fmt, \"/{}\", &self.data[..]),\n            }\n        } else {\n            write!(fmt, \"/\")\n        }\n    }\n}",
            "impl hash::Hash for PathAndQuery {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        self.data.hash(state);\n    }\n}",
            "impl<'a> PartialEq<&'a str> for PathAndQuery {\n    #[inline]\n    fn eq(&self, other: &&'a str) -> bool {\n        self.as_str() == *other\n    }\n}",
            "impl<'a> PartialOrd<&'a str> for PathAndQuery {\n    #[inline]\n    fn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering> {\n        self.as_str().partial_cmp(*other)\n    }\n}",
            "impl<'a> TryFrom<&'a [u8]> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        PathAndQuery::from_shared(Bytes::copy_from_slice(s))\n    }\n}",
            "impl<'a> TryFrom<&'a str> for PathAndQuery {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        TryFrom::try_from(s.as_bytes())\n    }\n}"
        ],
        "uri::port::Port": [
            "impl<T, U> PartialEq<Port<U>> for Port<T> {\n    fn eq(&self, other: &Port<U>) -> bool {\n        self.port == other.port\n    }\n}",
            "impl<T> AsRef<str> for Port<T>\nwhere\n    T: AsRef<str>,\n{\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}",
            "impl<T> PartialEq<u16> for Port<T> {\n    fn eq(&self, other: &u16) -> bool {\n        self.port == *other\n    }\n}",
            "impl<T> Port<T>\nwhere\n    T: AsRef<str>,\n{\n    /// Converts a `str` to a port number.\n    ///\n    /// The supplied `str` must be a valid u16.\n    pub(crate) fn from_str(bytes: T) -> Result<Self, InvalidUri> {\n        bytes\n            .as_ref()\n            .parse::<u16>()\n            .map(|port| Port { port, repr: bytes })\n            .map_err(|_| ErrorKind::InvalidPort.into())\n    }\n\n    /// Returns the port number as a `str`.\n    ///\n    /// # Examples\n    ///\n    /// Port as `str`.\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = \"example.org:80\".parse().unwrap();\n    ///\n    /// let port = authority.port().unwrap();\n    /// assert_eq!(port.as_str(), \"80\");\n    /// ```\n    pub fn as_str(&self) -> &str {\n        self.repr.as_ref()\n    }\n}",
            "impl<T> Port<T> {\n    /// Returns the port number as a `u16`.\n    ///\n    /// # Examples\n    ///\n    /// Port as `u16`.\n    ///\n    /// ```\n    /// # use http::uri::Authority;\n    /// let authority: Authority = \"example.org:80\".parse().unwrap();\n    ///\n    /// let port = authority.port().unwrap();\n    /// assert_eq!(port.as_u16(), 80);\n    /// ```\n    pub const fn as_u16(&self) -> u16 {\n        self.port\n    }\n}",
            "impl<T> fmt::Debug for Port<T>\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"Port\").field(&self.port).finish()\n    }\n}",
            "impl<T> fmt::Display for Port<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // Use `u16::fmt` so that it respects any formatting flags that\n        // may have been set (like padding, align, etc).\n        fmt::Display::fmt(&self.port, f)\n    }\n}"
        ],
        "uri::scheme::Protocol": [
            "Clone",
            "Copy",
            "Debug",
            "impl Protocol {\n    pub(super) fn len(&self) -> usize {\n        match *self {\n            Protocol::Http => 4,\n            Protocol::Https => 5,\n        }\n    }\n}"
        ],
        "uri::scheme::Scheme": [
            "Clone",
            "impl AsRef<str> for Scheme {\n    #[inline]\n    fn as_ref(&self) -> &str {\n        self.as_str()\n    }\n}",
            "impl Eq for Scheme {}",
            "impl From<Scheme2> for Scheme {\n    fn from(src: Scheme2) -> Self {\n        Scheme { inner: src }\n    }\n}",
            "impl FromStr for Scheme {\n    type Err = InvalidUri;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        TryFrom::try_from(s)\n    }\n}",
            "impl Hash for Scheme {\n    fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        match self.inner {\n            Scheme2::None => (),\n            Scheme2::Standard(Protocol::Http) => state.write_u8(1),\n            Scheme2::Standard(Protocol::Https) => state.write_u8(2),\n            Scheme2::Other(ref other) => {\n                other.len().hash(state);\n                for &b in other.as_bytes() {\n                    state.write_u8(b.to_ascii_lowercase());\n                }\n            }\n        }\n    }\n}",
            "impl PartialEq for Scheme {\n    fn eq(&self, other: &Scheme) -> bool {\n        use self::Protocol::*;\n        use self::Scheme2::*;\n\n        match (&self.inner, &other.inner) {\n            (&Standard(Http), &Standard(Http)) => true,\n            (&Standard(Https), &Standard(Https)) => true,\n            (Other(a), Other(b)) => a.eq_ignore_ascii_case(b),\n            (&None, _) | (_, &None) => unreachable!(),\n            _ => false,\n        }\n    }\n}",
            "impl PartialEq<str> for Scheme {\n    fn eq(&self, other: &str) -> bool {\n        self.as_str().eq_ignore_ascii_case(other)\n    }\n}",
            "impl Scheme {\n    /// HTTP protocol scheme\n    pub const HTTP: Scheme = Scheme {\n        inner: Scheme2::Standard(Protocol::Http),\n    };\n\n    /// HTTP protocol over TLS.\n    pub const HTTPS: Scheme = Scheme {\n        inner: Scheme2::Standard(Protocol::Https),\n    };\n\n    pub(super) fn empty() -> Self {\n        Scheme {\n            inner: Scheme2::None,\n        }\n    }\n\n    /// Return a str representation of the scheme\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use http::uri::*;\n    /// let scheme: Scheme = \"http\".parse().unwrap();\n    /// assert_eq!(scheme.as_str(), \"http\");\n    /// ```\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        use self::Protocol::*;\n        use self::Scheme2::*;\n\n        match self.inner {\n            Standard(Http) => \"http\",\n            Standard(Https) => \"https\",\n            Other(ref v) => &v[..],\n            None => unreachable!(),\n        }\n    }\n}",
            "impl fmt::Debug for Scheme {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.as_str(), f)\n    }\n}",
            "impl fmt::Display for Scheme {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_str())\n    }\n}",
            "impl<'a> TryFrom<&'a [u8]> for Scheme {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a [u8]) -> Result<Self, Self::Error> {\n        use self::Scheme2::*;\n\n        match Scheme2::parse_exact(s)? {\n            None => Err(ErrorKind::InvalidScheme.into()),\n            Standard(p) => Ok(Standard(p).into()),\n            Other(_) => {\n                let bytes = Bytes::copy_from_slice(s);\n\n                // Safety: postcondition on parse_exact() means that s and\n                // hence bytes are valid UTF-8.\n                let string = unsafe { ByteStr::from_utf8_unchecked(bytes) };\n\n                Ok(Other(Box::new(string)).into())\n            }\n        }\n    }\n}",
            "impl<'a> TryFrom<&'a str> for Scheme {\n    type Error = InvalidUri;\n    #[inline]\n    fn try_from(s: &'a str) -> Result<Self, Self::Error> {\n        TryFrom::try_from(s.as_bytes())\n    }\n}"
        ],
        "uri::scheme::Scheme2": [
            "Clone",
            "Debug",
            "impl Scheme2<usize> {\n    // Postcondition: On all Ok() returns, s is valid UTF-8\n    fn parse_exact(s: &[u8]) -> Result<Scheme2<()>, InvalidUri> {\n        match s {\n            b\"http\" => Ok(Protocol::Http.into()),\n            b\"https\" => Ok(Protocol::Https.into()),\n            _ => {\n                if s.len() > MAX_SCHEME_LEN {\n                    return Err(ErrorKind::SchemeTooLong.into());\n                }\n\n                // check that each byte in s is a SCHEME_CHARS which implies\n                // that it is a valid single byte UTF-8 code point.\n                for &b in s {\n                    match SCHEME_CHARS[b as usize] {\n                        b':' => {\n                            // Don't want :// here\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        0 => {\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        _ => {}\n                    }\n                }\n\n                Ok(Scheme2::Other(()))\n            }\n        }\n    }\n\n    pub(super) fn parse(s: &[u8]) -> Result<Scheme2<usize>, InvalidUri> {\n        if s.len() >= 7 {\n            // Check for HTTP\n            if s[..7].eq_ignore_ascii_case(b\"http://\") {\n                // Prefix will be striped\n                return Ok(Protocol::Http.into());\n            }\n        }\n\n        if s.len() >= 8 {\n            // Check for HTTPs\n            if s[..8].eq_ignore_ascii_case(b\"https://\") {\n                return Ok(Protocol::Https.into());\n            }\n        }\n\n        if s.len() > 3 {\n            for i in 0..s.len() {\n                let b = s[i];\n\n                match SCHEME_CHARS[b as usize] {\n                    b':' => {\n                        // Not enough data remaining\n                        if s.len() < i + 3 {\n                            break;\n                        }\n\n                        // Not a scheme\n                        if &s[i + 1..i + 3] != b\"//\" {\n                            break;\n                        }\n\n                        if i > MAX_SCHEME_LEN {\n                            return Err(ErrorKind::SchemeTooLong.into());\n                        }\n\n                        // Return scheme\n                        return Ok(Scheme2::Other(i));\n                    }\n                    // Invalid scheme character, abort\n                    0 => break,\n                    _ => {}\n                }\n            }\n        }\n\n        Ok(Scheme2::None)\n    }\n}",
            "impl<T> From<Protocol> for Scheme2<T> {\n    fn from(src: Protocol) -> Self {\n        Scheme2::Standard(src)\n    }\n}",
            "impl<T> Scheme2<T> {\n    pub(super) fn is_none(&self) -> bool {\n        matches!(*self, Scheme2::None)\n    }\n}"
        ],
        "version::Http": [
            "Clone",
            "Copy",
            "Eq",
            "Hash",
            "Ord",
            "PartialEq",
            "PartialOrd"
        ],
        "version::Version": [
            "Clone",
            "Copy",
            "Eq",
            "Hash",
            "Ord",
            "PartialEq",
            "PartialOrd",
            "impl Default for Version {\n    #[inline]\n    fn default() -> Version {\n        Version::HTTP_11\n    }\n}",
            "impl Version {\n    /// `HTTP/0.9`\n    pub const HTTP_09: Version = Version(Http::Http09);\n\n    /// `HTTP/1.0`\n    pub const HTTP_10: Version = Version(Http::Http10);\n\n    /// `HTTP/1.1`\n    pub const HTTP_11: Version = Version(Http::Http11);\n\n    /// `HTTP/2.0`\n    pub const HTTP_2: Version = Version(Http::H2);\n\n    /// `HTTP/3.0`\n    pub const HTTP_3: Version = Version(Http::H3);\n}",
            "impl fmt::Debug for Version {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use self::Http::*;\n\n        f.write_str(match self.0 {\n            Http09 => \"HTTP/0.9\",\n            Http10 => \"HTTP/1.0\",\n            Http11 => \"HTTP/1.1\",\n            H2 => \"HTTP/2.0\",\n            H3 => \"HTTP/3.0\",\n            __NonExhaustive => unreachable!(),\n        })\n    }\n}"
        ]
    },
    "single_path_import": {
        "error::Error": "Error",
        "error::Result": "Result",
        "extensions::Extensions": "Extensions",
        "header::map::Drain": "header::Drain",
        "header::map::Entry": "header::Entry",
        "header::map::GetAll": "header::GetAll",
        "header::map::HeaderMap": "HeaderMap",
        "header::map::IntoIter": "header::IntoIter",
        "header::map::Iter": "header::Iter",
        "header::map::IterMut": "header::IterMut",
        "header::map::Keys": "header::Keys",
        "header::map::MaxSizeReached": "header::MaxSizeReached",
        "header::map::OccupiedEntry": "header::OccupiedEntry",
        "header::map::VacantEntry": "header::VacantEntry",
        "header::map::ValueDrain": "header::ValueDrain",
        "header::map::ValueIter": "header::ValueIter",
        "header::map::ValueIterMut": "header::ValueIterMut",
        "header::map::Values": "header::Values",
        "header::map::ValuesMut": "header::ValuesMut",
        "header::map::as_header_name::AsHeaderName": "header::AsHeaderName",
        "header::map::into_header_name::IntoHeaderName": "header::IntoHeaderName",
        "header::name::ACCEPT": "header::ACCEPT",
        "header::name::ACCEPT_CHARSET": "header::ACCEPT_CHARSET",
        "header::name::ACCEPT_ENCODING": "header::ACCEPT_ENCODING",
        "header::name::ACCEPT_LANGUAGE": "header::ACCEPT_LANGUAGE",
        "header::name::ACCEPT_RANGES": "header::ACCEPT_RANGES",
        "header::name::ACCESS_CONTROL_ALLOW_CREDENTIALS": "header::ACCESS_CONTROL_ALLOW_CREDENTIALS",
        "header::name::ACCESS_CONTROL_ALLOW_HEADERS": "header::ACCESS_CONTROL_ALLOW_HEADERS",
        "header::name::ACCESS_CONTROL_ALLOW_METHODS": "header::ACCESS_CONTROL_ALLOW_METHODS",
        "header::name::ACCESS_CONTROL_ALLOW_ORIGIN": "header::ACCESS_CONTROL_ALLOW_ORIGIN",
        "header::name::ACCESS_CONTROL_EXPOSE_HEADERS": "header::ACCESS_CONTROL_EXPOSE_HEADERS",
        "header::name::ACCESS_CONTROL_MAX_AGE": "header::ACCESS_CONTROL_MAX_AGE",
        "header::name::ACCESS_CONTROL_REQUEST_HEADERS": "header::ACCESS_CONTROL_REQUEST_HEADERS",
        "header::name::ACCESS_CONTROL_REQUEST_METHOD": "header::ACCESS_CONTROL_REQUEST_METHOD",
        "header::name::AGE": "header::AGE",
        "header::name::ALLOW": "header::ALLOW",
        "header::name::ALT_SVC": "header::ALT_SVC",
        "header::name::AUTHORIZATION": "header::AUTHORIZATION",
        "header::name::CACHE_CONTROL": "header::CACHE_CONTROL",
        "header::name::CACHE_STATUS": "header::CACHE_STATUS",
        "header::name::CDN_CACHE_CONTROL": "header::CDN_CACHE_CONTROL",
        "header::name::CONNECTION": "header::CONNECTION",
        "header::name::CONTENT_DISPOSITION": "header::CONTENT_DISPOSITION",
        "header::name::CONTENT_ENCODING": "header::CONTENT_ENCODING",
        "header::name::CONTENT_LANGUAGE": "header::CONTENT_LANGUAGE",
        "header::name::CONTENT_LENGTH": "header::CONTENT_LENGTH",
        "header::name::CONTENT_LOCATION": "header::CONTENT_LOCATION",
        "header::name::CONTENT_RANGE": "header::CONTENT_RANGE",
        "header::name::CONTENT_SECURITY_POLICY": "header::CONTENT_SECURITY_POLICY",
        "header::name::CONTENT_SECURITY_POLICY_REPORT_ONLY": "header::CONTENT_SECURITY_POLICY_REPORT_ONLY",
        "header::name::CONTENT_TYPE": "header::CONTENT_TYPE",
        "header::name::COOKIE": "header::COOKIE",
        "header::name::DATE": "header::DATE",
        "header::name::DNT": "header::DNT",
        "header::name::ETAG": "header::ETAG",
        "header::name::EXPECT": "header::EXPECT",
        "header::name::EXPIRES": "header::EXPIRES",
        "header::name::FORWARDED": "header::FORWARDED",
        "header::name::FROM": "header::FROM",
        "header::name::HOST": "header::HOST",
        "header::name::HeaderName": "HeaderName",
        "header::name::IF_MATCH": "header::IF_MATCH",
        "header::name::IF_MODIFIED_SINCE": "header::IF_MODIFIED_SINCE",
        "header::name::IF_NONE_MATCH": "header::IF_NONE_MATCH",
        "header::name::IF_RANGE": "header::IF_RANGE",
        "header::name::IF_UNMODIFIED_SINCE": "header::IF_UNMODIFIED_SINCE",
        "header::name::InvalidHeaderName": "header::InvalidHeaderName",
        "header::name::LAST_MODIFIED": "header::LAST_MODIFIED",
        "header::name::LINK": "header::LINK",
        "header::name::LOCATION": "header::LOCATION",
        "header::name::MAX_FORWARDS": "header::MAX_FORWARDS",
        "header::name::ORIGIN": "header::ORIGIN",
        "header::name::PRAGMA": "header::PRAGMA",
        "header::name::PROXY_AUTHENTICATE": "header::PROXY_AUTHENTICATE",
        "header::name::PROXY_AUTHORIZATION": "header::PROXY_AUTHORIZATION",
        "header::name::PUBLIC_KEY_PINS": "header::PUBLIC_KEY_PINS",
        "header::name::PUBLIC_KEY_PINS_REPORT_ONLY": "header::PUBLIC_KEY_PINS_REPORT_ONLY",
        "header::name::RANGE": "header::RANGE",
        "header::name::REFERER": "header::REFERER",
        "header::name::REFERRER_POLICY": "header::REFERRER_POLICY",
        "header::name::REFRESH": "header::REFRESH",
        "header::name::RETRY_AFTER": "header::RETRY_AFTER",
        "header::name::SEC_WEBSOCKET_ACCEPT": "header::SEC_WEBSOCKET_ACCEPT",
        "header::name::SEC_WEBSOCKET_EXTENSIONS": "header::SEC_WEBSOCKET_EXTENSIONS",
        "header::name::SEC_WEBSOCKET_KEY": "header::SEC_WEBSOCKET_KEY",
        "header::name::SEC_WEBSOCKET_PROTOCOL": "header::SEC_WEBSOCKET_PROTOCOL",
        "header::name::SEC_WEBSOCKET_VERSION": "header::SEC_WEBSOCKET_VERSION",
        "header::name::SERVER": "header::SERVER",
        "header::name::SET_COOKIE": "header::SET_COOKIE",
        "header::name::STRICT_TRANSPORT_SECURITY": "header::STRICT_TRANSPORT_SECURITY",
        "header::name::TE": "header::TE",
        "header::name::TRAILER": "header::TRAILER",
        "header::name::TRANSFER_ENCODING": "header::TRANSFER_ENCODING",
        "header::name::UPGRADE": "header::UPGRADE",
        "header::name::UPGRADE_INSECURE_REQUESTS": "header::UPGRADE_INSECURE_REQUESTS",
        "header::name::USER_AGENT": "header::USER_AGENT",
        "header::name::VARY": "header::VARY",
        "header::name::VIA": "header::VIA",
        "header::name::WARNING": "header::WARNING",
        "header::name::WWW_AUTHENTICATE": "header::WWW_AUTHENTICATE",
        "header::name::X_CONTENT_TYPE_OPTIONS": "header::X_CONTENT_TYPE_OPTIONS",
        "header::name::X_DNS_PREFETCH_CONTROL": "header::X_DNS_PREFETCH_CONTROL",
        "header::name::X_FRAME_OPTIONS": "header::X_FRAME_OPTIONS",
        "header::name::X_XSS_PROTECTION": "header::X_XSS_PROTECTION",
        "header::value::HeaderValue": "HeaderValue",
        "header::value::InvalidHeaderValue": "header::InvalidHeaderValue",
        "header::value::ToStrError": "header::ToStrError",
        "method::Method": "Method",
        "request::Request": "Request",
        "response::Response": "Response",
        "status::StatusCode": "StatusCode",
        "uri::Uri": "Uri",
        "uri::authority::Authority": "uri::Authority",
        "uri::builder::Builder": "uri::Builder",
        "uri::path::PathAndQuery": "uri::PathAndQuery",
        "uri::port::Port": "uri::Port",
        "uri::scheme::Scheme": "uri::Scheme",
        "version::Version": "Version"
    },
    "srcs": {
        "<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": [
            "fn into_iter(self) -> Iter<'a, T>{\n        self.iter()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str": [
            "fn as_str(&self) -> &str{\n            <HeaderName>::as_str(self)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find": [
            "#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            map.find(*self)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry": [
            "#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>{\n            Ok(map.try_entry2(self)?)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_append": [
            "#[inline]\nfn try_append<T>(self, map: &mut HeaderMap<T>, val: T) -> Result<bool, MaxSizeReached>{\n            map.try_append2(self, val)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry": [
            "#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, MaxSizeReached>{\n            map.try_entry2(self)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert": [
            "#[inline]\nfn try_insert<T>(\n            self,\n            map: &mut HeaderMap<T>,\n            val: T,\n        ) -> Result<Option<T>, MaxSizeReached>{\n            map.try_insert2(self, val)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq": [
            "#[inline]\nfn eq(&self, other: &HeaderName) -> bool{\n        *other == *self\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq": [
            "#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        **self == *other\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        (**self).partial_cmp(other)\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq": [
            "#[inline]\nfn eq(&self, other: &Method) -> bool{\n        *self == other\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": [
            "fn into_iter(self) -> IterMut<'a, T>{\n        self.iter_mut()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a std::string::String as header::map::as_header_name::Sealed>::as_str": [
            "fn as_str(&self) -> &str{\n            self\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a std::string::String as header::map::as_header_name::Sealed>::find": [
            "#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            Sealed::find(*self, map)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a std::string::String as header::map::as_header_name::Sealed>::try_entry": [
            "#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>{\n            self.as_str().try_entry(map)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a str as header::map::as_header_name::Sealed>::as_str": [
            "fn as_str(&self) -> &str{\n            self\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a str as header::map::as_header_name::Sealed>::find": [
            "#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            HdrName::from_bytes(self.as_bytes(), move |hdr| map.find(&hdr)).unwrap_or(None)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'a str as header::map::as_header_name::Sealed>::try_entry": [
            "#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>{\n            Ok(HdrName::from_bytes(self.as_bytes(), move |hdr| {\n                map.try_entry2(hdr)\n            })??)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": [
            "fn into_iter(self) -> ValueIter<'a, T>{\n        self.map.value_iter(self.index)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": [
            "fn into_iter(self) -> ValueIter<'a, T>{\n        self.iter()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": [
            "fn into_iter(self) -> ValueIterMut<'a, T>{\n        self.iter_mut()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'static str as header::map::into_header_name::Sealed>::try_append": [
            "#[inline]\nfn try_append<T>(self, map: &mut HeaderMap<T>, val: T) -> Result<bool, MaxSizeReached>{\n            HdrName::from_static(self, move |hdr| map.try_append2(hdr, val))\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'static str as header::map::into_header_name::Sealed>::try_entry": [
            "#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, MaxSizeReached>{\n            HdrName::from_static(self, move |hdr| map.try_entry2(hdr))\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<&'static str as header::map::into_header_name::Sealed>::try_insert": [
            "#[inline]\nfn try_insert<T>(\n            self,\n            map: &mut HeaderMap<T>,\n            val: T,\n        ) -> Result<Option<T>, MaxSizeReached>{\n            HdrName::from_static(self, move |hdr| map.try_insert2(hdr, val))\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<T as extensions::AnyClone>::as_any": [
            "fn as_any(&self) -> &dyn Any{\n        self\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "<T as extensions::AnyClone>::as_any_mut": [
            "fn as_any_mut(&mut self) -> &mut dyn Any{\n        self\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "<T as extensions::AnyClone>::clone_box": [
            "fn clone_box(&self) -> Box<dyn AnyClone + Send + Sync>{\n        Box::new(self.clone())\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "<T as extensions::AnyClone>::into_any": [
            "fn into_any(self: Box<Self>) -> Box<dyn Any>{\n        self\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "<byte_str::ByteStr as std::convert::From<&'a str>>::from": [
            "#[inline]\nfn from(src: &'a str) -> ByteStr{\n        ByteStr {\n            // Invariant: src is a str so contains valid UTF-8.\n            bytes: Bytes::copy_from_slice(src.as_bytes()),\n        }\n    }",
            "Real(LocalPath(\"src/byte_str.rs\"))"
        ],
        "<byte_str::ByteStr as std::convert::From<std::string::String>>::from": [
            "#[inline]\nfn from(src: String) -> ByteStr{\n        ByteStr {\n            // Invariant: src is a String so contains valid UTF-8.\n            bytes: Bytes::from(src),\n        }\n    }",
            "Real(LocalPath(\"src/byte_str.rs\"))"
        ],
        "<byte_str::ByteStr as std::ops::Deref>::deref": [
            "#[inline]\nfn deref(&self) -> &str{\n        let b: &[u8] = self.bytes.as_ref();\n        // Safety: the invariant of `bytes` is that it contains valid UTF-8.\n        unsafe { str::from_utf8_unchecked(b) }\n    }",
            "Real(LocalPath(\"src/byte_str.rs\"))"
        ],
        "<error::Error as std::convert::From<header::map::MaxSizeReached>>::from": [
            "fn from(err: MaxSizeReached) -> Error{\n        Error {\n            inner: ErrorKind::MaxSizeReached(err),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from": [
            "fn from(err: header::InvalidHeaderName) -> Error{\n        Error {\n            inner: ErrorKind::HeaderName(err),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from": [
            "fn from(err: header::InvalidHeaderValue) -> Error{\n        Error {\n            inner: ErrorKind::HeaderValue(err),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as std::convert::From<method::InvalidMethod>>::from": [
            "fn from(err: method::InvalidMethod) -> Error{\n        Error {\n            inner: ErrorKind::Method(err),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as std::convert::From<status::InvalidStatusCode>>::from": [
            "fn from(err: status::InvalidStatusCode) -> Error{\n        Error {\n            inner: ErrorKind::StatusCode(err),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as std::convert::From<std::convert::Infallible>>::from": [
            "fn from(err: std::convert::Infallible) -> Error{\n        match err {}\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as std::convert::From<uri::InvalidUri>>::from": [
            "fn from(err: uri::InvalidUri) -> Error{\n        Error {\n            inner: ErrorKind::Uri(err),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as std::convert::From<uri::InvalidUriParts>>::from": [
            "fn from(err: uri::InvalidUriParts) -> Error{\n        Error {\n            inner: ErrorKind::UriParts(err),\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as std::error::Error>::source": [
            "fn source(&self) -> Option<&(dyn error::Error + 'static)>{\n        self.get_ref().source()\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_tuple(\"http::Error\")\n            // Skip the noise of the ErrorKind enum\n            .field(&self.get_ref())\n            .finish()\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<error::Error as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self.get_ref(), f)\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "<extensions::Extensions as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Extensions\").finish()\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "<extensions::IdHasher as std::hash::Hasher>::finish": [
            "#[inline]\nfn finish(&self) -> u64{\n        self.0\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "<extensions::IdHasher as std::hash::Hasher>::write": [
            "fn write(&mut self, _: &[u8]){\n        unreachable!(\"TypeId calls write_u64\");\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "<extensions::IdHasher as std::hash::Hasher>::write_u64": [
            "#[inline]\nfn write_u64(&mut self, id: u64){\n        self.0 = id;\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "<header::map::Drain<'a, T> as std::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        if let Some(next) = self.next {\n            // Remove the extra value\n\n            let raw_links = RawLinks(self.entries);\n            let extra = unsafe { remove_extra_value(raw_links, &mut *self.extra_values, next) };\n\n            match extra.next {\n                Link::Extra(idx) => self.next = Some(idx),\n                Link::Entry(_) => self.next = None,\n            }\n\n            return Some((None, extra.value));\n        }\n\n        let idx = self.idx;\n\n        if idx == self.len {\n            return None;\n        }\n\n        self.idx += 1;\n\n        unsafe {\n            let entry = &(*self.entries)[idx];\n\n            // Read the header name\n            let key = ptr::read(&entry.key as *const _);\n            let value = ptr::read(&entry.value as *const _);\n            self.next = entry.links.map(|l| l.next);\n\n            Some((Some(key), value))\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        // At least this many names... It's unknown if the user wants\n        // to count the extra_values on top.\n        //\n        // For instance, extending a new `HeaderMap` wouldn't need to\n        // reserve the upper-bound in `entries`, only the lower-bound.\n        let lower = self.len - self.idx;\n        let upper = unsafe { (*self.extra_values).len() } + lower;\n        (lower, Some(upper))\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Drain<'a, T> as std::ops::Drop>::drop": [
            "fn drop(&mut self){\n        for _ in self {}\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq": [
            "fn eq(&self, other: &Self) -> bool{\n        self.iter().eq(other.iter())\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": [
            "fn into_iter(self) -> ValueIter<'a, T>{\n        self.map.value_iter(self.index)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq": [
            "fn eq(&self, other: &HeaderMap<T>) -> bool{\n        if self.len() != other.len() {\n            return false;\n        }\n\n        self.keys()\n            .all(|key| self.get_all(key) == other.get_all(key))\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V, S>>>::try_from": [
            "fn try_from(c: &'a HashMap<K, V, S>) -> Result<Self, Self::Error>{\n        c.iter()\n            .map(|(k, v)| -> crate::Result<(HeaderName, T)> {\n                let name = TryFrom::try_from(k).map_err(Into::into)?;\n                let value = TryFrom::try_from(v).map_err(Into::into)?;\n                Ok((name, value))\n            })\n            .collect()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::HeaderMap<T> as std::default::Default>::default": [
            "fn default() -> Self{\n        HeaderMap::try_with_capacity(0).expect(\"zero capacity should never fail\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::HeaderMap<T> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_map().entries(self.iter()).finish()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend": [
            "fn extend<I: IntoIterator<Item = (HeaderName, T)>>(&mut self, iter: I){\n        // Keys may be already present or show multiple times in the iterator.\n        // Reserve the entire hint lower bound if the map is empty.\n        // Otherwise reserve half the hint (rounded up), so the map\n        // will only resize twice in the worst case.\n        let iter = iter.into_iter();\n\n        let reserve = if self.is_empty() {\n            iter.size_hint().0\n        } else {\n            (iter.size_hint().0 + 1) / 2\n        };\n\n        self.reserve(reserve);\n\n        for (k, v) in iter {\n            self.append(k, v);\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend": [
            "/// Extend a `HeaderMap` with the contents of another `HeaderMap`.\n///\n/// This function expects the yielded items to follow the same structure as\n/// `IntoIter`.\n///\n/// # Panics\n///\n/// This panics if the first yielded item does not have a `HeaderName`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// let mut extra = HeaderMap::new();\n///\n/// extra.insert(HOST, \"foo.bar\".parse().unwrap());\n/// extra.insert(COOKIE, \"hello\".parse().unwrap());\n/// extra.append(COOKIE, \"world\".parse().unwrap());\n///\n/// map.extend(extra);\n///\n/// assert_eq!(map[\"host\"], \"foo.bar\");\n/// assert_eq!(map[\"accept\"], \"text/plain\");\n/// assert_eq!(map[\"cookie\"], \"hello\");\n///\n/// let v = map.get_all(\"host\");\n/// assert_eq!(1, v.iter().count());\n///\n/// let v = map.get_all(\"cookie\");\n/// assert_eq!(2, v.iter().count());\n/// ```\nfn extend<I: IntoIterator<Item = (Option<HeaderName>, T)>>(&mut self, iter: I){\n        let mut iter = iter.into_iter();\n\n        // The structure of this is a bit weird, but it is mostly to make the\n        // borrow checker happy.\n        let (mut key, mut val) = match iter.next() {\n            Some((Some(key), val)) => (key, val),\n            Some((None, _)) => panic!(\"expected a header name, but got None\"),\n            None => return,\n        };\n\n        'outer: loop {\n            let mut entry = match self.try_entry2(key).expect(\"size overflows MAX_SIZE\") {\n                Entry::Occupied(mut e) => {\n                    // Replace all previous values while maintaining a handle to\n                    // the entry.\n                    e.insert(val);\n                    e\n                }\n                Entry::Vacant(e) => e.insert_entry(val),\n            };\n\n            // As long as `HeaderName` is none, keep inserting the value into\n            // the current entry\n            loop {\n                match iter.next() {\n                    Some((Some(k), v)) => {\n                        key = k;\n                        val = v;\n                        continue 'outer;\n                    }\n                    Some((None, v)) => {\n                        entry.append(v);\n                    }\n                    None => {\n                        return;\n                    }\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter": [
            "fn from_iter<I>(iter: I) -> Self\n    where\n        I: IntoIterator<Item = (HeaderName, T)>,{\n        let mut map = HeaderMap::default();\n        map.extend(iter);\n        map\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": [
            "/// Creates a consuming iterator, that is, one that moves keys and values\n/// out of the map in arbitrary order. The map cannot be used after calling\n/// this.\n///\n/// For each yielded item that has `None` provided for the `HeaderName`,\n/// then the associated header name is the same as that of the previously\n/// yielded item. The first yielded item will have `HeaderName` set.\n///\n/// # Examples\n///\n/// Basic usage.\n///\n/// ```\n/// # use http::header;\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n/// map.insert(header::CONTENT_LENGTH, \"123\".parse().unwrap());\n/// map.insert(header::CONTENT_TYPE, \"json\".parse().unwrap());\n///\n/// let mut iter = map.into_iter();\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), \"123\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), \"json\".parse().unwrap())));\n/// assert!(iter.next().is_none());\n/// ```\n///\n/// Multiple values per key.\n///\n/// ```\n/// # use http::header;\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// map.append(header::CONTENT_LENGTH, \"123\".parse().unwrap());\n/// map.append(header::CONTENT_LENGTH, \"456\".parse().unwrap());\n///\n/// map.append(header::CONTENT_TYPE, \"json\".parse().unwrap());\n/// map.append(header::CONTENT_TYPE, \"html\".parse().unwrap());\n/// map.append(header::CONTENT_TYPE, \"xml\".parse().unwrap());\n///\n/// let mut iter = map.into_iter();\n///\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), \"123\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, \"456\".parse().unwrap())));\n///\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), \"json\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, \"html\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, \"xml\".parse().unwrap())));\n/// assert!(iter.next().is_none());\n/// ```\nfn into_iter(self) -> IntoIter<T>{\n        IntoIter {\n            next: None,\n            entries: self.entries.into_iter(),\n            extra_values: self.extra_values,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::HeaderMap<T> as std::ops::Index<K>>::index": [
            "/// # Panics\n/// Using the index operator will cause a panic if the header you're querying isn't set.\n#[inline]\nfn index(&self, index: K) -> &T{\n        match self.get2(&index) {\n            Some(val) => val,\n            None => panic!(\"no entry found for key {:?}\", index.as_str()),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::IntoIter<T> as std::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        if let Some(next) = self.next {\n            self.next = match self.extra_values[next].next {\n                Link::Entry(_) => None,\n                Link::Extra(v) => Some(v),\n            };\n\n            let value = unsafe { ptr::read(&self.extra_values[next].value) };\n\n            return Some((None, value));\n        }\n\n        if let Some(bucket) = self.entries.next() {\n            self.next = bucket.links.map(|l| l.next);\n            let name = Some(bucket.key);\n            let value = bucket.value;\n\n            return Some((name, value));\n        }\n\n        None\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::IntoIter<T> as std::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        let (lower, _) = self.entries.size_hint();\n        // There could be more than just the entries upper, as there\n        // could be items in the `extra_values`. We could guess, saying\n        // `upper + extra_values.len()`, but that could overestimate by a lot.\n        (lower, None)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::IntoIter<T> as std::ops::Drop>::drop": [
            "fn drop(&mut self){\n        // Ensure the iterator is consumed\n        for _ in self.by_ref() {}\n\n        // All the values have already been yielded out.\n        unsafe {\n            self.extra_values.set_len(0);\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Iter<'a, T> as std::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        if self.cursor.is_none() {\n            if (self.entry + 1) >= self.map.entries.len() {\n                return None;\n            }\n\n            self.entry += 1;\n            self.cursor = Some(Cursor::Head);\n        }\n\n        let entry = &self.map.entries[self.entry];\n\n        match self.cursor.unwrap() {\n            Head => {\n                self.cursor = entry.links.map(|l| Values(l.next));\n                Some((&entry.key, &entry.value))\n            }\n            Values(idx) => {\n                let extra = &self.map.extra_values[idx];\n\n                match extra.next {\n                    Link::Entry(_) => self.cursor = None,\n                    Link::Extra(i) => self.cursor = Some(Values(i)),\n                }\n\n                Some((&entry.key, &extra.value))\n            }\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        let map = self.map;\n        debug_assert!(map.entries.len() >= self.entry);\n\n        let lower = map.entries.len() - self.entry;\n        // We could pessimistically guess at the upper bound, saying\n        // that its lower + map.extra_values.len(). That could be\n        // way over though, such as if we're near the end, and have\n        // already gone through several extra values...\n        (lower, None)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::IterMut<'a, T> as std::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        self.next_unsafe()\n            .map(|(key, ptr)| (key, unsafe { &mut *ptr }))\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        let map = unsafe { &*self.map };\n        debug_assert!(map.entries.len() >= self.entry);\n\n        let lower = map.entries.len() - self.entry;\n        // We could pessimistically guess at the upper bound, saying\n        // that its lower + map.extra_values.len(). That could be\n        // way over though, such as if we're near the end, and have\n        // already gone through several extra values...\n        (lower, None)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::count": [
            "fn count(self) -> usize{\n        self.inner.count()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::last": [
            "fn last(self) -> Option<Self::Item>{\n        self.inner.last().map(|b| &b.key)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|b| &b.key)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::nth": [
            "fn nth(&mut self, n: usize) -> Option<Self::Item>{\n        self.inner.nth(n).map(|b| &b.key)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::MaxSizeReached as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"MaxSizeReached\")\n            // skip _priv noise\n            .finish()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::MaxSizeReached as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"max size reached\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": [
            "fn into_iter(self) -> ValueIterMut<'a, T>{\n        self.map.value_iter_mut(self.index)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::RawLinks<T> as std::clone::Clone>::clone": [
            "fn clone(&self) -> RawLinks<T>{\n        *self\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::RawLinks<T> as std::ops::Index<usize>>::index": [
            "fn index(&self, idx: usize) -> &Self::Output{\n        unsafe { &(*self.0)[idx].links }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut": [
            "fn index_mut(&mut self, idx: usize) -> &mut Self::Output{\n        unsafe { &mut (*self.0)[idx].links }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<T>{\n        if self.first.is_some() {\n            self.first.take()\n        } else if let Some(ref mut extras) = self.next {\n            extras.next()\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        match (&self.first, &self.next) {\n            // Exactly 1\n            (&Some(_), &None) => (1, Some(1)),\n            // 1 + extras\n            (&Some(_), Some(extras)) => {\n                let (l, u) = extras.size_hint();\n                (l + 1, u.map(|u| u + 1))\n            }\n            // Extras only\n            (&None, Some(extras)) => extras.size_hint(),\n            // No more\n            (&None, &None) => (0, Some(0)),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop": [
            "fn drop(&mut self){\n        for _ in self.by_ref() {}\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&self.map.entries[self.index].value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::ValueIter<'a, T> as std::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        match self.front {\n            Some(Head) => {\n                let entry = &self.map.entries[self.index];\n\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = &self.map.extra_values[idx];\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&extra.value)\n            }\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        match (self.front, self.back) {\n            // Exactly 1 value...\n            (Some(Cursor::Head), Some(Cursor::Head)) => (1, Some(1)),\n            // At least 1...\n            (Some(_), _) => (1, None),\n            // No more values...\n            (None, _) => (0, Some(0)),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back": [
            "fn next_back(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.back {\n            Some(Head) => {\n                self.front = None;\n                self.back = None;\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.prev {\n                        Link::Entry(_) => self.back = Some(Head),\n                        Link::Extra(idx) => self.back = Some(Values(idx)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        use self::Cursor::*;\n\n        let entry = unsafe { &mut (*self.map).entries[self.index] };\n\n        match self.front {\n            Some(Head) => {\n                if self.back == Some(Head) {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    // Update the iterator state\n                    match entry.links {\n                        Some(links) => {\n                            self.front = Some(Values(links.next));\n                        }\n                        None => unreachable!(),\n                    }\n                }\n\n                Some(&mut entry.value)\n            }\n            Some(Values(idx)) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                if self.front == self.back {\n                    self.front = None;\n                    self.back = None;\n                } else {\n                    match extra.next {\n                        Link::Entry(_) => self.front = None,\n                        Link::Extra(i) => self.front = Some(Values(i)),\n                    }\n                }\n\n                Some(&mut extra.value)\n            }\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Values<'a, T> as std::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|(_, v)| v)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::Values<'a, T> as std::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next": [
            "fn next(&mut self) -> Option<Self::Item>{\n        self.inner.next().map(|(_, v)| v)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint": [
            "fn size_hint(&self) -> (usize, Option<usize>){\n        self.inner.size_hint()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::as_header_name::TryEntryError as std::convert::From<header::map::MaxSizeReached>>::from": [
            "fn from(e: MaxSizeReached) -> TryEntryError{\n            TryEntryError::MaxSizeReached(e)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::map::as_header_name::TryEntryError as std::convert::From<header::name::InvalidHeaderName>>::from": [
            "fn from(e: InvalidHeaderName) -> TryEntryError{\n            TryEntryError::InvalidHeaderName(e)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::name::Custom as std::hash::Hash>::hash": [
            "#[inline]\nfn hash<H: Hasher>(&self, hasher: &mut H){\n        hasher.write(self.0.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from": [
            "fn from(hdr: StandardHeader) -> HdrName<'a>{\n        HdrName {\n            inner: Repr::Standard(hdr),\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str": [
            "fn as_str(&self) -> &str{\n            <HeaderName>::as_str(self)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::name::HeaderName as header::map::as_header_name::Sealed>::find": [
            "#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            map.find(self)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry": [
            "#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>{\n            Ok(map.try_entry2(self)?)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::name::HeaderName as header::map::into_header_name::Sealed>::try_append": [
            "#[inline]\nfn try_append<T>(self, map: &mut HeaderMap<T>, val: T) -> Result<bool, MaxSizeReached>{\n            map.try_append2(self, val)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry": [
            "#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, MaxSizeReached>{\n            map.try_entry2(self)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert": [
            "#[inline]\nfn try_insert<T>(\n            self,\n            map: &mut HeaderMap<T>,\n            val: T,\n        ) -> Result<Option<T>, MaxSizeReached>{\n            map.try_insert2(self, val)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<header::name::HeaderName as std::borrow::Borrow<str>>::borrow": [
            "fn borrow(&self) -> &str{\n        self.as_str()\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq": [
            "#[inline]\nfn eq(&self, other: &&'a HeaderName) -> bool{\n        *self == **other\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq": [
            "/// Performs a case-insensitive comparison of the string against the header\n/// name\n#[inline]\nfn eq(&self, other: &&'a str) -> bool{\n        *self == **other\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq": [
            "#[inline]\nfn eq(&self, other: &HdrName<'a>) -> bool{\n        match self.inner {\n            Repr::Standard(a) => match other.inner {\n                Repr::Standard(b) => a == b,\n                _ => false,\n            },\n            Repr::Custom(Custom(ref a)) => match other.inner {\n                Repr::Custom(ref b) => {\n                    if b.lower {\n                        a.as_bytes() == b.buf\n                    } else {\n                        eq_ignore_ascii_case(a.as_bytes(), b.buf)\n                    }\n                }\n                _ => false,\n            },\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<str>>::eq": [
            "/// Performs a case-insensitive comparison of the string against the header\n/// name\n///\n/// # Examples\n///\n/// ```\n/// use http::header::CONTENT_LENGTH;\n///\n/// assert_eq!(CONTENT_LENGTH, \"content-length\");\n/// assert_eq!(CONTENT_LENGTH, \"Content-Length\");\n/// assert_ne!(CONTENT_LENGTH, \"content length\");\n/// ```\n#[inline]\nfn eq(&self, other: &str) -> bool{\n        eq_ignore_ascii_case(self.as_ref(), other.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref": [
            "fn as_ref(&self) -> &[u8]{\n        self.as_str().as_bytes()\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::AsRef<str>>::as_ref": [
            "fn as_ref(&self) -> &str{\n        self.as_str()\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from": [
            "fn from(src: &'a HeaderName) -> HeaderName{\n        src.clone()\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::From<header::name::Custom>>::from": [
            "fn from(src: Custom) -> HeaderName{\n        HeaderName {\n            inner: Repr::Custom(src),\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from": [
            "fn from(src: HdrName<'a>) -> HeaderName{\n        match src.inner {\n            Repr::Standard(s) => HeaderName {\n                inner: Repr::Standard(s),\n            },\n            Repr::Custom(maybe_lower) => {\n                if maybe_lower.lower {\n                    let buf = Bytes::copy_from_slice(maybe_lower.buf);\n                    // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                    let byte_str = unsafe { ByteStr::from_utf8_unchecked(buf) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(byte_str)),\n                    }\n                } else {\n                    use bytes::BufMut;\n                    let mut dst = BytesMut::with_capacity(maybe_lower.buf.len());\n\n                    for b in maybe_lower.buf.iter() {\n                        // HEADER_CHARS maps each byte to a valid single-byte UTF-8\n                        // codepoint.\n                        dst.put_u8(HEADER_CHARS[*b as usize]);\n                    }\n\n                    // Safety: the loop above maps each byte of maybe_lower.buf to a\n                    // valid single-byte UTF-8 codepoint before copying it into dst.\n                    // dst (and hence dst.freeze()) is thus valid UTF-8.\n                    let buf = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                    HeaderName {\n                        inner: Repr::Custom(Custom(buf)),\n                    }\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from": [
            "fn from(src: StandardHeader) -> HeaderName{\n        HeaderName {\n            inner: Repr::Standard(src),\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        Self::from_bytes(s)\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<&'a std::string::String>>::try_from": [
            "#[inline]\nfn try_from(s: &'a String) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<&'a str>>::try_from": [
            "#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<std::string::String>>::try_from": [
            "#[inline]\nfn try_from(s: String) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "#[inline]\nfn try_from(vec: Vec<u8>) -> Result<Self, Self::Error>{\n        Self::from_bytes(&vec)\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::fmt::Debug>::fmt": [
            "fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Debug::fmt(self.as_str(), fmt)\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::fmt::Display>::fmt": [
            "fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self.as_str(), fmt)\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::HeaderName as std::str::FromStr>::from_str": [
            "fn from_str(s: &str) -> Result<HeaderName, InvalidHeaderName>{\n        HeaderName::from_bytes(s.as_bytes()).map_err(|_| InvalidHeaderName { _priv: () })\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::InvalidHeaderName as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"InvalidHeaderName\")\n            // skip _priv noise\n            .finish()\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::InvalidHeaderName as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"invalid HTTP header name\")\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::name::MaybeLower<'a> as std::hash::Hash>::hash": [
            "#[inline]\nfn hash<H: Hasher>(&self, hasher: &mut H){\n        if self.lower {\n            hasher.write(self.buf);\n        } else {\n            for &b in self.buf {\n                hasher.write(&[HEADER_CHARS[b as usize]]);\n            }\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::Ord>::cmp": [
            "#[inline]\nfn cmp(&self, other: &Self) -> cmp::Ordering{\n        self.inner.cmp(&other.inner)\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq": [
            "#[inline]\nfn eq(&self, other: &&'a T) -> bool{\n        *self == **other\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq": [
            "#[inline]\nfn eq(&self, other: &[u8]) -> bool{\n        self.inner == other\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq": [
            "#[inline]\nfn eq(&self, other: &String) -> bool{\n        *self == other[..]\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq": [
            "#[inline]\nfn eq(&self, other: &str) -> bool{\n        self.inner == other.as_bytes()\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq>::eq": [
            "#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        self.inner == other.inner\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &&'a T) -> Option<cmp::Ordering>{\n        self.partial_cmp(*other)\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &[u8]) -> Option<cmp::Ordering>{\n        (*self.inner).partial_cmp(other)\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &String) -> Option<cmp::Ordering>{\n        self.inner.partial_cmp(other.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &str) -> Option<cmp::Ordering>{\n        (*self.inner).partial_cmp(other.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        Some(self.cmp(other))\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref": [
            "#[inline]\nfn as_ref(&self) -> &[u8]{\n        self.inner.as_ref()\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from": [
            "#[inline]\nfn from(t: &'a HeaderValue) -> Self{\n        t.clone()\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from": [
            "#[inline]\nfn from(h: HeaderName) -> HeaderValue{\n        HeaderValue {\n            inner: h.into_bytes(),\n            is_sensitive: false,\n        }\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::From<i16>>::from": [
            "fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::From<i32>>::from": [
            "fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::From<i64>>::from": [
            "fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::From<isize>>::from": [
            "fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::From<u16>>::from": [
            "fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::From<u32>>::from": [
            "fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::From<u64>>::from": [
            "fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::From<usize>>::from": [
            "fn from(num: $t) -> HeaderValue{\n                let mut buf = BytesMut::with_capacity($max_len);\n                let _ = buf.write_str(::itoa::Buffer::new().format(num));\n                HeaderValue {\n                    inner: buf.freeze(),\n                    is_sensitive: false,\n                }\n            }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        HeaderValue::from_bytes(t)\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<&'a std::string::String>>::try_from": [
            "#[inline]\nfn try_from(s: &'a String) -> Result<Self, Self::Error>{\n        Self::from_bytes(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<&'a str>>::try_from": [
            "#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        t.parse()\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<std::string::String>>::try_from": [
            "#[inline]\nfn try_from(t: String) -> Result<Self, Self::Error>{\n        HeaderValue::from_shared(t.into())\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "#[inline]\nfn try_from(vec: Vec<u8>) -> Result<Self, Self::Error>{\n        HeaderValue::from_shared(vec.into())\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        if self.is_sensitive {\n            f.write_str(\"Sensitive\")\n        } else {\n            f.write_str(\"\\\"\")?;\n            let mut from = 0;\n            let bytes = self.as_bytes();\n            for (i, &b) in bytes.iter().enumerate() {\n                if !is_visible_ascii(b) || b == b'\"' {\n                    if from != i {\n                        f.write_str(unsafe { str::from_utf8_unchecked(&bytes[from..i]) })?;\n                    }\n                    if b == b'\"' {\n                        f.write_str(\"\\\\\\\"\")?;\n                    } else {\n                        write!(f, \"\\\\x{:x}\", b)?;\n                    }\n                    from = i + 1;\n                }\n            }\n\n            f.write_str(unsafe { str::from_utf8_unchecked(&bytes[from..]) })?;\n            f.write_str(\"\\\"\")\n        }\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::hash::Hash>::hash": [
            "fn hash<H: Hasher>(&self, state: &mut H){\n        self.inner.hash(state);\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::HeaderValue as std::str::FromStr>::from_str": [
            "#[inline]\nfn from_str(s: &str) -> Result<HeaderValue, Self::Err>{\n        HeaderValue::from_str(s)\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"InvalidHeaderValue\")\n            // skip _priv noise\n            .finish()\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::InvalidHeaderValue as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"failed to parse header value\")\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<header::value::ToStrError as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"failed to convert header to a str\")\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "<method::InvalidMethod as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"InvalidMethod\")\n            // skip _priv noise\n            .finish()\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::InvalidMethod as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"invalid HTTP method\")\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq": [
            "#[inline]\nfn eq(&self, other: &&'a Method) -> bool{\n        self == *other\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::cmp::PartialEq<&'a str>>::eq": [
            "#[inline]\nfn eq(&self, other: &&'a str) -> bool{\n        self.as_ref() == *other\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::cmp::PartialEq<str>>::eq": [
            "#[inline]\nfn eq(&self, other: &str) -> bool{\n        self.as_ref() == other\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::convert::AsRef<str>>::as_ref": [
            "#[inline]\nfn as_ref(&self) -> &str{\n        self.as_str()\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::convert::From<&'a method::Method>>::from": [
            "#[inline]\nfn from(t: &'a Method) -> Self{\n        t.clone()\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        Method::from_bytes(t)\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::convert::TryFrom<&'a str>>::try_from": [
            "#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        TryFrom::try_from(t.as_bytes())\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::default::Default>::default": [
            "#[inline]\nfn default() -> Method{\n        Method::GET\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(self.as_ref())\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::fmt::Display>::fmt": [
            "fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt.write_str(self.as_ref())\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<method::Method as std::str::FromStr>::from_str": [
            "#[inline]\nfn from_str(t: &str) -> Result<Self, Self::Err>{\n        TryFrom::try_from(t)\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "<request::Builder as std::default::Default>::default": [
            "#[inline]\nfn default() -> Builder{\n        Builder {\n            inner: Ok(Parts::new()),\n        }\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "<request::Parts as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Parts\")\n            .field(\"method\", &self.method)\n            .field(\"uri\", &self.uri)\n            .field(\"version\", &self.version)\n            .field(\"headers\", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "<request::Request<T> as std::default::Default>::default": [
            "fn default() -> Request<T>{\n        Request::new(T::default())\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "<request::Request<T> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Request\")\n            .field(\"method\", self.method())\n            .field(\"uri\", self.uri())\n            .field(\"version\", &self.version())\n            .field(\"headers\", self.headers())\n            // omits Extensions because not useful\n            .field(\"body\", self.body())\n            .finish()\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "<response::Builder as std::default::Default>::default": [
            "#[inline]\nfn default() -> Builder{\n        Builder {\n            inner: Ok(Parts::new()),\n        }\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "<response::Parts as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Parts\")\n            .field(\"status\", &self.status)\n            .field(\"version\", &self.version)\n            .field(\"headers\", &self.headers)\n            // omits Extensions because not useful\n            // omits _priv because not useful\n            .finish()\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "<response::Response<T> as std::default::Default>::default": [
            "#[inline]\nfn default() -> Response<T>{\n        Response::new(T::default())\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "<response::Response<T> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Response\")\n            .field(\"status\", &self.status())\n            .field(\"version\", &self.version())\n            .field(\"headers\", self.headers())\n            // omits Extensions because not useful\n            .field(\"body\", self.body())\n            .finish()\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "<status::InvalidStatusCode as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.debug_struct(\"InvalidStatusCode\")\n            // skip _priv noise\n            .finish()\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<status::InvalidStatusCode as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"invalid status code\")\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<status::StatusCode as std::cmp::PartialEq<u16>>::eq": [
            "#[inline]\nfn eq(&self, other: &u16) -> bool{\n        self.as_u16() == *other\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from": [
            "#[inline]\nfn from(t: &'a StatusCode) -> Self{\n        t.to_owned()\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<status::StatusCode as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        StatusCode::from_bytes(t)\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<status::StatusCode as std::convert::TryFrom<&'a str>>::try_from": [
            "#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        t.parse()\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<status::StatusCode as std::convert::TryFrom<u16>>::try_from": [
            "#[inline]\nfn try_from(t: u16) -> Result<Self, Self::Error>{\n        StatusCode::from_u16(t)\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<status::StatusCode as std::default::Default>::default": [
            "#[inline]\nfn default() -> StatusCode{\n        StatusCode::OK\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<status::StatusCode as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Debug::fmt(&self.0, f)\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<status::StatusCode as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(\n            f,\n            \"{} {}\",\n            u16::from(*self),\n            self.canonical_reason().unwrap_or(\"<unknown status code>\")\n        )\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<status::StatusCode as std::str::FromStr>::from_str": [
            "fn from_str(s: &str) -> Result<StatusCode, InvalidStatusCode>{\n        StatusCode::from_bytes(s.as_ref())\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "<std::string::String as header::map::as_header_name::Sealed>::as_str": [
            "fn as_str(&self) -> &str{\n            self\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<std::string::String as header::map::as_header_name::Sealed>::find": [
            "#[inline]\nfn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>{\n            Sealed::find(&self.as_str(), map)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<std::string::String as header::map::as_header_name::Sealed>::try_entry": [
            "#[inline]\nfn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>{\n            self.as_str().try_entry(map)\n        }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from": [
            "fn from(src: ErrorKind) -> InvalidUri{\n        InvalidUri(src)\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::InvalidUri as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        self.s().fmt(f)\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from": [
            "fn from(src: ErrorKind) -> InvalidUriParts{\n        InvalidUriParts(src.into())\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::InvalidUriParts as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        self.0.fmt(f)\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Parts as std::convert::From<uri::Uri>>::from": [
            "fn from(src: Uri) -> Self{\n        let path_and_query = if src.has_path() {\n            Some(src.path_and_query)\n        } else {\n            None\n        };\n\n        let scheme = match src.scheme.inner {\n            Scheme2::None => None,\n            _ => Some(src.scheme),\n        };\n\n        let authority = if src.authority.data.is_empty() {\n            None\n        } else {\n            Some(src.authority)\n        };\n\n        Parts {\n            scheme,\n            authority,\n            path_and_query,\n            _priv: (),\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::cmp::PartialEq<&'a str>>::eq": [
            "fn eq(&self, other: &&'a str) -> bool{\n        self == *other\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::cmp::PartialEq<str>>::eq": [
            "fn eq(&self, other: &str) -> bool{\n        let mut other = other.as_bytes();\n        let mut absolute = false;\n\n        if let Some(scheme) = self.scheme() {\n            let scheme = scheme.as_str().as_bytes();\n            absolute = true;\n\n            if other.len() < scheme.len() + 3 {\n                return false;\n            }\n\n            if !scheme.eq_ignore_ascii_case(&other[..scheme.len()]) {\n                return false;\n            }\n\n            other = &other[scheme.len()..];\n\n            if &other[..3] != b\"://\" {\n                return false;\n            }\n\n            other = &other[3..];\n        }\n\n        if let Some(auth) = self.authority() {\n            let len = auth.data.len();\n            absolute = true;\n\n            if other.len() < len {\n                return false;\n            }\n\n            if !auth.data.as_bytes().eq_ignore_ascii_case(&other[..len]) {\n                return false;\n            }\n\n            other = &other[len..];\n        }\n\n        let path = self.path();\n\n        if other.len() < path.len() || path.as_bytes() != &other[..path.len()] {\n            if absolute && path == \"/\" {\n                // PathAndQuery can be omitted, fall through\n            } else {\n                return false;\n            }\n        } else {\n            other = &other[path.len()..];\n        }\n\n        if let Some(query) = self.query() {\n            if other.is_empty() {\n                return query.is_empty();\n            }\n\n            if other[0] != b'?' {\n                return false;\n            }\n\n            other = &other[1..];\n\n            if other.len() < query.len() {\n                return false;\n            }\n\n            if query.as_bytes() != &other[..query.len()] {\n                return false;\n            }\n\n            other = &other[query.len()..];\n        }\n\n        other.is_empty() || other[0] == b'#'\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::cmp::PartialEq>::eq": [
            "fn eq(&self, other: &Uri) -> bool{\n        if self.scheme() != other.scheme() {\n            return false;\n        }\n\n        if self.authority() != other.authority() {\n            return false;\n        }\n\n        if self.path() != other.path() {\n            return false;\n        }\n\n        if self.query() != other.query() {\n            return false;\n        }\n\n        true\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::convert::From<uri::authority::Authority>>::from": [
            "fn from(authority: Authority) -> Self{\n        Self {\n            scheme: Scheme::empty(),\n            authority,\n            path_and_query: PathAndQuery::empty(),\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::convert::From<uri::path::PathAndQuery>>::from": [
            "fn from(path_and_query: PathAndQuery) -> Self{\n        Self {\n            scheme: Scheme::empty(),\n            authority: Authority::empty(),\n            path_and_query,\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "#[inline]\nfn try_from(t: &'a [u8]) -> Result<Self, Self::Error>{\n        Uri::from_shared(Bytes::copy_from_slice(t))\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a std::string::String>>::try_from": [
            "#[inline]\nfn try_from(t: &'a String) -> Result<Self, Self::Error>{\n        t.parse()\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a str>>::try_from": [
            "#[inline]\nfn try_from(t: &'a str) -> Result<Self, Self::Error>{\n        t.parse()\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a uri::Uri>>::try_from": [
            "#[inline]\nfn try_from(src: &'a Uri) -> Result<Self, Self::Error>{\n        Ok(src.clone())\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::convert::TryFrom<std::string::String>>::try_from": [
            "#[inline]\nfn try_from(t: String) -> Result<Self, Self::Error>{\n        Uri::from_shared(Bytes::from(t))\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "#[inline]\nfn try_from(vec: Vec<u8>) -> Result<Self, Self::Error>{\n        Uri::from_shared(Bytes::from(vec))\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::convert::TryFrom<uri::Parts>>::try_from": [
            "#[inline]\nfn try_from(src: Parts) -> Result<Self, Self::Error>{\n        Uri::from_parts(src)\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::default::Default>::default": [
            "#[inline]\nfn default() -> Uri{\n        Uri {\n            scheme: Scheme::empty(),\n            authority: Authority::empty(),\n            path_and_query: PathAndQuery::slash(),\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self, f)\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        if let Some(scheme) = self.scheme() {\n            write!(f, \"{}://\", scheme)?;\n        }\n\n        if let Some(authority) = self.authority() {\n            write!(f, \"{}\", authority)?;\n        }\n\n        write!(f, \"{}\", self.path())?;\n\n        if let Some(query) = self.query() {\n            write!(f, \"?{}\", query)?;\n        }\n\n        Ok(())\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::hash::Hash>::hash": [
            "fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        if !self.scheme.inner.is_none() {\n            self.scheme.hash(state);\n            state.write_u8(0xff);\n        }\n\n        if let Some(auth) = self.authority() {\n            auth.hash(state);\n        }\n\n        Hash::hash_slice(self.path().as_bytes(), state);\n\n        if let Some(query) = self.query() {\n            b'?'.hash(state);\n            Hash::hash_slice(query.as_bytes(), state);\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::Uri as std::str::FromStr>::from_str": [
            "#[inline]\nfn from_str(s: &str) -> Result<Uri, InvalidUri>{\n        Uri::try_from(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq": [
            "fn eq(&self, other: &&'a str) -> bool{\n        self.data.eq_ignore_ascii_case(other)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq": [
            "fn eq(&self, other: &String) -> bool{\n        self.data.eq_ignore_ascii_case(other.as_str())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq<str>>::eq": [
            "fn eq(&self, other: &str) -> bool{\n        self.data.eq_ignore_ascii_case(other)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq>::eq": [
            "fn eq(&self, other: &Authority) -> bool{\n        self.data.eq_ignore_ascii_case(&other.data)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp": [
            "fn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp": [
            "fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp": [
            "fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp": [
            "fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::convert::AsRef<str>>::as_ref": [
            "fn as_ref(&self) -> &str{\n        self.as_str()\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        // parse first, and only turn into Bytes if valid\n\n        // Preconditon on create_authority: copy_from_slice() copies all of\n        // bytes from the [u8] parameter into a new Bytes\n        create_authority(s, Bytes::copy_from_slice)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<&'a str>>::try_from": [
            "#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        TryFrom::try_from(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<std::string::String>>::try_from": [
            "#[inline]\nfn try_from(t: String) -> Result<Self, Self::Error>{\n        Authority::from_shared(t.into())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "#[inline]\nfn try_from(vec: Vec<u8>) -> Result<Self, Self::Error>{\n        Authority::from_shared(vec.into())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(self.as_str())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(self.as_str())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::hash::Hash>::hash": [
            "fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        self.data.len().hash(state);\n        for &b in self.data.as_bytes() {\n            state.write_u8(b.to_ascii_lowercase());\n        }\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::authority::Authority as std::str::FromStr>::from_str": [
            "fn from_str(s: &str) -> Result<Self, InvalidUri>{\n        TryFrom::try_from(s)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "<uri::builder::Builder as std::convert::From<uri::Uri>>::from": [
            "fn from(uri: Uri) -> Self{\n        Self {\n            parts: Ok(uri.into_parts()),\n        }\n    }",
            "Real(LocalPath(\"src/uri/builder.rs\"))"
        ],
        "<uri::builder::Builder as std::default::Default>::default": [
            "#[inline]\nfn default() -> Builder{\n        Builder {\n            parts: Ok(Parts::default()),\n        }\n    }",
            "Real(LocalPath(\"src/uri/builder.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq": [
            "#[inline]\nfn eq(&self, other: &&'a str) -> bool{\n        self.as_str() == *other\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq": [
            "#[inline]\nfn eq(&self, other: &String) -> bool{\n        self.as_str() == other.as_str()\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq": [
            "#[inline]\nfn eq(&self, other: &str) -> bool{\n        self.as_str() == other\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq>::eq": [
            "#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self.data == other.data\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &&'a str) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(*other)\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &String) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other.as_str())\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &str) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other)\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other.as_str())\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        PathAndQuery::from_shared(Bytes::copy_from_slice(s))\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<&'a str>>::try_from": [
            "#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        TryFrom::try_from(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<&std::string::String>>::try_from": [
            "#[inline]\nfn try_from(s: &String) -> Result<Self, Self::Error>{\n        TryFrom::try_from(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<std::string::String>>::try_from": [
            "#[inline]\nfn try_from(s: String) -> Result<Self, Self::Error>{\n        PathAndQuery::from_shared(s.into())\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "#[inline]\nfn try_from(vec: Vec<u8>) -> Result<Self, Self::Error>{\n        PathAndQuery::from_shared(vec.into())\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self, f)\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::fmt::Display>::fmt": [
            "fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result{\n        if !self.data.is_empty() {\n            match self.data.as_bytes()[0] {\n                b'/' | b'*' => write!(fmt, \"{}\", &self.data[..]),\n                _ => write!(fmt, \"/{}\", &self.data[..]),\n            }\n        } else {\n            write!(fmt, \"/\")\n        }\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::hash::Hash>::hash": [
            "fn hash<H: hash::Hasher>(&self, state: &mut H){\n        self.data.hash(state);\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::path::PathAndQuery as std::str::FromStr>::from_str": [
            "#[inline]\nfn from_str(s: &str) -> Result<Self, InvalidUri>{\n        TryFrom::try_from(s)\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq": [
            "fn eq(&self, other: &u16) -> bool{\n        self.port == *other\n    }",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq": [
            "fn eq(&self, other: &Port<U>) -> bool{\n        self.port == other.port\n    }",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref": [
            "fn as_ref(&self) -> &str{\n        self.as_str()\n    }",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "<uri::port::Port<T> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"Port\").field(&self.port).finish()\n    }",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "<uri::port::Port<T> as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        // Use `u16::fmt` so that it respects any formatting flags that\n        // may have been set (like padding, align, etc).\n        fmt::Display::fmt(&self.port, f)\n    }",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq": [
            "fn eq(&self, other: &str) -> bool{\n        self.as_str().eq_ignore_ascii_case(other)\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<uri::scheme::Scheme as std::cmp::PartialEq>::eq": [
            "fn eq(&self, other: &Scheme) -> bool{\n        use self::Protocol::*;\n        use self::Scheme2::*;\n\n        match (&self.inner, &other.inner) {\n            (&Standard(Http), &Standard(Http)) => true,\n            (&Standard(Https), &Standard(Https)) => true,\n            (Other(a), Other(b)) => a.eq_ignore_ascii_case(b),\n            (&None, _) | (_, &None) => unreachable!(),\n            _ => false,\n        }\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref": [
            "#[inline]\nfn as_ref(&self) -> &str{\n        self.as_str()\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from": [
            "fn from(src: Scheme2) -> Self{\n        Scheme { inner: src }\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<uri::scheme::Scheme as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "#[inline]\nfn try_from(s: &'a [u8]) -> Result<Self, Self::Error>{\n        use self::Scheme2::*;\n\n        match Scheme2::parse_exact(s)? {\n            None => Err(ErrorKind::InvalidScheme.into()),\n            Standard(p) => Ok(Standard(p).into()),\n            Other(_) => {\n                let bytes = Bytes::copy_from_slice(s);\n\n                // Safety: postcondition on parse_exact() means that s and\n                // hence bytes are valid UTF-8.\n                let string = unsafe { ByteStr::from_utf8_unchecked(bytes) };\n\n                Ok(Other(Box::new(string)).into())\n            }\n        }\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<uri::scheme::Scheme as std::convert::TryFrom<&'a str>>::try_from": [
            "#[inline]\nfn try_from(s: &'a str) -> Result<Self, Self::Error>{\n        TryFrom::try_from(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<uri::scheme::Scheme as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Debug::fmt(self.as_str(), f)\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<uri::scheme::Scheme as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(self.as_str())\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<uri::scheme::Scheme as std::hash::Hash>::hash": [
            "fn hash<H>(&self, state: &mut H)\n    where\n        H: Hasher,{\n        match self.inner {\n            Scheme2::None => (),\n            Scheme2::Standard(Protocol::Http) => state.write_u8(1),\n            Scheme2::Standard(Protocol::Https) => state.write_u8(2),\n            Scheme2::Other(ref other) => {\n                other.len().hash(state);\n                for &b in other.as_bytes() {\n                    state.write_u8(b.to_ascii_lowercase());\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<uri::scheme::Scheme as std::str::FromStr>::from_str": [
            "fn from_str(s: &str) -> Result<Self, Self::Err>{\n        TryFrom::try_from(s)\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from": [
            "fn from(src: Protocol) -> Self{\n        Scheme2::Standard(src)\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "<version::Version as std::default::Default>::default": [
            "#[inline]\nfn default() -> Version{\n        Version::HTTP_11\n    }",
            "Real(LocalPath(\"src/version.rs\"))"
        ],
        "<version::Version as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        use self::Http::*;\n\n        f.write_str(match self.0 {\n            Http09 => \"HTTP/0.9\",\n            Http10 => \"HTTP/1.0\",\n            Http11 => \"HTTP/1.1\",\n            H2 => \"HTTP/2.0\",\n            H3 => \"HTTP/3.0\",\n            __NonExhaustive => unreachable!(),\n        })\n    }",
            "Real(LocalPath(\"src/version.rs\"))"
        ],
        "byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from": [
            "fn from(src: ByteStr) -> Self{\n        src.bytes\n    }",
            "Real(LocalPath(\"src/byte_str.rs\"))"
        ],
        "byte_str::ByteStr": [
            "pub(crate) struct ByteStr {\n    // Invariant: bytes contains valid UTF-8\n    bytes: Bytes,\n}",
            "Real(LocalPath(\"src/byte_str.rs\"))"
        ],
        "byte_str::ByteStr::from_static": [
            "#[inline]\npub const fn from_static(val: &'static str) -> ByteStr{\n        ByteStr {\n            // Invariant: val is a str so contains valid UTF-8.\n            bytes: Bytes::from_static(val.as_bytes()),\n        }\n    }",
            "Real(LocalPath(\"src/byte_str.rs\"))"
        ],
        "byte_str::ByteStr::from_utf8": [
            "pub(crate) fn from_utf8(bytes: Bytes) -> Result<ByteStr, std::str::Utf8Error>{\n        str::from_utf8(&bytes)?;\n        // Invariant: just checked is utf8\n        Ok(ByteStr { bytes })\n    }",
            "Real(LocalPath(\"src/byte_str.rs\"))"
        ],
        "byte_str::ByteStr::from_utf8_unchecked": [
            "#[inline]\n/// ## Panics\n/// In a debug build this will panic if `bytes` is not valid UTF-8.\n///\n/// ## Safety\n/// `bytes` must contain valid UTF-8. In a release build it is undefined\n/// behavior to call this with `bytes` that is not valid UTF-8.\npub unsafe fn from_utf8_unchecked(bytes: Bytes) -> ByteStr{\n        if cfg!(debug_assertions) {\n            match str::from_utf8(&bytes) {\n                Ok(_) => (),\n                Err(err) => panic!(\n                    \"ByteStr::from_utf8_unchecked() with invalid bytes; error = {}, bytes = {:?}\",\n                    err, bytes\n                ),\n            }\n        }\n        // Invariant: assumed by the safety requirements of this function.\n        ByteStr { bytes }\n    }",
            "Real(LocalPath(\"src/byte_str.rs\"))"
        ],
        "byte_str::ByteStr::new": [
            "#[inline]\npub fn new() -> ByteStr{\n        ByteStr {\n            // Invariant: the empty slice is trivially valid UTF-8.\n            bytes: Bytes::new(),\n        }\n    }",
            "Real(LocalPath(\"src/byte_str.rs\"))"
        ],
        "error::Error": [
            "/// A generic \"error\" for HTTP connections\n///\n/// This error type is less specific than the error returned from other\n/// functions in this crate, but all other errors can be converted to this\n/// error. Consumers of this crate can typically consume and work with this form\n/// of error for conversions with the `?` operator.\npub struct Error {\n    inner: ErrorKind,\n}",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::get_ref": [
            "/// Return a reference to the lower level, inner error.\npub fn get_ref(&self) -> &(dyn error::Error + 'static){\n        use self::ErrorKind::*;\n\n        match self.inner {\n            StatusCode(ref e) => e,\n            Method(ref e) => e,\n            Uri(ref e) => e,\n            UriParts(ref e) => e,\n            HeaderName(ref e) => e,\n            HeaderValue(ref e) => e,\n            MaxSizeReached(ref e) => e,\n        }\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::Error::is": [
            "/// Return true if the underlying error has the same type as T.\npub fn is<T: error::Error + 'static>(&self) -> bool{\n        self.get_ref().is::<T>()\n    }",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "error::ErrorKind": [
            "enum ErrorKind {\n    StatusCode(status::InvalidStatusCode),\n    Method(method::InvalidMethod),\n    Uri(uri::InvalidUri),\n    UriParts(uri::InvalidUriParts),\n    HeaderName(header::InvalidHeaderName),\n    HeaderValue(header::InvalidHeaderValue),\n    MaxSizeReached(MaxSizeReached),\n}",
            "Real(LocalPath(\"src/error.rs\"))"
        ],
        "extensions::<impl std::clone::Clone for std::boxed::Box<(dyn extensions::AnyClone + std::marker::Send + std::marker::Sync + 'static)>>::clone": [
            "fn clone(&self) -> Self{\n        (**self).clone_box()\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::AnyClone": [
            "trait AnyClone: Any {\n    fn clone_box(&self) -> Box<dyn AnyClone + Send + Sync>;\n    fn as_any(&self) -> &dyn Any;\n    fn as_any_mut(&mut self) -> &mut dyn Any;\n    fn into_any(self: Box<Self>) -> Box<dyn Any>;\n}",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions": [
            "/// A type map of protocol extensions.\n///\n/// `Extensions` can be used by `Request` and `Response` to store\n/// extra data derived from the underlying protocol.\npub struct Extensions {\n    // If extensions are never used, no need to carry around an empty HashMap.\n    // That's 3 words. Instead, this is only 1 word.\n    map: Option<Box<AnyMap>>,\n}",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::clear": [
            "/// Clear the `Extensions` of all inserted extensions.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// ext.insert(5i32);\n/// ext.clear();\n///\n/// assert!(ext.get::<i32>().is_none());\n/// ```\n#[inline]\npub fn clear(&mut self){\n        if let Some(ref mut map) = self.map {\n            map.clear();\n        }\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::extend": [
            "/// Extends `self` with another `Extensions`.\n///\n/// If an instance of a specific type exists in both, the one in `self` is overwritten with the\n/// one from `other`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext_a = Extensions::new();\n/// ext_a.insert(8u8);\n/// ext_a.insert(16u16);\n///\n/// let mut ext_b = Extensions::new();\n/// ext_b.insert(4u8);\n/// ext_b.insert(\"hello\");\n///\n/// ext_a.extend(ext_b);\n/// assert_eq!(ext_a.len(), 3);\n/// assert_eq!(ext_a.get::<u8>(), Some(&4u8));\n/// assert_eq!(ext_a.get::<u16>(), Some(&16u16));\n/// assert_eq!(ext_a.get::<&'static str>().copied(), Some(\"hello\"));\n/// ```\npub fn extend(&mut self, other: Self){\n        if let Some(other) = other.map {\n            if let Some(map) = &mut self.map {\n                map.extend(*other);\n            } else {\n                self.map = Some(other);\n            }\n        }\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::get": [
            "/// Get a reference to a type previously inserted on this `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// assert!(ext.get::<i32>().is_none());\n/// ext.insert(5i32);\n///\n/// assert_eq!(ext.get::<i32>(), Some(&5i32));\n/// ```\npub fn get<T: Send + Sync + 'static>(&self) -> Option<&T>{\n        self.map\n            .as_ref()\n            .and_then(|map| map.get(&TypeId::of::<T>()))\n            .and_then(|boxed| (**boxed).as_any().downcast_ref())\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::get_mut": [
            "/// Get a mutable reference to a type previously inserted on this `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// ext.insert(String::from(\"Hello\"));\n/// ext.get_mut::<String>().unwrap().push_str(\" World\");\n///\n/// assert_eq!(ext.get::<String>().unwrap(), \"Hello World\");\n/// ```\npub fn get_mut<T: Send + Sync + 'static>(&mut self) -> Option<&mut T>{\n        self.map\n            .as_mut()\n            .and_then(|map| map.get_mut(&TypeId::of::<T>()))\n            .and_then(|boxed| (**boxed).as_any_mut().downcast_mut())\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::get_or_insert": [
            "/// Get a mutable reference to a type, inserting `value` if not already present on this\n/// `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// *ext.get_or_insert(1i32) += 2;\n///\n/// assert_eq!(*ext.get::<i32>().unwrap(), 3);\n/// ```\npub fn get_or_insert<T: Clone + Send + Sync + 'static>(&mut self, value: T) -> &mut T{\n        self.get_or_insert_with(|| value)\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::get_or_insert_default": [
            "/// Get a mutable reference to a type, inserting the type's default value if not already present\n/// on this `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// *ext.get_or_insert_default::<i32>() += 2;\n///\n/// assert_eq!(*ext.get::<i32>().unwrap(), 2);\n/// ```\npub fn get_or_insert_default<T: Default + Clone + Send + Sync + 'static>(&mut self) -> &mut T{\n        self.get_or_insert_with(T::default)\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::get_or_insert_with": [
            "/// Get a mutable reference to a type, inserting the value created by `f` if not already present\n/// on this `Extensions`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// *ext.get_or_insert_with(|| 1i32) += 2;\n///\n/// assert_eq!(*ext.get::<i32>().unwrap(), 3);\n/// ```\npub fn get_or_insert_with<T: Clone + Send + Sync + 'static, F: FnOnce() -> T>(\n        &mut self,\n        f: F,\n    ) -> &mut T{\n        let out = self\n            .map\n            .get_or_insert_with(Box::default)\n            .entry(TypeId::of::<T>())\n            .or_insert_with(|| Box::new(f()));\n        (**out).as_any_mut().downcast_mut().unwrap()\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::insert": [
            "/// Insert a type into this `Extensions`.\n///\n/// If a extension of this type already existed, it will\n/// be returned and replaced with the new one.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// assert!(ext.insert(5i32).is_none());\n/// assert!(ext.insert(4u8).is_none());\n/// assert_eq!(ext.insert(9i32), Some(5i32));\n/// ```\npub fn insert<T: Clone + Send + Sync + 'static>(&mut self, val: T) -> Option<T>{\n        self.map\n            .get_or_insert_with(Box::default)\n            .insert(TypeId::of::<T>(), Box::new(val))\n            .and_then(|boxed| boxed.into_any().downcast().ok().map(|boxed| *boxed))\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::is_empty": [
            "/// Check whether the extension set is empty or not.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// assert!(ext.is_empty());\n/// ext.insert(5i32);\n/// assert!(!ext.is_empty());\n/// ```\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.map.as_ref().map_or(true, |map| map.is_empty())\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::len": [
            "/// Get the number of extensions available.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// assert_eq!(ext.len(), 0);\n/// ext.insert(5i32);\n/// assert_eq!(ext.len(), 1);\n/// ```\n#[inline]\npub fn len(&self) -> usize{\n        self.map.as_ref().map_or(0, |map| map.len())\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::new": [
            "/// Create an empty `Extensions`.\n#[inline]\npub fn new() -> Extensions{\n        Extensions { map: None }\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::Extensions::remove": [
            "/// Remove a type from this `Extensions`.\n///\n/// If a extension of this type existed, it will be returned.\n///\n/// # Example\n///\n/// ```\n/// # use http::Extensions;\n/// let mut ext = Extensions::new();\n/// ext.insert(5i32);\n/// assert_eq!(ext.remove::<i32>(), Some(5i32));\n/// assert!(ext.get::<i32>().is_none());\n/// ```\npub fn remove<T: Send + Sync + 'static>(&mut self) -> Option<T>{\n        self.map\n            .as_mut()\n            .and_then(|map| map.remove(&TypeId::of::<T>()))\n            .and_then(|boxed| boxed.into_any().downcast().ok().map(|boxed| *boxed))\n    }",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "extensions::IdHasher": [
            "struct IdHasher(u64);",
            "Real(LocalPath(\"src/extensions.rs\"))"
        ],
        "header::map::Bucket": [
            "/// Stores the data associated with a `HeaderMap` entry. Only the first value is\n/// included in this struct. If a header name has more than one associated\n/// value, all extra values are stored in the `extra_values` vector. A doubly\n/// linked list of entries is maintained. The doubly linked list is used so that\n/// removing a value is constant time. This also has the nice property of\n/// enabling double ended iteration.\nstruct Bucket<T> {\n    hash: HashValue,\n    key: HeaderName,\n    value: T,\n    links: Option<Links>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Cursor": [
            "/// Tracks the value iterator state\nenum Cursor {\n    Head,\n    Values(usize),\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Danger": [
            "/// Tracks the header map danger level! This relates to the adaptive hashing\n/// algorithm. A HeaderMap starts in the \"green\" state, when a large number of\n/// collisions are detected, it transitions to the yellow state. At this point,\n/// the header map will either grow and switch back to the green state OR it\n/// will transition to the red state.\n///\n/// When in the red state, a safe hashing algorithm is used and all values in\n/// the header map have to be rehashed.\nenum Danger {\n    Green,\n    Yellow,\n    Red(RandomState),\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Danger::is_red": [
            "fn is_red(&self) -> bool{\n        matches!(*self, Danger::Red(_))\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Danger::is_yellow": [
            "fn is_yellow(&self) -> bool{\n        matches!(*self, Danger::Yellow)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Danger::set_green": [
            "fn set_green(&mut self){\n        debug_assert!(self.is_yellow());\n        *self = Danger::Green;\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Danger::set_red": [
            "fn set_red(&mut self){\n        debug_assert!(self.is_yellow());\n        *self = Danger::Red(RandomState::new());\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Danger::set_yellow": [
            "fn set_yellow(&mut self){\n        if let Danger::Green = *self {\n            *self = Danger::Yellow;\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Drain": [
            "/// A drain iterator for `HeaderMap`.\npub struct Drain<'a, T> {\n    idx: usize,\n    len: usize,\n    entries: *mut [Bucket<T>],\n    // If None, pull from `entries`\n    next: Option<usize>,\n    extra_values: *mut Vec<ExtraValue<T>>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Entry": [
            "/// A view into a single location in a `HeaderMap`, which may be vacant or occupied.\npub enum Entry<'a, T: 'a> {\n    /// An occupied entry\n    Occupied(OccupiedEntry<'a, T>),\n\n    /// A vacant entry\n    Vacant(VacantEntry<'a, T>),\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Entry::<'a, T>::key": [
            "/// Returns a reference to the entry's key\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(map.entry(\"x-hello\").key(), \"x-hello\");\n/// ```\npub fn key(&self) -> &HeaderName{\n        use self::Entry::*;\n\n        match *self {\n            Vacant(ref e) => e.key(),\n            Occupied(ref e) => e.key(),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Entry::<'a, T>::or_insert": [
            "/// Ensures a value is in the entry by inserting the default if empty.\n///\n/// Returns a mutable reference to the **first** value in the entry.\n///\n/// # Panics\n///\n/// This method panics if capacity exceeds max `HeaderMap` capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map: HeaderMap<u32> = HeaderMap::default();\n///\n/// let headers = &[\n///     \"content-length\",\n///     \"x-hello\",\n///     \"Content-Length\",\n///     \"x-world\",\n/// ];\n///\n/// for &header in headers {\n///     let counter = map.entry(header)\n///         .or_insert(0);\n///     *counter += 1;\n/// }\n///\n/// assert_eq!(map[\"content-length\"], 2);\n/// assert_eq!(map[\"x-hello\"], 1);\n/// ```\npub fn or_insert(self, default: T) -> &'a mut T{\n        self.or_try_insert(default)\n            .expect(\"size overflows MAX_SIZE\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Entry::<'a, T>::or_insert_with": [
            "/// Ensures a value is in the entry by inserting the result of the default\n/// function if empty.\n///\n/// The default function is not called if the entry exists in the map.\n/// Returns a mutable reference to the **first** value in the entry.\n///\n/// # Examples\n///\n/// Basic usage.\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// let res = map.entry(\"x-hello\")\n///     .or_insert_with(|| \"world\".parse().unwrap());\n///\n/// assert_eq!(res, \"world\");\n/// ```\n///\n/// The default function is not called if the entry exists in the map.\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.try_insert(HOST, \"world\".parse().unwrap()).unwrap();\n///\n/// let res = map.try_entry(\"host\")\n///     .unwrap()\n///     .or_try_insert_with(|| unreachable!())\n///     .unwrap();\n///\n///\n/// assert_eq!(res, \"world\");\n/// ```\npub fn or_insert_with<F: FnOnce() -> T>(self, default: F) -> &'a mut T{\n        self.or_try_insert_with(default)\n            .expect(\"size overflows MAX_SIZE\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Entry::<'a, T>::or_try_insert": [
            "/// Ensures a value is in the entry by inserting the default if empty.\n///\n/// Returns a mutable reference to the **first** value in the entry.\n///\n/// # Errors\n///\n/// This function may return an error if `HeaderMap` exceeds max capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map: HeaderMap<u32> = HeaderMap::default();\n///\n/// let headers = &[\n///     \"content-length\",\n///     \"x-hello\",\n///     \"Content-Length\",\n///     \"x-world\",\n/// ];\n///\n/// for &header in headers {\n///     let counter = map.entry(header)\n///         .or_try_insert(0)\n///         .unwrap();\n///     *counter += 1;\n/// }\n///\n/// assert_eq!(map[\"content-length\"], 2);\n/// assert_eq!(map[\"x-hello\"], 1);\n/// ```\npub fn or_try_insert(self, default: T) -> Result<&'a mut T, MaxSizeReached>{\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => Ok(e.into_mut()),\n            Vacant(e) => e.try_insert(default),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Entry::<'a, T>::or_try_insert_with": [
            "/// Ensures a value is in the entry by inserting the result of the default\n/// function if empty.\n///\n/// The default function is not called if the entry exists in the map.\n/// Returns a mutable reference to the **first** value in the entry.\n///\n/// # Examples\n///\n/// Basic usage.\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// let res = map.entry(\"x-hello\")\n///     .or_insert_with(|| \"world\".parse().unwrap());\n///\n/// assert_eq!(res, \"world\");\n/// ```\n///\n/// The default function is not called if the entry exists in the map.\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.try_insert(HOST, \"world\".parse().unwrap()).unwrap();\n///\n/// let res = map.try_entry(\"host\")\n///     .unwrap()\n///     .or_try_insert_with(|| unreachable!())\n///     .unwrap();\n///\n///\n/// assert_eq!(res, \"world\");\n/// ```\npub fn or_try_insert_with<F: FnOnce() -> T>(\n        self,\n        default: F,\n    ) -> Result<&'a mut T, MaxSizeReached>{\n        use self::Entry::*;\n\n        match self {\n            Occupied(e) => Ok(e.into_mut()),\n            Vacant(e) => e.try_insert(default()),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::ExtraValue": [
            "/// Node in doubly-linked list of header value entries\nstruct ExtraValue<T> {\n    value: T,\n    prev: Link,\n    next: Link,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::GetAll": [
            "/// A view to all values stored in a single entry.\n///\n/// This struct is returned by `HeaderMap::get_all`.\npub struct GetAll<'a, T> {\n    map: &'a HeaderMap<T>,\n    index: Option<usize>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::GetAll::<'a, T>::iter": [
            "/// Returns an iterator visiting all values associated with the entry.\n///\n/// Values are iterated in insertion order.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n/// map.append(HOST, \"hello.earth\".parse().unwrap());\n///\n/// let values = map.get_all(\"host\");\n/// let mut iter = values.iter();\n/// assert_eq!(&\"hello.world\", iter.next().unwrap());\n/// assert_eq!(&\"hello.earth\", iter.next().unwrap());\n/// assert!(iter.next().is_none());\n/// ```\npub fn iter(&self) -> ValueIter<'a, T>{\n        // This creates a new GetAll struct so that the lifetime\n        // isn't bound to &self.\n        GetAll {\n            map: self.map,\n            index: self.index,\n        }\n        .into_iter()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HashValue": [
            "/// Hash values are limited to u16 as well. While `fast_hash` and `Hasher`\n/// return `usize` hash codes, limiting the effective hash code to the lower 16\n/// bits is fine since we know that the `indices` vector will never grow beyond\n/// that size.\nstruct HashValue(u16);",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap": [
            "/// A set of HTTP headers\n///\n/// `HeaderMap` is a multimap of [`HeaderName`] to values.\n///\n/// [`HeaderName`]: struct.HeaderName.html\n///\n/// # Examples\n///\n/// Basic usage\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST, LOCATION};\n/// let mut headers = HeaderMap::new();\n///\n/// headers.insert(HOST, \"example.com\".parse().unwrap());\n/// headers.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n///\n/// assert!(headers.contains_key(HOST));\n/// assert!(!headers.contains_key(LOCATION));\n///\n/// assert_eq!(headers[HOST], \"example.com\");\n///\n/// headers.remove(HOST);\n///\n/// assert!(!headers.contains_key(HOST));\n/// ```\npub struct HeaderMap<T = HeaderValue> {\n    // Used to mask values to get an index\n    mask: Size,\n    indices: Box<[Pos]>,\n    entries: Vec<Bucket<T>>,\n    extra_values: Vec<ExtraValue<T>>,\n    danger: Danger,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::append": [
            "/// Inserts a key-value pair into the map.\n///\n/// If the map did not previously have this key present, then `false` is\n/// returned.\n///\n/// If the map did have this key present, the new value is pushed to the end\n/// of the list of values currently associated with the key. The key is not\n/// updated, though; this matters for types that can be `==` without being\n/// identical.\n///\n/// # Panics\n///\n/// This method panics if capacity exceeds max `HeaderMap` capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.insert(HOST, \"world\".parse().unwrap()).is_none());\n/// assert!(!map.is_empty());\n///\n/// map.append(HOST, \"earth\".parse().unwrap());\n///\n/// let values = map.get_all(\"host\");\n/// let mut i = values.iter();\n/// assert_eq!(\"world\", *i.next().unwrap());\n/// assert_eq!(\"earth\", *i.next().unwrap());\n/// ```\npub fn append<K>(&mut self, key: K, value: T) -> bool\n    where\n        K: IntoHeaderName,{\n        self.try_append(key, value)\n            .expect(\"size overflows MAX_SIZE\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::capacity": [
            "/// Returns the number of headers the map can hold without reallocating.\n///\n/// This number is an approximation as certain usage patterns could cause\n/// additional allocations before the returned capacity is filled.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(0, map.capacity());\n///\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n/// assert_eq!(6, map.capacity());\n/// ```\npub fn capacity(&self) -> usize{\n        usable_capacity(self.indices.len())\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::clear": [
            "/// Clears the map, removing all key-value pairs. Keeps the allocated memory\n/// for reuse.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// map.clear();\n/// assert!(map.is_empty());\n/// assert!(map.capacity() > 0);\n/// ```\npub fn clear(&mut self){\n        self.entries.clear();\n        self.extra_values.clear();\n        self.danger = Danger::Green;\n\n        for e in self.indices.iter_mut() {\n            *e = Pos::none();\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::contains_key": [
            "/// Returns true if the map contains a value for the specified key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(!map.contains_key(HOST));\n///\n/// map.insert(HOST, \"world\".parse().unwrap());\n/// assert!(map.contains_key(\"host\"));\n/// ```\npub fn contains_key<K>(&self, key: K) -> bool\n    where\n        K: AsHeaderName,{\n        key.find(self).is_some()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::drain": [
            "/// Clears the map, returning all entries as an iterator.\n///\n/// The internal memory is kept for reuse.\n///\n/// For each yielded item that has `None` provided for the `HeaderName`,\n/// then the associated header name is the same as that of the previously\n/// yielded item. The first yielded item will have `HeaderName` set.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// map.append(HOST, \"goodbye\".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n///\n/// let mut drain = map.drain();\n///\n///\n/// assert_eq!(drain.next(), Some((Some(HOST), \"hello\".parse().unwrap())));\n/// assert_eq!(drain.next(), Some((None, \"goodbye\".parse().unwrap())));\n///\n/// assert_eq!(drain.next(), Some((Some(CONTENT_LENGTH), \"123\".parse().unwrap())));\n///\n/// assert_eq!(drain.next(), None);\n/// ```\npub fn drain(&mut self) -> Drain<'_, T>{\n        for i in self.indices.iter_mut() {\n            *i = Pos::none();\n        }\n\n        // Memory safety\n        //\n        // When the Drain is first created, it shortens the length of\n        // the source vector to make sure no uninitialized or moved-from\n        // elements are accessible at all if the Drain's destructor never\n        // gets to run.\n\n        let entries = &mut self.entries[..] as *mut _;\n        let extra_values = &mut self.extra_values as *mut _;\n        let len = self.entries.len();\n        unsafe {\n            self.entries.set_len(0);\n        }\n\n        Drain {\n            idx: 0,\n            len,\n            entries,\n            extra_values,\n            next: None,\n            lt: PhantomData,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::entry": [
            "/// Gets the given key's corresponding entry in the map for in-place\n/// manipulation.\n///\n/// # Panics\n///\n/// This method panics if capacity exceeds max `HeaderMap` capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map: HeaderMap<u32> = HeaderMap::default();\n///\n/// let headers = &[\n///     \"content-length\",\n///     \"x-hello\",\n///     \"Content-Length\",\n///     \"x-world\",\n/// ];\n///\n/// for &header in headers {\n///     let counter = map.entry(header).or_insert(0);\n///     *counter += 1;\n/// }\n///\n/// assert_eq!(map[\"content-length\"], 2);\n/// assert_eq!(map[\"x-hello\"], 1);\n/// ```\npub fn entry<K>(&mut self, key: K) -> Entry<'_, T>\n    where\n        K: IntoHeaderName,{\n        key.try_entry(self).expect(\"size overflows MAX_SIZE\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::find": [
            "#[inline]\nfn find<K>(&self, key: &K) -> Option<(usize, usize)>\n    where\n        K: Hash + Into<HeaderName> + ?Sized,\n        HeaderName: PartialEq<K>,{\n        if self.entries.is_empty() {\n            return None;\n        }\n\n        let hash = hash_elem_using(&self.danger, key);\n        let mask = self.mask;\n        let mut probe = desired_pos(mask, hash);\n        let mut dist = 0;\n\n        probe_loop!(probe < self.indices.len(), {\n            if let Some((i, entry_hash)) = self.indices[probe].resolve() {\n                if dist > probe_distance(mask, entry_hash, probe) {\n                    // give up when probe distance is too long\n                    return None;\n                } else if entry_hash == hash && self.entries[i].key == *key {\n                    return Some((probe, i));\n                }\n            } else {\n                return None;\n            }\n\n            dist += 1;\n        });\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::get": [
            "/// Returns a reference to the value associated with the key.\n///\n/// If there are multiple values associated with the key, then the first one\n/// is returned. Use `get_all` to get all values associated with a given\n/// key. Returns `None` if there are no values associated with the key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.get(\"host\").is_none());\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// assert_eq!(map.get(HOST).unwrap(), &\"hello\");\n/// assert_eq!(map.get(\"host\").unwrap(), &\"hello\");\n///\n/// map.append(HOST, \"world\".parse().unwrap());\n/// assert_eq!(map.get(\"host\").unwrap(), &\"hello\");\n/// ```\npub fn get<K>(&self, key: K) -> Option<&T>\n    where\n        K: AsHeaderName,{\n        self.get2(&key)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::get2": [
            "fn get2<K>(&self, key: &K) -> Option<&T>\n    where\n        K: AsHeaderName,{\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &self.entries[found];\n                Some(&entry.value)\n            }\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::get_all": [
            "/// Returns a view of all values associated with a key.\n///\n/// The returned view does not incur any allocations and allows iterating\n/// the values associated with the key.  See [`GetAll`] for more details.\n/// Returns `None` if there are no values associated with the key.\n///\n/// [`GetAll`]: struct.GetAll.html\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// map.append(HOST, \"goodbye\".parse().unwrap());\n///\n/// let view = map.get_all(\"host\");\n///\n/// let mut iter = view.iter();\n/// assert_eq!(&\"hello\", iter.next().unwrap());\n/// assert_eq!(&\"goodbye\", iter.next().unwrap());\n/// assert!(iter.next().is_none());\n/// ```\npub fn get_all<K>(&self, key: K) -> GetAll<'_, T>\n    where\n        K: AsHeaderName,{\n        GetAll {\n            map: self,\n            index: key.find(self).map(|(_, i)| i),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::get_mut": [
            "/// Returns a mutable reference to the value associated with the key.\n///\n/// If there are multiple values associated with the key, then the first one\n/// is returned. Use `entry` to get all values associated with a given\n/// key. Returns `None` if there are no values associated with the key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, \"hello\".to_string());\n/// map.get_mut(\"host\").unwrap().push_str(\"-world\");\n///\n/// assert_eq!(map.get(HOST).unwrap(), &\"hello-world\");\n/// ```\npub fn get_mut<K>(&mut self, key: K) -> Option<&mut T>\n    where\n        K: AsHeaderName,{\n        match key.find(self) {\n            Some((_, found)) => {\n                let entry = &mut self.entries[found];\n                Some(&mut entry.value)\n            }\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::insert": [
            "/// Inserts a key-value pair into the map.\n///\n/// If the map did not previously have this key present, then `None` is\n/// returned.\n///\n/// If the map did have this key present, the new value is associated with\n/// the key and all previous values are removed. **Note** that only a single\n/// one of the previous values is returned. If there are multiple values\n/// that have been previously associated with the key, then the first one is\n/// returned. See `insert_mult` on `OccupiedEntry` for an API that returns\n/// all values.\n///\n/// The key is not updated, though; this matters for types that can be `==`\n/// without being identical.\n///\n/// # Panics\n///\n/// This method panics if capacity exceeds max `HeaderMap` capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.insert(HOST, \"world\".parse().unwrap()).is_none());\n/// assert!(!map.is_empty());\n///\n/// let mut prev = map.insert(HOST, \"earth\".parse().unwrap()).unwrap();\n/// assert_eq!(\"world\", prev);\n/// ```\npub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n    where\n        K: IntoHeaderName,{\n        self.try_insert(key, val).expect(\"size overflows MAX_SIZE\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::insert_occupied": [
            "/// Set an occupied bucket to the given value\n#[inline]\nfn insert_occupied(&mut self, index: usize, value: T) -> T{\n        if let Some(links) = self.entries[index].links {\n            self.remove_all_extra_values(links.next);\n        }\n\n        let entry = &mut self.entries[index];\n        mem::replace(&mut entry.value, value)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::insert_occupied_mult": [
            "fn insert_occupied_mult(&mut self, index: usize, value: T) -> ValueDrain<'_, T>{\n        let old;\n        let links;\n\n        {\n            let entry = &mut self.entries[index];\n\n            old = mem::replace(&mut entry.value, value);\n            links = entry.links.take();\n        }\n\n        let raw_links = self.raw_links();\n        let extra_values = &mut self.extra_values;\n\n        let next =\n            links.map(|l| drain_all_extra_values(raw_links, extra_values, l.next).into_iter());\n\n        ValueDrain {\n            first: Some(old),\n            next,\n            lt: PhantomData,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::is_empty": [
            "/// Returns true if the map contains no elements.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n///\n/// assert!(map.is_empty());\n///\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// assert!(!map.is_empty());\n/// ```\npub fn is_empty(&self) -> bool{\n        self.entries.len() == 0\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::iter": [
            "/// An iterator visiting all key-value pairs.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version. Each key will be yielded once per associated\n/// value. So, if a key has 3 associated values, it will be yielded 3 times.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// map.append(HOST, \"goodbye\".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n///\n/// for (key, value) in map.iter() {\n///     println!(\"{:?}: {:?}\", key, value);\n/// }\n/// ```\npub fn iter(&self) -> Iter<'_, T>{\n        Iter {\n            map: self,\n            entry: 0,\n            cursor: self.entries.first().map(|_| Cursor::Head),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::iter_mut": [
            "/// An iterator visiting all key-value pairs, with mutable value references.\n///\n/// The iterator order is arbitrary, but consistent across platforms for the\n/// same crate version. Each key will be yielded once per associated value,\n/// so if a key has 3 associated values, it will be yielded 3 times.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::default();\n///\n/// map.insert(HOST, \"hello\".to_string());\n/// map.append(HOST, \"goodbye\".to_string());\n/// map.insert(CONTENT_LENGTH, \"123\".to_string());\n///\n/// for (key, value) in map.iter_mut() {\n///     value.push_str(\"-boop\");\n/// }\n/// ```\npub fn iter_mut(&mut self) -> IterMut<'_, T>{\n        IterMut {\n            map: self as *mut _,\n            entry: 0,\n            cursor: self.entries.first().map(|_| Cursor::Head),\n            lt: PhantomData,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::keys": [
            "/// An iterator visiting all keys.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version. Each key will be yielded only once even if it\n/// has multiple associated values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// map.append(HOST, \"goodbye\".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n///\n/// for key in map.keys() {\n///     println!(\"{:?}\", key);\n/// }\n/// ```\npub fn keys(&self) -> Keys<'_, T>{\n        Keys {\n            inner: self.entries.iter(),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::keys_len": [
            "/// Returns the number of keys stored in the map.\n///\n/// This number will be less than or equal to `len()` as each key may have\n/// more than one associated value.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{ACCEPT, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(0, map.keys_len());\n///\n/// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n/// map.insert(HOST, \"localhost\".parse().unwrap());\n///\n/// assert_eq!(2, map.keys_len());\n///\n/// map.insert(ACCEPT, \"text/html\".parse().unwrap());\n///\n/// assert_eq!(2, map.keys_len());\n/// ```\npub fn keys_len(&self) -> usize{\n        self.entries.len()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::len": [
            "/// Returns the number of headers stored in the map.\n///\n/// This number represents the total number of **values** stored in the map.\n/// This number can be greater than or equal to the number of **keys**\n/// stored given that a single key may have more than one associated value.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{ACCEPT, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(0, map.len());\n///\n/// map.insert(ACCEPT, \"text/plain\".parse().unwrap());\n/// map.insert(HOST, \"localhost\".parse().unwrap());\n///\n/// assert_eq!(2, map.len());\n///\n/// map.append(ACCEPT, \"text/html\".parse().unwrap());\n///\n/// assert_eq!(3, map.len());\n/// ```\npub fn len(&self) -> usize{\n        self.entries.len() + self.extra_values.len()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::raw_links": [
            "#[inline]\nfn raw_links(&mut self) -> RawLinks<T>{\n        RawLinks(&mut self.entries[..] as *mut _)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::rebuild": [
            "fn rebuild(&mut self){\n        // Loop over all entries and re-insert them into the map\n        'outer: for (index, entry) in self.entries.iter_mut().enumerate() {\n            let hash = hash_elem_using(&self.danger, &entry.key);\n            let mut probe = desired_pos(self.mask, hash);\n            let mut dist = 0;\n\n            // Update the entry's hash code\n            entry.hash = hash;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    // if existing element probed less than us, swap\n                    let their_dist = probe_distance(self.mask, entry_hash, probe);\n\n                    if their_dist < dist {\n                        // Robinhood\n                        break;\n                    }\n                } else {\n                    // Vacant slot\n                    self.indices[probe] = Pos::new(index, hash);\n                    continue 'outer;\n                }\n\n                dist += 1;\n            });\n\n            do_insert_phase_two(&mut self.indices, probe, Pos::new(index, hash));\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::reinsert_entry_in_order": [
            "fn reinsert_entry_in_order(&mut self, pos: Pos){\n        if let Some((_, entry_hash)) = pos.resolve() {\n            // Find first empty bucket and insert there\n            let mut probe = desired_pos(self.mask, entry_hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if self.indices[probe].resolve().is_none() {\n                    // empty bucket, insert here\n                    self.indices[probe] = pos;\n                    return;\n                }\n            });\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::remove": [
            "/// Removes a key from the map, returning the value associated with the key.\n///\n/// Returns `None` if the map does not contain the key. If there are\n/// multiple values associated with the key, then the first one is returned.\n/// See `remove_entry_mult` on `OccupiedEntry` for an API that yields all\n/// values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// let prev = map.remove(HOST).unwrap();\n/// assert_eq!(\"hello.world\", prev);\n///\n/// assert!(map.remove(HOST).is_none());\n/// ```\npub fn remove<K>(&mut self, key: K) -> Option<T>\n    where\n        K: AsHeaderName,{\n        match key.find(self) {\n            Some((probe, idx)) => {\n                if let Some(links) = self.entries[idx].links {\n                    self.remove_all_extra_values(links.next);\n                }\n\n                let entry = self.remove_found(probe, idx);\n\n                Some(entry.value)\n            }\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::remove_all_extra_values": [
            "fn remove_all_extra_values(&mut self, mut head: usize){\n        loop {\n            let extra = self.remove_extra_value(head);\n\n            if let Link::Extra(idx) = extra.next {\n                head = idx;\n            } else {\n                break;\n            }\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::remove_extra_value": [
            "/// Removes the `ExtraValue` at the given index.\n#[inline]\nfn remove_extra_value(&mut self, idx: usize) -> ExtraValue<T>{\n        let raw_links = self.raw_links();\n        remove_extra_value(raw_links, &mut self.extra_values, idx)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::remove_found": [
            "/// Remove an entry from the map.\n///\n/// Warning: To avoid inconsistent state, extra values _must_ be removed\n/// for the `found` index (via `remove_all_extra_values` or similar)\n/// _before_ this method is called.\n#[inline]\nfn remove_found(&mut self, probe: usize, found: usize) -> Bucket<T>{\n        // index `probe` and entry `found` is to be removed\n        // use swap_remove, but then we need to update the index that points\n        // to the other entry that has to move\n        self.indices[probe] = Pos::none();\n        let entry = self.entries.swap_remove(found);\n\n        // correct index that points to the entry that had to swap places\n        if let Some(entry) = self.entries.get(found) {\n            // was not last element\n            // examine new element in `found` and find it in indices\n            let mut probe = desired_pos(self.mask, entry.hash);\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((i, _)) = self.indices[probe].resolve() {\n                    if i >= self.entries.len() {\n                        // found it\n                        self.indices[probe] = Pos::new(found, entry.hash);\n                        break;\n                    }\n                }\n            });\n\n            // Update links\n            if let Some(links) = entry.links {\n                self.extra_values[links.next].prev = Link::Entry(found);\n                self.extra_values[links.tail].next = Link::Entry(found);\n            }\n        }\n\n        // backward shift deletion in self.indices\n        // after probe, shift all non-ideally placed indices backward\n        if !self.entries.is_empty() {\n            let mut last_probe = probe;\n            let mut probe = probe + 1;\n\n            probe_loop!(probe < self.indices.len(), {\n                if let Some((_, entry_hash)) = self.indices[probe].resolve() {\n                    if probe_distance(self.mask, entry_hash, probe) > 0 {\n                        self.indices[last_probe] = self.indices[probe];\n                        self.indices[probe] = Pos::none();\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n\n                last_probe = probe;\n            });\n        }\n\n        entry\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::reserve": [
            "/// Reserves capacity for at least `additional` more headers to be inserted\n/// into the `HeaderMap`.\n///\n/// The header map may reserve more space to avoid frequent reallocations.\n/// Like with `with_capacity`, this will be a \"best effort\" to avoid\n/// allocations until `additional` more headers are inserted. Certain usage\n/// patterns could cause additional allocations before the number is\n/// reached.\n///\n/// # Panics\n///\n/// Panics if the new allocation size overflows `HeaderMap` `MAX_SIZE`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.reserve(10);\n/// # map.insert(HOST, \"bar\".parse().unwrap());\n/// ```\npub fn reserve(&mut self, additional: usize){\n        self.try_reserve(additional)\n            .expect(\"size overflows MAX_SIZE\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_append": [
            "/// Inserts a key-value pair into the map.\n///\n/// If the map did not previously have this key present, then `false` is\n/// returned.\n///\n/// If the map did have this key present, the new value is pushed to the end\n/// of the list of values currently associated with the key. The key is not\n/// updated, though; this matters for types that can be `==` without being\n/// identical.\n///\n/// # Errors\n///\n/// This function may return an error if `HeaderMap` exceeds max capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.try_insert(HOST, \"world\".parse().unwrap()).unwrap().is_none());\n/// assert!(!map.is_empty());\n///\n/// map.try_append(HOST, \"earth\".parse().unwrap()).unwrap();\n///\n/// let values = map.get_all(\"host\");\n/// let mut i = values.iter();\n/// assert_eq!(\"world\", *i.next().unwrap());\n/// assert_eq!(\"earth\", *i.next().unwrap());\n/// ```\npub fn try_append<K>(&mut self, key: K, value: T) -> Result<bool, MaxSizeReached>\n    where\n        K: IntoHeaderName,{\n        key.try_append(self, value)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_append2": [
            "#[inline]\nfn try_append2<K>(&mut self, key: K, value: T) -> Result<bool, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,{\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            // Vacant\n            {\n                let _ = danger;\n                let index = self.entries.len();\n                self.try_insert_entry(hash, key.into(), value)?;\n                self.indices[probe] = Pos::new(index, hash);\n                false\n            },\n            // Occupied\n            {\n                append_value(pos, &mut self.entries[pos], &mut self.extra_values, value);\n                true\n            },\n            // Robinhood\n            {\n                self.try_insert_phase_two(key.into(), value, hash, probe, danger)?;\n\n                false\n            }\n        ))\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_entry": [
            "/// Gets the given key's corresponding entry in the map for in-place\n/// manipulation.\n///\n/// # Errors\n///\n/// This method differs from `entry` by allowing types that may not be\n/// valid `HeaderName`s to passed as the key (such as `String`). If they\n/// do not parse as a valid `HeaderName`, this returns an\n/// `InvalidHeaderName` error.\n///\n/// If reserving space goes over the maximum, this will also return an\n/// error. However, to prevent breaking changes to the return type, the\n/// error will still say `InvalidHeaderName`, unlike other `try_*` methods\n/// which return a `MaxSizeReached` error.\npub fn try_entry<K>(&mut self, key: K) -> Result<Entry<'_, T>, InvalidHeaderName>\n    where\n        K: AsHeaderName,{\n        key.try_entry(self).map_err(|err| match err {\n            as_header_name::TryEntryError::InvalidHeaderName(e) => e,\n            as_header_name::TryEntryError::MaxSizeReached(_e) => {\n                // Unfortunately, we cannot change the return type of this\n                // method, so the max size reached error needs to be converted\n                // into an InvalidHeaderName. Yay.\n                InvalidHeaderName::new()\n            }\n        })\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_entry2": [
            "fn try_entry2<K>(&mut self, key: K) -> Result<Entry<'_, T>, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,{\n        // Ensure that there is space in the map\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash,\n                key: key.into(),\n                probe,\n                danger,\n            }),\n            Entry::Occupied(OccupiedEntry {\n                map: self,\n                index: pos,\n                probe,\n            }),\n            Entry::Vacant(VacantEntry {\n                map: self,\n                hash,\n                key: key.into(),\n                probe,\n                danger,\n            })\n        ))\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_grow": [
            "#[inline]\nfn try_grow(&mut self, new_raw_cap: usize) -> Result<(), MaxSizeReached>{\n        if new_raw_cap > MAX_SIZE {\n            return Err(MaxSizeReached::new());\n        }\n\n        // find first ideally placed element -- start of cluster\n        let mut first_ideal = 0;\n\n        for (i, pos) in self.indices.iter().enumerate() {\n            if let Some((_, entry_hash)) = pos.resolve() {\n                if 0 == probe_distance(self.mask, entry_hash, i) {\n                    first_ideal = i;\n                    break;\n                }\n            }\n        }\n\n        // visit the entries in an order where we can simply reinsert them\n        // into self.indices without any bucket stealing.\n        let old_indices = mem::replace(\n            &mut self.indices,\n            vec![Pos::none(); new_raw_cap].into_boxed_slice(),\n        );\n        self.mask = new_raw_cap.wrapping_sub(1) as Size;\n\n        for &pos in &old_indices[first_ideal..] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        for &pos in &old_indices[..first_ideal] {\n            self.reinsert_entry_in_order(pos);\n        }\n\n        // Reserve additional entry slots\n        let more = self.capacity() - self.entries.len();\n        self.entries.reserve_exact(more);\n        Ok(())\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_insert": [
            "/// Inserts a key-value pair into the map.\n///\n/// If the map did not previously have this key present, then `None` is\n/// returned.\n///\n/// If the map did have this key present, the new value is associated with\n/// the key and all previous values are removed. **Note** that only a single\n/// one of the previous values is returned. If there are multiple values\n/// that have been previously associated with the key, then the first one is\n/// returned. See `insert_mult` on `OccupiedEntry` for an API that returns\n/// all values.\n///\n/// The key is not updated, though; this matters for types that can be `==`\n/// without being identical.\n///\n/// # Errors\n///\n/// This function may return an error if `HeaderMap` exceeds max capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// assert!(map.try_insert(HOST, \"world\".parse().unwrap()).unwrap().is_none());\n/// assert!(!map.is_empty());\n///\n/// let mut prev = map.try_insert(HOST, \"earth\".parse().unwrap()).unwrap().unwrap();\n/// assert_eq!(\"world\", prev);\n/// ```\npub fn try_insert<K>(&mut self, key: K, val: T) -> Result<Option<T>, MaxSizeReached>\n    where\n        K: IntoHeaderName,{\n        key.try_insert(self, val)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_insert2": [
            "#[inline]\nfn try_insert2<K>(&mut self, key: K, value: T) -> Result<Option<T>, MaxSizeReached>\n    where\n        K: Hash + Into<HeaderName>,\n        HeaderName: PartialEq<K>,{\n        self.try_reserve_one()?;\n\n        Ok(insert_phase_one!(\n            self,\n            key,\n            probe,\n            pos,\n            hash,\n            danger,\n            // Vacant\n            {\n                let _ = danger; // Make lint happy\n                let index = self.entries.len();\n                self.try_insert_entry(hash, key.into(), value)?;\n                self.indices[probe] = Pos::new(index, hash);\n                None\n            },\n            // Occupied\n            Some(self.insert_occupied(pos, value)),\n            // Robinhood\n            {\n                self.try_insert_phase_two(key.into(), value, hash, probe, danger)?;\n                None\n            }\n        ))\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_insert_entry": [
            "#[inline]\nfn try_insert_entry(\n        &mut self,\n        hash: HashValue,\n        key: HeaderName,\n        value: T,\n    ) -> Result<(), MaxSizeReached>{\n        if self.entries.len() >= MAX_SIZE {\n            return Err(MaxSizeReached::new());\n        }\n\n        self.entries.push(Bucket {\n            hash,\n            key,\n            value,\n            links: None,\n        });\n\n        Ok(())\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_insert_phase_two": [
            "/// phase 2 is post-insert where we forward-shift `Pos` in the indices.\n#[inline]\nfn try_insert_phase_two(\n        &mut self,\n        key: HeaderName,\n        value: T,\n        hash: HashValue,\n        probe: usize,\n        danger: bool,\n    ) -> Result<usize, MaxSizeReached>{\n        // Push the value and get the index\n        let index = self.entries.len();\n        self.try_insert_entry(hash, key, value)?;\n\n        let num_displaced = do_insert_phase_two(&mut self.indices, probe, Pos::new(index, hash));\n\n        if danger || num_displaced >= DISPLACEMENT_THRESHOLD {\n            // Increase danger level\n            self.danger.set_yellow();\n        }\n\n        Ok(index)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_reserve": [
            "/// Reserves capacity for at least `additional` more headers to be inserted\n/// into the `HeaderMap`.\n///\n/// The header map may reserve more space to avoid frequent reallocations.\n/// Like with `with_capacity`, this will be a \"best effort\" to avoid\n/// allocations until `additional` more headers are inserted. Certain usage\n/// patterns could cause additional allocations before the number is\n/// reached.\n///\n/// # Errors\n///\n/// This method differs from `reserve` by returning an error instead of\n/// panicking if the value is too large.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::HOST;\n/// let mut map = HeaderMap::new();\n/// map.try_reserve(10).unwrap();\n/// # map.try_insert(HOST, \"bar\".parse().unwrap()).unwrap();\n/// ```\npub fn try_reserve(&mut self, additional: usize) -> Result<(), MaxSizeReached>{\n        // TODO: This can't overflow if done properly... since the max # of\n        // elements is u16::MAX.\n        let cap = self\n            .entries\n            .len()\n            .checked_add(additional)\n            .ok_or_else(MaxSizeReached::new)?;\n\n        let raw_cap = to_raw_capacity(cap);\n\n        if raw_cap > self.indices.len() {\n            let raw_cap = raw_cap\n                .checked_next_power_of_two()\n                .ok_or_else(MaxSizeReached::new)?;\n            if raw_cap > MAX_SIZE {\n                return Err(MaxSizeReached::new());\n            }\n\n            if self.entries.is_empty() {\n                self.mask = raw_cap as Size - 1;\n                self.indices = vec![Pos::none(); raw_cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(raw_cap));\n            } else {\n                self.try_grow(raw_cap)?;\n            }\n        }\n\n        Ok(())\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_reserve_one": [
            "fn try_reserve_one(&mut self) -> Result<(), MaxSizeReached>{\n        let len = self.entries.len();\n\n        if self.danger.is_yellow() {\n            let load_factor = self.entries.len() as f32 / self.indices.len() as f32;\n\n            if load_factor >= LOAD_FACTOR_THRESHOLD {\n                // Transition back to green danger level\n                self.danger.set_green();\n\n                // Double the capacity\n                let new_cap = self.indices.len() * 2;\n\n                // Grow the capacity\n                self.try_grow(new_cap)?;\n            } else {\n                self.danger.set_red();\n\n                // Rebuild hash table\n                for index in self.indices.iter_mut() {\n                    *index = Pos::none();\n                }\n\n                self.rebuild();\n            }\n        } else if len == self.capacity() {\n            if len == 0 {\n                let new_raw_cap = 8;\n                self.mask = 8 - 1;\n                self.indices = vec![Pos::none(); new_raw_cap].into_boxed_slice();\n                self.entries = Vec::with_capacity(usable_capacity(new_raw_cap));\n            } else {\n                let raw_cap = self.indices.len();\n                self.try_grow(raw_cap << 1)?;\n            }\n        }\n\n        Ok(())\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::try_with_capacity": [
            "/// Create an empty `HeaderMap` with the specified capacity.\n///\n/// The returned map will allocate internal storage in order to hold about\n/// `capacity` elements without reallocating. However, this is a \"best\n/// effort\" as there are usage patterns that could cause additional\n/// allocations before `capacity` headers are stored in the map.\n///\n/// More capacity than requested may be allocated.\n///\n/// # Errors\n///\n/// This function may return an error if `HeaderMap` exceeds max capacity\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let map: HeaderMap<u32> = HeaderMap::try_with_capacity(10).unwrap();\n///\n/// assert!(map.is_empty());\n/// assert_eq!(12, map.capacity());\n/// ```\npub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached>{\n        if capacity == 0 {\n            Ok(HeaderMap {\n                mask: 0,\n                indices: Box::new([]), // as a ZST, this doesn't actually allocate anything\n                entries: Vec::new(),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            })\n        } else {\n            let raw_cap = match to_raw_capacity(capacity).checked_next_power_of_two() {\n                Some(c) => c,\n                None => return Err(MaxSizeReached { _priv: () }),\n            };\n            if raw_cap > MAX_SIZE {\n                return Err(MaxSizeReached { _priv: () });\n            }\n            debug_assert!(raw_cap > 0);\n\n            Ok(HeaderMap {\n                mask: (raw_cap - 1) as Size,\n                indices: vec![Pos::none(); raw_cap].into_boxed_slice(),\n                entries: Vec::with_capacity(usable_capacity(raw_cap)),\n                extra_values: Vec::new(),\n                danger: Danger::Green,\n            })\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::value_iter": [
            "fn value_iter(&self, idx: Option<usize>) -> ValueIter<'_, T>{\n        use self::Cursor::*;\n\n        if let Some(idx) = idx {\n            let back = {\n                let entry = &self.entries[idx];\n\n                entry.links.map(|l| Values(l.tail)).unwrap_or(Head)\n            };\n\n            ValueIter {\n                map: self,\n                index: idx,\n                front: Some(Head),\n                back: Some(back),\n            }\n        } else {\n            ValueIter {\n                map: self,\n                index: usize::MAX,\n                front: None,\n                back: None,\n            }\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::value_iter_mut": [
            "fn value_iter_mut(&mut self, idx: usize) -> ValueIterMut<'_, T>{\n        use self::Cursor::*;\n\n        let back = {\n            let entry = &self.entries[idx];\n\n            entry.links.map(|l| Values(l.tail)).unwrap_or(Head)\n        };\n\n        ValueIterMut {\n            map: self as *mut _,\n            index: idx,\n            front: Some(Head),\n            back: Some(back),\n            lt: PhantomData,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::values": [
            "/// An iterator visiting all values.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::new();\n///\n/// map.insert(HOST, \"hello\".parse().unwrap());\n/// map.append(HOST, \"goodbye\".parse().unwrap());\n/// map.insert(CONTENT_LENGTH, \"123\".parse().unwrap());\n///\n/// for value in map.values() {\n///     println!(\"{:?}\", value);\n/// }\n/// ```\npub fn values(&self) -> Values<'_, T>{\n        Values { inner: self.iter() }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::values_mut": [
            "/// An iterator visiting all values mutably.\n///\n/// The iteration order is arbitrary, but consistent across platforms for\n/// the same crate version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// # use http::header::{CONTENT_LENGTH, HOST};\n/// let mut map = HeaderMap::default();\n///\n/// map.insert(HOST, \"hello\".to_string());\n/// map.append(HOST, \"goodbye\".to_string());\n/// map.insert(CONTENT_LENGTH, \"123\".to_string());\n///\n/// for value in map.values_mut() {\n///     value.push_str(\"-boop\");\n/// }\n/// ```\npub fn values_mut(&mut self) -> ValuesMut<'_, T>{\n        ValuesMut {\n            inner: self.iter_mut(),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::<T>::with_capacity": [
            "/// Create an empty `HeaderMap` with the specified capacity.\n///\n/// The returned map will allocate internal storage in order to hold about\n/// `capacity` elements without reallocating. However, this is a \"best\n/// effort\" as there are usage patterns that could cause additional\n/// allocations before `capacity` headers are stored in the map.\n///\n/// More capacity than requested may be allocated.\n///\n/// # Panics\n///\n/// This method panics if capacity exceeds max `HeaderMap` capacity.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let map: HeaderMap<u32> = HeaderMap::with_capacity(10);\n///\n/// assert!(map.is_empty());\n/// assert_eq!(12, map.capacity());\n/// ```\npub fn with_capacity(capacity: usize) -> HeaderMap<T>{\n        Self::try_with_capacity(capacity).expect(\"size overflows MAX_SIZE\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::HeaderMap::new": [
            "/// Create an empty `HeaderMap`.\n///\n/// The map will be created without any capacity. This function will not\n/// allocate.\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let map = HeaderMap::new();\n///\n/// assert!(map.is_empty());\n/// assert_eq!(0, map.capacity());\n/// ```\npub fn new() -> Self{\n        HeaderMap::try_with_capacity(0).unwrap()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::IntoIter": [
            "/// An owning iterator over the entries of a `HeaderMap`.\n///\n/// This struct is created by the `into_iter` method on `HeaderMap`.\npub struct IntoIter<T> {\n    // If None, pull from `entries`\n    next: Option<usize>,\n    entries: vec::IntoIter<Bucket<T>>,\n    extra_values: Vec<ExtraValue<T>>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Iter": [
            "/// `HeaderMap` entry iterator.\n///\n/// Yields `(&HeaderName, &value)` tuples. The same header name may be yielded\n/// more than once if it has more than one associated value.\npub struct Iter<'a, T> {\n    map: &'a HeaderMap<T>,\n    entry: usize,\n    cursor: Option<Cursor>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::IterMut": [
            "/// `HeaderMap` mutable entry iterator\n///\n/// Yields `(&HeaderName, &mut value)` tuples. The same header name may be\n/// yielded more than once if it has more than one associated value.\npub struct IterMut<'a, T> {\n    map: *mut HeaderMap<T>,\n    entry: usize,\n    cursor: Option<Cursor>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::IterMut::<'a, T>::next_unsafe": [
            "fn next_unsafe(&mut self) -> Option<(&'a HeaderName, *mut T)>{\n        use self::Cursor::*;\n\n        if self.cursor.is_none() {\n            if (self.entry + 1) >= unsafe { &*self.map }.entries.len() {\n                return None;\n            }\n\n            self.entry += 1;\n            self.cursor = Some(Cursor::Head);\n        }\n\n        let entry = unsafe { &mut (*self.map).entries[self.entry] };\n\n        match self.cursor.unwrap() {\n            Head => {\n                self.cursor = entry.links.map(|l| Values(l.next));\n                Some((&entry.key, &mut entry.value as *mut _))\n            }\n            Values(idx) => {\n                let extra = unsafe { &mut (*self.map).extra_values[idx] };\n\n                match extra.next {\n                    Link::Entry(_) => self.cursor = None,\n                    Link::Extra(i) => self.cursor = Some(Values(i)),\n                }\n\n                Some((&entry.key, &mut extra.value as *mut _))\n            }\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Keys": [
            "/// An iterator over `HeaderMap` keys.\n///\n/// Each header name is yielded only once, even if it has more than one\n/// associated value.\npub struct Keys<'a, T> {\n    inner: ::std::slice::Iter<'a, Bucket<T>>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Link": [
            "/// A header value node is either linked to another node in the `extra_values`\n/// list or it points to an entry in `entries`. The entry in `entries` is the\n/// start of the list and holds the associated header name.\nenum Link {\n    Entry(usize),\n    Extra(usize),\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Links": [
            "/// The head and tail of the value linked list.\nstruct Links {\n    next: usize,\n    tail: usize,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::MaxSizeReached": [
            "/// Error returned when max capacity of `HeaderMap` is exceeded\npub struct MaxSizeReached {\n    _priv: (),\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::MaxSizeReached::new": [
            "fn new() -> Self{\n        MaxSizeReached { _priv: () }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry": [
            "/// A view into a single occupied location in a `HeaderMap`.\n///\n/// This struct is returned as part of the `Entry` enum.\npub struct OccupiedEntry<'a, T> {\n    map: &'a mut HeaderMap<T>,\n    probe: usize,\n    index: usize,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::append": [
            "/// Insert the value into the entry.\n///\n/// The new value is appended to the end of the entry's value list. All\n/// previous values associated with the entry are retained.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n///     e.append(\"earth\".parse().unwrap());\n/// }\n///\n/// let values = map.get_all(\"host\");\n/// let mut i = values.iter();\n/// assert_eq!(\"world\", *i.next().unwrap());\n/// assert_eq!(\"earth\", *i.next().unwrap());\n/// ```\npub fn append(&mut self, value: T){\n        let idx = self.index;\n        let entry = &mut self.map.entries[idx];\n        append_value(idx, entry, &mut self.map.extra_values, value);\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::get": [
            "/// Get a reference to the first value in the entry.\n///\n/// Values are stored in insertion order.\n///\n/// # Panics\n///\n/// `get` panics if there are no values associated with the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n///     assert_eq!(e.get(), &\"hello.world\");\n///\n///     e.append(\"hello.earth\".parse().unwrap());\n///\n///     assert_eq!(e.get(), &\"hello.world\");\n/// }\n/// ```\npub fn get(&self) -> &T{\n        &self.map.entries[self.index].value\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::get_mut": [
            "/// Get a mutable reference to the first value in the entry.\n///\n/// Values are stored in insertion order.\n///\n/// # Panics\n///\n/// `get_mut` panics if there are no values associated with the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, \"hello.world\".to_string());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n///     e.get_mut().push_str(\"-2\");\n///     assert_eq!(e.get(), &\"hello.world-2\");\n/// }\n/// ```\npub fn get_mut(&mut self) -> &mut T{\n        &mut self.map.entries[self.index].value\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::insert": [
            "/// Sets the value of the entry.\n///\n/// All previous values associated with the entry are removed and the first\n/// one is returned. See `insert_mult` for an API that returns all values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"hello.world\".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n///     let mut prev = e.insert(\"earth\".parse().unwrap());\n///     assert_eq!(\"hello.world\", prev);\n/// }\n///\n/// assert_eq!(\"earth\", map[\"host\"]);\n/// ```\npub fn insert(&mut self, value: T) -> T{\n        self.map.insert_occupied(self.index, value)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::insert_mult": [
            "/// Sets the value of the entry.\n///\n/// This function does the same as `insert` except it returns an iterator\n/// that yields all values previously associated with the key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n/// map.append(HOST, \"world2\".parse().unwrap());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n///     let mut prev = e.insert_mult(\"earth\".parse().unwrap());\n///     assert_eq!(\"world\", prev.next().unwrap());\n///     assert_eq!(\"world2\", prev.next().unwrap());\n///     assert!(prev.next().is_none());\n/// }\n///\n/// assert_eq!(\"earth\", map[\"host\"]);\n/// ```\npub fn insert_mult(&mut self, value: T) -> ValueDrain<'_, T>{\n        self.map.insert_occupied_mult(self.index, value)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::into_mut": [
            "/// Converts the `OccupiedEntry` into a mutable reference to the **first**\n/// value.\n///\n/// The lifetime of the returned reference is bound to the original map.\n///\n/// # Panics\n///\n/// `into_mut` panics if there are no values associated with the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, \"hello.world\".to_string());\n/// map.append(HOST, \"hello.earth\".to_string());\n///\n/// if let Entry::Occupied(e) = map.entry(\"host\") {\n///     e.into_mut().push_str(\"-2\");\n/// }\n///\n/// assert_eq!(\"hello.world-2\", map[\"host\"]);\n/// ```\npub fn into_mut(self) -> &'a mut T{\n        &mut self.map.entries[self.index].value\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::iter": [
            "/// Returns an iterator visiting all values associated with the entry.\n///\n/// Values are iterated in insertion order.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n/// map.append(HOST, \"earth\".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry(\"host\") {\n///     let mut iter = e.iter();\n///     assert_eq!(&\"world\", iter.next().unwrap());\n///     assert_eq!(&\"earth\", iter.next().unwrap());\n///     assert!(iter.next().is_none());\n/// }\n/// ```\npub fn iter(&self) -> ValueIter<'_, T>{\n        self.map.value_iter(Some(self.index))\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::iter_mut": [
            "/// Returns an iterator mutably visiting all values associated with the\n/// entry.\n///\n/// Values are iterated in insertion order.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::default();\n/// map.insert(HOST, \"world\".to_string());\n/// map.append(HOST, \"earth\".to_string());\n///\n/// if let Entry::Occupied(mut e) = map.entry(\"host\") {\n///     for e in e.iter_mut() {\n///         e.push_str(\"-boop\");\n///     }\n/// }\n///\n/// let mut values = map.get_all(\"host\");\n/// let mut i = values.iter();\n/// assert_eq!(&\"world-boop\", i.next().unwrap());\n/// assert_eq!(&\"earth-boop\", i.next().unwrap());\n/// ```\npub fn iter_mut(&mut self) -> ValueIterMut<'_, T>{\n        self.map.value_iter_mut(self.index)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::key": [
            "/// Returns a reference to the entry's key.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry(\"host\") {\n///     assert_eq!(\"host\", e.key());\n/// }\n/// ```\npub fn key(&self) -> &HeaderName{\n        &self.map.entries[self.index].key\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::remove": [
            "/// Remove the entry from the map.\n///\n/// All values associated with the entry are removed and the first one is\n/// returned. See `remove_entry_mult` for an API that returns all values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry(\"host\") {\n///     let mut prev = e.remove();\n///     assert_eq!(\"world\", prev);\n/// }\n///\n/// assert!(!map.contains_key(\"host\"));\n/// ```\npub fn remove(self) -> T{\n        self.remove_entry().1\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::remove_entry": [
            "/// Remove the entry from the map.\n///\n/// The key and all values associated with the entry are removed and the\n/// first one is returned. See `remove_entry_mult` for an API that returns\n/// all values.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry, HOST};\n/// let mut map = HeaderMap::new();\n/// map.insert(HOST, \"world\".parse().unwrap());\n///\n/// if let Entry::Occupied(e) = map.entry(\"host\") {\n///     let (key, mut prev) = e.remove_entry();\n///     assert_eq!(\"host\", key.as_str());\n///     assert_eq!(\"world\", prev);\n/// }\n///\n/// assert!(!map.contains_key(\"host\"));\n/// ```\npub fn remove_entry(self) -> (HeaderName, T){\n        if let Some(links) = self.map.entries[self.index].links {\n            self.map.remove_all_extra_values(links.next);\n        }\n\n        let entry = self.map.remove_found(self.probe, self.index);\n\n        (entry.key, entry.value)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::OccupiedEntry::<'a, T>::remove_entry_mult": [
            "/// Remove the entry from the map.\n///\n/// The key and all values associated with the entry are removed and\n/// returned.\npub fn remove_entry_mult(self) -> (HeaderName, ValueDrain<'a, T>){\n        let raw_links = self.map.raw_links();\n        let extra_values = &mut self.map.extra_values;\n\n        let next = self.map.entries[self.index]\n            .links\n            .map(|l| drain_all_extra_values(raw_links, extra_values, l.next).into_iter());\n\n        let entry = self.map.remove_found(self.probe, self.index);\n\n        let drain = ValueDrain {\n            first: Some(entry.value),\n            next,\n            lt: PhantomData,\n        };\n        (entry.key, drain)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Pos": [
            "/// An entry in the hash table. This represents the full hash code for an entry\n/// as well as the position of the entry in the `entries` vector.\nstruct Pos {\n    // Index in the `entries` vec\n    index: Size,\n    // Full hash value for the entry.\n    hash: HashValue,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Pos::is_none": [
            "#[inline]\nfn is_none(&self) -> bool{\n        self.index == !0\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Pos::is_some": [
            "#[inline]\nfn is_some(&self) -> bool{\n        !self.is_none()\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Pos::new": [
            "#[inline]\nfn new(index: usize, hash: HashValue) -> Self{\n        debug_assert!(index < MAX_SIZE);\n        Pos {\n            index: index as Size,\n            hash,\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Pos::none": [
            "#[inline]\nfn none() -> Self{\n        Pos {\n            index: !0,\n            hash: HashValue(0),\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Pos::resolve": [
            "#[inline]\nfn resolve(&self) -> Option<(usize, HashValue)>{\n        if self.is_some() {\n            Some((self.index as usize, self.hash))\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::RawLinks": [
            "/// Access to the `links` value in a slice of buckets.\n///\n/// It's important that no other field is accessed, since it may have been\n/// freed in a `Drain` iterator.\nstruct RawLinks<T>(*mut [Bucket<T>]);",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::VacantEntry": [
            "/// A view into a single empty location in a `HeaderMap`.\n///\n/// This struct is returned as part of the `Entry` enum.\npub struct VacantEntry<'a, T> {\n    map: &'a mut HeaderMap<T>,\n    key: HeaderName,\n    hash: HashValue,\n    probe: usize,\n    danger: bool,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::VacantEntry::<'a, T>::insert": [
            "/// Insert the value into the entry.\n///\n/// The value will be associated with this entry's key. A mutable reference\n/// to the inserted value will be returned.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry};\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.entry(\"x-hello\") {\n///     v.insert(\"world\".parse().unwrap());\n/// }\n///\n/// assert_eq!(map[\"x-hello\"], \"world\");\n/// ```\npub fn insert(self, value: T) -> &'a mut T{\n        self.try_insert(value).expect(\"size overflows MAX_SIZE\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::VacantEntry::<'a, T>::insert_entry": [
            "/// Insert the value into the entry.\n///\n/// The value will be associated with this entry's key. The new\n/// `OccupiedEntry` is returned, allowing for further manipulation.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.try_entry(\"x-hello\").unwrap() {\n///     let mut e = v.try_insert_entry(\"world\".parse().unwrap()).unwrap();\n///     e.insert(\"world2\".parse().unwrap());\n/// }\n///\n/// assert_eq!(map[\"x-hello\"], \"world2\");\n/// ```\npub fn insert_entry(self, value: T) -> OccupiedEntry<'a, T>{\n        self.try_insert_entry(value)\n            .expect(\"size overflows MAX_SIZE\")\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::VacantEntry::<'a, T>::into_key": [
            "/// Take ownership of the key\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry};\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.entry(\"x-hello\") {\n///     assert_eq!(v.into_key().as_str(), \"x-hello\");\n/// }\n/// ```\npub fn into_key(self) -> HeaderName{\n        self.key\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::VacantEntry::<'a, T>::key": [
            "/// Returns a reference to the entry's key\n///\n/// # Examples\n///\n/// ```\n/// # use http::HeaderMap;\n/// let mut map = HeaderMap::new();\n///\n/// assert_eq!(map.entry(\"x-hello\").key().as_str(), \"x-hello\");\n/// ```\npub fn key(&self) -> &HeaderName{\n        &self.key\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::VacantEntry::<'a, T>::try_insert": [
            "/// Insert the value into the entry.\n///\n/// The value will be associated with this entry's key. A mutable reference\n/// to the inserted value will be returned.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderMap, Entry};\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.entry(\"x-hello\") {\n///     v.insert(\"world\".parse().unwrap());\n/// }\n///\n/// assert_eq!(map[\"x-hello\"], \"world\");\n/// ```\npub fn try_insert(self, value: T) -> Result<&'a mut T, MaxSizeReached>{\n        // Ensure that there is space in the map\n        let index =\n            self.map\n                .try_insert_phase_two(self.key, value, self.hash, self.probe, self.danger)?;\n\n        Ok(&mut self.map.entries[index].value)\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::VacantEntry::<'a, T>::try_insert_entry": [
            "/// Insert the value into the entry.\n///\n/// The value will be associated with this entry's key. The new\n/// `OccupiedEntry` is returned, allowing for further manipulation.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// if let Entry::Vacant(v) = map.try_entry(\"x-hello\").unwrap() {\n///     let mut e = v.try_insert_entry(\"world\".parse().unwrap()).unwrap();\n///     e.insert(\"world2\".parse().unwrap());\n/// }\n///\n/// assert_eq!(map[\"x-hello\"], \"world2\");\n/// ```\npub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached>{\n        // Ensure that there is space in the map\n        let index =\n            self.map\n                .try_insert_phase_two(self.key, value, self.hash, self.probe, self.danger)?;\n\n        Ok(OccupiedEntry {\n            map: self.map,\n            index,\n            probe: self.probe,\n        })\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::ValueDrain": [
            "/// An drain iterator of all values associated with a single header name.\npub struct ValueDrain<'a, T> {\n    first: Option<T>,\n    next: Option<::std::vec::IntoIter<T>>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::ValueIter": [
            "/// An iterator of all values associated with a single header name.\npub struct ValueIter<'a, T> {\n    map: &'a HeaderMap<T>,\n    index: usize,\n    front: Option<Cursor>,\n    back: Option<Cursor>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::ValueIterMut": [
            "/// A mutable iterator of all values associated with a single header name.\npub struct ValueIterMut<'a, T> {\n    map: *mut HeaderMap<T>,\n    index: usize,\n    front: Option<Cursor>,\n    back: Option<Cursor>,\n    lt: PhantomData<&'a mut HeaderMap<T>>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::Values": [
            "/// `HeaderMap` value iterator.\n///\n/// Each value contained in the `HeaderMap` will be yielded.\npub struct Values<'a, T> {\n    inner: Iter<'a, T>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::ValuesMut": [
            "/// `HeaderMap` mutable value iterator\npub struct ValuesMut<'a, T> {\n    inner: IterMut<'a, T>,\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::append_value": [
            "#[inline]\nfn append_value<T>(\n    entry_idx: usize,\n    entry: &mut Bucket<T>,\n    extra: &mut Vec<ExtraValue<T>>,\n    value: T,\n){\n    match entry.links {\n        Some(links) => {\n            let idx = extra.len();\n            extra.push(ExtraValue {\n                value,\n                prev: Link::Extra(links.tail),\n                next: Link::Entry(entry_idx),\n            });\n\n            extra[links.tail].next = Link::Extra(idx);\n\n            entry.links = Some(Links { tail: idx, ..links });\n        }\n        None => {\n            let idx = extra.len();\n            extra.push(ExtraValue {\n                value,\n                prev: Link::Entry(entry_idx),\n                next: Link::Entry(entry_idx),\n            });\n\n            entry.links = Some(Links {\n                next: idx,\n                tail: idx,\n            });\n        }\n    }\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::as_header_name::AsHeaderName": [
            "/// A marker trait used to identify values that can be used as search keys\n/// to a `HeaderMap`.\npub trait AsHeaderName: Sealed {}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::as_header_name::Sealed": [
            "pub trait Sealed {\n        #[doc(hidden)]\n        fn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, TryEntryError>;\n\n        #[doc(hidden)]\n        fn find<T>(&self, map: &HeaderMap<T>) -> Option<(usize, usize)>;\n\n        #[doc(hidden)]\n        fn as_str(&self) -> &str;\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::as_header_name::TryEntryError": [
            "#[allow(missing_debug_implementations)]\npub enum TryEntryError {\n        InvalidHeaderName(InvalidHeaderName),\n        MaxSizeReached(MaxSizeReached),\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::desired_pos": [
            "#[inline]\nfn desired_pos(mask: Size, hash: HashValue) -> usize{\n    (hash.0 & mask) as usize\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::do_insert_phase_two": [
            "/// phase 2 is post-insert where we forward-shift `Pos` in the indices.\n///\n/// returns the number of displaced elements\n#[inline]\nfn do_insert_phase_two(indices: &mut [Pos], mut probe: usize, mut old_pos: Pos) -> usize{\n    let mut num_displaced = 0;\n\n    probe_loop!(probe < indices.len(), {\n        let pos = &mut indices[probe];\n\n        if pos.is_none() {\n            *pos = old_pos;\n            break;\n        } else {\n            num_displaced += 1;\n            old_pos = mem::replace(pos, old_pos);\n        }\n    });\n\n    num_displaced\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::drain_all_extra_values": [
            "fn drain_all_extra_values<T>(\n    raw_links: RawLinks<T>,\n    extra_values: &mut Vec<ExtraValue<T>>,\n    mut head: usize,\n) -> Vec<T>{\n    let mut vec = Vec::new();\n    loop {\n        let extra = remove_extra_value(raw_links, extra_values, head);\n        vec.push(extra.value);\n\n        if let Link::Extra(idx) = extra.next {\n            head = idx;\n        } else {\n            break;\n        }\n    }\n    vec\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::hash_elem_using": [
            "fn hash_elem_using<K>(danger: &Danger, k: &K) -> HashValue\nwhere\n    K: Hash + ?Sized,{\n    use fnv::FnvHasher;\n\n    const MASK: u64 = (MAX_SIZE as u64) - 1;\n\n    let hash = match *danger {\n        // Safe hash\n        Danger::Red(ref hasher) => {\n            let mut h = hasher.build_hasher();\n            k.hash(&mut h);\n            h.finish()\n        }\n        // Fast hash\n        _ => {\n            let mut h = FnvHasher::default();\n            k.hash(&mut h);\n            h.finish()\n        }\n    };\n\n    HashValue((hash & MASK) as u16)\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::into_header_name::IntoHeaderName": [
            "/// A marker trait used to identify values that can be used as insert keys\n/// to a `HeaderMap`.\npub trait IntoHeaderName: Sealed {}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::into_header_name::Sealed": [
            "pub trait Sealed {\n        #[doc(hidden)]\n        fn try_insert<T>(self, map: &mut HeaderMap<T>, val: T)\n            -> Result<Option<T>, MaxSizeReached>;\n\n        #[doc(hidden)]\n        fn try_append<T>(self, map: &mut HeaderMap<T>, val: T) -> Result<bool, MaxSizeReached>;\n\n        #[doc(hidden)]\n        fn try_entry<T>(self, map: &mut HeaderMap<T>) -> Result<Entry<'_, T>, MaxSizeReached>;\n    }",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::probe_distance": [
            "/// The number of steps that `current` is forward of the desired position for hash\n#[inline]\nfn probe_distance(mask: Size, hash: HashValue, current: usize) -> usize{\n    current.wrapping_sub(desired_pos(mask, hash)) & mask as usize\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::remove_extra_value": [
            "/// Removes the `ExtraValue` at the given index.\n#[inline]\nfn remove_extra_value<T>(\n    mut raw_links: RawLinks<T>,\n    extra_values: &mut Vec<ExtraValue<T>>,\n    idx: usize,\n) -> ExtraValue<T>{\n    let prev;\n    let next;\n\n    {\n        debug_assert!(extra_values.len() > idx);\n        let extra = &extra_values[idx];\n        prev = extra.prev;\n        next = extra.next;\n    }\n\n    // First unlink the extra value\n    match (prev, next) {\n        (Link::Entry(prev), Link::Entry(next)) => {\n            debug_assert_eq!(prev, next);\n\n            raw_links[prev] = None;\n        }\n        (Link::Entry(prev), Link::Extra(next)) => {\n            debug_assert!(raw_links[prev].is_some());\n\n            raw_links[prev].as_mut().unwrap().next = next;\n\n            debug_assert!(extra_values.len() > next);\n            extra_values[next].prev = Link::Entry(prev);\n        }\n        (Link::Extra(prev), Link::Entry(next)) => {\n            debug_assert!(raw_links[next].is_some());\n\n            raw_links[next].as_mut().unwrap().tail = prev;\n\n            debug_assert!(extra_values.len() > prev);\n            extra_values[prev].next = Link::Entry(next);\n        }\n        (Link::Extra(prev), Link::Extra(next)) => {\n            debug_assert!(extra_values.len() > next);\n            debug_assert!(extra_values.len() > prev);\n\n            extra_values[prev].next = Link::Extra(next);\n            extra_values[next].prev = Link::Extra(prev);\n        }\n    }\n\n    // Remove the extra value\n    let mut extra = extra_values.swap_remove(idx);\n\n    // This is the index of the value that was moved (possibly `extra`)\n    let old_idx = extra_values.len();\n\n    // Update the links\n    if extra.prev == Link::Extra(old_idx) {\n        extra.prev = Link::Extra(idx);\n    }\n\n    if extra.next == Link::Extra(old_idx) {\n        extra.next = Link::Extra(idx);\n    }\n\n    // Check if another entry was displaced. If it was, then the links\n    // need to be fixed.\n    if idx != old_idx {\n        let next;\n        let prev;\n\n        {\n            debug_assert!(extra_values.len() > idx);\n            let moved = &extra_values[idx];\n            next = moved.next;\n            prev = moved.prev;\n        }\n\n        // An entry was moved, we have to the links\n        match prev {\n            Link::Entry(entry_idx) => {\n                // It is critical that we do not attempt to read the\n                // header name or value as that memory may have been\n                // \"released\" already.\n                debug_assert!(raw_links[entry_idx].is_some());\n\n                let links = raw_links[entry_idx].as_mut().unwrap();\n                links.next = idx;\n            }\n            Link::Extra(extra_idx) => {\n                debug_assert!(extra_values.len() > extra_idx);\n                extra_values[extra_idx].next = Link::Extra(idx);\n            }\n        }\n\n        match next {\n            Link::Entry(entry_idx) => {\n                debug_assert!(raw_links[entry_idx].is_some());\n\n                let links = raw_links[entry_idx].as_mut().unwrap();\n                links.tail = idx;\n            }\n            Link::Extra(extra_idx) => {\n                debug_assert!(extra_values.len() > extra_idx);\n                extra_values[extra_idx].prev = Link::Extra(idx);\n            }\n        }\n    }\n\n    debug_assert!({\n        for v in &*extra_values {\n            assert!(v.next != Link::Extra(old_idx));\n            assert!(v.prev != Link::Extra(old_idx));\n        }\n\n        true\n    });\n\n    extra\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::to_raw_capacity": [
            "#[inline]\nfn to_raw_capacity(n: usize) -> usize{\n    match n.checked_add(n / 3) {\n        Some(n) => n,\n        None => panic!(\n            \"requested capacity {} too large: overflow while converting to raw capacity\",\n            n\n        ),\n    }\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::map::usable_capacity": [
            "#[inline]\nfn usable_capacity(cap: usize) -> usize{\n    cap - cap / 4\n}",
            "Real(LocalPath(\"src/header/map.rs\"))"
        ],
        "header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq": [
            "/// Performs a case-insensitive comparison of the string against the header\n/// name\n#[inline]\nfn eq(&self, other: &HeaderName) -> bool{\n        *other == *self\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq": [
            "/// Performs a case-insensitive comparison of the string against the header\n/// name\n///\n/// # Examples\n///\n/// ```\n/// use http::header::CONTENT_LENGTH;\n///\n/// assert_eq!(CONTENT_LENGTH, \"content-length\");\n/// assert_eq!(CONTENT_LENGTH, \"Content-Length\");\n/// assert_ne!(CONTENT_LENGTH, \"content length\");\n/// ```\n#[inline]\nfn eq(&self, other: &HeaderName) -> bool{\n        *other == *self\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from": [
            "#[inline]\nfn from(Custom(inner): Custom) -> Bytes{\n        Bytes::from(inner)\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from": [
            "fn from(repr: Repr<T>) -> Bytes{\n        match repr {\n            Repr::Standard(header) => Bytes::from_static(header.as_str().as_bytes()),\n            Repr::Custom(header) => header.into(),\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::Custom": [
            "struct Custom(ByteStr);",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::HdrName": [
            "pub struct HdrName<'a> {\n    inner: Repr<MaybeLower<'a>>,\n}",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::HdrName::<'a>::custom": [
            "fn custom(buf: &'a [u8], lower: bool) -> HdrName<'a>{\n        HdrName {\n            // Invariant (on MaybeLower): follows from the precondition\n            inner: Repr::Custom(MaybeLower { buf, lower }),\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::HdrName::<'a>::from_bytes": [
            "pub fn from_bytes<F, U>(hdr: &[u8], f: F) -> Result<U, InvalidHeaderName>\n    where\n        F: FnOnce(HdrName<'_>) -> U,{\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n        let hdr = parse_hdr(hdr, &mut buf, &HEADER_CHARS)?;\n        Ok(f(hdr))\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::HdrName::<'a>::from_static": [
            "pub fn from_static<F, U>(hdr: &'static str, f: F) -> U\n    where\n        F: FnOnce(HdrName<'_>) -> U,{\n        let mut buf = uninit_u8_array();\n        let hdr =\n            // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n            parse_hdr(hdr.as_bytes(), &mut buf, &HEADER_CHARS).expect(\"static str is invalid name\");\n        f(hdr)\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::HeaderName": [
            "/// Represents an HTTP header field name\n///\n/// Header field names identify the header. Header sets may include multiple\n/// headers with the same name. The HTTP specification defines a number of\n/// standard headers, but HTTP messages may include non-standard header names as\n/// well as long as they adhere to the specification.\n///\n/// `HeaderName` is used as the [`HeaderMap`] key. Constants are available for\n/// all standard header names in the [`header`] module.\n///\n/// # Representation\n///\n/// `HeaderName` represents standard header names using an `enum`, as such they\n/// will not require an allocation for storage. All custom header names are\n/// lower cased upon conversion to a `HeaderName` value. This avoids the\n/// overhead of dynamically doing lower case conversion during the hash code\n/// computation and the comparison operation.\n///\n/// [`HeaderMap`]: struct.HeaderMap.html\n/// [`header`]: index.html\npub struct HeaderName {\n    inner: Repr<Custom>,\n}",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::HeaderName::as_str": [
            "/// Returns a `str` representation of the header.\n///\n/// The returned string will always be lower case.\n#[inline]\npub fn as_str(&self) -> &str{\n        match self.inner {\n            Repr::Standard(v) => v.as_str(),\n            Repr::Custom(ref v) => &v.0,\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::HeaderName::from_bytes": [
            "/// Converts a slice of bytes to an HTTP header name.\n///\n/// This function normalizes the input.\npub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName>{\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS is a valid table for parse_hdr().\n        match parse_hdr(src, &mut buf, &HEADER_CHARS)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                use bytes::BufMut;\n                let mut dst = BytesMut::with_capacity(buf.len());\n\n                for b in buf.iter() {\n                    // HEADER_CHARS maps all bytes to valid single-byte UTF-8\n                    let b = HEADER_CHARS[*b as usize];\n\n                    if b == 0 {\n                        return Err(InvalidHeaderName::new());\n                    }\n\n                    dst.put_u8(b);\n                }\n\n                // Safety: the loop above maps all bytes in buf to valid single byte\n                // UTF-8 before copying them into dst. This means that dst (and hence\n                // dst.freeze()) is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(dst.freeze()) };\n\n                Ok(Custom(val).into())\n            }\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::HeaderName::from_lowercase": [
            "/// Converts a slice of bytes to an HTTP header name.\n///\n/// This function expects the input to only contain lowercase characters.\n/// This is useful when decoding HTTP/2.0 or HTTP/3.0 headers. Both\n/// require that all headers be represented in lower case.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n///\n/// // Parsing a lower case header\n/// let hdr = HeaderName::from_lowercase(b\"content-length\").unwrap();\n/// assert_eq!(CONTENT_LENGTH, hdr);\n///\n/// // Parsing a header that contains uppercase characters\n/// assert!(HeaderName::from_lowercase(b\"Content-Length\").is_err());\n/// ```\npub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName>{\n        let mut buf = uninit_u8_array();\n        // Precondition: HEADER_CHARS_H2 is a valid table for parse_hdr()\n        match parse_hdr(src, &mut buf, &HEADER_CHARS_H2)?.inner {\n            Repr::Standard(std) => Ok(std.into()),\n            Repr::Custom(MaybeLower { buf, lower: true }) => {\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the invariant on MaybeLower ensures buf is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n            Repr::Custom(MaybeLower { buf, lower: false }) => {\n                for &b in buf.iter() {\n                    // HEADER_CHARS_H2 maps all bytes that are not valid single-byte\n                    // UTF-8 to 0 so this check returns an error for invalid UTF-8.\n                    if HEADER_CHARS_H2[b as usize] == 0 {\n                        return Err(InvalidHeaderName::new());\n                    }\n                }\n\n                let buf = Bytes::copy_from_slice(buf);\n                // Safety: the loop above checks that each byte of buf (either\n                // version) is valid UTF-8.\n                let val = unsafe { ByteStr::from_utf8_unchecked(buf) };\n                Ok(Custom(val).into())\n            }\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::HeaderName::from_static": [
            "/// Converts a static string to a HTTP header name.\n///\n/// This function requires the static string to only contain lowercase\n/// characters, numerals and symbols, as per the HTTP/2.0 specification\n/// and header names internal representation within this library.\n///\n/// # Panics\n///\n/// This function panics when the static string is a invalid header.\n///\n/// Until [Allow panicking in constants](https://github.com/rust-lang/rfcs/pull/2345)\n/// makes its way into stable, the panic message at compile-time is\n/// going to look cryptic, but should at least point at your header value:\n///\n/// ```text\n/// error: any use of this value will cause an error\n///     --> http/src/header/name.rs:1241:13\n///      |\n/// 1241 |             ([] as [u8; 0])[0]; // Invalid header name\n///      |             ^^^^^^^^^^^^^^^^^^\n///      |             |\n///      |             index out of bounds: the length is 0 but the index is 0\n///      |             inside `http::HeaderName::from_static` at http/src/header/name.rs:1241:13\n///      |             inside `INVALID_NAME` at src/main.rs:3:34\n///      |\n///     ::: src/main.rs:3:1\n///      |\n/// 3    | const INVALID_NAME: HeaderName = HeaderName::from_static(\"Capitalized\");\n///      | ------------------------------------------------------------------------\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::*;\n/// // Parsing a standard header\n/// let hdr = HeaderName::from_static(\"content-length\");\n/// assert_eq!(CONTENT_LENGTH, hdr);\n///\n/// // Parsing a custom header\n/// let CUSTOM_HEADER: &'static str = \"custom-header\";\n///\n/// let a = HeaderName::from_lowercase(b\"custom-header\").unwrap();\n/// let b = HeaderName::from_static(CUSTOM_HEADER);\n/// assert_eq!(a, b);\n/// ```\n///\n/// ```should_panic\n/// # use http::header::*;\n/// #\n/// // Parsing a header that contains invalid symbols(s):\n/// HeaderName::from_static(\"content{}{}length\"); // This line panics!\n///\n/// // Parsing a header that contains invalid uppercase characters.\n/// let a = HeaderName::from_static(\"foobar\");\n/// let b = HeaderName::from_static(\"FOOBAR\"); // This line panics!\n/// ```\n#[allow(unconditional_panic)]\npub const fn from_static(src: &'static str) -> HeaderName{\n        let name_bytes = src.as_bytes();\n        if let Some(standard) = StandardHeader::from_bytes(name_bytes) {\n            return HeaderName {\n                inner: Repr::Standard(standard),\n            };\n        }\n\n        if name_bytes.is_empty() || name_bytes.len() > super::MAX_HEADER_NAME_LEN || {\n            let mut i = 0;\n            loop {\n                if i >= name_bytes.len() {\n                    break false;\n                } else if HEADER_CHARS_H2[name_bytes[i] as usize] == 0 {\n                    break true;\n                }\n                i += 1;\n            }\n        } {\n            // TODO: When msrv is bumped to larger than 1.57, this should be\n            // replaced with `panic!` macro.\n            // https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html#panic-in-const-contexts\n            //\n            // See the panics section of this method's document for details.\n            #[allow(clippy::no_effect, clippy::out_of_bounds_indexing)]\n            ([] as [u8; 0])[0]; // Invalid header name\n        }\n\n        HeaderName {\n            inner: Repr::Custom(Custom(ByteStr::from_static(src))),\n        }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::HeaderName::into_bytes": [
            "pub(super) fn into_bytes(self) -> Bytes{\n        self.inner.into()\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::InvalidHeaderName": [
            "/// A possible error when converting a `HeaderName` from another type.\npub struct InvalidHeaderName {\n    _priv: (),\n}",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::InvalidHeaderName::new": [
            "pub(super) fn new() -> InvalidHeaderName{\n        InvalidHeaderName { _priv: () }\n    }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::MaybeLower": [
            "struct MaybeLower<'a> {\n    buf: &'a [u8],\n    lower: bool,\n}",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::Repr": [
            "enum Repr<T> {\n    Standard(StandardHeader),\n    Custom(T),\n}",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::StandardHeader": [
            "enum StandardHeader {\n            $(\n                $konst,\n            )+\n        }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::StandardHeader::as_str": [
            "#[inline]\nfn as_str(&self) -> &'static str{\n                match *self {\n                    // Safety: test_parse_standard_headers ensures these &[u8]s are &str-safe.\n                    $(\n                    StandardHeader::$konst => unsafe { std::str::from_utf8_unchecked( $name_bytes ) },\n                    )+\n                }\n            }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::StandardHeader::from_bytes": [
            "const fn from_bytes(name_bytes: &[u8]) -> Option<StandardHeader>{\n                match name_bytes {\n                    $(\n                        $name_bytes => Some(StandardHeader::$konst),\n                    )+\n                    _ => None,\n                }\n            }",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::eq_ignore_ascii_case": [
            "#[inline]\nfn eq_ignore_ascii_case(lower: &[u8], s: &[u8]) -> bool{\n    if lower.len() != s.len() {\n        return false;\n    }\n\n    lower\n        .iter()\n        .zip(s)\n        .all(|(a, b)| *a == HEADER_CHARS[*b as usize])\n}",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::parse_hdr": [
            "fn parse_hdr<'a>(\n    data: &'a [u8],\n    b: &'a mut [MaybeUninit<u8>; SCRATCH_BUF_SIZE],\n    table: &[u8; 256],\n) -> Result<HdrName<'a>, InvalidHeaderName>{\n    match data.len() {\n        0 => Err(InvalidHeaderName::new()),\n        len @ 1..=SCRATCH_BUF_SIZE => {\n            // Read from data into the buffer - transforming using `table` as we go\n            data.iter()\n                .zip(b.iter_mut())\n                .for_each(|(index, out)| *out = MaybeUninit::new(table[*index as usize]));\n            // Safety: len bytes of b were just initialized.\n            let name: &'a [u8] = unsafe { slice_assume_init(&b[0..len]) };\n            match StandardHeader::from_bytes(name) {\n                Some(sh) => Ok(sh.into()),\n                None => {\n                    if name.contains(&0) {\n                        Err(InvalidHeaderName::new())\n                    } else {\n                        Ok(HdrName::custom(name, true))\n                    }\n                }\n            }\n        }\n        SCRATCH_BUF_OVERFLOW..=super::MAX_HEADER_NAME_LEN => Ok(HdrName::custom(data, false)),\n        _ => Err(InvalidHeaderName::new()),\n    }\n}",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::slice_assume_init": [
            "unsafe fn slice_assume_init<T>(slice: &[MaybeUninit<T>]) -> &[T]{\n    &*(slice as *const [MaybeUninit<T>] as *const [T])\n}",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::name::uninit_u8_array": [
            "fn uninit_u8_array() -> [MaybeUninit<u8>; SCRATCH_BUF_SIZE]{\n    let arr = MaybeUninit::<[MaybeUninit<u8>; SCRATCH_BUF_SIZE]>::uninit();\n    // Safety: assume_init() is claiming that an array of MaybeUninit<>\n    // has been initialized, but MaybeUninit<>'s do not require initialization.\n    unsafe { arr.assume_init() }\n}",
            "Real(LocalPath(\"src/header/name.rs\"))"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq": [
            "#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq": [
            "#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq": [
            "#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq": [
            "#[inline]\nfn eq(&self, other: &HeaderValue) -> bool{\n        *other == *self\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.partial_cmp(other.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &HeaderValue) -> Option<cmp::Ordering>{\n        self.as_bytes().partial_cmp(other.as_bytes())\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue": [
            "/// Represents an HTTP header field value.\n///\n/// In practice, HTTP header field values are usually valid ASCII. However, the\n/// HTTP spec allows for a header value to contain opaque bytes as well. In this\n/// case, the header field value is not able to be represented as a string.\n///\n/// To handle this, the `HeaderValue` is useable as a type and can be compared\n/// with strings and implements `Debug`. A `to_str` fn is provided that returns\n/// an `Err` if the header value contains non visible ascii characters.\npub struct HeaderValue {\n    inner: Bytes,\n    is_sensitive: bool,\n}",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::as_bytes": [
            "/// Converts a `HeaderValue` to a byte slice.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert_eq!(val.as_bytes(), b\"hello\");\n/// ```\n#[inline]\npub fn as_bytes(&self) -> &[u8]{\n        self.as_ref()\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::from_bytes": [
            "/// Attempt to convert a byte slice to a `HeaderValue`.\n///\n/// If the argument contains invalid header value bytes, an error is\n/// returned. Only byte values between 32 and 255 (inclusive) are permitted,\n/// excluding byte 127 (DEL).\n///\n/// This function is intended to be replaced in the future by a `TryFrom`\n/// implementation once the trait is stabilized in std.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_bytes(b\"hello\\xfa\").unwrap();\n/// assert_eq!(val, &b\"hello\\xfa\"[..]);\n/// ```\n///\n/// An invalid value\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_bytes(b\"\\n\");\n/// assert!(val.is_err());\n/// ```\n#[inline]\npub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue>{\n        HeaderValue::try_from_generic(src, Bytes::copy_from_slice)\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::from_maybe_shared": [
            "/// Attempt to convert a `Bytes` buffer to a `HeaderValue`.\n///\n/// This will try to prevent a copy if the type passed is the type used\n/// internally, and will copy the data if it is not.\npub fn from_maybe_shared<T>(src: T) -> Result<HeaderValue, InvalidHeaderValue>\n    where\n        T: AsRef<[u8]> + 'static,{\n        if_downcast_into!(T, Bytes, src, {\n            return HeaderValue::from_shared(src);\n        });\n\n        HeaderValue::from_bytes(src.as_ref())\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::from_maybe_shared_unchecked": [
            "/// Convert a `Bytes` directly into a `HeaderValue` without validating.\n///\n/// This function does NOT validate that illegal bytes are not contained\n/// within the buffer.\n///\n/// ## Panics\n/// In a debug build this will panic if `src` is not valid UTF-8.\n///\n/// ## Safety\n/// `src` must contain valid UTF-8. In a release build it is undefined\n/// behaviour to call this with `src` that is not valid UTF-8.\npub unsafe fn from_maybe_shared_unchecked<T>(src: T) -> HeaderValue\n    where\n        T: AsRef<[u8]> + 'static,{\n        if cfg!(debug_assertions) {\n            match HeaderValue::from_maybe_shared(src) {\n                Ok(val) => val,\n                Err(_err) => {\n                    panic!(\"HeaderValue::from_maybe_shared_unchecked() with invalid bytes\");\n                }\n            }\n        } else {\n            if_downcast_into!(T, Bytes, src, {\n                return HeaderValue {\n                    inner: src,\n                    is_sensitive: false,\n                };\n            });\n\n            let src = Bytes::copy_from_slice(src.as_ref());\n            HeaderValue {\n                inner: src,\n                is_sensitive: false,\n            }\n        }\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::from_name": [
            "/// Converts a HeaderName into a HeaderValue\n///\n/// Since every valid HeaderName is a valid HeaderValue this is done infallibly.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::{HeaderValue, HeaderName};\n/// # use http::header::ACCEPT;\n/// let val = HeaderValue::from_name(ACCEPT);\n/// assert_eq!(val, HeaderValue::from_bytes(b\"accept\").unwrap());\n/// ```\n#[inline]\npub fn from_name(name: HeaderName) -> HeaderValue{\n        name.into()\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::from_shared": [
            "fn from_shared(src: Bytes) -> Result<HeaderValue, InvalidHeaderValue>{\n        HeaderValue::try_from_generic(src, std::convert::identity)\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::from_static": [
            "/// Convert a static string to a `HeaderValue`.\n///\n/// This function will not perform any copying, however the string is\n/// checked to ensure that no invalid characters are present. Only visible\n/// ASCII characters (32-127) are permitted.\n///\n/// # Panics\n///\n/// This function panics if the argument contains invalid header value\n/// characters.\n///\n/// Until [Allow panicking in constants](https://github.com/rust-lang/rfcs/pull/2345)\n/// makes its way into stable, the panic message at compile-time is\n/// going to look cryptic, but should at least point at your header value:\n///\n/// ```text\n/// error: any use of this value will cause an error\n///   --> http/src/header/value.rs:67:17\n///    |\n/// 67 |                 ([] as [u8; 0])[0]; // Invalid header value\n///    |                 ^^^^^^^^^^^^^^^^^^\n///    |                 |\n///    |                 index out of bounds: the length is 0 but the index is 0\n///    |                 inside `HeaderValue::from_static` at http/src/header/value.rs:67:17\n///    |                 inside `INVALID_HEADER` at src/main.rs:73:33\n///    |\n///   ::: src/main.rs:73:1\n///    |\n/// 73 | const INVALID_HEADER: HeaderValue = HeaderValue::from_static(\"some value\");\n///    | ----------------------------------------------------------------------------\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert_eq!(val, \"hello\");\n/// ```\n#[inline]\n#[allow(unconditional_panic)]\npub const fn from_static(src: &'static str) -> HeaderValue{\n        let bytes = src.as_bytes();\n        let mut i = 0;\n        while i < bytes.len() {\n            if !is_visible_ascii(bytes[i]) {\n                // TODO: When msrv is bumped to larger than 1.57, this should be\n                // replaced with `panic!` macro.\n                // https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html#panic-in-const-contexts\n                //\n                // See the panics section of this method's document for details.\n                #[allow(clippy::no_effect, clippy::out_of_bounds_indexing)]\n                ([] as [u8; 0])[0]; // Invalid header value\n            }\n            i += 1;\n        }\n\n        HeaderValue {\n            inner: Bytes::from_static(bytes),\n            is_sensitive: false,\n        }\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::from_str": [
            "/// Attempt to convert a string to a `HeaderValue`.\n///\n/// If the argument contains invalid header value characters, an error is\n/// returned. Only visible ASCII characters (32-127) are permitted. Use\n/// `from_bytes` to create a `HeaderValue` that includes opaque octets\n/// (128-255).\n///\n/// This function is intended to be replaced in the future by a `TryFrom`\n/// implementation once the trait is stabilized in std.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_str(\"hello\").unwrap();\n/// assert_eq!(val, \"hello\");\n/// ```\n///\n/// An invalid value\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_str(\"\\n\");\n/// assert!(val.is_err());\n/// ```\n#[inline]\n#[allow(clippy::should_implement_trait)]\npub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue>{\n        HeaderValue::try_from_generic(src, |s| Bytes::copy_from_slice(s.as_bytes()))\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::is_empty": [
            "/// Returns true if the `HeaderValue` has a length of zero bytes.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"\");\n/// assert!(val.is_empty());\n///\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert!(!val.is_empty());\n/// ```\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::is_sensitive": [
            "/// Returns `true` if the value represents sensitive data.\n///\n/// Sensitive data could represent passwords or other data that should not\n/// be stored on disk or in memory. By marking header values as sensitive,\n/// components using this crate can be instructed to treat them with special\n/// care for security reasons. For example, caches can avoid storing\n/// sensitive values, and HPACK encoders used by HTTP/2.0 implementations\n/// can choose not to compress them.\n///\n/// Additionally, sensitive values will be masked by the `Debug`\n/// implementation of `HeaderValue`.\n///\n/// Note that sensitivity is not factored into equality or ordering.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let mut val = HeaderValue::from_static(\"my secret\");\n///\n/// val.set_sensitive(true);\n/// assert!(val.is_sensitive());\n///\n/// val.set_sensitive(false);\n/// assert!(!val.is_sensitive());\n/// ```\n#[inline]\npub fn is_sensitive(&self) -> bool{\n        self.is_sensitive\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::len": [
            "/// Returns the length of `self`.\n///\n/// This length is in bytes.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert_eq!(val.len(), 5);\n/// ```\n#[inline]\npub fn len(&self) -> usize{\n        self.as_ref().len()\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::set_sensitive": [
            "/// Mark that the header value represents sensitive information.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let mut val = HeaderValue::from_static(\"my secret\");\n///\n/// val.set_sensitive(true);\n/// assert!(val.is_sensitive());\n///\n/// val.set_sensitive(false);\n/// assert!(!val.is_sensitive());\n/// ```\n#[inline]\npub fn set_sensitive(&mut self, val: bool){\n        self.is_sensitive = val;\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::to_str": [
            "/// Yields a `&str` slice if the `HeaderValue` only contains visible ASCII\n/// chars.\n///\n/// This function will perform a scan of the header value, checking all the\n/// characters.\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert_eq!(val.to_str().unwrap(), \"hello\");\n/// ```\npub fn to_str(&self) -> Result<&str, ToStrError>{\n        let bytes = self.as_ref();\n\n        for &b in bytes {\n            if !is_visible_ascii(b) {\n                return Err(ToStrError { _priv: () });\n            }\n        }\n\n        unsafe { Ok(str::from_utf8_unchecked(bytes)) }\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::HeaderValue::try_from_generic": [
            "fn try_from_generic<T: AsRef<[u8]>, F: FnOnce(T) -> Bytes>(\n        src: T,\n        into: F,\n    ) -> Result<HeaderValue, InvalidHeaderValue>{\n        for &b in src.as_ref() {\n            if !is_valid(b) {\n                return Err(InvalidHeaderValue { _priv: () });\n            }\n        }\n        Ok(HeaderValue {\n            inner: into(src),\n            is_sensitive: false,\n        })\n    }",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::InvalidHeaderValue": [
            "/// A possible error when converting a `HeaderValue` from a string or byte\n/// slice.\npub struct InvalidHeaderValue {\n    _priv: (),\n}",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::ToStrError": [
            "/// A possible error when converting a `HeaderValue` to a string representation.\n///\n/// Header field values may contain opaque bytes, in which case it is not\n/// possible to represent the value as a string.\npub struct ToStrError {\n    _priv: (),\n}",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::is_valid": [
            "#[inline]\nfn is_valid(b: u8) -> bool{\n    b >= 32 && b != 127 || b == b'\\t'\n}",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "header::value::is_visible_ascii": [
            "const fn is_visible_ascii(b: u8) -> bool{\n    b >= 32 && b < 127 || b == b'\\t'\n}",
            "Real(LocalPath(\"src/header/value.rs\"))"
        ],
        "method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq": [
            "#[inline]\nfn eq(&self, other: &Method) -> bool{\n        *self == other.as_ref()\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::<impl std::cmp::PartialEq<method::Method> for str>::eq": [
            "#[inline]\nfn eq(&self, other: &Method) -> bool{\n        self == other.as_ref()\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::Inner": [
            "enum Inner {\n    Options,\n    Get,\n    Post,\n    Put,\n    Delete,\n    Head,\n    Trace,\n    Connect,\n    Patch,\n    // If the extension is short enough, store it inline\n    ExtensionInline(InlineExtension),\n    // Otherwise, allocate it\n    ExtensionAllocated(AllocatedExtension),\n}",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::InvalidMethod": [
            "/// A possible error value when converting `Method` from bytes.\npub struct InvalidMethod {\n    _priv: (),\n}",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::InvalidMethod::new": [
            "fn new() -> InvalidMethod{\n        InvalidMethod { _priv: () }\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::Method": [
            "/// The Request Method (VERB)\n///\n/// This type also contains constants for a number of common HTTP methods such\n/// as GET, POST, etc.\n///\n/// Currently includes 8 variants representing the 8 methods defined in\n/// [RFC 7230](https://tools.ietf.org/html/rfc7231#section-4.1), plus PATCH,\n/// and an Extension variant for all extensions.\n///\n/// # Examples\n///\n/// ```\n/// use http::Method;\n///\n/// assert_eq!(Method::GET, Method::from_bytes(b\"GET\").unwrap());\n/// assert!(Method::GET.is_idempotent());\n/// assert_eq!(Method::POST.as_str(), \"POST\");\n/// ```\npub struct Method(Inner);",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::Method::as_str": [
            "/// Return a &str representation of the HTTP method\n#[inline]\npub fn as_str(&self) -> &str{\n        match self.0 {\n            Options => \"OPTIONS\",\n            Get => \"GET\",\n            Post => \"POST\",\n            Put => \"PUT\",\n            Delete => \"DELETE\",\n            Head => \"HEAD\",\n            Trace => \"TRACE\",\n            Connect => \"CONNECT\",\n            Patch => \"PATCH\",\n            ExtensionInline(ref inline) => inline.as_str(),\n            ExtensionAllocated(ref allocated) => allocated.as_str(),\n        }\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::Method::extension_inline": [
            "fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod>{\n        let inline = InlineExtension::new(src)?;\n\n        Ok(Method(ExtensionInline(inline)))\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::Method::from_bytes": [
            "/// Converts a slice of bytes to an HTTP method.\npub fn from_bytes(src: &[u8]) -> Result<Method, InvalidMethod>{\n        match src.len() {\n            0 => Err(InvalidMethod::new()),\n            3 => match src {\n                b\"GET\" => Ok(Method(Get)),\n                b\"PUT\" => Ok(Method(Put)),\n                _ => Method::extension_inline(src),\n            },\n            4 => match src {\n                b\"POST\" => Ok(Method(Post)),\n                b\"HEAD\" => Ok(Method(Head)),\n                _ => Method::extension_inline(src),\n            },\n            5 => match src {\n                b\"PATCH\" => Ok(Method(Patch)),\n                b\"TRACE\" => Ok(Method(Trace)),\n                _ => Method::extension_inline(src),\n            },\n            6 => match src {\n                b\"DELETE\" => Ok(Method(Delete)),\n                _ => Method::extension_inline(src),\n            },\n            7 => match src {\n                b\"OPTIONS\" => Ok(Method(Options)),\n                b\"CONNECT\" => Ok(Method(Connect)),\n                _ => Method::extension_inline(src),\n            },\n            _ => {\n                if src.len() <= InlineExtension::MAX {\n                    Method::extension_inline(src)\n                } else {\n                    let allocated = AllocatedExtension::new(src)?;\n\n                    Ok(Method(ExtensionAllocated(allocated)))\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::Method::is_idempotent": [
            "/// Whether a method is considered \"idempotent\", meaning the request has\n/// the same result if executed multiple times.\n///\n/// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.2) for\n/// more words.\npub fn is_idempotent(&self) -> bool{\n        match self.0 {\n            Put | Delete => true,\n            _ => self.is_safe(),\n        }\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::Method::is_safe": [
            "/// Whether a method is considered \"safe\", meaning the request is\n/// essentially read-only.\n///\n/// See [the spec](https://tools.ietf.org/html/rfc7231#section-4.2.1)\n/// for more words.\npub fn is_safe(&self) -> bool{\n        matches!(self.0, Get | Head | Options | Trace)\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::extension::AllocatedExtension": [
            "pub struct AllocatedExtension(Box<[u8]>);",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::extension::AllocatedExtension::as_str": [
            "pub fn as_str(&self) -> &str{\n            // Safety: the invariant of AllocatedExtension ensures that self.0\n            // contains valid UTF-8.\n            unsafe { str::from_utf8_unchecked(&self.0) }\n        }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::extension::AllocatedExtension::new": [
            "pub fn new(src: &[u8]) -> Result<AllocatedExtension, InvalidMethod>{\n            let mut data: Vec<u8> = vec![0; src.len()];\n\n            write_checked(src, &mut data)?;\n\n            // Invariant: data is exactly src.len() long and write_checked\n            // ensures that the first src.len() bytes of data are valid UTF-8.\n            Ok(AllocatedExtension(data.into_boxed_slice()))\n        }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::extension::InlineExtension": [
            "pub struct InlineExtension([u8; InlineExtension::MAX], u8);",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::extension::InlineExtension::as_str": [
            "pub fn as_str(&self) -> &str{\n            let InlineExtension(ref data, len) = self;\n            // Safety: the invariant of InlineExtension ensures that the first\n            // len bytes of data contain valid UTF-8.\n            unsafe { str::from_utf8_unchecked(&data[..*len as usize]) }\n        }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::extension::InlineExtension::new": [
            "pub fn new(src: &[u8]) -> Result<InlineExtension, InvalidMethod>{\n            let mut data: [u8; InlineExtension::MAX] = Default::default();\n\n            write_checked(src, &mut data)?;\n\n            // Invariant: write_checked ensures that the first src.len() bytes\n            // of data are valid UTF-8.\n            Ok(InlineExtension(data, src.len() as u8))\n        }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "method::extension::write_checked": [
            "fn write_checked(src: &[u8], dst: &mut [u8]) -> Result<(), InvalidMethod>{\n        for (i, &b) in src.iter().enumerate() {\n            let b = METHOD_CHARS[b as usize];\n\n            if b == 0 {\n                return Err(InvalidMethod::new());\n            }\n\n            dst[i] = b;\n        }\n\n        Ok(())\n    }",
            "Real(LocalPath(\"src/method.rs\"))"
        ],
        "request::Builder": [
            "/// An HTTP request builder\n///\n/// This type can be used to construct an instance or `Request`\n/// through a builder-like pattern.\npub struct Builder {\n    inner: Result<Parts>,\n}",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::and_then": [
            "fn and_then<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts>,{\n        Builder {\n            inner: self.inner.and_then(func),\n        }\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::body": [
            "/// \"Consumes\" this builder, using the provided `body` to return a\n/// constructed `Request`.\n///\n/// # Errors\n///\n/// This function may return an error if any previously configured argument\n/// failed to parse or get converted to the internal representation. For\n/// example if an invalid `head` was specified via `header(\"Foo\",\n/// \"Bar\\r\\n\")` the error will be returned when this function is called\n/// rather than when `header` was called.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::builder()\n///     .body(())\n///     .unwrap();\n/// ```\npub fn body<T>(self, body: T) -> Result<Request<T>>{\n        self.inner.map(move |head| Request { head, body })\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::extension": [
            "/// Adds an extension to this builder\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .extension(\"My Extension\")\n///     .body(())\n///     .unwrap();\n///\n/// assert_eq!(req.extensions().get::<&'static str>(),\n///            Some(&\"My Extension\"));\n/// ```\npub fn extension<T>(self, extension: T) -> Builder\n    where\n        T: Clone + Any + Send + Sync + 'static,{\n        self.and_then(move |mut head| {\n            head.extensions.insert(extension);\n            Ok(head)\n        })\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::extensions_mut": [
            "/// Get a mutable reference to the extensions for this request builder.\n///\n/// If the builder has an error, this returns `None`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Request;\n/// let mut req = Request::builder().extension(\"My Extension\");\n/// let mut extensions = req.extensions_mut().unwrap();\n/// assert_eq!(extensions.get::<&'static str>(), Some(&\"My Extension\"));\n/// extensions.insert(5u32);\n/// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n/// ```\npub fn extensions_mut(&mut self) -> Option<&mut Extensions>{\n        self.inner.as_mut().ok().map(|h| &mut h.extensions)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::extensions_ref": [
            "/// Get a reference to the extensions for this request builder.\n///\n/// If the builder has an error, this returns `None`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Request;\n/// let req = Request::builder().extension(\"My Extension\").extension(5u32);\n/// let extensions = req.extensions_ref().unwrap();\n/// assert_eq!(extensions.get::<&'static str>(), Some(&\"My Extension\"));\n/// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n/// ```\npub fn extensions_ref(&self) -> Option<&Extensions>{\n        self.inner.as_ref().ok().map(|h| &h.extensions)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::header": [
            "/// Appends a header to this request builder.\n///\n/// This function will append the provided key/value as a header to the\n/// internal `HeaderMap` being constructed. Essentially this is equivalent\n/// to calling `HeaderMap::append`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n///\n/// let req = Request::builder()\n///     .header(\"Accept\", \"text/html\")\n///     .header(\"X-Custom-Foo\", \"bar\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn header<K, V>(self, key: K, value: V) -> Builder\n    where\n        K: TryInto<HeaderName>,\n        <K as TryInto<HeaderName>>::Error: Into<crate::Error>,\n        V: TryInto<HeaderValue>,\n        <V as TryInto<HeaderValue>>::Error: Into<crate::Error>,{\n        self.and_then(move |mut head| {\n            let name = key.try_into().map_err(Into::into)?;\n            let value = value.try_into().map_err(Into::into)?;\n            head.headers.try_append(name, value)?;\n            Ok(head)\n        })\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::headers_mut": [
            "/// Get headers on this request builder.\n///\n/// When builder has error returns None.\n///\n/// # Example\n///\n/// ```\n/// # use http::{header::HeaderValue, Request};\n/// let mut req = Request::builder();\n/// {\n///   let headers = req.headers_mut().unwrap();\n///   headers.insert(\"Accept\", HeaderValue::from_static(\"text/html\"));\n///   headers.insert(\"X-Custom-Foo\", HeaderValue::from_static(\"bar\"));\n/// }\n/// let headers = req.headers_ref().unwrap();\n/// assert_eq!( headers[\"Accept\"], \"text/html\" );\n/// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n/// ```\npub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>>{\n        self.inner.as_mut().ok().map(|h| &mut h.headers)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::headers_ref": [
            "/// Get header on this request builder.\n/// when builder has error returns None\n///\n/// # Example\n///\n/// ```\n/// # use http::Request;\n/// let req = Request::builder()\n///     .header(\"Accept\", \"text/html\")\n///     .header(\"X-Custom-Foo\", \"bar\");\n/// let headers = req.headers_ref().unwrap();\n/// assert_eq!( headers[\"Accept\"], \"text/html\" );\n/// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n/// ```\npub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>>{\n        self.inner.as_ref().ok().map(|h| &h.headers)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::method": [
            "/// Set the HTTP method for this request.\n///\n/// By default this is `GET`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .method(\"POST\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn method<T>(self, method: T) -> Builder\n    where\n        T: TryInto<Method>,\n        <T as TryInto<Method>>::Error: Into<crate::Error>,{\n        self.and_then(move |mut head| {\n            let method = method.try_into().map_err(Into::into)?;\n            head.method = method;\n            Ok(head)\n        })\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::method_ref": [
            "/// Get the HTTP Method for this request.\n///\n/// By default this is `GET`. If builder has error, returns None.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let mut req = Request::builder();\n/// assert_eq!(req.method_ref(),Some(&Method::GET));\n///\n/// req = req.method(\"POST\");\n/// assert_eq!(req.method_ref(),Some(&Method::POST));\n/// ```\npub fn method_ref(&self) -> Option<&Method>{\n        self.inner.as_ref().ok().map(|h| &h.method)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::new": [
            "/// Creates a new default instance of `Builder` to construct a `Request`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = request::Builder::new()\n///     .method(\"POST\")\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn new() -> Builder{\n        Builder::default()\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::uri": [
            "/// Set the URI for this request.\n///\n/// By default this is `/`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .uri(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn uri<T>(self, uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        self.and_then(move |mut head| {\n            head.uri = uri.try_into().map_err(Into::into)?;\n            Ok(head)\n        })\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::uri_ref": [
            "/// Get the URI for this request\n///\n/// By default this is `/`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let mut req = Request::builder();\n/// assert_eq!(req.uri_ref().unwrap(), \"/\" );\n///\n/// req = req.uri(\"https://www.rust-lang.org/\");\n/// assert_eq!(req.uri_ref().unwrap(), \"https://www.rust-lang.org/\" );\n/// ```\npub fn uri_ref(&self) -> Option<&Uri>{\n        self.inner.as_ref().ok().map(|h| &h.uri)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::version": [
            "/// Set the HTTP version for this request.\n///\n/// By default this is HTTP/1.1\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let req = Request::builder()\n///     .version(Version::HTTP_2)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn version(self, version: Version) -> Builder{\n        self.and_then(move |mut head| {\n            head.version = version;\n            Ok(head)\n        })\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Builder::version_ref": [
            "/// Get the HTTP version for this request\n///\n/// By default this is HTTP/1.1.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let mut req = Request::builder();\n/// assert_eq!(req.version_ref().unwrap(), &Version::HTTP_11 );\n///\n/// req = req.version(Version::HTTP_2);\n/// assert_eq!(req.version_ref().unwrap(), &Version::HTTP_2 );\n/// ```\npub fn version_ref(&self) -> Option<&Version>{\n        self.inner.as_ref().ok().map(|h| &h.version)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Parts": [
            "/// Component parts of an HTTP `Request`\n///\n/// The HTTP request head consists of a method, uri, version, and a set of\n/// header fields.\npub struct Parts {\n    /// The request's method\n    pub method: Method,\n\n    /// The request's URI\n    pub uri: Uri,\n\n    /// The request's version\n    pub version: Version,\n\n    /// The request's headers\n    pub headers: HeaderMap<HeaderValue>,\n\n    /// The request's extensions\n    pub extensions: Extensions,\n\n    _priv: (),\n}",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Parts::new": [
            "/// Creates a new default instance of `Parts`\nfn new() -> Parts{\n        Parts {\n            method: Method::default(),\n            uri: Uri::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request": [
            "/// Represents an HTTP request.\n///\n/// An HTTP request consists of a head and a potentially optional body. The body\n/// component is generic, enabling arbitrary types to represent the HTTP body.\n/// For example, the body could be `Vec<u8>`, a `Stream` of byte chunks, or a\n/// value that has been deserialized.\n///\n/// # Examples\n///\n/// Creating a `Request` to send\n///\n/// ```no_run\n/// use http::{Request, Response};\n///\n/// let mut request = Request::builder()\n///     .uri(\"https://www.rust-lang.org/\")\n///     .header(\"User-Agent\", \"my-awesome-agent/1.0\");\n///\n/// if needs_awesome_header() {\n///     request = request.header(\"Awesome\", \"yes\");\n/// }\n///\n/// let response = send(request.body(()).unwrap());\n///\n/// # fn needs_awesome_header() -> bool {\n/// #     true\n/// # }\n/// #\n/// fn send(req: Request<()>) -> Response<()> {\n///     // ...\n/// # panic!()\n/// }\n/// ```\n///\n/// Inspecting a request to see what was sent.\n///\n/// ```\n/// use http::{Request, Response, StatusCode};\n///\n/// fn respond_to(req: Request<()>) -> http::Result<Response<()>> {\n///     if req.uri() != \"/awesome-url\" {\n///         return Response::builder()\n///             .status(StatusCode::NOT_FOUND)\n///             .body(())\n///     }\n///\n///     let has_awesome_header = req.headers().contains_key(\"Awesome\");\n///     let body = req.body();\n///\n///     // ...\n/// # panic!()\n/// }\n/// ```\n///\n/// Deserialize a request of bytes via json:\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Request;\n/// use serde::de;\n///\n/// fn deserialize<T>(req: Request<Vec<u8>>) -> serde_json::Result<Request<T>>\n///     where for<'de> T: de::Deserialize<'de>,\n/// {\n///     let (parts, body) = req.into_parts();\n///     let body = serde_json::from_slice(&body)?;\n///     Ok(Request::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\n///\n/// Or alternatively, serialize the body of a request to json\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Request;\n/// use serde::ser;\n///\n/// fn serialize<T>(req: Request<T>) -> serde_json::Result<Request<Vec<u8>>>\n///     where T: ser::Serialize,\n/// {\n///     let (parts, body) = req.into_parts();\n///     let body = serde_json::to_vec(&body)?;\n///     Ok(Request::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\npub struct Request<T> {\n    head: Parts,\n    body: T,\n}",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<()>::builder": [
            "/// Creates a new builder-style object to manufacture a `Request`\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::builder()\n///     .method(\"GET\")\n///     .uri(\"https://www.rust-lang.org/\")\n///     .header(\"X-Custom-Foo\", \"Bar\")\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn builder() -> Builder{\n        Builder::new()\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<()>::connect": [
            "/// Creates a new `Builder` initialized with a CONNECT method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::connect(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn connect<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::CONNECT).uri(uri)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<()>::delete": [
            "/// Creates a new `Builder` initialized with a DELETE method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::delete(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn delete<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::DELETE).uri(uri)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<()>::get": [
            "/// Creates a new `Builder` initialized with a GET method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::get(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn get<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::GET).uri(uri)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<()>::head": [
            "/// Creates a new `Builder` initialized with a HEAD method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::head(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn head<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::HEAD).uri(uri)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<()>::options": [
            "/// Creates a new `Builder` initialized with an OPTIONS method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::options(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// # assert_eq!(*request.method(), Method::OPTIONS);\n/// ```\npub fn options<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::OPTIONS).uri(uri)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<()>::patch": [
            "/// Creates a new `Builder` initialized with a PATCH method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::patch(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn patch<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::PATCH).uri(uri)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<()>::post": [
            "/// Creates a new `Builder` initialized with a POST method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::post(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn post<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::POST).uri(uri)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<()>::put": [
            "/// Creates a new `Builder` initialized with a PUT method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::put(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn put<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::PUT).uri(uri)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<()>::trace": [
            "/// Creates a new `Builder` initialized with a TRACE method and the given URI.\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Request`.\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n///\n/// let request = Request::trace(\"https://www.rust-lang.org/\")\n///     .body(())\n///     .unwrap();\n/// ```\npub fn trace<T>(uri: T) -> Builder\n    where\n        T: TryInto<Uri>,\n        <T as TryInto<Uri>>::Error: Into<crate::Error>,{\n        Builder::new().method(Method::TRACE).uri(uri)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::body": [
            "/// Returns a reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<String> = Request::default();\n/// assert!(request.body().is_empty());\n/// ```\n#[inline]\npub fn body(&self) -> &T{\n        &self.body\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::body_mut": [
            "/// Returns a mutable reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<String> = Request::default();\n/// request.body_mut().push_str(\"hello world\");\n/// assert!(!request.body().is_empty());\n/// ```\n#[inline]\npub fn body_mut(&mut self) -> &mut T{\n        &mut self.body\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::extensions": [
            "/// Returns a reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert!(request.extensions().get::<i32>().is_none());\n/// ```\n#[inline]\npub fn extensions(&self) -> &Extensions{\n        &self.head.extensions\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::extensions_mut": [
            "/// Returns a mutable reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut request: Request<()> = Request::default();\n/// request.extensions_mut().insert(\"hello\");\n/// assert_eq!(request.extensions().get(), Some(&\"hello\"));\n/// ```\n#[inline]\npub fn extensions_mut(&mut self) -> &mut Extensions{\n        &mut self.head.extensions\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::from_parts": [
            "/// Creates a new `Request` with the given components parts and body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::new(\"hello world\");\n/// let (mut parts, body) = request.into_parts();\n/// parts.method = Method::POST;\n///\n/// let request = Request::from_parts(parts, body);\n/// ```\n#[inline]\npub fn from_parts(parts: Parts, body: T) -> Request<T>{\n        Request { head: parts, body }\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::headers": [
            "/// Returns a reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert!(request.headers().is_empty());\n/// ```\n#[inline]\npub fn headers(&self) -> &HeaderMap<HeaderValue>{\n        &self.head.headers\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::headers_mut": [
            "/// Returns a mutable reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut request: Request<()> = Request::default();\n/// request.headers_mut().insert(HOST, HeaderValue::from_static(\"world\"));\n/// assert!(!request.headers().is_empty());\n/// ```\n#[inline]\npub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue>{\n        &mut self.head.headers\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::into_body": [
            "/// Consumes the request, returning just the body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::Request;\n/// let request = Request::new(10);\n/// let body = request.into_body();\n/// assert_eq!(body, 10);\n/// ```\n#[inline]\npub fn into_body(self) -> T{\n        self.body\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::into_parts": [
            "/// Consumes the request returning the head and body parts.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::new(());\n/// let (parts, body) = request.into_parts();\n/// assert_eq!(parts.method, Method::GET);\n/// ```\n#[inline]\npub fn into_parts(self) -> (Parts, T){\n        (self.head, self.body)\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::map": [
            "/// Consumes the request returning a new request with body mapped to the\n/// return type of the passed in function.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::builder().body(\"some string\").unwrap();\n/// let mapped_request: Request<&[u8]> = request.map(|b| {\n///   assert_eq!(b, \"some string\");\n///   b.as_bytes()\n/// });\n/// assert_eq!(mapped_request.body(), &\"some string\".as_bytes());\n/// ```\n#[inline]\npub fn map<F, U>(self, f: F) -> Request<U>\n    where\n        F: FnOnce(T) -> U,{\n        Request {\n            body: f(self.body),\n            head: self.head,\n        }\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::method": [
            "/// Returns a reference to the associated HTTP method.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert_eq!(*request.method(), Method::GET);\n/// ```\n#[inline]\npub fn method(&self) -> &Method{\n        &self.head.method\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::method_mut": [
            "/// Returns a mutable reference to the associated HTTP method.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<()> = Request::default();\n/// *request.method_mut() = Method::PUT;\n/// assert_eq!(*request.method(), Method::PUT);\n/// ```\n#[inline]\npub fn method_mut(&mut self) -> &mut Method{\n        &mut self.head.method\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::new": [
            "/// Creates a new blank `Request` with the body\n///\n/// The component parts of this request will be set to their default, e.g.\n/// the GET method, no headers, etc.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request = Request::new(\"hello world\");\n///\n/// assert_eq!(*request.method(), Method::GET);\n/// assert_eq!(*request.body(), \"hello world\");\n/// ```\n#[inline]\npub fn new(body: T) -> Request<T>{\n        Request {\n            head: Parts::new(),\n            body,\n        }\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::uri": [
            "/// Returns a reference to the associated URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert_eq!(*request.uri(), *\"/\");\n/// ```\n#[inline]\npub fn uri(&self) -> &Uri{\n        &self.head.uri\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::uri_mut": [
            "/// Returns a mutable reference to the associated URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<()> = Request::default();\n/// *request.uri_mut() = \"/hello\".parse().unwrap();\n/// assert_eq!(*request.uri(), *\"/hello\");\n/// ```\n#[inline]\npub fn uri_mut(&mut self) -> &mut Uri{\n        &mut self.head.uri\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::version": [
            "/// Returns the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let request: Request<()> = Request::default();\n/// assert_eq!(request.version(), Version::HTTP_11);\n/// ```\n#[inline]\npub fn version(&self) -> Version{\n        self.head.version\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "request::Request::<T>::version_mut": [
            "/// Returns a mutable reference to the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut request: Request<()> = Request::default();\n/// *request.version_mut() = Version::HTTP_2;\n/// assert_eq!(request.version(), Version::HTTP_2);\n/// ```\n#[inline]\npub fn version_mut(&mut self) -> &mut Version{\n        &mut self.head.version\n    }",
            "Real(LocalPath(\"src/request.rs\"))"
        ],
        "response::Builder": [
            "/// An HTTP response builder\n///\n/// This type can be used to construct an instance of `Response` through a\n/// builder-like pattern.\npub struct Builder {\n    inner: Result<Parts>,\n}",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::and_then": [
            "fn and_then<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts>,{\n        Builder {\n            inner: self.inner.and_then(func),\n        }\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::body": [
            "/// \"Consumes\" this builder, using the provided `body` to return a\n/// constructed `Response`.\n///\n/// # Errors\n///\n/// This function may return an error if any previously configured argument\n/// failed to parse or get converted to the internal representation. For\n/// example if an invalid `head` was specified via `header(\"Foo\",\n/// \"Bar\\r\\n\")` the error will be returned when this function is called\n/// rather than when `header` was called.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .body(())\n///     .unwrap();\n/// ```\npub fn body<T>(self, body: T) -> Result<Response<T>>{\n        self.inner.map(move |head| Response { head, body })\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::extension": [
            "/// Adds an extension to this builder\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .extension(\"My Extension\")\n///     .body(())\n///     .unwrap();\n///\n/// assert_eq!(response.extensions().get::<&'static str>(),\n///            Some(&\"My Extension\"));\n/// ```\npub fn extension<T>(self, extension: T) -> Builder\n    where\n        T: Clone + Any + Send + Sync + 'static,{\n        self.and_then(move |mut head| {\n            head.extensions.insert(extension);\n            Ok(head)\n        })\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::extensions_mut": [
            "/// Get a mutable reference to the extensions for this response builder.\n///\n/// If the builder has an error, this returns `None`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Response;\n/// let mut res = Response::builder().extension(\"My Extension\");\n/// let mut extensions = res.extensions_mut().unwrap();\n/// assert_eq!(extensions.get::<&'static str>(), Some(&\"My Extension\"));\n/// extensions.insert(5u32);\n/// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n/// ```\npub fn extensions_mut(&mut self) -> Option<&mut Extensions>{\n        self.inner.as_mut().ok().map(|h| &mut h.extensions)\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::extensions_ref": [
            "/// Get a reference to the extensions for this response builder.\n///\n/// If the builder has an error, this returns `None`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Response;\n/// let res = Response::builder().extension(\"My Extension\").extension(5u32);\n/// let extensions = res.extensions_ref().unwrap();\n/// assert_eq!(extensions.get::<&'static str>(), Some(&\"My Extension\"));\n/// assert_eq!(extensions.get::<u32>(), Some(&5u32));\n/// ```\npub fn extensions_ref(&self) -> Option<&Extensions>{\n        self.inner.as_ref().ok().map(|h| &h.extensions)\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::header": [
            "/// Appends a header to this response builder.\n///\n/// This function will append the provided key/value as a header to the\n/// internal `HeaderMap` being constructed. Essentially this is equivalent\n/// to calling `HeaderMap::append`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n///\n/// let response = Response::builder()\n///     .header(\"Content-Type\", \"text/html\")\n///     .header(\"X-Custom-Foo\", \"bar\")\n///     .header(\"content-length\", 0)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn header<K, V>(self, key: K, value: V) -> Builder\n    where\n        K: TryInto<HeaderName>,\n        <K as TryInto<HeaderName>>::Error: Into<crate::Error>,\n        V: TryInto<HeaderValue>,\n        <V as TryInto<HeaderValue>>::Error: Into<crate::Error>,{\n        self.and_then(move |mut head| {\n            let name = key.try_into().map_err(Into::into)?;\n            let value = value.try_into().map_err(Into::into)?;\n            head.headers.try_append(name, value)?;\n            Ok(head)\n        })\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::headers_mut": [
            "/// Get header on this response builder.\n/// when builder has error returns None\n///\n/// # Example\n///\n/// ```\n/// # use http::*;\n/// # use http::header::HeaderValue;\n/// # use http::response::Builder;\n/// let mut res = Response::builder();\n/// {\n///   let headers = res.headers_mut().unwrap();\n///   headers.insert(\"Accept\", HeaderValue::from_static(\"text/html\"));\n///   headers.insert(\"X-Custom-Foo\", HeaderValue::from_static(\"bar\"));\n/// }\n/// let headers = res.headers_ref().unwrap();\n/// assert_eq!( headers[\"Accept\"], \"text/html\" );\n/// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n/// ```\npub fn headers_mut(&mut self) -> Option<&mut HeaderMap<HeaderValue>>{\n        self.inner.as_mut().ok().map(|h| &mut h.headers)\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::headers_ref": [
            "/// Get header on this response builder.\n///\n/// When builder has error returns None.\n///\n/// # Example\n///\n/// ```\n/// # use http::Response;\n/// # use http::header::HeaderValue;\n/// let res = Response::builder()\n///     .header(\"Accept\", \"text/html\")\n///     .header(\"X-Custom-Foo\", \"bar\");\n/// let headers = res.headers_ref().unwrap();\n/// assert_eq!( headers[\"Accept\"], \"text/html\" );\n/// assert_eq!( headers[\"X-Custom-Foo\"], \"bar\" );\n/// ```\npub fn headers_ref(&self) -> Option<&HeaderMap<HeaderValue>>{\n        self.inner.as_ref().ok().map(|h| &h.headers)\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::new": [
            "/// Creates a new default instance of `Builder` to construct either a\n/// `Head` or a `Response`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = response::Builder::new()\n///     .status(200)\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn new() -> Builder{\n        Builder::default()\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::status": [
            "/// Set the HTTP status for this response.\n///\n/// By default this is `200`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .status(200)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn status<T>(self, status: T) -> Builder\n    where\n        T: TryInto<StatusCode>,\n        <T as TryInto<StatusCode>>::Error: Into<crate::Error>,{\n        self.and_then(move |mut head| {\n            head.status = status.try_into().map_err(Into::into)?;\n            Ok(head)\n        })\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Builder::version": [
            "/// Set the HTTP version for this response.\n///\n/// By default this is HTTP/1.1\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let response = Response::builder()\n///     .version(Version::HTTP_2)\n///     .body(())\n///     .unwrap();\n/// ```\npub fn version(self, version: Version) -> Builder{\n        self.and_then(move |mut head| {\n            head.version = version;\n            Ok(head)\n        })\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Parts": [
            "/// Component parts of an HTTP `Response`\n///\n/// The HTTP response head consists of a status, version, and a set of\n/// header fields.\npub struct Parts {\n    /// The response's status\n    pub status: StatusCode,\n\n    /// The response's version\n    pub version: Version,\n\n    /// The response's headers\n    pub headers: HeaderMap<HeaderValue>,\n\n    /// The response's extensions\n    pub extensions: Extensions,\n\n    _priv: (),\n}",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Parts::new": [
            "/// Creates a new default instance of `Parts`\nfn new() -> Parts{\n        Parts {\n            status: StatusCode::default(),\n            version: Version::default(),\n            headers: HeaderMap::default(),\n            extensions: Extensions::default(),\n            _priv: (),\n        }\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response": [
            "/// Represents an HTTP response\n///\n/// An HTTP response consists of a head and a potentially optional body. The body\n/// component is generic, enabling arbitrary types to represent the HTTP body.\n/// For example, the body could be `Vec<u8>`, a `Stream` of byte chunks, or a\n/// value that has been deserialized.\n///\n/// Typically you'll work with responses on the client side as the result of\n/// sending a `Request` and on the server you'll be generating a `Response` to\n/// send back to the client.\n///\n/// # Examples\n///\n/// Creating a `Response` to return\n///\n/// ```\n/// use http::{Request, Response, StatusCode};\n///\n/// fn respond_to(req: Request<()>) -> http::Result<Response<()>> {\n///     let mut builder = Response::builder()\n///         .header(\"Foo\", \"Bar\")\n///         .status(StatusCode::OK);\n///\n///     if req.headers().contains_key(\"Another-Header\") {\n///         builder = builder.header(\"Another-Header\", \"Ack\");\n///     }\n///\n///     builder.body(())\n/// }\n/// ```\n///\n/// A simple 404 handler\n///\n/// ```\n/// use http::{Request, Response, StatusCode};\n///\n/// fn not_found(_req: Request<()>) -> http::Result<Response<()>> {\n///     Response::builder()\n///         .status(StatusCode::NOT_FOUND)\n///         .body(())\n/// }\n/// ```\n///\n/// Or otherwise inspecting the result of a request:\n///\n/// ```no_run\n/// use http::{Request, Response};\n///\n/// fn get(url: &str) -> http::Result<Response<()>> {\n///     // ...\n/// # panic!()\n/// }\n///\n/// let response = get(\"https://www.rust-lang.org/\").unwrap();\n///\n/// if !response.status().is_success() {\n///     panic!(\"failed to get a successful response status!\");\n/// }\n///\n/// if let Some(date) = response.headers().get(\"Date\") {\n///     // we've got a `Date` header!\n/// }\n///\n/// let body = response.body();\n/// // ...\n/// ```\n///\n/// Deserialize a response of bytes via json:\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Response;\n/// use serde::de;\n///\n/// fn deserialize<T>(res: Response<Vec<u8>>) -> serde_json::Result<Response<T>>\n///     where for<'de> T: de::Deserialize<'de>,\n/// {\n///     let (parts, body) = res.into_parts();\n///     let body = serde_json::from_slice(&body)?;\n///     Ok(Response::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\n///\n/// Or alternatively, serialize the body of a response to json\n///\n/// ```\n/// # extern crate serde;\n/// # extern crate serde_json;\n/// # extern crate http;\n/// use http::Response;\n/// use serde::ser;\n///\n/// fn serialize<T>(res: Response<T>) -> serde_json::Result<Response<Vec<u8>>>\n///     where T: ser::Serialize,\n/// {\n///     let (parts, body) = res.into_parts();\n///     let body = serde_json::to_vec(&body)?;\n///     Ok(Response::from_parts(parts, body))\n/// }\n/// #\n/// # fn main() {}\n/// ```\npub struct Response<T> {\n    head: Parts,\n    body: T,\n}",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<()>::builder": [
            "/// Creates a new builder-style object to manufacture a `Response`\n///\n/// This method returns an instance of `Builder` which can be used to\n/// create a `Response`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::builder()\n///     .status(200)\n///     .header(\"X-Custom-Foo\", \"Bar\")\n///     .body(())\n///     .unwrap();\n/// ```\n#[inline]\npub fn builder() -> Builder{\n        Builder::new()\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::body": [
            "/// Returns a reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<String> = Response::default();\n/// assert!(response.body().is_empty());\n/// ```\n#[inline]\npub fn body(&self) -> &T{\n        &self.body\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::body_mut": [
            "/// Returns a mutable reference to the associated HTTP body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut response: Response<String> = Response::default();\n/// response.body_mut().push_str(\"hello world\");\n/// assert!(!response.body().is_empty());\n/// ```\n#[inline]\npub fn body_mut(&mut self) -> &mut T{\n        &mut self.body\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::extensions": [
            "/// Returns a reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert!(response.extensions().get::<i32>().is_none());\n/// ```\n#[inline]\npub fn extensions(&self) -> &Extensions{\n        &self.head.extensions\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::extensions_mut": [
            "/// Returns a mutable reference to the associated extensions.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut response: Response<()> = Response::default();\n/// response.extensions_mut().insert(\"hello\");\n/// assert_eq!(response.extensions().get(), Some(&\"hello\"));\n/// ```\n#[inline]\npub fn extensions_mut(&mut self) -> &mut Extensions{\n        &mut self.head.extensions\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::from_parts": [
            "/// Creates a new `Response` with the given head and body\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::new(\"hello world\");\n/// let (mut parts, body) = response.into_parts();\n///\n/// parts.status = StatusCode::BAD_REQUEST;\n/// let response = Response::from_parts(parts, body);\n///\n/// assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n/// assert_eq!(*response.body(), \"hello world\");\n/// ```\n#[inline]\npub fn from_parts(parts: Parts, body: T) -> Response<T>{\n        Response { head: parts, body }\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::headers": [
            "/// Returns a reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert!(response.headers().is_empty());\n/// ```\n#[inline]\npub fn headers(&self) -> &HeaderMap<HeaderValue>{\n        &self.head.headers\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::headers_mut": [
            "/// Returns a mutable reference to the associated header field map.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// # use http::header::*;\n/// let mut response: Response<()> = Response::default();\n/// response.headers_mut().insert(HOST, HeaderValue::from_static(\"world\"));\n/// assert!(!response.headers().is_empty());\n/// ```\n#[inline]\npub fn headers_mut(&mut self) -> &mut HeaderMap<HeaderValue>{\n        &mut self.head.headers\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::into_body": [
            "/// Consumes the response, returning just the body.\n///\n/// # Examples\n///\n/// ```\n/// # use http::Response;\n/// let response = Response::new(10);\n/// let body = response.into_body();\n/// assert_eq!(body, 10);\n/// ```\n#[inline]\npub fn into_body(self) -> T{\n        self.body\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::into_parts": [
            "/// Consumes the response returning the head and body parts.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// let (parts, body) = response.into_parts();\n/// assert_eq!(parts.status, StatusCode::OK);\n/// ```\n#[inline]\npub fn into_parts(self) -> (Parts, T){\n        (self.head, self.body)\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::map": [
            "/// Consumes the response returning a new response with body mapped to the\n/// return type of the passed in function.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::builder().body(\"some string\").unwrap();\n/// let mapped_response: Response<&[u8]> = response.map(|b| {\n///   assert_eq!(b, \"some string\");\n///   b.as_bytes()\n/// });\n/// assert_eq!(mapped_response.body(), &\"some string\".as_bytes());\n/// ```\n#[inline]\npub fn map<F, U>(self, f: F) -> Response<U>\n    where\n        F: FnOnce(T) -> U,{\n        Response {\n            body: f(self.body),\n            head: self.head,\n        }\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::new": [
            "/// Creates a new blank `Response` with the body\n///\n/// The component parts of this response will be set to their default, e.g.\n/// the ok status, no headers, etc.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response = Response::new(\"hello world\");\n///\n/// assert_eq!(response.status(), StatusCode::OK);\n/// assert_eq!(*response.body(), \"hello world\");\n/// ```\n#[inline]\npub fn new(body: T) -> Response<T>{\n        Response {\n            head: Parts::new(),\n            body,\n        }\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::status": [
            "/// Returns the `StatusCode`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert_eq!(response.status(), StatusCode::OK);\n/// ```\n#[inline]\npub fn status(&self) -> StatusCode{\n        self.head.status\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::status_mut": [
            "/// Returns a mutable reference to the associated `StatusCode`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut response: Response<()> = Response::default();\n/// *response.status_mut() = StatusCode::CREATED;\n/// assert_eq!(response.status(), StatusCode::CREATED);\n/// ```\n#[inline]\npub fn status_mut(&mut self) -> &mut StatusCode{\n        &mut self.head.status\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::version": [
            "/// Returns a reference to the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let response: Response<()> = Response::default();\n/// assert_eq!(response.version(), Version::HTTP_11);\n/// ```\n#[inline]\npub fn version(&self) -> Version{\n        self.head.version\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "response::Response::<T>::version_mut": [
            "/// Returns a mutable reference to the associated version.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n/// let mut response: Response<()> = Response::default();\n/// *response.version_mut() = Version::HTTP_2;\n/// assert_eq!(response.version(), Version::HTTP_2);\n/// ```\n#[inline]\npub fn version_mut(&mut self) -> &mut Version{\n        &mut self.head.version\n    }",
            "Real(LocalPath(\"src/response.rs\"))"
        ],
        "status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq": [
            "#[inline]\nfn eq(&self, other: &StatusCode) -> bool{\n        *self == other.as_u16()\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::<impl std::convert::From<status::StatusCode> for u16>::from": [
            "#[inline]\nfn from(status: StatusCode) -> u16{\n        status.0.get()\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::InvalidStatusCode": [
            "/// A possible error value when converting a `StatusCode` from a `u16` or `&str`.\n///\n/// This error indicates that the supplied input was not a valid number, was less\n/// than 100, or was greater than 999.\npub struct InvalidStatusCode {\n    _priv: (),\n}",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::InvalidStatusCode::new": [
            "fn new() -> InvalidStatusCode{\n        InvalidStatusCode { _priv: () }\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode": [
            "/// An HTTP status code (`status-code` in RFC 9110 et al.).\n///\n/// Constants are provided for known status codes, including those in the IANA\n/// [HTTP Status Code Registry](\n/// https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml).\n///\n/// Status code values in the range 100-999 (inclusive) are supported by this\n/// type. Values in the range 100-599 are semantically classified by the most\n/// significant digit. See [`StatusCode::is_success`], etc. Values above 599\n/// are unclassified but allowed for legacy compatibility, though their use is\n/// discouraged. Applications may interpret such values as protocol errors.\n///\n/// # Examples\n///\n/// ```\n/// use http::StatusCode;\n///\n/// assert_eq!(StatusCode::from_u16(200).unwrap(), StatusCode::OK);\n/// assert_eq!(StatusCode::NOT_FOUND.as_u16(), 404);\n/// assert!(StatusCode::OK.is_success());\n/// ```\npub struct StatusCode(NonZeroU16);",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode::as_str": [
            "/// Returns a &str representation of the `StatusCode`\n///\n/// The return value only includes a numerical representation of the\n/// status code. The canonical reason is not included.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.as_str(), \"200\");\n/// ```\n#[inline]\npub fn as_str(&self) -> &str{\n        let offset = (self.0.get() - 100) as usize;\n        let offset = offset * 3;\n\n        // Invariant: self has checked range [100, 999] and CODE_DIGITS is\n        // ASCII-only, of length 900 * 3 = 2700 bytes\n\n        #[cfg(debug_assertions)]\n        {\n            &CODE_DIGITS[offset..offset + 3]\n        }\n\n        #[cfg(not(debug_assertions))]\n        unsafe {\n            CODE_DIGITS.get_unchecked(offset..offset + 3)\n        }\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode::as_u16": [
            "/// Returns the `u16` corresponding to this `StatusCode`.\n///\n/// # Note\n///\n/// This is the same as the `From<StatusCode>` implementation, but\n/// included as an inherent method because that implementation doesn't\n/// appear in rustdocs, as well as a way to force the type instead of\n/// relying on inference.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.as_u16(), 200);\n/// ```\n#[inline]\npub const fn as_u16(&self) -> u16{\n        self.0.get()\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode::canonical_reason": [
            "/// Get the standardised `reason-phrase` for this status code.\n///\n/// This is mostly here for servers writing responses, but could potentially have application\n/// at other times.\n///\n/// The reason phrase is defined as being exclusively for human readers. You should avoid\n/// deriving any meaning from it at all costs.\n///\n/// Bear in mind also that in HTTP/2.0 and HTTP/3.0 the reason phrase is abolished from\n/// transmission, and so this canonical reason phrase really is the only reason phrase youll\n/// find.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.canonical_reason(), Some(\"OK\"));\n/// ```\npub fn canonical_reason(&self) -> Option<&'static str>{\n        canonical_reason(self.0.get())\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode::from_bytes": [
            "/// Converts a `&[u8]` to a status code.\npub fn from_bytes(src: &[u8]) -> Result<StatusCode, InvalidStatusCode>{\n        if src.len() != 3 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let a = src[0].wrapping_sub(b'0') as u16;\n        let b = src[1].wrapping_sub(b'0') as u16;\n        let c = src[2].wrapping_sub(b'0') as u16;\n\n        if a == 0 || a > 9 || b > 9 || c > 9 {\n            return Err(InvalidStatusCode::new());\n        }\n\n        let status = (a * 100) + (b * 10) + c;\n        NonZeroU16::new(status)\n            .map(StatusCode)\n            .ok_or_else(InvalidStatusCode::new)\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode::from_u16": [
            "/// Converts a u16 to a status code.\n///\n/// The function validates the correctness of the supplied u16. It must be\n/// greater or equal to 100 and less than 1000.\n///\n/// # Example\n///\n/// ```\n/// use http::StatusCode;\n///\n/// let ok = StatusCode::from_u16(200).unwrap();\n/// assert_eq!(ok, StatusCode::OK);\n///\n/// let err = StatusCode::from_u16(99);\n/// assert!(err.is_err());\n/// ```\n#[inline]\npub fn from_u16(src: u16) -> Result<StatusCode, InvalidStatusCode>{\n        if !(100..1000).contains(&src) {\n            return Err(InvalidStatusCode::new());\n        }\n\n        NonZeroU16::new(src)\n            .map(StatusCode)\n            .ok_or_else(InvalidStatusCode::new)\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode::is_client_error": [
            "/// Check if status is within 400-499.\n#[inline]\npub fn is_client_error(&self) -> bool{\n        (400..500).contains(&self.0.get())\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode::is_informational": [
            "/// Check if status is within 100-199.\n#[inline]\npub fn is_informational(&self) -> bool{\n        (100..200).contains(&self.0.get())\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode::is_redirection": [
            "/// Check if status is within 300-399.\n#[inline]\npub fn is_redirection(&self) -> bool{\n        (300..400).contains(&self.0.get())\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode::is_server_error": [
            "/// Check if status is within 500-599.\n#[inline]\npub fn is_server_error(&self) -> bool{\n        (500..600).contains(&self.0.get())\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::StatusCode::is_success": [
            "/// Check if status is within 200-299.\n#[inline]\npub fn is_success(&self) -> bool{\n        (200..300).contains(&self.0.get())\n    }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "status::canonical_reason": [
            "fn canonical_reason(num: u16) -> Option<&'static str>{\n            match num {\n                $(\n                $num => Some($phrase),\n                )+\n                _ => None\n            }\n        }",
            "Real(LocalPath(\"src/status.rs\"))"
        ],
        "uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq": [
            "fn eq(&self, uri: &Uri) -> bool{\n        uri == *self\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq": [
            "fn eq(&self, uri: &Uri) -> bool{\n        uri == self\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::ErrorKind": [
            "enum ErrorKind {\n    InvalidUriChar,\n    InvalidScheme,\n    InvalidAuthority,\n    InvalidPort,\n    InvalidFormat,\n    SchemeMissing,\n    AuthorityMissing,\n    PathAndQueryMissing,\n    TooLong,\n    Empty,\n    SchemeTooLong,\n}",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::InvalidUri": [
            "/// An error resulting from a failed attempt to construct a URI.\npub struct InvalidUri(ErrorKind);",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::InvalidUri::s": [
            "fn s(&self) -> &str{\n        match self.0 {\n            ErrorKind::InvalidUriChar => \"invalid uri character\",\n            ErrorKind::InvalidScheme => \"invalid scheme\",\n            ErrorKind::InvalidAuthority => \"invalid authority\",\n            ErrorKind::InvalidPort => \"invalid port\",\n            ErrorKind::InvalidFormat => \"invalid format\",\n            ErrorKind::SchemeMissing => \"scheme missing\",\n            ErrorKind::AuthorityMissing => \"authority missing\",\n            ErrorKind::PathAndQueryMissing => \"path missing\",\n            ErrorKind::TooLong => \"uri too long\",\n            ErrorKind::Empty => \"empty string\",\n            ErrorKind::SchemeTooLong => \"scheme too long\",\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::InvalidUriParts": [
            "/// An error resulting from a failed attempt to construct a URI.\npub struct InvalidUriParts(InvalidUri);",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Parts": [
            "/// The various parts of a URI.\n///\n/// This struct is used to provide to and retrieve from a URI.\npub struct Parts {\n    /// The scheme component of a URI\n    pub scheme: Option<Scheme>,\n\n    /// The authority component of a URI\n    pub authority: Option<Authority>,\n\n    /// The origin-form component of a URI\n    pub path_and_query: Option<PathAndQuery>,\n\n    /// Allow extending in the future\n    _priv: (),\n}",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri": [
            "/// The URI component of a request.\n///\n/// For HTTP 1, this is included as part of the request line. From Section 5.3,\n/// Request Target:\n///\n/// > Once an inbound connection is obtained, the client sends an HTTP\n/// > request message (Section 3) with a request-target derived from the\n/// > target URI.  There are four distinct formats for the request-target,\n/// > depending on both the method being requested and whether the request\n/// > is to a proxy.\n/// >\n/// > ```notrust\n/// > request-target = origin-form\n/// >                / absolute-form\n/// >                / authority-form\n/// >                / asterisk-form\n/// > ```\n///\n/// The URI is structured as follows:\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n/// |-|   |-------------------------------||--------| |-------------------| |-----|\n///  |                  |                       |               |              |\n/// scheme          authority                 path            query         fragment\n/// ```\n///\n/// For HTTP 2.0, the URI is encoded using pseudoheaders.\n///\n/// # Examples\n///\n/// ```\n/// use http::Uri;\n///\n/// let uri = \"/foo/bar?baz\".parse::<Uri>().unwrap();\n/// assert_eq!(uri.path(), \"/foo/bar\");\n/// assert_eq!(uri.query(), Some(\"baz\"));\n/// assert_eq!(uri.host(), None);\n///\n/// let uri = \"https://www.rust-lang.org/install.html\".parse::<Uri>().unwrap();\n/// assert_eq!(uri.scheme_str(), Some(\"https\"));\n/// assert_eq!(uri.host(), Some(\"www.rust-lang.org\"));\n/// assert_eq!(uri.path(), \"/install.html\");\n/// ```\npub struct Uri {\n    scheme: Scheme,\n    authority: Authority,\n    path_and_query: PathAndQuery,\n}",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::authority": [
            "/// Get the authority of this `Uri`.\n///\n/// The authority is a hierarchical element for naming authority such that\n/// the remainder of the URI is delegated to that authority. For HTTP, the\n/// authority consists of the host and port. The host portion of the\n/// authority is **case-insensitive**.\n///\n/// The authority also includes a `username:password` component, however\n/// the use of this is deprecated and should be avoided.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///       |-------------------------------|\n///                     |\n///                 authority\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.authority().map(|a| a.as_str()), Some(\"example.org:80\"));\n/// ```\n///\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert!(uri.authority().is_none());\n/// ```\n#[inline]\npub fn authority(&self) -> Option<&Authority>{\n        if self.authority.data.is_empty() {\n            None\n        } else {\n            Some(&self.authority)\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::builder": [
            "/// Creates a new builder-style object to manufacture a `Uri`.\n///\n/// This method returns an instance of `Builder` which can be usd to\n/// create a `Uri`.\n///\n/// # Examples\n///\n/// ```\n/// use http::Uri;\n///\n/// let uri = Uri::builder()\n///     .scheme(\"https\")\n///     .authority(\"hyper.rs\")\n///     .path_and_query(\"/\")\n///     .build()\n///     .unwrap();\n/// ```\npub fn builder() -> Builder{\n        Builder::new()\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::from_maybe_shared": [
            "/// Attempt to convert a `Bytes` buffer to a `Uri`.\n///\n/// This will try to prevent a copy if the type passed is the type used\n/// internally, and will copy the data if it is not.\npub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + 'static,{\n        if_downcast_into!(T, Bytes, src, {\n            return Uri::from_shared(src);\n        });\n\n        Uri::try_from(src.as_ref())\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::from_parts": [
            "/// Attempt to convert a `Parts` into a `Uri`.\n///\n/// # Examples\n///\n/// Relative URI\n///\n/// ```\n/// # use http::uri::*;\n/// let mut parts = Parts::default();\n/// parts.path_and_query = Some(\"/foo\".parse().unwrap());\n///\n/// let uri = Uri::from_parts(parts).unwrap();\n///\n/// assert_eq!(uri.path(), \"/foo\");\n///\n/// assert!(uri.scheme().is_none());\n/// assert!(uri.authority().is_none());\n/// ```\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::uri::*;\n/// let mut parts = Parts::default();\n/// parts.scheme = Some(\"http\".parse().unwrap());\n/// parts.authority = Some(\"foo.com\".parse().unwrap());\n/// parts.path_and_query = Some(\"/foo\".parse().unwrap());\n///\n/// let uri = Uri::from_parts(parts).unwrap();\n///\n/// assert_eq!(uri.scheme().unwrap().as_str(), \"http\");\n/// assert_eq!(uri.authority().unwrap(), \"foo.com\");\n/// assert_eq!(uri.path(), \"/foo\");\n/// ```\npub fn from_parts(src: Parts) -> Result<Uri, InvalidUriParts>{\n        if src.scheme.is_some() {\n            if src.authority.is_none() {\n                return Err(ErrorKind::AuthorityMissing.into());\n            }\n\n            if src.path_and_query.is_none() {\n                return Err(ErrorKind::PathAndQueryMissing.into());\n            }\n        } else if src.authority.is_some() && src.path_and_query.is_some() {\n            return Err(ErrorKind::SchemeMissing.into());\n        }\n\n        let scheme = match src.scheme {\n            Some(scheme) => scheme,\n            None => Scheme {\n                inner: Scheme2::None,\n            },\n        };\n\n        let authority = match src.authority {\n            Some(authority) => authority,\n            None => Authority::empty(),\n        };\n\n        let path_and_query = match src.path_and_query {\n            Some(path_and_query) => path_and_query,\n            None => PathAndQuery::empty(),\n        };\n\n        Ok(Uri {\n            scheme,\n            authority,\n            path_and_query,\n        })\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::from_shared": [
            "fn from_shared(s: Bytes) -> Result<Uri, InvalidUri>{\n        use self::ErrorKind::*;\n\n        if s.len() > MAX_LEN {\n            return Err(TooLong.into());\n        }\n\n        match s.len() {\n            0 => {\n                return Err(Empty.into());\n            }\n            1 => match s[0] {\n                b'/' => {\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority: Authority::empty(),\n                        path_and_query: PathAndQuery::slash(),\n                    });\n                }\n                b'*' => {\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority: Authority::empty(),\n                        path_and_query: PathAndQuery::star(),\n                    });\n                }\n                _ => {\n                    let authority = Authority::from_shared(s)?;\n\n                    return Ok(Uri {\n                        scheme: Scheme::empty(),\n                        authority,\n                        path_and_query: PathAndQuery::empty(),\n                    });\n                }\n            },\n            _ => {}\n        }\n\n        if s[0] == b'/' {\n            return Ok(Uri {\n                scheme: Scheme::empty(),\n                authority: Authority::empty(),\n                path_and_query: PathAndQuery::from_shared(s)?,\n            });\n        }\n\n        parse_full(s)\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::from_static": [
            "/// Convert a `Uri` from a static string.\n///\n/// This function will not perform any copying, however the string is\n/// checked to ensure that it is valid.\n///\n/// # Panics\n///\n/// This function panics if the argument is an invalid URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::Uri;\n/// let uri = Uri::from_static(\"http://example.com/foo\");\n///\n/// assert_eq!(uri.host().unwrap(), \"example.com\");\n/// assert_eq!(uri.path(), \"/foo\");\n/// ```\npub fn from_static(src: &'static str) -> Self{\n        let s = Bytes::from_static(src.as_bytes());\n        match Uri::from_shared(s) {\n            Ok(uri) => uri,\n            Err(e) => panic!(\"static str is not valid URI: {}\", e),\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::has_path": [
            "fn has_path(&self) -> bool{\n        !self.path_and_query.data.is_empty() || !self.scheme.inner.is_none()\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::host": [
            "/// Get the host of this `Uri`.\n///\n/// The host subcomponent of authority is identified by an IP literal\n/// encapsulated within square brackets, an IPv4 address in dotted- decimal\n/// form, or a registered name.  The host subcomponent is **case-insensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                         |---------|\n///                              |\n///                             host\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.host(), Some(\"example.org\"));\n/// ```\n///\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert!(uri.host().is_none());\n/// ```\n#[inline]\npub fn host(&self) -> Option<&str>{\n        self.authority().map(|a| a.host())\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::into_parts": [
            "/// Convert a `Uri` into `Parts`.\n///\n/// # Note\n///\n/// This is just an inherent method providing the same functionality as\n/// `let parts: Parts = uri.into()`\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let uri: Uri = \"/foo\".parse().unwrap();\n///\n/// let parts = uri.into_parts();\n///\n/// assert_eq!(parts.path_and_query.unwrap(), \"/foo\");\n///\n/// assert!(parts.scheme.is_none());\n/// assert!(parts.authority.is_none());\n/// ```\n#[inline]\npub fn into_parts(self) -> Parts{\n        self.into()\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::path": [
            "/// Get the path of this `Uri`.\n///\n/// Both relative and absolute URIs contain a path component, though it\n/// might be the empty string. The path component is **case sensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                        |--------|\n///                                             |\n///                                           path\n/// ```\n///\n/// If the URI is `*` then the path component is equal to `*`.\n///\n/// # Examples\n///\n/// A relative URI\n///\n/// ```\n/// # use http::Uri;\n///\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.path(), \"/hello/world\");\n/// ```\n///\n/// An absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.path(), \"/hello/world\");\n/// ```\n#[inline]\npub fn path(&self) -> &str{\n        if self.has_path() {\n            self.path_and_query.path()\n        } else {\n            \"\"\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::path_and_query": [
            "/// Returns the path & query components of the Uri\n#[inline]\npub fn path_and_query(&self) -> Option<&PathAndQuery>{\n        if !self.scheme.inner.is_none() || self.authority.data.is_empty() {\n            Some(&self.path_and_query)\n        } else {\n            None\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::port": [
            "/// Get the port part of this `Uri`.\n///\n/// The port subcomponent of authority is designated by an optional port\n/// number following the host and delimited from it by a single colon (\":\")\n/// character. It can be turned into a decimal port number with the `as_u16`\n/// method or as a `str` with the `as_str` method.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                     |-|\n///                                      |\n///                                     port\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI with port\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n///\n/// let port = uri.port().unwrap();\n/// assert_eq!(port.as_u16(), 80);\n/// ```\n///\n/// Absolute URI without port\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n///\n/// assert!(uri.port().is_none());\n/// ```\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert!(uri.port().is_none());\n/// ```\npub fn port(&self) -> Option<Port<&str>>{\n        self.authority().and_then(|a| a.port())\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::port_u16": [
            "/// Get the port of this `Uri` as a `u16`.\n///\n///\n/// # Example\n///\n/// ```\n/// # use http::{Uri, uri::Port};\n/// let uri: Uri = \"http://example.org:80/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.port_u16(), Some(80));\n/// ```\npub fn port_u16(&self) -> Option<u16>{\n        self.port().map(|p| p.as_u16())\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::query": [
            "/// Get the query string of this `Uri`, starting after the `?`.\n///\n/// The query component contains non-hierarchical data that, along with data\n/// in the path component, serves to identify a resource within the scope of\n/// the URI's scheme and naming authority (if any). The query component is\n/// indicated by the first question mark (\"?\") character and terminated by a\n/// number sign (\"#\") character or by the end of the URI.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                                   |-------------------|\n///                                                             |\n///                                                           query\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org/hello/world?key=value\".parse().unwrap();\n///\n/// assert_eq!(uri.query(), Some(\"key=value\"));\n/// ```\n///\n/// Relative URI with a query string component\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n///\n/// assert_eq!(uri.query(), Some(\"key=value&foo=bar\"));\n/// ```\n///\n/// Relative URI without a query string component\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert!(uri.query().is_none());\n/// ```\n#[inline]\npub fn query(&self) -> Option<&str>{\n        self.path_and_query.query()\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::scheme": [
            "/// Get the scheme of this `Uri`.\n///\n/// The URI scheme refers to a specification for assigning identifiers\n/// within that scheme. Only absolute URIs contain a scheme component, but\n/// not all absolute URIs will contain a scheme component.  Although scheme\n/// names are case-insensitive, the canonical form is lowercase.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n/// |-|\n///  |\n/// scheme\n/// ```\n///\n/// # Examples\n///\n/// Absolute URI\n///\n/// ```\n/// use http::uri::{Scheme, Uri};\n///\n/// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.scheme(), Some(&Scheme::HTTP));\n/// ```\n///\n///\n/// Relative URI\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"/hello/world\".parse().unwrap();\n///\n/// assert!(uri.scheme().is_none());\n/// ```\n#[inline]\npub fn scheme(&self) -> Option<&Scheme>{\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(&self.scheme)\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::Uri::scheme_str": [
            "/// Get the scheme of this `Uri` as a `&str`.\n///\n/// # Example\n///\n/// ```\n/// # use http::Uri;\n/// let uri: Uri = \"http://example.org/hello/world\".parse().unwrap();\n///\n/// assert_eq!(uri.scheme_str(), Some(\"http\"));\n/// ```\n#[inline]\npub fn scheme_str(&self) -> Option<&str>{\n        if self.scheme.inner.is_none() {\n            None\n        } else {\n            Some(self.scheme.as_str())\n        }\n    }",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq": [
            "fn eq(&self, other: &Authority) -> bool{\n        self.eq_ignore_ascii_case(other.as_str())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq": [
            "fn eq(&self, other: &Authority) -> bool{\n        self.as_str().eq_ignore_ascii_case(other.as_str())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq": [
            "fn eq(&self, other: &Authority) -> bool{\n        self.eq_ignore_ascii_case(other.as_str())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp": [
            "fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp": [
            "fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp": [
            "fn partial_cmp(&self, other: &Authority) -> Option<cmp::Ordering>{\n        let left = self.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        let right = other.data.as_bytes().iter().map(|b| b.to_ascii_lowercase());\n        left.partial_cmp(right)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority": [
            "/// Represents the authority component of a URI.\npub struct Authority {\n    pub(super) data: ByteStr,\n}",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority::as_str": [
            "/// Return a str representation of the authority\n#[inline]\npub fn as_str(&self) -> &str{\n        &self.data[..]\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority::empty": [
            "pub(super) fn empty() -> Self{\n        Authority {\n            data: ByteStr::new(),\n        }\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority::from_maybe_shared": [
            "/// Attempt to convert a `Bytes` buffer to a `Authority`.\n///\n/// This will try to prevent a copy if the type passed is the type used\n/// internally, and will copy the data if it is not.\npub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + 'static,{\n        if_downcast_into!(T, Bytes, src, {\n            return Authority::from_shared(src);\n        });\n\n        Authority::try_from(src.as_ref())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority::from_shared": [
            "pub(super) fn from_shared(s: Bytes) -> Result<Self, InvalidUri>{\n        // Precondition on create_authority: trivially satisfied by the\n        // identity closure\n        create_authority(s, |s| s)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority::from_static": [
            "/// Attempt to convert an `Authority` from a static string.\n///\n/// This function will not perform any copying, and the string will be\n/// checked if it is empty or contains an invalid character.\n///\n/// # Panics\n///\n/// This function panics if the argument contains invalid characters or\n/// is empty.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority = Authority::from_static(\"example.com\");\n/// assert_eq!(authority.host(), \"example.com\");\n/// ```\npub fn from_static(src: &'static str) -> Self{\n        Authority::from_shared(Bytes::from_static(src.as_bytes()))\n            .expect(\"static str is not valid authority\")\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority::host": [
            "/// Get the host of this `Authority`.\n///\n/// The host subcomponent of authority is identified by an IP literal\n/// encapsulated within square brackets, an IPv4 address in dotted- decimal\n/// form, or a registered name.  The host subcomponent is **case-insensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                         |---------|\n///                              |\n///                             host\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let authority: Authority = \"example.org:80\".parse().unwrap();\n///\n/// assert_eq!(authority.host(), \"example.org\");\n/// ```\n#[inline]\npub fn host(&self) -> &str{\n        host(self.as_str())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority::parse": [
            "pub(super) fn parse(s: &[u8]) -> Result<usize, InvalidUri>{\n        let mut colon_cnt = 0u32;\n        let mut start_bracket = false;\n        let mut end_bracket = false;\n        let mut has_percent = false;\n        let mut end = s.len();\n        let mut at_sign_pos = None;\n        const MAX_COLONS: u32 = 8; // e.g., [FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:80\n\n        // Among other things, this loop checks that every byte in s up to the\n        // first '/', '?', or '#' is a valid URI character (or in some contexts,\n        // a '%'). This means that each such byte is a valid single-byte UTF-8\n        // code point.\n        for (i, &b) in s.iter().enumerate() {\n            match URI_CHARS[b as usize] {\n                b'/' | b'?' | b'#' => {\n                    end = i;\n                    break;\n                }\n                b':' => {\n                    if colon_cnt >= MAX_COLONS {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    colon_cnt += 1;\n                }\n                b'[' => {\n                    if has_percent || start_bracket {\n                        // Something other than the userinfo has a `%`, so reject it.\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    start_bracket = true;\n                }\n                b']' => {\n                    if (!start_bracket) || end_bracket {\n                        return Err(ErrorKind::InvalidAuthority.into());\n                    }\n                    end_bracket = true;\n\n                    // Those were part of an IPv6 hostname, so forget them...\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                b'@' => {\n                    at_sign_pos = Some(i);\n\n                    // Those weren't a port colon, but part of the\n                    // userinfo, so it needs to be forgotten.\n                    colon_cnt = 0;\n                    has_percent = false;\n                }\n                0 if b == b'%' => {\n                    // Per https://tools.ietf.org/html/rfc3986#section-3.2.1 and\n                    // https://url.spec.whatwg.org/#authority-state\n                    // the userinfo can have a percent-encoded username and password,\n                    // so record that a `%` was found. If this turns out to be\n                    // part of the userinfo, this flag will be cleared.\n                    // Also per https://tools.ietf.org/html/rfc6874, percent-encoding can\n                    // be used to indicate a zone identifier.\n                    // If the flag hasn't been cleared at the end, that means this\n                    // was part of the hostname (and not part of an IPv6 address), and\n                    // will fail with an error.\n                    has_percent = true;\n                }\n                0 => {\n                    return Err(ErrorKind::InvalidUriChar.into());\n                }\n                _ => {}\n            }\n        }\n\n        if start_bracket ^ end_bracket {\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if colon_cnt > 1 {\n            // Things like 'localhost:8080:3030' are rejected.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if end > 0 && at_sign_pos == Some(end - 1) {\n            // If there's nothing after an `@`, this is bonkers.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        if has_percent {\n            // Something after the userinfo has a `%`, so reject it.\n            return Err(ErrorKind::InvalidAuthority.into());\n        }\n\n        Ok(end)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority::parse_non_empty": [
            "fn parse_non_empty(s: &[u8]) -> Result<usize, InvalidUri>{\n        if s.is_empty() {\n            return Err(ErrorKind::Empty.into());\n        }\n        Authority::parse(s)\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority::port": [
            "/// Get the port part of this `Authority`.\n///\n/// The port subcomponent of authority is designated by an optional port\n/// number following the host and delimited from it by a single colon (\":\")\n/// character. It can be turned into a decimal port number with the `as_u16`\n/// method or as a `str` with the `as_str` method.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                     |-|\n///                                      |\n///                                     port\n/// ```\n///\n/// # Examples\n///\n/// Authority with port\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = \"example.org:80\".parse().unwrap();\n///\n/// let port = authority.port().unwrap();\n/// assert_eq!(port.as_u16(), 80);\n/// assert_eq!(port.as_str(), \"80\");\n/// ```\n///\n/// Authority without port\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = \"example.org\".parse().unwrap();\n///\n/// assert!(authority.port().is_none());\n/// ```\npub fn port(&self) -> Option<Port<&str>>{\n        let bytes = self.as_str();\n        bytes\n            .rfind(':')\n            .and_then(|i| Port::from_str(&bytes[i + 1..]).ok())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::Authority::port_u16": [
            "/// Get the port of this `Authority` as a `u16`.\n///\n/// # Example\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = \"example.org:80\".parse().unwrap();\n///\n/// assert_eq!(authority.port_u16(), Some(80));\n/// ```\npub fn port_u16(&self) -> Option<u16>{\n        self.port().map(|p| p.as_u16())\n    }",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::create_authority": [
            "fn create_authority<B, F>(b: B, f: F) -> Result<Authority, InvalidUri>\nwhere\n    B: AsRef<[u8]>,\n    F: FnOnce(B) -> Bytes,{\n    let s = b.as_ref();\n    let authority_end = Authority::parse_non_empty(s)?;\n\n    if authority_end != s.len() {\n        return Err(ErrorKind::InvalidUriChar.into());\n    }\n\n    let bytes = f(b);\n\n    Ok(Authority {\n        // Safety: the postcondition on parse_non_empty() and the check against\n        // s.len() ensure that b is valid UTF-8. The precondition on f ensures\n        // that this is carried through to bytes.\n        data: unsafe { ByteStr::from_utf8_unchecked(bytes) },\n    })\n}",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::authority::host": [
            "fn host(auth: &str) -> &str{\n    let host_port = auth\n        .rsplit('@')\n        .next()\n        .expect(\"split always has at least 1 item\");\n\n    if host_port.as_bytes()[0] == b'[' {\n        let i = host_port\n            .find(']')\n            .expect(\"parsing should validate brackets\");\n        // ..= ranges aren't available in 1.20, our minimum Rust version...\n        &host_port[0..i + 1]\n    } else {\n        host_port\n            .split(':')\n            .next()\n            .expect(\"split always has at least 1 item\")\n    }\n}",
            "Real(LocalPath(\"src/uri/authority.rs\"))"
        ],
        "uri::builder::Builder": [
            "/// A builder for `Uri`s.\n///\n/// This type can be used to construct an instance of `Uri`\n/// through a builder pattern.\npub struct Builder {\n    parts: Result<Parts, crate::Error>,\n}",
            "Real(LocalPath(\"src/uri/builder.rs\"))"
        ],
        "uri::builder::Builder::authority": [
            "/// Set the `Authority` for this URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = uri::Builder::new()\n///     .authority(\"tokio.rs\")\n///     .build()\n///     .unwrap();\n/// ```\npub fn authority<T>(self, auth: T) -> Self\n    where\n        T: TryInto<Authority>,\n        <T as TryInto<Authority>>::Error: Into<crate::Error>,{\n        self.map(move |mut parts| {\n            let auth = auth.try_into().map_err(Into::into)?;\n            parts.authority = Some(auth);\n            Ok(parts)\n        })\n    }",
            "Real(LocalPath(\"src/uri/builder.rs\"))"
        ],
        "uri::builder::Builder::build": [
            "/// Consumes this builder, and tries to construct a valid `Uri` from\n/// the configured pieces.\n///\n/// # Errors\n///\n/// This function may return an error if any previously configured argument\n/// failed to parse or get converted to the internal representation. For\n/// example if an invalid `scheme` was specified via `scheme(\"!@#%/^\")`\n/// the error will be returned when this function is called rather than\n/// when `scheme` was called.\n///\n/// Additionally, the various forms of URI require certain combinations of\n/// parts to be set to be valid. If the parts don't fit into any of the\n/// valid forms of URI, a new error is returned.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = Uri::builder()\n///     .build()\n///     .unwrap();\n/// ```\npub fn build(self) -> Result<Uri, crate::Error>{\n        let parts = self.parts?;\n        Uri::from_parts(parts).map_err(Into::into)\n    }",
            "Real(LocalPath(\"src/uri/builder.rs\"))"
        ],
        "uri::builder::Builder::map": [
            "fn map<F>(self, func: F) -> Self\n    where\n        F: FnOnce(Parts) -> Result<Parts, crate::Error>,{\n        Builder {\n            parts: self.parts.and_then(func),\n        }\n    }",
            "Real(LocalPath(\"src/uri/builder.rs\"))"
        ],
        "uri::builder::Builder::new": [
            "/// Creates a new default instance of `Builder` to construct a `Uri`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = uri::Builder::new()\n///     .scheme(\"https\")\n///     .authority(\"hyper.rs\")\n///     .path_and_query(\"/\")\n///     .build()\n///     .unwrap();\n/// ```\n#[inline]\npub fn new() -> Builder{\n        Builder::default()\n    }",
            "Real(LocalPath(\"src/uri/builder.rs\"))"
        ],
        "uri::builder::Builder::path_and_query": [
            "/// Set the `PathAndQuery` for this URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let uri = uri::Builder::new()\n///     .path_and_query(\"/hello?foo=bar\")\n///     .build()\n///     .unwrap();\n/// ```\npub fn path_and_query<T>(self, p_and_q: T) -> Self\n    where\n        T: TryInto<PathAndQuery>,\n        <T as TryInto<PathAndQuery>>::Error: Into<crate::Error>,{\n        self.map(move |mut parts| {\n            let p_and_q = p_and_q.try_into().map_err(Into::into)?;\n            parts.path_and_query = Some(p_and_q);\n            Ok(parts)\n        })\n    }",
            "Real(LocalPath(\"src/uri/builder.rs\"))"
        ],
        "uri::builder::Builder::scheme": [
            "/// Set the `Scheme` for this URI.\n///\n/// # Examples\n///\n/// ```\n/// # use http::*;\n///\n/// let mut builder = uri::Builder::new();\n/// builder.scheme(\"https\");\n/// ```\npub fn scheme<T>(self, scheme: T) -> Self\n    where\n        T: TryInto<Scheme>,\n        <T as TryInto<Scheme>>::Error: Into<crate::Error>,{\n        self.map(move |mut parts| {\n            let scheme = scheme.try_into().map_err(Into::into)?;\n            parts.scheme = Some(scheme);\n            Ok(parts)\n        })\n    }",
            "Real(LocalPath(\"src/uri/builder.rs\"))"
        ],
        "uri::parse_full": [
            "fn parse_full(mut s: Bytes) -> Result<Uri, InvalidUri>{\n    // Parse the scheme\n    let scheme = match Scheme2::parse(&s[..])? {\n        Scheme2::None => Scheme2::None,\n        Scheme2::Standard(p) => {\n            // TODO: use truncate\n            let _ = s.split_to(p.len() + 3);\n            Scheme2::Standard(p)\n        }\n        Scheme2::Other(n) => {\n            // Grab the protocol\n            let mut scheme = s.split_to(n + 3);\n\n            // Strip ://, TODO: truncate\n            let _ = scheme.split_off(n);\n\n            // Allocate the ByteStr\n            let val = unsafe { ByteStr::from_utf8_unchecked(scheme) };\n\n            Scheme2::Other(Box::new(val))\n        }\n    };\n\n    // Find the end of the authority. The scheme will already have been\n    // extracted.\n    let authority_end = Authority::parse(&s[..])?;\n\n    if scheme.is_none() {\n        if authority_end != s.len() {\n            return Err(ErrorKind::InvalidFormat.into());\n        }\n\n        let authority = Authority {\n            data: unsafe { ByteStr::from_utf8_unchecked(s) },\n        };\n\n        return Ok(Uri {\n            scheme: scheme.into(),\n            authority,\n            path_and_query: PathAndQuery::empty(),\n        });\n    }\n\n    // Authority is required when absolute\n    if authority_end == 0 {\n        return Err(ErrorKind::InvalidFormat.into());\n    }\n\n    let authority = s.split_to(authority_end);\n    let authority = Authority {\n        data: unsafe { ByteStr::from_utf8_unchecked(authority) },\n    };\n\n    Ok(Uri {\n        scheme: scheme.into(),\n        authority,\n        path_and_query: PathAndQuery::from_shared(s)?,\n    })\n}",
            "Real(LocalPath(\"src/uri/mod.rs\"))"
        ],
        "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq": [
            "#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self == &other.as_str()\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq": [
            "#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self.as_str() == other.as_str()\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq": [
            "#[inline]\nfn eq(&self, other: &PathAndQuery) -> bool{\n        self == other.as_str()\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.partial_cmp(&other.as_str())\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.as_str().partial_cmp(other.as_str())\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp": [
            "#[inline]\nfn partial_cmp(&self, other: &PathAndQuery) -> Option<cmp::Ordering>{\n        self.partial_cmp(other.as_str())\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::PathAndQuery": [
            "/// Represents the path component of a URI\npub struct PathAndQuery {\n    pub(super) data: ByteStr,\n    pub(super) query: u16,\n}",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::PathAndQuery::as_str": [
            "/// Returns the path and query as a string component.\n///\n/// # Examples\n///\n/// With a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n///\n/// assert_eq!(path_and_query.as_str(), \"/hello/world?key=value&foo=bar\");\n/// ```\n///\n/// Without a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n///\n/// assert_eq!(path_and_query.as_str(), \"/hello/world\");\n/// ```\n#[inline]\npub fn as_str(&self) -> &str{\n        let ret = &self.data[..];\n        if ret.is_empty() {\n            return \"/\";\n        }\n        ret\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::PathAndQuery::empty": [
            "pub(super) fn empty() -> Self{\n        PathAndQuery {\n            data: ByteStr::new(),\n            query: NONE,\n        }\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::PathAndQuery::from_maybe_shared": [
            "/// Attempt to convert a `Bytes` buffer to a `PathAndQuery`.\n///\n/// This will try to prevent a copy if the type passed is the type used\n/// internally, and will copy the data if it is not.\npub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n    where\n        T: AsRef<[u8]> + 'static,{\n        if_downcast_into!(T, Bytes, src, {\n            return PathAndQuery::from_shared(src);\n        });\n\n        PathAndQuery::try_from(src.as_ref())\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::PathAndQuery::from_shared": [
            "pub(super) fn from_shared(mut src: Bytes) -> Result<Self, InvalidUri>{\n        let mut query = NONE;\n        let mut fragment = None;\n\n        let mut is_maybe_not_utf8 = false;\n\n        // block for iterator borrow\n        {\n            let mut iter = src.as_ref().iter().enumerate();\n\n            // path ...\n            for (i, &b) in &mut iter {\n                // See https://url.spec.whatwg.org/#path-state\n                match b {\n                    b'?' => {\n                        debug_assert_eq!(query, NONE);\n                        query = i as u16;\n                        break;\n                    }\n                    b'#' => {\n                        fragment = Some(i);\n                        break;\n                    }\n\n                    // This is the range of bytes that don't need to be\n                    // percent-encoded in the path. If it should have been\n                    // percent-encoded, then error.\n                    #[rustfmt::skip]\n                    0x21 |\n                    0x24..=0x3B |\n                    0x3D |\n                    0x40..=0x5F |\n                    0x61..=0x7A |\n                    0x7C |\n                    0x7E => {}\n\n                    // potentially utf8, might not, should check\n                    0x7F..=0xFF => {\n                        is_maybe_not_utf8 = true;\n                    }\n\n                    // These are code points that are supposed to be\n                    // percent-encoded in the path but there are clients\n                    // out there sending them as is and httparse accepts\n                    // to parse those requests, so they are allowed here\n                    // for parity.\n                    //\n                    // For reference, those are code points that are used\n                    // to send requests with JSON directly embedded in\n                    // the URI path. Yes, those things happen for real.\n                    #[rustfmt::skip]\n                    b'\"' |\n                    b'{' | b'}' => {}\n\n                    _ => return Err(ErrorKind::InvalidUriChar.into()),\n                }\n            }\n\n            // query ...\n            if query != NONE {\n                for (i, &b) in iter {\n                    match b {\n                        // While queries *should* be percent-encoded, most\n                        // bytes are actually allowed...\n                        // See https://url.spec.whatwg.org/#query-state\n                        //\n                        // Allowed: 0x21 / 0x24 - 0x3B / 0x3D / 0x3F - 0x7E\n                        #[rustfmt::skip]\n                        0x21 |\n                        0x24..=0x3B |\n                        0x3D |\n                        0x3F..=0x7E => {}\n\n                        0x7F..=0xFF => {\n                            is_maybe_not_utf8 = true;\n                        }\n\n                        b'#' => {\n                            fragment = Some(i);\n                            break;\n                        }\n\n                        _ => return Err(ErrorKind::InvalidUriChar.into()),\n                    }\n                }\n            }\n        }\n\n        if let Some(i) = fragment {\n            src.truncate(i);\n        }\n\n        let data = if is_maybe_not_utf8 {\n            ByteStr::from_utf8(src).map_err(|_| ErrorKind::InvalidUriChar)?\n        } else {\n            unsafe { ByteStr::from_utf8_unchecked(src) }\n        };\n\n        Ok(PathAndQuery { data, query })\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::PathAndQuery::from_static": [
            "/// Convert a `PathAndQuery` from a static string.\n///\n/// This function will not perform any copying, however the string is\n/// checked to ensure that it is valid.\n///\n/// # Panics\n///\n/// This function panics if the argument is an invalid path and query.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let v = PathAndQuery::from_static(\"/hello?world\");\n///\n/// assert_eq!(v.path(), \"/hello\");\n/// assert_eq!(v.query(), Some(\"world\"));\n/// ```\n#[inline]\npub fn from_static(src: &'static str) -> Self{\n        let src = Bytes::from_static(src.as_bytes());\n\n        PathAndQuery::from_shared(src).unwrap()\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::PathAndQuery::path": [
            "/// Returns the path component\n///\n/// The path component is **case sensitive**.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                        |--------|\n///                                             |\n///                                           path\n/// ```\n///\n/// If the URI is `*` then the path component is equal to `*`.\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n///\n/// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n///\n/// assert_eq!(path_and_query.path(), \"/hello/world\");\n/// ```\n#[inline]\npub fn path(&self) -> &str{\n        let ret = if self.query == NONE {\n            &self.data[..]\n        } else {\n            &self.data[..self.query as usize]\n        };\n\n        if ret.is_empty() {\n            return \"/\";\n        }\n\n        ret\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::PathAndQuery::query": [
            "/// Returns the query string component\n///\n/// The query component contains non-hierarchical data that, along with data\n/// in the path component, serves to identify a resource within the scope of\n/// the URI's scheme and naming authority (if any). The query component is\n/// indicated by the first question mark (\"?\") character and terminated by a\n/// number sign (\"#\") character or by the end of the URI.\n///\n/// ```notrust\n/// abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1\n///                                                   |-------------------|\n///                                                             |\n///                                                           query\n/// ```\n///\n/// # Examples\n///\n/// With a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = \"/hello/world?key=value&foo=bar\".parse().unwrap();\n///\n/// assert_eq!(path_and_query.query(), Some(\"key=value&foo=bar\"));\n/// ```\n///\n/// Without a query string component\n///\n/// ```\n/// # use http::uri::*;\n/// let path_and_query: PathAndQuery = \"/hello/world\".parse().unwrap();\n///\n/// assert!(path_and_query.query().is_none());\n/// ```\n#[inline]\npub fn query(&self) -> Option<&str>{\n        if self.query == NONE {\n            None\n        } else {\n            let i = self.query + 1;\n            Some(&self.data[i as usize..])\n        }\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::PathAndQuery::slash": [
            "pub(super) fn slash() -> Self{\n        PathAndQuery {\n            data: ByteStr::from_static(\"/\"),\n            query: NONE,\n        }\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::path::PathAndQuery::star": [
            "pub(super) fn star() -> Self{\n        PathAndQuery {\n            data: ByteStr::from_static(\"*\"),\n            query: NONE,\n        }\n    }",
            "Real(LocalPath(\"src/uri/path.rs\"))"
        ],
        "uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq": [
            "fn eq(&self, other: &Port<T>) -> bool{\n        other.port == *self\n    }",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from": [
            "fn from(port: Port<T>) -> Self{\n        port.as_u16()\n    }",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "uri::port::Port": [
            "/// The port component of a URI.\npub struct Port<T> {\n    port: u16,\n    repr: T,\n}",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "uri::port::Port::<T>::as_str": [
            "/// Returns the port number as a `str`.\n///\n/// # Examples\n///\n/// Port as `str`.\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = \"example.org:80\".parse().unwrap();\n///\n/// let port = authority.port().unwrap();\n/// assert_eq!(port.as_str(), \"80\");\n/// ```\npub fn as_str(&self) -> &str{\n        self.repr.as_ref()\n    }",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "uri::port::Port::<T>::as_u16": [
            "/// Returns the port number as a `u16`.\n///\n/// # Examples\n///\n/// Port as `u16`.\n///\n/// ```\n/// # use http::uri::Authority;\n/// let authority: Authority = \"example.org:80\".parse().unwrap();\n///\n/// let port = authority.port().unwrap();\n/// assert_eq!(port.as_u16(), 80);\n/// ```\npub const fn as_u16(&self) -> u16{\n        self.port\n    }",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "uri::port::Port::<T>::from_str": [
            "/// Converts a `str` to a port number.\n///\n/// The supplied `str` must be a valid u16.\npub(crate) fn from_str(bytes: T) -> Result<Self, InvalidUri>{\n        bytes\n            .as_ref()\n            .parse::<u16>()\n            .map(|port| Port { port, repr: bytes })\n            .map_err(|_| ErrorKind::InvalidPort.into())\n    }",
            "Real(LocalPath(\"src/uri/port.rs\"))"
        ],
        "uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq": [
            "fn eq(&self, other: &Scheme) -> bool{\n        other == self\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "uri::scheme::Protocol": [
            "pub(super) enum Protocol {\n    Http,\n    Https,\n}",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "uri::scheme::Protocol::len": [
            "pub(super) fn len(&self) -> usize{\n        match *self {\n            Protocol::Http => 4,\n            Protocol::Https => 5,\n        }\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "uri::scheme::Scheme": [
            "/// Represents the scheme component of a URI\npub struct Scheme {\n    pub(super) inner: Scheme2,\n}",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "uri::scheme::Scheme2": [
            "pub(super) enum Scheme2<T = Box<ByteStr>> {\n    None,\n    Standard(Protocol),\n    Other(T),\n}",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "uri::scheme::Scheme2::<T>::is_none": [
            "pub(super) fn is_none(&self) -> bool{\n        matches!(*self, Scheme2::None)\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "uri::scheme::Scheme2::<usize>::parse": [
            "pub(super) fn parse(s: &[u8]) -> Result<Scheme2<usize>, InvalidUri>{\n        if s.len() >= 7 {\n            // Check for HTTP\n            if s[..7].eq_ignore_ascii_case(b\"http://\") {\n                // Prefix will be striped\n                return Ok(Protocol::Http.into());\n            }\n        }\n\n        if s.len() >= 8 {\n            // Check for HTTPs\n            if s[..8].eq_ignore_ascii_case(b\"https://\") {\n                return Ok(Protocol::Https.into());\n            }\n        }\n\n        if s.len() > 3 {\n            for i in 0..s.len() {\n                let b = s[i];\n\n                match SCHEME_CHARS[b as usize] {\n                    b':' => {\n                        // Not enough data remaining\n                        if s.len() < i + 3 {\n                            break;\n                        }\n\n                        // Not a scheme\n                        if &s[i + 1..i + 3] != b\"//\" {\n                            break;\n                        }\n\n                        if i > MAX_SCHEME_LEN {\n                            return Err(ErrorKind::SchemeTooLong.into());\n                        }\n\n                        // Return scheme\n                        return Ok(Scheme2::Other(i));\n                    }\n                    // Invalid scheme character, abort\n                    0 => break,\n                    _ => {}\n                }\n            }\n        }\n\n        Ok(Scheme2::None)\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "uri::scheme::Scheme2::<usize>::parse_exact": [
            "fn parse_exact(s: &[u8]) -> Result<Scheme2<()>, InvalidUri>{\n        match s {\n            b\"http\" => Ok(Protocol::Http.into()),\n            b\"https\" => Ok(Protocol::Https.into()),\n            _ => {\n                if s.len() > MAX_SCHEME_LEN {\n                    return Err(ErrorKind::SchemeTooLong.into());\n                }\n\n                // check that each byte in s is a SCHEME_CHARS which implies\n                // that it is a valid single byte UTF-8 code point.\n                for &b in s {\n                    match SCHEME_CHARS[b as usize] {\n                        b':' => {\n                            // Don't want :// here\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        0 => {\n                            return Err(ErrorKind::InvalidScheme.into());\n                        }\n                        _ => {}\n                    }\n                }\n\n                Ok(Scheme2::Other(()))\n            }\n        }\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "uri::scheme::Scheme::as_str": [
            "/// Return a str representation of the scheme\n///\n/// # Examples\n///\n/// ```\n/// # use http::uri::*;\n/// let scheme: Scheme = \"http\".parse().unwrap();\n/// assert_eq!(scheme.as_str(), \"http\");\n/// ```\n#[inline]\npub fn as_str(&self) -> &str{\n        use self::Protocol::*;\n        use self::Scheme2::*;\n\n        match self.inner {\n            Standard(Http) => \"http\",\n            Standard(Https) => \"https\",\n            Other(ref v) => &v[..],\n            None => unreachable!(),\n        }\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "uri::scheme::Scheme::empty": [
            "pub(super) fn empty() -> Self{\n        Scheme {\n            inner: Scheme2::None,\n        }\n    }",
            "Real(LocalPath(\"src/uri/scheme.rs\"))"
        ],
        "version::Http": [
            "enum Http {\n    Http09,\n    Http10,\n    Http11,\n    H2,\n    H3,\n    __NonExhaustive,\n}",
            "Real(LocalPath(\"src/version.rs\"))"
        ],
        "version::Version": [
            "/// Represents a version of the HTTP spec.\npub struct Version(Http);",
            "Real(LocalPath(\"src/version.rs\"))"
        ]
    },
    "struct_constructor": {
        "&'^0.Named(DefId(0:2929 ~ http[472d]::header::map::{impl#35}::key::'_), \"'_\") header::name::HeaderName": [
            "key"
        ],
        "&'^0.Named(DefId(0:2930 ~ http[472d]::header::map::{impl#36}::key::'_), \"'_\") header::name::HeaderName": [
            "key"
        ],
        "&'^0.Named(DefId(0:2942 ~ http[472d]::header::map::{impl#52}::key::'_), \"'_\") header::name::HeaderName": [
            "key"
        ],
        "&'^0.Named(DefId(0:2954 ~ http[472d]::header::map::{impl#63}::index::'_), \"'_\") Alias(Projection, AliasTy { args: [header::map::RawLinks<T/#0>, usize], def_id: DefId(2:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index"
        ],
        "&'^0.Named(DefId(0:2955 ~ http[472d]::header::map::{impl#64}::index_mut::'_), \"'_\") mut Alias(Projection, AliasTy { args: [header::map::RawLinks<T/#0>, usize], def_id: DefId(2:40133 ~ core[a245]::ops::index::Index::Output) })": [
            "index_mut"
        ],
        "&'^0.Named(DefId(0:2987 ~ http[472d]::header::map::as_header_name::Sealed::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:2991 ~ http[472d]::header::map::as_header_name::{impl#2}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:2995 ~ http[472d]::header::map::as_header_name::{impl#4}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:2999 ~ http[472d]::header::map::as_header_name::{impl#6}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3003 ~ http[472d]::header::map::as_header_name::{impl#8}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3007 ~ http[472d]::header::map::as_header_name::{impl#10}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3012 ~ http[472d]::header::name::{impl#1}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3014 ~ http[472d]::header::name::{impl#3}::as_ref::'_), \"'_\") str": [
            "as_ref"
        ],
        "&'^0.Named(DefId(0:3015 ~ http[472d]::header::name::{impl#4}::as_ref::'_), \"'_\") [u8]": [
            "as_ref"
        ],
        "&'^0.Named(DefId(0:3016 ~ http[472d]::header::name::{impl#5}::borrow::'_), \"'_\") str": [
            "borrow"
        ],
        "&'^0.Named(DefId(0:3054 ~ http[472d]::header::name::slice_assume_init::'_), \"'_\") [T/#0]": [
            "slice_assume_init"
        ],
        "&'^0.Named(DefId(0:3057 ~ http[472d]::header::value::{impl#0}::to_str::'_), \"'_\") str": [
            "to_str"
        ],
        "&'^0.Named(DefId(0:3060 ~ http[472d]::header::value::{impl#0}::as_bytes::'_), \"'_\") [u8]": [
            "as_bytes"
        ],
        "&'^0.Named(DefId(0:3063 ~ http[472d]::header::value::{impl#1}::as_ref::'_), \"'_\") [u8]": [
            "as_ref"
        ],
        "&'^0.Named(DefId(0:3125 ~ http[472d]::method::{impl#0}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3126 ~ http[472d]::method::{impl#1}::as_ref::'_), \"'_\") str": [
            "as_ref"
        ],
        "&'^0.Named(DefId(0:3153 ~ http[472d]::method::extension::{impl#0}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3155 ~ http[472d]::method::extension::{impl#1}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3158 ~ http[472d]::request::{impl#1}::method::'_), \"'_\") method::Method": [
            "method"
        ],
        "&'^0.Named(DefId(0:3159 ~ http[472d]::request::{impl#1}::method_mut::'_), \"'_\") mut method::Method": [
            "method_mut"
        ],
        "&'^0.Named(DefId(0:3160 ~ http[472d]::request::{impl#1}::uri::'_), \"'_\") uri::Uri": [
            "uri"
        ],
        "&'^0.Named(DefId(0:3161 ~ http[472d]::request::{impl#1}::uri_mut::'_), \"'_\") mut uri::Uri": [
            "uri_mut"
        ],
        "&'^0.Named(DefId(0:3163 ~ http[472d]::request::{impl#1}::version_mut::'_), \"'_\") mut version::Version": [
            "version_mut"
        ],
        "&'^0.Named(DefId(0:3166 ~ http[472d]::request::{impl#1}::extensions::'_), \"'_\") extensions::Extensions": [
            "extensions"
        ],
        "&'^0.Named(DefId(0:3167 ~ http[472d]::request::{impl#1}::extensions_mut::'_), \"'_\") mut extensions::Extensions": [
            "extensions_mut"
        ],
        "&'^0.Named(DefId(0:3176 ~ http[472d]::request::{impl#6}::method_ref::'_), \"'_\") method::Method": [
            "method_ref"
        ],
        "&'^0.Named(DefId(0:3177 ~ http[472d]::request::{impl#6}::uri_ref::'_), \"'_\") uri::Uri": [
            "uri_ref"
        ],
        "&'^0.Named(DefId(0:3178 ~ http[472d]::request::{impl#6}::version_ref::'_), \"'_\") version::Version": [
            "version_ref"
        ],
        "&'^0.Named(DefId(0:3181 ~ http[472d]::request::{impl#6}::extensions_ref::'_), \"'_\") extensions::Extensions": [
            "extensions_ref"
        ],
        "&'^0.Named(DefId(0:3182 ~ http[472d]::request::{impl#6}::extensions_mut::'_), \"'_\") mut extensions::Extensions": [
            "extensions_mut"
        ],
        "&'^0.Named(DefId(0:3184 ~ http[472d]::response::{impl#1}::status_mut::'_), \"'_\") mut status::StatusCode": [
            "status_mut"
        ],
        "&'^0.Named(DefId(0:3186 ~ http[472d]::response::{impl#1}::version_mut::'_), \"'_\") mut version::Version": [
            "version_mut"
        ],
        "&'^0.Named(DefId(0:3189 ~ http[472d]::response::{impl#1}::extensions::'_), \"'_\") extensions::Extensions": [
            "extensions"
        ],
        "&'^0.Named(DefId(0:3190 ~ http[472d]::response::{impl#1}::extensions_mut::'_), \"'_\") mut extensions::Extensions": [
            "extensions_mut"
        ],
        "&'^0.Named(DefId(0:3201 ~ http[472d]::response::{impl#6}::extensions_ref::'_), \"'_\") extensions::Extensions": [
            "extensions_ref"
        ],
        "&'^0.Named(DefId(0:3202 ~ http[472d]::response::{impl#6}::extensions_mut::'_), \"'_\") mut extensions::Extensions": [
            "extensions_mut"
        ],
        "&'^0.Named(DefId(0:3205 ~ http[472d]::status::{impl#0}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3231 ~ http[472d]::uri::authority::{impl#0}::host::'_), \"'_\") str": [
            "host"
        ],
        "&'^0.Named(DefId(0:3234 ~ http[472d]::uri::authority::{impl#0}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3235 ~ http[472d]::uri::authority::{impl#1}::as_ref::'_), \"'_\") str": [
            "as_ref"
        ],
        "&'^0.Named(DefId(0:3274 ~ http[472d]::uri::path::{impl#0}::path::'_), \"'_\") str": [
            "path"
        ],
        "&'^0.Named(DefId(0:3275 ~ http[472d]::uri::path::{impl#0}::query::'_), \"'_\") str": [
            "query"
        ],
        "&'^0.Named(DefId(0:3276 ~ http[472d]::uri::path::{impl#0}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3317 ~ http[472d]::uri::port::{impl#1}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3324 ~ http[472d]::uri::port::{impl#5}::as_ref::'_), \"'_\") str": [
            "as_ref"
        ],
        "&'^0.Named(DefId(0:3331 ~ http[472d]::uri::scheme::{impl#0}::as_str::'_), \"'_\") str": [
            "as_str"
        ],
        "&'^0.Named(DefId(0:3339 ~ http[472d]::uri::scheme::{impl#6}::as_ref::'_), \"'_\") str": [
            "as_ref"
        ],
        "&'^0.Named(DefId(0:3352 ~ http[472d]::uri::{impl#0}::path_and_query::'_), \"'_\") uri::path::PathAndQuery": [
            "path_and_query"
        ],
        "&'^0.Named(DefId(0:3353 ~ http[472d]::uri::{impl#0}::path::'_), \"'_\") str": [
            "path"
        ],
        "&'^0.Named(DefId(0:3354 ~ http[472d]::uri::{impl#0}::scheme::'_), \"'_\") uri::scheme::Scheme": [
            "scheme"
        ],
        "&'^0.Named(DefId(0:3355 ~ http[472d]::uri::{impl#0}::scheme_str::'_), \"'_\") str": [
            "scheme_str"
        ],
        "&'^0.Named(DefId(0:3356 ~ http[472d]::uri::{impl#0}::authority::'_), \"'_\") uri::authority::Authority": [
            "authority"
        ],
        "&'^0.Named(DefId(0:3357 ~ http[472d]::uri::{impl#0}::host::'_), \"'_\") str": [
            "host"
        ],
        "&'^0.Named(DefId(0:3360 ~ http[472d]::uri::{impl#0}::query::'_), \"'_\") str": [
            "query"
        ],
        "&'^0.Named(DefId(0:3379 ~ http[472d]::uri::{impl#23}::s::'_), \"'_\") str": [
            "s"
        ],
        "&'^0.Named(DefId(0:3391 ~ http[472d]::byte_str::{impl#1}::deref::'_), \"'_\") str": [
            "deref"
        ],
        "&'^0.Named(DefId(0:3399 ~ http[472d]::error::{impl#2}::get_ref::'_), \"'_\") dyn [Binder { value: Trait(std::error::Error), bound_vars: [] }] + 'static": [
            "get_ref"
        ],
        "&'^0.Named(DefId(0:3400 ~ http[472d]::error::{impl#3}::source::'_), \"'_\") dyn [Binder { value: Trait(std::error::Error), bound_vars: [] }] + 'static": [
            "source"
        ],
        "&'^0.Named(DefId(0:3420 ~ http[472d]::extensions::AnyClone::as_any::'_), \"'_\") dyn [Binder { value: Trait(std::any::Any), bound_vars: [] }] + 'static": [
            "as_any"
        ],
        "&'^0.Named(DefId(0:3421 ~ http[472d]::extensions::AnyClone::as_any_mut::'_), \"'_\") mut dyn [Binder { value: Trait(std::any::Any), bound_vars: [] }] + 'static": [
            "as_any_mut"
        ],
        "&'^0.Named(DefId(0:3423 ~ http[472d]::extensions::{impl#3}::as_any::'_), \"'_\") dyn [Binder { value: Trait(std::any::Any), bound_vars: [] }] + 'static": [
            "as_any"
        ],
        "&'^0.Named(DefId(0:3424 ~ http[472d]::extensions::{impl#3}::as_any_mut::'_), \"'_\") mut dyn [Binder { value: Trait(std::any::Any), bound_vars: [] }] + 'static": [
            "as_any_mut"
        ],
        "&'static str": [
            "as_str",
            "canonical_reason"
        ],
        "(&'a/#0 header::name::HeaderName, *mut T/#1)": [
            "next_unsafe"
        ],
        "(header::name::HeaderName, T/#1)": [
            "remove_entry"
        ],
        "(header::name::HeaderName, header::map::ValueDrain<'a/#0, T/#1>)": [
            "remove_entry_mult"
        ],
        "(request::Parts, T/#0)": [
            "into_parts"
        ],
        "(response::Parts, T/#0)": [
            "into_parts"
        ],
        "(usize, header::map::HashValue)": [
            "resolve"
        ],
        "(usize, std::option::Option<usize>)": [
            "size_hint"
        ],
        "(usize, usize)": [
            "find"
        ],
        "Alias(Projection, AliasTy { args: [header::map::Drain<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": [
            "next"
        ],
        "Alias(Projection, AliasTy { args: [header::map::IntoIter<T/#0>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": [
            "next"
        ],
        "Alias(Projection, AliasTy { args: [header::map::Iter<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": [
            "next"
        ],
        "Alias(Projection, AliasTy { args: [header::map::IterMut<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": [
            "next"
        ],
        "Alias(Projection, AliasTy { args: [header::map::Keys<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": [
            "last",
            "next",
            "nth"
        ],
        "Alias(Projection, AliasTy { args: [header::map::ValueIter<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": [
            "next",
            "next_back"
        ],
        "Alias(Projection, AliasTy { args: [header::map::ValueIterMut<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": [
            "next",
            "next_back"
        ],
        "Alias(Projection, AliasTy { args: [header::map::Values<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": [
            "next"
        ],
        "Alias(Projection, AliasTy { args: [header::map::ValuesMut<'a/#0, T/#1>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })": [
            "next"
        ],
        "[std::mem::MaybeUninit<u8>; UnevaluatedConst { def: DefId(0:3053 ~ http[472d]::header::name::uninit_u8_array::{constant#1}), args: [] }]": [
            "uninit_u8_array"
        ],
        "bool": [
            "append",
            "contains_key",
            "eq",
            "eq_ignore_ascii_case",
            "has_path",
            "is",
            "is_client_error",
            "is_empty",
            "is_idempotent",
            "is_informational",
            "is_none",
            "is_red",
            "is_redirection",
            "is_safe",
            "is_sensitive",
            "is_server_error",
            "is_some",
            "is_success",
            "is_valid",
            "is_visible_ascii",
            "is_yellow",
            "try_append",
            "try_append2"
        ],
        "byte_str::ByteStr": [
            "clone",
            "from",
            "from_static",
            "from_utf8",
            "from_utf8_unchecked",
            "new"
        ],
        "bytes::Bytes": [
            "from",
            "into_bytes"
        ],
        "error::Error": [
            "from"
        ],
        "extensions::Extensions": [
            "clone",
            "default",
            "new"
        ],
        "extensions::IdHasher": [
            "default"
        ],
        "header::map::Bucket": [
            "clone",
            "remove_found"
        ],
        "header::map::Cursor": [
            "clone"
        ],
        "header::map::Danger": [
            "clone"
        ],
        "header::map::Drain": [
            "drain"
        ],
        "header::map::Entry": [
            "entry",
            "try_entry",
            "try_entry2"
        ],
        "header::map::ExtraValue": [
            "clone",
            "remove_extra_value"
        ],
        "header::map::GetAll": [
            "get_all"
        ],
        "header::map::HashValue": [
            "clone",
            "hash_elem_using"
        ],
        "header::map::HeaderMap": [
            "clone",
            "default",
            "from_iter",
            "new",
            "try_from",
            "try_with_capacity",
            "with_capacity"
        ],
        "header::map::IntoIter": [
            "into_iter"
        ],
        "header::map::Iter": [
            "into_iter",
            "iter"
        ],
        "header::map::IterMut": [
            "into_iter",
            "iter_mut"
        ],
        "header::map::Keys": [
            "keys"
        ],
        "header::map::Link": [
            "clone"
        ],
        "header::map::Links": [
            "clone"
        ],
        "header::map::MaxSizeReached": [
            "new"
        ],
        "header::map::OccupiedEntry": [
            "insert_entry",
            "try_insert_entry"
        ],
        "header::map::Pos": [
            "clone",
            "new",
            "none"
        ],
        "header::map::RawLinks": [
            "clone",
            "raw_links"
        ],
        "header::map::ValueDrain": [
            "insert_mult",
            "insert_occupied_mult"
        ],
        "header::map::ValueIter": [
            "into_iter",
            "iter",
            "value_iter"
        ],
        "header::map::ValueIterMut": [
            "into_iter",
            "iter_mut",
            "value_iter_mut"
        ],
        "header::map::Values": [
            "values"
        ],
        "header::map::ValuesMut": [
            "values_mut"
        ],
        "header::map::as_header_name::TryEntryError": [
            "from"
        ],
        "header::name::Custom": [
            "clone"
        ],
        "header::name::HdrName": [
            "custom",
            "from",
            "parse_hdr"
        ],
        "header::name::HeaderName": [
            "clone",
            "from",
            "from_bytes",
            "from_lowercase",
            "from_static",
            "from_str",
            "into_key",
            "try_from"
        ],
        "header::name::InvalidHeaderName": [
            "new"
        ],
        "header::name::MaybeLower": [
            "clone"
        ],
        "header::name::Repr": [
            "clone"
        ],
        "header::name::StandardHeader": [
            "clone",
            "from_bytes"
        ],
        "header::value::HeaderValue": [
            "clone",
            "from",
            "from_bytes",
            "from_maybe_shared",
            "from_maybe_shared_unchecked",
            "from_name",
            "from_shared",
            "from_static",
            "from_str",
            "try_from",
            "try_from_generic"
        ],
        "method::Inner": [
            "clone"
        ],
        "method::InvalidMethod": [
            "new"
        ],
        "method::Method": [
            "clone",
            "default",
            "extension_inline",
            "from",
            "from_bytes",
            "from_str",
            "try_from"
        ],
        "method::extension::AllocatedExtension": [
            "clone",
            "new"
        ],
        "method::extension::InlineExtension": [
            "clone",
            "new"
        ],
        "request::Builder": [
            "builder",
            "connect",
            "default",
            "delete",
            "get",
            "head",
            "new",
            "options",
            "patch",
            "post",
            "put",
            "trace"
        ],
        "request::Parts": [
            "clone",
            "new"
        ],
        "request::Request": [
            "body",
            "clone",
            "default",
            "from_parts",
            "new"
        ],
        "response::Builder": [
            "builder",
            "default",
            "new"
        ],
        "response::Parts": [
            "clone",
            "new"
        ],
        "response::Response": [
            "body",
            "clone",
            "default",
            "from_parts",
            "new"
        ],
        "status::InvalidStatusCode": [
            "new"
        ],
        "status::StatusCode": [
            "clone",
            "default",
            "from",
            "from_bytes",
            "from_str",
            "from_u16",
            "status",
            "try_from"
        ],
        "std::boxed::Box": [
            "clone",
            "clone_box"
        ],
        "std::cmp::Ordering": [
            "cmp",
            "partial_cmp"
        ],
        "std::vec::Vec": [
            "drain_all_extra_values"
        ],
        "u16": [
            "as_u16",
            "from",
            "port_u16"
        ],
        "u64": [
            "finish"
        ],
        "uri::InvalidUri": [
            "from"
        ],
        "uri::InvalidUriParts": [
            "from"
        ],
        "uri::Parts": [
            "default",
            "from",
            "into_parts"
        ],
        "uri::Uri": [
            "build",
            "clone",
            "default",
            "from",
            "from_maybe_shared",
            "from_parts",
            "from_shared",
            "from_static",
            "from_str",
            "parse_full",
            "try_from"
        ],
        "uri::authority::Authority": [
            "clone",
            "create_authority",
            "empty",
            "from_maybe_shared",
            "from_shared",
            "from_static",
            "from_str",
            "try_from"
        ],
        "uri::builder::Builder": [
            "builder",
            "default",
            "from",
            "new"
        ],
        "uri::path::PathAndQuery": [
            "clone",
            "empty",
            "from_maybe_shared",
            "from_shared",
            "from_static",
            "from_str",
            "slash",
            "star",
            "try_from"
        ],
        "uri::port::Port": [
            "from_str",
            "port"
        ],
        "uri::scheme::Protocol": [
            "clone"
        ],
        "uri::scheme::Scheme": [
            "clone",
            "empty",
            "from",
            "from_str",
            "try_from"
        ],
        "uri::scheme::Scheme2": [
            "clone",
            "from",
            "parse",
            "parse_exact"
        ],
        "usize": [
            "capacity",
            "count",
            "desired_pos",
            "keys_len",
            "len",
            "parse",
            "parse_non_empty"
        ],
        "version::Http": [
            "clone"
        ],
        "version::Version": [
            "clone",
            "default",
            "version"
        ]
    },
    "struct_to_trait": {
        "<T as extensions::AnyClone>::T": [
            "extensions::AnyClone"
        ],
        "byte_str::ByteStr": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::Ord",
            "std::cmp::PartialEq",
            "std::cmp::PartialOrd",
            "std::convert::From",
            "std::fmt::Debug",
            "std::hash::Hash",
            "std::marker::StructuralPartialEq",
            "std::ops::Deref"
        ],
        "bytes::Bytes": [
            "std::convert::From"
        ],
        "error::Error": [
            "std::convert::From",
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "extensions::Extensions": [
            "std::clone::Clone",
            "std::default::Default",
            "std::fmt::Debug"
        ],
        "extensions::IdHasher": [
            "std::default::Default",
            "std::hash::Hasher"
        ],
        "header::map::Bucket": [
            "std::clone::Clone",
            "std::fmt::Debug"
        ],
        "header::map::Cursor": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::Copy",
            "std::marker::StructuralPartialEq"
        ],
        "header::map::Danger": [
            "std::clone::Clone"
        ],
        "header::map::Drain": [
            "std::fmt::Debug",
            "std::iter::FusedIterator",
            "std::iter::Iterator",
            "std::marker::Send",
            "std::marker::Sync",
            "std::ops::Drop"
        ],
        "header::map::Entry": [
            "std::fmt::Debug"
        ],
        "header::map::ExtraValue": [
            "std::clone::Clone",
            "std::fmt::Debug"
        ],
        "header::map::GetAll": [
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::iter::IntoIterator"
        ],
        "header::map::HashValue": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::Copy",
            "std::marker::StructuralPartialEq"
        ],
        "header::map::HeaderMap": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::convert::TryFrom",
            "std::default::Default",
            "std::fmt::Debug",
            "std::iter::Extend",
            "std::iter::FromIterator",
            "std::iter::IntoIterator",
            "std::ops::Index"
        ],
        "header::map::IntoIter": [
            "std::fmt::Debug",
            "std::iter::FusedIterator",
            "std::iter::Iterator",
            "std::ops::Drop"
        ],
        "header::map::Iter": [
            "std::fmt::Debug",
            "std::iter::FusedIterator",
            "std::iter::Iterator",
            "std::marker::Send",
            "std::marker::Sync"
        ],
        "header::map::IterMut": [
            "std::fmt::Debug",
            "std::iter::FusedIterator",
            "std::iter::Iterator",
            "std::marker::Send",
            "std::marker::Sync"
        ],
        "header::map::Keys": [
            "std::fmt::Debug",
            "std::iter::ExactSizeIterator",
            "std::iter::FusedIterator",
            "std::iter::Iterator"
        ],
        "header::map::Link": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::Copy",
            "std::marker::StructuralPartialEq"
        ],
        "header::map::Links": [
            "std::clone::Clone",
            "std::fmt::Debug",
            "std::marker::Copy"
        ],
        "header::map::MaxSizeReached": [
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "header::map::OccupiedEntry": [
            "std::fmt::Debug",
            "std::iter::IntoIterator"
        ],
        "header::map::Pos": [
            "std::clone::Clone",
            "std::marker::Copy"
        ],
        "header::map::RawLinks": [
            "std::clone::Clone",
            "std::fmt::Debug",
            "std::marker::Copy",
            "std::ops::Index",
            "std::ops::IndexMut"
        ],
        "header::map::VacantEntry": [
            "std::fmt::Debug"
        ],
        "header::map::ValueDrain": [
            "std::fmt::Debug",
            "std::iter::FusedIterator",
            "std::iter::Iterator",
            "std::marker::Send",
            "std::marker::Sync",
            "std::ops::Drop"
        ],
        "header::map::ValueIter": [
            "std::fmt::Debug",
            "std::iter::DoubleEndedIterator",
            "std::iter::FusedIterator",
            "std::iter::Iterator"
        ],
        "header::map::ValueIterMut": [
            "std::fmt::Debug",
            "std::iter::DoubleEndedIterator",
            "std::iter::FusedIterator",
            "std::iter::Iterator",
            "std::marker::Send",
            "std::marker::Sync"
        ],
        "header::map::Values": [
            "std::fmt::Debug",
            "std::iter::FusedIterator",
            "std::iter::Iterator"
        ],
        "header::map::ValuesMut": [
            "std::fmt::Debug",
            "std::iter::FusedIterator",
            "std::iter::Iterator"
        ],
        "header::map::as_header_name::TryEntryError": [
            "std::convert::From"
        ],
        "header::name::Custom": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::hash::Hash",
            "std::marker::StructuralPartialEq"
        ],
        "header::name::HdrName": [
            "std::convert::From",
            "std::fmt::Debug",
            "std::hash::Hash"
        ],
        "header::name::HeaderName": [
            "header::map::as_header_name::AsHeaderName",
            "header::map::as_header_name::Sealed",
            "header::map::into_header_name::IntoHeaderName",
            "header::map::into_header_name::Sealed",
            "std::borrow::Borrow",
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::convert::AsRef",
            "std::convert::From",
            "std::convert::TryFrom",
            "std::fmt::Debug",
            "std::fmt::Display",
            "std::hash::Hash",
            "std::marker::StructuralPartialEq",
            "std::str::FromStr"
        ],
        "header::name::InvalidHeaderName": [
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "header::name::MaybeLower": [
            "std::clone::Clone",
            "std::fmt::Debug",
            "std::hash::Hash"
        ],
        "header::name::Repr": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::hash::Hash",
            "std::marker::StructuralPartialEq"
        ],
        "header::name::StandardHeader": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::hash::Hash",
            "std::marker::Copy",
            "std::marker::StructuralPartialEq"
        ],
        "header::value::HeaderValue": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::Ord",
            "std::cmp::PartialEq",
            "std::cmp::PartialOrd",
            "std::convert::AsRef",
            "std::convert::From",
            "std::convert::TryFrom",
            "std::fmt::Debug",
            "std::hash::Hash",
            "std::str::FromStr"
        ],
        "header::value::InvalidHeaderValue": [
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "header::value::ToStrError": [
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "method::Inner": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::hash::Hash",
            "std::marker::StructuralPartialEq"
        ],
        "method::InvalidMethod": [
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "method::Method": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::convert::AsRef",
            "std::convert::From",
            "std::convert::TryFrom",
            "std::default::Default",
            "std::fmt::Debug",
            "std::fmt::Display",
            "std::hash::Hash",
            "std::marker::StructuralPartialEq",
            "std::str::FromStr"
        ],
        "method::extension::AllocatedExtension": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::hash::Hash",
            "std::marker::StructuralPartialEq"
        ],
        "method::extension::InlineExtension": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::hash::Hash",
            "std::marker::StructuralPartialEq"
        ],
        "request::Builder": [
            "std::default::Default",
            "std::fmt::Debug"
        ],
        "request::Parts": [
            "std::clone::Clone",
            "std::fmt::Debug"
        ],
        "request::Request": [
            "std::clone::Clone",
            "std::default::Default",
            "std::fmt::Debug"
        ],
        "response::Builder": [
            "std::default::Default",
            "std::fmt::Debug"
        ],
        "response::Parts": [
            "std::clone::Clone",
            "std::fmt::Debug"
        ],
        "response::Response": [
            "std::clone::Clone",
            "std::default::Default",
            "std::fmt::Debug"
        ],
        "status::InvalidStatusCode": [
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "status::StatusCode": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::Ord",
            "std::cmp::PartialEq",
            "std::cmp::PartialOrd",
            "std::convert::From",
            "std::convert::TryFrom",
            "std::default::Default",
            "std::fmt::Debug",
            "std::fmt::Display",
            "std::hash::Hash",
            "std::marker::Copy",
            "std::marker::StructuralPartialEq",
            "std::str::FromStr"
        ],
        "std::boxed::Box": [
            "std::clone::Clone"
        ],
        "std::string::String": [
            "header::map::as_header_name::AsHeaderName",
            "header::map::as_header_name::Sealed",
            "std::cmp::PartialEq",
            "std::cmp::PartialOrd"
        ],
        "uri::ErrorKind": [
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::StructuralPartialEq"
        ],
        "uri::InvalidUri": [
            "std::convert::From",
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "uri::InvalidUriParts": [
            "std::convert::From",
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "uri::Parts": [
            "std::convert::From",
            "std::default::Default",
            "std::fmt::Debug"
        ],
        "uri::Uri": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::convert::From",
            "std::convert::TryFrom",
            "std::default::Default",
            "std::fmt::Debug",
            "std::fmt::Display",
            "std::hash::Hash",
            "std::str::FromStr"
        ],
        "uri::authority::Authority": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::cmp::PartialOrd",
            "std::convert::AsRef",
            "std::convert::TryFrom",
            "std::fmt::Debug",
            "std::fmt::Display",
            "std::hash::Hash",
            "std::str::FromStr"
        ],
        "uri::builder::Builder": [
            "std::convert::From",
            "std::default::Default",
            "std::fmt::Debug"
        ],
        "uri::path::PathAndQuery": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::cmp::PartialOrd",
            "std::convert::TryFrom",
            "std::fmt::Debug",
            "std::fmt::Display",
            "std::hash::Hash",
            "std::str::FromStr"
        ],
        "uri::port::Port": [
            "std::cmp::PartialEq",
            "std::convert::AsRef",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "uri::scheme::Protocol": [
            "std::clone::Clone",
            "std::fmt::Debug",
            "std::marker::Copy"
        ],
        "uri::scheme::Scheme": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::convert::AsRef",
            "std::convert::From",
            "std::convert::TryFrom",
            "std::fmt::Debug",
            "std::fmt::Display",
            "std::hash::Hash",
            "std::str::FromStr"
        ],
        "uri::scheme::Scheme2": [
            "std::clone::Clone",
            "std::convert::From",
            "std::fmt::Debug"
        ],
        "version::Http": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::Ord",
            "std::cmp::PartialEq",
            "std::cmp::PartialOrd",
            "std::hash::Hash",
            "std::marker::Copy",
            "std::marker::StructuralPartialEq"
        ],
        "version::Version": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::Ord",
            "std::cmp::PartialEq",
            "std::cmp::PartialOrd",
            "std::default::Default",
            "std::fmt::Debug",
            "std::hash::Hash",
            "std::marker::Copy",
            "std::marker::StructuralPartialEq"
        ]
    },
    "targets": {
        "<&'a header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::IntoIterator"
        ],
        "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::as_str": [
            "as_str",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::find": [
            "find",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<&'a header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry": [
            "try_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_append": [
            "try_append",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::into_header_name::Sealed"
        ],
        "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry": [
            "try_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::into_header_name::Sealed"
        ],
        "<&'a header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert": [
            "try_insert",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::into_header_name::Sealed"
        ],
        "<&'a header::name::HeaderName as std::cmp::PartialEq<header::name::HeaderName>>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<&'a header::value::HeaderValue as std::cmp::PartialEq<header::value::HeaderValue>>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<&'a header::value::HeaderValue as std::cmp::PartialOrd<header::value::HeaderValue>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<&'a method::Method as std::cmp::PartialEq<method::Method>>::eq": [
            "eq",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<&'a mut header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::IntoIterator"
        ],
        "<&'a std::string::String as header::map::as_header_name::Sealed>::as_str": [
            "as_str",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<&'a std::string::String as header::map::as_header_name::Sealed>::find": [
            "find",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<&'a std::string::String as header::map::as_header_name::Sealed>::try_entry": [
            "try_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<&'a str as header::map::as_header_name::Sealed>::as_str": [
            "as_str",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<&'a str as header::map::as_header_name::Sealed>::find": [
            "find",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<&'a str as header::map::as_header_name::Sealed>::try_entry": [
            "try_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<&'b header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::IntoIterator"
        ],
        "<&'b header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::IntoIterator"
        ],
        "<&'b mut header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::IntoIterator"
        ],
        "<&'static str as header::map::into_header_name::Sealed>::try_append": [
            "try_append",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::into_header_name::Sealed"
        ],
        "<&'static str as header::map::into_header_name::Sealed>::try_entry": [
            "try_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::into_header_name::Sealed"
        ],
        "<&'static str as header::map::into_header_name::Sealed>::try_insert": [
            "try_insert",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::into_header_name::Sealed"
        ],
        "<T as extensions::AnyClone>::as_any": [
            "as_any",
            "Real(LocalPath(\"src/extensions.rs\"))",
            "extensions::AnyClone"
        ],
        "<T as extensions::AnyClone>::as_any_mut": [
            "as_any_mut",
            "Real(LocalPath(\"src/extensions.rs\"))",
            "extensions::AnyClone"
        ],
        "<T as extensions::AnyClone>::clone_box": [
            "clone_box",
            "Real(LocalPath(\"src/extensions.rs\"))",
            "extensions::AnyClone"
        ],
        "<T as extensions::AnyClone>::into_any": [
            "into_any",
            "Real(LocalPath(\"src/extensions.rs\"))",
            "extensions::AnyClone"
        ],
        "<byte_str::ByteStr as std::convert::From<&'a str>>::from": [
            "from",
            "Real(LocalPath(\"src/byte_str.rs\"))",
            "std::convert::From"
        ],
        "<byte_str::ByteStr as std::convert::From<std::string::String>>::from": [
            "from",
            "Real(LocalPath(\"src/byte_str.rs\"))",
            "std::convert::From"
        ],
        "<byte_str::ByteStr as std::ops::Deref>::deref": [
            "deref",
            "Real(LocalPath(\"src/byte_str.rs\"))",
            "std::ops::Deref"
        ],
        "<error::Error as std::convert::From<header::map::MaxSizeReached>>::from": [
            "from",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::convert::From"
        ],
        "<error::Error as std::convert::From<header::name::InvalidHeaderName>>::from": [
            "from",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::convert::From"
        ],
        "<error::Error as std::convert::From<header::value::InvalidHeaderValue>>::from": [
            "from",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::convert::From"
        ],
        "<error::Error as std::convert::From<method::InvalidMethod>>::from": [
            "from",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::convert::From"
        ],
        "<error::Error as std::convert::From<status::InvalidStatusCode>>::from": [
            "from",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::convert::From"
        ],
        "<error::Error as std::convert::From<std::convert::Infallible>>::from": [
            "from",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::convert::From"
        ],
        "<error::Error as std::convert::From<uri::InvalidUri>>::from": [
            "from",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::convert::From"
        ],
        "<error::Error as std::convert::From<uri::InvalidUriParts>>::from": [
            "from",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::convert::From"
        ],
        "<error::Error as std::error::Error>::source": [
            "source",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::error::Error"
        ],
        "<error::Error as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::fmt::Debug"
        ],
        "<error::Error as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/error.rs\"))",
            "std::fmt::Display"
        ],
        "<extensions::Extensions as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/extensions.rs\"))",
            "std::fmt::Debug"
        ],
        "<extensions::IdHasher as std::hash::Hasher>::finish": [
            "finish",
            "Real(LocalPath(\"src/extensions.rs\"))",
            "std::hash::Hasher"
        ],
        "<extensions::IdHasher as std::hash::Hasher>::write": [
            "write",
            "Real(LocalPath(\"src/extensions.rs\"))",
            "std::hash::Hasher"
        ],
        "<extensions::IdHasher as std::hash::Hasher>::write_u64": [
            "write_u64",
            "Real(LocalPath(\"src/extensions.rs\"))",
            "std::hash::Hasher"
        ],
        "<header::map::Drain<'a, T> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::Drain<'a, T> as std::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::Drain<'a, T> as std::ops::Drop>::drop": [
            "drop",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::ops::Drop"
        ],
        "<header::map::GetAll<'a, T> as std::cmp::PartialEq>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::map::GetAll<'a, T> as std::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::IntoIterator"
        ],
        "<header::map::HeaderMap<T> as std::cmp::PartialEq>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::map::HeaderMap<T> as std::convert::TryFrom<&'a std::collections::HashMap<K, V, S>>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::map::HeaderMap<T> as std::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::default::Default"
        ],
        "<header::map::HeaderMap<T> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::fmt::Debug"
        ],
        "<header::map::HeaderMap<T> as std::iter::Extend<(header::name::HeaderName, T)>>::extend": [
            "extend",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Extend"
        ],
        "<header::map::HeaderMap<T> as std::iter::Extend<(std::option::Option<header::name::HeaderName>, T)>>::extend": [
            "extend",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Extend"
        ],
        "<header::map::HeaderMap<T> as std::iter::FromIterator<(header::name::HeaderName, T)>>::from_iter": [
            "from_iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::FromIterator"
        ],
        "<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::IntoIterator"
        ],
        "<header::map::HeaderMap<T> as std::ops::Index<K>>::index": [
            "index",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::ops::Index"
        ],
        "<header::map::IntoIter<T> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::IntoIter<T> as std::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::IntoIter<T> as std::ops::Drop>::drop": [
            "drop",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::ops::Drop"
        ],
        "<header::map::Iter<'a, T> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::Iter<'a, T> as std::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::IterMut<'a, T> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::IterMut<'a, T> as std::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::count": [
            "count",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::last": [
            "last",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::nth": [
            "nth",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::Keys<'a, T> as std::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::MaxSizeReached as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::fmt::Debug"
        ],
        "<header::map::MaxSizeReached as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::fmt::Display"
        ],
        "<header::map::OccupiedEntry<'a, T> as std::iter::IntoIterator>::into_iter": [
            "into_iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::IntoIterator"
        ],
        "<header::map::RawLinks<T> as std::clone::Clone>::clone": [
            "clone",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::clone::Clone"
        ],
        "<header::map::RawLinks<T> as std::ops::Index<usize>>::index": [
            "index",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::ops::Index"
        ],
        "<header::map::RawLinks<T> as std::ops::IndexMut<usize>>::index_mut": [
            "index_mut",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::ops::IndexMut"
        ],
        "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::ValueDrain<'a, T> as std::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::ValueDrain<'a, T> as std::ops::Drop>::drop": [
            "drop",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::ops::Drop"
        ],
        "<header::map::ValueIter<'a, T> as std::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::DoubleEndedIterator"
        ],
        "<header::map::ValueIter<'a, T> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::ValueIter<'a, T> as std::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::ValueIterMut<'a, T> as std::iter::DoubleEndedIterator>::next_back": [
            "next_back",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::DoubleEndedIterator"
        ],
        "<header::map::ValueIterMut<'a, T> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::Values<'a, T> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::Values<'a, T> as std::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::ValuesMut<'a, T> as std::iter::Iterator>::size_hint": [
            "size_hint",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::iter::Iterator"
        ],
        "<header::map::as_header_name::TryEntryError as std::convert::From<header::map::MaxSizeReached>>::from": [
            "from",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::convert::From"
        ],
        "<header::map::as_header_name::TryEntryError as std::convert::From<header::name::InvalidHeaderName>>::from": [
            "from",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "std::convert::From"
        ],
        "<header::name::Custom as std::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::hash::Hash"
        ],
        "<header::name::HdrName<'a> as std::convert::From<header::name::StandardHeader>>::from": [
            "from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::From"
        ],
        "<header::name::HeaderName as header::map::as_header_name::Sealed>::as_str": [
            "as_str",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<header::name::HeaderName as header::map::as_header_name::Sealed>::find": [
            "find",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<header::name::HeaderName as header::map::as_header_name::Sealed>::try_entry": [
            "try_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<header::name::HeaderName as header::map::into_header_name::Sealed>::try_append": [
            "try_append",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::into_header_name::Sealed"
        ],
        "<header::name::HeaderName as header::map::into_header_name::Sealed>::try_entry": [
            "try_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::into_header_name::Sealed"
        ],
        "<header::name::HeaderName as header::map::into_header_name::Sealed>::try_insert": [
            "try_insert",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::into_header_name::Sealed"
        ],
        "<header::name::HeaderName as std::borrow::Borrow<str>>::borrow": [
            "borrow",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::borrow::Borrow"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<&'a header::name::HeaderName>>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<&'a str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<header::name::HdrName<'a>>>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::name::HeaderName as std::cmp::PartialEq<str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::name::HeaderName as std::convert::AsRef<[u8]>>::as_ref": [
            "as_ref",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::AsRef"
        ],
        "<header::name::HeaderName as std::convert::AsRef<str>>::as_ref": [
            "as_ref",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::AsRef"
        ],
        "<header::name::HeaderName as std::convert::From<&'a header::name::HeaderName>>::from": [
            "from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::From"
        ],
        "<header::name::HeaderName as std::convert::From<header::name::Custom>>::from": [
            "from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::From"
        ],
        "<header::name::HeaderName as std::convert::From<header::name::HdrName<'a>>>::from": [
            "from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::From"
        ],
        "<header::name::HeaderName as std::convert::From<header::name::StandardHeader>>::from": [
            "from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::From"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<&'a std::string::String>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<&'a str>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<std::string::String>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::name::HeaderName as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::name::HeaderName as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::fmt::Debug"
        ],
        "<header::name::HeaderName as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::fmt::Display"
        ],
        "<header::name::HeaderName as std::str::FromStr>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::str::FromStr"
        ],
        "<header::name::InvalidHeaderName as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::fmt::Debug"
        ],
        "<header::name::InvalidHeaderName as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::fmt::Display"
        ],
        "<header::name::MaybeLower<'a> as std::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::hash::Hash"
        ],
        "<header::value::HeaderValue as std::cmp::Ord>::cmp": [
            "cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::Ord"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<&'a T>>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<[u8]>>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<std::string::String>>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq<str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::value::HeaderValue as std::cmp::PartialEq>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<&'a T>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<[u8]>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<std::string::String>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd<str>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<header::value::HeaderValue as std::cmp::PartialOrd>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<header::value::HeaderValue as std::convert::AsRef<[u8]>>::as_ref": [
            "as_ref",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::AsRef"
        ],
        "<header::value::HeaderValue as std::convert::From<&'a header::value::HeaderValue>>::from": [
            "from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::From"
        ],
        "<header::value::HeaderValue as std::convert::From<header::name::HeaderName>>::from": [
            "from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::From"
        ],
        "<header::value::HeaderValue as std::convert::From<i16>>::from": [
            "from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::From"
        ],
        "<header::value::HeaderValue as std::convert::From<i32>>::from": [
            "from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::From"
        ],
        "<header::value::HeaderValue as std::convert::From<i64>>::from": [
            "from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::From"
        ],
        "<header::value::HeaderValue as std::convert::From<isize>>::from": [
            "from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::From"
        ],
        "<header::value::HeaderValue as std::convert::From<u16>>::from": [
            "from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::From"
        ],
        "<header::value::HeaderValue as std::convert::From<u32>>::from": [
            "from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::From"
        ],
        "<header::value::HeaderValue as std::convert::From<u64>>::from": [
            "from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::From"
        ],
        "<header::value::HeaderValue as std::convert::From<usize>>::from": [
            "from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::From"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<&'a std::string::String>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<&'a str>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<std::string::String>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::value::HeaderValue as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::convert::TryFrom"
        ],
        "<header::value::HeaderValue as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::fmt::Debug"
        ],
        "<header::value::HeaderValue as std::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::hash::Hash"
        ],
        "<header::value::HeaderValue as std::str::FromStr>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::str::FromStr"
        ],
        "<header::value::InvalidHeaderValue as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::fmt::Debug"
        ],
        "<header::value::InvalidHeaderValue as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::fmt::Display"
        ],
        "<header::value::ToStrError as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::fmt::Display"
        ],
        "<method::InvalidMethod as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::fmt::Debug"
        ],
        "<method::InvalidMethod as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::fmt::Display"
        ],
        "<method::Method as std::cmp::PartialEq<&'a method::Method>>::eq": [
            "eq",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<method::Method as std::cmp::PartialEq<&'a str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<method::Method as std::cmp::PartialEq<str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<method::Method as std::convert::AsRef<str>>::as_ref": [
            "as_ref",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::convert::AsRef"
        ],
        "<method::Method as std::convert::From<&'a method::Method>>::from": [
            "from",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::convert::From"
        ],
        "<method::Method as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::convert::TryFrom"
        ],
        "<method::Method as std::convert::TryFrom<&'a str>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::convert::TryFrom"
        ],
        "<method::Method as std::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::default::Default"
        ],
        "<method::Method as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::fmt::Debug"
        ],
        "<method::Method as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::fmt::Display"
        ],
        "<method::Method as std::str::FromStr>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::str::FromStr"
        ],
        "<request::Builder as std::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/request.rs\"))",
            "std::default::Default"
        ],
        "<request::Parts as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/request.rs\"))",
            "std::fmt::Debug"
        ],
        "<request::Request<T> as std::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/request.rs\"))",
            "std::default::Default"
        ],
        "<request::Request<T> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/request.rs\"))",
            "std::fmt::Debug"
        ],
        "<response::Builder as std::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/response.rs\"))",
            "std::default::Default"
        ],
        "<response::Parts as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/response.rs\"))",
            "std::fmt::Debug"
        ],
        "<response::Response<T> as std::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/response.rs\"))",
            "std::default::Default"
        ],
        "<response::Response<T> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/response.rs\"))",
            "std::fmt::Debug"
        ],
        "<status::InvalidStatusCode as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::fmt::Debug"
        ],
        "<status::InvalidStatusCode as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::fmt::Display"
        ],
        "<status::StatusCode as std::cmp::PartialEq<u16>>::eq": [
            "eq",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<status::StatusCode as std::convert::From<&'a status::StatusCode>>::from": [
            "from",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::convert::From"
        ],
        "<status::StatusCode as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::convert::TryFrom"
        ],
        "<status::StatusCode as std::convert::TryFrom<&'a str>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::convert::TryFrom"
        ],
        "<status::StatusCode as std::convert::TryFrom<u16>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::convert::TryFrom"
        ],
        "<status::StatusCode as std::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::default::Default"
        ],
        "<status::StatusCode as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::fmt::Debug"
        ],
        "<status::StatusCode as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::fmt::Display"
        ],
        "<status::StatusCode as std::str::FromStr>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::str::FromStr"
        ],
        "<std::string::String as header::map::as_header_name::Sealed>::as_str": [
            "as_str",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<std::string::String as header::map::as_header_name::Sealed>::find": [
            "find",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<std::string::String as header::map::as_header_name::Sealed>::try_entry": [
            "try_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            "header::map::as_header_name::Sealed"
        ],
        "<uri::InvalidUri as std::convert::From<uri::ErrorKind>>::from": [
            "from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::From"
        ],
        "<uri::InvalidUri as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::fmt::Display"
        ],
        "<uri::InvalidUriParts as std::convert::From<uri::ErrorKind>>::from": [
            "from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::From"
        ],
        "<uri::InvalidUriParts as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::fmt::Display"
        ],
        "<uri::Parts as std::convert::From<uri::Uri>>::from": [
            "from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::From"
        ],
        "<uri::Uri as std::cmp::PartialEq<&'a str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::Uri as std::cmp::PartialEq<str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::Uri as std::cmp::PartialEq>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::Uri as std::convert::From<uri::authority::Authority>>::from": [
            "from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::From"
        ],
        "<uri::Uri as std::convert::From<uri::path::PathAndQuery>>::from": [
            "from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::From"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a std::string::String>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a str>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::Uri as std::convert::TryFrom<&'a uri::Uri>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::Uri as std::convert::TryFrom<std::string::String>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::Uri as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::Uri as std::convert::TryFrom<uri::Parts>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::Uri as std::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::default::Default"
        ],
        "<uri::Uri as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::fmt::Debug"
        ],
        "<uri::Uri as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::fmt::Display"
        ],
        "<uri::Uri as std::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::hash::Hash"
        ],
        "<uri::Uri as std::str::FromStr>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::str::FromStr"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq<&'a str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq<std::string::String>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq<str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::authority::Authority as std::cmp::PartialEq>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd<&'a str>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd<std::string::String>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd<str>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<uri::authority::Authority as std::cmp::PartialOrd>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<uri::authority::Authority as std::convert::AsRef<str>>::as_ref": [
            "as_ref",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::convert::AsRef"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<&'a str>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<std::string::String>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::authority::Authority as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::authority::Authority as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::fmt::Debug"
        ],
        "<uri::authority::Authority as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::fmt::Display"
        ],
        "<uri::authority::Authority as std::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::hash::Hash"
        ],
        "<uri::authority::Authority as std::str::FromStr>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::str::FromStr"
        ],
        "<uri::builder::Builder as std::convert::From<uri::Uri>>::from": [
            "from",
            "Real(LocalPath(\"src/uri/builder.rs\"))",
            "std::convert::From"
        ],
        "<uri::builder::Builder as std::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/uri/builder.rs\"))",
            "std::default::Default"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq<&'a str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq<std::string::String>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq<str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialEq>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd<&'a str>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd<std::string::String>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd<str>>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<uri::path::PathAndQuery as std::cmp::PartialOrd>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<&'a str>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<&std::string::String>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<std::string::String>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::path::PathAndQuery as std::convert::TryFrom<std::vec::Vec<u8>>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::path::PathAndQuery as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::fmt::Debug"
        ],
        "<uri::path::PathAndQuery as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::fmt::Display"
        ],
        "<uri::path::PathAndQuery as std::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::hash::Hash"
        ],
        "<uri::path::PathAndQuery as std::str::FromStr>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::str::FromStr"
        ],
        "<uri::port::Port<T> as std::cmp::PartialEq<u16>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/port.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::port::Port<T> as std::cmp::PartialEq<uri::port::Port<U>>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/port.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::port::Port<T> as std::convert::AsRef<str>>::as_ref": [
            "as_ref",
            "Real(LocalPath(\"src/uri/port.rs\"))",
            "std::convert::AsRef"
        ],
        "<uri::port::Port<T> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/port.rs\"))",
            "std::fmt::Debug"
        ],
        "<uri::port::Port<T> as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/port.rs\"))",
            "std::fmt::Display"
        ],
        "<uri::scheme::Scheme as std::cmp::PartialEq<str>>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::scheme::Scheme as std::cmp::PartialEq>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::cmp::PartialEq"
        ],
        "<uri::scheme::Scheme as std::convert::AsRef<str>>::as_ref": [
            "as_ref",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::convert::AsRef"
        ],
        "<uri::scheme::Scheme as std::convert::From<uri::scheme::Scheme2>>::from": [
            "from",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::convert::From"
        ],
        "<uri::scheme::Scheme as std::convert::TryFrom<&'a [u8]>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::scheme::Scheme as std::convert::TryFrom<&'a str>>::try_from": [
            "try_from",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::convert::TryFrom"
        ],
        "<uri::scheme::Scheme as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::fmt::Debug"
        ],
        "<uri::scheme::Scheme as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::fmt::Display"
        ],
        "<uri::scheme::Scheme as std::hash::Hash>::hash": [
            "hash",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::hash::Hash"
        ],
        "<uri::scheme::Scheme as std::str::FromStr>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::str::FromStr"
        ],
        "<uri::scheme::Scheme2<T> as std::convert::From<uri::scheme::Protocol>>::from": [
            "from",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::convert::From"
        ],
        "<version::Version as std::default::Default>::default": [
            "default",
            "Real(LocalPath(\"src/version.rs\"))",
            "std::default::Default"
        ],
        "<version::Version as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/version.rs\"))",
            "std::fmt::Debug"
        ],
        "byte_str::<impl std::convert::From<byte_str::ByteStr> for bytes::Bytes>::from": [
            "from",
            "Real(LocalPath(\"src/byte_str.rs\"))",
            "std::convert::From"
        ],
        "byte_str::ByteStr::from_static": [
            "from_static",
            "Real(LocalPath(\"src/byte_str.rs\"))",
            ""
        ],
        "byte_str::ByteStr::from_utf8": [
            "from_utf8",
            "Real(LocalPath(\"src/byte_str.rs\"))",
            ""
        ],
        "byte_str::ByteStr::from_utf8_unchecked": [
            "from_utf8_unchecked",
            "Real(LocalPath(\"src/byte_str.rs\"))",
            ""
        ],
        "byte_str::ByteStr::new": [
            "new",
            "Real(LocalPath(\"src/byte_str.rs\"))",
            ""
        ],
        "error::Error::get_ref": [
            "get_ref",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "error::Error::is": [
            "is",
            "Real(LocalPath(\"src/error.rs\"))",
            ""
        ],
        "extensions::<impl std::clone::Clone for std::boxed::Box<(dyn extensions::AnyClone + std::marker::Send + std::marker::Sync + 'static)>>::clone": [
            "clone",
            "Real(LocalPath(\"src/extensions.rs\"))",
            "std::clone::Clone"
        ],
        "extensions::Extensions::clear": [
            "clear",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::extend": [
            "extend",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::get": [
            "get",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::get_or_insert": [
            "get_or_insert",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::get_or_insert_default": [
            "get_or_insert_default",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::get_or_insert_with": [
            "get_or_insert_with",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::insert": [
            "insert",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::is_empty": [
            "is_empty",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::len": [
            "len",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::new": [
            "new",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "extensions::Extensions::remove": [
            "remove",
            "Real(LocalPath(\"src/extensions.rs\"))",
            ""
        ],
        "header::map::Danger::is_red": [
            "is_red",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Danger::is_yellow": [
            "is_yellow",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Danger::set_green": [
            "set_green",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Danger::set_red": [
            "set_red",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Danger::set_yellow": [
            "set_yellow",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Entry::<'a, T>::key": [
            "key",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Entry::<'a, T>::or_insert": [
            "or_insert",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Entry::<'a, T>::or_insert_with": [
            "or_insert_with",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Entry::<'a, T>::or_try_insert": [
            "or_try_insert",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Entry::<'a, T>::or_try_insert_with": [
            "or_try_insert_with",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::GetAll::<'a, T>::iter": [
            "iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::append": [
            "append",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::capacity": [
            "capacity",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::clear": [
            "clear",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::contains_key": [
            "contains_key",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::drain": [
            "drain",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::entry": [
            "entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::find": [
            "find",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::get": [
            "get",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::get2": [
            "get2",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::get_all": [
            "get_all",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::insert": [
            "insert",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::insert_occupied": [
            "insert_occupied",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::insert_occupied_mult": [
            "insert_occupied_mult",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::is_empty": [
            "is_empty",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::iter": [
            "iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::iter_mut": [
            "iter_mut",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::keys": [
            "keys",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::keys_len": [
            "keys_len",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::len": [
            "len",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::raw_links": [
            "raw_links",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::rebuild": [
            "rebuild",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::reinsert_entry_in_order": [
            "reinsert_entry_in_order",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::remove": [
            "remove",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::remove_all_extra_values": [
            "remove_all_extra_values",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::remove_extra_value": [
            "remove_extra_value",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::remove_found": [
            "remove_found",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::reserve": [
            "reserve",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_append": [
            "try_append",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_append2": [
            "try_append2",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_entry": [
            "try_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_entry2": [
            "try_entry2",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_grow": [
            "try_grow",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_insert": [
            "try_insert",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_insert2": [
            "try_insert2",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_insert_entry": [
            "try_insert_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_insert_phase_two": [
            "try_insert_phase_two",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_reserve": [
            "try_reserve",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_reserve_one": [
            "try_reserve_one",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::try_with_capacity": [
            "try_with_capacity",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::value_iter": [
            "value_iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::value_iter_mut": [
            "value_iter_mut",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::values": [
            "values",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::values_mut": [
            "values_mut",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::<T>::with_capacity": [
            "with_capacity",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::HeaderMap::new": [
            "new",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::IterMut::<'a, T>::next_unsafe": [
            "next_unsafe",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::MaxSizeReached::new": [
            "new",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::append": [
            "append",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::get": [
            "get",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::insert": [
            "insert",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::insert_mult": [
            "insert_mult",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::into_mut": [
            "into_mut",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::iter": [
            "iter",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::iter_mut": [
            "iter_mut",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::key": [
            "key",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::remove": [
            "remove",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::remove_entry": [
            "remove_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::OccupiedEntry::<'a, T>::remove_entry_mult": [
            "remove_entry_mult",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Pos::is_none": [
            "is_none",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Pos::is_some": [
            "is_some",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Pos::new": [
            "new",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Pos::none": [
            "none",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::Pos::resolve": [
            "resolve",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::VacantEntry::<'a, T>::insert": [
            "insert",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::VacantEntry::<'a, T>::insert_entry": [
            "insert_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::VacantEntry::<'a, T>::into_key": [
            "into_key",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::VacantEntry::<'a, T>::key": [
            "key",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::VacantEntry::<'a, T>::try_insert": [
            "try_insert",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::VacantEntry::<'a, T>::try_insert_entry": [
            "try_insert_entry",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::append_value": [
            "append_value",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::desired_pos": [
            "desired_pos",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::do_insert_phase_two": [
            "do_insert_phase_two",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::drain_all_extra_values": [
            "drain_all_extra_values",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::hash_elem_using": [
            "hash_elem_using",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::probe_distance": [
            "probe_distance",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::remove_extra_value": [
            "remove_extra_value",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::to_raw_capacity": [
            "to_raw_capacity",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::map::usable_capacity": [
            "usable_capacity",
            "Real(LocalPath(\"src/header/map.rs\"))",
            ""
        ],
        "header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for &'a str>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::cmp::PartialEq"
        ],
        "header::name::<impl std::cmp::PartialEq<header::name::HeaderName> for str>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::cmp::PartialEq"
        ],
        "header::name::<impl std::convert::From<header::name::Custom> for bytes::Bytes>::from": [
            "from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::From"
        ],
        "header::name::<impl std::convert::From<header::name::Repr<T>> for bytes::Bytes>::from": [
            "from",
            "Real(LocalPath(\"src/header/name.rs\"))",
            "std::convert::From"
        ],
        "header::name::HdrName::<'a>::custom": [
            "custom",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::HdrName::<'a>::from_bytes": [
            "from_bytes",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::HdrName::<'a>::from_static": [
            "from_static",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::HeaderName::as_str": [
            "as_str",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::HeaderName::from_bytes": [
            "from_bytes",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::HeaderName::from_lowercase": [
            "from_lowercase",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::HeaderName::from_static": [
            "from_static",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::HeaderName::into_bytes": [
            "into_bytes",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::InvalidHeaderName::new": [
            "new",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::StandardHeader::as_str": [
            "as_str",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::StandardHeader::from_bytes": [
            "from_bytes",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::eq_ignore_ascii_case": [
            "eq_ignore_ascii_case",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::parse_hdr": [
            "parse_hdr",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::slice_assume_init": [
            "slice_assume_init",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::name::uninit_u8_array": [
            "uninit_u8_array",
            "Real(LocalPath(\"src/header/name.rs\"))",
            ""
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for &'a str>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialEq"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for [u8]>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialEq"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for std::string::String>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialEq"
        ],
        "header::value::<impl std::cmp::PartialEq<header::value::HeaderValue> for str>::eq": [
            "eq",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialEq"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for &'a str>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for [u8]>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for std::string::String>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "header::value::<impl std::cmp::PartialOrd<header::value::HeaderValue> for str>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/header/value.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "header::value::HeaderValue::as_bytes": [
            "as_bytes",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::from_bytes": [
            "from_bytes",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::from_maybe_shared": [
            "from_maybe_shared",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::from_maybe_shared_unchecked": [
            "from_maybe_shared_unchecked",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::from_name": [
            "from_name",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::from_shared": [
            "from_shared",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::from_static": [
            "from_static",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::from_str": [
            "from_str",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::is_empty": [
            "is_empty",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::is_sensitive": [
            "is_sensitive",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::len": [
            "len",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::set_sensitive": [
            "set_sensitive",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::to_str": [
            "to_str",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::HeaderValue::try_from_generic": [
            "try_from_generic",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::is_valid": [
            "is_valid",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "header::value::is_visible_ascii": [
            "is_visible_ascii",
            "Real(LocalPath(\"src/header/value.rs\"))",
            ""
        ],
        "method::<impl std::cmp::PartialEq<method::Method> for &'a str>::eq": [
            "eq",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::cmp::PartialEq"
        ],
        "method::<impl std::cmp::PartialEq<method::Method> for str>::eq": [
            "eq",
            "Real(LocalPath(\"src/method.rs\"))",
            "std::cmp::PartialEq"
        ],
        "method::InvalidMethod::new": [
            "new",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "method::Method::as_str": [
            "as_str",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "method::Method::extension_inline": [
            "extension_inline",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "method::Method::from_bytes": [
            "from_bytes",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "method::Method::is_idempotent": [
            "is_idempotent",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "method::Method::is_safe": [
            "is_safe",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "method::extension::AllocatedExtension::as_str": [
            "as_str",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "method::extension::AllocatedExtension::new": [
            "new",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "method::extension::InlineExtension::as_str": [
            "as_str",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "method::extension::InlineExtension::new": [
            "new",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "method::extension::write_checked": [
            "write_checked",
            "Real(LocalPath(\"src/method.rs\"))",
            ""
        ],
        "request::Builder::and_then": [
            "and_then",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::body": [
            "body",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::extension": [
            "extension",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::extensions_mut": [
            "extensions_mut",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::extensions_ref": [
            "extensions_ref",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::header": [
            "header",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::headers_mut": [
            "headers_mut",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::headers_ref": [
            "headers_ref",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::method": [
            "method",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::method_ref": [
            "method_ref",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::new": [
            "new",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::uri": [
            "uri",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::uri_ref": [
            "uri_ref",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::version": [
            "version",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Builder::version_ref": [
            "version_ref",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Parts::new": [
            "new",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<()>::builder": [
            "builder",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<()>::connect": [
            "connect",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<()>::delete": [
            "delete",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<()>::get": [
            "get",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<()>::head": [
            "head",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<()>::options": [
            "options",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<()>::patch": [
            "patch",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<()>::post": [
            "post",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<()>::put": [
            "put",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<()>::trace": [
            "trace",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::body": [
            "body",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::body_mut": [
            "body_mut",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::extensions": [
            "extensions",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::extensions_mut": [
            "extensions_mut",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::from_parts": [
            "from_parts",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::headers": [
            "headers",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::headers_mut": [
            "headers_mut",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::into_body": [
            "into_body",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::into_parts": [
            "into_parts",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::map": [
            "map",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::method": [
            "method",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::method_mut": [
            "method_mut",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::new": [
            "new",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::uri": [
            "uri",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::uri_mut": [
            "uri_mut",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::version": [
            "version",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "request::Request::<T>::version_mut": [
            "version_mut",
            "Real(LocalPath(\"src/request.rs\"))",
            ""
        ],
        "response::Builder::and_then": [
            "and_then",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Builder::body": [
            "body",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Builder::extension": [
            "extension",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Builder::extensions_mut": [
            "extensions_mut",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Builder::extensions_ref": [
            "extensions_ref",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Builder::header": [
            "header",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Builder::headers_mut": [
            "headers_mut",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Builder::headers_ref": [
            "headers_ref",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Builder::new": [
            "new",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Builder::status": [
            "status",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Builder::version": [
            "version",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Parts::new": [
            "new",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<()>::builder": [
            "builder",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::body": [
            "body",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::body_mut": [
            "body_mut",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::extensions": [
            "extensions",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::extensions_mut": [
            "extensions_mut",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::from_parts": [
            "from_parts",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::headers": [
            "headers",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::headers_mut": [
            "headers_mut",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::into_body": [
            "into_body",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::into_parts": [
            "into_parts",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::map": [
            "map",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::new": [
            "new",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::status": [
            "status",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::status_mut": [
            "status_mut",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::version": [
            "version",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "response::Response::<T>::version_mut": [
            "version_mut",
            "Real(LocalPath(\"src/response.rs\"))",
            ""
        ],
        "status::<impl std::cmp::PartialEq<status::StatusCode> for u16>::eq": [
            "eq",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::cmp::PartialEq"
        ],
        "status::<impl std::convert::From<status::StatusCode> for u16>::from": [
            "from",
            "Real(LocalPath(\"src/status.rs\"))",
            "std::convert::From"
        ],
        "status::InvalidStatusCode::new": [
            "new",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::StatusCode::as_str": [
            "as_str",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::StatusCode::as_u16": [
            "as_u16",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::StatusCode::canonical_reason": [
            "canonical_reason",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::StatusCode::from_bytes": [
            "from_bytes",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::StatusCode::from_u16": [
            "from_u16",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::StatusCode::is_client_error": [
            "is_client_error",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::StatusCode::is_informational": [
            "is_informational",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::StatusCode::is_redirection": [
            "is_redirection",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::StatusCode::is_server_error": [
            "is_server_error",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::StatusCode::is_success": [
            "is_success",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "status::canonical_reason": [
            "canonical_reason",
            "Real(LocalPath(\"src/status.rs\"))",
            ""
        ],
        "uri::<impl std::cmp::PartialEq<uri::Uri> for &'a str>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::cmp::PartialEq"
        ],
        "uri::<impl std::cmp::PartialEq<uri::Uri> for str>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            "std::cmp::PartialEq"
        ],
        "uri::InvalidUri::s": [
            "s",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::authority": [
            "authority",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::builder": [
            "builder",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::from_maybe_shared": [
            "from_maybe_shared",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::from_parts": [
            "from_parts",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::from_shared": [
            "from_shared",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::from_static": [
            "from_static",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::has_path": [
            "has_path",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::host": [
            "host",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::into_parts": [
            "into_parts",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::path": [
            "path",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::path_and_query": [
            "path_and_query",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::port": [
            "port",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::port_u16": [
            "port_u16",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::query": [
            "query",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::scheme": [
            "scheme",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::Uri::scheme_str": [
            "scheme_str",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for &'a str>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialEq"
        ],
        "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for std::string::String>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialEq"
        ],
        "uri::authority::<impl std::cmp::PartialEq<uri::authority::Authority> for str>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialEq"
        ],
        "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for &'a str>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for std::string::String>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "uri::authority::<impl std::cmp::PartialOrd<uri::authority::Authority> for str>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "uri::authority::Authority::as_str": [
            "as_str",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::Authority::empty": [
            "empty",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::Authority::from_maybe_shared": [
            "from_maybe_shared",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::Authority::from_shared": [
            "from_shared",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::Authority::from_static": [
            "from_static",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::Authority::host": [
            "host",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::Authority::parse": [
            "parse",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::Authority::parse_non_empty": [
            "parse_non_empty",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::Authority::port": [
            "port",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::Authority::port_u16": [
            "port_u16",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::create_authority": [
            "create_authority",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::authority::host": [
            "host",
            "Real(LocalPath(\"src/uri/authority.rs\"))",
            ""
        ],
        "uri::builder::Builder::authority": [
            "authority",
            "Real(LocalPath(\"src/uri/builder.rs\"))",
            ""
        ],
        "uri::builder::Builder::build": [
            "build",
            "Real(LocalPath(\"src/uri/builder.rs\"))",
            ""
        ],
        "uri::builder::Builder::map": [
            "map",
            "Real(LocalPath(\"src/uri/builder.rs\"))",
            ""
        ],
        "uri::builder::Builder::new": [
            "new",
            "Real(LocalPath(\"src/uri/builder.rs\"))",
            ""
        ],
        "uri::builder::Builder::path_and_query": [
            "path_and_query",
            "Real(LocalPath(\"src/uri/builder.rs\"))",
            ""
        ],
        "uri::builder::Builder::scheme": [
            "scheme",
            "Real(LocalPath(\"src/uri/builder.rs\"))",
            ""
        ],
        "uri::parse_full": [
            "parse_full",
            "Real(LocalPath(\"src/uri/mod.rs\"))",
            ""
        ],
        "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for &'a str>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialEq"
        ],
        "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for std::string::String>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialEq"
        ],
        "uri::path::<impl std::cmp::PartialEq<uri::path::PathAndQuery> for str>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialEq"
        ],
        "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for &'a str>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for std::string::String>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "uri::path::<impl std::cmp::PartialOrd<uri::path::PathAndQuery> for str>::partial_cmp": [
            "partial_cmp",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            "std::cmp::PartialOrd"
        ],
        "uri::path::PathAndQuery::as_str": [
            "as_str",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            ""
        ],
        "uri::path::PathAndQuery::empty": [
            "empty",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            ""
        ],
        "uri::path::PathAndQuery::from_maybe_shared": [
            "from_maybe_shared",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            ""
        ],
        "uri::path::PathAndQuery::from_shared": [
            "from_shared",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            ""
        ],
        "uri::path::PathAndQuery::from_static": [
            "from_static",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            ""
        ],
        "uri::path::PathAndQuery::path": [
            "path",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            ""
        ],
        "uri::path::PathAndQuery::query": [
            "query",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            ""
        ],
        "uri::path::PathAndQuery::slash": [
            "slash",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            ""
        ],
        "uri::path::PathAndQuery::star": [
            "star",
            "Real(LocalPath(\"src/uri/path.rs\"))",
            ""
        ],
        "uri::port::<impl std::cmp::PartialEq<uri::port::Port<T>> for u16>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/port.rs\"))",
            "std::cmp::PartialEq"
        ],
        "uri::port::<impl std::convert::From<uri::port::Port<T>> for u16>::from": [
            "from",
            "Real(LocalPath(\"src/uri/port.rs\"))",
            "std::convert::From"
        ],
        "uri::port::Port::<T>::as_str": [
            "as_str",
            "Real(LocalPath(\"src/uri/port.rs\"))",
            ""
        ],
        "uri::port::Port::<T>::as_u16": [
            "as_u16",
            "Real(LocalPath(\"src/uri/port.rs\"))",
            ""
        ],
        "uri::port::Port::<T>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/uri/port.rs\"))",
            ""
        ],
        "uri::scheme::<impl std::cmp::PartialEq<uri::scheme::Scheme> for str>::eq": [
            "eq",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            "std::cmp::PartialEq"
        ],
        "uri::scheme::Protocol::len": [
            "len",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            ""
        ],
        "uri::scheme::Scheme2::<T>::is_none": [
            "is_none",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            ""
        ],
        "uri::scheme::Scheme2::<usize>::parse": [
            "parse",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            ""
        ],
        "uri::scheme::Scheme2::<usize>::parse_exact": [
            "parse_exact",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            ""
        ],
        "uri::scheme::Scheme::as_str": [
            "as_str",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            ""
        ],
        "uri::scheme::Scheme::empty": [
            "empty",
            "Real(LocalPath(\"src/uri/scheme.rs\"))",
            ""
        ]
    },
    "trait_to_struct": {
        "extensions::AnyClone": [
            "<T as extensions::AnyClone>::T"
        ],
        "header::map::as_header_name::AsHeaderName": [
            "header::name::HeaderName",
            "std::string::String"
        ],
        "header::map::as_header_name::Sealed": [
            "header::name::HeaderName",
            "std::string::String"
        ],
        "header::map::into_header_name::IntoHeaderName": [
            "header::name::HeaderName"
        ],
        "header::map::into_header_name::Sealed": [
            "header::name::HeaderName"
        ],
        "std::borrow::Borrow": [
            "header::name::HeaderName"
        ],
        "std::clone::Clone": [
            "byte_str::ByteStr",
            "extensions::Extensions",
            "header::map::Bucket",
            "header::map::Cursor",
            "header::map::Danger",
            "header::map::ExtraValue",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::Link",
            "header::map::Links",
            "header::map::Pos",
            "header::map::RawLinks",
            "header::name::Custom",
            "header::name::HeaderName",
            "header::name::MaybeLower",
            "header::name::Repr",
            "header::name::StandardHeader",
            "header::value::HeaderValue",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "request::Parts",
            "request::Request",
            "response::Parts",
            "response::Response",
            "status::StatusCode",
            "std::boxed::Box",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Http",
            "version::Version"
        ],
        "std::cmp::Eq": [
            "byte_str::ByteStr",
            "header::map::Cursor",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::Link",
            "header::name::Custom",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "header::value::HeaderValue",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "status::StatusCode",
            "uri::ErrorKind",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Scheme",
            "version::Http",
            "version::Version"
        ],
        "std::cmp::Ord": [
            "byte_str::ByteStr",
            "header::value::HeaderValue",
            "status::StatusCode",
            "version::Http",
            "version::Version"
        ],
        "std::cmp::PartialEq": [
            "byte_str::ByteStr",
            "header::map::Cursor",
            "header::map::GetAll",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::Link",
            "header::name::Custom",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "header::value::HeaderValue",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "status::StatusCode",
            "std::string::String",
            "uri::ErrorKind",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::port::Port",
            "uri::scheme::Scheme",
            "version::Http",
            "version::Version"
        ],
        "std::cmp::PartialOrd": [
            "byte_str::ByteStr",
            "header::value::HeaderValue",
            "status::StatusCode",
            "std::string::String",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "version::Http",
            "version::Version"
        ],
        "std::convert::AsRef": [
            "header::name::HeaderName",
            "header::value::HeaderValue",
            "method::Method",
            "uri::authority::Authority",
            "uri::port::Port",
            "uri::scheme::Scheme"
        ],
        "std::convert::From": [
            "byte_str::ByteStr",
            "bytes::Bytes",
            "error::Error",
            "header::map::as_header_name::TryEntryError",
            "header::name::HdrName",
            "header::name::HeaderName",
            "header::value::HeaderValue",
            "method::Method",
            "status::StatusCode",
            "uri::InvalidUri",
            "uri::InvalidUriParts",
            "uri::Parts",
            "uri::Uri",
            "uri::builder::Builder",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2"
        ],
        "std::convert::TryFrom": [
            "header::map::HeaderMap",
            "header::name::HeaderName",
            "header::value::HeaderValue",
            "method::Method",
            "status::StatusCode",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Scheme"
        ],
        "std::default::Default": [
            "extensions::Extensions",
            "extensions::IdHasher",
            "header::map::HeaderMap",
            "method::Method",
            "request::Builder",
            "request::Request",
            "response::Builder",
            "response::Response",
            "status::StatusCode",
            "uri::Parts",
            "uri::Uri",
            "uri::builder::Builder",
            "version::Version"
        ],
        "std::error::Error": [
            "error::Error",
            "header::map::MaxSizeReached",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "header::value::ToStrError",
            "method::InvalidMethod",
            "status::InvalidStatusCode",
            "uri::InvalidUri",
            "uri::InvalidUriParts"
        ],
        "std::fmt::Debug": [
            "byte_str::ByteStr",
            "error::Error",
            "extensions::Extensions",
            "header::map::Bucket",
            "header::map::Cursor",
            "header::map::Drain",
            "header::map::Entry",
            "header::map::ExtraValue",
            "header::map::GetAll",
            "header::map::HashValue",
            "header::map::HeaderMap",
            "header::map::IntoIter",
            "header::map::Iter",
            "header::map::IterMut",
            "header::map::Keys",
            "header::map::Link",
            "header::map::Links",
            "header::map::MaxSizeReached",
            "header::map::OccupiedEntry",
            "header::map::RawLinks",
            "header::map::VacantEntry",
            "header::map::ValueDrain",
            "header::map::ValueIter",
            "header::map::ValueIterMut",
            "header::map::Values",
            "header::map::ValuesMut",
            "header::name::Custom",
            "header::name::HdrName",
            "header::name::HeaderName",
            "header::name::InvalidHeaderName",
            "header::name::MaybeLower",
            "header::name::Repr",
            "header::name::StandardHeader",
            "header::value::HeaderValue",
            "header::value::InvalidHeaderValue",
            "header::value::ToStrError",
            "method::InvalidMethod",
            "method::Method",
            "request::Builder",
            "request::Parts",
            "request::Request",
            "response::Builder",
            "response::Parts",
            "response::Response",
            "status::InvalidStatusCode",
            "status::StatusCode",
            "uri::ErrorKind",
            "uri::InvalidUri",
            "uri::InvalidUriParts",
            "uri::Parts",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::builder::Builder",
            "uri::path::PathAndQuery",
            "uri::port::Port",
            "uri::scheme::Protocol",
            "uri::scheme::Scheme",
            "uri::scheme::Scheme2",
            "version::Version"
        ],
        "std::fmt::Display": [
            "error::Error",
            "header::map::MaxSizeReached",
            "header::name::HeaderName",
            "header::name::InvalidHeaderName",
            "header::value::InvalidHeaderValue",
            "header::value::ToStrError",
            "method::InvalidMethod",
            "method::Method",
            "status::InvalidStatusCode",
            "status::StatusCode",
            "uri::InvalidUri",
            "uri::InvalidUriParts",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::port::Port",
            "uri::scheme::Scheme"
        ],
        "std::hash::Hash": [
            "byte_str::ByteStr",
            "header::name::Custom",
            "header::name::HdrName",
            "header::name::HeaderName",
            "header::name::MaybeLower",
            "header::name::Repr",
            "header::name::StandardHeader",
            "header::value::HeaderValue",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "status::StatusCode",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Scheme",
            "version::Http",
            "version::Version"
        ],
        "std::hash::Hasher": [
            "extensions::IdHasher"
        ],
        "std::iter::DoubleEndedIterator": [
            "header::map::ValueIter",
            "header::map::ValueIterMut"
        ],
        "std::iter::ExactSizeIterator": [
            "header::map::Keys"
        ],
        "std::iter::Extend": [
            "header::map::HeaderMap"
        ],
        "std::iter::FromIterator": [
            "header::map::HeaderMap"
        ],
        "std::iter::FusedIterator": [
            "header::map::Drain",
            "header::map::IntoIter",
            "header::map::Iter",
            "header::map::IterMut",
            "header::map::Keys",
            "header::map::ValueDrain",
            "header::map::ValueIter",
            "header::map::ValueIterMut",
            "header::map::Values",
            "header::map::ValuesMut"
        ],
        "std::iter::IntoIterator": [
            "header::map::GetAll",
            "header::map::HeaderMap",
            "header::map::OccupiedEntry"
        ],
        "std::iter::Iterator": [
            "header::map::Drain",
            "header::map::IntoIter",
            "header::map::Iter",
            "header::map::IterMut",
            "header::map::Keys",
            "header::map::ValueDrain",
            "header::map::ValueIter",
            "header::map::ValueIterMut",
            "header::map::Values",
            "header::map::ValuesMut"
        ],
        "std::marker::Copy": [
            "header::map::Cursor",
            "header::map::HashValue",
            "header::map::Link",
            "header::map::Links",
            "header::map::Pos",
            "header::map::RawLinks",
            "header::name::StandardHeader",
            "status::StatusCode",
            "uri::scheme::Protocol",
            "version::Http",
            "version::Version"
        ],
        "std::marker::Send": [
            "header::map::Drain",
            "header::map::Iter",
            "header::map::IterMut",
            "header::map::ValueDrain",
            "header::map::ValueIterMut"
        ],
        "std::marker::StructuralPartialEq": [
            "byte_str::ByteStr",
            "header::map::Cursor",
            "header::map::HashValue",
            "header::map::Link",
            "header::name::Custom",
            "header::name::HeaderName",
            "header::name::Repr",
            "header::name::StandardHeader",
            "method::Inner",
            "method::Method",
            "method::extension::AllocatedExtension",
            "method::extension::InlineExtension",
            "status::StatusCode",
            "uri::ErrorKind",
            "version::Http",
            "version::Version"
        ],
        "std::marker::Sync": [
            "header::map::Drain",
            "header::map::Iter",
            "header::map::IterMut",
            "header::map::ValueDrain",
            "header::map::ValueIterMut"
        ],
        "std::ops::Deref": [
            "byte_str::ByteStr"
        ],
        "std::ops::Drop": [
            "header::map::Drain",
            "header::map::IntoIter",
            "header::map::ValueDrain"
        ],
        "std::ops::Index": [
            "header::map::HeaderMap",
            "header::map::RawLinks"
        ],
        "std::ops::IndexMut": [
            "header::map::RawLinks"
        ],
        "std::str::FromStr": [
            "header::name::HeaderName",
            "header::value::HeaderValue",
            "method::Method",
            "status::StatusCode",
            "uri::Uri",
            "uri::authority::Authority",
            "uri::path::PathAndQuery",
            "uri::scheme::Scheme"
        ]
    },
    "type_to_def_path": {
        "byte_str::ByteStr": "byte_str::ByteStr",
        "error::Error": "error::Error",
        "error::ErrorKind": "error::ErrorKind",
        "extensions::Extensions": "extensions::Extensions",
        "extensions::IdHasher": "extensions::IdHasher",
        "header::map::Bucket<T>": "header::map::Bucket",
        "header::map::Cursor": "header::map::Cursor",
        "header::map::Danger": "header::map::Danger",
        "header::map::Drain<'a, T>": "header::map::Drain",
        "header::map::Entry<'a, T>": "header::map::Entry",
        "header::map::ExtraValue<T>": "header::map::ExtraValue",
        "header::map::GetAll<'a, T>": "header::map::GetAll",
        "header::map::HashValue": "header::map::HashValue",
        "header::map::HeaderMap<T>": "header::map::HeaderMap",
        "header::map::IntoIter<T>": "header::map::IntoIter",
        "header::map::Iter<'a, T>": "header::map::Iter",
        "header::map::IterMut<'a, T>": "header::map::IterMut",
        "header::map::Keys<'a, T>": "header::map::Keys",
        "header::map::Link": "header::map::Link",
        "header::map::Links": "header::map::Links",
        "header::map::MaxSizeReached": "header::map::MaxSizeReached",
        "header::map::OccupiedEntry<'a, T>": "header::map::OccupiedEntry",
        "header::map::Pos": "header::map::Pos",
        "header::map::RawLinks<T>": "header::map::RawLinks",
        "header::map::VacantEntry<'a, T>": "header::map::VacantEntry",
        "header::map::ValueDrain<'a, T>": "header::map::ValueDrain",
        "header::map::ValueIter<'a, T>": "header::map::ValueIter",
        "header::map::ValueIterMut<'a, T>": "header::map::ValueIterMut",
        "header::map::Values<'a, T>": "header::map::Values",
        "header::map::ValuesMut<'a, T>": "header::map::ValuesMut",
        "header::map::as_header_name::TryEntryError": "header::map::as_header_name::TryEntryError",
        "header::name::Custom": "header::name::Custom",
        "header::name::HdrName<'a>": "header::name::HdrName",
        "header::name::HeaderName": "header::name::HeaderName",
        "header::name::InvalidHeaderName": "header::name::InvalidHeaderName",
        "header::name::MaybeLower<'a>": "header::name::MaybeLower",
        "header::name::Repr<T>": "header::name::Repr",
        "header::name::StandardHeader": "header::name::StandardHeader",
        "header::value::HeaderValue": "header::value::HeaderValue",
        "header::value::InvalidHeaderValue": "header::value::InvalidHeaderValue",
        "header::value::ToStrError": "header::value::ToStrError",
        "method::Inner": "method::Inner",
        "method::InvalidMethod": "method::InvalidMethod",
        "method::Method": "method::Method",
        "method::extension::AllocatedExtension": "method::extension::AllocatedExtension",
        "method::extension::InlineExtension": "method::extension::InlineExtension",
        "request::Builder": "request::Builder",
        "request::Parts": "request::Parts",
        "request::Request<T>": "request::Request",
        "response::Builder": "response::Builder",
        "response::Parts": "response::Parts",
        "response::Response<T>": "response::Response",
        "status::InvalidStatusCode": "status::InvalidStatusCode",
        "status::StatusCode": "status::StatusCode",
        "uri::ErrorKind": "uri::ErrorKind",
        "uri::InvalidUri": "uri::InvalidUri",
        "uri::InvalidUriParts": "uri::InvalidUriParts",
        "uri::Parts": "uri::Parts",
        "uri::Uri": "uri::Uri",
        "uri::authority::Authority": "uri::authority::Authority",
        "uri::builder::Builder": "uri::builder::Builder",
        "uri::path::PathAndQuery": "uri::path::PathAndQuery",
        "uri::port::Port<T>": "uri::port::Port",
        "uri::scheme::Protocol": "uri::scheme::Protocol",
        "uri::scheme::Scheme": "uri::scheme::Scheme",
        "uri::scheme::Scheme2<T>": "uri::scheme::Scheme2",
        "version::Http": "version::Http",
        "version::Version": "version::Version"
    }
}