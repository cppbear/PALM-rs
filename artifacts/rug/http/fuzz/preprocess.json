{"dependencies":{"<HttpSpec as std::fmt::Debug>::fmt":["HttpSpec","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"HttpSpec":["HttpSpec","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"_::<impl arbitrary::Arbitrary<'arbitrary> for HttpSpec>::arbitrary":["arbitrary::Unstructured","std::marker::Sized","std::result::Result"],"_::<impl arbitrary::Arbitrary<'arbitrary> for HttpSpec>::arbitrary_take_rest":["arbitrary::Unstructured","std::marker::Sized","std::result::Result"],"_::<impl arbitrary::Arbitrary<'arbitrary> for HttpSpec>::size_hint":["std::marker::Sized","std::option::Option"],"_::<impl arbitrary::Arbitrary<'arbitrary> for HttpSpec>::try_size_hint":["std::marker::Sized","std::result::Result"],"_::LLVMFuzzerInitialize":[],"_::RECURSIVE_COUNT_HttpSpec::__init":["std::cell::Cell"],"_::__libfuzzer_sys_run":["HttpSpec","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"_::rust_fuzzer_test_input":[]},"glob_path_import":{},"self_to_fn":{"HttpSpec":["Arbitrary","Debug"]},"single_path_import":{},"srcs":{"HttpSpec":["struct HttpSpec {\n    uri: Vec<u8>,\n    header_name: Vec<u8>,\n    header_value: Vec<u8>,\n    status_codes: Vec<u8>,\n}","Real(LocalPath(\"src/fuzz_http.rs\"))"],"_::LLVMFuzzerInitialize":["/// Auto-generated functions\n/// LLVMFuzzerInitialize is called once before the fuzzer starts.\n#[no_mangle]\npub extern \"C\" fn LLVMFuzzerInitialize(_argc: *const isize, _argv: *const *const *const u8) -> isize{\n                $crate::initialize(_argc, _argv);\n\n                // Supplied init code\n                $init;\n                0\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.9/src/lib.rs\"))"],"_::RECURSIVE_COUNT_HttpSpec::__init":["#[inline]\nfn __init() -> $t{\n            $init\n        }","Real(Remapped { local_path: Some(\"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/native/mod.rs\"), virtual_name: \"/rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/sys/thread_local/native/mod.rs\" })"],"_::__libfuzzer_sys_run":["#[inline(never)]\nfn __libfuzzer_sys_run($data: $dty) -> $rty{\n                $body\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.9/src/lib.rs\"))"],"_::rust_fuzzer_test_input":["#[no_mangle]\npub extern \"C\" fn rust_fuzzer_test_input(bytes: &[u8]) -> i32{\n                use $crate::arbitrary::{Arbitrary, Unstructured};\n\n                // Early exit if we don't have enough bytes for the `Arbitrary`\n                // implementation. This helps the fuzzer avoid exploring all the\n                // different not-enough-input-bytes paths inside the `Arbitrary`\n                // implementation. Additionally, it exits faster, letting the fuzzer\n                // get to longer inputs that actually lead to interesting executions\n                // quicker.\n                if bytes.len() < <$dty as Arbitrary>::size_hint(0).0 {\n                    return -1;\n                }\n\n                let mut u = Unstructured::new(bytes);\n                let data = <$dty as Arbitrary>::arbitrary_take_rest(u);\n\n                // When `RUST_LIBFUZZER_DEBUG_PATH` is set, write the debug\n                // formatting of the input to that file. This is only intended for\n                // `cargo fuzz`'s use!\n\n                // `RUST_LIBFUZZER_DEBUG_PATH` is set in initialization.\n                if let Some(path) = $crate::rust_libfuzzer_debug_path() {\n                    use std::io::Write;\n                    let mut file = std::fs::File::create(path)\n                        .expect(\"failed to create `RUST_LIBFUZZER_DEBUG_PATH` file\");\n                    (match data {\n                        Ok(data) => writeln!(&mut file, \"{:#?}\", data),\n                        Err(err) => writeln!(&mut file, \"Arbitrary Error: {}\", err),\n                    })\n                    .expect(\"failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file\");\n                    return -1;\n                }\n\n                let data = match data {\n                    Ok(d) => d,\n                    Err(_) => return -1,\n                };\n\n                let result = ::libfuzzer_sys::Corpus::from(__libfuzzer_sys_run(data));\n                result.to_libfuzzer_code()\n            }","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.9/src/lib.rs\"))"]},"struct_constructor":{"(usize, std::option::Option<usize>)":["size_hint","try_size_hint"],"HttpSpec":["arbitrary","arbitrary_take_rest"],"i32":["rust_fuzzer_test_input"],"isize":["LLVMFuzzerInitialize"],"std::cell::Cell":["__init"]},"struct_to_trait":{"HttpSpec":["arbitrary::Arbitrary","std::fmt::Debug"]},"targets":{"_::LLVMFuzzerInitialize":["LLVMFuzzerInitialize","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.9/src/lib.rs\"))",""],"_::RECURSIVE_COUNT_HttpSpec::__init":["__init","Real(Remapped { local_path: Some(\"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/native/mod.rs\"), virtual_name: \"/rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/sys/thread_local/native/mod.rs\" })",""],"_::__libfuzzer_sys_run":["__libfuzzer_sys_run","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.9/src/lib.rs\"))",""],"_::rust_fuzzer_test_input":["rust_fuzzer_test_input","Real(LocalPath(\"/home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.9/src/lib.rs\"))",""]},"trait_to_struct":{"arbitrary::Arbitrary":["HttpSpec"],"std::fmt::Debug":["HttpSpec"]},"type_to_def_path":{"HttpSpec":"HttpSpec"}}