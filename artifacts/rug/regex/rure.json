{"dependencies":{"<error::Error as std::fmt::Debug>::fmt":["error::Error","error::ErrorKind","regex::Error","std::ffi::NulError","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::str::Utf8Error"],"<error::Error as std::fmt::Display>::fmt":["error::Error","error::ErrorKind","regex::Error","std::ffi::NulError","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::str::Utf8Error"],"<error::ErrorKind as std::fmt::Debug>::fmt":["error::ErrorKind","regex::Error","std::ffi::NulError","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::str::Utf8Error"],"<rure::Options as std::default::Default>::default":["rure::Options"],"<rure::Regex as std::ops::Deref>::deref":["regex::bytes::Regex","rure::Regex","std::collections::HashMap","std::marker::Sized"],"<rure::RegexSet as std::ops::Deref>::deref":["regex::bytes::RegexSet","rure::RegexSet"],"error::Error":["error::Error","error::ErrorKind","regex::Error","std::ffi::NulError","std::marker::Sized","std::option::Option","std::str::Utf8Error"],"error::Error::is_err":["error::Error","error::ErrorKind","regex::Error","std::ffi::NulError","std::marker::Sized","std::option::Option","std::str::Utf8Error"],"error::Error::new":["error::Error","error::ErrorKind","regex::Error","std::ffi::NulError","std::marker::Sized","std::option::Option","std::str::Utf8Error"],"error::ErrorKind":["error::ErrorKind","regex::Error","std::ffi::NulError","std::str::Utf8Error"],"error::rure_error_free":["error::Error","error::ErrorKind","regex::Error","std::ffi::NulError","std::marker::Sized","std::option::Option","std::str::Utf8Error"],"error::rure_error_message":["error::Error","error::ErrorKind","regex::Error","std::ffi::NulError","std::marker::Sized","std::option::Option","std::str::Utf8Error"],"error::rure_error_new":["error::Error","error::ErrorKind","regex::Error","std::ffi::NulError","std::marker::Sized","std::option::Option","std::str::Utf8Error"],"rure::Captures":["regex::bytes::CaptureLocations","rure::Captures"],"rure::Iter":["regex::bytes::Regex","rure::Iter","rure::Regex","std::collections::HashMap","std::marker::Sized","std::option::Option"],"rure::IterCaptureNames":["regex::bytes::CaptureNames","rure::IterCaptureNames","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"rure::Options":["rure::Options"],"rure::Regex":["regex::bytes::Regex","rure::Regex","std::collections::HashMap","std::marker::Sized"],"rure::RegexSet":["regex::bytes::RegexSet","rure::RegexSet"],"rure::rure_capture_name_index":["regex::bytes::Regex","rure::Regex","std::collections::HashMap","std::marker::Sized"],"rure::rure_captures_at":["regex::bytes::CaptureLocations","rure::Captures","rure::rure_match"],"rure::rure_captures_free":["regex::bytes::CaptureLocations","rure::Captures"],"rure::rure_captures_len":["regex::bytes::CaptureLocations","rure::Captures"],"rure::rure_captures_new":["regex::bytes::CaptureLocations","regex::bytes::Regex","rure::Captures","rure::Regex","std::collections::HashMap","std::marker::Sized"],"rure::rure_compile":["error::Error","error::ErrorKind","regex::Error","regex::bytes::Regex","rure::Options","rure::Regex","std::collections::HashMap","std::ffi::NulError","std::marker::Sized","std::option::Option","std::str::Utf8Error"],"rure::rure_compile_must":["regex::bytes::Regex","rure::Regex","std::collections::HashMap","std::marker::Sized"],"rure::rure_compile_set":["error::Error","error::ErrorKind","regex::Error","regex::bytes::RegexSet","rure::Options","rure::RegexSet","std::ffi::NulError","std::marker::Sized","std::option::Option","std::str::Utf8Error"],"rure::rure_cstring_free":[],"rure::rure_escape":["error::Error","error::ErrorKind","regex::Error","std::ffi::NulError","std::marker::Sized","std::option::Option","std::str::Utf8Error"],"rure::rure_escape_must":[],"rure::rure_find":["regex::bytes::Regex","rure::Regex","rure::rure_match","std::collections::HashMap","std::marker::Sized"],"rure::rure_find_captures":["regex::bytes::CaptureLocations","regex::bytes::Regex","rure::Captures","rure::Regex","std::collections::HashMap","std::marker::Sized"],"rure::rure_free":["regex::bytes::Regex","rure::Regex","std::collections::HashMap","std::marker::Sized"],"rure::rure_is_match":["regex::bytes::Regex","rure::Regex","std::collections::HashMap","std::marker::Sized"],"rure::rure_iter_capture_names_free":["regex::bytes::CaptureNames","rure::IterCaptureNames","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"rure::rure_iter_capture_names_new":["regex::bytes::CaptureNames","regex::bytes::Regex","rure::IterCaptureNames","rure::Regex","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"rure::rure_iter_capture_names_next":["regex::bytes::CaptureNames","rure::IterCaptureNames","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"rure::rure_iter_free":["regex::bytes::Regex","rure::Iter","rure::Regex","std::collections::HashMap","std::marker::Sized","std::option::Option"],"rure::rure_iter_new":["regex::bytes::Regex","rure::Iter","rure::Regex","std::collections::HashMap","std::marker::Sized","std::option::Option"],"rure::rure_iter_next":["regex::bytes::Regex","rure::Iter","rure::Regex","rure::rure_match","std::collections::HashMap","std::marker::Sized","std::option::Option"],"rure::rure_iter_next_captures":["regex::bytes::CaptureLocations","regex::bytes::Regex","rure::Captures","rure::Iter","rure::Regex","std::collections::HashMap","std::marker::Sized","std::option::Option"],"rure::rure_match":["rure::rure_match"],"rure::rure_options_dfa_size_limit":["rure::Options"],"rure::rure_options_free":["rure::Options"],"rure::rure_options_new":["rure::Options"],"rure::rure_options_size_limit":["rure::Options"],"rure::rure_set_free":["regex::bytes::RegexSet","rure::RegexSet"],"rure::rure_set_is_match":["regex::bytes::RegexSet","rure::RegexSet"],"rure::rure_set_len":["regex::bytes::RegexSet","rure::RegexSet"],"rure::rure_set_matches":["regex::bytes::RegexSet","rure::RegexSet"],"rure::rure_shortest_match":["regex::bytes::Regex","rure::Regex","std::collections::HashMap","std::marker::Sized"]},"glob_path_import":{"error":"","rure":""},"self_to_fn":{"error::Error":["Debug","impl Error {\n    pub fn new(kind: ErrorKind) -> Error {\n        Error { message: None, kind: kind }\n    }\n\n    pub fn is_err(&self) -> bool {\n        match self.kind {\n            ErrorKind::None => false,\n            ErrorKind::Str(_) | ErrorKind::Regex(_) | ErrorKind::Nul(_) => {\n                true\n            }\n        }\n    }\n}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.kind {\n            ErrorKind::None => write!(f, \"no error\"),\n            ErrorKind::Str(ref e) => e.fmt(f),\n            ErrorKind::Regex(ref e) => e.fmt(f),\n            ErrorKind::Nul(ref e) => e.fmt(f),\n        }\n    }\n}"],"error::ErrorKind":["Debug"],"rure::Options":["impl Default for Options {\n    fn default() -> Options {\n        Options { size_limit: 10 * (1 << 20), dfa_size_limit: 2 * (1 << 20) }\n    }\n}"],"rure::Regex":["impl Deref for Regex {\n    type Target = bytes::Regex;\n    fn deref(&self) -> &bytes::Regex {\n        &self.re\n    }\n}"],"rure::RegexSet":["impl Deref for RegexSet {\n    type Target = bytes::RegexSet;\n    fn deref(&self) -> &bytes::RegexSet {\n        &self.re\n    }\n}"]},"single_path_import":{},"srcs":{"<error::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match self.kind {\n            ErrorKind::None => write!(f, \"no error\"),\n            ErrorKind::Str(ref e) => e.fmt(f),\n            ErrorKind::Regex(ref e) => e.fmt(f),\n            ErrorKind::Nul(ref e) => e.fmt(f),\n        }\n    }","Real(LocalPath(\"regex-capi/src/error.rs\"))"],"<rure::Options as std::default::Default>::default":["fn default() -> Options{\n        Options { size_limit: 10 * (1 << 20), dfa_size_limit: 2 * (1 << 20) }\n    }","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"<rure::Regex as std::ops::Deref>::deref":["fn deref(&self) -> &bytes::Regex{\n        &self.re\n    }","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"<rure::RegexSet as std::ops::Deref>::deref":["fn deref(&self) -> &bytes::RegexSet{\n        &self.re\n    }","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"error::Error":["pub struct Error {\n    message: Option<CString>,\n    kind: ErrorKind,\n}","Real(LocalPath(\"regex-capi/src/error.rs\"))"],"error::Error::is_err":["pub fn is_err(&self) -> bool{\n        match self.kind {\n            ErrorKind::None => false,\n            ErrorKind::Str(_) | ErrorKind::Regex(_) | ErrorKind::Nul(_) => {\n                true\n            }\n        }\n    }","Real(LocalPath(\"regex-capi/src/error.rs\"))"],"error::Error::new":["pub fn new(kind: ErrorKind) -> Error{\n        Error { message: None, kind: kind }\n    }","Real(LocalPath(\"regex-capi/src/error.rs\"))"],"error::ErrorKind":["pub enum ErrorKind {\n    None,\n    Str(str::Utf8Error),\n    Regex(regex::Error),\n    Nul(ffi::NulError),\n}","Real(LocalPath(\"regex-capi/src/error.rs\"))"],"error::rure_error_free":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"error::rure_error_message":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"error::rure_error_new":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::Captures":["pub struct Captures(bytes::Locations);","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"rure::Iter":["pub struct Iter {\n    re: *const Regex,\n    last_end: usize,\n    last_match: Option<usize>,\n}","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"rure::IterCaptureNames":["pub struct IterCaptureNames {\n    capture_names: bytes::CaptureNames<'static>,\n    name_ptrs: Vec<*mut c_char>,\n}","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"rure::Options":["pub struct Options {\n    size_limit: usize,\n    dfa_size_limit: usize,\n}","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"rure::Regex":["pub struct Regex {\n    re: bytes::Regex,\n    capture_names: HashMap<String, i32>,\n}","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"rure::RegexSet":["pub struct RegexSet {\n    re: bytes::RegexSet,\n}","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"rure::rure_capture_name_index":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_captures_at":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_captures_free":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_captures_len":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_captures_new":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_compile":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_compile_must":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_compile_set":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_cstring_free":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_escape":["/// A helper function that implements fallible escaping in a way that returns\n/// an error if escaping failed.\n///\n/// This should ideally be exposed, but it needs API design work. In\n/// particular, this should not return a C string, but a `const uint8_t *`\n/// instead, since it may contain a NUL byte.\nfn rure_escape(\n    pattern: *const u8,\n    length: size_t,\n    error: *mut Error,\n) -> *const c_char{\n    let pat: &[u8] = unsafe { slice::from_raw_parts(pattern, length) };\n    let str_pat = match str::from_utf8(pat) {\n        Ok(val) => val,\n        Err(err) => unsafe {\n            if !error.is_null() {\n                *error = Error::new(ErrorKind::Str(err));\n            }\n            return ptr::null();\n        },\n    };\n    let esc_pat = regex::escape(str_pat);\n    let c_esc_pat = match CString::new(esc_pat) {\n        Ok(val) => val,\n        Err(err) => unsafe {\n            if !error.is_null() {\n                *error = Error::new(ErrorKind::Nul(err));\n            }\n            return ptr::null();\n        },\n    };\n    c_esc_pat.into_raw() as *const c_char\n}","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"rure::rure_escape_must":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_find":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_find_captures":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_free":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_is_match":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_iter_capture_names_free":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_iter_capture_names_new":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_iter_capture_names_next":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_iter_free":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_iter_new":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_iter_next":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_iter_next_captures":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_match":["#[repr(C)]\npub struct rure_match {\n    pub start: size_t,\n    pub end: size_t,\n}","Real(LocalPath(\"regex-capi/src/rure.rs\"))"],"rure::rure_options_dfa_size_limit":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_options_free":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_options_new":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_options_size_limit":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_set_free":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_set_is_match":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_set_len":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_set_matches":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"],"rure::rure_shortest_match":["#[no_mangle]\npub extern fn $name($($arg: $arg_ty),*) -> $ret{\n            use ::std::io::{self, Write};\n            use ::std::panic::{self, AssertUnwindSafe};\n            use ::libc::abort;\n            match panic::catch_unwind(AssertUnwindSafe(move || $body)) {\n                Ok(v) => v,\n                Err(err) => {\n                    let msg = if let Some(&s) = err.downcast_ref::<&str>() {\n                        s.to_owned()\n                    } else if let Some(s) = err.downcast_ref::<String>() {\n                        s.to_owned()\n                    } else {\n                        \"UNABLE TO SHOW RESULT OF PANIC.\".to_owned()\n                    };\n                    let _ = writeln!(\n                        &mut io::stderr(),\n                        \"panic unwind caught, aborting: {:?}\",\n                        msg);\n                    unsafe { abort() }\n                }\n            }\n        }","Real(LocalPath(\"regex-capi/src/macros.rs\"))"]},"struct_constructor":{"&'^0.Named(DefId(0:394 ~ rure[9b14]::rure::{impl#0}::deref::'_), \"'_\") regex::bytes::Regex":["deref"],"&'^0.Named(DefId(0:395 ~ rure[9b14]::rure::{impl#1}::deref::'_), \"'_\") regex::bytes::RegexSet":["deref"],"*const i8":["rure_error_message","rure_escape"],"*const rure::Regex":["rure_compile","rure_compile_must"],"*const rure::RegexSet":["rure_compile_set"],"*mut error::Error":["rure_error_new"],"*mut rure::Captures":["rure_captures_new"],"*mut rure::Iter":["rure_iter_new"],"*mut rure::IterCaptureNames":["rure_iter_capture_names_new"],"*mut rure::Options":["rure_options_new"],"bool":["is_err","rure_captures_at","rure_find","rure_find_captures","rure_is_match","rure_iter_capture_names_next","rure_iter_next","rure_iter_next_captures","rure_set_is_match","rure_set_matches","rure_shortest_match"],"error::Error":["new"],"i32":["rure_capture_name_index"],"rure::Options":["default"],"usize":["rure_captures_len","rure_set_len"]},"struct_to_trait":{"error::Error":["std::fmt::Debug","std::fmt::Display"],"error::ErrorKind":["std::fmt::Debug"],"rure::Options":["std::default::Default"],"rure::Regex":["std::ops::Deref"],"rure::RegexSet":["std::ops::Deref"]},"targets":{"<error::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"regex-capi/src/error.rs\"))","std::fmt::Display"],"<rure::Options as std::default::Default>::default":["default","Real(LocalPath(\"regex-capi/src/rure.rs\"))","std::default::Default"],"<rure::Regex as std::ops::Deref>::deref":["deref","Real(LocalPath(\"regex-capi/src/rure.rs\"))","std::ops::Deref"],"<rure::RegexSet as std::ops::Deref>::deref":["deref","Real(LocalPath(\"regex-capi/src/rure.rs\"))","std::ops::Deref"],"error::Error::is_err":["is_err","Real(LocalPath(\"regex-capi/src/error.rs\"))",""],"error::Error::new":["new","Real(LocalPath(\"regex-capi/src/error.rs\"))",""],"error::rure_error_free":["rure_error_free","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"error::rure_error_message":["rure_error_message","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"error::rure_error_new":["rure_error_new","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_capture_name_index":["rure_capture_name_index","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_captures_at":["rure_captures_at","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_captures_free":["rure_captures_free","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_captures_len":["rure_captures_len","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_captures_new":["rure_captures_new","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_compile":["rure_compile","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_compile_must":["rure_compile_must","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_compile_set":["rure_compile_set","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_cstring_free":["rure_cstring_free","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_escape":["rure_escape","Real(LocalPath(\"regex-capi/src/rure.rs\"))",""],"rure::rure_escape_must":["rure_escape_must","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_find":["rure_find","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_find_captures":["rure_find_captures","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_free":["rure_free","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_is_match":["rure_is_match","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_iter_capture_names_free":["rure_iter_capture_names_free","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_iter_capture_names_new":["rure_iter_capture_names_new","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_iter_capture_names_next":["rure_iter_capture_names_next","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_iter_free":["rure_iter_free","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_iter_new":["rure_iter_new","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_iter_next":["rure_iter_next","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_iter_next_captures":["rure_iter_next_captures","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_options_dfa_size_limit":["rure_options_dfa_size_limit","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_options_free":["rure_options_free","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_options_new":["rure_options_new","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_options_size_limit":["rure_options_size_limit","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_set_free":["rure_set_free","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_set_is_match":["rure_set_is_match","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_set_len":["rure_set_len","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_set_matches":["rure_set_matches","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""],"rure::rure_shortest_match":["rure_shortest_match","Real(LocalPath(\"regex-capi/src/macros.rs\"))",""]},"trait_to_struct":{"std::default::Default":["rure::Options"],"std::fmt::Debug":["error::Error","error::ErrorKind"],"std::fmt::Display":["error::Error"],"std::ops::Deref":["rure::Regex","rure::RegexSet"]},"type_to_def_path":{"error::Error":"error::Error","error::ErrorKind":"error::ErrorKind","rure::Captures":"rure::Captures","rure::Iter":"rure::Iter","rure::IterCaptureNames":"rure::IterCaptureNames","rure::Options":"rure::Options","rure::Regex":"rure::Regex","rure::RegexSet":"rure::RegexSet","rure::rure_match":"rure::rure_match"}}